   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** //uint16_t lineCount = 0; //res test
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 141:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 145:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 146:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 147:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 148:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 149:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 150:../uvc.c      ****                                    with adjustable compression parameters */
 151:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 152:../uvc.c      ****                                    streaming with adjustable compression parameters */
 153:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 154:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 155:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 156:../uvc.c      **** };
 157:../uvc.c      **** 
 158:../uvc.c      **** 
 159:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 160:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 161:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 162:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 163:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 164:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 170:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 171:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 174:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 175:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 176:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 177:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 178:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 179:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 180:../uvc.c      ****                                    with adjustable compression parameters */
 181:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 182:../uvc.c      ****                                    streaming with adjustable compression parameters */
 183:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 184:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 185:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 186:../uvc.c      **** };
 187:../uvc.c      **** 
 188:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 189:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 190:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 191:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 192:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 193:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 194:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 195:../uvc.c      **** };
 196:../uvc.c      **** 
 197:../uvc.c      **** 
 198:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 199:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 200:../uvc.c      **** 
 201:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 202:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 203:../uvc.c      **** {
 204:../uvc.c      ****     0x0C,                               /* Header Length */
 205:../uvc.c      ****     0x8C,                               /* Bit field header field */
 206:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 208:../uvc.c      **** };
 209:../uvc.c      **** 
 210:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 211:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 212:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 213:../uvc.c      ****                                                            the current video frame. */
 214:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 215:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 216:../uvc.c      **** 
 217:../uvc.c      **** #define isWBMamu   0  // Is white balance control manual mode.
 218:../uvc.c      **** 
 219:../uvc.c      **** /************ control parameters array ***********
 220:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 221:../uvc.c      ****  *    e.g.
 222:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 223:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 224:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 225:../uvc.c      ****  **************************************************/
 226:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 227:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 228:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 229:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 230:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 231:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 232:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 233:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 234:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 235:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 236:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 237:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 239:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 240:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 241:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 247:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 248:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 250:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 251:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 253:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 254:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 255:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 256:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 257:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 258:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 259:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		/**********************************
 261:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 262:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 263:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 264:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 265:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 266:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 267:../uvc.c      **** 		 *
 268:../uvc.c      **** 		 *********************************/
 269:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 270:../uvc.c      **** };
 271:../uvc.c      **** 
 272:../uvc.c      **** #ifndef CAM720
 273:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 274:../uvc.c      **** #else
 275:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 276:../uvc.c      **** #endif
 277:../uvc.c      **** 
 278:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 279:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 280:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 281:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 282:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 283:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 284:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 285:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 286:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 287:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 288:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 289:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 290:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 291:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 295:../uvc.c      **** };
 296:../uvc.c      **** 
 297:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 298:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 299:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 300:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 301:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 302:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 304:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 306:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 307:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 308:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 309:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 310:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 311:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 312:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 313:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 314:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 315:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 318:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 319:../uvc.c      **** /*
 320:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 321:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 322:../uvc.c      ****  */
 323:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 324:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 325:../uvc.c      **** };
 326:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 327:../uvc.c      **** 		0
 328:../uvc.c      **** };
 329:../uvc.c      **** 
 330:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 331:../uvc.c      **** 
 332:../uvc.c      **** void I2CCmdHandler(){
 333:../uvc.c      **** 	uint8_t buf[2];
 334:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 336:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 337:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 338:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 339:../uvc.c      **** 	uint8_t i;
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 341:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 342:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 343:../uvc.c      **** 
 344:../uvc.c      **** 	if(CmdType == 0)//I2C read
 345:../uvc.c      **** 	{
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 347:../uvc.c      **** #if 0 //for debugging
 348:../uvc.c      **** 		/* test still image operation */
 349:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 350:../uvc.c      **** 			snapButFlag = 0; //press
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 353:../uvc.c      **** 			snapButFlag = 0xf; //release
 354:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 355:../uvc.c      **** 		}
 356:../uvc.c      **** 
 357:../uvc.c      **** 		/* end of the test */
 358:../uvc.c      **** #endif
 359:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 361:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 362:../uvc.c      **** 			}
 363:../uvc.c      **** 			else{
 364:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 366:../uvc.c      **** 				if(CmdDataLen == 2){
 367:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 368:../uvc.c      **** 				}
 369:../uvc.c      **** 			}
 370:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 371:../uvc.c      **** 		}else{//not support currently
 372:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 373:../uvc.c      **** 		}
 374:../uvc.c      **** 	}else if(CmdType == 1){
 375:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 376:../uvc.c      **** 			if(CmdRegLen == 2){
 377:../uvc.c      **** 				for(i = 0; i<4; i++)
 378:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 379:../uvc.c      **** 			}
 380:../uvc.c      **** 			else{
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 382:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 383:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 385:../uvc.c      **** 				}
 386:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 387:../uvc.c      **** 			}
 388:../uvc.c      **** 		}else{//not support currently
 389:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 390:../uvc.c      **** 		}
 391:../uvc.c      **** 
 392:../uvc.c      **** 	}
 393:../uvc.c      **** }
 394:../uvc.c      **** 
 395:../uvc.c      **** /************************************
 396:../uvc.c      ****  * set Iris mode
 397:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 398:../uvc.c      ****  */
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 400:../uvc.c      **** 	uint8_t dataIdx;
 401:../uvc.c      **** 	  dataIdx = 0;
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 406:../uvc.c      **** }
 407:../uvc.c      **** 
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 409:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 410:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 411:../uvc.c      ****     uint16_t readCount;
 412:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 413:../uvc.c      ****     uint8_t devAdd;
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 417:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 418:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 419:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 420:../uvc.c      ****     }else{
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 422:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 423:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 424:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 425:../uvc.c      ****     }
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 427:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 428:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 429:../uvc.c      **** #endif
 430:../uvc.c      ****     reqData = bRequest;
 431:../uvc.c      ****     /*
 432:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 433:../uvc.c      ****      */
 434:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 435:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 436:../uvc.c      ****     	goto EndofSet;
 437:../uvc.c      ****     }
 438:../uvc.c      ****     switch (bRequest)
 439:../uvc.c      **** 		 {
 440:../uvc.c      **** 
 441:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 443:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 445:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 446:../uvc.c      **** 			  break;
 447:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 448:../uvc.c      **** 
 449:../uvc.c      **** 			 switch(CtrlID)
 450:../uvc.c      **** 			 {
 451:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 452:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 453:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 454:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 457:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 458:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 459:../uvc.c      **** 			 	 		 break;
 460:../uvc.c      **** 			 	 }
 461:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 462:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 464:../uvc.c      **** 						if(sendData >= 3){
 465:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 466:../uvc.c      **** 							sendData = 0; //set back to default
 467:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 468:../uvc.c      **** 						}
 469:../uvc.c      **** 						sendData += 4;
 470:../uvc.c      **** 					 }
 471:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 472:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 474:../uvc.c      **** 					 break;
 475:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 478:../uvc.c      **** 			 		 }
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 480:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 481:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 482:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 483:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 484:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 485:../uvc.c      **** #endif
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 487:../uvc.c      **** 			 		 {
 488:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 489:../uvc.c      **** 			 		 }
 490:../uvc.c      **** 			 		 break;
 491:../uvc.c      **** 				 case ExtAexModCtlID9:
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 495:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 496:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 497:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 498:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 499:../uvc.c      **** 					 break;
 500:../uvc.c      **** 
 501:../uvc.c      **** 			 	 case BrgtCtlID1:
 502:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 503:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 504:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 505:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 506:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 507:../uvc.c      **** 					 }else{
 508:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 509:../uvc.c      **** 					 }
 510:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 511:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 512:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 513:../uvc.c      **** 					 */
 514:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 515:../uvc.c      **** 					  if(Data0&0x80){
 516:../uvc.c      **** 						  Data0 = ~Data0;
 517:../uvc.c      **** 					  }else{
 518:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 519:../uvc.c      **** 					  }
 520:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 522:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 523:../uvc.c      **** 			 		 break;
 524:../uvc.c      **** 				 case HueCtlID5:
 525:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 526:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 527:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 528:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 529:../uvc.c      **** 					 break;
 530:../uvc.c      **** 				 case WBTLevCtlID11:
 531:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 533:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 534:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 535:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 536:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 537:../uvc.c      **** 					 break;
 538:../uvc.c      **** 				 case SaturCtlID6:
 539:../uvc.c      **** 				 default:
 540:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 542:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 543:../uvc.c      **** 					 break;
 544:../uvc.c      **** 			 }
 545:../uvc.c      **** 
 546:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 547:../uvc.c      **** 
 548:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 549:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 550:../uvc.c      **** #endif
 551:../uvc.c      **** 			  break;
 552:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 553:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 554:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 555:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 556:../uvc.c      **** 		 	 }
 557:../uvc.c      **** 
 558:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 559:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 560:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 561:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 562:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 563:../uvc.c      **** 			 }else
 564:../uvc.c      **** 			 {
 565:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 566:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 567:../uvc.c      **** 			 }
 568:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 569:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 570:../uvc.c      **** 			  break;
 571:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 572:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 573:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 574:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 575:../uvc.c      **** 		 	 }
 576:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 577:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 578:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 579:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 580:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 581:../uvc.c      **** 			 }else
 582:../uvc.c      **** 			 {
 583:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 584:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 585:../uvc.c      **** 			 }
 586:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 587:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 588:../uvc.c      **** 			  break;
 589:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 590:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 591:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 592:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 593:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 594:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 595:../uvc.c      **** 		 	 }
 596:../uvc.c      **** 		 	 else{
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 599:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 600:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 601:../uvc.c      **** 		 	 }
 602:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 603:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 604:../uvc.c      **** 			  break;
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 606:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 608:../uvc.c      **** 		 	 }
 609:../uvc.c      **** 		 	 else{
 610:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 611:../uvc.c      **** 		 	 }
 612:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 613:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 614:../uvc.c      **** 			  Len = 1;
 615:../uvc.c      **** 			  break;
 616:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 617:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 618:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 620:../uvc.c      **** 		 	 }
 621:../uvc.c      **** 
 622:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 623:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 624:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 625:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 626:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 627:../uvc.c      **** 			 }else{
 628:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 629:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 630:../uvc.c      **** 			 }
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 632:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 633:../uvc.c      **** 			  break;
 634:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 635:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 636:../uvc.c      **** 				  glEp0Buffer, &readCount);
 637:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 638:../uvc.c      **** 			   {
 639:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 640:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 641:../uvc.c      **** 				  getData = glEp0Buffer[0];
 642:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 643:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 644:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 645:../uvc.c      **** #endif
 646:../uvc.c      **** 				  switch(CtrlID)
 647:../uvc.c      **** 					 {
 648:../uvc.c      **** 						 case ExtShutCtlID0:
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 650:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 651:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 652:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 653:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 654:../uvc.c      **** 									 }else{
 655:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 656:../uvc.c      **** 									 }
 657:../uvc.c      **** 								 }
 658:../uvc.c      **** 							 }else{
 659:../uvc.c      **** 								 Data1 = Data0 - 1;
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 661:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 662:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 663:../uvc.c      **** 									 }else{
 664:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 665:../uvc.c      **** 									 }
 666:../uvc.c      **** 								 }
 667:../uvc.c      **** 								 if(Data1 < 8){
 668:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 669:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 670:../uvc.c      **** 								 }else{
 671:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 672:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 673:../uvc.c      **** 								 }
 674:../uvc.c      **** 							 }
 675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 676:../uvc.c      **** 							 dataIdx = 0;
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 680:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 681:../uvc.c      **** 							 break;
 682:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 683:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 685:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 686:../uvc.c      **** 							 dataIdx = 0;
 687:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 688:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 689:../uvc.c      **** 							 if(getData != 0){
 690:../uvc.c      **** 								 dataIdx++;
 691:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 692:../uvc.c      **** 							 }
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 695:../uvc.c      **** 							 break;
 696:../uvc.c      **** 						 case ExtCamMCtlID12:
 697:../uvc.c      **** 							 dataIdx = 0;
 698:../uvc.c      **** 							 if(Data0 <= 3){
 699:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 700:../uvc.c      **** 								 Data1 = Data0;
 701:../uvc.c      **** 							 }else{
 702:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 703:../uvc.c      **** 								 Data1 = Data0-4;
 704:../uvc.c      **** 							 }
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 706:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 708:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 709:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 710:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 711:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 712:../uvc.c      **** 							 break;
 713:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 714:../uvc.c      **** 							 dataIdx = 0;
 715:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 716:../uvc.c      **** 								 Data0 = 1;
 717:../uvc.c      **** 							 }else{ //save current sensor parameters.
 718:../uvc.c      **** 								 Data0 = 0;
 719:../uvc.c      **** 							 }
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 721:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 723:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 724:../uvc.c      **** 							 break;
 725:../uvc.c      **** 						 case ExtI2CCtlID15:
 726:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 727:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 728:../uvc.c      **** 					 		 }
 729:../uvc.c      **** 					 		I2CCmdHandler();
 730:../uvc.c      **** 							 break;
 731:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 732:../uvc.c      **** 							 dataIdx = 0;
 733:../uvc.c      **** #if 0 //seperate version
 734:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 735:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 736:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 737:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 738:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 739:../uvc.c      **** 							 }else{ //disable BLD window
 740:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 741:../uvc.c      **** 							 }
 742:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 743:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 744:../uvc.c      **** 							 dataIdx++;
 745:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 746:../uvc.c      **** 							 dataIdx++;
 747:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 748:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 749:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 750:../uvc.c      **** 							 dataIdx++;
 751:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 752:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 753:../uvc.c      **** #else //combination version
 754:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 755:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 756:../uvc.c      **** 						     /* end test */
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 758:../uvc.c      **** 							 dataIdx++;
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 760:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 761:../uvc.c      **** 							 getData1 = Data1;
 762:../uvc.c      **** #endif
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 766:../uvc.c      **** 							 break;
 767:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 768:../uvc.c      **** 							 dataIdx = 0;
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 771:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 772:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 773:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 774:../uvc.c      **** 							 break;
 775:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 776:../uvc.c      **** 							 dataIdx = 0;
 777:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 779:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 780:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 781:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 782:../uvc.c      **** 							 break;
 783:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 784:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
 785:../uvc.c      **** 							 dataIdx = 0;
 786:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 787:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 788:../uvc.c      **** 							  if(Data0&0x80){
 789:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 790:../uvc.c      **** 							  }else{
 791:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 792:../uvc.c      **** 							  }
 793:../uvc.c      **** 							 Data1 |= ~0x03;
 794:../uvc.c      **** 							 Data1 &= 0xC7;
 795:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 796:../uvc.c      **** 						  	 dataIdx++;
 797:../uvc.c      **** 
 798:../uvc.c      **** 							 Data0 = (Data0 << 2);
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 800:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 801:../uvc.c      **** 
 802:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 803:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 804:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 805:../uvc.c      **** #endif
 806:../uvc.c      **** 							 dataIdx = 0;
 807:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 808:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 809:../uvc.c      **** 							  if(Data0&0x80){
 810:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 811:../uvc.c      **** 							  }else{
 812:../uvc.c      **** 								  Data0 = ~Data0;
 813:../uvc.c      **** 							  }
 814:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 816:../uvc.c      **** 
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 819:../uvc.c      **** 
 820:../uvc.c      **** 
 821:../uvc.c      **** 							 break;
 822:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 823:../uvc.c      **** 							 dataIdx = 0;
 824:../uvc.c      **** 
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 827:../uvc.c      **** 							 dataIdx++;
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 829:../uvc.c      **** 							 dataIdx++;
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 831:../uvc.c      **** 							 dataIdx++;
 832:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 833:../uvc.c      **** 							 dataIdx++;
 834:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 835:../uvc.c      **** 							 dataIdx++;
 836:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 837:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 838:../uvc.c      **** 
 839:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 841:../uvc.c      **** 							 break;
 842:../uvc.c      **** 						 case SaturCtlID6:
 843:../uvc.c      **** 							 dataIdx = 0;
 844:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 847:../uvc.c      **** 							 dataIdx++;
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 852:../uvc.c      **** 							 break;
 853:../uvc.c      **** 
 854:../uvc.c      **** 						 case WBTLevCtlID11:
 855:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 856:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 857:../uvc.c      **** 							 dataIdx = 0;
 858:../uvc.c      **** 
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 864:../uvc.c      **** 
 865:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 866:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 868:../uvc.c      **** 							 break;
 869:../uvc.c      **** 						 case MFreqCtlID4:
 870:../uvc.c      **** 							 dataIdx = 0;
 871:../uvc.c      **** 							 Data0 = Data0 - 1;
 872:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 873:../uvc.c      **** 								 Data0 = 0;
 874:../uvc.c      **** 							 else if(Data0 >2)
 875:../uvc.c      **** 								 Data0 = 1;
 876:../uvc.c      **** 
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 878:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 880:../uvc.c      **** 
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 883:../uvc.c      **** 							 break;
 884:../uvc.c      **** 					 	 case BLCCtlID0:
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 887:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 888:../uvc.c      **** 							 {
 889:../uvc.c      **** 								 if(Data0 < 3){
 890:../uvc.c      **** 					 				 Data0 += 4;
 891:../uvc.c      **** 					 			 }else{
 892:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 893:../uvc.c      **** 									Data0 = 4; //set to default.
 894:../uvc.c      **** 					 			 }
 895:../uvc.c      **** 					 		 }
 896:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 897:../uvc.c      **** 							 dataIdx = 0;
 898:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 899:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 901:../uvc.c      **** 
 902:../uvc.c      **** 					 		 break;
 903:../uvc.c      **** 						 default:
 904:../uvc.c      **** 							 dataIdx = 0;
 905:../uvc.c      **** 
 906:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 907:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 909:../uvc.c      **** 
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 912:../uvc.c      **** 							 break;
 913:../uvc.c      **** 					 }
 914:../uvc.c      **** 			   }else{
 915:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 916:../uvc.c      **** 			   }
 917:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 918:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 919:../uvc.c      **** #endif
 920:../uvc.c      **** 
 921:../uvc.c      **** 			  break;
 922:../uvc.c      **** 		  default:
 923:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 924:../uvc.c      **** 			  break;
 925:../uvc.c      **** 		 }
 926:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 927:../uvc.c      **** }
 928:../uvc.c      **** /************** CT control requests handler *************************/
 929:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 930:../uvc.c      **** 
 931:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 932:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 933:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 934:../uvc.c      ****     uint16_t readCount;
 935:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 936:../uvc.c      ****     uint16_t diff, value, diffRd;
 937:../uvc.c      ****     uint8_t i, shutter, index;
 938:../uvc.c      ****     diff = 0xffff;
 939:../uvc.c      ****     shutter = 1;
 940:../uvc.c      ****     index = 1;
 941:../uvc.c      **** 
 942:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 943:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 944:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 945:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 946:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 947:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 948:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 949:../uvc.c      **** #endif
 950:../uvc.c      ****     reqData = bRequest;
 951:../uvc.c      **** 
 952:../uvc.c      ****     switch (bRequest)
 953:../uvc.c      **** 		 {
 954:../uvc.c      **** 
 955:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 956:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 957:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 958:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 959:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 960:../uvc.c      **** 			  break;
 961:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 962:../uvc.c      **** 
 963:../uvc.c      **** 			 switch(CtrlID)
 964:../uvc.c      **** 			 {
 965:../uvc.c      **** 				 default:
 966:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 967:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 968:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 969:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 970:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 971:../uvc.c      **** 					 break;
 972:../uvc.c      **** 			 }
 973:../uvc.c      **** 
 974:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 975:../uvc.c      **** 
 976:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 977:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 978:../uvc.c      **** #endif
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 982:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 983:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 984:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 985:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 986:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 987:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 988:../uvc.c      **** 			  break;
 989:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 993:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 994:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 995:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 996:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 997:../uvc.c      **** 			  break;
 998:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 999:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1000:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1001:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1002:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1003:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1004:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1005:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1006:../uvc.c      **** 			  break;
1007:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1008:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1009:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1010:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1011:../uvc.c      **** 			  Len = 1;
1012:../uvc.c      **** 			  break;
1013:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1014:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1017:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1018:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1019:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1020:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1021:../uvc.c      **** 			  break;
1022:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1023:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1024:../uvc.c      **** 			  glEp0Buffer, &readCount);
1025:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1026:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1027:../uvc.c      **** 			  value = Data1;
1028:../uvc.c      **** 
1029:../uvc.c      **** 			  switch(CtrlID)
1030:../uvc.c      **** 			  {
1031:../uvc.c      **** 		  	      case AutoExMCtlID1:
1032:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1033:../uvc.c      **** 
1034:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1035:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1036:../uvc.c      **** 				    getData = glEp0Buffer[0];
1037:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1038:../uvc.c      **** 		  		    switch (getData){
1039:../uvc.c      **** 						case 1:
1040:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1041:../uvc.c      **** 							break;
1042:../uvc.c      **** 						case 2:
1043:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1044:../uvc.c      **** 							dataIdx = 0;
1045:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1046:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1047:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1048:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1049:../uvc.c      **** 
1050:../uvc.c      **** 							break;
1051:../uvc.c      **** 						case 4:
1052:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1053:../uvc.c      **** 							break;
1054:../uvc.c      **** 						case 8:
1055:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1056:../uvc.c      **** 			  		    	dataIdx = 0;
1057:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1058:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1059:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1060:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1061:../uvc.c      **** 							break;
1062:../uvc.c      **** 		  		    }
1063:../uvc.c      **** #if 0
1064:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1065:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1066:../uvc.c      **** 						  dataIdx = 0;
1067:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1068:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1069:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1070:../uvc.c      **** 		  		    }
1071:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1072:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1073:../uvc.c      **** 		  		    }
1074:../uvc.c      **** #endif
1075:../uvc.c      **** 				    break;
1076:../uvc.c      **** 
1077:../uvc.c      **** 			  	  case ExTmACtlID3:
1078:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1079:../uvc.c      **** 
1080:../uvc.c      **** 					  value = (value << 8)|Data0;
1081:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1082:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1083:../uvc.c      **** 					  {
1084:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1085:../uvc.c      **** 						  {
1086:../uvc.c      **** 							if(value > ShutValueArry[i]){
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1088:../uvc.c      **** 							}else{
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1090:../uvc.c      **** 							}
1091:../uvc.c      **** 							  if(diff > diffRd){
1092:../uvc.c      **** 								  diff = diffRd;
1093:../uvc.c      **** 								  index = i;
1094:../uvc.c      **** 							  }
1095:../uvc.c      **** 						  }
1096:../uvc.c      **** 						  shutter = shutter+index;
1097:../uvc.c      **** 
1098:../uvc.c      **** 						  dataIdx = 0;
1099:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1100:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1101:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1102:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1103:../uvc.c      **** 
1104:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1105:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1106:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1107:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1108:../uvc.c      **** 					  }else{
1109:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1110:../uvc.c      **** 					  }
1111:../uvc.c      **** 					  getData = glEp0Buffer[0];
1112:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1113:../uvc.c      **** 					  break;
1114:../uvc.c      **** 			  	  case IriACtlID7:
1115:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1116:../uvc.c      **** 					  {
1117:../uvc.c      **** 							 dataIdx = 0;
1118:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1119:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1120:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1122:../uvc.c      **** 
1123:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1124:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1125:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1126:../uvc.c      **** 					  }else{
1127:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1128:../uvc.c      **** 					  }
1129:../uvc.c      **** 					  getData = glEp0Buffer[0];
1130:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1131:../uvc.c      **** 
1132:../uvc.c      **** 					  break;
1133:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1134:../uvc.c      **** 					  getData = glEp0Buffer[0];
1135:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1136:../uvc.c      **** #if 1
1137:../uvc.c      **** 					  dataIdx = 0;
1138:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1139:../uvc.c      **** 					  if(getData == 1)
1140:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1141:../uvc.c      **** 					  else if(getData == 0xff)
1142:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1143:../uvc.c      **** 					  else
1144:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1145:../uvc.c      **** 					  //dataIdx++;
1146:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1147:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1148:../uvc.c      **** #endif
1149:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1150:../uvc.c      **** 					  break;
1151:../uvc.c      **** 
1152:../uvc.c      **** 			  	  default:
1153:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1154:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1155:../uvc.c      **** 			  		 break;
1156:../uvc.c      **** 			  }
1157:../uvc.c      **** 			  break;
1158:../uvc.c      **** 		  default:
1159:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1160:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1161:../uvc.c      **** 			  break;
1162:../uvc.c      **** 		 }
1163:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1164:../uvc.c      **** 
1165:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1166:../uvc.c      **** }
1167:../uvc.c      **** 
1168:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1169:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1170:../uvc.c      **** {
1171:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1172:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1173:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1174:../uvc.c      **** 
1175:../uvc.c      ****     CtrlID = BrgtCtlID1;
1176:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1177:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1178:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1179:../uvc.c      ****     Data1 = Data0;
1180:../uvc.c      **** 
1181:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1182:../uvc.c      ****     if(Data1&0x80){
1183:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1184:../uvc.c      ****     }else{
1185:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1186:../uvc.c      ****     }
1187:../uvc.c      ****     Data0 = (Data0 << 2);
1188:../uvc.c      **** 
1189:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1190:../uvc.c      **** 
1191:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1192:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1193:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1194:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1195:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1196:../uvc.c      **** 
1197:../uvc.c      ****     CtrlID = ConsCtlID2;
1198:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1199:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1200:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1201:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1202:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1203:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1204:../uvc.c      **** 
1205:../uvc.c      ****     CtrlID = HueCtlID5;
1206:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1207:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1208:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1209:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1212:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1213:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1214:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1215:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1216:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1217:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1218:../uvc.c      **** 
1219:../uvc.c      ****     CtrlID = SaturCtlID6;
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1221:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1222:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1223:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1224:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1225:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1226:../uvc.c      **** 
1227:../uvc.c      ****     CtrlID = ShapCtlID7;
1228:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1229:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1230:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1231:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1232:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1234:../uvc.c      **** 
1235:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1236:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1237:../uvc.c      **** 	return;
1238:../uvc.c      **** }
1239:../uvc.c      **** 
1240:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1241:../uvc.c      **** void
1242:../uvc.c      **** CyFxUVCAddHeader (
1243:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1244:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1245:../uvc.c      ****         )
1246:../uvc.c      **** {
1247:../uvc.c      ****     /* Copy header to buffer */
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1249:../uvc.c      **** 
1250:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1251:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1252:../uvc.c      ****     {
1253:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1254:../uvc.c      ****     }
1255:../uvc.c      **** }
1256:../uvc.c      **** 
1257:../uvc.c      **** 
1258:../uvc.c      **** /* Application Error Handler */
1259:../uvc.c      **** void
1260:../uvc.c      **** CyFxAppErrorHandler (
1261:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1262:../uvc.c      ****         )
1263:../uvc.c      **** {
1264:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1265:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1266:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1267:../uvc.c      **** 
1268:../uvc.c      ****        This function can be modified to take additional error handling actions such
1269:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1270:../uvc.c      ****      */
1271:../uvc.c      ****     for (;;)
1272:../uvc.c      ****     {
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
1275:../uvc.c      ****     }
1276:../uvc.c      **** }
1277:../uvc.c      **** 
1278:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1279:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1280:../uvc.c      ****  */
1281:../uvc.c      **** static void
1282:../uvc.c      **** CyFxUVCApplnAbortHandler (
1283:../uvc.c      ****         void)
1284:../uvc.c      **** {
1285:../uvc.c      **** 	uint32_t flag;
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1287:../uvc.c      **** 	{
1288:../uvc.c      ****         /* Clear the Video Stream Request Event */
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1290:../uvc.c      **** 
1291:../uvc.c      ****         /* Set Video Stream Abort Event */
1292:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1293:../uvc.c      **** 	}
1294:../uvc.c      **** }
1295:../uvc.c      **** 
1296:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1297:../uvc.c      **** static void
1298:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1299:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1300:../uvc.c      ****         uint16_t             evdata  /* Event data */
1301:../uvc.c      ****         )
1302:../uvc.c      **** {
1303:../uvc.c      ****     switch (evtype)
1304:../uvc.c      ****     {
1305:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1306:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1307:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1308:../uvc.c      ****             gpif_initialized = 0;
1309:../uvc.c      ****             streamingStarted = CyFalse;
1310:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1311:../uvc.c      ****             break;
1312:../uvc.c      **** 
1313:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1314:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1315:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1316:../uvc.c      ****             gpif_initialized = 0;
1317:../uvc.c      ****             streamingStarted = CyFalse;
1318:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1319:../uvc.c      ****             break;
1320:../uvc.c      **** 
1321:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1322:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1323:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1324:../uvc.c      ****             gpif_initialized = 0;
1325:../uvc.c      ****             isUsbConnected = CyFalse;
1326:../uvc.c      ****             streamingStarted = CyFalse;
1327:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1328:../uvc.c      ****             break;
1329:../uvc.c      **** 
1330:../uvc.c      **** #ifdef BACKFLOW_DETECT
1331:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1332:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1333:../uvc.c      ****             break;
1334:../uvc.c      **** #endif
1335:../uvc.c      **** 
1336:../uvc.c      ****         default:
1337:../uvc.c      ****             break;
1338:../uvc.c      ****     }
1339:../uvc.c      **** }
1340:../uvc.c      **** 
1341:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1342:../uvc.c      **** static CyBool_t
1343:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1344:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1345:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1346:../uvc.c      ****         )
1347:../uvc.c      **** {
1348:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1349:../uvc.c      ****     uint32_t status;
1350:../uvc.c      **** 
1351:../uvc.c      ****     /* Obtain Request Type and Request */
1352:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1353:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1354:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1355:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1356:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1357:../uvc.c      **** 
1358:../uvc.c      ****     /* Check for UVC Class Requests */
1359:../uvc.c      ****     switch (bmReqType)
1360:../uvc.c      ****     {
1361:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1362:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1363:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1364:../uvc.c      ****             switch (wIndex & 0xFF)
1365:../uvc.c      ****             {
1366:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1367:../uvc.c      ****                     {
1368:../uvc.c      ****                         uvcHandleReq = CyTrue;
1369:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1370:../uvc.c      ****                                 CYU3P_EVENT_OR);
1371:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1372:../uvc.c      ****                         {
1373:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1374:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1375:../uvc.c      ****                         }
1376:../uvc.c      ****                     }
1377:../uvc.c      ****                     break;
1378:../uvc.c      **** 
1379:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1380:../uvc.c      ****                     {
1381:../uvc.c      ****                         uvcHandleReq = CyTrue;
1382:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1383:../uvc.c      ****                                 CYU3P_EVENT_OR);
1384:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1385:../uvc.c      ****                         {
1386:../uvc.c      ****                             /* Error handling */
1387:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1388:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1389:../uvc.c      ****                         }
1390:../uvc.c      ****                     }
1391:../uvc.c      ****                     break;
1392:../uvc.c      **** 
1393:../uvc.c      ****                 default:
1394:../uvc.c      ****                     break;
1395:../uvc.c      ****             }
1396:../uvc.c      ****             break;
1397:../uvc.c      **** 
1398:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1399:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1400:../uvc.c      ****             {
1401:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1402:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1403:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1404:../uvc.c      ****                 {
1405:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1406:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1407:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1408:../uvc.c      ****                     gpif_initialized = 0;
1409:../uvc.c      ****                     streamingStarted = CyFalse;
1410:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1411:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1412:../uvc.c      ****                     CyU3PBusyWait (100);
1413:../uvc.c      **** 
1414:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1415:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1416:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1417:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1418:../uvc.c      ****                     CyU3PBusyWait (100);
1419:../uvc.c      **** 
1420:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1421:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1422:../uvc.c      ****                     uvcHandleReq = CyTrue;
1423:../uvc.c      ****                     /* Complete Control request handshake */
1424:../uvc.c      ****                     CyU3PUsbAckSetup ();
1425:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1426:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1427:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1428:../uvc.c      **** 
1429:../uvc.c      ****                 }
1430:../uvc.c      ****             }
1431:../uvc.c      ****             break;
1432:../uvc.c      **** 
1433:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1434:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1435:../uvc.c      ****             {
1436:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1437:../uvc.c      ****                 {
1438:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1439:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1440:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1441:../uvc.c      ****                 	 * has started. */
1442:../uvc.c      ****                     if (streamingStarted == CyTrue)
1443:../uvc.c      ****                     {
1444:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1445:../uvc.c      **** 
1446:../uvc.c      ****                         /* Disable the GPIF state machine. */
1447:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1448:../uvc.c      ****                         gpif_initialized = 0;
1449:../uvc.c      ****                         streamingStarted = CyFalse;
1450:../uvc.c      **** 
1451:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1452:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1453:../uvc.c      ****                         CyU3PBusyWait (100);
1454:../uvc.c      **** 
1455:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1456:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1457:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1458:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1459:../uvc.c      ****                         CyU3PBusyWait (100);
1460:../uvc.c      **** 
1461:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1462:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1463:../uvc.c      **** 
1464:../uvc.c      ****                         uvcHandleReq = CyTrue;
1465:../uvc.c      ****                         /* Complete Control request handshake */
1466:../uvc.c      ****                         CyU3PUsbAckSetup ();
1467:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1468:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1469:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1470:../uvc.c      ****                     }
1471:../uvc.c      ****                     else
1472:../uvc.c      ****                     {
1473:../uvc.c      ****                         uvcHandleReq = CyTrue;
1474:../uvc.c      ****                         CyU3PUsbAckSetup ();
1475:../uvc.c      ****                     }
1476:../uvc.c      ****                 }
1477:../uvc.c      ****             }
1478:../uvc.c      ****             break;
1479:../uvc.c      **** 
1480:../uvc.c      ****         default:
1481:../uvc.c      ****             break;
1482:../uvc.c      ****     }
1483:../uvc.c      **** 
1484:../uvc.c      ****     /* Return status of request handling to the USB driver */
1485:../uvc.c      ****     return uvcHandleReq;
1486:../uvc.c      **** }
1487:../uvc.c      **** 
1488:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1489:../uvc.c      **** 
1490:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1491:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1492:../uvc.c      ****  */
1493:../uvc.c      **** void
1494:../uvc.c      **** CyFxUvcApplnDmaCallback (
1495:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1496:../uvc.c      ****         CyU3PDmaCbType_t      type,
1497:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1498:../uvc.c      ****         )
1499:../uvc.c      **** {
1500:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1501:../uvc.c      **** #if 1
1502:../uvc.c      ****     CyU3PReturnStatus_t status;
1503:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1504:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1505:../uvc.c      **** 
1506:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1507:../uvc.c      ****     {
1508:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1509:../uvc.c      ****             {
1510:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1511:../uvc.c      ****                 fb++;
1512:../uvc.c      ****             }
1513:../uvc.c      ****             else
1514:../uvc.c      ****             {
1515:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1516:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1517:../uvc.c      ****                 pb++;
1518:../uvc.c      ****                 pbc = input->buffer_p.count;
1519:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1520:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1521:../uvc.c      ****                 //lineCount = 0; //res test
1522:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
1523:../uvc.c      ****             }
1524:../uvc.c      **** 
1525:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1526:../uvc.c      ****             prodCount++;
1527:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1528:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1529:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1530:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1531:../uvc.c      ****             {
1532:../uvc.c      ****                 prodCount--;
1533:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1534:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1535:../uvc.c      ****             }
1536:../uvc.c      ****     }
1537:../uvc.c      **** #endif
1538:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1539:../uvc.c      ****     {
1540:../uvc.c      ****         consCount++;
1541:../uvc.c      ****         streamingStarted = CyTrue;
1542:../uvc.c      ****     }
1543:../uvc.c      **** }
1544:../uvc.c      **** 
1545:../uvc.c      **** /*
1546:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1547:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1548:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1549:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1550:../uvc.c      ****  * to commit the buffer.
1551:../uvc.c      ****  */
1552:../uvc.c      **** static uint8_t
1553:../uvc.c      **** CyFxUvcAppCommitEOF (
1554:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1555:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1556:../uvc.c      ****         )
1557:../uvc.c      **** {
1558:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1559:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1560:../uvc.c      **** 
1561:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1562:../uvc.c      **** 
1563:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1564:../uvc.c      ****     {
1565:../uvc.c      ****         switch (stateId)
1566:../uvc.c      ****         {
1567:../uvc.c      **** 
1568:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1569:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1570:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** 
1573:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1574:../uvc.c      ****                 socket = 0;
1575:../uvc.c      ****                 break;
1576:../uvc.c      **** 
1577:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1578:../uvc.c      ****                 socket = 1;
1579:../uvc.c      ****                 break;
1580:../uvc.c      **** 
1581:../uvc.c      ****             default:
1582:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1583:../uvc.c      ****                 /* Unexpected current state. Return error. */
1584:../uvc.c      ****             	//lineCount++;
1585:../uvc.c      ****             	return 1;
1586:../uvc.c      ****         }
1587:../uvc.c      ****     }
1588:../uvc.c      **** 
1589:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1590:../uvc.c      ****     {
1591:../uvc.c      ****         switch (stateId)
1592:../uvc.c      ****         {
1593:../uvc.c      **** #ifndef CAM720
1594:../uvc.c      **** #ifdef GPIFIIM
1595:../uvc.c      ****             case 13:
1596:../uvc.c      ****             case 24:
1597:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** 
1600:../uvc.c      ****             case 8:
1601:../uvc.c      ****                 socket = 0;
1602:../uvc.c      ****                 break;
1603:../uvc.c      **** 
1604:../uvc.c      ****             case 20:
1605:../uvc.c      ****                 socket = 1;
1606:../uvc.c      ****                 break;
1607:../uvc.c      **** #else
1608:../uvc.c      ****             case 11:
1609:../uvc.c      ****             case 18:
1610:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1611:../uvc.c      ****                 break;
1612:../uvc.c      **** 
1613:../uvc.c      ****             case 8:
1614:../uvc.c      ****                 socket = 0;
1615:../uvc.c      ****                 break;
1616:../uvc.c      **** 
1617:../uvc.c      ****             case 15:
1618:../uvc.c      ****                 socket = 1;
1619:../uvc.c      ****                 break;
1620:../uvc.c      **** #endif
1621:../uvc.c      **** #else
1622:../uvc.c      ****             case 11:
1623:../uvc.c      ****             case 18:
1624:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1625:../uvc.c      ****                 break;
1626:../uvc.c      **** 
1627:../uvc.c      ****             case 8:
1628:../uvc.c      ****                 socket = 0;
1629:../uvc.c      ****                 break;
1630:../uvc.c      **** 
1631:../uvc.c      ****             case 15:
1632:../uvc.c      ****                 socket = 1;
1633:../uvc.c      ****                 break;
1634:../uvc.c      **** 
1635:../uvc.c      **** #endif
1636:../uvc.c      ****              default:
1637:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1638:../uvc.c      ****                 /* Unexpected current state. Return error. */
1639:../uvc.c      ****                return 1;
1640:../uvc.c      ****         }
1641:../uvc.c      ****     }
1642:../uvc.c      **** 
1643:../uvc.c      ****     if (socket != 0xFF)
1644:../uvc.c      ****     {
1645:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1646:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1647:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1648:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1649:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1650:../uvc.c      ****         {
1651:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1652:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1653:../uvc.c      ****         }
1654:../uvc.c      ****     }
1655:../uvc.c      **** 
1656:../uvc.c      ****     return 0;
1657:../uvc.c      **** }
1658:../uvc.c      **** 
1659:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1660:../uvc.c      **** void
1661:../uvc.c      **** CyFxGpifCB (
1662:../uvc.c      ****         CyU3PGpifEventType event,
1663:../uvc.c      ****         uint8_t currentState
1664:../uvc.c      ****         )
1665:../uvc.c      **** {
1666:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1667:../uvc.c      ****     {
1668:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1669:../uvc.c      ****     	           in the UVC implementation. */
1670:../uvc.c      ****     	//hitFV = CyTrue;
1671:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1672:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1673:../uvc.c      ****     }
1674:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1675:../uvc.c      **** }
1676:../uvc.c      **** 
1677:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1678:../uvc.c      **** static void
1679:../uvc.c      **** CyFxUVCApplnDebugInit (
1680:../uvc.c      ****         void)
1681:../uvc.c      **** {
1682:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1683:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1684:../uvc.c      **** 
1685:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1686:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1687:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1688:../uvc.c      ****     {
1689:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1691:../uvc.c      ****     }
1692:../uvc.c      **** 
1693:../uvc.c      ****     /* Set UART Configuration */
1694:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1695:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1696:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1697:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1698:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1699:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1700:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1701:../uvc.c      **** 
1702:../uvc.c      ****     /* Set the UART configuration */
1703:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1704:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1705:../uvc.c      ****     {
1706:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1707:../uvc.c      ****     }
1708:../uvc.c      **** 
1709:../uvc.c      ****     /* Set the UART transfer */
1710:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1711:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1712:../uvc.c      ****     {
1713:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1714:../uvc.c      ****     }
1715:../uvc.c      **** 
1716:../uvc.c      ****     /* Initialize the Debug logger module. */
1717:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1718:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1719:../uvc.c      ****     {
1720:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1721:../uvc.c      ****     }
1722:../uvc.c      **** 
1723:../uvc.c      ****     /* Disable log message headers. */
1724:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1725:../uvc.c      **** }
1726:../uvc.c      **** 
1727:../uvc.c      **** /* I2C initialization. */
1728:../uvc.c      **** static void
1729:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1730:../uvc.c      **** {
1731:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1732:../uvc.c      ****     CyU3PReturnStatus_t status;
1733:../uvc.c      **** 
1734:../uvc.c      ****     status = CyU3PI2cInit ();
1735:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1736:../uvc.c      ****     {
1737:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1738:../uvc.c      ****         CyFxAppErrorHandler (status);
1739:../uvc.c      ****     }
1740:../uvc.c      **** 
1741:../uvc.c      ****     /*  Set I2C Configuration */
1742:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1743:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1744:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1745:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1746:../uvc.c      **** 
1747:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1748:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1749:../uvc.c      ****     {
1750:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1751:../uvc.c      ****         CyFxAppErrorHandler (status);
1752:../uvc.c      ****     }
1753:../uvc.c      **** }
1754:../uvc.c      **** 
1755:../uvc.c      **** #ifdef BACKFLOW_DETECT
1756:../uvc.c      **** static void CyFxUvcAppPibCallback (
1757:../uvc.c      ****         CyU3PPibIntrType cbType,
1758:../uvc.c      ****         uint16_t cbArg)
1759:../uvc.c      **** {
1760:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1761:../uvc.c      ****     {
1762:../uvc.c      ****         if (!back_flow_detected)
1763:../uvc.c      ****         {
1764:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1765:../uvc.c      ****             back_flow_detected = 1;
1766:../uvc.c      ****         }
1767:../uvc.c      ****     }
1768:../uvc.c      **** }
1769:../uvc.c      **** #endif
1770:../uvc.c      **** 
1771:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1772:../uvc.c      **** static void
1773:../uvc.c      **** CyFxUvcAppDebugCallback (
1774:../uvc.c      ****         CyU3PDmaChannel   *handle,
1775:../uvc.c      ****         CyU3PDmaCbType_t   type,
1776:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1777:../uvc.c      **** {
1778:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1779:../uvc.c      ****     {
1780:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1781:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1782:../uvc.c      ****     }
1783:../uvc.c      **** }
1784:../uvc.c      **** #endif
1785:../uvc.c      **** 
1786:../uvc.c      **** #if 0
1787:../uvc.c      **** static void CyFxAppIntEpCb(
1788:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1789:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1790:../uvc.c      **** 		uint8_t  ebNum)
1791:../uvc.c      **** 		{
1792:../uvc.c      **** 			//CyBool_t value;
1793:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1794:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1795:../uvc.c      **** 
1796:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1797:../uvc.c      **** 		}
1798:../uvc.c      **** #endif
1799:../uvc.c      **** 
1800:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1801:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1802:../uvc.c      ****    configures the DMA module for the UVC Application */
1803:../uvc.c      **** static void
1804:../uvc.c      **** CyFxUVCApplnInit (void)
1805:../uvc.c      **** {
1806:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1807:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1808:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1809:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1810:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1811:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1812:../uvc.c      **** 
1813:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1814:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1815:../uvc.c      **** 
1816:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1817:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1818:../uvc.c      **** #endif
1819:../uvc.c      **** 
1820:../uvc.c      ****     /* Create UVC event group */
1821:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1822:../uvc.c      ****     if (apiRetStatus != 0)
1823:../uvc.c      ****     {
1824:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1825:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1826:../uvc.c      ****     }
1827:../uvc.c      **** 
1828:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1829:../uvc.c      ****     CyFxUvcAppPTZInit ();
1830:../uvc.c      **** #endif
1831:../uvc.c      **** 
1832:../uvc.c      ****     isUsbConnected = CyFalse;
1833:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1834:../uvc.c      **** 
1835:../uvc.c      ****     /* Init the GPIO module */
1836:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1837:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1838:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1839:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1840:../uvc.c      ****     gpioClock.halfDiv    = 0;
1841:../uvc.c      **** 
1842:../uvc.c      ****     /* Initialize Gpio interface */
1843:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1844:../uvc.c      ****     if (apiRetStatus != 0)
1845:../uvc.c      ****     {
1846:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1847:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1848:../uvc.c      ****     }
1849:../uvc.c      **** 
1850:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1851:../uvc.c      ****      * must use GpioOverride to configure it */
1852:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1853:../uvc.c      ****     if (apiRetStatus != 0)
1854:../uvc.c      ****     {
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1856:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1857:../uvc.c      ****     }
1858:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1859:../uvc.c      ****     if (apiRetStatus != 0)
1860:../uvc.c      ****     {
1861:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1863:../uvc.c      ****     }
1864:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1865:../uvc.c      ****     if (apiRetStatus != 0)
1866:../uvc.c      ****     {
1867:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1868:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1869:../uvc.c      ****     }
1870:../uvc.c      **** 
1871:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1872:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1873:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1874:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1875:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1876:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1877:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1878:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1879:../uvc.c      ****     {
1880:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1881:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1882:../uvc.c      ****     }
1883:../uvc.c      **** 
1884:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1885:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1886:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1887:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1888:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1889:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1890:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1891:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1892:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1893:../uvc.c      ****     {
1894:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1896:../uvc.c      ****     }
1897:../uvc.c      **** 
1898:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1899:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1900:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1901:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1902:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1903:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1904:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1905:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1906:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1907:../uvc.c      ****     {
1908:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1909:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1910:../uvc.c      ****     }
1911:../uvc.c      **** 
1912:../uvc.c      ****     /* Initialize the P-port. */
1913:../uvc.c      ****     pibclock.clkDiv      = 2;
1914:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1915:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1916:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1917:../uvc.c      **** 
1918:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1920:../uvc.c      ****     {
1921:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1922:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1923:../uvc.c      ****     }
1924:../uvc.c      **** 
1925:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1926:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1927:../uvc.c      **** 
1928:../uvc.c      **** #ifdef BACKFLOW_DETECT
1929:../uvc.c      ****     back_flow_detected = 0;
1930:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1931:../uvc.c      **** #endif
1932:../uvc.c      **** 
1933:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1934:../uvc.c      ****     SensorReset ();
1935:../uvc.c      ****     CyU3PThreadSleep(5000);
1936:../uvc.c      ****     //SensorInit ();
1937:../uvc.c      **** 
1938:../uvc.c      ****     /* USB initialization. */
1939:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1940:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1941:../uvc.c      ****     {
1942:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1943:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1944:../uvc.c      ****     }
1945:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1946:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1947:../uvc.c      **** 
1948:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1949:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1950:../uvc.c      **** 
1951:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1952:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1953:../uvc.c      **** 
1954:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1955:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1956:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1957:../uvc.c      **** 
1958:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1959:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1960:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1961:../uvc.c      **** 
1962:../uvc.c      ****     /* Configuration descriptors. */
1963:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1964:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1965:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1966:../uvc.c      **** 
1967:../uvc.c      ****     /* String Descriptors */
1968:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1969:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1970:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1971:../uvc.c      **** 
1972:../uvc.c      ****     /* Configure the status interrupt endpoint.
1973:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1974:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1975:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1976:../uvc.c      ****      */
1977:../uvc.c      ****     endPointConfig.enable   = 1;
1978:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1979:../uvc.c      ****     endPointConfig.pcktSize = 64;
1980:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1981:../uvc.c      ****     endPointConfig.streams  = 0;
1982:../uvc.c      ****     endPointConfig.burstLen = 1;
1983:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1985:../uvc.c      ****     {
1986:../uvc.c      ****         /* Error Handling */
1987:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1988:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1989:../uvc.c      ****     }
1990:../uvc.c      **** 
1991:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1992:../uvc.c      ****     dmaInterConfig.size           = 1024;
1993:../uvc.c      ****     dmaInterConfig.count          = 1;
1994:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1995:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1996:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1997:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1998:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1999:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2000:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2001:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2002:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2003:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2004:../uvc.c      ****             &dmaInterConfig);
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2006:../uvc.c      ****     {
2007:../uvc.c      ****         /* Error handling */
2008:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2009:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2010:../uvc.c      ****     }
2011:../uvc.c      **** 
2012:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2013:../uvc.c      ****     if (glInterStaBuffer == 0)
2014:../uvc.c      ****     {
2015:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2016:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2017:../uvc.c      ****     }
2018:../uvc.c      **** 
2019:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2020:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2021:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2022:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2023:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2024:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2025:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2026:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2027:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2028:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2029:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2030:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2031:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2032:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2033:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2034:../uvc.c      ****             &dmaMultiConfig);
2035:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2036:../uvc.c      ****     {
2037:../uvc.c      ****         /* Error handling */
2038:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2039:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2040:../uvc.c      ****     }
2041:../uvc.c      **** 
2042:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2043:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2044:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2045:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2046:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2047:../uvc.c      ****      */
2048:../uvc.c      **** 
2049:../uvc.c      ****     endPointConfig.enable   = 1;
2050:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2051:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2052:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2053:../uvc.c      ****     endPointConfig.streams  = 0;
2054:../uvc.c      ****     endPointConfig.burstLen = 1;
2055:../uvc.c      **** 
2056:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2057:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2058:../uvc.c      ****     {
2059:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2060:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2061:../uvc.c      ****     }
2062:../uvc.c      **** 
2063:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2064:../uvc.c      **** 
2065:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2066:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2067:../uvc.c      ****     {
2068:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2069:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2070:../uvc.c      ****     }
2071:../uvc.c      **** 
2072:../uvc.c      ****     channelConfig.size           = 1024;
2073:../uvc.c      ****     channelConfig.count          = 1;
2074:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2075:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2076:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2077:../uvc.c      ****     channelConfig.prodHeader     = 0;
2078:../uvc.c      ****     channelConfig.prodFooter     = 0;
2079:../uvc.c      ****     channelConfig.consHeader     = 0;
2080:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2081:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2082:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2083:../uvc.c      **** 
2084:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2085:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2086:../uvc.c      ****     {
2087:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2088:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2089:../uvc.c      ****     }
2090:../uvc.c      **** 
2091:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2092:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2093:../uvc.c      ****     {
2094:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2095:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2096:../uvc.c      ****     }
2097:../uvc.c      **** 
2098:../uvc.c      ****     channelConfig.size           = 1024;
2099:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2100:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2101:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2102:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2103:../uvc.c      ****     channelConfig.prodHeader     = 0;
2104:../uvc.c      ****     channelConfig.prodFooter     = 0;
2105:../uvc.c      ****     channelConfig.consHeader     = 0;
2106:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2107:../uvc.c      ****     channelConfig.notification   = 0;
2108:../uvc.c      ****     channelConfig.cb             = 0;
2109:../uvc.c      **** 
2110:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2111:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2112:../uvc.c      ****     {
2113:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2114:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2115:../uvc.c      ****     }
2116:../uvc.c      **** 
2117:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2118:../uvc.c      ****     if (glDebugRspBuffer == 0)
2119:../uvc.c      ****     {
2120:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2121:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2122:../uvc.c      ****     }
2123:../uvc.c      **** #endif
2124:../uvc.c      **** 
2125:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2126:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2127:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2128:../uvc.c      ****     {
2129:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2130:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2131:../uvc.c      ****     }
2132:../uvc.c      **** 
2133:../uvc.c      ****     CyU3PBusyWait(100);
2134:../uvc.c      **** 
2135:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2136:../uvc.c      **** 
2137:../uvc.c      ****     endPointConfig.enable   = 1;
2138:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2140:../uvc.c      ****     {
2141:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2142:../uvc.c      ****     	endPointConfig.burstLen = 16;
2143:../uvc.c      ****     }
2144:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2145:../uvc.c      ****     {
2146:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2147:../uvc.c      ****     	endPointConfig.burstLen = 1;
2148:../uvc.c      ****     }
2149:../uvc.c      ****     endPointConfig.streams  = 0;
2150:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         /* Error Handling */
2154:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      **** #if 0    //for still image method 3 using
2158:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2159:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         /* Error Handling */
2162:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2163:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2164:../uvc.c      ****     }
2165:../uvc.c      **** #endif
2166:../uvc.c      **** 
2167:../uvc.c      **** }
2168:../uvc.c      **** 
2169:../uvc.c      **** /*
2170:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2171:../uvc.c      ****  * streaming session is started.
2172:../uvc.c      ****  */
2173:../uvc.c      **** static void
2174:../uvc.c      **** CyFxUvcAppGpifInit (
2175:../uvc.c      ****         void)
2176:../uvc.c      **** {
2177:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2178:../uvc.c      **** 
2179:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2180:../uvc.c      ****     {
2181:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2182:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2183:../uvc.c      ****     }
2184:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2185:../uvc.c      ****     {
2186:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2187:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2188:../uvc.c      ****     }
2189:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2190:../uvc.c      ****     {
2191:../uvc.c      ****         /* Error Handling */
2192:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2193:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2194:../uvc.c      ****     }
2195:../uvc.c      **** 
2196:../uvc.c      ****     /* Start the state machine from the designated start state. */
2197:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2198:../uvc.c      ****     {
2199:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2200:../uvc.c      ****     }
2201:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2202:../uvc.c      ****     {
2203:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2204:../uvc.c      ****     }
2205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2206:../uvc.c      ****     {
2207:../uvc.c      ****         /* Error Handling */
2208:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2209:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2210:../uvc.c      ****     }
2211:../uvc.c      **** }
2212:../uvc.c      **** 
2213:../uvc.c      **** /*
2214:../uvc.c      ****  * Entry function for the UVC Application Thread
2215:../uvc.c      ****  */
2216:../uvc.c      **** 
2217:../uvc.c      **** uint32_t posTick;
2218:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2219:../uvc.c      **** 
2220:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2221:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2222:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2223:../uvc.c      **** }
2224:../uvc.c      **** 
2225:../uvc.c      **** 
2226:../uvc.c      **** void
2227:../uvc.c      **** UVCAppThread_Entry (
2228:../uvc.c      ****         uint32_t input)
2229:../uvc.c      **** {
2230:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2231:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2232:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2233:../uvc.c      ****     uint8_t i = 0;
2234:../uvc.c      ****     uint32_t flag;
2235:../uvc.c      ****     uint32_t prinflag = 0;
2236:../uvc.c      **** 
2237:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2238:../uvc.c      ****     uint32_t frameCnt = 0;
2239:../uvc.c      **** #endif
2240:../uvc.c      ****     /* Initialize the Uart Debug Module */
2241:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2242:../uvc.c      **** 
2243:../uvc.c      ****     /* Initialize the I2C interface */
2244:../uvc.c      **** 	while (i++ < 6){
2245:../uvc.c      **** 		CyU3PThreadSleep(500);
2246:../uvc.c      **** 	}
2247:../uvc.c      **** 
2248:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2249:../uvc.c      **** 
2250:../uvc.c      ****     /* Initialize the UVC Application */
2251:../uvc.c      ****     CyFxUVCApplnInit ();
2252:../uvc.c      ****     /*
2253:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2254:../uvc.c      **** 
2255:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2256:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2257:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2258:../uvc.c      **** 
2259:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2260:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2261:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2262:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2263:../uvc.c      **** 
2264:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2265:../uvc.c      ****        of handling the abort request.
2266:../uvc.c      ****      */
2267:../uvc.c      **** 
2268:../uvc.c      ****     for (;;)
2269:../uvc.c      ****     {
2270:../uvc.c      ****         /* Waiting for the Video Stream Event */
2271:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2272:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2273:../uvc.c      ****         {
2274:../uvc.c      **** #if 0 //test for new firmware no video bring up
2275:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2276:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2277:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2278:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2279:../uvc.c      ****             {
2280:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2281:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2282:../uvc.c      ****                 {
2283:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2284:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2285:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2286:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2287:../uvc.c      **** #endif
2288:../uvc.c      **** #endif
2289:../uvc.c      ****                     }
2290:../uvc.c      ****                 else
2291:../uvc.c      ****                 {
2292:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2293:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2294:../uvc.c      **** #ifdef USB_LOWRES_IMG
2295:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2296:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2297:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2298:../uvc.c      **** #endif
2299:../uvc.c      **** #endif
2300:../uvc.c      ****                 }
2301:../uvc.c      **** 
2302:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2303:../uvc.c      ****                 prodCount++;
2304:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2305:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2306:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2307:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2308:../uvc.c      ****                 {
2309:../uvc.c      ****                     prodCount--;
2310:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2311:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2312:../uvc.c      ****                 }
2313:../uvc.c      ****             }
2314:../uvc.c      **** #endif
2315:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2316:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2317:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2318:../uvc.c      ****             {
2319:../uvc.c      ****             	if(0&&(prinflag == 0)){
2320:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2321:../uvc.c      ****             		prinflag = 1;
2322:../uvc.c      ****             	}
2323:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2324:../uvc.c      ****             	fb=0;
2325:../uvc.c      ****             	pb=0;
2326:../uvc.c      ****             	pbc=0;
2327:../uvc.c      ****                 prodCount = 0;
2328:../uvc.c      ****                 consCount = 0;
2329:../uvc.c      ****                 hitFV     = CyFalse;
2330:../uvc.c      **** 
2331:../uvc.c      **** #ifdef BACKFLOW_DETECT
2332:../uvc.c      ****                 back_flow_detected = 0;
2333:../uvc.c      **** #endif
2334:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2335:../uvc.c      ****                 frameCnt++;
2336:../uvc.c      **** #endif
2337:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2338:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2339:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2340:../uvc.c      ****                 //}
2341:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2342:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2343:../uvc.c      ****                 if(stiflag){
2344:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
2345:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
2346:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
2347:../uvc.c      ****                 		stiflag = CyFalse;
2348:../uvc.c      ****                 	}
2349:../uvc.c      ****                 }else{
2350:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2351:../uvc.c      ****                 }
2352:../uvc.c      ****                 /* Reset the DMA channel. */
2353:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2354:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2355:../uvc.c      ****                 {
2356:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2357:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2358:../uvc.c      ****                 }
2359:../uvc.c      **** 
2360:../uvc.c      ****                 /* Start Channel Immediately */
2361:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2362:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2363:../uvc.c      ****                 {
2364:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2365:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2366:../uvc.c      ****                 }
2367:../uvc.c      **** 
2368:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2369:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2370:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2371:../uvc.c      ****                 }
2372:../uvc.c      ****         }
2373:../uvc.c      ****         else
2374:../uvc.c      ****         {
2375:../uvc.c      ****             /* If we have a stream abort request pending. */
2376:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2377:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2378:../uvc.c      ****             {
2379:../uvc.c      ****                 hitFV     = CyFalse;
2380:../uvc.c      ****                 prodCount = 0;
2381:../uvc.c      ****                 consCount = 0;
2382:../uvc.c      ****                 if(0&&(prinflag == 0)){
2383:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2384:../uvc.c      ****                 	prinflag = 1;
2385:../uvc.c      ****                 }
2386:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2387:../uvc.c      ****                 fb=0;
2388:../uvc.c      ****                 pb=0;
2389:../uvc.c      ****                 pbc=0;
2390:../uvc.c      **** 
2391:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2392:../uvc.c      ****                 {
2393:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2394:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2395:../uvc.c      ****                     {
2396:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2397:../uvc.c      ****                     }
2398:../uvc.c      **** 
2399:../uvc.c      ****                     /* Flush the Endpoint memory */
2400:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2401:../uvc.c      ****                 }
2402:../uvc.c      **** 
2403:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2404:../uvc.c      ****             }
2405:../uvc.c      ****             else
2406:../uvc.c      ****             {
2407:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2408:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2409:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2410:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2411:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2412:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2413:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2414:../uvc.c      ****                 {
2415:../uvc.c      ****                     /* Error handling */
2416:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2417:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2418:../uvc.c      ****                 }
2419:../uvc.c      **** 
2420:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2421:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2422:../uvc.c      ****                 {
2423:../uvc.c      **** #if 0
2424:../uvc.c      ****                 	//for start up of the AF Lens
2425:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2426:../uvc.c      ****                     CyU3PThreadSleep(500);
2427:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2428:../uvc.c      ****                     CyU3PThreadSleep(500);
2429:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2430:../uvc.c      ****                    	CyU3PThreadSleep(300);
2431:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2432:../uvc.c      ****                     CyU3PThreadSleep(500);
2433:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2434:../uvc.c      ****                     CyU3PThreadSleep(500);
2435:../uvc.c      **** //#if 0
2436:../uvc.c      ****                     //CyFxUVCApplnI2CInit ();
2437:../uvc.c      ****                     for(i = 0; i<1; i++){
2438:../uvc.c      ****     					//CyFxUVCApplnI2CInit ();
2439:../uvc.c      ****     					SensorWrite2B2(0x7a, 0x2, 0, 0x20, 0);
2440:../uvc.c      ****     					CyU3PThreadSleep(2000);
2441:../uvc.c      ****     				}
2442:../uvc.c      **** //#endif			// write sensor commands for hide the over write issue
2443:../uvc.c      ****                     CyU3PThreadSleep(1000);
2444:../uvc.c      ****                     SensorSetIrisControl(0x0, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2445:../uvc.c      ****                     CyU3PThreadSleep(1000);
2446:../uvc.c      ****                     SensorSetIrisControl(0x2, 0x30, 0x10, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2447:../uvc.c      ****                     CyU3PThreadSleep(1000);
2448:../uvc.c      ****                     SensorSetIrisControl(0x4, 0x30, 0x80, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2449:../uvc.c      **** #endif
2450:../uvc.c      ****                     CyU3PThreadSleep(1000);
2451:../uvc.c      ****                     SensorSetIrisControl(0x1, 0x30, 0x20, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2452:../uvc.c      ****                     CyU3PThreadSleep(1000);
2453:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2454:../uvc.c      ****                     gpif_initialized = CyTrue;
2455:../uvc.c      ****                     CyU3PThreadSleep(200);
2456:../uvc.c      ****                     
2457:../uvc.c      ****                 }
2458:../uvc.c      ****                 else
2459:../uvc.c      ****                 {
2460:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2461:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2462:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2463:../uvc.c      ****                 }
2464:../uvc.c      ****             }
2465:../uvc.c      ****         }
2466:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2467:../uvc.c      **** 
2468:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2469:../uvc.c      ****         CyU3PThreadRelinquish ();
2470:../uvc.c      ****     }
2471:../uvc.c      **** }
2472:../uvc.c      **** 
2473:../uvc.c      **** /*
2474:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2475:../uvc.c      ****  */
2476:../uvc.c      **** 
2477:../uvc.c      **** static void
2478:../uvc.c      **** UVCHandleProcessingUnitRqts (
2479:../uvc.c      ****         void)
2480:../uvc.c      **** {
2481:../uvc.c      ****     uint8_t CtrlAdd;
2482:../uvc.c      **** #ifdef DbgInfo
2483:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2484:../uvc.c      **** #endif
2485:../uvc.c      ****     switch (wValue)
2486:../uvc.c      ****     {
2487:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2488:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2489:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2490:../uvc.c      ****     		break;
2491:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2492:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2493:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2494:../uvc.c      ****     		break;
2495:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2496:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2497:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2498:../uvc.c      **** 			break;
2499:../uvc.c      **** 
2500:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2501:../uvc.c      **** 
2502:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2503:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2504:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2505:../uvc.c      ****       		break;
2506:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2507:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2508:../uvc.c      ****      		ControlHandle(HueCtlID5);
2509:../uvc.c      ****      		break;
2510:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2511:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2512:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2513:../uvc.c      ****           		break;
2514:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2515:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2516:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2517:../uvc.c      ****           		break;
2518:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2519:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2520:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2521:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2522:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2523:../uvc.c      ****     		break;
2524:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2525:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2526:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2527:../uvc.c      ****     		break;
2528:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2529:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2530:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2531:../uvc.c      ****     		break;
2532:../uvc.c      **** 
2533:../uvc.c      ****         default:
2534:../uvc.c      ****             /*
2535:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2536:../uvc.c      ****              * other controls.
2537:../uvc.c      ****              */
2538:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2539:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2540:../uvc.c      ****             break;
2541:../uvc.c      ****     }
2542:../uvc.c      **** }
2543:../uvc.c      **** 
2544:../uvc.c      **** /*
2545:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2546:../uvc.c      ****  */
2547:../uvc.c      **** static void
2548:../uvc.c      **** UVCHandleCameraTerminalRqts (
2549:../uvc.c      ****         void)
2550:../uvc.c      **** {
2551:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2552:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2553:../uvc.c      ****     uint16_t readCount;
2554:../uvc.c      ****     uint16_t zoomVal;
2555:../uvc.c      ****     int32_t  panVal, tiltVal;
2556:../uvc.c      ****     CyBool_t sendData = CyFalse;
2557:../uvc.c      **** #endif
2558:../uvc.c      ****     uint8_t CtrlAdd;
2559:../uvc.c      **** 
2560:../uvc.c      ****     switch (wValue)
2561:../uvc.c      ****     {
2562:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2563:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2564:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2565:../uvc.c      ****     		break;
2566:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2567:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2568:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2569:../uvc.c      ****     		break;
2570:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2571:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2572:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2573:../uvc.c      **** 			break;
2574:../uvc.c      **** 
2575:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2576:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2577:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2578:../uvc.c      **** 			break;
2579:../uvc.c      **** 
2580:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2581:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2582:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2583:../uvc.c      ****       		break;
2584:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2585:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2586:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2587:../uvc.c      ****      		break;
2588:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2589:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2590:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2591:../uvc.c      ****           		break;
2592:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2593:../uvc.c      ****           		break;
2594:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2595:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2596:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2597:../uvc.c      ****      		break;
2598:../uvc.c      **** 
2599:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2600:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2601:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2602:../uvc.c      ****     		break;
2603:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2604:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2605:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2606:../uvc.c      ****     		break;
2607:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2608:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2609:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2610:../uvc.c      ****     		break;
2611:../uvc.c      **** 
2612:../uvc.c      ****         default:
2613:../uvc.c      ****             /*
2614:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2615:../uvc.c      ****              * other controls.
2616:../uvc.c      ****              */
2617:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2618:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2619:../uvc.c      ****             break;
2620:../uvc.c      ****     }
2621:../uvc.c      **** 
2622:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2623:../uvc.c      ****     switch (wValue)
2624:../uvc.c      ****     {
2625:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2626:../uvc.c      ****             switch (bRequest)
2627:../uvc.c      ****             {
2628:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2629:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2630:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2631:../uvc.c      ****                     break;
2632:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2633:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2634:../uvc.c      ****                     sendData = CyTrue;
2635:../uvc.c      ****                     break;
2636:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2637:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2638:../uvc.c      ****                     sendData = CyTrue;
2639:../uvc.c      ****                     break;
2640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2641:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2642:../uvc.c      ****                     sendData = CyTrue;
2643:../uvc.c      ****                     break;
2644:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2645:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2646:../uvc.c      ****                     sendData = CyTrue;
2647:../uvc.c      ****                     break;
2648:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2649:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2650:../uvc.c      ****                     sendData = CyTrue;
2651:../uvc.c      ****                     break;
2652:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2653:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2654:../uvc.c      ****                             glEp0Buffer, &readCount);
2655:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2656:../uvc.c      ****                     {
2657:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2658:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2659:../uvc.c      ****                     }
2660:../uvc.c      ****                     break;
2661:../uvc.c      ****                 default:
2662:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2663:../uvc.c      ****                     break;
2664:../uvc.c      ****             }
2665:../uvc.c      **** 
2666:../uvc.c      ****             if (sendData)
2667:../uvc.c      ****             {
2668:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2669:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2670:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2671:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2672:../uvc.c      ****             }
2673:../uvc.c      ****             break;
2674:../uvc.c      **** 
2675:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2676:../uvc.c      ****             switch (bRequest)
2677:../uvc.c      ****             {
2678:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2679:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2680:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2681:../uvc.c      ****                     break;
2682:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2683:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2684:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2685:../uvc.c      ****                     sendData = CyTrue;
2686:../uvc.c      ****                     break;
2687:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2688:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2689:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2690:../uvc.c      ****                     sendData = CyTrue;
2691:../uvc.c      ****                     break;
2692:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2693:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2694:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2695:../uvc.c      ****                     sendData = CyTrue;
2696:../uvc.c      ****                     break;
2697:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2698:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2699:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2700:../uvc.c      ****                     sendData = CyTrue;
2701:../uvc.c      ****                     break;
2702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2703:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2704:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2705:../uvc.c      ****                     sendData = CyTrue;
2706:../uvc.c      ****                     break;
2707:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2708:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2709:../uvc.c      ****                             glEp0Buffer, &readCount);
2710:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2711:../uvc.c      ****                     {
2712:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2713:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2714:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2715:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2716:../uvc.c      **** 
2717:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2718:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2719:../uvc.c      ****                     }
2720:../uvc.c      ****                     break;
2721:../uvc.c      ****                 default:
2722:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2723:../uvc.c      ****                     break;
2724:../uvc.c      ****             }
2725:../uvc.c      **** 
2726:../uvc.c      ****             if (sendData)
2727:../uvc.c      ****             {
2728:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2729:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2730:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2731:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2732:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2733:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2734:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2735:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2736:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2737:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2738:../uvc.c      ****             }
2739:../uvc.c      ****             break;
2740:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2741:../uvc.c      ****         default:
2742:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2743:../uvc.c      ****             break;
2744:../uvc.c      ****     }
2745:../uvc.c      **** #endif
2746:../uvc.c      **** }
2747:../uvc.c      **** 
2748:../uvc.c      **** /*
2749:../uvc.c      ****  * Handler for UVC Interface control requests.
2750:../uvc.c      ****  */
2751:../uvc.c      **** static void
2752:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2753:../uvc.c      ****         void)
2754:../uvc.c      **** {
2755:../uvc.c      **** 
2756:../uvc.c      ****     switch (wValue)
2757:../uvc.c      ****     {
2758:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2759:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2760:../uvc.c      ****     		break;
2761:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2762:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2763:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2764:../uvc.c      ****     		break;
2765:../uvc.c      ****     	default:
2766:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2767:../uvc.c      ****      		break;
2768:../uvc.c      ****     }
2769:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2770:../uvc.c      **** 
2771:../uvc.c      **** }
2772:../uvc.c      **** 
2773:../uvc.c      **** /*
2774:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2775:../uvc.c      ****  */
2776:../uvc.c      **** static void
2777:../uvc.c      **** UVCHandleExtensionUnitRqts (
2778:../uvc.c      ****         void)
2779:../uvc.c      **** {
2780:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2781:../uvc.c      **** 
2782:../uvc.c      **** #ifdef DbgInfo
2783:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2784:../uvc.c      **** #endif
2785:../uvc.c      ****     switch (wValue)
2786:../uvc.c      ****     {
2787:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2788:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2789:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2790:../uvc.c      ****     		break;
2791:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2792:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2793:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2794:../uvc.c      ****     		break;
2795:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2796:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2797:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2798:../uvc.c      ****      		break;
2799:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2800:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2801:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2802:../uvc.c      ****     		break;
2803:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2804:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2805:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2806:../uvc.c      ****     		break;
2807:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2808:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2809:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2810:../uvc.c      ****      		break;
2811:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2812:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2813:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2814:../uvc.c      ****     		break;
2815:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2816:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2817:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2818:../uvc.c      ****     		break;
2819:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2820:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2821:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2822:../uvc.c      ****      		break;
2823:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2824:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2825:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2826:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2827:../uvc.c      ****     		}else/* no support for 1080p camera */
2828:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2829:../uvc.c      ****     		break;
2830:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2831:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2832:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2833:../uvc.c      ****     		break;
2834:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2835:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2836:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2837:../uvc.c      ****     		break;
2838:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2839:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2840:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2841:../uvc.c      ****     		//break;
2842:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2843:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2844:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2845:../uvc.c      ****     		break;
2846:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2847:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2848:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2849:../uvc.c      ****     		break;
2850:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2851:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2852:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2853:../uvc.c      ****     		break;
2854:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2855:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2856:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2857:../uvc.c      ****     		break;
2858:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2859:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2860:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2861:../uvc.c      ****     		break;
2862:../uvc.c      ****    	default:
2863:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2864:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2865:../uvc.c      ****     		break;
2866:../uvc.c      ****     }
2867:../uvc.c      **** 
2868:../uvc.c      **** }
2869:../uvc.c      **** 
2870:../uvc.c      **** /*
2871:../uvc.c      ****  * Handler for the video streaming control requests.
2872:../uvc.c      ****  */
2873:../uvc.c      **** static void
2874:../uvc.c      **** UVCHandleVideoStreamingRqts (
2875:../uvc.c      ****         void)
2876:../uvc.c      **** {
2877:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2878:../uvc.c      ****     uint16_t readCount;
2879:../uvc.c      **** 
2880:../uvc.c      ****     switch (wValue)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2883:../uvc.c      ****             switch (bRequest)
2884:../uvc.c      ****             {
2885:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2886:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2887:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2888:../uvc.c      ****                     break;
2889:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2890:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2891:../uvc.c      ****                     glEp0Buffer[1] = 0;
2892:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2893:../uvc.c      ****                     break;
2894:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2895:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2896:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2897:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2898:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2899:../uvc.c      ****                     {
2900:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
2901:../uvc.c      ****                     }
2902:../uvc.c      ****                     else
2903:../uvc.c      ****                     {
2904:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2905:../uvc.c      ****                     }
2906:../uvc.c      ****                     break;
2907:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2908:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2909:../uvc.c      ****                             glCommitCtrl, &readCount);
2910:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2911:../uvc.c      ****                     {
2912:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2913:../uvc.c      ****                         {
2914:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2915:../uvc.c      ****                                active data structure. */
2916:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
2917:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
2918:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
2919:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
2920:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
2921:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
2922:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
2923:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
2924:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
2925:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
2926:../uvc.c      **** 
2927:../uvc.c      **** 
2928:../uvc.c      ****                         }
2929:../uvc.c      ****                     }
2930:../uvc.c      ****                     break;
2931:../uvc.c      ****                 default:
2932:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2933:../uvc.c      ****                     break;
2934:../uvc.c      ****             }
2935:../uvc.c      ****             break;
2936:../uvc.c      **** 
2937:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2938:../uvc.c      ****             switch (bRequest)
2939:../uvc.c      ****             {
2940:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2941:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2942:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2943:../uvc.c      ****                     break;
2944:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2945:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2946:../uvc.c      ****                     glEp0Buffer[1] = 0;
2947:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2948:../uvc.c      ****                     break;
2949:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2950:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2951:../uvc.c      ****                     {
2952:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2953:../uvc.c      ****                     }
2954:../uvc.c      ****                     else
2955:../uvc.c      ****                     {
2956:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2957:../uvc.c      ****                     }
2958:../uvc.c      ****                     break;
2959:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2960:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2961:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2962:../uvc.c      ****                        */
2963:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2964:../uvc.c      ****                             glCommitCtrl, &readCount);
2965:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2966:../uvc.c      ****                     {
2967:../uvc.c      **** #if 0
2968:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2969:../uvc.c      ****                         {
2970:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2971:../uvc.c      ****                         }
2972:../uvc.c      ****                         else
2973:../uvc.c      ****                         {
2974:../uvc.c      ****                             SensorScaling_VGA ();
2975:../uvc.c      ****                         }
2976:../uvc.c      **** #endif
2977:../uvc.c      ****                         /* We can start streaming video now. */
2978:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2979:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2980:../uvc.c      ****                         {
2981:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2982:../uvc.c      ****                         }
2983:../uvc.c      ****                     }
2984:../uvc.c      ****                     break;
2985:../uvc.c      **** 
2986:../uvc.c      ****                 default:
2987:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2988:../uvc.c      ****                     break;
2989:../uvc.c      ****             }
2990:../uvc.c      ****             break;
2991:../uvc.c      **** 
2992:../uvc.c      **** /* still image streaming handler */
2993:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2994:../uvc.c      ****                 switch (bRequest)
2995:../uvc.c      ****                 {
2996:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2997:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2998:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2999:../uvc.c      ****                         break;
3000:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3001:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3002:../uvc.c      ****                         glEp0Buffer[1] = 0;
3003:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3004:../uvc.c      ****                         break;
3005:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3006:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3007:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3008:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3009:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3010:../uvc.c      ****                         {
3011:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3012:../uvc.c      ****                         }
3013:../uvc.c      ****                         else
3014:../uvc.c      ****                         {
3015:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3016:../uvc.c      ****                         }
3017:../uvc.c      ****                         break;
3018:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3019:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3020:../uvc.c      ****                                 glCommitCtrl, &readCount);
3021:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3022:../uvc.c      ****                         {
3023:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3024:../uvc.c      ****                             {
3025:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3026:../uvc.c      ****                                    active data structure. */
3027:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3028:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3029:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3030:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3031:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3032:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3033:../uvc.c      ****                             }
3034:../uvc.c      ****                         }
3035:../uvc.c      ****                         break;
3036:../uvc.c      ****                     default:
3037:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3038:../uvc.c      ****                         break;
3039:../uvc.c      ****                 }
3040:../uvc.c      ****                 break;
3041:../uvc.c      **** 
3042:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3043:../uvc.c      ****                 switch (bRequest)
3044:../uvc.c      ****                 {
3045:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3046:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3047:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3048:../uvc.c      ****                         break;
3049:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3050:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3051:../uvc.c      ****                         glEp0Buffer[1] = 0;
3052:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3053:../uvc.c      ****                         break;
3054:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3055:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3056:../uvc.c      ****                         {
3057:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3058:../uvc.c      ****                         }
3059:../uvc.c      ****                         else
3060:../uvc.c      ****                         {
3061:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3062:../uvc.c      ****                         }
3063:../uvc.c      ****                         break;
3064:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3065:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3066:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3067:../uvc.c      ****                            */
3068:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3069:../uvc.c      ****                                 glCommitCtrl, &readCount);
3070:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3071:../uvc.c      ****                         {
3072:../uvc.c      ****     #if 0
3073:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3074:../uvc.c      ****                             {
3075:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3076:../uvc.c      ****                             }
3077:../uvc.c      ****                             else
3078:../uvc.c      ****                             {
3079:../uvc.c      ****                                 SensorScaling_VGA ();
3080:../uvc.c      ****                             }
3081:../uvc.c      ****     #endif
3082:../uvc.c      ****                             /* We can start streaming video now. */
3083:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3084:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3085:../uvc.c      ****                             {
3086:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3087:../uvc.c      ****                             }
3088:../uvc.c      ****                         }
3089:../uvc.c      ****                         break;
3090:../uvc.c      **** 
3091:../uvc.c      ****                     default:
3092:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3093:../uvc.c      ****                         break;
3094:../uvc.c      ****                 }
3095:../uvc.c      ****                 break;
3096:../uvc.c      **** 
3097:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3098:../uvc.c      ****                 switch (bRequest)
3099:../uvc.c      ****                 {
3100:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3101:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3102:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3103:../uvc.c      ****                         break;
3104:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3105:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3106:../uvc.c      ****                         glEp0Buffer[1] = 0;
3107:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3108:../uvc.c      ****                         break;
3109:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3110:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3111:../uvc.c      ****                         {
3112:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3113:../uvc.c      ****                         }
3114:../uvc.c      ****                         else
3115:../uvc.c      ****                         {
3116:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3117:../uvc.c      ****                         }
3118:../uvc.c      ****                         break;
3119:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3120:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3121:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3122:../uvc.c      ****                            */
3123:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3124:../uvc.c      ****                                 glCommitCtrl, &readCount);
3125:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3126:../uvc.c      ****                         {
3127:../uvc.c      ****     #if 1
3128:../uvc.c      ****                             /* We can start still streaming video now. */
3129:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3130:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3131:../uvc.c      ****                             {
3132:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3133:../uvc.c      ****                             }
3134:../uvc.c      ****     #endif
3135:../uvc.c      ****                             stiflag = CyTrue;//set still flag
3136:../uvc.c      ****                             //stillcont = 0;
3137:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3138:../uvc.c      ****                         }else{
3139:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3140:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3141:../uvc.c      ****                         }
3142:../uvc.c      ****                         break;
3143:../uvc.c      **** 
3144:../uvc.c      ****                     default:
3145:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3146:../uvc.c      ****                         break;
3147:../uvc.c      ****                 }
3148:../uvc.c      ****                 break;
3149:../uvc.c      **** 
3150:../uvc.c      ****         default:
3151:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3152:../uvc.c      ****             break;
3153:../uvc.c      ****     }
3154:../uvc.c      **** }
3155:../uvc.c      **** 
3156:../uvc.c      **** /*
3157:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3158:../uvc.c      ****  */
3159:../uvc.c      **** void
3160:../uvc.c      **** UVCAppEP0Thread_Entry (
3161:../uvc.c      ****         uint32_t input)
3162:../uvc.c      **** {
3163:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3164:../uvc.c      ****     uint32_t eventFlag;
3165:../uvc.c      **** 	CyBool_t value;
3166:../uvc.c      **** 	CyBool_t *valueptr = &value;
3167:../uvc.c      **** 
3168:../uvc.c      **** 
3169:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3170:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3171:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3172:../uvc.c      **** 
3173:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3174:../uvc.c      **** #endif
3175:../uvc.c      **** 
3176:../uvc.c      ****     /* for interrupt status test */
3177:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3178:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3179:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3180:../uvc.c      **** 
3181:../uvc.c      ****     for (;;)
3182:../uvc.c      ****     {
3183:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3184:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3185:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3186:../uvc.c      ****         {
3187:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3188:../uvc.c      ****             if (!isUsbConnected)
3189:../uvc.c      ****             {
3190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3191:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3192:../uvc.c      ****                 {
3193:../uvc.c      ****                     isUsbConnected = CyTrue;
3194:../uvc.c      ****                 }
3195:../uvc.c      ****             }
3196:../uvc.c      **** //#ifdef DbgInfo
3197:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3198:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3199:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3200:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3201:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3202:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3203:../uvc.c      **** //#endif
3204:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3205:../uvc.c      ****             {
3206:../uvc.c      ****             	switch ((wIndex >> 8))
3207:../uvc.c      ****                 {
3208:../uvc.c      **** 
3209:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3210:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3211:../uvc.c      ****                         break;
3212:../uvc.c      **** 
3213:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3214:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3215:../uvc.c      ****                         break;
3216:../uvc.c      **** 
3217:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3218:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3219:../uvc.c      ****                         break;
3220:../uvc.c      **** 
3221:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3222:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3223:../uvc.c      ****                         break;
3224:../uvc.c      **** 
3225:../uvc.c      ****                     default:
3226:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3227:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3228:../uvc.c      ****                         break;
3229:../uvc.c      ****                 }
3230:../uvc.c      ****             }
3231:../uvc.c      **** 
3232:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3233:../uvc.c      ****             {
3234:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3235:../uvc.c      **** 
3236:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3237:../uvc.c      ****                 {
3238:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3239:../uvc.c      ****                 }
3240:../uvc.c      ****                 else
3241:../uvc.c      ****                 {
3242:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3243:../uvc.c      ****                 }
3244:../uvc.c      ****             }
3245:../uvc.c      **** 
3246:../uvc.c      ****             /* handle interrupt status event */
3247:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3248:../uvc.c      ****             {
3249:../uvc.c      **** 
3250:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3251:../uvc.c      ****             	/** preparing interrupt status data **/
3252:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3253:../uvc.c      **** 
3254:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3255:../uvc.c      **** 
3256:../uvc.c      **** #if 1 //for real button
3257:../uvc.c      **** 				if(value&&(!snapButFlag)){
3258:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3259:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3260:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3261:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3262:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3263:../uvc.c      **** 
3264:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3265:../uvc.c      **** 					interStabuf.size   = 1024;
3266:../uvc.c      **** 					interStabuf.status = 0;
3267:../uvc.c      **** 
3268:../uvc.c      **** 					interStabuf.count = 4;
3269:../uvc.c      **** 
3270:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3271:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3272:../uvc.c      **** 
3273:../uvc.c      **** 					/** send a interrupt status data **/
3274:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3275:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3276:../uvc.c      **** 					{
3277:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3278:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3279:../uvc.c      **** 					}
3280:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3281:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3282:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3283:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3284:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3285:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3286:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3287:../uvc.c      **** 
3288:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3289:../uvc.c      **** 					interStabuf.size   = 1024;
3290:../uvc.c      **** 					interStabuf.status = 0;
3291:../uvc.c      **** 
3292:../uvc.c      **** 					interStabuf.count = 4;
3293:../uvc.c      **** 
3294:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3296:../uvc.c      **** 
3297:../uvc.c      **** 					/** send a interrupt status data **/
3298:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3299:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3300:../uvc.c      **** 					{
3301:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3302:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3303:../uvc.c      **** 					}
3304:../uvc.c      **** 
3305:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3306:../uvc.c      **** 					stiflag = CyTrue;
3307:../uvc.c      **** 				}
3308:../uvc.c      **** #else			//for botton simulation
3309:../uvc.c      **** 				if(snapButFlag == 0x0f){
3310:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3311:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3312:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3313:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3314:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3315:../uvc.c      **** 
3316:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3317:../uvc.c      **** 					interStabuf.size   = 1024;
3318:../uvc.c      **** 					interStabuf.status = 0;
3319:../uvc.c      **** 
3320:../uvc.c      **** 					interStabuf.count = 4;
3321:../uvc.c      **** 
3322:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3323:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3324:../uvc.c      **** 
3325:../uvc.c      **** 					/** send a interrupt status data **/
3326:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3327:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3328:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3329:../uvc.c      **** 					{
3330:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3331:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3332:../uvc.c      **** 					}
3333:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3334:../uvc.c      **** 
3335:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3336:../uvc.c      **** 				}else if(!snapButFlag){
3337:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3338:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3339:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3340:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3341:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3342:../uvc.c      **** 
3343:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3344:../uvc.c      **** 					interStabuf.size   = 1024;
3345:../uvc.c      **** 					interStabuf.status = 0;
3346:../uvc.c      **** 
3347:../uvc.c      **** 					interStabuf.count = 4;
3348:../uvc.c      **** 
3349:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3350:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3351:../uvc.c      **** 
3352:../uvc.c      **** 					/** send a interrupt status data **/
3353:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3354:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3355:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3356:../uvc.c      **** 					{
3357:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3358:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3359:../uvc.c      **** 					}
3360:../uvc.c      **** 
3361:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3362:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3363:../uvc.c      **** 				}
3364:../uvc.c      **** #endif
3365:../uvc.c      **** 
3366:../uvc.c      ****             }
3367:../uvc.c      **** 
3368:../uvc.c      **** 
3369:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3370:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3371:../uvc.c      ****             {
3372:../uvc.c      ****                 /* Get the command buffer */
3373:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3374:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3375:../uvc.c      ****                 {
3376:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3377:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3378:../uvc.c      ****                 }
3379:../uvc.c      **** 
3380:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3381:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3382:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3383:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3384:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3385:../uvc.c      ****                  * register value high byte and register value low byte.
3386:../uvc.c      ****                  */
3387:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3388:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3389:../uvc.c      ****                 {
3390:../uvc.c      ****                     if (dmaInfo.count == 3)
3391:../uvc.c      ****                     {
3392:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3393:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3394:../uvc.c      ****                         dmaInfo.count = 3;
3395:../uvc.c      ****                     }
3396:../uvc.c      ****                     else if (dmaInfo.count == 4)
3397:../uvc.c      ****                     {
3398:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3399:../uvc.c      ****                         {
3400:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3401:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3402:../uvc.c      ****                         }
3403:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3404:../uvc.c      ****                     }
3405:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3406:../uvc.c      ****                 }
3407:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3408:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3409:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3410:../uvc.c      ****                  */
3411:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3412:../uvc.c      ****                 {
3413:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3414:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3415:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3416:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3417:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3418:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3419:../uvc.c      ****                         	break;
3420:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3421:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3422:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3423:../uvc.c      ****                         	break;*/
3424:../uvc.c      ****                     dmaInfo.count -= 2;
3425:../uvc.c      ****                 }
3426:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3427:../uvc.c      ****                 else
3428:../uvc.c      ****                 {
3429:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3430:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3431:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3432:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3433:../uvc.c      ****                 }
3434:../uvc.c      **** 
3435:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3436:../uvc.c      ****                 dmaInfo.size   = 1024;
3437:../uvc.c      ****                 dmaInfo.status = 0;
3438:../uvc.c      **** 
3439:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3440:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3441:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3442:../uvc.c      ****                 {
3443:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3444:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3445:../uvc.c      ****                 }
3446:../uvc.c      **** 
3447:../uvc.c      ****                 /* Wait until the response has gone out. */
3448:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3449:../uvc.c      **** 
3450:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3451:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3452:../uvc.c      ****                 {
3453:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3454:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3455:../uvc.c      ****                 }
3456:../uvc.c      ****             }
3457:../uvc.c      **** #endif
3458:../uvc.c      ****         }
3459:../uvc.c      ****         /* Allow other ready threads to run. */
3460:../uvc.c      ****         CyU3PThreadRelinquish ();
3461:../uvc.c      ****     }
3462:../uvc.c      **** }
3463:../uvc.c      **** 
3464:../uvc.c      **** /*
3465:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3466:../uvc.c      ****  * added 10/2013
3467:../uvc.c      ****  */
3468:../uvc.c      **** /*
3469:../uvc.c      **** static uint8_t timeDelay[64] = {
3470:../uvc.c      **** 
3471:../uvc.c      **** };
3472:../uvc.c      **** */
3473:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3473 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3474:../uvc.c      **** 
3475:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3476:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3477:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3478:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3479:../uvc.c      **** 	VdstateDes *lcStaDes;
3480:../uvc.c      **** 	uint32_t flag = 0;
3481:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3482:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3483:../uvc.c      **** 	uint8_t i;
3484:../uvc.c      **** 	uint16_t delaytime;
3485:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3486:../uvc.c      **** 
3487:../uvc.c      **** #if 0 //for test the command queue
3488:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3489:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3490:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3491:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3492:../uvc.c      **** 		lcCmdDes += 1;
3493:../uvc.c      **** 	}
3494:../uvc.c      **** #endif
3495:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3496:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3496 0
  36 0004 10229FE5 		ldr	r2, .L22
3480:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3480 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3473:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3473 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3496 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3480:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3480 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3496 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3497:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3497 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3498:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3498 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3499:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3499 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3500:../uvc.c      **** 
3501:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3501 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3502:../uvc.c      ****         /* Allow other ready threads to run. */
3503:../uvc.c      **** 
3504:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3504 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3501:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3501 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3505:../uvc.c      **** 	}
3506:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3506 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3507:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3508:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3509:../uvc.c      **** 	//CyU3PThreadSleep(100);
3510:../uvc.c      **** 	//SetCurCmd();
3511:../uvc.c      **** 	/*********** the loop of the thread ***********/
3512:../uvc.c      **** 	for(;;){
3513:../uvc.c      **** 
3514:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3514 0
 101 0098 0060E0E3 		mvn	r6, #0
3515:../uvc.c      **** /*  // for test GPIO output
3516:../uvc.c      **** 		if(trigger)
3517:../uvc.c      **** 		{
3518:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3519:../uvc.c      **** 			{
3520:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3521:../uvc.c      **** 			}
3522:../uvc.c      **** 
3523:../uvc.c      **** 		}else{
3524:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3525:../uvc.c      **** 			{
3526:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3527:../uvc.c      **** 			}
3528:../uvc.c      **** 
3529:../uvc.c      **** 		}
3530:../uvc.c      **** */
3531:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3532:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3533:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3534:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3535:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3536:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3537:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3538:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3539:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3540:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3541:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3542:../uvc.c      **** #endif
3543:../uvc.c      **** 				}
3544:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3545:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3546:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3547:../uvc.c      **** 			}
3548:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3549:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3550:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3551:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3552:../uvc.c      **** 
3553:../uvc.c      **** 				/*
3554:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3555:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3556:../uvc.c      **** 				*/
3557:../uvc.c      **** 
3558:../uvc.c      **** 				/* find a available command */
3559:../uvc.c      **** 				i = 0;
3560:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3560 0
 103 009c 0090A0E3 		mov	r9, #0
3561:../uvc.c      **** 					i++;
3562:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3563:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3564:../uvc.c      **** 				}
3565:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3566:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3567:../uvc.c      **** 					i = lcCmdDes->curNum;
3568:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3569:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3570:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3571:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3572:../uvc.c      **** #if 1
3573:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3574:../uvc.c      **** 						case 20:
3575:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3576:../uvc.c      **** 							delaytime = 500;
3577:../uvc.c      **** 							break;
3578:../uvc.c      **** 						case 21:
3579:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3580:../uvc.c      **** 							delaytime = 500;
3581:../uvc.c      **** 							break;
3582:../uvc.c      **** 						case 22:
3583:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3584:../uvc.c      **** 							delaytime = 300;
3585:../uvc.c      **** 							break;
3586:../uvc.c      **** 						case 23:
3587:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3588:../uvc.c      **** 							delaytime = 300;
3589:../uvc.c      **** 							break;
3590:../uvc.c      **** 						default:
3591:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3592:../uvc.c      **** 							break;
3593:../uvc.c      **** 					}
3594:../uvc.c      **** #endif
3595:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3596:../uvc.c      **** 					/** timer's ticket modify **/
3597:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3598:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3599:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3600:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3601:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3602:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3603:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3604:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3605:../uvc.c      **** #endif
3606:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3607:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3608:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3609:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3610:../uvc.c      **** 						}else{
3611:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3612:../uvc.c      **** 						}
3613:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3614:../uvc.c      **** 					}else{
3615:../uvc.c      **** 						lcCmdDes->curNum ++;
3616:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3616 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3514:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3514 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3531:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3531 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3548:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3548 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3550:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3550 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3551:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3551 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3560:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3560 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3562:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3562 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3561:../uvc.c      **** 					i++;
 140              		.loc 1 3561 0
 141 00f4 011083E2 		add	r1, r3, #1
3560:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3560 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3561:../uvc.c      **** 					i++;
 144              		.loc 1 3561 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3560:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3560 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3566:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3566 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3568:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3568 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3573:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3573 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3568:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3568 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3573:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3573 0
 166 0128 14C042E2 		sub	ip, r2, #20
3568:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3568 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3569:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3569 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3570:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3570 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3571:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3571 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3573:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3573 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3587:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3587 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3589:../uvc.c      **** 							break;
 193              		.loc 1 3589 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3598:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3598 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3599:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3599 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3606:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3606 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3615:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3615 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3616 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3606:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3606 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3617:../uvc.c      **** 					}
3618:../uvc.c      **** 				}else{
3619:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3620:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3621:../uvc.c      **** 				}
3622:../uvc.c      **** 			}
3623:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3623 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3624:../uvc.c      **** /*
3625:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3626:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3627:../uvc.c      **** */
3628:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3629:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3630:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3631:../uvc.c      **** #endif
3632:../uvc.c      **** 
3633:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3634:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3635:../uvc.c      **** #if 0
3636:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3637:../uvc.c      **** 
3638:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3639:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3640:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3641:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3642:../uvc.c      **** 			    i = 0;
3643:../uvc.c      **** 				 switch(cmdCopyIdx)
3644:../uvc.c      **** 				 {
3645:../uvc.c      **** 					 case BrgtCtlID1:
3646:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3647:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3648:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3649:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3650:../uvc.c      **** 							 i++;
3651:../uvc.c      **** 						 }
3652:../uvc.c      **** 						 else{
3653:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3654:../uvc.c      **** 						 }
3655:../uvc.c      **** 
3656:../uvc.c      **** 						 CyU3PBusyWait(500);
3657:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3658:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3659:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3660:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3661:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3662:../uvc.c      **** 						 }
3663:../uvc.c      **** 						 else{
3664:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3665:../uvc.c      **** 						 }
3666:../uvc.c      **** 						 break;
3667:../uvc.c      **** 					 case HueCtlID5:
3668:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3669:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3670:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3671:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3672:../uvc.c      **** 						 }
3673:../uvc.c      **** 						 else{
3674:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3675:../uvc.c      **** 						 }
3676:../uvc.c      **** 						 break;
3677:../uvc.c      **** 					 case SaturCtlID6:
3678:../uvc.c      **** 					 case WBTLevCtlID10:
3679:../uvc.c      **** 					 default:
3680:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3681:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3682:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3683:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3684:../uvc.c      **** 						 }
3685:../uvc.c      **** 						 else{
3686:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3687:../uvc.c      **** 						 }
3688:../uvc.c      **** 						 break;
3689:../uvc.c      **** 				 }
3690:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3691:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3692:../uvc.c      **** 			}
3693:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3694:../uvc.c      **** #endif
3695:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3696:../uvc.c      **** 		/* Allow other ready threads to run. */
3697:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3698:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3698 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3699:../uvc.c      **** 		}
 224              		.loc 1 3699 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3579:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3579 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3581:../uvc.c      **** 							break;
 232              		.loc 1 3581 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3591:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3591 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3592:../uvc.c      **** 							break;
 241              		.loc 1 3592 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3575:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3575 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3577:../uvc.c      **** 							break;
 249              		.loc 1 3577 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3619:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3619 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3620:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3620 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3608:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3608 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3607:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3607 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3608:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3608 0
 269 01f0 1F005CE3 		cmp	ip, #31
3609:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3609 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3611:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3611 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3609:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3609 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3611:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3611 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3609:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3609 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3611:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3611 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3613:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3613 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2220:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2220 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2222:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2222 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2223:../uvc.c      **** }
 318              		.loc 1 2223 0
2222:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2222 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 329              		.global	CyFxUvcApplnDmaCallback
 331              	CyFxUvcApplnDmaCallback:
 332              	.LFB10:
1499:../uvc.c      **** {
 333              		.loc 1 1499 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL31:
1506:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 338              		.loc 1 1506 0
 339 0250 080051E3 		cmp	r1, #8
1499:../uvc.c      **** {
 340              		.loc 1 1499 0
 341 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 12
 344 0258 0240A0E1 		mov	r4, r2
 345              		.cfi_offset 14, -4
 346              		.cfi_offset 5, -8
 347              		.cfi_offset 4, -12
 348 025c 0CD04DE2 		sub	sp, sp, #12
 349              	.LCFI3:
 350              		.cfi_def_cfa_offset 24
1506:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 351              		.loc 1 1506 0
 352 0260 0B00000A 		beq	.L32
1538:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 353              		.loc 1 1538 0
 354 0264 100051E3 		cmp	r1, #16
 355 0268 0700001A 		bne	.L27
1540:../uvc.c      ****         consCount++;
 356              		.loc 1 1540 0
 357 026c 0C319FE5 		ldr	r3, .L34
1541:../uvc.c      ****         streamingStarted = CyTrue;
 358              		.loc 1 1541 0
 359 0270 0110A0E3 		mov	r1, #1
 360              	.LVL32:
1540:../uvc.c      ****         consCount++;
 361              		.loc 1 1540 0
 362 0274 B603D3E1 		ldrh	r0, [r3, #54]
 363              	.LVL33:
1541:../uvc.c      ****         streamingStarted = CyTrue;
 364              		.loc 1 1541 0
 365 0278 381083E5 		str	r1, [r3, #56]
1540:../uvc.c      ****         consCount++;
 366              		.loc 1 1540 0
 367 027c 01C080E0 		add	ip, r0, r1
 368 0280 0C28A0E1 		mov	r2, ip, asl #16
 369              	.LVL34:
 370 0284 2218A0E1 		mov	r1, r2, lsr #16
 371 0288 B613C3E1 		strh	r1, [r3, #54]	@ movhi
 372              	.L27:
1543:../uvc.c      **** }
 373              		.loc 1 1543 0
 374 028c 0CD08DE2 		add	sp, sp, #12
 375 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 376              	.LVL35:
 377              	.L32:
1508:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 378              		.loc 1 1508 0
 379 0294 B420D2E1 		ldrh	r2, [r2, #4]
 380 0298 E4309FE5 		ldr	r3, .L34+4
 381 029c 030052E1 		cmp	r2, r3
 382 02a0 2B00000A 		beq	.L33
1516:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 383              		.loc 1 1516 0
 384 02a4 005094E5 		ldr	r5, [r4, #0]
 385              	.LVL36:
 386              	.LBB14:
 387              	.LBB15:
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 388              		.loc 1 1248 0
 389 02a8 D8109FE5 		ldr	r1, .L34+8
 390              	.LVL37:
 391 02ac 0C0045E2 		sub	r0, r5, #12
 392              	.LVL38:
 393 02b0 0C20A0E3 		mov	r2, #12
 394 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 395              	.LVL39:
1253:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 396              		.loc 1 1253 0
 397 02b8 0B2055E5 		ldrb	r2, [r5, #-11]	@ zero_extendqisi2
 398              	.LBE15:
 399              	.LBE14:
1517:../uvc.c      ****                 pb++;
 400              		.loc 1 1517 0
 401 02bc BC309FE5 		ldr	r3, .L34
 402              	.LBB17:
 403              	.LBB16:
1253:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 404              		.loc 1 1253 0
 405 02c0 021082E3 		orr	r1, r2, #2
 406 02c4 0B1045E5 		strb	r1, [r5, #-11]
 407              	.LBE16:
 408              	.LBE17:
1517:../uvc.c      ****                 pb++;
 409              		.loc 1 1517 0
 410 02c8 BAC2D3E1 		ldrh	ip, [r3, #42]
1518:../uvc.c      ****                 pbc = input->buffer_p.count;
 411              		.loc 1 1518 0
 412 02cc B410D4E1 		ldrh	r1, [r4, #4]
1517:../uvc.c      ****                 pb++;
 413              		.loc 1 1517 0
 414 02d0 01008CE2 		add	r0, ip, #1
1522:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 415              		.loc 1 1522 0
 416 02d4 0120A0E3 		mov	r2, #1
1517:../uvc.c      ****                 pb++;
 417              		.loc 1 1517 0
 418 02d8 BA02C3E1 		strh	r0, [r3, #42]	@ movhi
1518:../uvc.c      ****                 pbc = input->buffer_p.count;
 419              		.loc 1 1518 0
 420 02dc BC12C3E1 		strh	r1, [r3, #44]	@ movhi
1522:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 421              		.loc 1 1522 0
 422 02e0 302083E5 		str	r2, [r3, #48]
 423              	.LVL40:
 424              	.L30:
1526:../uvc.c      ****             prodCount++;
 425              		.loc 1 1526 0
 426 02e4 B4E3D3E1 		ldrh	lr, [r3, #52]
1527:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 427              		.loc 1 1527 0
 428 02e8 0C2081E2 		add	r2, r1, #12
1526:../uvc.c      ****             prodCount++;
 429              		.loc 1 1526 0
 430 02ec 01C08EE2 		add	ip, lr, #1
 431 02f0 0C08A0E1 		mov	r0, ip, asl #16
 432 02f4 20E8A0E1 		mov	lr, r0, lsr #16
1527:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 433              		.loc 1 1527 0
 434 02f8 0218A0E1 		mov	r1, r2, asl #16
 435 02fc 2118A0E1 		mov	r1, r1, lsr #16
 436 0300 0020A0E3 		mov	r2, #0
 437 0304 80009FE5 		ldr	r0, .L34+12
1526:../uvc.c      ****             prodCount++;
 438              		.loc 1 1526 0
 439 0308 B4E3C3E1 		strh	lr, [r3, #52]	@ movhi
1527:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 440              		.loc 1 1527 0
 441 030c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 442              	.LVL41:
1526:../uvc.c      ****             prodCount++;
 443              		.loc 1 1526 0
 444 0310 68109FE5 		ldr	r1, .L34
1530:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 445              		.loc 1 1530 0
 446 0314 002050E2 		subs	r2, r0, #0
 447 0318 DBFFFF0A 		beq	.L27
1532:../uvc.c      ****                 prodCount--;
 448              		.loc 1 1532 0
 449 031c B403D1E1 		ldrh	r0, [r1, #52]
 450              	.LVL42:
1533:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 451              		.loc 1 1533 0
 452 0320 B430D4E1 		ldrh	r3, [r4, #4]
1532:../uvc.c      ****                 prodCount--;
 453              		.loc 1 1532 0
 454 0324 01E040E2 		sub	lr, r0, #1
 455 0328 0EC8A0E1 		mov	ip, lr, asl #16
 456 032c 2C08A0E1 		mov	r0, ip, lsr #16
 457 0330 B403C1E1 		strh	r0, [r1, #52]	@ movhi
1533:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 458              		.loc 1 1533 0
 459 0334 B4E3D1E1 		ldrh	lr, [r1, #52]
 460 0338 B6C3D1E1 		ldrh	ip, [r1, #54]
 461 033c 0400A0E3 		mov	r0, #4
 462 0340 48109FE5 		ldr	r1, .L34+16
 463 0344 00E08DE5 		str	lr, [sp, #0]
 464 0348 04C08DE5 		str	ip, [sp, #4]
 465 034c FEFFFFEB 		bl	CyU3PDebugPrint
 466              	.LVL43:
 467 0350 CDFFFFEA 		b	.L27
 468              	.LVL44:
 469              	.L33:
1510:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 470              		.loc 1 1510 0
 471 0354 00E094E5 		ldr	lr, [r4, #0]
 472              	.LBB18:
 473              	.LBB19:
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 474              		.loc 1 1248 0
 475 0358 28109FE5 		ldr	r1, .L34+8
 476              	.LVL45:
 477 035c 0C004EE2 		sub	r0, lr, #12
 478              	.LVL46:
 479 0360 0C20A0E3 		mov	r2, #12
 480 0364 FEFFFFEB 		bl	CyU3PMemCopy
 481              	.LVL47:
 482              	.LBE19:
 483              	.LBE18:
1511:../uvc.c      ****                 fb++;
 484              		.loc 1 1511 0
 485 0368 10309FE5 		ldr	r3, .L34
 486 036c B410D4E1 		ldrh	r1, [r4, #4]
 487 0370 B8C2D3E1 		ldrh	ip, [r3, #40]
 488 0374 01008CE2 		add	r0, ip, #1
 489 0378 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 490 037c D8FFFFEA 		b	.L30
 491              	.L35:
 492              		.align	2
 493              	.L34:
 494 0380 00000000 		.word	.LANCHOR0
 495 0384 F03F0000 		.word	16368
 496 0388 80040000 		.word	.LANCHOR1+1152
 497 038c 00000000 		.word	glChHandleUVCStream
 498 0390 38000000 		.word	.LC2
 499              		.cfi_endproc
 500              	.LFE10:
 502              		.align	2
 504              	CyFxUVCApplnUSBEventCB:
 505              	.LFB8:
1302:../uvc.c      **** {
 506              		.loc 1 1302 0
 507              		.cfi_startproc
 508              		@ args = 0, pretend = 0, frame = 8
 509              		@ frame_needed = 0, uses_anonymous_args = 0
 510              	.LVL48:
1303:../uvc.c      ****     switch (evtype)
 511              		.loc 1 1303 0
 512 0394 020050E3 		cmp	r0, #2
1302:../uvc.c      **** {
 513              		.loc 1 1302 0
 514 0398 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 515              	.LCFI4:
 516              		.cfi_def_cfa_offset 16
 517 039c 0130A0E1 		mov	r3, r1
 518 03a0 10D04DE2 		sub	sp, sp, #16
 519              	.LCFI5:
 520              		.cfi_def_cfa_offset 32
1302:../uvc.c      **** {
 521              		.loc 1 1302 0
 522 03a4 0040A0E1 		mov	r4, r0
 523              		.cfi_offset 14, -4
 524              		.cfi_offset 6, -8
 525              		.cfi_offset 5, -12
 526              		.cfi_offset 4, -16
1303:../uvc.c      ****     switch (evtype)
 527              		.loc 1 1303 0
 528 03a8 3600000A 		beq	.L39
 529 03ac 040050E3 		cmp	r0, #4
 530 03b0 1F00000A 		beq	.L40
 531 03b4 010050E3 		cmp	r0, #1
 532 03b8 0100000A 		beq	.L42
 533              	.LVL49:
 534              	.L36:
1339:../uvc.c      **** }
 535              		.loc 1 1339 0
 536 03bc 10D08DE2 		add	sp, sp, #16
 537 03c0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 538              	.LVL50:
 539              	.L42:
1324:../uvc.c      ****             gpif_initialized = 0;
 540              		.loc 1 1324 0
 541 03c4 28519FE5 		ldr	r5, .L43
1322:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 542              		.loc 1 1322 0
 543 03c8 0020A0E1 		mov	r2, r0
 544 03cc 24119FE5 		ldr	r1, .L43+4
 545              	.LVL51:
 546 03d0 0400A0E3 		mov	r0, #4
 547              	.LVL52:
 548 03d4 FEFFFFEB 		bl	CyU3PDebugPrint
1323:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 549              		.loc 1 1323 0
 550 03d8 0400A0E1 		mov	r0, r4
 551 03dc FEFFFFEB 		bl	CyU3PGpifDisable
1324:../uvc.c      ****             gpif_initialized = 0;
 552              		.loc 1 1324 0
 553 03e0 00C0A0E3 		mov	ip, #0
 554              	.LBB26:
 555              	.LBB27:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 556              		.loc 1 1286 0
 557 03e4 0410A0E1 		mov	r1, r4
 558 03e8 0500A0E1 		mov	r0, r5
 559 03ec 0220A0E3 		mov	r2, #2
 560 03f0 0C308DE2 		add	r3, sp, #12
 561              	.LBE27:
 562              	.LBE26:
1324:../uvc.c      ****             gpif_initialized = 0;
 563              		.loc 1 1324 0
 564 03f4 3CC085E5 		str	ip, [r5, #60]
1325:../uvc.c      ****             isUsbConnected = CyFalse;
 565              		.loc 1 1325 0
 566 03f8 40C085E5 		str	ip, [r5, #64]
1326:../uvc.c      ****             streamingStarted = CyFalse;
 567              		.loc 1 1326 0
 568 03fc 38C085E5 		str	ip, [r5, #56]
 569              	.LBB29:
 570              	.LBB28:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 571              		.loc 1 1286 0
 572 0400 00C08DE5 		str	ip, [sp, #0]
 573 0404 FEFFFFEB 		bl	_txe_event_flags_get
 574 0408 004050E2 		subs	r4, r0, #0
 575 040c EAFFFF1A 		bne	.L36
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 576              		.loc 1 1289 0
 577 0410 0110E0E3 		mvn	r1, #1
 578 0414 0220A0E3 		mov	r2, #2
 579 0418 0500A0E1 		mov	r0, r5
 580              	.L41:
 581 041c FEFFFFEB 		bl	_txe_event_flags_set
1292:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 582              		.loc 1 1292 0
 583 0420 0500A0E1 		mov	r0, r5
 584 0424 0210A0E3 		mov	r1, #2
 585 0428 0420A0E1 		mov	r2, r4
 586 042c FEFFFFEB 		bl	_txe_event_flags_set
 587 0430 E1FFFFEA 		b	.L36
 588              	.LVL53:
 589              	.L40:
 590              	.LBE28:
 591              	.LBE29:
1308:../uvc.c      ****             gpif_initialized = 0;
 592              		.loc 1 1308 0
 593 0434 B8509FE5 		ldr	r5, .L43
1306:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 594              		.loc 1 1306 0
 595 0438 BC109FE5 		ldr	r1, .L43+8
 596              	.LVL54:
 597 043c 0020A0E1 		mov	r2, r0
 598 0440 FEFFFFEB 		bl	CyU3PDebugPrint
 599              	.LVL55:
1307:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 600              		.loc 1 1307 0
 601 0444 0100A0E3 		mov	r0, #1
 602 0448 FEFFFFEB 		bl	CyU3PGpifDisable
1308:../uvc.c      ****             gpif_initialized = 0;
 603              		.loc 1 1308 0
 604 044c 00C0A0E3 		mov	ip, #0
 605              	.LBB30:
 606              	.LBB31:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 607              		.loc 1 1286 0
 608 0450 0110A0E3 		mov	r1, #1
 609 0454 0220A0E3 		mov	r2, #2
 610 0458 0500A0E1 		mov	r0, r5
 611 045c 0C308DE2 		add	r3, sp, #12
 612              	.LBE31:
 613              	.LBE30:
1308:../uvc.c      ****             gpif_initialized = 0;
 614              		.loc 1 1308 0
 615 0460 3CC085E5 		str	ip, [r5, #60]
1309:../uvc.c      ****             streamingStarted = CyFalse;
 616              		.loc 1 1309 0
 617 0464 38C085E5 		str	ip, [r5, #56]
 618              	.LBB33:
 619              	.LBB32:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 620              		.loc 1 1286 0
 621 0468 00C08DE5 		str	ip, [sp, #0]
 622 046c FEFFFFEB 		bl	_txe_event_flags_get
 623 0470 004050E2 		subs	r4, r0, #0
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 624              		.loc 1 1289 0
 625 0474 0500A001 		moveq	r0, r5
 626 0478 0110E003 		mvneq	r1, #1
 627 047c 0220A003 		moveq	r2, #2
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 628              		.loc 1 1286 0
 629 0480 CDFFFF1A 		bne	.L36
 630 0484 E4FFFFEA 		b	.L41
 631              	.LVL56:
 632              	.L39:
 633              	.LBE32:
 634              	.LBE33:
1316:../uvc.c      ****             gpif_initialized = 0;
 635              		.loc 1 1316 0
 636 0488 64509FE5 		ldr	r5, .L43
1314:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 637              		.loc 1 1314 0
 638 048c 0020A0E1 		mov	r2, r0
 639 0490 68109FE5 		ldr	r1, .L43+12
 640              	.LVL57:
 641 0494 0400A0E3 		mov	r0, #4
 642              	.LVL58:
 643 0498 FEFFFFEB 		bl	CyU3PDebugPrint
1315:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 644              		.loc 1 1315 0
 645 049c 0100A0E3 		mov	r0, #1
 646 04a0 FEFFFFEB 		bl	CyU3PGpifDisable
1316:../uvc.c      ****             gpif_initialized = 0;
 647              		.loc 1 1316 0
 648 04a4 0060A0E3 		mov	r6, #0
 649              	.LBB34:
 650              	.LBB35:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 651              		.loc 1 1286 0
 652 04a8 0500A0E1 		mov	r0, r5
 653 04ac 0110A0E3 		mov	r1, #1
 654 04b0 0420A0E1 		mov	r2, r4
 655 04b4 0C308DE2 		add	r3, sp, #12
 656              	.LBE35:
 657              	.LBE34:
1316:../uvc.c      ****             gpif_initialized = 0;
 658              		.loc 1 1316 0
 659 04b8 3C6085E5 		str	r6, [r5, #60]
1317:../uvc.c      ****             streamingStarted = CyFalse;
 660              		.loc 1 1317 0
 661 04bc 386085E5 		str	r6, [r5, #56]
 662              	.LBB37:
 663              	.LBB36:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 664              		.loc 1 1286 0
 665 04c0 00608DE5 		str	r6, [sp, #0]
 666 04c4 FEFFFFEB 		bl	_txe_event_flags_get
 667 04c8 006050E2 		subs	r6, r0, #0
 668 04cc BAFFFF1A 		bne	.L36
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 669              		.loc 1 1289 0
 670 04d0 0420A0E1 		mov	r2, r4
 671 04d4 0500A0E1 		mov	r0, r5
 672 04d8 0110E0E3 		mvn	r1, #1
 673 04dc FEFFFFEB 		bl	_txe_event_flags_set
1292:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 674              		.loc 1 1292 0
 675 04e0 0500A0E1 		mov	r0, r5
 676 04e4 0410A0E1 		mov	r1, r4
 677 04e8 0620A0E1 		mov	r2, r6
 678 04ec FEFFFFEB 		bl	_txe_event_flags_set
 679 04f0 B1FFFFEA 		b	.L36
 680              	.L44:
 681              		.align	2
 682              	.L43:
 683 04f4 00000000 		.word	.LANCHOR0
 684 04f8 C8000000 		.word	.LC5
 685 04fc 84000000 		.word	.LC3
 686 0500 A4000000 		.word	.LC4
 687              	.LBE36:
 688              	.LBE37:
 689              		.cfi_endproc
 690              	.LFE8:
 692              		.align	2
 694              	CyFxUVCApplnUSBSetupCB:
 695              	.LFB9:
1347:../uvc.c      **** {
 696              		.loc 1 1347 0
 697              		.cfi_startproc
 698              		@ args = 0, pretend = 0, frame = 8
 699              		@ frame_needed = 0, uses_anonymous_args = 0
 700              	.LVL59:
1352:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 701              		.loc 1 1352 0
 702 0504 C0329FE5 		ldr	r3, .L70
1347:../uvc.c      **** {
 703              		.loc 1 1347 0
 704 0508 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 705              	.LCFI6:
 706              		.cfi_def_cfa_offset 24
1353:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 707              		.loc 1 1353 0
 708 050c BCC29FE5 		ldr	ip, .L70+4
1352:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 709              		.loc 1 1352 0
 710 0510 FF4000E2 		and	r4, r0, #255
 711              		.cfi_offset 14, -4
 712              		.cfi_offset 8, -8
 713              		.cfi_offset 7, -12
 714              		.cfi_offset 6, -16
 715              		.cfi_offset 5, -20
 716              		.cfi_offset 4, -24
1353:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 717              		.loc 1 1353 0
 718 0514 FF8C00E2 		and	r8, r0, #65280
1354:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 719              		.loc 1 1354 0
 720 0518 2078A0E1 		mov	r7, r0, lsr #16
1352:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 721              		.loc 1 1352 0
 722 051c 0040C3E5 		strb	r4, [r3, #0]
1354:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 723              		.loc 1 1354 0
 724 0520 AC229FE5 		ldr	r2, .L70+8
1355:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 725              		.loc 1 1355 0
 726 0524 AC029FE5 		ldr	r0, .L70+12
 727              	.LVL60:
1356:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 728              		.loc 1 1356 0
 729 0528 AC329FE5 		ldr	r3, .L70+16
1355:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 730              		.loc 1 1355 0
 731 052c 0158A0E1 		mov	r5, r1, asl #16
1353:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 732              		.loc 1 1353 0
 733 0530 2884A0E1 		mov	r8, r8, lsr #8
1355:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 734              		.loc 1 1355 0
 735 0534 2558A0E1 		mov	r5, r5, lsr #16
1356:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 736              		.loc 1 1356 0
 737 0538 2118A0E1 		mov	r1, r1, lsr #16
 738              	.LVL61:
1359:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1359 0
 740 053c 020054E3 		cmp	r4, #2
1347:../uvc.c      **** {
 741              		.loc 1 1347 0
 742 0540 10D04DE2 		sub	sp, sp, #16
 743              	.LCFI7:
 744              		.cfi_def_cfa_offset 40
1353:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 745              		.loc 1 1353 0
 746 0544 0080CCE5 		strb	r8, [ip, #0]
1354:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 747              		.loc 1 1354 0
 748 0548 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1355:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 749              		.loc 1 1355 0
 750 054c B050C0E1 		strh	r5, [r0, #0]	@ movhi
1356:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 751              		.loc 1 1356 0
 752 0550 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1359:../uvc.c      ****     switch (bmReqType)
 753              		.loc 1 1359 0
 754 0554 4F00000A 		beq	.L48
 755 0558 0600009A 		bls	.L66
 756 055c 210054E3 		cmp	r4, #33
 757 0560 3A00000A 		beq	.L49
 758 0564 A10054E3 		cmp	r4, #161
 759 0568 3800000A 		beq	.L49
 760              	.L63:
1348:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 761              		.loc 1 1348 0
 762 056c 0000A0E3 		mov	r0, #0
 763              	.LVL62:
 764              	.L46:
1486:../uvc.c      **** }
 765              		.loc 1 1486 0
 766 0570 10D08DE2 		add	sp, sp, #16
 767 0574 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 768              	.LVL63:
 769              	.L66:
1359:../uvc.c      ****     switch (bmReqType)
 770              		.loc 1 1359 0
 771 0578 010054E3 		cmp	r4, #1
 772 057c FAFFFF1A 		bne	.L63
1399:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 773              		.loc 1 1399 0
 774 0580 0B0058E3 		cmp	r8, #11
 775 0584 F8FFFF1A 		bne	.L63
1403:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 776              		.loc 1 1403 0
 777 0588 010055E3 		cmp	r5, #1
 778 058c F6FFFF1A 		bne	.L63
1403:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 779              		.loc 1 1403 0 is_stmt 0 discriminator 1
 780 0590 000057E3 		cmp	r7, #0
 781 0594 F4FFFF1A 		bne	.L63
1408:../uvc.c      ****                     gpif_initialized = 0;
 782              		.loc 1 1408 0 is_stmt 1
 783 0598 40429FE5 		ldr	r4, .L70+20
1406:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 784              		.loc 1 1406 0
 785 059c 40129FE5 		ldr	r1, .L70+24
 786 05a0 0400A0E3 		mov	r0, #4
 787 05a4 FEFFFFEB 		bl	CyU3PDebugPrint
1407:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 788              		.loc 1 1407 0
 789 05a8 0500A0E1 		mov	r0, r5
 790 05ac FEFFFFEB 		bl	CyU3PGpifDisable
1411:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 791              		.loc 1 1411 0
 792 05b0 0510A0E1 		mov	r1, r5
 793 05b4 8300A0E3 		mov	r0, #131
1408:../uvc.c      ****                     gpif_initialized = 0;
 794              		.loc 1 1408 0
 795 05b8 3C7084E5 		str	r7, [r4, #60]
1409:../uvc.c      ****                     streamingStarted = CyFalse;
 796              		.loc 1 1409 0
 797 05bc 387084E5 		str	r7, [r4, #56]
1411:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 798              		.loc 1 1411 0
 799 05c0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1412:../uvc.c      ****                     CyU3PBusyWait (100);
 800              		.loc 1 1412 0
 801 05c4 6400A0E3 		mov	r0, #100
 802 05c8 FEFFFFEB 		bl	CyU3PBusyWait
1415:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 803              		.loc 1 1415 0
 804 05cc 14029FE5 		ldr	r0, .L70+28
 805 05d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1416:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 806              		.loc 1 1416 0
 807 05d4 8300A0E3 		mov	r0, #131
 808 05d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1417:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 809              		.loc 1 1417 0
 810 05dc 0710A0E1 		mov	r1, r7
 811 05e0 8300A0E3 		mov	r0, #131
 812 05e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1418:../uvc.c      ****                     CyU3PBusyWait (100);
 813              		.loc 1 1418 0
 814 05e8 6400A0E3 		mov	r0, #100
 815 05ec FEFFFFEB 		bl	CyU3PBusyWait
1421:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 816              		.loc 1 1421 0
 817 05f0 0710A0E1 		mov	r1, r7
 818 05f4 0520A0E1 		mov	r2, r5
 819 05f8 8300A0E3 		mov	r0, #131
 820 05fc FEFFFFEB 		bl	CyU3PUsbStall
 821              	.LVL64:
1424:../uvc.c      ****                     CyU3PUsbAckSetup ();
 822              		.loc 1 1424 0
 823 0600 FEFFFFEB 		bl	CyU3PUsbAckSetup
1426:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 824              		.loc 1 1426 0
 825 0604 445084E5 		str	r5, [r4, #68]
 826              	.LBB42:
 827              	.LBB43:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 828              		.loc 1 1286 0
 829 0608 0400A0E1 		mov	r0, r4
 830 060c 0510A0E1 		mov	r1, r5
 831 0610 0220A0E3 		mov	r2, #2
 832 0614 0C308DE2 		add	r3, sp, #12
 833 0618 00708DE5 		str	r7, [sp, #0]
 834 061c FEFFFFEB 		bl	_txe_event_flags_get
 835 0620 006050E2 		subs	r6, r0, #0
 836 0624 2E00001A 		bne	.L61
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 837              		.loc 1 1289 0
 838 0628 0110E0E3 		mvn	r1, #1
 839 062c 0220A0E3 		mov	r2, #2
 840 0630 0400A0E1 		mov	r0, r4
 841 0634 FEFFFFEB 		bl	_txe_event_flags_set
1292:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 842              		.loc 1 1292 0
 843 0638 0400A0E1 		mov	r0, r4
 844 063c 0210A0E3 		mov	r1, #2
 845 0640 0620A0E1 		mov	r2, r6
 846 0644 FEFFFFEB 		bl	_txe_event_flags_set
1422:../uvc.c      ****                     uvcHandleReq = CyTrue;
 847              		.loc 1 1422 0
 848 0648 0500A0E1 		mov	r0, r5
 849 064c C7FFFFEA 		b	.L46
 850              	.LVL65:
 851              	.L49:
 852              	.LBE43:
 853              	.LBE42:
1364:../uvc.c      ****             switch (wIndex & 0xFF)
 854              		.loc 1 1364 0
 855 0650 FF5015E2 		ands	r5, r5, #255
 856 0654 1A00001A 		bne	.L67
 857              	.LVL66:
1369:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 858              		.loc 1 1369 0
 859 0658 0520A0E1 		mov	r2, r5
 860 065c 7C019FE5 		ldr	r0, .L70+20
 861 0660 0410A0E3 		mov	r1, #4
 862 0664 FEFFFFEB 		bl	_txe_event_flags_set
 863              	.LVL67:
1371:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 864              		.loc 1 1371 0
 865 0668 002050E2 		subs	r2, r0, #0
1368:../uvc.c      ****                         uvcHandleReq = CyTrue;
 866              		.loc 1 1368 0
 867 066c 0100A003 		moveq	r0, #1
 868              	.LVL68:
1371:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 869              		.loc 1 1371 0
 870 0670 BEFFFF0A 		beq	.L46
1373:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 871              		.loc 1 1373 0
 872 0674 70119FE5 		ldr	r1, .L70+32
 873 0678 0400A0E3 		mov	r0, #4
 874 067c FEFFFFEB 		bl	CyU3PDebugPrint
 875              	.LVL69:
1374:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 876              		.loc 1 1374 0
 877 0680 0500A0E1 		mov	r0, r5
 878 0684 0110A0E3 		mov	r1, #1
 879 0688 0520A0E1 		mov	r2, r5
 880 068c FEFFFFEB 		bl	CyU3PUsbStall
1368:../uvc.c      ****                         uvcHandleReq = CyTrue;
 881              		.loc 1 1368 0
 882 0690 0100A0E3 		mov	r0, #1
 883 0694 B5FFFFEA 		b	.L46
 884              	.LVL70:
 885              	.L48:
1434:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 886              		.loc 1 1434 0
 887 0698 010058E3 		cmp	r8, #1
 888 069c B2FFFF1A 		bne	.L63
1436:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 889              		.loc 1 1436 0
 890 06a0 830055E3 		cmp	r5, #131
 891 06a4 B0FFFF1A 		bne	.L63
1442:../uvc.c      ****                     if (streamingStarted == CyTrue)
 892              		.loc 1 1442 0
 893 06a8 30719FE5 		ldr	r7, .L70+20
 894 06ac 386097E5 		ldr	r6, [r7, #56]
 895 06b0 010056E3 		cmp	r6, #1
 896 06b4 1500000A 		beq	.L68
 897              	.LVL71:
1474:../uvc.c      ****                         CyU3PUsbAckSetup ();
 898              		.loc 1 1474 0
 899 06b8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1473:../uvc.c      ****                         uvcHandleReq = CyTrue;
 900              		.loc 1 1473 0
 901 06bc 0800A0E1 		mov	r0, r8
 902 06c0 AAFFFFEA 		b	.L46
 903              	.LVL72:
 904              	.L67:
1364:../uvc.c      ****             switch (wIndex & 0xFF)
 905              		.loc 1 1364 0
 906 06c4 010055E3 		cmp	r5, #1
 907 06c8 A7FFFF1A 		bne	.L63
 908              	.LVL73:
1382:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 909              		.loc 1 1382 0
 910 06cc 0020A0E3 		mov	r2, #0
 911 06d0 08019FE5 		ldr	r0, .L70+20
 912 06d4 0810A0E3 		mov	r1, #8
 913 06d8 FEFFFFEB 		bl	_txe_event_flags_set
 914              	.LVL74:
1384:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 915              		.loc 1 1384 0
 916 06dc 002050E2 		subs	r2, r0, #0
 917 06e0 0100001A 		bne	.L69
 918              	.LVL75:
 919              	.L61:
 920              	.LBB45:
 921              	.LBB44:
1422:../uvc.c      ****                     uvcHandleReq = CyTrue;
 922              		.loc 1 1422 0
 923 06e4 0500A0E1 		mov	r0, r5
 924 06e8 A0FFFFEA 		b	.L46
 925              	.LVL76:
 926              	.L69:
 927              	.LBE44:
 928              	.LBE45:
1387:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 929              		.loc 1 1387 0
 930 06ec FC109FE5 		ldr	r1, .L70+36
 931 06f0 0400A0E3 		mov	r0, #4
 932              	.LVL77:
 933 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 934              	.LVL78:
1388:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 935              		.loc 1 1388 0
 936 06f8 0000A0E3 		mov	r0, #0
 937 06fc 0510A0E1 		mov	r1, r5
 938 0700 0020A0E1 		mov	r2, r0
 939 0704 FEFFFFEB 		bl	CyU3PUsbStall
1381:../uvc.c      ****                         uvcHandleReq = CyTrue;
 940              		.loc 1 1381 0
 941 0708 0500A0E1 		mov	r0, r5
 942 070c 97FFFFEA 		b	.L46
 943              	.LVL79:
 944              	.L68:
1444:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 945              		.loc 1 1444 0
 946 0710 DC109FE5 		ldr	r1, .L70+40
 947 0714 0400A0E3 		mov	r0, #4
 948 0718 FEFFFFEB 		bl	CyU3PDebugPrint
1448:../uvc.c      ****                         gpif_initialized = 0;
 949              		.loc 1 1448 0
 950 071c 0080A0E3 		mov	r8, #0
1447:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 951              		.loc 1 1447 0
 952 0720 0600A0E1 		mov	r0, r6
 953 0724 FEFFFFEB 		bl	CyU3PGpifDisable
1452:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 954              		.loc 1 1452 0
 955 0728 0610A0E1 		mov	r1, r6
 956 072c 0500A0E1 		mov	r0, r5
1448:../uvc.c      ****                         gpif_initialized = 0;
 957              		.loc 1 1448 0
 958 0730 3C8087E5 		str	r8, [r7, #60]
1449:../uvc.c      ****                         streamingStarted = CyFalse;
 959              		.loc 1 1449 0
 960 0734 388087E5 		str	r8, [r7, #56]
1452:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 961              		.loc 1 1452 0
 962 0738 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1453:../uvc.c      ****                         CyU3PBusyWait (100);
 963              		.loc 1 1453 0
 964 073c 6400A0E3 		mov	r0, #100
 965 0740 FEFFFFEB 		bl	CyU3PBusyWait
1456:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 966              		.loc 1 1456 0
 967 0744 9C009FE5 		ldr	r0, .L70+28
 968 0748 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1457:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 969              		.loc 1 1457 0
 970 074c 0500A0E1 		mov	r0, r5
 971 0750 FEFFFFEB 		bl	CyU3PUsbFlushEp
1458:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 972              		.loc 1 1458 0
 973 0754 0810A0E1 		mov	r1, r8
 974 0758 0500A0E1 		mov	r0, r5
 975 075c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1459:../uvc.c      ****                         CyU3PBusyWait (100);
 976              		.loc 1 1459 0
 977 0760 6400A0E3 		mov	r0, #100
 978 0764 FEFFFFEB 		bl	CyU3PBusyWait
1462:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 979              		.loc 1 1462 0
 980 0768 0810A0E1 		mov	r1, r8
 981 076c 0620A0E1 		mov	r2, r6
 982 0770 0500A0E1 		mov	r0, r5
 983 0774 FEFFFFEB 		bl	CyU3PUsbStall
 984              	.LVL80:
1466:../uvc.c      ****                         CyU3PUsbAckSetup ();
 985              		.loc 1 1466 0
 986 0778 FEFFFFEB 		bl	CyU3PUsbAckSetup
1468:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 987              		.loc 1 1468 0
 988 077c 446087E5 		str	r6, [r7, #68]
 989              	.LBB46:
 990              	.LBB47:
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 991              		.loc 1 1286 0
 992 0780 0700A0E1 		mov	r0, r7
 993 0784 0610A0E1 		mov	r1, r6
 994 0788 0420A0E1 		mov	r2, r4
 995 078c 0C308DE2 		add	r3, sp, #12
 996 0790 00808DE5 		str	r8, [sp, #0]
 997 0794 FEFFFFEB 		bl	_txe_event_flags_get
 998 0798 005050E2 		subs	r5, r0, #0
1464:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1464 0
 1000 079c 0600A011 		movne	r0, r6
1286:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1001              		.loc 1 1286 0
 1002 07a0 72FFFF1A 		bne	.L46
1289:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1003              		.loc 1 1289 0
 1004 07a4 0110E0E3 		mvn	r1, #1
 1005 07a8 0420A0E1 		mov	r2, r4
 1006 07ac 0700A0E1 		mov	r0, r7
 1007 07b0 FEFFFFEB 		bl	_txe_event_flags_set
1292:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1008              		.loc 1 1292 0
 1009 07b4 0700A0E1 		mov	r0, r7
 1010 07b8 0410A0E1 		mov	r1, r4
 1011 07bc 0520A0E1 		mov	r2, r5
 1012 07c0 FEFFFFEB 		bl	_txe_event_flags_set
1464:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1013              		.loc 1 1464 0
 1014 07c4 0600A0E1 		mov	r0, r6
 1015 07c8 68FFFFEA 		b	.L46
 1016              	.L71:
 1017              		.align	2
 1018              	.L70:
 1019 07cc 00000000 		.word	bmReqType
 1020 07d0 00000000 		.word	bRequest
 1021 07d4 00000000 		.word	wValue
 1022 07d8 00000000 		.word	wIndex
 1023 07dc 00000000 		.word	wLength
 1024 07e0 00000000 		.word	.LANCHOR0
 1025 07e4 54010000 		.word	.LC8
 1026 07e8 00000000 		.word	glChHandleUVCStream
 1027 07ec E8000000 		.word	.LC6
 1028 07f0 20010000 		.word	.LC7
 1029 07f4 6C010000 		.word	.LC9
 1030              	.LBE47:
 1031              	.LBE46:
 1032              		.cfi_endproc
 1033              	.LFE9:
 1035              		.align	2
 1036              		.global	CyFxGpifCB
 1038              	CyFxGpifCB:
 1039              	.LFB12:
1665:../uvc.c      **** {
 1040              		.loc 1 1665 0
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 0
 1043              		@ frame_needed = 0, uses_anonymous_args = 0
 1044              	.LVL81:
1666:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1045              		.loc 1 1666 0
 1046 07f8 010050E3 		cmp	r0, #1
1665:../uvc.c      **** {
 1047              		.loc 1 1665 0
 1048 07fc 10402DE9 		stmfd	sp!, {r4, lr}
 1049              	.LCFI8:
 1050              		.cfi_def_cfa_offset 8
1665:../uvc.c      **** {
 1051              		.loc 1 1665 0
 1052 0800 0120A0E1 		mov	r2, r1
1666:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1053              		.loc 1 1666 0
 1054 0804 1080BD18 		ldmnefd	sp!, {r4, pc}
 1055              		.cfi_offset 14, -4
 1056              		.cfi_offset 4, -8
 1057              	.LVL82:
 1058              	.LBB52:
 1059              	.LBB53:
1563:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1060              		.loc 1 1563 0
 1061 0808 CC309FE5 		ldr	r3, .L87
 1062 080c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1063 0810 030053E3 		cmp	r3, #3
 1064 0814 2100000A 		beq	.L86
1589:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1065              		.loc 1 1589 0
 1066 0818 020053E3 		cmp	r3, #2
 1067 081c 1080BD18 		ldmnefd	sp!, {r4, pc}
1591:../uvc.c      ****         switch (stateId)
 1068              		.loc 1 1591 0
 1069 0820 080041E2 		sub	r0, r1, #8
 1070              	.LVL83:
 1071 0824 0A0050E3 		cmp	r0, #10
 1072 0828 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1073 082c 230000EA 		b	.L79
 1074              	.L81:
 1075 0830 60080000 		.word	.L76
 1076 0834 C0080000 		.word	.L79
 1077 0838 C0080000 		.word	.L79
 1078 083c 5C080000 		.word	.L72
 1079 0840 C0080000 		.word	.L79
 1080 0844 C0080000 		.word	.L79
 1081 0848 C0080000 		.word	.L79
 1082 084c 98080000 		.word	.L85
 1083 0850 C0080000 		.word	.L79
 1084 0854 C0080000 		.word	.L79
 1085 0858 5C080000 		.word	.L72
 1086              	.LVL84:
 1087              	.L72:
 1088 085c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1089              	.LVL85:
 1090              	.L76:
1574:../uvc.c      ****                 socket = 0;
 1091              		.loc 1 1574 0
 1092 0860 0010A0E3 		mov	r1, #0
 1093              	.LVL86:
 1094              	.L77:
1648:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1095              		.loc 1 1648 0
 1096 0864 74009FE5 		ldr	r0, .L87+4
 1097 0868 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1098              	.LVL87:
1649:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1099              		.loc 1 1649 0
 1100 086c 002050E2 		subs	r2, r0, #0
 1101 0870 F9FFFF0A 		beq	.L72
1651:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1102              		.loc 1 1651 0
 1103 0874 0400A0E3 		mov	r0, #4
 1104              	.LVL88:
 1105 0878 64109FE5 		ldr	r1, .L87+8
 1106 087c FEFFFFEB 		bl	CyU3PDebugPrint
 1107              	.LVL89:
 1108              	.L82:
 1109              	.LBB54:
 1110              	.LBB55:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1111              		.loc 1 1273 0
 1112 0880 60109FE5 		ldr	r1, .L87+12
 1113 0884 0400A0E3 		mov	r0, #4
 1114 0888 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 1115              		.loc 1 1274 0
 1116 088c FA0FA0E3 		mov	r0, #1000
 1117 0890 FEFFFFEB 		bl	_tx_thread_sleep
 1118 0894 F9FFFFEA 		b	.L82
 1119              	.LVL90:
 1120              	.L85:
 1121              	.LBE55:
 1122              	.LBE54:
1618:../uvc.c      ****                 socket = 1;
 1123              		.loc 1 1618 0
 1124 0898 0110A0E3 		mov	r1, #1
 1125              	.LVL91:
 1126 089c F0FFFFEA 		b	.L77
 1127              	.LVL92:
 1128              	.L86:
1565:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1565 0
 1130 08a0 0B2041E2 		sub	r2, r1, #11
 1131 08a4 030052E3 		cmp	r2, #3
 1132 08a8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1133 08ac 060000EA 		b	.L75
 1134              	.L78:
 1135 08b0 60080000 		.word	.L76
 1136 08b4 98080000 		.word	.L85
 1137 08b8 5C080000 		.word	.L72
 1138 08bc 5C080000 		.word	.L72
 1139              	.LVL93:
 1140              	.L79:
1637:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1141              		.loc 1 1637 0
 1142 08c0 24109FE5 		ldr	r1, .L87+16
 1143              	.LVL94:
 1144 08c4 0100A0E3 		mov	r0, #1
 1145 08c8 FEFFFFEB 		bl	CyU3PDebugPrint
 1146              	.LVL95:
 1147              	.L75:
 1148              	.LBE53:
 1149              	.LBE52:
1672:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1150              		.loc 1 1672 0
 1151 08cc 1C109FE5 		ldr	r1, .L87+20
 1152 08d0 0400A0E3 		mov	r0, #4
1675:../uvc.c      **** }
 1153              		.loc 1 1675 0
 1154 08d4 1040BDE8 		ldmfd	sp!, {r4, lr}
1672:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1155              		.loc 1 1672 0
 1156 08d8 FEFFFFEA 		b	CyU3PDebugPrint
 1157              	.L88:
 1158              		.align	2
 1159              	.L87:
 1160 08dc 00000000 		.word	.LANCHOR0
 1161 08e0 00000000 		.word	glChHandleUVCStream
 1162 08e4 A8010000 		.word	.LC11
 1163 08e8 D8010000 		.word	.LC12
 1164 08ec 90010000 		.word	.LC10
 1165 08f0 EC010000 		.word	.LC13
 1166              		.cfi_endproc
 1167              	.LFE12:
 1169              		.align	2
 1170              		.global	I2CCmdHandler
 1172              	I2CCmdHandler:
 1173              	.LFB0:
 332:../uvc.c      **** void I2CCmdHandler(){
 1174              		.loc 1 332 0
 1175              		.cfi_startproc
 1176              		@ args = 0, pretend = 0, frame = 16
 1177              		@ frame_needed = 0, uses_anonymous_args = 0
 1178 08f4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1179              	.LCFI9:
 1180              		.cfi_def_cfa_offset 36
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1181              		.loc 1 335 0
 1182 08f8 08429FE5 		ldr	r4, .L101
 1183              		.cfi_offset 14, -4
 1184              		.cfi_offset 11, -8
 1185              		.cfi_offset 10, -12
 1186              		.cfi_offset 9, -16
 1187              		.cfi_offset 8, -20
 1188              		.cfi_offset 7, -24
 1189              		.cfi_offset 6, -28
 1190              		.cfi_offset 5, -32
 1191              		.cfi_offset 4, -36
 332:../uvc.c      **** void I2CCmdHandler(){
 1192              		.loc 1 332 0
 1193 08fc 3CD04DE2 		sub	sp, sp, #60
 1194              	.LCFI10:
 1195              		.cfi_def_cfa_offset 96
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1196              		.loc 1 340 0
 1197 0900 5310D4E5 		ldrb	r1, [r4, #83]	@ zero_extendqisi2
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1198              		.loc 1 335 0
 1199 0904 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1200              	.LVL96:
 336:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1201              		.loc 1 336 0
 1202 0908 4D60D4E5 		ldrb	r6, [r4, #77]	@ zero_extendqisi2
 1203              	.LVL97:
 337:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1204              		.loc 1 337 0
 1205 090c 5470D4E5 		ldrb	r7, [r4, #84]	@ zero_extendqisi2
 1206              	.LVL98:
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1207              		.loc 1 340 0
 1208 0910 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1209 0914 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1210 0918 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1211 091c 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1212 0920 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1213 0924 14108DE5 		str	r1, [sp, #20]
 1214 0928 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1215 092c 0400A0E3 		mov	r0, #4
 1216 0930 1C308DE5 		str	r3, [sp, #28]
 1217 0934 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1218 0938 CC119FE5 		ldr	r1, .L101+4
 1219 093c 0520A0E1 		mov	r2, r5
 1220 0940 0630A0E1 		mov	r3, r6
 1221 0944 00E08DE5 		str	lr, [sp, #0]
 1222 0948 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1223 094c 0C908DE5 		str	r9, [sp, #12]
 1224 0950 10B08DE5 		str	fp, [sp, #16]
 1225 0954 18708DE5 		str	r7, [sp, #24]
 1226 0958 20C08DE5 		str	ip, [sp, #32]
 1227 095c FEFFFFEB 		bl	CyU3PDebugPrint
 344:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1228              		.loc 1 344 0
 1229 0960 000055E3 		cmp	r5, #0
 1230 0964 1500001A 		bne	.L90
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1231              		.loc 1 346 0
 1232 0968 0F00A0E3 		mov	r0, #15
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 1233              		.loc 1 360 0
 1234 096c 020056E3 		cmp	r6, #2
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1235              		.loc 1 346 0
 1236 0970 5700C4E5 		strb	r0, [r4, #87]
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 1237              		.loc 1 360 0
 1238 0974 2500000A 		beq	.L99
 364:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1239              		.loc 1 364 0
 1240 0978 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1241 097c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1242 0980 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1243 0984 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1244 0988 34C08DE2 		add	ip, sp, #52
 1245 098c 010080E3 		orr	r0, r0, #1
 1246 0990 011081E3 		orr	r1, r1, #1
 1247 0994 00C08DE5 		str	ip, [sp, #0]
 1248 0998 FEFFFFEB 		bl	SensorRead2B
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1249              		.loc 1 365 0
 1250 099c 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 366:../uvc.c      **** 				if(CmdDataLen == 2){
 1251              		.loc 1 366 0
 1252 09a0 020057E3 		cmp	r7, #2
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1253              		.loc 1 365 0
 1254 09a4 5530C4E5 		strb	r3, [r4, #85]
 367:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1255              		.loc 1 367 0
 1256 09a8 3530DD05 		ldreqb	r3, [sp, #53]	@ zero_extendqisi2
 1257 09ac 5630C405 		streqb	r3, [r4, #86]
 1258              	.L92:
 370:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1259              		.loc 1 370 0
 1260 09b0 0020E0E3 		mvn	r2, #0
 1261 09b4 5720C4E5 		strb	r2, [r4, #87]
 1262              	.LVL99:
 1263              	.L89:
 393:../uvc.c      **** }
 1264              		.loc 1 393 0
 1265 09b8 3CD08DE2 		add	sp, sp, #60
 1266 09bc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1267              	.LVL100:
 1268              	.L90:
 374:../uvc.c      **** 	}else if(CmdType == 1){
 1269              		.loc 1 374 0
 1270 09c0 010055E3 		cmp	r5, #1
 1271 09c4 FBFFFF1A 		bne	.L89
 376:../uvc.c      **** 			if(CmdRegLen == 2){
 1272              		.loc 1 376 0
 1273 09c8 020056E3 		cmp	r6, #2
 1274 09cc 1900000A 		beq	.L100
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1275              		.loc 1 381 0
 1276 09d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1277 09d4 FE1003E2 		and	r1, r3, #254
 1278 09d8 820051E3 		cmp	r1, #130
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1279              		.loc 1 384 0
 1280 09dc 5050D415 		ldrneb	r5, [r4, #80]	@ zero_extendqisi2
 1281              	.LVL101:
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1282              		.loc 1 381 0
 1283 09e0 0200001A 		bne	.L98
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1284              		.loc 1 381 0 is_stmt 0 discriminator 1
 1285 09e4 5050D4E5 		ldrb	r5, [r4, #80]	@ zero_extendqisi2
 1286 09e8 300055E3 		cmp	r5, #48
 1287 09ec 3200000A 		beq	.L96
 1288              	.L98:
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1289              		.loc 1 384 0 is_stmt 1
 1290 09f0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1291              	.L97:
 386:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1292              		.loc 1 386 0
 1293 09f4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1294 09f8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1295 09fc 0520A0E1 		mov	r2, r5
 1296 0a00 FE0000E2 		and	r0, r0, #254
 1297 0a04 00E08DE5 		str	lr, [sp, #0]
 1298 0a08 FEFFFFEB 		bl	SensorWrite2B
 1299 0a0c E9FFFFEA 		b	.L89
 1300              	.LVL102:
 1301              	.L99:
 1302              	.LBB56:
 361:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 1303              		.loc 1 361 0
 1304 0a10 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 1305 0a14 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1306 0a18 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1307 0a1c 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1308 0a20 011082E3 		orr	r1, r2, #1
 1309 0a24 01008EE3 		orr	r0, lr, #1
 1310 0a28 0520A0E1 		mov	r2, r5
 1311 0a2c 00C08DE5 		str	ip, [sp, #0]
 1312 0a30 FEFFFFEB 		bl	SensorRead2B2
 1313 0a34 DDFFFFEA 		b	.L92
 1314              	.L100:
 1315              	.LBE56:
 378:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1316              		.loc 1 378 0
 1317 0a38 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1318 0a3c 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1319 0a40 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1320 0a44 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1321 0a48 FE0002E2 		and	r0, r2, #254
 1322 0a4c 0020A0E3 		mov	r2, #0
 1323 0a50 00E08DE5 		str	lr, [sp, #0]
 1324 0a54 FEFFFFEB 		bl	SensorWrite2B2
 1325 0a58 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1326 0a5c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1327 0a60 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1328 0a64 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1329 0a68 0020A0E3 		mov	r2, #0
 1330 0a6c FE0000E2 		and	r0, r0, #254
 1331 0a70 00C08DE5 		str	ip, [sp, #0]
 1332 0a74 FEFFFFEB 		bl	SensorWrite2B2
 1333              	.LVL103:
 1334 0a78 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1335 0a7c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1336 0a80 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1337 0a84 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1338 0a88 FE0002E2 		and	r0, r2, #254
 1339 0a8c 0020A0E3 		mov	r2, #0
 1340 0a90 00C08DE5 		str	ip, [sp, #0]
 1341 0a94 FEFFFFEB 		bl	SensorWrite2B2
 1342 0a98 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1343 0a9c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1344 0aa0 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1345 0aa4 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1346 0aa8 0020A0E3 		mov	r2, #0
 1347 0aac FE0000E2 		and	r0, r0, #254
 1348 0ab0 00C08DE5 		str	ip, [sp, #0]
 1349 0ab4 FEFFFFEB 		bl	SensorWrite2B2
 1350 0ab8 BEFFFFEA 		b	.L89
 1351              	.LVL104:
 1352              	.L96:
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1353              		.loc 1 381 0 discriminator 1
 1354 0abc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1355 0ac0 100053E3 		cmp	r3, #16
 1356 0ac4 CAFFFF1A 		bne	.L97
 382:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1357              		.loc 1 382 0
 1358 0ac8 40409FE5 		ldr	r4, .L101+8
 1359 0acc 0010E0E3 		mvn	r1, #0
 1360 0ad0 1C0094E5 		ldr	r0, [r4, #28]
 1361 0ad4 2C308DE5 		str	r3, [sp, #44]
 1362 0ad8 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1363              		.loc 1 383 0
 1364 0adc 00C0A0E3 		mov	ip, #0
 1365 0ae0 0400A0E1 		mov	r0, r4
 1366 0ae4 1710A0E3 		mov	r1, #23
 1367 0ae8 2C209DE5 		ldr	r2, [sp, #44]
 1368 0aec 0530A0E1 		mov	r3, r5
 1369 0af0 00C08DE5 		str	ip, [sp, #0]
 1370 0af4 04C08DE5 		str	ip, [sp, #4]
 1371 0af8 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1372              		.loc 1 384 0
 1373 0afc 1C0094E5 		ldr	r0, [r4, #28]
 1374 0b00 FEFFFFEB 		bl	_txe_mutex_put
 1375 0b04 ABFFFFEA 		b	.L89
 1376              	.L102:
 1377              		.align	2
 1378              	.L101:
 1379 0b08 00000000 		.word	.LANCHOR0
 1380 0b0c 04020000 		.word	.LC14
 1381 0b10 00000000 		.word	cmdQu
 1382              		.cfi_endproc
 1383              	.LFE0:
 1385              		.align	2
 1386              		.global	setIrisauto
 1388              	setIrisauto:
 1389              	.LFB1:
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1390              		.loc 1 399 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 0
 1393              		@ frame_needed = 0, uses_anonymous_args = 0
 1394              	.LVL105:
 1395 0b14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1396              	.LCFI11:
 1397              		.cfi_def_cfa_offset 16
 1398 0b18 0160A0E1 		mov	r6, r1
 1399              		.cfi_offset 14, -4
 1400              		.cfi_offset 6, -8
 1401              		.cfi_offset 5, -12
 1402              		.cfi_offset 4, -16
 1403 0b1c 08D04DE2 		sub	sp, sp, #8
 1404              	.LCFI12:
 1405              		.cfi_def_cfa_offset 24
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1406              		.loc 1 403 0
 1407 0b20 0050A0E3 		mov	r5, #0
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1408              		.loc 1 399 0
 1409 0b24 0040A0E1 		mov	r4, r0
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1410              		.loc 1 402 0
 1411 0b28 0010E0E3 		mvn	r1, #0
 1412              	.LVL106:
 1413 0b2c 1C0090E5 		ldr	r0, [r0, #28]
 1414              	.LVL107:
 1415 0b30 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1416              		.loc 1 403 0
 1417 0b34 060065E0 		rsb	r0, r5, r6
 1418 0b38 00C070E2 		rsbs	ip, r0, #0
 1419 0b3c 00C0ACE0 		adc	ip, ip, r0
 1420 0b40 1410A0E3 		mov	r1, #20
 1421 0b44 2720A0E3 		mov	r2, #39
 1422 0b48 3030A0E3 		mov	r3, #48
 1423 0b4c 0400A0E1 		mov	r0, r4
 1424 0b50 00C08DE5 		str	ip, [sp, #0]
 1425 0b54 04508DE5 		str	r5, [sp, #4]
 1426 0b58 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1427              		.loc 1 404 0
 1428 0b5c 050056E1 		cmp	r6, r5
 1429 0b60 0260A003 		moveq	r6, #2
 1430 0b64 0560A011 		movne	r6, r5
 1431 0b68 0400A0E1 		mov	r0, r4
 1432 0b6c 1510A0E3 		mov	r1, #21
 1433 0b70 2520A0E3 		mov	r2, #37
 1434 0b74 3030A0E3 		mov	r3, #48
 1435 0b78 00608DE5 		str	r6, [sp, #0]
 1436 0b7c 04508DE5 		str	r5, [sp, #4]
 1437 0b80 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1438              		.loc 1 405 0
 1439 0b84 1C0094E5 		ldr	r0, [r4, #28]
 406:../uvc.c      **** }
 1440              		.loc 1 406 0
 1441 0b88 08D08DE2 		add	sp, sp, #8
 1442 0b8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1443              		.loc 1 405 0
 1444 0b90 FEFFFFEA 		b	_txe_mutex_put
 1445              		.cfi_endproc
 1446              	.LFE1:
 1448              		.align	2
 1449              		.global	ControlHandle
 1451              	ControlHandle:
 1452              	.LFB2:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1453              		.loc 1 408 0
 1454              		.cfi_startproc
 1455              		@ args = 0, pretend = 0, frame = 24
 1456              		@ frame_needed = 0, uses_anonymous_args = 0
 1457              	.LVL108:
 1458 0b94 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1459              	.LCFI13:
 1460              		.cfi_def_cfa_offset 36
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1461              		.loc 1 415 0
 1462 0b98 1F0050E3 		cmp	r0, #31
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1463              		.loc 1 414 0
 1464 0b9c 207040E2 		sub	r7, r0, #32
 1465              		.cfi_offset 14, -4
 1466              		.cfi_offset 11, -8
 1467              		.cfi_offset 10, -12
 1468              		.cfi_offset 9, -16
 1469              		.cfi_offset 8, -20
 1470              		.cfi_offset 7, -24
 1471              		.cfi_offset 6, -28
 1472              		.cfi_offset 5, -32
 1473              		.cfi_offset 4, -36
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1474              		.loc 1 408 0
 1475 0ba0 2CD04DE2 		sub	sp, sp, #44
 1476              	.LCFI14:
 1477              		.cfi_def_cfa_offset 80
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1478              		.loc 1 408 0
 1479 0ba4 0040A0E1 		mov	r4, r0
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1480              		.loc 1 414 0
 1481 0ba8 FF7007E2 		and	r7, r7, #255
 1482              	.LVL109:
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1483              		.loc 1 415 0
 1484 0bac 2300009A 		bls	.L107
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1485              		.loc 1 416 0
 1486 0bb0 386E9FE5 		ldr	r6, .L215
 1487 0bb4 872087E0 		add	r2, r7, r7, asl #1
 1488 0bb8 8221A0E1 		mov	r2, r2, asl #3
 1489 0bbc 023086E0 		add	r3, r6, r2
 417:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1490              		.loc 1 417 0
 1491 0bc0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 418:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1492              		.loc 1 418 0
 1493 0bc4 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 419:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1494              		.loc 1 419 0
 1495 0bc8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 430:../uvc.c      ****     reqData = bRequest;
 1496              		.loc 1 430 0
 1497 0bcc 203E9FE5 		ldr	r3, .L215+4
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1498              		.loc 1 416 0
 1499 0bd0 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1500              	.LVL110:
 430:../uvc.c      ****     reqData = bRequest;
 1501              		.loc 1 430 0
 1502 0bd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1503              	.LVL111:
 438:../uvc.c      ****     switch (bRequest)
 1504              		.loc 1 438 0
 1505 0bd8 830055E3 		cmp	r5, #131
 1506 0bdc 2200000A 		beq	.L113
 1507              	.LVL112:
 1508              	.L210:
 1509 0be0 2B00009A 		bls	.L208
 1510 0be4 850055E3 		cmp	r5, #133
 1511 0be8 8400000A 		beq	.L115
 1512 0bec 7200003A 		bcc	.L114
 1513 0bf0 860055E3 		cmp	r5, #134
 1514 0bf4 BD00000A 		beq	.L116
 1515 0bf8 870055E3 		cmp	r5, #135
 1516 0bfc B100000A 		beq	.L209
 1517              	.L109:
 923:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1518              		.loc 1 923 0
 1519 0c00 0000A0E3 		mov	r0, #0
 1520 0c04 0110A0E3 		mov	r1, #1
 1521 0c08 0020A0E1 		mov	r2, r0
 1522 0c0c FEFFFFEB 		bl	CyU3PUsbStall
 924:../uvc.c      **** 			  break;
 1523              		.loc 1 924 0
 1524 0c10 FFE0A0E3 		mov	lr, #255
 1525 0c14 0E40A0E1 		mov	r4, lr
 1526 0c18 0EC0A0E1 		mov	ip, lr
 1527 0c1c 0E30A0E1 		mov	r3, lr
 1528              	.LVL113:
 1529              	.L119:
 926:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1530              		.loc 1 926 0
 1531 0c20 D01D9FE5 		ldr	r1, .L215+8
 1532 0c24 0520A0E1 		mov	r2, r5
 1533 0c28 0400A0E3 		mov	r0, #4
 1534 0c2c 00C08DE5 		str	ip, [sp, #0]
 1535 0c30 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1536 0c34 FEFFFFEB 		bl	CyU3PDebugPrint
 927:../uvc.c      **** }
 1537              		.loc 1 927 0
 1538 0c38 2CD08DE2 		add	sp, sp, #44
 1539 0c3c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1540              	.LVL114:
 1541              	.L107:
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1542              		.loc 1 421 0
 1543 0c40 A86D9FE5 		ldr	r6, .L215
 430:../uvc.c      ****     reqData = bRequest;
 1544              		.loc 1 430 0
 1545 0c44 A83D9FE5 		ldr	r3, .L215+4
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1546              		.loc 1 421 0
 1547 0c48 805080E0 		add	r5, r0, r0, asl #1
 1548 0c4c 850186E0 		add	r0, r6, r5, asl #3
 1549              	.LVL115:
 430:../uvc.c      ****     reqData = bRequest;
 1550              		.loc 1 430 0
 1551 0c50 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1552              		.loc 1 421 0
 1553 0c54 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1554              	.LVL116:
 438:../uvc.c      ****     switch (bRequest)
 1555              		.loc 1 438 0
 1556 0c58 830055E3 		cmp	r5, #131
 422:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1557              		.loc 1 422 0
 1558 0c5c 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1559              	.LVL117:
 423:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1560              		.loc 1 423 0
 1561 0c60 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1562              	.LVL118:
 424:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1563              		.loc 1 424 0
 1564 0c64 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1565              	.LVL119:
 438:../uvc.c      ****     switch (bRequest)
 1566              		.loc 1 438 0
 1567 0c68 DCFFFF1A 		bne	.L210
 1568              	.LVL120:
 1569              	.L113:
 572:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1570              		.loc 1 572 0
 1571 0c6c 1F0054E3 		cmp	r4, #31
 1572 0c70 BC00009A 		bls	.L144
 573:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1573              		.loc 1 573 0
 1574 0c74 877087E0 		add	r7, r7, r7, asl #1
 1575              	.LVL121:
 1576 0c78 876186E0 		add	r6, r6, r7, asl #3
 1577 0c7c 78AD9FE5 		ldr	sl, .L215+12
 1578 0c80 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 574:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1579              		.loc 1 574 0
 1580 0c84 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 573:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1581              		.loc 1 573 0
 1582 0c88 5800CAE5 		strb	r0, [sl, #88]
 574:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1583              		.loc 1 574 0
 1584 0c8c 59C0CAE5 		strb	ip, [sl, #89]
 1585 0c90 0B0000EA 		b	.L152
 1586              	.LVL122:
 1587              	.L208:
 438:../uvc.c      ****     switch (bRequest)
 1588              		.loc 1 438 0
 1589 0c94 810055E3 		cmp	r5, #129
 1590 0c98 6400000A 		beq	.L111
 1591 0c9c 1000009A 		bls	.L211
 553:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1592              		.loc 1 553 0
 1593 0ca0 1F0054E3 		cmp	r4, #31
 1594 0ca4 A300009A 		bls	.L141
 554:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1595              		.loc 1 554 0
 1596 0ca8 877087E0 		add	r7, r7, r7, asl #1
 1597              	.LVL123:
 1598 0cac 876186E0 		add	r6, r6, r7, asl #3
 1599 0cb0 44AD9FE5 		ldr	sl, .L215+12
 1600 0cb4 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 555:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1601              		.loc 1 555 0
 1602 0cb8 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 554:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1603              		.loc 1 554 0
 1604 0cbc 5820CAE5 		strb	r2, [sl, #88]
 555:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1605              		.loc 1 555 0
 1606 0cc0 59E0CAE5 		strb	lr, [sl, #89]
 1607              	.L152:
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1608              		.loc 1 631 0
 1609 0cc4 0800A0E1 		mov	r0, r8
 1610 0cc8 301D9FE5 		ldr	r1, .L215+16
 1611 0ccc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1612              	.LVL124:
 633:../uvc.c      **** 			  break;
 1613              		.loc 1 633 0
 1614 0cd0 FFE0A0E3 		mov	lr, #255
 631:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1615              		.loc 1 631 0
 1616 0cd4 5840DAE5 		ldrb	r4, [sl, #88]	@ zero_extendqisi2
 633:../uvc.c      **** 			  break;
 1617              		.loc 1 633 0
 1618 0cd8 0EC0A0E1 		mov	ip, lr
 1619 0cdc 0E30A0E1 		mov	r3, lr
 1620 0ce0 CEFFFFEA 		b	.L119
 1621              	.LVL125:
 1622              	.L211:
 438:../uvc.c      ****     switch (bRequest)
 1623              		.loc 1 438 0
 1624 0ce4 010055E3 		cmp	r5, #1
 1625 0ce8 C4FFFF1A 		bne	.L109
 635:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1626              		.loc 1 635 0
 1627 0cec 081D9FE5 		ldr	r1, .L215+12
 1628 0cf0 26208DE2 		add	r2, sp, #38
 1629 0cf4 2000A0E3 		mov	r0, #32
 1630 0cf8 581081E2 		add	r1, r1, #88
 1631 0cfc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1632              	.LVL126:
 637:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1633              		.loc 1 637 0
 1634 0d00 002050E2 		subs	r2, r0, #0
 1635 0d04 FE02001A 		bne	.L154
 639:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1636              		.loc 1 639 0
 1637 0d08 ECEC9FE5 		ldr	lr, .L215+12
 1638 0d0c 5830DEE5 		ldrb	r3, [lr, #88]	@ zero_extendqisi2
 640:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1639              		.loc 1 640 0
 1640 0d10 E4EC9FE5 		ldr	lr, .L215+12
 639:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1641              		.loc 1 639 0
 1642 0d14 18308DE5 		str	r3, [sp, #24]
 1643              	.LVL127:
 642:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1644              		.loc 1 642 0
 1645 0d18 5A00DEE5 		ldrb	r0, [lr, #90]	@ zero_extendqisi2
 1646              	.LVL128:
 640:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1647              		.loc 1 640 0
 1648 0d1c 59C0DEE5 		ldrb	ip, [lr, #89]	@ zero_extendqisi2
 1649              	.LVL129:
 642:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1650              		.loc 1 642 0
 1651 0d20 1C008DE5 		str	r0, [sp, #28]
 1652              	.LVL130:
 646:../uvc.c      **** 				  switch(CtrlID)
 1653              		.loc 1 646 0
 1654 0d24 220054E3 		cmp	r4, #34
 1655 0d28 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1656 0d2c DB0200EA 		b	.L155
 1657              	.L170:
 1658 0d30 50180000 		.word	.L156
 1659 0d34 E8170000 		.word	.L157
 1660 0d38 A0180000 		.word	.L155
 1661 0d3c A0180000 		.word	.L155
 1662 0d40 A0170000 		.word	.L158
 1663 0d44 5C160000 		.word	.L159
 1664 0d48 E0150000 		.word	.L160
 1665 0d4c A0180000 		.word	.L155
 1666 0d50 A0180000 		.word	.L155
 1667 0d54 A0180000 		.word	.L155
 1668 0d58 A0180000 		.word	.L155
 1669 0d5c 58150000 		.word	.L161
 1670 0d60 A0180000 		.word	.L155
 1671 0d64 A0180000 		.word	.L155
 1672 0d68 A0180000 		.word	.L155
 1673 0d6c A0180000 		.word	.L155
 1674 0d70 60140000 		.word	.L162
 1675 0d74 A0180000 		.word	.L155
 1676 0d78 A0180000 		.word	.L155
 1677 0d7c A0180000 		.word	.L155
 1678 0d80 A0180000 		.word	.L155
 1679 0d84 A0180000 		.word	.L155
 1680 0d88 A0180000 		.word	.L155
 1681 0d8c A0180000 		.word	.L155
 1682 0d90 A0180000 		.word	.L155
 1683 0d94 A4130000 		.word	.L163
 1684 0d98 A0180000 		.word	.L155
 1685 0d9c A0180000 		.word	.L155
 1686 0da0 E8140000 		.word	.L164
 1687 0da4 A0180000 		.word	.L155
 1688 0da8 48130000 		.word	.L165
 1689 0dac C4120000 		.word	.L166
 1690 0db0 2C120000 		.word	.L167
 1691 0db4 14120000 		.word	.L168
 1692 0db8 B0110000 		.word	.L169
 1693              	.LVL131:
 1694              	.L114:
 590:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1695              		.loc 1 590 0
 1696 0dbc 1F0054E3 		cmp	r4, #31
 591:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1697              		.loc 1 591 0
 1698 0dc0 87708780 		addhi	r7, r7, r7, asl #1
 1699              	.LVL132:
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1700              		.loc 1 597 0
 1701 0dc4 84408490 		addls	r4, r4, r4, asl #1
 591:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1702              		.loc 1 591 0
 1703 0dc8 87618680 		addhi	r6, r6, r7, asl #3
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1704              		.loc 1 597 0
 1705 0dcc 84618690 		addls	r6, r6, r4, asl #3
 591:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1706              		.loc 1 591 0
 1707 0dd0 24AC9F85 		ldrhi	sl, .L215+12
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1708              		.loc 1 597 0
 1709 0dd4 20AC9F95 		ldrls	sl, .L215+12
 591:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1710              		.loc 1 591 0
 1711 0dd8 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 592:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1712              		.loc 1 592 0
 1713 0ddc 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1714              		.loc 1 597 0
 1715 0de0 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1716              		.loc 1 598 0
 1717 0de4 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 599:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1718              		.loc 1 599 0
 1719 0de8 0030A0E3 		mov	r3, #0
 597:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1720              		.loc 1 597 0
 1721 0dec 5810CAE5 		strb	r1, [sl, #88]
 598:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1722              		.loc 1 598 0
 1723 0df0 5920CAE5 		strb	r2, [sl, #89]
 599:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1724              		.loc 1 599 0
 1725 0df4 5A30CAE5 		strb	r3, [sl, #90]
 600:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1726              		.loc 1 600 0
 1727 0df8 5B30CAE5 		strb	r3, [sl, #91]
 1728 0dfc B0FFFFEA 		b	.L152
 1729              	.LVL133:
 1730              	.L115:
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1731              		.loc 1 442 0
 1732 0e00 F44B9FE5 		ldr	r4, .L215+12
 443:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1733              		.loc 1 443 0
 1734 0e04 00C0A0E3 		mov	ip, #0
 1735 0e08 59C0C4E5 		strb	ip, [r4, #89]
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1736              		.loc 1 444 0
 1737 0e0c 581084E2 		add	r1, r4, #88
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1738              		.loc 1 442 0
 1739 0e10 5880C4E5 		strb	r8, [r4, #88]
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1740              		.loc 1 444 0
 1741 0e14 0200A0E3 		mov	r0, #2
 1742 0e18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1743              	.LVL134:
 446:../uvc.c      **** 			  break;
 1744              		.loc 1 446 0
 1745 0e1c FFE0A0E3 		mov	lr, #255
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1746              		.loc 1 444 0
 1747 0e20 5840D4E5 		ldrb	r4, [r4, #88]	@ zero_extendqisi2
 446:../uvc.c      **** 			  break;
 1748              		.loc 1 446 0
 1749 0e24 0EC0A0E1 		mov	ip, lr
 1750 0e28 0E30A0E1 		mov	r3, lr
 1751 0e2c 7BFFFFEA 		b	.L119
 1752              	.LVL135:
 1753              	.L111:
 449:../uvc.c      **** 			 switch(CtrlID)
 1754              		.loc 1 449 0
 1755 0e30 011044E2 		sub	r1, r4, #1
 1756 0e34 210051E3 		cmp	r1, #33
 1757 0e38 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1758 0e3c D20000EA 		b	.L120
 1759              	.L128:
 1760 0e40 60110000 		.word	.L121
 1761 0e44 8C110000 		.word	.L120
 1762 0e48 8C110000 		.word	.L120
 1763 0e4c 8C110000 		.word	.L120
 1764 0e50 40110000 		.word	.L122
 1765 0e54 8C110000 		.word	.L120
 1766 0e58 8C110000 		.word	.L120
 1767 0e5c 8C110000 		.word	.L120
 1768 0e60 8C110000 		.word	.L120
 1769 0e64 8C110000 		.word	.L120
 1770 0e68 1C110000 		.word	.L123
 1771 0e6c 8C110000 		.word	.L120
 1772 0e70 8C110000 		.word	.L120
 1773 0e74 8C110000 		.word	.L120
 1774 0e78 8C110000 		.word	.L120
 1775 0e7c 8C110000 		.word	.L120
 1776 0e80 8C110000 		.word	.L120
 1777 0e84 8C110000 		.word	.L120
 1778 0e88 8C110000 		.word	.L120
 1779 0e8c 8C110000 		.word	.L120
 1780 0e90 8C110000 		.word	.L120
 1781 0e94 8C110000 		.word	.L120
 1782 0e98 8C110000 		.word	.L120
 1783 0e9c 8C110000 		.word	.L120
 1784 0ea0 E0100000 		.word	.L124
 1785 0ea4 8C110000 		.word	.L120
 1786 0ea8 8C110000 		.word	.L120
 1787 0eac B8100000 		.word	.L125
 1788 0eb0 8C110000 		.word	.L120
 1789 0eb4 8C110000 		.word	.L120
 1790 0eb8 1C100000 		.word	.L126
 1791 0ebc E40F0000 		.word	.L127
 1792 0ec0 E40F0000 		.word	.L127
 1793 0ec4 E40F0000 		.word	.L127
 1794              	.L209:
 617:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1795              		.loc 1 617 0
 1796 0ec8 1F0054E3 		cmp	r4, #31
 1797 0ecc 3100009A 		bls	.L151
 618:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1798              		.loc 1 618 0
 1799 0ed0 877087E0 		add	r7, r7, r7, asl #1
 1800              	.LVL136:
 1801 0ed4 876186E0 		add	r6, r6, r7, asl #3
 1802 0ed8 1CAB9FE5 		ldr	sl, .L215+12
 1803 0edc 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1804              		.loc 1 619 0
 1805 0ee0 0C40D6E5 		ldrb	r4, [r6, #12]	@ zero_extendqisi2
 618:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1806              		.loc 1 618 0
 1807 0ee4 5810CAE5 		strb	r1, [sl, #88]
 619:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1808              		.loc 1 619 0
 1809 0ee8 5940CAE5 		strb	r4, [sl, #89]
 1810 0eec 74FFFFEA 		b	.L152
 1811              	.LVL137:
 1812              	.L116:
 606:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1813              		.loc 1 606 0
 1814 0ef0 1F0054E3 		cmp	r4, #31
 610:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1815              		.loc 1 610 0
 1816 0ef4 84408490 		addls	r4, r4, r4, asl #1
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1817              		.loc 1 607 0
 1818 0ef8 87708780 		addhi	r7, r7, r7, asl #1
 1819              	.LVL138:
 610:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1820              		.loc 1 610 0
 1821 0efc 84618690 		addls	r6, r6, r4, asl #3
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1822              		.loc 1 607 0
 1823 0f00 87618680 		addhi	r6, r6, r7, asl #3
 1824 0f04 F08A9F85 		ldrhi	r8, .L215+12
 1825 0f08 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 610:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1826              		.loc 1 610 0
 1827 0f0c E88A9F95 		ldrls	r8, .L215+12
 1828 0f10 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 612:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1829              		.loc 1 612 0
 1830 0f14 0100A0E3 		mov	r0, #1
 610:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1831              		.loc 1 610 0
 1832 0f18 5830C8E5 		strb	r3, [r8, #88]
 612:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1833              		.loc 1 612 0
 1834 0f1c DC1A9FE5 		ldr	r1, .L215+16
 1835 0f20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1836              	.LVL139:
 615:../uvc.c      **** 			  break;
 1837              		.loc 1 615 0
 1838 0f24 FFE0A0E3 		mov	lr, #255
 612:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1839              		.loc 1 612 0
 1840 0f28 5840D8E5 		ldrb	r4, [r8, #88]	@ zero_extendqisi2
 615:../uvc.c      **** 			  break;
 1841              		.loc 1 615 0
 1842 0f2c 0EC0A0E1 		mov	ip, lr
 1843 0f30 0E30A0E1 		mov	r3, lr
 1844 0f34 39FFFFEA 		b	.L119
 1845              	.LVL140:
 1846              	.L141:
 558:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1847              		.loc 1 558 0
 1848 0f38 0B0054E3 		cmp	r4, #11
 565:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1849              		.loc 1 565 0
 1850 0f3c 84408410 		addne	r4, r4, r4, asl #1
 1851 0f40 84618610 		addne	r6, r6, r4, asl #3
 1852 0f44 B0AA9F15 		ldrne	sl, .L215+12
 559:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1853              		.loc 1 559 0
 1854 0f48 ACAA9F05 		ldreq	sl, .L215+12
 1855 0f4c B03A9F05 		ldreq	r3, .L215+20
 565:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1856              		.loc 1 565 0
 1857 0f50 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 566:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1858              		.loc 1 566 0
 1859 0f54 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 559:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1860              		.loc 1 559 0
 1861 0f58 58308A05 		streq	r3, [sl, #88]
 565:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1862              		.loc 1 565 0
 1863 0f5c 5820CA15 		strneb	r2, [sl, #88]
 566:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1864              		.loc 1 566 0
 1865 0f60 5930CA15 		strneb	r3, [sl, #89]
 1866 0f64 56FFFFEA 		b	.L152
 1867              	.L144:
 576:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1868              		.loc 1 576 0
 1869 0f68 0B0054E3 		cmp	r4, #11
 583:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1870              		.loc 1 583 0
 1871 0f6c 84408410 		addne	r4, r4, r4, asl #1
 1872 0f70 84618610 		addne	r6, r6, r4, asl #3
 1873 0f74 80AA9F15 		ldrne	sl, .L215+12
 577:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1874              		.loc 1 577 0
 1875 0f78 7CAA9F05 		ldreq	sl, .L215+12
 1876 0f7c 843A9F05 		ldreq	r3, .L215+24
 583:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1877              		.loc 1 583 0
 1878 0f80 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 584:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1879              		.loc 1 584 0
 1880 0f84 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 577:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1881              		.loc 1 577 0
 1882 0f88 58308A05 		streq	r3, [sl, #88]
 583:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1883              		.loc 1 583 0
 1884 0f8c 5820CA15 		strneb	r2, [sl, #88]
 584:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1885              		.loc 1 584 0
 1886 0f90 5930CA15 		strneb	r3, [sl, #89]
 1887 0f94 4AFFFFEA 		b	.L152
 1888              	.L151:
 622:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1889              		.loc 1 622 0
 1890 0f98 0B0054E3 		cmp	r4, #11
 1891 0f9c 0700000A 		beq	.L212
 628:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1892              		.loc 1 628 0
 1893 0fa0 84A084E0 		add	sl, r4, r4, asl #1
 1894 0fa4 8A6186E0 		add	r6, r6, sl, asl #3
 1895 0fa8 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1896 0fac 48AA9FE5 		ldr	sl, .L215+12
 629:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1897              		.loc 1 629 0
 1898 0fb0 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 628:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1899              		.loc 1 628 0
 1900 0fb4 5830CAE5 		strb	r3, [sl, #88]
 629:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1901              		.loc 1 629 0
 1902 0fb8 5900CAE5 		strb	r0, [sl, #89]
 1903 0fbc 40FFFFEA 		b	.L152
 1904              	.L212:
 623:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1905              		.loc 1 623 0
 1906 0fc0 34AA9FE5 		ldr	sl, .L215+12
 1907 0fc4 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 625:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1908              		.loc 1 625 0
 1909 0fc8 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 624:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1910              		.loc 1 624 0
 1911 0fcc 00E0A0E3 		mov	lr, #0
 623:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1912              		.loc 1 623 0
 1913 0fd0 58C0CAE5 		strb	ip, [sl, #88]
 624:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1914              		.loc 1 624 0
 1915 0fd4 59E0CAE5 		strb	lr, [sl, #89]
 625:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1916              		.loc 1 625 0
 1917 0fd8 5A20CAE5 		strb	r2, [sl, #90]
 626:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1918              		.loc 1 626 0
 1919 0fdc 5BE0CAE5 		strb	lr, [sl, #91]
 1920 0fe0 37FFFFEA 		b	.L152
 1921              	.L127:
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1922              		.loc 1 455 0
 1923 0fe4 877087E0 		add	r7, r7, r7, asl #1
 1924              	.LVL141:
 1925 0fe8 876186E0 		add	r6, r6, r7, asl #3
 1926 0fec 08EA9FE5 		ldr	lr, .L215+12
 1927 0ff0 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1928              		.loc 1 456 0
 1929 0ff4 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1930              		.loc 1 455 0
 1931 0ff8 5840CEE5 		strb	r4, [lr, #88]
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1932              		.loc 1 456 0
 1933 0ffc 5960CEE5 		strb	r6, [lr, #89]
 1934              	.LVL142:
 1935              	.L131:
 546:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1936              		.loc 1 546 0
 1937 1000 0800A0E1 		mov	r0, r8
 1938 1004 F4199FE5 		ldr	r1, .L215+16
 1939 1008 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 551:../uvc.c      **** 			  break;
 1940              		.loc 1 551 0
 1941 100c FFC0A0E3 		mov	ip, #255
 546:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1942              		.loc 1 546 0
 1943 1010 06E0A0E1 		mov	lr, r6
 551:../uvc.c      **** 			  break;
 1944              		.loc 1 551 0
 1945 1014 0C30A0E1 		mov	r3, ip
 1946 1018 00FFFFEA 		b	.L119
 1947              	.LVL143:
 1948              	.L126:
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1949              		.loc 1 476 0 discriminator 1
 1950 101c 000058E3 		cmp	r8, #0
 1951 1020 6B02000A 		beq	.L204
 474:../uvc.c      **** 					 break;
 1952              		.loc 1 474 0
 1953 1024 28E1A0E1 		mov	lr, r8, lsr #2
 1954 1028 00005EE3 		cmp	lr, #0
 1955 102c 03005813 		cmpne	r8, #3
 1956 1030 0020A083 		movhi	r2, #0
 1957 1034 0120A093 		movls	r2, #1
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1958              		.loc 1 408 0
 1959 1038 0E31A0E1 		mov	r3, lr, asl #2
 474:../uvc.c      **** 					 break;
 1960              		.loc 1 474 0
 1961 103c 6802009A 		bls	.L191
 1962 1040 B8199FE5 		ldr	r1, .L215+16
 1963 1044 0C0041E2 		sub	r0, r1, #12
 1964              	.LVL144:
 1965              	.L136:
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1966              		.loc 1 477 0 discriminator 2
 1967 1048 044090E4 		ldr	r4, [r0], #4
 1968 104c 01C082E2 		add	ip, r2, #1
 1969 1050 FF200CE2 		and	r2, ip, #255
 1970 1054 02005EE1 		cmp	lr, r2
 1971 1058 044081E4 		str	r4, [r1], #4
 1972 105c F9FFFF8A 		bhi	.L136
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1973              		.loc 1 477 0 is_stmt 0
 1974 1060 030058E1 		cmp	r8, r3
 1975 1064 90099F15 		ldrne	r0, .L215+12
 1976 1068 5902000A 		beq	.L204
 1977              	.L196:
 1978 106c 03E080E0 		add	lr, r0, r3
 1979 1070 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1980              		.loc 1 476 0 is_stmt 1
 1981 1074 016083E2 		add	r6, r3, #1
 1982 1078 FF3006E2 		and	r3, r6, #255
 1983              	.LVL145:
 1984 107c 030058E1 		cmp	r8, r3
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1985              		.loc 1 477 0
 1986 1080 5810CEE5 		strb	r1, [lr, #88]
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1987              		.loc 1 476 0
 1988 1084 F8FFFF8A 		bhi	.L196
 1989              	.LVL146:
 1990              	.L130:
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1991              		.loc 1 486 0
 1992 1088 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1993              		.loc 1 479 0
 1994 108c 68399FE5 		ldr	r3, .L215+12
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1995              		.loc 1 486 0
 1996 1090 FF0052E3 		cmp	r2, #255
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1997              		.loc 1 479 0
 1998 1094 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1999              	.LVL147:
 480:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2000              		.loc 1 480 0
 2001 1098 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 2002              	.LVL148:
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2003              		.loc 1 486 0
 2004 109c D7FFFF0A 		beq	.L131
 488:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2005              		.loc 1 488 0
 2006 10a0 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2007 10a4 60199FE5 		ldr	r1, .L215+28
 2008 10a8 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2009 10ac 0400A0E3 		mov	r0, #4
 2010 10b0 FEFFFFEB 		bl	CyU3PDebugPrint
 2011 10b4 D1FFFFEA 		b	.L131
 2012              	.LVL149:
 2013              	.L125:
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 2014              		.loc 1 463 0
 2015 10b8 3C799FE5 		ldr	r7, .L215+12
 2016              	.LVL150:
 462:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2017              		.loc 1 462 0
 2018 10bc 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2019              	.LVL151:
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 2020              		.loc 1 463 0
 2021 10c0 7820D7E5 		ldrb	r2, [r7, #120]	@ zero_extendqisi2
 2022 10c4 010052E3 		cmp	r2, #1
 2023 10c8 1502000A 		beq	.L213
 2024              	.LVL152:
 2025              	.L132:
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2026              		.loc 1 473 0
 2027 10cc 0000A0E3 		mov	r0, #0
 472:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2028              		.loc 1 472 0
 2029 10d0 5840C7E5 		strb	r4, [r7, #88]
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2030              		.loc 1 473 0
 2031 10d4 5900C7E5 		strb	r0, [r7, #89]
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2032              		.loc 1 426 0
 2033 10d8 FF60A0E3 		mov	r6, #255
 474:../uvc.c      **** 					 break;
 2034              		.loc 1 474 0
 2035 10dc C7FFFFEA 		b	.L131
 2036              	.LVL153:
 2037              	.L124:
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2038              		.loc 1 492 0
 2039 10e0 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2040 10e4 10C99FE5 		ldr	ip, .L215+12
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2041              		.loc 1 494 0
 2042 10e8 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2043              		.loc 1 493 0
 2044 10ec 00E0A0E3 		mov	lr, #0
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2045              		.loc 1 492 0
 2046 10f0 5840CCE5 		strb	r4, [ip, #88]
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2047              		.loc 1 493 0
 2048 10f4 59E0CCE5 		strb	lr, [ip, #89]
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2049              		.loc 1 494 0
 2050 10f8 5A60CCE5 		strb	r6, [ip, #90]
 495:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2051              		.loc 1 495 0
 2052 10fc 5BE0CCE5 		strb	lr, [ip, #91]
 2053              	.LVL154:
 498:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2054              		.loc 1 498 0
 2055 1100 08199FE5 		ldr	r1, .L215+32
 2056 1104 0420A0E1 		mov	r2, r4
 2057 1108 0E30A0E1 		mov	r3, lr
 2058 110c 0400A0E3 		mov	r0, #4
 2059 1110 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2060 1114 FEFFFFEB 		bl	CyU3PDebugPrint
 499:../uvc.c      **** 					 break;
 2061              		.loc 1 499 0
 2062 1118 B8FFFFEA 		b	.L131
 2063              	.LVL155:
 2064              	.L123:
 531:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2065              		.loc 1 531 0
 2066 111c D8C89FE5 		ldr	ip, .L215+12
 2067 1120 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 533:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2068              		.loc 1 533 0
 2069 1124 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2070              		.loc 1 532 0
 2071 1128 00E0A0E3 		mov	lr, #0
 531:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2072              		.loc 1 531 0
 2073 112c 5840CCE5 		strb	r4, [ip, #88]
 532:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2074              		.loc 1 532 0
 2075 1130 59E0CCE5 		strb	lr, [ip, #89]
 533:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2076              		.loc 1 533 0
 2077 1134 5A60CCE5 		strb	r6, [ip, #90]
 534:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2078              		.loc 1 534 0
 2079 1138 5BE0CCE5 		strb	lr, [ip, #91]
 2080              	.LVL156:
 537:../uvc.c      **** 					 break;
 2081              		.loc 1 537 0
 2082 113c AFFFFFEA 		b	.L131
 2083              	.LVL157:
 2084              	.L122:
 526:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2085              		.loc 1 526 0
 2086 1140 0522D6E5 		ldrb	r2, [r6, #517]	@ zero_extendqisi2
 2087 1144 B0689FE5 		ldr	r6, .L215+12
 2088 1148 804022E2 		eor	r4, r2, #128
 527:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2089              		.loc 1 527 0
 2090 114c 0010A0E3 		mov	r1, #0
 526:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2091              		.loc 1 526 0
 2092 1150 5840C6E5 		strb	r4, [r6, #88]
 527:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2093              		.loc 1 527 0
 2094 1154 5910C6E5 		strb	r1, [r6, #89]
 2095              	.LVL158:
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2096              		.loc 1 426 0
 2097 1158 FF60A0E3 		mov	r6, #255
 529:../uvc.c      **** 					 break;
 2098              		.loc 1 529 0
 2099 115c A7FFFFEA 		b	.L131
 2100              	.LVL159:
 2101              	.L121:
 514:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2102              		.loc 1 514 0
 2103 1160 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2104              	.LVL160:
 520:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2105              		.loc 1 520 0
 2106 1164 90389FE5 		ldr	r3, .L215+12
 515:../uvc.c      **** 					  if(Data0&0x80){
 2107              		.loc 1 515 0
 2108 1168 800014E3 		tst	r4, #128
 516:../uvc.c      **** 						  Data0 = ~Data0;
 2109              		.loc 1 516 0
 2110 116c 0440E011 		mvnne	r4, r4
 2111              	.LVL161:
 518:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2112              		.loc 1 518 0
 2113 1170 80404402 		subeq	r4, r4, #128
 2114 1174 FF4004E2 		and	r4, r4, #255
 2115              	.LVL162:
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2116              		.loc 1 521 0
 2117 1178 0000A0E3 		mov	r0, #0
 520:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2118              		.loc 1 520 0
 2119 117c 5840C3E5 		strb	r4, [r3, #88]
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2120              		.loc 1 521 0
 2121 1180 5900C3E5 		strb	r0, [r3, #89]
 2122              	.LVL163:
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2123              		.loc 1 426 0
 2124 1184 FF60A0E3 		mov	r6, #255
 523:../uvc.c      **** 			 		 break;
 2125              		.loc 1 523 0
 2126 1188 9CFFFFEA 		b	.L131
 2127              	.LVL164:
 2128              	.L120:
 540:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2129              		.loc 1 540 0
 2130 118c 841084E0 		add	r1, r4, r4, asl #1
 2131 1190 814186E0 		add	r4, r6, r1, asl #3
 2132 1194 60389FE5 		ldr	r3, .L215+12
 2133 1198 8D41D4E5 		ldrb	r4, [r4, #397]	@ zero_extendqisi2
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2134              		.loc 1 541 0
 2135 119c 0000A0E3 		mov	r0, #0
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2136              		.loc 1 426 0
 2137 11a0 FF60A0E3 		mov	r6, #255
 540:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2138              		.loc 1 540 0
 2139 11a4 5840C3E5 		strb	r4, [r3, #88]
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2140              		.loc 1 541 0
 2141 11a8 5900C3E5 		strb	r0, [r3, #89]
 2142              	.LVL165:
 543:../uvc.c      **** 					 break;
 2143              		.loc 1 543 0
 2144 11ac 93FFFFEA 		b	.L131
 2145              	.LVL166:
 2146              	.L169:
 777:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2147              		.loc 1 777 0
 2148 11b0 5C489FE5 		ldr	r4, .L215+36
 2149 11b4 0010E0E3 		mvn	r1, #0
 2150 11b8 1C0094E5 		ldr	r0, [r4, #28]
 2151 11bc FEFFFFEB 		bl	_txe_mutex_get
 2152              	.LVL167:
 778:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2153              		.loc 1 778 0
 2154 11c0 2210A0E3 		mov	r1, #34
 2155              	.L207:
 2156 11c4 18C09DE5 		ldr	ip, [sp, #24]
 2157 11c8 00E0A0E3 		mov	lr, #0
 2158 11cc 0A30A0E1 		mov	r3, sl
 2159 11d0 0920A0E1 		mov	r2, r9
 2160 11d4 0400A0E1 		mov	r0, r4
 2161 11d8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2162 11dc FEFFFFEB 		bl	cmdSet
 779:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2163              		.loc 1 779 0
 2164 11e0 1C0094E5 		ldr	r0, [r4, #28]
 2165 11e4 FEFFFFEB 		bl	_txe_mutex_put
 780:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2166              		.loc 1 780 0
 2167 11e8 18109DE5 		ldr	r1, [sp, #24]
 2168 11ec 877087E0 		add	r7, r7, r7, asl #1
 2169              	.LVL168:
 2170 11f0 876186E0 		add	r6, r6, r7, asl #3
 781:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2171              		.loc 1 781 0
 2172 11f4 0130A0E3 		mov	r3, #1
 782:../uvc.c      **** 							 break;
 2173              		.loc 1 782 0
 2174 11f8 FFE0A0E3 		mov	lr, #255
 781:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2175              		.loc 1 781 0
 2176 11fc 1030C6E5 		strb	r3, [r6, #16]
 780:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2177              		.loc 1 780 0
 2178 1200 0D10C6E5 		strb	r1, [r6, #13]
 781:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2179              		.loc 1 781 0
 2180 1204 0130A0E1 		mov	r3, r1
 2181 1208 1CC09DE5 		ldr	ip, [sp, #28]
 782:../uvc.c      **** 							 break;
 2182              		.loc 1 782 0
 2183 120c 0E40A0E1 		mov	r4, lr
 2184 1210 82FEFFEA 		b	.L119
 2185              	.LVL169:
 2186              	.L168:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2187              		.loc 1 769 0
 2188 1214 F8479FE5 		ldr	r4, .L215+36
 2189 1218 0010E0E3 		mvn	r1, #0
 2190 121c 1C0094E5 		ldr	r0, [r4, #28]
 2191 1220 FEFFFFEB 		bl	_txe_mutex_get
 2192              	.LVL170:
 770:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2193              		.loc 1 770 0
 2194 1224 2110A0E3 		mov	r1, #33
 2195 1228 E5FFFFEA 		b	.L207
 2196              	.LVL171:
 2197              	.L167:
 755:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2198              		.loc 1 755 0
 2199 122c E0479FE5 		ldr	r4, .L215+36
 2200 1230 0010E0E3 		mvn	r1, #0
 2201 1234 1C0094E5 		ldr	r0, [r4, #28]
 2202 1238 14C08DE5 		str	ip, [sp, #20]
 2203 123c FEFFFFEB 		bl	_txe_mutex_get
 2204              	.LVL172:
 754:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2205              		.loc 1 754 0
 2206 1240 18209DE5 		ldr	r2, [sp, #24]
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2207              		.loc 1 757 0
 2208 1244 00E0A0E3 		mov	lr, #0
 754:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2209              		.loc 1 754 0
 2210 1248 7F8002E2 		and	r8, r2, #127
 2211 124c 1C808DE5 		str	r8, [sp, #28]
 2212              	.LVL173:
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2213              		.loc 1 757 0
 2214 1250 1CC09DE5 		ldr	ip, [sp, #28]
 2215 1254 2010A0E3 		mov	r1, #32
 2216 1258 0920A0E1 		mov	r2, r9
 2217 125c 0A30A0E1 		mov	r3, sl
 2218 1260 0400A0E1 		mov	r0, r4
 2219 1264 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2220 1268 FEFFFFEB 		bl	cmdSet
 2221              	.LVL174:
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2222              		.loc 1 759 0
 2223 126c 14C09DE5 		ldr	ip, [sp, #20]
 2224 1270 0A30A0E1 		mov	r3, sl
 2225 1274 0180A0E3 		mov	r8, #1
 2226 1278 2010A0E3 		mov	r1, #32
 2227 127c 0B20A0E1 		mov	r2, fp
 2228 1280 0400A0E1 		mov	r0, r4
 2229 1284 00C08DE5 		str	ip, [sp, #0]
 2230 1288 04808DE5 		str	r8, [sp, #4]
 2231 128c FEFFFFEB 		bl	cmdSet
 760:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2232              		.loc 1 760 0
 2233 1290 1C0094E5 		ldr	r0, [r4, #28]
 2234 1294 FEFFFFEB 		bl	_txe_mutex_put
 2235              	.LVL175:
 763:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2236              		.loc 1 763 0
 2237 1298 1C009DE5 		ldr	r0, [sp, #28]
 2238 129c 877087E0 		add	r7, r7, r7, asl #1
 2239              	.LVL176:
 2240 12a0 876186E0 		add	r6, r6, r7, asl #3
 2241 12a4 0D00C6E5 		strb	r0, [r6, #13]
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2242              		.loc 1 764 0
 2243 12a8 14C09DE5 		ldr	ip, [sp, #20]
 766:../uvc.c      **** 							 break;
 2244              		.loc 1 766 0
 2245 12ac FFE0A0E3 		mov	lr, #255
 764:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2246              		.loc 1 764 0
 2247 12b0 0EC0C6E5 		strb	ip, [r6, #14]
 765:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2248              		.loc 1 765 0
 2249 12b4 1080C6E5 		strb	r8, [r6, #16]
 2250 12b8 18309DE5 		ldr	r3, [sp, #24]
 766:../uvc.c      **** 							 break;
 2251              		.loc 1 766 0
 2252 12bc 0E40A0E1 		mov	r4, lr
 2253 12c0 56FEFFEA 		b	.L119
 2254              	.LVL177:
 2255              	.L166:
 726:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2256              		.loc 1 726 0 discriminator 1
 2257 12c4 000058E3 		cmp	r8, #0
 2258 12c8 1800000A 		beq	.L172
 724:../uvc.c      **** 							 break;
 2259              		.loc 1 724 0
 2260 12cc 28E1A0E1 		mov	lr, r8, lsr #2
 2261 12d0 00005EE3 		cmp	lr, #0
 2262 12d4 03005813 		cmpne	r8, #3
 2263 12d8 0020A083 		movhi	r2, #0
 2264 12dc 0120A093 		movls	r2, #1
 2265              	.LVL178:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2266              		.loc 1 408 0
 2267 12e0 0E31A0E1 		mov	r3, lr, asl #2
 724:../uvc.c      **** 							 break;
 2268              		.loc 1 724 0
 2269 12e4 BC01009A 		bls	.L192
 2270 12e8 28179FE5 		ldr	r1, .L215+40
 2271 12ec 0C0081E2 		add	r0, r1, #12
 2272              	.LVL179:
 2273              	.L183:
 727:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2274              		.loc 1 727 0 discriminator 2
 2275 12f0 044090E4 		ldr	r4, [r0], #4
 2276 12f4 012082E2 		add	r2, r2, #1
 2277 12f8 FF2002E2 		and	r2, r2, #255
 2278 12fc 02005EE1 		cmp	lr, r2
 2279 1300 044081E4 		str	r4, [r1], #4
 2280 1304 F9FFFF8A 		bhi	.L183
 727:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2281              		.loc 1 727 0 is_stmt 0
 2282 1308 030058E1 		cmp	r8, r3
 2283 130c 0700000A 		beq	.L172
 2284              	.LVL180:
 2285              	.L197:
 2286 1310 E4C69FE5 		ldr	ip, .L215+12
 2287 1314 03E08CE0 		add	lr, ip, r3
 2288 1318 5810DEE5 		ldrb	r1, [lr, #88]	@ zero_extendqisi2
 726:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2289              		.loc 1 726 0 is_stmt 1
 2290 131c 013083E2 		add	r3, r3, #1
 2291 1320 FF3003E2 		and	r3, r3, #255
 2292              	.LVL181:
 2293 1324 030058E1 		cmp	r8, r3
 727:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2294              		.loc 1 727 0
 2295 1328 4C10CEE5 		strb	r1, [lr, #76]
 726:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2296              		.loc 1 726 0
 2297 132c F7FFFF8A 		bhi	.L197
 2298              	.LVL182:
 2299              	.L172:
 729:../uvc.c      **** 					 		I2CCmdHandler();
 2300              		.loc 1 729 0
 2301 1330 FEFFFFEB 		bl	I2CCmdHandler
 730:../uvc.c      **** 							 break;
 2302              		.loc 1 730 0
 2303 1334 FFE0A0E3 		mov	lr, #255
 729:../uvc.c      **** 					 		I2CCmdHandler();
 2304              		.loc 1 729 0
 2305 1338 18309DE5 		ldr	r3, [sp, #24]
 2306 133c 1CC09DE5 		ldr	ip, [sp, #28]
 730:../uvc.c      **** 							 break;
 2307              		.loc 1 730 0
 2308 1340 0E40A0E1 		mov	r4, lr
 2309 1344 35FEFFEA 		b	.L119
 2310              	.LVL183:
 2311              	.L165:
 720:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2312              		.loc 1 720 0
 2313 1348 C4469FE5 		ldr	r4, .L215+36
 2314 134c 0010E0E3 		mvn	r1, #0
 2315 1350 1C0094E5 		ldr	r0, [r4, #28]
 2316 1354 FEFFFFEB 		bl	_txe_mutex_get
 2317              	.LVL184:
 721:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2318              		.loc 1 721 0
 2319 1358 18009DE5 		ldr	r0, [sp, #24]
 2320 135c 00E0A0E3 		mov	lr, #0
 2321 1360 01C070E2 		rsbs	ip, r0, #1
 2322 1364 00C0A033 		movcc	ip, #0
 2323 1368 0A30A0E1 		mov	r3, sl
 2324 136c 1E10A0E3 		mov	r1, #30
 2325 1370 0920A0E1 		mov	r2, r9
 2326 1374 0400A0E1 		mov	r0, r4
 2327 1378 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2328 137c FEFFFFEB 		bl	cmdSet
 722:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2329              		.loc 1 722 0
 2330 1380 1C0094E5 		ldr	r0, [r4, #28]
 2331 1384 FEFFFFEB 		bl	_txe_mutex_put
 723:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2332              		.loc 1 723 0
 2333 1388 0130A0E3 		mov	r3, #1
 724:../uvc.c      **** 							 break;
 2334              		.loc 1 724 0
 2335 138c FFE0A0E3 		mov	lr, #255
 723:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2336              		.loc 1 723 0
 2337 1390 6034C6E5 		strb	r3, [r6, #1120]
 2338 1394 1CC09DE5 		ldr	ip, [sp, #28]
 2339 1398 18309DE5 		ldr	r3, [sp, #24]
 724:../uvc.c      **** 							 break;
 2340              		.loc 1 724 0
 2341 139c 0E40A0E1 		mov	r4, lr
 2342 13a0 1EFEFFEA 		b	.L119
 2343              	.LVL185:
 2344              	.L163:
 687:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2345              		.loc 1 687 0
 2346 13a4 68469FE5 		ldr	r4, .L215+36
 683:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2347              		.loc 1 683 0
 2348 13a8 E533C6E5 		strb	r3, [r6, #997]
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2349              		.loc 1 684 0
 2350 13ac 1C309DE5 		ldr	r3, [sp, #28]
 685:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2351              		.loc 1 685 0
 2352 13b0 0170A0E3 		mov	r7, #1
 2353              	.LVL186:
 687:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2354              		.loc 1 687 0
 2355 13b4 0010E0E3 		mvn	r1, #0
 684:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2356              		.loc 1 684 0
 2357 13b8 E633C6E5 		strb	r3, [r6, #998]
 687:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2358              		.loc 1 687 0
 2359 13bc 1C0094E5 		ldr	r0, [r4, #28]
 685:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2360              		.loc 1 685 0
 2361 13c0 E873C6E5 		strb	r7, [r6, #1000]
 2362              	.LVL187:
 687:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2363              		.loc 1 687 0
 2364 13c4 FEFFFFEB 		bl	_txe_mutex_get
 2365              	.LVL188:
 688:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2366              		.loc 1 688 0
 2367 13c8 18C09DE5 		ldr	ip, [sp, #24]
 2368 13cc 0400A0E1 		mov	r0, r4
 2369 13d0 00C08DE5 		str	ip, [sp, #0]
 2370 13d4 1910A0E3 		mov	r1, #25
 2371 13d8 00C0A0E3 		mov	ip, #0
 2372 13dc 0920A0E1 		mov	r2, r9
 2373 13e0 0A30A0E1 		mov	r3, sl
 2374 13e4 04C08DE5 		str	ip, [sp, #4]
 2375 13e8 FEFFFFEB 		bl	cmdSet
 689:../uvc.c      **** 							 if(getData != 0){
 2376              		.loc 1 689 0
 2377 13ec 18009DE5 		ldr	r0, [sp, #24]
 2378 13f0 000050E3 		cmp	r0, #0
 2379 13f4 0700000A 		beq	.L179
 2380              	.LVL189:
 691:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2381              		.loc 1 691 0
 2382 13f8 1CE09DE5 		ldr	lr, [sp, #28]
 2383 13fc 0400A0E1 		mov	r0, r4
 2384 1400 1910A0E3 		mov	r1, #25
 2385 1404 0B20A0E1 		mov	r2, fp
 2386 1408 0A30A0E1 		mov	r3, sl
 2387 140c 00E08DE5 		str	lr, [sp, #0]
 2388 1410 04708DE5 		str	r7, [sp, #4]
 2389 1414 FEFFFFEB 		bl	cmdSet
 2390              	.LVL190:
 2391              	.L179:
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2392              		.loc 1 693 0
 2393 1418 1C0094E5 		ldr	r0, [r4, #28]
 2394 141c FEFFFFEB 		bl	_txe_mutex_put
 694:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2395              		.loc 1 694 0
 2396 1420 D4059FE5 		ldr	r0, .L215+12
 2397 1424 D0159FE5 		ldr	r1, .L215+12
 2398 1428 5AC0D0E5 		ldrb	ip, [r0, #90]	@ zero_extendqisi2
 2399 142c 5B40D1E5 		ldrb	r4, [r1, #91]	@ zero_extendqisi2
 2400 1430 5930D0E5 		ldrb	r3, [r0, #89]	@ zero_extendqisi2
 2401 1434 5820D0E5 		ldrb	r2, [r0, #88]	@ zero_extendqisi2
 2402 1438 DC159FE5 		ldr	r1, .L215+44
 2403 143c 0400A0E3 		mov	r0, #4
 2404 1440 00C08DE5 		str	ip, [sp, #0]
 2405 1444 04408DE5 		str	r4, [sp, #4]
 2406 1448 FEFFFFEB 		bl	CyU3PDebugPrint
 695:../uvc.c      **** 							 break;
 2407              		.loc 1 695 0
 2408 144c FFE0A0E3 		mov	lr, #255
 694:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2409              		.loc 1 694 0
 2410 1450 18309DE5 		ldr	r3, [sp, #24]
 2411 1454 1CC09DE5 		ldr	ip, [sp, #28]
 695:../uvc.c      **** 							 break;
 2412              		.loc 1 695 0
 2413 1458 0E40A0E1 		mov	r4, lr
 2414 145c EFFDFFEA 		b	.L119
 2415              	.LVL191:
 2416              	.L162:
 650:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2417              		.loc 1 650 0
 2418 1460 001053E2 		subs	r1, r3, #0
 649:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2419              		.loc 1 649 0
 2420 1464 0D13C6E5 		strb	r1, [r6, #781]
 2421 1468 80359FE5 		ldr	r3, .L215
 650:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2422              		.loc 1 650 0
 2423 146c 3901001A 		bne	.L173
 651:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2424              		.loc 1 651 0
 2425 1470 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2426              	.LVL192:
 2427 1474 020052E3 		cmp	r2, #2
 2428 1478 08005213 		cmpne	r2, #8
 2429 147c 0300000A 		beq	.L174
 652:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2430              		.loc 1 652 0
 2431 1480 010052E3 		cmp	r2, #1
 653:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2432              		.loc 1 653 0
 2433 1484 07208202 		addeq	r2, r2, #7
 655:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2434              		.loc 1 655 0
 2435 1488 0220A013 		movne	r2, #2
 2436 148c B524C3E5 		strb	r2, [r3, #1205]
 2437              	.LVL193:
 2438              	.L174:
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2439              		.loc 1 677 0
 2440 1490 7C459FE5 		ldr	r4, .L215+36
 675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2441              		.loc 1 675 0
 2442 1494 0120A0E3 		mov	r2, #1
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2443              		.loc 1 677 0
 2444 1498 0010E0E3 		mvn	r1, #0
 675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2445              		.loc 1 675 0
 2446 149c 1023C6E5 		strb	r2, [r6, #784]
 2447              	.LVL194:
 677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2448              		.loc 1 677 0
 2449 14a0 1C0094E5 		ldr	r0, [r4, #28]
 2450 14a4 FEFFFFEB 		bl	_txe_mutex_get
 678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2451              		.loc 1 678 0
 2452 14a8 18C09DE5 		ldr	ip, [sp, #24]
 2453 14ac 1010A0E3 		mov	r1, #16
 2454 14b0 00C08DE5 		str	ip, [sp, #0]
 2455 14b4 0920A0E1 		mov	r2, r9
 2456 14b8 0A30A0E1 		mov	r3, sl
 2457 14bc 0400A0E1 		mov	r0, r4
 2458 14c0 00C0A0E3 		mov	ip, #0
 2459              	.LVL195:
 2460              	.L206:
 899:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2461              		.loc 1 899 0
 2462 14c4 04C08DE5 		str	ip, [sp, #4]
 2463 14c8 FEFFFFEB 		bl	cmdSet
 900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2464              		.loc 1 900 0
 2465 14cc 1C0094E5 		ldr	r0, [r4, #28]
 2466 14d0 FEFFFFEB 		bl	_txe_mutex_put
 902:../uvc.c      **** 					 		 break;
 2467              		.loc 1 902 0
 2468 14d4 FFE0A0E3 		mov	lr, #255
 900:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2469              		.loc 1 900 0
 2470 14d8 18309DE5 		ldr	r3, [sp, #24]
 2471 14dc 1CC09DE5 		ldr	ip, [sp, #28]
 902:../uvc.c      **** 					 		 break;
 2472              		.loc 1 902 0
 2473 14e0 0E40A0E1 		mov	r4, lr
 2474 14e4 CDFDFFEA 		b	.L119
 2475              	.LVL196:
 2476              	.L164:
 698:../uvc.c      **** 							 if(Data0 <= 3){
 2477              		.loc 1 698 0
 2478 14e8 030053E3 		cmp	r3, #3
 699:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2479              		.loc 1 699 0
 2480 14ec 08259F95 		ldrls	r2, .L215+12
 2481              	.LVL197:
 702:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2482              		.loc 1 702 0
 2483 14f0 04E59F85 		ldrhi	lr, .L215+12
 2484 14f4 0340A0E1 		mov	r4, r3
 2485              	.LVL198:
 699:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2486              		.loc 1 699 0
 2487 14f8 0030A093 		movls	r3, #0
 2488 14fc 7830C295 		strlsb	r3, [r2, #120]
 2489              	.LVL199:
 702:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2490              		.loc 1 702 0
 2491 1500 0120A083 		movhi	r2, #1
 2492 1504 18209D95 		ldrls	r2, [sp, #24]
 699:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2493              		.loc 1 699 0
 2494 1508 0430A091 		movls	r3, r4
 702:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2495              		.loc 1 702 0
 2496 150c 7820CE85 		strhib	r2, [lr, #120]
 2497 1510 0420A081 		movhi	r2, r4
 708:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2498              		.loc 1 708 0
 2499 1514 F8449FE5 		ldr	r4, .L215+36
 703:../uvc.c      **** 								 Data1 = Data0-4;
 2500              		.loc 1 703 0
 2501 1518 04304382 		subhi	r3, r3, #4
 2502              	.LVL200:
 705:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2503              		.loc 1 705 0
 2504 151c 2D24C6E5 		strb	r2, [r6, #1069]
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2505              		.loc 1 707 0
 2506 1520 0120A0E3 		mov	r2, #1
 708:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2507              		.loc 1 708 0
 2508 1524 0010E0E3 		mvn	r1, #0
 706:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2509              		.loc 1 706 0
 2510 1528 8D31C6E5 		strb	r3, [r6, #397]
 707:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2511              		.loc 1 707 0
 2512 152c 3024C6E5 		strb	r2, [r6, #1072]
 708:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2513              		.loc 1 708 0
 2514 1530 1C0094E5 		ldr	r0, [r4, #28]
 2515 1534 FEFFFFEB 		bl	_txe_mutex_get
 2516              	.LVL201:
 709:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2517              		.loc 1 709 0
 2518 1538 18C09DE5 		ldr	ip, [sp, #24]
 2519 153c 1C10A0E3 		mov	r1, #28
 2520 1540 00C08DE5 		str	ip, [sp, #0]
 2521 1544 0920A0E1 		mov	r2, r9
 2522 1548 0A30A0E1 		mov	r3, sl
 2523 154c 0400A0E1 		mov	r0, r4
 2524 1550 00C0A0E3 		mov	ip, #0
 2525 1554 DAFFFFEA 		b	.L206
 2526              	.LVL202:
 2527              	.L161:
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2528              		.loc 1 859 0
 2529 1558 B4449FE5 		ldr	r4, .L215+36
 2530 155c 0010E0E3 		mvn	r1, #0
 2531 1560 1C0094E5 		ldr	r0, [r4, #28]
 2532 1564 FEFFFFEB 		bl	_txe_mutex_get
 2533              	.LVL203:
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2534              		.loc 1 860 0
 2535 1568 18C09DE5 		ldr	ip, [sp, #24]
 2536 156c 0B10A0E3 		mov	r1, #11
 2537 1570 0920A0E1 		mov	r2, r9
 2538 1574 0A30A0E1 		mov	r3, sl
 2539 1578 0400A0E1 		mov	r0, r4
 2540 157c 00C08DE5 		str	ip, [sp, #0]
 2541 1580 00C0A0E3 		mov	ip, #0
 2542 1584 04C08DE5 		str	ip, [sp, #4]
 2543 1588 FEFFFFEB 		bl	cmdSet
 2544              	.LVL204:
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2545              		.loc 1 862 0
 2546 158c 1CE09DE5 		ldr	lr, [sp, #28]
 2547 1590 0B10A0E3 		mov	r1, #11
 2548 1594 0B20A0E1 		mov	r2, fp
 2549 1598 0A30A0E1 		mov	r3, sl
 2550 159c 0170A0E3 		mov	r7, #1
 2551              	.LVL205:
 2552 15a0 0400A0E1 		mov	r0, r4
 2553 15a4 00E08DE5 		str	lr, [sp, #0]
 2554 15a8 04708DE5 		str	r7, [sp, #4]
 2555 15ac FEFFFFEB 		bl	cmdSet
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2556              		.loc 1 863 0
 2557 15b0 1C0094E5 		ldr	r0, [r4, #28]
 2558 15b4 FEFFFFEB 		bl	_txe_mutex_put
 865:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2559              		.loc 1 865 0
 2560 15b8 18109DE5 		ldr	r1, [sp, #24]
 866:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2561              		.loc 1 866 0
 2562 15bc 1C209DE5 		ldr	r2, [sp, #28]
 868:../uvc.c      **** 							 break;
 2563              		.loc 1 868 0
 2564 15c0 FFE0A0E3 		mov	lr, #255
 865:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2565              		.loc 1 865 0
 2566 15c4 8C14C6E5 		strb	r1, [r6, #1164]
 866:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2567              		.loc 1 866 0
 2568 15c8 8E24C6E5 		strb	r2, [r6, #1166]
 867:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2569              		.loc 1 867 0
 2570 15cc 9872C6E5 		strb	r7, [r6, #664]
 2571 15d0 0130A0E1 		mov	r3, r1
 2572 15d4 02C0A0E1 		mov	ip, r2
 868:../uvc.c      **** 							 break;
 2573              		.loc 1 868 0
 2574 15d8 0E40A0E1 		mov	r4, lr
 2575 15dc 8FFDFFEA 		b	.L119
 2576              	.LVL206:
 2577              	.L160:
 845:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2578              		.loc 1 845 0
 2579 15e0 2C449FE5 		ldr	r4, .L215+36
 2580 15e4 0010E0E3 		mvn	r1, #0
 2581 15e8 1C0094E5 		ldr	r0, [r4, #28]
 2582 15ec FEFFFFEB 		bl	_txe_mutex_get
 2583              	.LVL207:
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2584              		.loc 1 846 0
 2585 15f0 18C09DE5 		ldr	ip, [sp, #24]
 2586 15f4 00E0A0E3 		mov	lr, #0
 2587 15f8 0610A0E3 		mov	r1, #6
 2588 15fc 0920A0E1 		mov	r2, r9
 2589 1600 0A30A0E1 		mov	r3, sl
 2590 1604 0400A0E1 		mov	r0, r4
 2591 1608 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2592 160c FEFFFFEB 		bl	cmdSet
 2593              	.LVL208:
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2594              		.loc 1 848 0
 2595 1610 18C09DE5 		ldr	ip, [sp, #24]
 2596 1614 0A30A0E1 		mov	r3, sl
 2597 1618 0170A0E3 		mov	r7, #1
 2598              	.LVL209:
 2599 161c 0610A0E3 		mov	r1, #6
 2600 1620 0B20A0E1 		mov	r2, fp
 2601 1624 0400A0E1 		mov	r0, r4
 2602 1628 00C08DE5 		str	ip, [sp, #0]
 2603 162c 04708DE5 		str	r7, [sp, #4]
 2604 1630 FEFFFFEB 		bl	cmdSet
 849:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2605              		.loc 1 849 0
 2606 1634 1C0094E5 		ldr	r0, [r4, #28]
 2607 1638 FEFFFFEB 		bl	_txe_mutex_put
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2608              		.loc 1 850 0
 2609 163c 18409DE5 		ldr	r4, [sp, #24]
 852:../uvc.c      **** 							 break;
 2610              		.loc 1 852 0
 2611 1640 FFE0A0E3 		mov	lr, #255
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2612              		.loc 1 850 0
 2613 1644 1D42C6E5 		strb	r4, [r6, #541]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2614              		.loc 1 851 0
 2615 1648 0430A0E1 		mov	r3, r4
 2616 164c 2072C6E5 		strb	r7, [r6, #544]
 2617 1650 1CC09DE5 		ldr	ip, [sp, #28]
 852:../uvc.c      **** 							 break;
 2618              		.loc 1 852 0
 2619 1654 0E40A0E1 		mov	r4, lr
 2620 1658 70FDFFEA 		b	.L119
 2621              	.LVL210:
 2622              	.L159:
 825:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2623              		.loc 1 825 0
 2624 165c B0439FE5 		ldr	r4, .L215+36
 2625 1660 0010E0E3 		mvn	r1, #0
 2626 1664 1C0094E5 		ldr	r0, [r4, #28]
 2627 1668 FEFFFFEB 		bl	_txe_mutex_get
 2628              	.LVL211:
 826:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2629              		.loc 1 826 0
 2630 166c 18009DE5 		ldr	r0, [sp, #24]
 2631 1670 00C0A0E3 		mov	ip, #0
 2632 1674 803040E2 		sub	r3, r0, #128
 2633 1678 FF7003E2 		and	r7, r3, #255
 2634              	.LVL212:
 2635 167c 0510A0E3 		mov	r1, #5
 2636 1680 0920A0E1 		mov	r2, r9
 2637 1684 0A30A0E1 		mov	r3, sl
 2638 1688 0400A0E1 		mov	r0, r4
 2639 168c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2640 1690 FEFFFFEB 		bl	cmdSet
 2641              	.LVL213:
 828:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2642              		.loc 1 828 0
 2643 1694 18109DE5 		ldr	r1, [sp, #24]
 2644 1698 DC20A0E3 		mov	r2, #220
 2645 169c 767041E2 		sub	r7, r1, #118
 2646 16a0 FFE007E2 		and	lr, r7, #255
 2647 16a4 0510A0E3 		mov	r1, #5
 2648 16a8 0170A0E3 		mov	r7, #1
 2649 16ac 0A30A0E1 		mov	r3, sl
 2650 16b0 0400A0E1 		mov	r0, r4
 2651 16b4 00E08DE5 		str	lr, [sp, #0]
 2652 16b8 04708DE5 		str	r7, [sp, #4]
 2653 16bc FEFFFFEB 		bl	cmdSet
 2654              	.LVL214:
 830:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2655              		.loc 1 830 0
 2656 16c0 18209DE5 		ldr	r2, [sp, #24]
 2657 16c4 0510A0E3 		mov	r1, #5
 2658 16c8 7E0082E2 		add	r0, r2, #126
 2659 16cc FFC000E2 		and	ip, r0, #255
 2660 16d0 DE20A0E3 		mov	r2, #222
 2661 16d4 0A30A0E1 		mov	r3, sl
 2662 16d8 0400A0E1 		mov	r0, r4
 2663 16dc 00C08DE5 		str	ip, [sp, #0]
 2664 16e0 02C0A0E3 		mov	ip, #2
 2665 16e4 04C08DE5 		str	ip, [sp, #4]
 2666 16e8 FEFFFFEB 		bl	cmdSet
 2667              	.LVL215:
 832:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2668              		.loc 1 832 0
 2669 16ec 18309DE5 		ldr	r3, [sp, #24]
 2670 16f0 E020A0E3 		mov	r2, #224
 2671 16f4 721083E2 		add	r1, r3, #114
 2672 16f8 FFC001E2 		and	ip, r1, #255
 2673 16fc 0A30A0E1 		mov	r3, sl
 2674 1700 0510A0E3 		mov	r1, #5
 2675 1704 0400A0E1 		mov	r0, r4
 2676 1708 00C08DE5 		str	ip, [sp, #0]
 2677 170c 03C0A0E3 		mov	ip, #3
 2678 1710 04C08DE5 		str	ip, [sp, #4]
 2679 1714 FEFFFFEB 		bl	cmdSet
 2680              	.LVL216:
 834:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2681              		.loc 1 834 0
 2682 1718 18209DE5 		ldr	r2, [sp, #24]
 2683 171c 0510A0E3 		mov	r1, #5
 2684 1720 6F0042E2 		sub	r0, r2, #111
 2685 1724 FFC000E2 		and	ip, r0, #255
 2686 1728 DD20A0E3 		mov	r2, #221
 2687 172c 0A30A0E1 		mov	r3, sl
 2688 1730 0400A0E1 		mov	r0, r4
 2689 1734 00C08DE5 		str	ip, [sp, #0]
 2690 1738 04C0A0E3 		mov	ip, #4
 2691 173c 04C08DE5 		str	ip, [sp, #4]
 2692 1740 FEFFFFEB 		bl	cmdSet
 2693              	.LVL217:
 836:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2694              		.loc 1 836 0
 2695 1744 B0329FE5 		ldr	r3, .L215+12
 2696 1748 05E0A0E3 		mov	lr, #5
 2697 174c 5810D3E5 		ldrb	r1, [r3, #88]	@ zero_extendqisi2
 2698 1750 0400A0E1 		mov	r0, r4
 2699 1754 7F2081E2 		add	r2, r1, #127
 2700 1758 FFC002E2 		and	ip, r2, #255
 2701 175c 0E10A0E1 		mov	r1, lr
 2702 1760 0A30A0E1 		mov	r3, sl
 2703 1764 0B20A0E1 		mov	r2, fp
 2704 1768 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2705 176c FEFFFFEB 		bl	cmdSet
 837:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2706              		.loc 1 837 0
 2707 1770 1C0094E5 		ldr	r0, [r4, #28]
 2708 1774 FEFFFFEB 		bl	_txe_mutex_put
 839:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2709              		.loc 1 839 0
 2710 1778 7C029FE5 		ldr	r0, .L215+12
 841:../uvc.c      **** 							 break;
 2711              		.loc 1 841 0
 2712 177c FFE0A0E3 		mov	lr, #255
 839:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2713              		.loc 1 839 0
 2714 1780 5830D0E5 		ldrb	r3, [r0, #88]	@ zero_extendqisi2
 840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2715              		.loc 1 840 0
 2716 1784 0872C6E5 		strb	r7, [r6, #520]
 839:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2717              		.loc 1 839 0
 2718 1788 801043E2 		sub	r1, r3, #128
 2719 178c 0512C6E5 		strb	r1, [r6, #517]
 840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2720              		.loc 1 840 0
 2721 1790 18309DE5 		ldr	r3, [sp, #24]
 2722 1794 1CC09DE5 		ldr	ip, [sp, #28]
 841:../uvc.c      **** 							 break;
 2723              		.loc 1 841 0
 2724 1798 0E40A0E1 		mov	r4, lr
 2725 179c 1FFDFFEA 		b	.L119
 2726              	.LVL218:
 2727              	.L158:
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2728              		.loc 1 877 0
 2729 17a0 6C429FE5 		ldr	r4, .L215+36
 871:../uvc.c      **** 							 Data0 = Data0 - 1;
 2730              		.loc 1 871 0
 2731 17a4 017043E2 		sub	r7, r3, #1
 2732              	.LVL219:
 2733 17a8 FF7007E2 		and	r7, r7, #255
 2734              	.LVL220:
 875:../uvc.c      **** 								 Data0 = 1;
 2735              		.loc 1 875 0
 2736 17ac 020057E3 		cmp	r7, #2
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2737              		.loc 1 877 0
 2738 17b0 0010E0E3 		mvn	r1, #0
 2739 17b4 1C0094E5 		ldr	r0, [r4, #28]
 875:../uvc.c      **** 								 Data0 = 1;
 2740              		.loc 1 875 0
 2741 17b8 0170A083 		movhi	r7, #1
 2742              	.LVL221:
 877:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2743              		.loc 1 877 0
 2744 17bc FEFFFFEB 		bl	_txe_mutex_get
 2745              	.LVL222:
 879:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2746              		.loc 1 879 0
 2747 17c0 1C0094E5 		ldr	r0, [r4, #28]
 2748 17c4 FEFFFFEB 		bl	_txe_mutex_put
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2749              		.loc 1 882 0
 2750 17c8 0130A0E3 		mov	r3, #1
 883:../uvc.c      **** 							 break;
 2751              		.loc 1 883 0
 2752 17cc FFE0A0E3 		mov	lr, #255
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2753              		.loc 1 882 0
 2754 17d0 F031C6E5 		strb	r3, [r6, #496]
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2755              		.loc 1 881 0
 2756 17d4 ED71C6E5 		strb	r7, [r6, #493]
 882:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2757              		.loc 1 882 0
 2758 17d8 18309DE5 		ldr	r3, [sp, #24]
 2759 17dc 1CC09DE5 		ldr	ip, [sp, #28]
 883:../uvc.c      **** 							 break;
 2760              		.loc 1 883 0
 2761 17e0 0E40A0E1 		mov	r4, lr
 2762 17e4 0DFDFFEA 		b	.L119
 2763              	.LVL223:
 2764              	.L157:
 807:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2765              		.loc 1 807 0
 2766 17e8 24429FE5 		ldr	r4, .L215+36
 2767 17ec 0010E0E3 		mvn	r1, #0
 2768 17f0 1C0094E5 		ldr	r0, [r4, #28]
 2769 17f4 FEFFFFEB 		bl	_txe_mutex_get
 2770              	.LVL224:
 809:../uvc.c      **** 							  if(Data0&0x80){
 2771              		.loc 1 809 0
 2772 17f8 18209DE5 		ldr	r2, [sp, #24]
 814:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2773              		.loc 1 814 0
 2774 17fc 00C0A0E3 		mov	ip, #0
 809:../uvc.c      **** 							  if(Data0&0x80){
 2775              		.loc 1 809 0
 2776 1800 800012E3 		tst	r2, #128
 810:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2777              		.loc 1 810 0
 2778 1804 80704212 		subne	r7, r2, #128
 2779              	.LVL225:
 812:../uvc.c      **** 								  Data0 = ~Data0;
 2780              		.loc 1 812 0
 2781 1808 0270E001 		mvneq	r7, r2
 814:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2782              		.loc 1 814 0
 2783 180c 0A30A0E1 		mov	r3, sl
 812:../uvc.c      **** 								  Data0 = ~Data0;
 2784              		.loc 1 812 0
 2785 1810 FF7007E2 		and	r7, r7, #255
 2786              	.LVL226:
 814:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2787              		.loc 1 814 0
 2788 1814 0110A0E3 		mov	r1, #1
 2789 1818 0B20A0E1 		mov	r2, fp
 2790 181c F0019FE5 		ldr	r0, .L215+36
 2791 1820 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2792 1824 FEFFFFEB 		bl	cmdSet
 815:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2793              		.loc 1 815 0
 2794 1828 1C0094E5 		ldr	r0, [r4, #28]
 2795 182c FEFFFFEB 		bl	_txe_mutex_put
 821:../uvc.c      **** 							 break;
 2796              		.loc 1 821 0
 2797 1830 FFE0A0E3 		mov	lr, #255
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2798              		.loc 1 818 0
 2799 1834 0100A0E3 		mov	r0, #1
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2800              		.loc 1 817 0
 2801 1838 A571C6E5 		strb	r7, [r6, #421]
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2802              		.loc 1 818 0
 2803 183c A801C6E5 		strb	r0, [r6, #424]
 2804 1840 18309DE5 		ldr	r3, [sp, #24]
 2805 1844 1CC09DE5 		ldr	ip, [sp, #28]
 821:../uvc.c      **** 							 break;
 2806              		.loc 1 821 0
 2807 1848 0E40A0E1 		mov	r4, lr
 2808 184c F3FCFFEA 		b	.L119
 2809              	.LVL227:
 2810              	.L156:
 887:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2811              		.loc 1 887 0
 2812 1850 A4219FE5 		ldr	r2, .L215+12
 2813              	.LVL228:
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2814              		.loc 1 886 0
 2815 1854 0100A0E3 		mov	r0, #1
 887:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2816              		.loc 1 887 0
 2817 1858 7820D2E5 		ldrb	r2, [r2, #120]	@ zero_extendqisi2
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2818              		.loc 1 885 0
 2819 185c 8D31C6E5 		strb	r3, [r6, #397]
 887:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2820              		.loc 1 887 0
 2821 1860 010052E3 		cmp	r2, #1
 886:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2822              		.loc 1 886 0
 2823 1864 9001C6E5 		strb	r0, [r6, #400]
 2824 1868 0370A011 		movne	r7, r3
 2825              	.LVL229:
 887:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2826              		.loc 1 887 0
 2827 186c 4E00000A 		beq	.L214
 2828              	.LVL230:
 2829              	.L189:
 898:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2830              		.loc 1 898 0
 2831 1870 9C419FE5 		ldr	r4, .L215+36
 2832 1874 0010E0E3 		mvn	r1, #0
 2833 1878 1C0094E5 		ldr	r0, [r4, #28]
 896:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2834              		.loc 1 896 0
 2835 187c 2D74C6E5 		strb	r7, [r6, #1069]
 2836              	.LVL231:
 898:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2837              		.loc 1 898 0
 2838 1880 FEFFFFEB 		bl	_txe_mutex_get
 899:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2839              		.loc 1 899 0
 2840 1884 00C0A0E3 		mov	ip, #0
 2841 1888 0C10A0E1 		mov	r1, ip
 2842 188c 0920A0E1 		mov	r2, r9
 2843 1890 0A30A0E1 		mov	r3, sl
 2844 1894 0400A0E1 		mov	r0, r4
 2845 1898 00708DE5 		str	r7, [sp, #0]
 2846 189c 08FFFFEA 		b	.L206
 2847              	.LVL232:
 2848              	.L155:
 906:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2849              		.loc 1 906 0
 2850 18a0 6C719FE5 		ldr	r7, .L215+36
 2851              	.LVL233:
 2852 18a4 0010E0E3 		mvn	r1, #0
 2853 18a8 1C0097E5 		ldr	r0, [r7, #28]
 2854 18ac FEFFFFEB 		bl	_txe_mutex_get
 2855              	.LVL234:
 907:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2856              		.loc 1 907 0
 2857 18b0 18C09DE5 		ldr	ip, [sp, #24]
 2858 18b4 0410A0E1 		mov	r1, r4
 2859 18b8 00E0A0E3 		mov	lr, #0
 2860 18bc 0A30A0E1 		mov	r3, sl
 2861 18c0 0920A0E1 		mov	r2, r9
 2862 18c4 0700A0E1 		mov	r0, r7
 2863 18c8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2864 18cc FEFFFFEB 		bl	cmdSet
 908:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2865              		.loc 1 908 0
 2866 18d0 1C0097E5 		ldr	r0, [r7, #28]
 2867 18d4 FEFFFFEB 		bl	_txe_mutex_put
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2868              		.loc 1 910 0
 2869 18d8 18109DE5 		ldr	r1, [sp, #24]
 2870 18dc 843084E0 		add	r3, r4, r4, asl #1
 2871 18e0 836186E0 		add	r6, r6, r3, asl #3
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2872              		.loc 1 911 0
 2873 18e4 01C0A0E3 		mov	ip, #1
 912:../uvc.c      **** 							 break;
 2874              		.loc 1 912 0
 2875 18e8 FFE0A0E3 		mov	lr, #255
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2876              		.loc 1 911 0
 2877 18ec 90C1C6E5 		strb	ip, [r6, #400]
 910:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2878              		.loc 1 910 0
 2879 18f0 8D11C6E5 		strb	r1, [r6, #397]
 911:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2880              		.loc 1 911 0
 2881 18f4 0130A0E1 		mov	r3, r1
 2882 18f8 1CC09DE5 		ldr	ip, [sp, #28]
 912:../uvc.c      **** 							 break;
 2883              		.loc 1 912 0
 2884 18fc 0E40A0E1 		mov	r4, lr
 2885 1900 C6FCFFEA 		b	.L119
 2886              	.LVL235:
 2887              	.L154:
 915:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2888              		.loc 1 915 0
 2889 1904 0400A0E3 		mov	r0, #4
 2890              	.LVL236:
 2891 1908 10119FE5 		ldr	r1, .L215+48
 2892 190c FEFFFFEB 		bl	CyU3PDebugPrint
 2893              	.LVL237:
 2894 1910 FFE0A0E3 		mov	lr, #255
 2895 1914 0E40A0E1 		mov	r4, lr
 2896 1918 0EC0A0E1 		mov	ip, lr
 2897 191c 0E30A0E1 		mov	r3, lr
 2898 1920 BEFCFFEA 		b	.L119
 2899              	.LVL238:
 2900              	.L213:
 464:../uvc.c      **** 						if(sendData >= 3){
 2901              		.loc 1 464 0
 2902 1924 020054E3 		cmp	r4, #2
 2903 1928 04408492 		addls	r4, r4, #4
 2904              	.LVL239:
 2905 192c FF400492 		andls	r4, r4, #255
 2906 1930 E5FDFF9A 		bls	.L132
 465:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2907              		.loc 1 465 0
 2908 1934 0430A0E1 		mov	r3, r4
 2909 1938 0400A0E3 		mov	r0, #4
 2910 193c E0109FE5 		ldr	r1, .L215+52
 2911 1940 FEFFFFEB 		bl	CyU3PDebugPrint
 2912              	.LVL240:
 467:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2913              		.loc 1 467 0
 2914 1944 A4309FE5 		ldr	r3, .L215
 2915 1948 0020A0E3 		mov	r2, #0
 2916 194c 0440A0E3 		mov	r4, #4
 2917 1950 2D24C3E5 		strb	r2, [r3, #1069]
 2918              	.LVL241:
 2919 1954 DCFDFFEA 		b	.L132
 2920              	.LVL242:
 2921              	.L173:
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2922              		.loc 1 660 0
 2923 1958 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2924              	.LVL243:
 659:../uvc.c      **** 								 Data1 = Data0 - 1;
 2925              		.loc 1 659 0
 2926 195c 014041E2 		sub	r4, r1, #1
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2927              		.loc 1 660 0
 2928 1960 040052E3 		cmp	r2, #4
 2929 1964 01005213 		cmpne	r2, #1
 659:../uvc.c      **** 								 Data1 = Data0 - 1;
 2930              		.loc 1 659 0
 2931 1968 FF1004E2 		and	r1, r4, #255
 2932              	.LVL244:
 660:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2933              		.loc 1 660 0
 2934 196c 0300000A 		beq	.L176
 661:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2935              		.loc 1 661 0
 2936 1970 080052E3 		cmp	r2, #8
 662:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2937              		.loc 1 662 0
 2938 1974 0120A003 		moveq	r2, #1
 664:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2939              		.loc 1 664 0
 2940 1978 0420A013 		movne	r2, #4
 2941 197c B524C3E5 		strb	r2, [r3, #1205]
 2942              	.L176:
 667:../uvc.c      **** 								 if(Data1 < 8){
 2943              		.loc 1 667 0
 2944 1980 070051E3 		cmp	r1, #7
 668:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2945              		.loc 1 668 0
 2946 1984 9C309F95 		ldrls	r3, .L215+56
 671:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2947              		.loc 1 671 0
 2948 1988 0130A083 		movhi	r3, #1
 669:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2949              		.loc 1 669 0
 2950 198c 81008390 		addls	r0, r3, r1, asl #1
 668:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2951              		.loc 1 668 0
 2952 1990 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 669:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2953              		.loc 1 669 0
 2954 1994 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 671:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2955              		.loc 1 671 0
 2956 1998 E534C685 		strhib	r3, [r6, #1253]
 672:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2957              		.loc 1 672 0
 2958 199c 0030A083 		movhi	r3, #0
 668:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2959              		.loc 1 668 0
 2960 19a0 E524C695 		strlsb	r2, [r6, #1253]
 672:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2961              		.loc 1 672 0
 2962 19a4 E634C6E5 		strb	r3, [r6, #1254]
 2963 19a8 B8FEFFEA 		b	.L174
 2964              	.LVL245:
 2965              	.L214:
 889:../uvc.c      **** 								 if(Data0 < 3){
 2966              		.loc 1 889 0
 2967 19ac 020053E3 		cmp	r3, #2
 890:../uvc.c      **** 					 				 Data0 += 4;
 2968              		.loc 1 890 0
 2969 19b0 04708392 		addls	r7, r3, #4
 2970 19b4 FF700792 		andls	r7, r7, #255
 889:../uvc.c      **** 								 if(Data0 < 3){
 2971              		.loc 1 889 0
 2972 19b8 ACFFFF9A 		bls	.L189
 892:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2973              		.loc 1 892 0
 2974 19bc 0400A0E3 		mov	r0, #4
 2975 19c0 5C109FE5 		ldr	r1, .L215+52
 2976 19c4 18309DE5 		ldr	r3, [sp, #24]
 2977 19c8 FEFFFFEB 		bl	CyU3PDebugPrint
 2978              	.LVL246:
 893:../uvc.c      **** 									Data0 = 4; //set to default.
 2979              		.loc 1 893 0
 2980 19cc 0470A0E3 		mov	r7, #4
 2981 19d0 A6FFFFEA 		b	.L189
 2982              	.LVL247:
 2983              	.L204:
 2984 19d4 20009FE5 		ldr	r0, .L215+12
 2985 19d8 AAFDFFEA 		b	.L130
 2986              	.LVL248:
 2987              	.L192:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2988              		.loc 1 408 0
 2989 19dc 0030A0E3 		mov	r3, #0
 2990 19e0 4AFEFFEA 		b	.L197
 2991              	.LVL249:
 2992              	.L191:
 2993 19e4 10009FE5 		ldr	r0, .L215+12
 2994 19e8 0030A0E3 		mov	r3, #0
 2995 19ec 9EFDFFEA 		b	.L196
 2996              	.L216:
 2997              		.align	2
 2998              	.L215:
 2999 19f0 00000000 		.word	.LANCHOR1
 3000 19f4 00000000 		.word	bRequest
 3001 19f8 48030000 		.word	.LC20
 3002 19fc 00000000 		.word	.LANCHOR0
 3003 1a00 58000000 		.word	.LANCHOR0+88
 3004 1a04 01000100 		.word	65537
 3005 1a08 FF00FF00 		.word	16711935
 3006 1a0c 88020000 		.word	.LC16
 3007 1a10 C4020000 		.word	.LC17
 3008 1a14 00000000 		.word	cmdQu
 3009 1a18 4C000000 		.word	.LANCHOR0+76
 3010 1a1c EC020000 		.word	.LC18
 3011 1a20 18030000 		.word	.LC19
 3012 1a24 50020000 		.word	.LC15
 3013 1a28 00000000 		.word	.LANCHOR2
 3014              		.cfi_endproc
 3015              	.LFE2:
 3017              		.align	2
 3018              		.global	CTControlHandle
 3020              	CTControlHandle:
 3021              	.LFB3:
 931:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3022              		.loc 1 931 0
 3023              		.cfi_startproc
 3024              		@ args = 0, pretend = 0, frame = 64
 3025              		@ frame_needed = 0, uses_anonymous_args = 0
 3026              	.LVL250:
 3027 1a2c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3028              	.LCFI15:
 3029              		.cfi_def_cfa_offset 36
 950:../uvc.c      ****     reqData = bRequest;
 3030              		.loc 1 950 0
 3031 1a30 60A99FE5 		ldr	sl, .L302
 3032              		.cfi_offset 14, -4
 3033              		.cfi_offset 11, -8
 3034              		.cfi_offset 10, -12
 3035              		.cfi_offset 9, -16
 3036              		.cfi_offset 8, -20
 3037              		.cfi_offset 7, -24
 3038              		.cfi_offset 6, -28
 3039              		.cfi_offset 5, -32
 3040              		.cfi_offset 4, -36
 942:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3041              		.loc 1 942 0
 3042 1a34 60899FE5 		ldr	r8, .L302+4
 950:../uvc.c      ****     reqData = bRequest;
 3043              		.loc 1 950 0
 3044 1a38 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 942:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3045              		.loc 1 942 0
 3046 1a3c 8090A0E1 		mov	r9, r0, asl #1
 3047 1a40 002089E0 		add	r2, r9, r0
 3048 1a44 822188E0 		add	r2, r8, r2, asl #3
 952:../uvc.c      ****     switch (bRequest)
 3049              		.loc 1 952 0
 3050 1a48 830055E3 		cmp	r5, #131
 931:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3051              		.loc 1 931 0
 3052 1a4c 5CD04DE2 		sub	sp, sp, #92
 3053              	.LCFI16:
 3054              		.cfi_def_cfa_offset 128
 931:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3055              		.loc 1 931 0
 3056 1a50 0060A0E1 		mov	r6, r0
 942:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3057              		.loc 1 942 0
 3058 1a54 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3059              	.LVL251:
 943:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3060              		.loc 1 943 0
 3061 1a58 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3062              	.LVL252:
 945:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3063              		.loc 1 945 0
 3064 1a5c 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3065              	.LVL253:
 952:../uvc.c      ****     switch (bRequest)
 3066              		.loc 1 952 0
 3067 1a60 7600000A 		beq	.L222
 3068 1a64 2100009A 		bls	.L297
 3069 1a68 850055E3 		cmp	r5, #133
 3070 1a6c 5900000A 		beq	.L224
 3071 1a70 4E00003A 		bcc	.L223
 3072 1a74 860055E3 		cmp	r5, #134
 3073 1a78 8000000A 		beq	.L225
 3074 1a7c 870055E3 		cmp	r5, #135
 3075 1a80 7600000A 		beq	.L298
 3076              	.L218:
1159:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3077              		.loc 1 1159 0
 3078 1a84 0000A0E3 		mov	r0, #0
 3079              	.LVL254:
 3080 1a88 0110A0E3 		mov	r1, #1
 3081 1a8c 0020A0E1 		mov	r2, r0
 3082 1a90 FEFFFFEB 		bl	CyU3PUsbStall
 3083              	.LVL255:
 3084 1a94 04499FE5 		ldr	r4, .L302+8
1160:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3085              		.loc 1 1160 0
 3086 1a98 0620A0E1 		mov	r2, r6
 3087 1a9c 0400A0E3 		mov	r0, #4
 3088 1aa0 FC189FE5 		ldr	r1, .L302+12
 3089 1aa4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3090 1aa8 FEFFFFEB 		bl	CyU3PDebugPrint
1161:../uvc.c      **** 			  break;
 3091              		.loc 1 1161 0
 3092 1aac FFC0A0E3 		mov	ip, #255
 3093 1ab0 0C60A0E1 		mov	r6, ip
 3094 1ab4 0C80A0E1 		mov	r8, ip
 3095              	.LVL256:
 3096              	.L228:
1165:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3097              		.loc 1 1165 0
 3098 1ab8 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3099 1abc 08C08DE5 		str	ip, [sp, #8]
 3100 1ac0 E0189FE5 		ldr	r1, .L302+16
 3101 1ac4 FFC0A0E3 		mov	ip, #255
 3102 1ac8 0520A0E1 		mov	r2, r5
 3103 1acc 0830A0E1 		mov	r3, r8
 3104 1ad0 0400A0E3 		mov	r0, #4
 3105 1ad4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3106 1ad8 0CC08DE5 		str	ip, [sp, #12]
 3107 1adc 10E08DE5 		str	lr, [sp, #16]
 3108 1ae0 14708DE5 		str	r7, [sp, #20]
 3109 1ae4 FEFFFFEB 		bl	CyU3PDebugPrint
1166:../uvc.c      **** }
 3110              		.loc 1 1166 0
 3111 1ae8 5CD08DE2 		add	sp, sp, #92
 3112 1aec F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3113              	.LVL257:
 3114              	.L297:
 952:../uvc.c      ****     switch (bRequest)
 3115              		.loc 1 952 0
 3116 1af0 810055E3 		cmp	r5, #129
 3117 1af4 4200000A 		beq	.L220
 3118 1af8 1100009A 		bls	.L299
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3119              		.loc 1 981 0
 3120 1afc 9C489FE5 		ldr	r4, .L302+8
 3121 1b00 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 982:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3122              		.loc 1 982 0
 3123 1b04 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 983:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3124              		.loc 1 983 0
 3125 1b08 0A0050E3 		cmp	r0, #10
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3126              		.loc 1 981 0
 3127 1b0c 5810C4E5 		strb	r1, [r4, #88]
 982:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3128              		.loc 1 982 0
 3129 1b10 5960C4E5 		strb	r6, [r4, #89]
 983:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3130              		.loc 1 983 0
 3131 1b14 2C00000A 		beq	.L296
 3132              	.LVL258:
 3133              	.L235:
1017:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3134              		.loc 1 1017 0
 3135 1b18 00E0A0E3 		mov	lr, #0
 3136 1b1c 5AE0C4E5 		strb	lr, [r4, #90]
 3137              	.L236:
1018:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3138              		.loc 1 1018 0
 3139 1b20 0030A0E3 		mov	r3, #0
1019:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3140              		.loc 1 1019 0
 3141 1b24 0700A0E1 		mov	r0, r7
 3142              	.LVL259:
 3143 1b28 7C189FE5 		ldr	r1, .L302+20
1021:../uvc.c      **** 			  break;
 3144              		.loc 1 1021 0
 3145 1b2c FF60A0E3 		mov	r6, #255
1018:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3146              		.loc 1 1018 0
 3147 1b30 5B30C4E5 		strb	r3, [r4, #91]
1021:../uvc.c      **** 			  break;
 3148              		.loc 1 1021 0
 3149 1b34 0680A0E1 		mov	r8, r6
1019:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3150              		.loc 1 1019 0
 3151 1b38 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3152              	.LVL260:
 3153 1b3c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
1021:../uvc.c      **** 			  break;
 3154              		.loc 1 1021 0
 3155 1b40 DCFFFFEA 		b	.L228
 3156              	.LVL261:
 3157              	.L299:
 952:../uvc.c      ****     switch (bRequest)
 3158              		.loc 1 952 0
 3159 1b44 010055E3 		cmp	r5, #1
 3160 1b48 CDFFFF1A 		bne	.L218
1023:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3161              		.loc 1 1023 0
 3162 1b4c 4C489FE5 		ldr	r4, .L302+8
 3163 1b50 56208DE2 		add	r2, sp, #86
 3164 1b54 2000A0E3 		mov	r0, #32
 3165              	.LVL262:
 3166 1b58 581084E2 		add	r1, r4, #88
 3167 1b5c 2C308DE5 		str	r3, [sp, #44]
 3168 1b60 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3169              	.LVL263:
1025:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3170              		.loc 1 1025 0
 3171 1b64 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
1026:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3172              		.loc 1 1026 0
 3173 1b68 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1029:../uvc.c      **** 			  switch(CtrlID)
 3174              		.loc 1 1029 0
 3175 1b6c 012046E2 		sub	r2, r6, #1
1025:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3176              		.loc 1 1025 0
 3177 1b70 30008DE5 		str	r0, [sp, #48]
 3178              	.LVL264:
1026:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3179              		.loc 1 1026 0
 3180 1b74 34C08DE5 		str	ip, [sp, #52]
 3181              	.LVL265:
1029:../uvc.c      **** 			  switch(CtrlID)
 3182              		.loc 1 1029 0
 3183 1b78 2C309DE5 		ldr	r3, [sp, #44]
 3184 1b7c 090052E3 		cmp	r2, #9
 3185 1b80 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3186 1b84 550100EA 		b	.L237
 3187              	.L242:
 3188 1b88 9C200000 		.word	.L238
 3189 1b8c E0200000 		.word	.L237
 3190 1b90 AC1D0000 		.word	.L239
 3191 1b94 E0200000 		.word	.L237
 3192 1b98 E0200000 		.word	.L237
 3193 1b9c E0200000 		.word	.L237
 3194 1ba0 281D0000 		.word	.L240
 3195 1ba4 E0200000 		.word	.L237
 3196 1ba8 E0200000 		.word	.L237
 3197 1bac AC1C0000 		.word	.L241
 3198              	.LVL266:
 3199              	.L223:
 999:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3200              		.loc 1 999 0
 3201 1bb0 E8479FE5 		ldr	r4, .L302+8
 3202 1bb4 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
1000:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3203              		.loc 1 1000 0
 3204 1bb8 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
1001:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3205              		.loc 1 1001 0
 3206 1bbc 0A0050E3 		cmp	r0, #10
 999:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3207              		.loc 1 999 0
 3208 1bc0 5880C4E5 		strb	r8, [r4, #88]
1000:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3209              		.loc 1 1000 0
 3210 1bc4 5920C4E5 		strb	r2, [r4, #89]
1001:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3211              		.loc 1 1001 0
 3212 1bc8 D2FFFF1A 		bne	.L235
 3213              	.LVL267:
 3214              	.L296:
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3215              		.loc 1 1016 0 discriminator 1
 3216 1bcc 0110A0E3 		mov	r1, #1
 3217 1bd0 5A10C4E5 		strb	r1, [r4, #90]
 3218 1bd4 D1FFFFEA 		b	.L236
 3219              	.LVL268:
 3220              	.L224:
 956:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3221              		.loc 1 956 0
 3222 1bd8 C0479FE5 		ldr	r4, .L302+8
 957:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3223              		.loc 1 957 0
 3224 1bdc 0030A0E3 		mov	r3, #0
 3225              	.LVL269:
 958:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3226              		.loc 1 958 0
 3227 1be0 0200A0E3 		mov	r0, #2
 3228              	.LVL270:
 3229 1be4 581084E2 		add	r1, r4, #88
 960:../uvc.c      **** 			  break;
 3230              		.loc 1 960 0
 3231 1be8 FF60A0E3 		mov	r6, #255
 956:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3232              		.loc 1 956 0
 3233 1bec 5870C4E5 		strb	r7, [r4, #88]
 957:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3234              		.loc 1 957 0
 3235 1bf0 5930C4E5 		strb	r3, [r4, #89]
 960:../uvc.c      **** 			  break;
 3236              		.loc 1 960 0
 3237 1bf4 0680A0E1 		mov	r8, r6
 958:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3238              		.loc 1 958 0
 3239 1bf8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3240              	.LVL271:
 3241 1bfc 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 960:../uvc.c      **** 			  break;
 3242              		.loc 1 960 0
 3243 1c00 ACFFFFEA 		b	.L228
 3244              	.LVL272:
 3245              	.L220:
 966:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3246              		.loc 1 966 0
 3247 1c04 94479FE5 		ldr	r4, .L302+8
 3248 1c08 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 967:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3249              		.loc 1 967 0
 3250 1c0c 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 968:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3251              		.loc 1 968 0
 3252 1c10 0080A0E3 		mov	r8, #0
 974:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3253              		.loc 1 974 0
 3254 1c14 0700A0E1 		mov	r0, r7
 3255              	.LVL273:
 3256 1c18 581084E2 		add	r1, r4, #88
 979:../uvc.c      **** 			  break;
 3257              		.loc 1 979 0
 3258 1c1c FF60A0E3 		mov	r6, #255
 967:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3259              		.loc 1 967 0
 3260 1c20 59C0C4E5 		strb	ip, [r4, #89]
 968:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3261              		.loc 1 968 0
 3262 1c24 5A80C4E5 		strb	r8, [r4, #90]
 969:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3263              		.loc 1 969 0
 3264 1c28 5B80C4E5 		strb	r8, [r4, #91]
 3265              	.LVL274:
 966:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3266              		.loc 1 966 0
 3267 1c2c 58A0C4E5 		strb	sl, [r4, #88]
 979:../uvc.c      **** 			  break;
 3268              		.loc 1 979 0
 3269 1c30 0680A0E1 		mov	r8, r6
 974:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3270              		.loc 1 974 0
 3271 1c34 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3272              	.LVL275:
 3273 1c38 0AC0A0E1 		mov	ip, sl
 979:../uvc.c      **** 			  break;
 3274              		.loc 1 979 0
 3275 1c3c 9DFFFFEA 		b	.L228
 3276              	.LVL276:
 3277              	.L222:
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3278              		.loc 1 990 0
 3279 1c40 58479FE5 		ldr	r4, .L302+8
 3280 1c44 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3281              	.LVL277:
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3282              		.loc 1 991 0
 3283 1c48 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3284              		.loc 1 992 0
 3285 1c4c 0A0050E3 		cmp	r0, #10
 990:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3286              		.loc 1 990 0
 3287 1c50 5830C4E5 		strb	r3, [r4, #88]
 991:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3288              		.loc 1 991 0
 3289 1c54 59E0C4E5 		strb	lr, [r4, #89]
 992:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3290              		.loc 1 992 0
 3291 1c58 AEFFFF1A 		bne	.L235
 3292 1c5c DAFFFFEA 		b	.L296
 3293              	.LVL278:
 3294              	.L298:
1014:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3295              		.loc 1 1014 0
 3296 1c60 38479FE5 		ldr	r4, .L302+8
 3297 1c64 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3298              		.loc 1 1015 0
 3299 1c68 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3300              		.loc 1 1016 0
 3301 1c6c 0A0050E3 		cmp	r0, #10
1014:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3302              		.loc 1 1014 0
 3303 1c70 5860C4E5 		strb	r6, [r4, #88]
1015:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3304              		.loc 1 1015 0
 3305 1c74 59C0C4E5 		strb	ip, [r4, #89]
1016:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3306              		.loc 1 1016 0
 3307 1c78 A6FFFF1A 		bne	.L235
 3308 1c7c D2FFFFEA 		b	.L296
 3309              	.L225:
1008:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3310              		.loc 1 1008 0
 3311 1c80 18479FE5 		ldr	r4, .L302+8
 3312 1c84 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3313              	.LVL279:
 3314 1c88 0410A0E1 		mov	r1, r4
 3315 1c8c 5800E1E5 		strb	r0, [r1, #88]!
1012:../uvc.c      **** 			  break;
 3316              		.loc 1 1012 0
 3317 1c90 FF60A0E3 		mov	r6, #255
1009:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3318              		.loc 1 1009 0
 3319 1c94 0100A0E3 		mov	r0, #1
 3320 1c98 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3321              	.LVL280:
1012:../uvc.c      **** 			  break;
 3322              		.loc 1 1012 0
 3323 1c9c 0680A0E1 		mov	r8, r6
1009:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3324              		.loc 1 1009 0
 3325 1ca0 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
1012:../uvc.c      **** 			  break;
 3326              		.loc 1 1012 0
 3327 1ca4 0170A0E3 		mov	r7, #1
 3328 1ca8 82FFFFEA 		b	.L228
 3329              	.LVL281:
 3330              	.L241:
1138:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3331              		.loc 1 1138 0
 3332 1cac FC669FE5 		ldr	r6, .L302+24
 3333 1cb0 0010E0E3 		mvn	r1, #0
 3334 1cb4 1C0096E5 		ldr	r0, [r6, #28]
 3335 1cb8 2C308DE5 		str	r3, [sp, #44]
 3336 1cbc FEFFFFEB 		bl	_txe_mutex_get
1139:../uvc.c      **** 					  if(getData == 1)
 3337              		.loc 1 1139 0
 3338 1cc0 30E09DE5 		ldr	lr, [sp, #48]
 3339 1cc4 2C309DE5 		ldr	r3, [sp, #44]
 3340 1cc8 01005EE3 		cmp	lr, #1
 3341 1ccc A901000A 		beq	.L300
1141:../uvc.c      **** 					  else if(getData == 0xff)
 3342              		.loc 1 1141 0
 3343 1cd0 FF005EE3 		cmp	lr, #255
 3344 1cd4 9E01000A 		beq	.L301
1144:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3345              		.loc 1 1144 0
 3346 1cd8 0080A0E3 		mov	r8, #0
 3347 1cdc 0600A0E1 		mov	r0, r6
 3348 1ce0 1710A0E3 		mov	r1, #23
 3349 1ce4 0B20A0E1 		mov	r2, fp
 3350 1ce8 00808DE5 		str	r8, [sp, #0]
 3351 1cec 04808DE5 		str	r8, [sp, #4]
 3352 1cf0 FEFFFFEB 		bl	cmdSet
 3353              	.L294:
1147:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3354              		.loc 1 1147 0
 3355 1cf4 1C0096E5 		ldr	r0, [r6, #28]
 3356 1cf8 FEFFFFEB 		bl	_txe_mutex_put
1149:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3357              		.loc 1 1149 0
 3358 1cfc 30809DE5 		ldr	r8, [sp, #48]
 3359 1d00 34609DE5 		ldr	r6, [sp, #52]
 3360 1d04 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3361 1d08 0400A0E3 		mov	r0, #4
 3362 1d0c A0169FE5 		ldr	r1, .L302+28
 3363 1d10 0820A0E1 		mov	r2, r8
 3364 1d14 0630A0E1 		mov	r3, r6
 3365 1d18 00C08DE5 		str	ip, [sp, #0]
 3366 1d1c FEFFFFEB 		bl	CyU3PDebugPrint
1150:../uvc.c      **** 					  break;
 3367              		.loc 1 1150 0
 3368 1d20 FFC0A0E3 		mov	ip, #255
 3369 1d24 63FFFFEA 		b	.L228
 3370              	.LVL282:
 3371              	.L240:
1115:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3372              		.loc 1 1115 0
 3373 1d28 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3374 1d2c 010058E3 		cmp	r8, #1
 3375 1d30 08005813 		cmpne	r8, #8
 3376 1d34 0000A013 		movne	r0, #0
 3377 1d38 0100A003 		moveq	r0, #1
 3378 1d3c 8001001A 		bne	.L291
 3379              	.LVL283:
1118:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3380              		.loc 1 1118 0
 3381 1d40 68869FE5 		ldr	r8, .L302+24
 3382 1d44 0010E0E3 		mvn	r1, #0
 3383 1d48 1C0098E5 		ldr	r0, [r8, #28]
 3384 1d4c 2C308DE5 		str	r3, [sp, #44]
 3385 1d50 FEFFFFEB 		bl	_txe_mutex_get
1119:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3386              		.loc 1 1119 0
 3387 1d54 30A09DE5 		ldr	sl, [sp, #48]
 3388 1d58 1610A0E3 		mov	r1, #22
 3389 1d5c 0B20A0E1 		mov	r2, fp
 3390 1d60 2C309DE5 		ldr	r3, [sp, #44]
 3391 1d64 00C0A0E3 		mov	ip, #0
 3392 1d68 0800A0E1 		mov	r0, r8
 3393 1d6c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3394 1d70 FEFFFFEB 		bl	cmdSet
1120:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3395              		.loc 1 1120 0
 3396 1d74 1C0098E5 		ldr	r0, [r8, #28]
 3397 1d78 FEFFFFEB 		bl	_txe_mutex_put
1123:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3398              		.loc 1 1123 0
 3399 1d7c 18069FE5 		ldr	r0, .L302+4
1124:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3400              		.loc 1 1124 0
 3401 1d80 34209DE5 		ldr	r2, [sp, #52]
1123:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3402              		.loc 1 1123 0
 3403 1d84 061089E0 		add	r1, r9, r6
 3404 1d88 813180E0 		add	r3, r0, r1, asl #3
1125:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3405              		.loc 1 1125 0
 3406 1d8c 0160A0E3 		mov	r6, #1
1123:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3407              		.loc 1 1123 0
 3408 1d90 9DA4C3E5 		strb	sl, [r3, #1181]
1124:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3409              		.loc 1 1124 0
 3410 1d94 9E24C3E5 		strb	r2, [r3, #1182]
1125:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3411              		.loc 1 1125 0
 3412 1d98 A064C3E5 		strb	r6, [r3, #1184]
 3413              	.LVL284:
 3414              	.L292:
1127:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3415              		.loc 1 1127 0
 3416 1d9c 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3417 1da0 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1132:../uvc.c      **** 					  break;
 3418              		.loc 1 1132 0
 3419 1da4 FFC0A0E3 		mov	ip, #255
 3420 1da8 42FFFFEA 		b	.L228
 3421              	.LVL285:
 3422              	.L239:
1081:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3423              		.loc 1 1081 0
 3424 1dac B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3425 1db0 010050E3 		cmp	r0, #1
 3426 1db4 04005013 		cmpne	r0, #4
 3427 1db8 5C01001A 		bne	.L249
1080:../uvc.c      **** 					  value = (value << 8)|Data0;
 3428              		.loc 1 1080 0
 3429 1dbc 30109DE5 		ldr	r1, [sp, #48]
 3430 1dc0 34E09DE5 		ldr	lr, [sp, #52]
 3431 1dc4 0E2481E1 		orr	r2, r1, lr, asl #8
1082:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3432              		.loc 1 1082 0
 3433 1dc8 F90052E3 		cmp	r2, #249
 3434 1dcc 5701008A 		bhi	.L249
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3435              		.loc 1 1087 0
 3436 1dd0 C8A042E2 		sub	sl, r2, #200
 3437 1dd4 0AC8A0E1 		mov	ip, sl, asl #16
 3438 1dd8 3CC08DE5 		str	ip, [sp, #60]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3439              		.loc 1 1089 0
 3440 1ddc 27A062E2 		rsb	sl, r2, #39
 3441 1de0 38A08DE5 		str	sl, [sp, #56]
 3442 1de4 3CA09DE5 		ldr	sl, [sp, #60]
 3443 1de8 C81062E2 		rsb	r1, r2, #200
 3444 1dec C80052E3 		cmp	r2, #200
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3445              		.loc 1 1087 0
 3446 1df0 640042E2 		sub	r0, r2, #100
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3447              		.loc 1 1089 0
 3448 1df4 0118A0E1 		mov	r1, r1, asl #16
 3449 1df8 64E062E2 		rsb	lr, r2, #100
 3450 1dfc 2A18A081 		movhi	r1, sl, lsr #16
 3451 1e00 2118A091 		movls	r1, r1, lsr #16
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3452              		.loc 1 1087 0
 3453 1e04 00C8A0E1 		mov	ip, r0, asl #16
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3454              		.loc 1 1089 0
 3455 1e08 640052E3 		cmp	r2, #100
 3456 1e0c 0E08A0E1 		mov	r0, lr, asl #16
 3457 1e10 2C08A081 		movhi	r0, ip, lsr #16
 3458 1e14 38C09DE5 		ldr	ip, [sp, #56]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3459              		.loc 1 1087 0
 3460 1e18 14A042E2 		sub	sl, r2, #20
 3461 1e1c 38A08DE5 		str	sl, [sp, #56]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3462              		.loc 1 1089 0
 3463 1e20 2008A091 		movls	r0, r0, lsr #16
 3464 1e24 14A062E2 		rsb	sl, r2, #20
 3465 1e28 3CA08DE5 		str	sl, [sp, #60]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3466              		.loc 1 1087 0
 3467 1e2c 27E042E2 		sub	lr, r2, #39
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3468              		.loc 1 1089 0
 3469 1e30 000051E1 		cmp	r1, r0
 3470 1e34 01A0A031 		movcc	sl, r1
 3471 1e38 00A0A021 		movcs	sl, r0
 3472 1e3c 0CC8A0E1 		mov	ip, ip, asl #16
 3473 1e40 270052E3 		cmp	r2, #39
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3474              		.loc 1 1087 0
 3475 1e44 0EE8A0E1 		mov	lr, lr, asl #16
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3476              		.loc 1 1089 0
 3477 1e48 2CE8A091 		movls	lr, ip, lsr #16
 3478 1e4c 64C59FE5 		ldr	ip, .L302+32
 3479 1e50 20A08DE5 		str	sl, [sp, #32]
 3480 1e54 01A06CE0 		rsb	sl, ip, r1
 3481 1e58 2EE8A081 		movhi	lr, lr, lsr #16
 3482 1e5c 00C07AE2 		rsbs	ip, sl, #0
 3483 1e60 0AC0ACE0 		adc	ip, ip, sl
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3484              		.loc 1 1087 0
 3485 1e64 38A09DE5 		ldr	sl, [sp, #56]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3486              		.loc 1 1089 0
 3487 1e68 44C08DE5 		str	ip, [sp, #68]
 3488              	.LVL286:
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3489              		.loc 1 1087 0
 3490 1e6c 0AC8A0E1 		mov	ip, sl, asl #16
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3491              		.loc 1 1089 0
 3492 1e70 3CA09DE5 		ldr	sl, [sp, #60]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3493              		.loc 1 1087 0
 3494 1e74 4CC08DE5 		str	ip, [sp, #76]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3495              		.loc 1 1089 0
 3496 1e78 0AC8A0E1 		mov	ip, sl, asl #16
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3497              		.loc 1 1087 0
 3498 1e7c 0AA042E2 		sub	sl, r2, #10
 3499 1e80 48A08DE5 		str	sl, [sp, #72]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3500              		.loc 1 1089 0
 3501 1e84 20A09DE5 		ldr	sl, [sp, #32]
 3502 1e88 3CC08DE5 		str	ip, [sp, #60]
 3503 1e8c 0A005EE1 		cmp	lr, sl
 3504 1e90 0EA0A031 		movcc	sl, lr
 3505 1e94 0AC062E2 		rsb	ip, r2, #10
 3506 1e98 40C08DE5 		str	ip, [sp, #64]
 3507 1e9c 38A08DE5 		str	sl, [sp, #56]
 3508 1ea0 3CC09DE5 		ldr	ip, [sp, #60]
 3509 1ea4 4CA09DE5 		ldr	sl, [sp, #76]
 3510 1ea8 140052E3 		cmp	r2, #20
 3511 1eac 2CA8A091 		movls	sl, ip, lsr #16
 3512 1eb0 2AA8A081 		movhi	sl, sl, lsr #16
 3513 1eb4 44C09DE5 		ldr	ip, [sp, #68]
 3514 1eb8 010050E1 		cmp	r0, r1
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3515              		.loc 1 1087 0
 3516 1ebc 48109DE5 		ldr	r1, [sp, #72]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3517              		.loc 1 1089 0
 3518 1ec0 01C0A033 		movcc	ip, #1
 3519 1ec4 3CA08DE5 		str	sl, [sp, #60]
 3520 1ec8 24C08DE5 		str	ip, [sp, #36]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3521              		.loc 1 1087 0
 3522 1ecc 01A8A0E1 		mov	sl, r1, asl #16
 3523 1ed0 05C042E2 		sub	ip, r2, #5
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3524              		.loc 1 1089 0
 3525 1ed4 051062E2 		rsb	r1, r2, #5
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3526              		.loc 1 1087 0
 3527 1ed8 48A08DE5 		str	sl, [sp, #72]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3528              		.loc 1 1089 0
 3529 1edc 40009DE5 		ldr	r0, [sp, #64]
 3530 1ee0 38A09DE5 		ldr	sl, [sp, #56]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3531              		.loc 1 1087 0
 3532 1ee4 40C08DE5 		str	ip, [sp, #64]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3533              		.loc 1 1089 0
 3534 1ee8 3CC09DE5 		ldr	ip, [sp, #60]
 3535 1eec 4C108DE5 		str	r1, [sp, #76]
 3536 1ef0 48109DE5 		ldr	r1, [sp, #72]
 3537 1ef4 0008A0E1 		mov	r0, r0, asl #16
 3538 1ef8 0A005CE1 		cmp	ip, sl
 3539 1efc 0AC0A021 		movcs	ip, sl
 3540 1f00 0A0052E3 		cmp	r2, #10
 3541 1f04 20A09DE5 		ldr	sl, [sp, #32]
 3542 1f08 2108A081 		movhi	r0, r1, lsr #16
 3543 1f0c 2008A091 		movls	r0, r0, lsr #16
 3544 1f10 48008DE5 		str	r0, [sp, #72]
 3545 1f14 24009DE5 		ldr	r0, [sp, #36]
 3546 1f18 0A005EE1 		cmp	lr, sl
 3547 1f1c 0200A033 		movcc	r0, #2
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3548              		.loc 1 1087 0
 3549 1f20 02E042E2 		sub	lr, r2, #2
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3550              		.loc 1 1089 0
 3551 1f24 44C08DE5 		str	ip, [sp, #68]
 3552 1f28 24008DE5 		str	r0, [sp, #36]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3553              		.loc 1 1087 0
 3554 1f2c 40C09DE5 		ldr	ip, [sp, #64]
 3555 1f30 1CE08DE5 		str	lr, [sp, #28]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3556              		.loc 1 1089 0
 3557 1f34 44009DE5 		ldr	r0, [sp, #68]
 3558 1f38 48E09DE5 		ldr	lr, [sp, #72]
 3559 1f3c 4C109DE5 		ldr	r1, [sp, #76]
 3560 1f40 02A062E2 		rsb	sl, r2, #2
 3561 1f44 00005EE1 		cmp	lr, r0
 3562 1f48 00E0A021 		movcs	lr, r0
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3563              		.loc 1 1087 0
 3564 1f4c 0CC8A0E1 		mov	ip, ip, asl #16
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3565              		.loc 1 1089 0
 3566 1f50 050052E3 		cmp	r2, #5
 3567 1f54 40A08DE5 		str	sl, [sp, #64]
 3568 1f58 0118A0E1 		mov	r1, r1, asl #16
 3569 1f5c 3CA09DE5 		ldr	sl, [sp, #60]
 3570 1f60 2C18A081 		movhi	r1, ip, lsr #16
 3571 1f64 38C09DE5 		ldr	ip, [sp, #56]
 3572 1f68 4CE08DE5 		str	lr, [sp, #76]
 3573 1f6c 24009DE5 		ldr	r0, [sp, #36]
 3574 1f70 40E09DE5 		ldr	lr, [sp, #64]
 3575 1f74 2118A091 		movls	r1, r1, lsr #16
 3576 1f78 0C005AE1 		cmp	sl, ip
 3577 1f7c 20108DE5 		str	r1, [sp, #32]
 3578 1f80 0300A033 		movcc	r0, #3
 3579 1f84 38008DE5 		str	r0, [sp, #56]
 3580 1f88 4CA09DE5 		ldr	sl, [sp, #76]
 3581 1f8c 0E08A0E1 		mov	r0, lr, asl #16
 3582 1f90 20E09DE5 		ldr	lr, [sp, #32]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3583              		.loc 1 1087 0
 3584 1f94 1C109DE5 		ldr	r1, [sp, #28]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3585              		.loc 1 1089 0
 3586 1f98 0A005EE1 		cmp	lr, sl
 3587 1f9c 0AE0A021 		movcs	lr, sl
 3588 1fa0 44C09DE5 		ldr	ip, [sp, #68]
 3589 1fa4 48A09DE5 		ldr	sl, [sp, #72]
 3590 1fa8 020052E3 		cmp	r2, #2
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3591              		.loc 1 1087 0
 3592 1fac 0118A0E1 		mov	r1, r1, asl #16
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3593              		.loc 1 1089 0
 3594 1fb0 2018A091 		movls	r1, r0, lsr #16
 3595 1fb4 38009DE5 		ldr	r0, [sp, #56]
 3596 1fb8 2118A081 		movhi	r1, r1, lsr #16
 3597 1fbc 0C005AE1 		cmp	sl, ip
 3598 1fc0 0400A033 		movcc	r0, #4
 3599 1fc4 40008DE5 		str	r0, [sp, #64]
1087:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3600              		.loc 1 1087 0
 3601 1fc8 010042E2 		sub	r0, r2, #1
 3602 1fcc 38008DE5 		str	r0, [sp, #56]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3603              		.loc 1 1089 0
 3604 1fd0 4CA09DE5 		ldr	sl, [sp, #76]
 3605 1fd4 20009DE5 		ldr	r0, [sp, #32]
 3606 1fd8 01C062E2 		rsb	ip, r2, #1
 3607 1fdc 3CC08DE5 		str	ip, [sp, #60]
 3608 1fe0 0A0050E1 		cmp	r0, sl
1096:../uvc.c      **** 						  shutter = shutter+index;
 3609              		.loc 1 1096 0
 3610 1fe4 38A09DE5 		ldr	sl, [sp, #56]
 3611 1fe8 3C009DE5 		ldr	r0, [sp, #60]
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3612              		.loc 1 1089 0
 3613 1fec 40C09DE5 		ldr	ip, [sp, #64]
 3614 1ff0 05C0A033 		movcc	ip, #5
1096:../uvc.c      **** 						  shutter = shutter+index;
 3615              		.loc 1 1096 0
 3616 1ff4 010052E3 		cmp	r2, #1
 3617 1ff8 0028A091 		movls	r2, r0, asl #16
 3618 1ffc 0A28A081 		movhi	r2, sl, asl #16
 3619 2000 0E0051E1 		cmp	r1, lr
 3620 2004 01A0A031 		movcc	sl, r1
 3621 2008 0EA0A021 		movcs	sl, lr
1089:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3622              		.loc 1 1089 0
 3623 200c 0E0051E1 		cmp	r1, lr
 3624 2010 0C10A021 		movcs	r1, ip
 3625 2014 0610A033 		movcc	r1, #6
1096:../uvc.c      **** 						  shutter = shutter+index;
 3626              		.loc 1 1096 0
 3627 2018 22085AE1 		cmp	sl, r2, lsr #16
1099:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3628              		.loc 1 1099 0
 3629 201c 8CA39FE5 		ldr	sl, .L302+24
1096:../uvc.c      **** 						  shutter = shutter+index;
 3630              		.loc 1 1096 0
 3631 2020 0120A091 		movls	r2, r1
 3632 2024 0720A083 		movhi	r2, #7
 3633 2028 012082E2 		add	r2, r2, #1
 3634 202c FFE002E2 		and	lr, r2, #255
1099:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3635              		.loc 1 1099 0
 3636 2030 0010E0E3 		mvn	r1, #0
 3637 2034 1C009AE5 		ldr	r0, [sl, #28]
1096:../uvc.c      **** 						  shutter = shutter+index;
 3638              		.loc 1 1096 0
 3639 2038 38E08DE5 		str	lr, [sp, #56]
 3640              	.LVL287:
1099:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3641              		.loc 1 1099 0
 3642 203c 2C308DE5 		str	r3, [sp, #44]
 3643 2040 FEFFFFEB 		bl	_txe_mutex_get
1100:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3644              		.loc 1 1100 0
 3645 2044 38C09DE5 		ldr	ip, [sp, #56]
 3646 2048 0310A0E3 		mov	r1, #3
 3647 204c 0B20A0E1 		mov	r2, fp
 3648 2050 2C309DE5 		ldr	r3, [sp, #44]
 3649 2054 00C08DE5 		str	ip, [sp, #0]
 3650 2058 0A00A0E1 		mov	r0, sl
 3651 205c 00C0A0E3 		mov	ip, #0
 3652 2060 04C08DE5 		str	ip, [sp, #4]
 3653 2064 FEFFFFEB 		bl	cmdSet
1101:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3654              		.loc 1 1101 0
 3655 2068 1C009AE5 		ldr	r0, [sl, #28]
 3656 206c FEFFFFEB 		bl	_txe_mutex_put
1104:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3657              		.loc 1 1104 0
 3658 2070 30009DE5 		ldr	r0, [sp, #48]
1105:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3659              		.loc 1 1105 0
 3660 2074 34C09DE5 		ldr	ip, [sp, #52]
1107:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3661              		.loc 1 1107 0
 3662 2078 38309DE5 		ldr	r3, [sp, #56]
1104:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3663              		.loc 1 1104 0
 3664 207c 061089E0 		add	r1, r9, r6
 3665 2080 816188E0 		add	r6, r8, r1, asl #3
1106:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3666              		.loc 1 1106 0
 3667 2084 0120A0E3 		mov	r2, #1
1104:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3668              		.loc 1 1104 0
 3669 2088 9D04C6E5 		strb	r0, [r6, #1181]
1105:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3670              		.loc 1 1105 0
 3671 208c 9EC4C6E5 		strb	ip, [r6, #1182]
1106:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3672              		.loc 1 1106 0
 3673 2090 A024C6E5 		strb	r2, [r6, #1184]
1107:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3674              		.loc 1 1107 0
 3675 2094 0D33C8E5 		strb	r3, [r8, #781]
 3676 2098 3FFFFFEA 		b	.L292
 3677              	.LVL288:
 3678              	.L238:
1034:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3679              		.loc 1 1034 0
 3680 209c 062089E0 		add	r2, r9, r6
 3681 20a0 826188E0 		add	r6, r8, r2, asl #3
1035:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3682              		.loc 1 1035 0
 3683 20a4 0110A0E3 		mov	r1, #1
1038:../uvc.c      **** 		  		    switch (getData){
 3684              		.loc 1 1038 0
 3685 20a8 01E040E2 		sub	lr, r0, #1
1034:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3686              		.loc 1 1034 0
 3687 20ac 9D04C6E5 		strb	r0, [r6, #1181]
1035:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3688              		.loc 1 1035 0
 3689 20b0 A014C6E5 		strb	r1, [r6, #1184]
 3690              	.LVL289:
1038:../uvc.c      **** 		  		    switch (getData){
 3691              		.loc 1 1038 0
 3692 20b4 07005EE3 		cmp	lr, #7
 3693 20b8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3694 20bc 970000EA 		b	.L243
 3695              	.L248:
 3696 20c0 B4220000 		.word	.L244
 3697 20c4 18220000 		.word	.L245
 3698 20c8 20230000 		.word	.L243
 3699 20cc B4210000 		.word	.L246
 3700 20d0 20230000 		.word	.L243
 3701 20d4 20230000 		.word	.L243
 3702 20d8 20230000 		.word	.L243
 3703 20dc 14210000 		.word	.L247
 3704              	.LVL290:
 3705              	.L237:
1154:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3706              		.loc 1 1154 0
 3707 20e0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1153:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3708              		.loc 1 1153 0
 3709 20e4 30A09DE5 		ldr	sl, [sp, #48]
 3710 20e8 069089E0 		add	r9, r9, r6
 3711 20ec 89E188E0 		add	lr, r8, r9, asl #3
1154:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3712              		.loc 1 1154 0
 3713 20f0 0620A0E1 		mov	r2, r6
 3714 20f4 0400A0E3 		mov	r0, #4
 3715 20f8 BC129FE5 		ldr	r1, .L302+36
1153:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3716              		.loc 1 1153 0
 3717 20fc 9DA4CEE5 		strb	sl, [lr, #1181]
1154:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3718              		.loc 1 1154 0
 3719 2100 FEFFFFEB 		bl	CyU3PDebugPrint
1155:../uvc.c      **** 			  		 break;
 3720              		.loc 1 1155 0
 3721 2104 FFC0A0E3 		mov	ip, #255
 3722 2108 0C60A0E1 		mov	r6, ip
 3723 210c 0C80A0E1 		mov	r8, ip
 3724 2110 68FEFFEA 		b	.L228
 3725              	.LVL291:
 3726              	.L247:
1057:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3727              		.loc 1 1057 0
 3728 2114 94629FE5 		ldr	r6, .L302+24
1055:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3729              		.loc 1 1055 0
 3730 2118 00A0A0E3 		mov	sl, #0
1057:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3731              		.loc 1 1057 0
 3732 211c 1C0096E5 		ldr	r0, [r6, #28]
1055:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3733              		.loc 1 1055 0
 3734 2120 0DA3C8E5 		strb	sl, [r8, #781]
 3735              	.LVL292:
1057:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3736              		.loc 1 1057 0
 3737 2124 0010E0E3 		mvn	r1, #0
 3738 2128 2C308DE5 		str	r3, [sp, #44]
 3739 212c FEFFFFEB 		bl	_txe_mutex_get
1058:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3740              		.loc 1 1058 0
 3741 2130 0B20A0E1 		mov	r2, fp
 3742 2134 2C309DE5 		ldr	r3, [sp, #44]
 3743 2138 1010A0E3 		mov	r1, #16
 3744 213c 0600A0E1 		mov	r0, r6
 3745 2140 00A08DE5 		str	sl, [sp, #0]
 3746 2144 04A08DE5 		str	sl, [sp, #4]
 3747 2148 FEFFFFEB 		bl	cmdSet
1059:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3748              		.loc 1 1059 0
 3749 214c 1C0096E5 		ldr	r0, [r6, #28]
 3750 2150 FEFFFFEB 		bl	_txe_mutex_put
 3751              	.LVL293:
 3752              	.LBB65:
 3753              	.LBB66:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3754              		.loc 1 402 0
 3755 2154 0010E0E3 		mvn	r1, #0
 3756 2158 1C0096E5 		ldr	r0, [r6, #28]
 3757 215c FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3758              		.loc 1 403 0
 3759 2160 0180A0E3 		mov	r8, #1
 3760 2164 1410A0E3 		mov	r1, #20
 3761 2168 2720A0E3 		mov	r2, #39
 3762 216c 3030A0E3 		mov	r3, #48
 3763 2170 0600A0E1 		mov	r0, r6
 3764 2174 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3765 2178 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3766              		.loc 1 404 0
 3767 217c 02C0A0E3 		mov	ip, #2
 3768 2180 1510A0E3 		mov	r1, #21
 3769 2184 2520A0E3 		mov	r2, #37
 3770 2188 3030A0E3 		mov	r3, #48
 3771 218c 0600A0E1 		mov	r0, r6
 3772 2190 00C08DE5 		str	ip, [sp, #0]
 3773 2194 04A08DE5 		str	sl, [sp, #4]
 3774 2198 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3775              		.loc 1 405 0
 3776 219c 1C0096E5 		ldr	r0, [r6, #28]
 3777 21a0 FEFFFFEB 		bl	_txe_mutex_put
 3778              	.LBE66:
 3779              	.LBE65:
1061:../uvc.c      **** 							break;
 3780              		.loc 1 1061 0
 3781 21a4 FFC0A0E3 		mov	ip, #255
 3782 21a8 0C60A0E1 		mov	r6, ip
 3783 21ac 0880A0E3 		mov	r8, #8
 3784 21b0 40FEFFEA 		b	.L228
 3785              	.LVL294:
 3786              	.L246:
 3787              	.LBB67:
 3788              	.LBB68:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3789              		.loc 1 402 0
 3790 21b4 F4819FE5 		ldr	r8, .L302+24
 3791 21b8 0010E0E3 		mvn	r1, #0
 3792 21bc 1C0098E5 		ldr	r0, [r8, #28]
 3793 21c0 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3794              		.loc 1 403 0
 3795 21c4 0060A0E3 		mov	r6, #0
 3796 21c8 1410A0E3 		mov	r1, #20
 3797 21cc 2720A0E3 		mov	r2, #39
 3798 21d0 3030A0E3 		mov	r3, #48
 3799 21d4 0800A0E1 		mov	r0, r8
 3800 21d8 00608DE5 		str	r6, [sp, #0]
 3801 21dc 04608DE5 		str	r6, [sp, #4]
 3802 21e0 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3803              		.loc 1 404 0
 3804 21e4 1510A0E3 		mov	r1, #21
 3805 21e8 2520A0E3 		mov	r2, #37
 3806 21ec 3030A0E3 		mov	r3, #48
 3807 21f0 0800A0E1 		mov	r0, r8
 3808 21f4 00608DE5 		str	r6, [sp, #0]
 3809 21f8 04608DE5 		str	r6, [sp, #4]
 3810 21fc FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3811              		.loc 1 405 0
 3812 2200 1C0098E5 		ldr	r0, [r8, #28]
 3813 2204 FEFFFFEB 		bl	_txe_mutex_put
 3814 2208 FFC0A0E3 		mov	ip, #255
 3815 220c 0C60A0E1 		mov	r6, ip
 3816 2210 0480A0E3 		mov	r8, #4
 3817 2214 27FEFFEA 		b	.L228
 3818              	.LVL295:
 3819              	.L245:
 3820              	.LBE68:
 3821              	.LBE67:
1045:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3822              		.loc 1 1045 0
 3823 2218 90A19FE5 		ldr	sl, .L302+24
1043:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3824              		.loc 1 1043 0
 3825 221c 0060A0E3 		mov	r6, #0
 3826 2220 0D63C8E5 		strb	r6, [r8, #781]
 3827              	.LVL296:
1045:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3828              		.loc 1 1045 0
 3829 2224 0010E0E3 		mvn	r1, #0
 3830 2228 1C009AE5 		ldr	r0, [sl, #28]
 3831 222c 2C308DE5 		str	r3, [sp, #44]
 3832 2230 FEFFFFEB 		bl	_txe_mutex_get
1046:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3833              		.loc 1 1046 0
 3834 2234 0B20A0E1 		mov	r2, fp
 3835 2238 2C309DE5 		ldr	r3, [sp, #44]
 3836 223c 1010A0E3 		mov	r1, #16
 3837 2240 0A00A0E1 		mov	r0, sl
 3838 2244 00608DE5 		str	r6, [sp, #0]
 3839 2248 04608DE5 		str	r6, [sp, #4]
 3840 224c FEFFFFEB 		bl	cmdSet
1047:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3841              		.loc 1 1047 0
 3842 2250 1C009AE5 		ldr	r0, [sl, #28]
 3843 2254 FEFFFFEB 		bl	_txe_mutex_put
 3844              	.LVL297:
 3845              	.LBB69:
 3846              	.LBB70:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3847              		.loc 1 402 0
 3848 2258 0010E0E3 		mvn	r1, #0
 3849 225c 1C009AE5 		ldr	r0, [sl, #28]
 3850 2260 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3851              		.loc 1 403 0
 3852 2264 1410A0E3 		mov	r1, #20
 3853 2268 2720A0E3 		mov	r2, #39
 3854 226c 3030A0E3 		mov	r3, #48
 3855 2270 0A00A0E1 		mov	r0, sl
 3856 2274 00608DE5 		str	r6, [sp, #0]
 3857 2278 04608DE5 		str	r6, [sp, #4]
 3858 227c FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3859              		.loc 1 404 0
 3860 2280 1510A0E3 		mov	r1, #21
 3861 2284 2520A0E3 		mov	r2, #37
 3862 2288 3030A0E3 		mov	r3, #48
 3863 228c 0A00A0E1 		mov	r0, sl
 3864 2290 00608DE5 		str	r6, [sp, #0]
 3865 2294 04608DE5 		str	r6, [sp, #4]
 3866 2298 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3867              		.loc 1 405 0
 3868 229c 1C009AE5 		ldr	r0, [sl, #28]
 3869 22a0 FEFFFFEB 		bl	_txe_mutex_put
 3870 22a4 FFC0A0E3 		mov	ip, #255
 3871 22a8 0C60A0E1 		mov	r6, ip
 3872 22ac 0280A0E3 		mov	r8, #2
 3873 22b0 00FEFFEA 		b	.L228
 3874              	.LVL298:
 3875              	.L244:
 3876              	.LBE70:
 3877              	.LBE69:
 3878              	.LBB71:
 3879              	.LBB72:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3880              		.loc 1 402 0
 3881 22b4 F4609FE5 		ldr	r6, .L302+24
 3882 22b8 0010E0E3 		mvn	r1, #0
 3883 22bc 1C0096E5 		ldr	r0, [r6, #28]
 3884 22c0 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3885              		.loc 1 403 0
 3886 22c4 0080A0E3 		mov	r8, #0
 3887 22c8 01A0A0E3 		mov	sl, #1
 3888 22cc 1410A0E3 		mov	r1, #20
 3889 22d0 2720A0E3 		mov	r2, #39
 3890 22d4 3030A0E3 		mov	r3, #48
 3891 22d8 0600A0E1 		mov	r0, r6
 3892 22dc 04808DE5 		str	r8, [sp, #4]
 3893 22e0 00A08DE5 		str	sl, [sp, #0]
 3894 22e4 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3895              		.loc 1 404 0
 3896 22e8 02C0A0E3 		mov	ip, #2
 3897 22ec 1510A0E3 		mov	r1, #21
 3898 22f0 2520A0E3 		mov	r2, #37
 3899 22f4 3030A0E3 		mov	r3, #48
 3900 22f8 0600A0E1 		mov	r0, r6
 3901 22fc 00C08DE5 		str	ip, [sp, #0]
 3902 2300 04808DE5 		str	r8, [sp, #4]
 3903 2304 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3904              		.loc 1 405 0
 3905 2308 1C0096E5 		ldr	r0, [r6, #28]
 3906 230c FEFFFFEB 		bl	_txe_mutex_put
 3907              	.LBE72:
 3908              	.LBE71:
1041:../uvc.c      **** 							break;
 3909              		.loc 1 1041 0
 3910 2310 FFC0A0E3 		mov	ip, #255
 3911 2314 0C60A0E1 		mov	r6, ip
 3912 2318 0A80A0E1 		mov	r8, sl
 3913 231c E5FDFFEA 		b	.L228
 3914              	.LVL299:
 3915              	.L243:
1038:../uvc.c      **** 		  		    switch (getData){
 3916              		.loc 1 1038 0
 3917 2320 FFC0A0E3 		mov	ip, #255
 3918 2324 0080A0E1 		mov	r8, r0
 3919 2328 0C60A0E1 		mov	r6, ip
 3920 232c E1FDFFEA 		b	.L228
 3921              	.LVL300:
 3922              	.L249:
1109:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3923              		.loc 1 1109 0
 3924 2330 0000A0E3 		mov	r0, #0
 3925 2334 0110A0E3 		mov	r1, #1
 3926 2338 0020A0E1 		mov	r2, r0
 3927 233c FEFFFFEB 		bl	CyU3PUsbStall
 3928              	.LVL301:
 3929 2340 95FEFFEA 		b	.L292
 3930              	.LVL302:
 3931              	.L291:
1127:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3932              		.loc 1 1127 0
 3933 2344 0110A0E3 		mov	r1, #1
 3934 2348 0020A0E1 		mov	r2, r0
 3935 234c FEFFFFEB 		bl	CyU3PUsbStall
 3936 2350 91FEFFEA 		b	.L292
 3937              	.LVL303:
 3938              	.L301:
1142:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3939              		.loc 1 1142 0
 3940 2354 08E0A0E3 		mov	lr, #8
 3941 2358 00C0A0E3 		mov	ip, #0
 3942 235c 0600A0E1 		mov	r0, r6
 3943 2360 1710A0E3 		mov	r1, #23
 3944 2364 0B20A0E1 		mov	r2, fp
 3945 2368 00E08DE5 		str	lr, [sp, #0]
 3946 236c 04C08DE5 		str	ip, [sp, #4]
 3947 2370 FEFFFFEB 		bl	cmdSet
 3948 2374 5EFEFFEA 		b	.L294
 3949              	.L300:
1140:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3950              		.loc 1 1140 0
 3951 2378 0480A0E3 		mov	r8, #4
 3952 237c 00E0A0E3 		mov	lr, #0
 3953 2380 0600A0E1 		mov	r0, r6
 3954 2384 1710A0E3 		mov	r1, #23
 3955 2388 0B20A0E1 		mov	r2, fp
 3956 238c 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3957 2390 FEFFFFEB 		bl	cmdSet
 3958 2394 56FEFFEA 		b	.L294
 3959              	.L303:
 3960              		.align	2
 3961              	.L302:
 3962 2398 00000000 		.word	bRequest
 3963 239c 00000000 		.word	.LANCHOR1
 3964 23a0 00000000 		.word	.LANCHOR0
 3965 23a4 E4030000 		.word	.LC23
 3966 23a8 08040000 		.word	.LC24
 3967 23ac 58000000 		.word	.LANCHOR0+88
 3968 23b0 00000000 		.word	cmdQu
 3969 23b4 98030000 		.word	.LC21
 3970 23b8 FFFF0000 		.word	65535
 3971 23bc C0030000 		.word	.LC22
 3972              		.cfi_endproc
 3973              	.LFE3:
 3975              		.align	2
 3976              		.global	UVCAppEP0Thread_Entry
 3978              	UVCAppEP0Thread_Entry:
 3979              	.LFB24:
3162:../uvc.c      **** {
 3980              		.loc 1 3162 0
 3981              		.cfi_startproc
 3982              		@ args = 0, pretend = 0, frame = 32
 3983              		@ frame_needed = 0, uses_anonymous_args = 0
 3984              	.LVL304:
 3985 23c0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3986              	.LCFI17:
 3987              		.cfi_def_cfa_offset 36
 3988 23c4 2C4A9FE5 		ldr	r4, .L452
 3989              		.cfi_offset 14, -4
 3990              		.cfi_offset 11, -8
 3991              		.cfi_offset 10, -12
 3992              		.cfi_offset 9, -16
 3993              		.cfi_offset 8, -20
 3994              		.cfi_offset 7, -24
 3995              		.cfi_offset 6, -28
 3996              		.cfi_offset 5, -32
 3997              		.cfi_offset 4, -36
 3998 23c8 2C6A9FE5 		ldr	r6, .L452+4
 3999 23cc 2CAA9FE5 		ldr	sl, .L452+8
 4000 23d0 2C9A9FE5 		ldr	r9, .L452+12
 4001 23d4 2C8A9FE5 		ldr	r8, .L452+16
 4002 23d8 2C7A9FE5 		ldr	r7, .L452+20
 4003 23dc 3CD04DE2 		sub	sp, sp, #60
 4004              	.LCFI18:
 4005              		.cfi_def_cfa_offset 96
 4006              	.LVL305:
3184:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4007              		.loc 1 3184 0
 4008 23e0 0450A0E1 		mov	r5, r4
 4009              	.LVL306:
 4010              	.L429:
 4011 23e4 00C0E0E3 		mvn	ip, #0
 4012 23e8 080A9FE5 		ldr	r0, .L452
 4013 23ec 4C10A0E3 		mov	r1, #76
 4014 23f0 0120A0E3 		mov	r2, #1
 4015 23f4 30308DE2 		add	r3, sp, #48
 4016 23f8 00C08DE5 		str	ip, [sp, #0]
 4017 23fc FEFFFFEB 		bl	_txe_event_flags_get
 4018 2400 000050E3 		cmp	r0, #0
 4019 2404 3000001A 		bne	.L305
3188:../uvc.c      ****             if (!isUsbConnected)
 4020              		.loc 1 3188 0
 4021 2408 403095E5 		ldr	r3, [r5, #64]
 4022 240c 000053E3 		cmp	r3, #0
 4023 2410 8900000A 		beq	.L442
 4024              	.L306:
3197:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4025              		.loc 1 3197 0
 4026 2414 30309DE5 		ldr	r3, [sp, #48]
 4027 2418 0C0013E3 		tst	r3, #12
 4028 241c 7200001A 		bne	.L443
 4029              	.L307:
3204:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4030              		.loc 1 3204 0
 4031 2420 040013E3 		tst	r3, #4
 4032 2424 1C00000A 		beq	.L308
3206:../uvc.c      ****             	switch ((wIndex >> 8))
 4033              		.loc 1 3206 0
 4034 2428 B0E0D8E1 		ldrh	lr, [r8, #0]
 4035 242c 2E24A0E1 		mov	r2, lr, lsr #8
 4036 2430 030052E3 		cmp	r2, #3
 4037 2434 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4038 2438 120000EA 		b	.L309
 4039              	.L314:
 4040 243c 88240000 		.word	.L309
 4041 2440 6C250000 		.word	.L311
 4042 2444 4C240000 		.word	.L312
 4043 2448 A8250000 		.word	.L313
 4044              	.L312:
 4045              	.LBB87:
 4046              	.LBB89:
2485:../uvc.c      ****     switch (wValue)
 4047              		.loc 1 2485 0
 4048 244c B020D9E1 		ldrh	r2, [r9, #0]
 4049 2450 060C52E3 		cmp	r2, #1536
 4050 2454 E001000A 		beq	.L320
 4051 2458 D700008A 		bhi	.L326
 4052 245c 030C52E3 		cmp	r2, #768
 4053 2460 D901000A 		beq	.L318
 4054 2464 D001008A 		bhi	.L327
 4055 2468 010C52E3 		cmp	r2, #256
 4056 246c 6F01000A 		beq	.L316
 4057 2470 020C52E3 		cmp	r2, #512
 4058 2474 6901000A 		beq	.L444
 4059              	.L329:
 4060              	.LBE89:
 4061              	.LBE87:
 4062              	.LBB92:
 4063              	.LBB96:
2617:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4064              		.loc 1 2617 0
 4065 2478 90199FE5 		ldr	r1, .L452+24
 4066 247c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4067 2480 0400A0E3 		mov	r0, #4
 4068 2484 FEFFFFEB 		bl	CyU3PDebugPrint
 4069              	.L309:
 4070              	.LBE96:
 4071              	.LBE92:
3227:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4072              		.loc 1 3227 0
 4073 2488 0000A0E3 		mov	r0, #0
 4074 248c 0110A0E3 		mov	r1, #1
 4075 2490 0020A0E1 		mov	r2, r0
 4076 2494 FEFFFFEB 		bl	CyU3PUsbStall
 4077 2498 30309DE5 		ldr	r3, [sp, #48]
 4078              	.L308:
3232:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4079              		.loc 1 3232 0
 4080 249c 080013E3 		tst	r3, #8
 4081 24a0 0700000A 		beq	.L370
3236:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4082              		.loc 1 3236 0
 4083 24a4 B030D8E1 		ldrh	r3, [r8, #0]
 4084 24a8 010053E3 		cmp	r3, #1
 4085 24ac 6800000A 		beq	.L371
 4086              	.L372:
 4087              	.LBB101:
 4088              	.LBB107:
3151:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4089              		.loc 1 3151 0
 4090 24b0 0000A0E3 		mov	r0, #0
 4091 24b4 0110A0E3 		mov	r1, #1
 4092 24b8 0020A0E1 		mov	r2, r0
 4093 24bc FEFFFFEB 		bl	CyU3PUsbStall
 4094              	.L432:
 4095 24c0 30309DE5 		ldr	r3, [sp, #48]
 4096              	.L370:
 4097              	.LBE107:
 4098              	.LBE101:
3247:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4099              		.loc 1 3247 0
 4100 24c4 400013E3 		tst	r3, #64
 4101 24c8 0100001A 		bne	.L445
 4102              	.L305:
3460:../uvc.c      ****         CyU3PThreadRelinquish ();
 4103              		.loc 1 3460 0
 4104 24cc FEFFFFEB 		bl	_txe_thread_relinquish
3461:../uvc.c      ****     }
 4105              		.loc 1 3461 0
 4106 24d0 C3FFFFEA 		b	.L429
 4107              	.L445:
3252:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4108              		.loc 1 3252 0
 4109 24d4 1800A0E3 		mov	r0, #24
 4110 24d8 2C108DE2 		add	r1, sp, #44
 4111 24dc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3257:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4112              		.loc 1 3257 0
 4113 24e0 2C209DE5 		ldr	r2, [sp, #44]
 4114 24e4 000052E3 		cmp	r2, #0
 4115 24e8 6D00000A 		beq	.L424
3257:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4116              		.loc 1 3257 0 is_stmt 0 discriminator 1
 4117 24ec 7B36D6E5 		ldrb	r3, [r6, #1659]	@ zero_extendqisi2
 4118 24f0 000053E3 		cmp	r3, #0
 4119 24f4 F4FFFF1A 		bne	.L305
3259:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4120              		.loc 1 3259 0 is_stmt 1
 4121 24f8 002097E5 		ldr	r2, [r7, #0]
 4122 24fc 02B0A0E3 		mov	fp, #2
 4123 2500 00B0C2E5 		strb	fp, [r2, #0]
3260:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4124              		.loc 1 3260 0
 4125 2504 001097E5 		ldr	r1, [r7, #0]
 4126 2508 01B0A0E3 		mov	fp, #1
 4127 250c 01B0C1E5 		strb	fp, [r1, #1]
3261:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4128              		.loc 1 3261 0
 4129 2510 000097E5 		ldr	r0, [r7, #0]
3265:../uvc.c      **** 					interStabuf.size   = 1024;
 4130              		.loc 1 3265 0
 4131 2514 01EBA0E3 		mov	lr, #1024	@ movhi
3261:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4132              		.loc 1 3261 0
 4133 2518 0230C0E5 		strb	r3, [r0, #2]
3262:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4134              		.loc 1 3262 0
 4135 251c 00C097E5 		ldr	ip, [r7, #0]
3271:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4136              		.loc 1 3271 0
 4137 2520 0010E0E3 		mvn	r1, #0
3262:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4138              		.loc 1 3262 0
 4139 2524 0330CCE5 		strb	r3, [ip, #3]
3264:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4140              		.loc 1 3264 0
 4141 2528 002097E5 		ldr	r2, [r7, #0]
3268:../uvc.c      **** 					interStabuf.count = 4;
 4142              		.loc 1 3268 0
 4143 252c 04C0A0E3 		mov	ip, #4	@ movhi
3271:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4144              		.loc 1 3271 0
 4145 2530 DC089FE5 		ldr	r0, .L452+28
3264:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4146              		.loc 1 3264 0
 4147 2534 20208DE5 		str	r2, [sp, #32]
3265:../uvc.c      **** 					interStabuf.size   = 1024;
 4148              		.loc 1 3265 0
 4149 2538 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3266:../uvc.c      **** 					interStabuf.status = 0;
 4150              		.loc 1 3266 0
 4151 253c B832CDE1 		strh	r3, [sp, #40]	@ movhi
3268:../uvc.c      **** 					interStabuf.count = 4;
 4152              		.loc 1 3268 0
 4153 2540 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3271:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4154              		.loc 1 3271 0
 4155 2544 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3274:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4156              		.loc 1 3274 0
 4157 2548 C4089FE5 		ldr	r0, .L452+28
 4158 254c 20108DE2 		add	r1, sp, #32
 4159 2550 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4160              	.LVL307:
3275:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4161              		.loc 1 3275 0
 4162 2554 002050E2 		subs	r2, r0, #0
 4163 2558 6E01001A 		bne	.L446
3280:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4164              		.loc 1 3280 0
 4165 255c 98389FE5 		ldr	r3, .L452+4
 4166 2560 7BB6C3E5 		strb	fp, [r3, #1659]
3460:../uvc.c      ****         CyU3PThreadRelinquish ();
 4167              		.loc 1 3460 0
 4168 2564 FEFFFFEB 		bl	_txe_thread_relinquish
 4169              	.LVL308:
 4170 2568 9DFFFFEA 		b	.L429
 4171              	.L311:
 4172              	.LBB113:
 4173              	.LBB97:
2560:../uvc.c      ****     switch (wValue)
 4174              		.loc 1 2560 0
 4175 256c B020D9E1 		ldrh	r2, [r9, #0]
 4176 2570 060C52E3 		cmp	r2, #1536
 4177 2574 DC00000A 		beq	.L335
 4178 2578 9A00008A 		bhi	.L341
 4179 257c 030C52E3 		cmp	r2, #768
 4180 2580 1E01000A 		beq	.L332
 4181 2584 1501008A 		bhi	.L342
 4182 2588 010C52E3 		cmp	r2, #256
 4183 258c 5D01000A 		beq	.L330
 4184 2590 020C52E3 		cmp	r2, #512
 4185 2594 B7FFFF1A 		bne	.L329
 4186              	.LVL309:
2568:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4187              		.loc 1 2568 0
 4188 2598 0100A0E3 		mov	r0, #1
 4189 259c FEFFFFEB 		bl	CTControlHandle
 4190              	.LVL310:
 4191 25a0 30309DE5 		ldr	r3, [sp, #48]
 4192 25a4 BCFFFFEA 		b	.L308
 4193              	.L313:
 4194              	.LBE97:
 4195              	.LBE113:
 4196              	.LBB114:
 4197              	.LBB119:
2785:../uvc.c      ****     switch (wValue)
 4198              		.loc 1 2785 0
 4199 25a8 B030D9E1 		ldrh	r3, [r9, #0]
 4200 25ac 090C53E3 		cmp	r3, #2304
 4201 25b0 FD01000A 		beq	.L356
 4202 25b4 9300008A 		bhi	.L365
 4203 25b8 010B53E3 		cmp	r3, #1024
 4204 25bc F601000A 		beq	.L351
 4205 25c0 8E01008A 		bhi	.L366
 4206 25c4 020C53E3 		cmp	r3, #512
 4207 25c8 EF01000A 		beq	.L349
 4208 25cc 030C53E3 		cmp	r3, #768
 4209 25d0 E901000A 		beq	.L350
 4210 25d4 010C53E3 		cmp	r3, #256
 4211 25d8 AAFFFF1A 		bne	.L309
 4212              	.LVL311:
2789:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4213              		.loc 1 2789 0
 4214 25dc 1000A0E3 		mov	r0, #16
 4215 25e0 FEFFFFEB 		bl	ControlHandle
 4216              	.LVL312:
 4217 25e4 30309DE5 		ldr	r3, [sp, #48]
 4218 25e8 ABFFFFEA 		b	.L308
 4219              	.L443:
 4220              	.LBE119:
 4221              	.LBE114:
3198:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4222              		.loc 1 3198 0
 4223 25ec 24B89FE5 		ldr	fp, .L452+32
 4224 25f0 B0C0D9E1 		ldrh	ip, [r9, #0]
 4225 25f4 B000D8E1 		ldrh	r0, [r8, #0]
 4226 25f8 1C189FE5 		ldr	r1, .L452+36
 4227 25fc 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4228 2600 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4229 2604 0C008DE5 		str	r0, [sp, #12]
 4230 2608 08C08DE5 		str	ip, [sp, #8]
 4231 260c B0C0D1E1 		ldrh	ip, [r1, #0]
 4232 2610 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4233 2614 04B08DE5 		str	fp, [sp, #4]
 4234 2618 0400A0E3 		mov	r0, #4
 4235 261c FC179FE5 		ldr	r1, .L452+40
 4236 2620 00B0A0E3 		mov	fp, #0
 4237 2624 00E08DE5 		str	lr, [sp, #0]
 4238 2628 10C08DE5 		str	ip, [sp, #16]
 4239 262c 14B08DE5 		str	fp, [sp, #20]
 4240 2630 FEFFFFEB 		bl	CyU3PDebugPrint
 4241 2634 30309DE5 		ldr	r3, [sp, #48]
 4242 2638 78FFFFEA 		b	.L307
 4243              	.L442:
3190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4244              		.loc 1 3190 0
 4245 263c FEFFFFEB 		bl	CyU3PUsbGetSpeed
3191:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4246              		.loc 1 3191 0
 4247 2640 000050E3 		cmp	r0, #0
3190:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4248              		.loc 1 3190 0
 4249 2644 4800C5E5 		strb	r0, [r5, #72]
3193:../uvc.c      ****                     isUsbConnected = CyTrue;
 4250              		.loc 1 3193 0
 4251 2648 0100A013 		movne	r0, #1
 4252 264c 40008515 		strne	r0, [r5, #64]
 4253 2650 6FFFFFEA 		b	.L306
 4254              	.L371:
 4255              	.LVL313:
 4256              	.LBB125:
 4257              	.LBB106:
2880:../uvc.c      ****     switch (wValue)
 4258              		.loc 1 2880 0
 4259 2654 B020D9E1 		ldrh	r2, [r9, #0]
 4260 2658 030C52E3 		cmp	r2, #768
 4261 265c 8800000A 		beq	.L375
 4262 2660 3300008A 		bhi	.L378
 4263 2664 010C52E3 		cmp	r2, #256
 4264 2668 9200000A 		beq	.L373
 4265 266c 020C52E3 		cmp	r2, #512
 4266 2670 8EFFFF1A 		bne	.L372
2938:../uvc.c      ****             switch (bRequest)
 4267              		.loc 1 2938 0
 4268 2674 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4269 2678 810053E3 		cmp	r3, #129
 4270 267c B601000A 		beq	.L417
 4271 2680 2D01008A 		bhi	.L393
 4272 2684 010053E3 		cmp	r3, #1
 4273 2688 A201000A 		beq	.L447
 4274              	.L406:
3092:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4275              		.loc 1 3092 0
 4276 268c 0000A0E3 		mov	r0, #0
 4277 2690 0110A0E3 		mov	r1, #1
 4278 2694 0020A0E1 		mov	r2, r0
 4279 2698 FEFFFFEB 		bl	CyU3PUsbStall
 4280 269c 30309DE5 		ldr	r3, [sp, #48]
 4281 26a0 87FFFFEA 		b	.L370
 4282              	.LVL314:
 4283              	.L424:
 4284              	.LBE106:
 4285              	.LBE125:
3281:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4286              		.loc 1 3281 0
 4287 26a4 7BE6D6E5 		ldrb	lr, [r6, #1659]	@ zero_extendqisi2
 4288 26a8 00005EE3 		cmp	lr, #0
 4289 26ac 86FFFF0A 		beq	.L305
3283:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4290              		.loc 1 3283 0
 4291 26b0 003097E5 		ldr	r3, [r7, #0]
 4292 26b4 02B0A0E3 		mov	fp, #2
 4293 26b8 00B0C3E5 		strb	fp, [r3, #0]
3284:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4294              		.loc 1 3284 0
 4295 26bc 001097E5 		ldr	r1, [r7, #0]
 4296 26c0 01B0A0E3 		mov	fp, #1
 4297 26c4 01B0C1E5 		strb	fp, [r1, #1]
3285:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4298              		.loc 1 3285 0
 4299 26c8 000097E5 		ldr	r0, [r7, #0]
3289:../uvc.c      **** 					interStabuf.size   = 1024;
 4300              		.loc 1 3289 0
 4301 26cc 01EBA0E3 		mov	lr, #1024	@ movhi
3285:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4302              		.loc 1 3285 0
 4303 26d0 0220C0E5 		strb	r2, [r0, #2]
3286:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4304              		.loc 1 3286 0
 4305 26d4 00C097E5 		ldr	ip, [r7, #0]
3295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4306              		.loc 1 3295 0
 4307 26d8 0010E0E3 		mvn	r1, #0
3286:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4308              		.loc 1 3286 0
 4309 26dc 03B0CCE5 		strb	fp, [ip, #3]
3288:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4310              		.loc 1 3288 0
 4311 26e0 003097E5 		ldr	r3, [r7, #0]
3290:../uvc.c      **** 					interStabuf.status = 0;
 4312              		.loc 1 3290 0
 4313 26e4 02C0A0E1 		mov	ip, r2	@ movhi
 4314 26e8 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4315              		.loc 1 3295 0
 4316 26ec 20079FE5 		ldr	r0, .L452+28
3292:../uvc.c      **** 					interStabuf.count = 4;
 4317              		.loc 1 3292 0
 4318 26f0 0420A0E3 		mov	r2, #4	@ movhi
3288:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4319              		.loc 1 3288 0
 4320 26f4 20308DE5 		str	r3, [sp, #32]
3292:../uvc.c      **** 					interStabuf.count = 4;
 4321              		.loc 1 3292 0
 4322 26f8 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3289:../uvc.c      **** 					interStabuf.size   = 1024;
 4323              		.loc 1 3289 0
 4324 26fc B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3295:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4325              		.loc 1 3295 0
 4326 2700 1CC08DE5 		str	ip, [sp, #28]
 4327 2704 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3298:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4328              		.loc 1 3298 0
 4329 2708 04079FE5 		ldr	r0, .L452+28
 4330 270c 20108DE2 		add	r1, sp, #32
 4331 2710 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4332              	.LVL315:
3299:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4333              		.loc 1 3299 0
 4334 2714 1C309DE5 		ldr	r3, [sp, #28]
 4335 2718 002050E2 		subs	r2, r0, #0
 4336 271c C700001A 		bne	.L448
3305:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4337              		.loc 1 3305 0
 4338 2720 D4269FE5 		ldr	r2, .L452+4
3306:../uvc.c      **** 					stiflag = CyTrue;
 4339              		.loc 1 3306 0
 4340 2724 9CB084E5 		str	fp, [r4, #156]
3305:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4341              		.loc 1 3305 0
 4342 2728 7B36C2E5 		strb	r3, [r2, #1659]
3460:../uvc.c      ****         CyU3PThreadRelinquish ();
 4343              		.loc 1 3460 0
 4344 272c FEFFFFEB 		bl	_txe_thread_relinquish
 4345              	.LVL316:
 4346 2730 2BFFFFEA 		b	.L429
 4347              	.LVL317:
 4348              	.L378:
 4349              	.LBB126:
 4350              	.LBB108:
2880:../uvc.c      ****     switch (wValue)
 4351              		.loc 1 2880 0
 4352 2734 010B52E3 		cmp	r2, #1024
 4353 2738 3F00000A 		beq	.L376
 4354 273c 050C52E3 		cmp	r2, #1280
 4355 2740 5AFFFF1A 		bne	.L372
3098:../uvc.c      ****                 switch (bRequest)
 4356              		.loc 1 3098 0
 4357 2744 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4358 2748 810052E3 		cmp	r2, #129
 4359 274c 8201000A 		beq	.L417
 4360 2750 2501008A 		bhi	.L420
 4361 2754 010052E3 		cmp	r2, #1
 4362 2758 54FFFF1A 		bne	.L372
3123:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4363              		.loc 1 3123 0
 4364 275c 2000A0E3 		mov	r0, #32
 4365 2760 BC169FE5 		ldr	r1, .L452+44
 4366 2764 36208DE2 		add	r2, sp, #54
 4367 2768 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4368              	.LVL318:
3125:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4369              		.loc 1 3125 0
 4370 276c 000050E3 		cmp	r0, #0
 4371 2770 6201001A 		bne	.L422
3129:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4372              		.loc 1 3129 0
 4373 2774 0020A0E3 		mov	r2, #0
 4374 2778 78069FE5 		ldr	r0, .L452
 4375              	.LVL319:
 4376 277c 8010A0E3 		mov	r1, #128
 4377 2780 FEFFFFEB 		bl	_txe_event_flags_set
 4378              	.LVL320:
3130:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4379              		.loc 1 3130 0
 4380 2784 002050E2 		subs	r2, r0, #0
 4381 2788 0200000A 		beq	.L423
3132:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4382              		.loc 1 3132 0
 4383 278c 0400A0E3 		mov	r0, #4
 4384              	.LVL321:
 4385 2790 90169FE5 		ldr	r1, .L452+48
 4386 2794 FEFFFFEB 		bl	CyU3PDebugPrint
 4387              	.LVL322:
 4388              	.L423:
3137:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4389              		.loc 1 3137 0
 4390 2798 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4391 279c 0400A0E3 		mov	r0, #4
 4392 27a0 84169FE5 		ldr	r1, .L452+52
 4393 27a4 B623DDE1 		ldrh	r2, [sp, #54]
3135:../uvc.c      ****                             stiflag = CyTrue;//set still flag
 4394              		.loc 1 3135 0
 4395 27a8 01B0A0E3 		mov	fp, #1
 4396 27ac 9CB084E5 		str	fp, [r4, #156]
3137:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4397              		.loc 1 3137 0
 4398 27b0 FEFFFFEB 		bl	CyU3PDebugPrint
 4399 27b4 30309DE5 		ldr	r3, [sp, #48]
 4400 27b8 41FFFFEA 		b	.L370
 4401              	.L326:
 4402              	.LBE108:
 4403              	.LBE126:
 4404              	.LBB127:
 4405              	.LBB90:
2485:../uvc.c      ****     switch (wValue)
 4406              		.loc 1 2485 0
 4407 27bc 0A0C52E3 		cmp	r2, #2560
 4408 27c0 F100000A 		beq	.L323
 4409 27c4 E600008A 		bhi	.L328
 4410 27c8 070C52E3 		cmp	r2, #1792
 4411 27cc E000000A 		beq	.L321
 4412 27d0 020B52E3 		cmp	r2, #2048
 4413 27d4 27FFFF1A 		bne	.L329
 4414              	.LVL323:
2516:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4415              		.loc 1 2516 0
 4416 27d8 0700A0E3 		mov	r0, #7
 4417 27dc FEFFFFEB 		bl	ControlHandle
 4418              	.LVL324:
 4419 27e0 30309DE5 		ldr	r3, [sp, #48]
 4420 27e4 2CFFFFEA 		b	.L308
 4421              	.L341:
 4422              	.LBE90:
 4423              	.LBE127:
 4424              	.LBB128:
 4425              	.LBB95:
2560:../uvc.c      ****     switch (wValue)
 4426              		.loc 1 2560 0
 4427 27e8 090C52E3 		cmp	r2, #2304
 4428 27ec 2201000A 		beq	.L337
 4429 27f0 1701008A 		bhi	.L343
 4430 27f4 070C52E3 		cmp	r2, #1792
 4431 27f8 0901000A 		beq	.L336
 4432 27fc 020B52E3 		cmp	r2, #2048
 4433 2800 1CFFFF1A 		bne	.L329
 4434 2804 24FFFFEA 		b	.L308
 4435              	.L365:
 4436              	.LBE95:
 4437              	.LBE128:
 4438              	.LBB129:
 4439              	.LBB120:
2785:../uvc.c      ****     switch (wValue)
 4440              		.loc 1 2785 0
 4441 2808 0F0C53E3 		cmp	r3, #3840
 4442 280c 3701000A 		beq	.L360
 4443 2810 3900008A 		bhi	.L368
 4444 2814 0B0C53E3 		cmp	r3, #2816
 4445 2818 3001000A 		beq	.L358
 4446 281c 0D0C53E3 		cmp	r3, #3328
 4447 2820 2A01000A 		beq	.L359
 4448 2824 0A0C53E3 		cmp	r3, #2560
 4449 2828 16FFFF1A 		bne	.L309
 4450              	.LVL325:
2826:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4451              		.loc 1 2826 0
 4452 282c 1900A0E3 		mov	r0, #25
 4453 2830 FEFFFFEB 		bl	ControlHandle
 4454              	.LVL326:
 4455 2834 30309DE5 		ldr	r3, [sp, #48]
 4456 2838 17FFFFEA 		b	.L308
 4457              	.LVL327:
 4458              	.L376:
 4459              	.LBE120:
 4460              	.LBE129:
 4461              	.LBB130:
 4462              	.LBB105:
3043:../uvc.c      ****                 switch (bRequest)
 4463              		.loc 1 3043 0
 4464 283c 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4465 2840 81005BE3 		cmp	fp, #129
 4466 2844 1300000A 		beq	.L408
 4467 2848 8500008A 		bhi	.L411
 4468 284c 01005BE3 		cmp	fp, #1
 4469 2850 8DFFFF1A 		bne	.L406
3068:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4470              		.loc 1 3068 0
 4471 2854 36208DE2 		add	r2, sp, #54
 4472 2858 2000A0E3 		mov	r0, #32
 4473 285c C0159FE5 		ldr	r1, .L452+44
 4474 2860 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4475              	.LVL328:
3070:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4476              		.loc 1 3070 0
 4477 2864 002050E2 		subs	r2, r0, #0
 4478 2868 14FFFF1A 		bne	.L432
3083:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4479              		.loc 1 3083 0
 4480 286c 84059FE5 		ldr	r0, .L452
 4481              	.LVL329:
 4482 2870 0B10A0E1 		mov	r1, fp
 4483 2874 FEFFFFEB 		bl	_txe_event_flags_set
 4484              	.LVL330:
3084:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4485              		.loc 1 3084 0
 4486 2878 002050E2 		subs	r2, r0, #0
 4487 287c 0FFFFF0A 		beq	.L432
 4488 2880 300100EA 		b	.L414
 4489              	.LVL331:
 4490              	.L375:
2994:../uvc.c      ****                 switch (bRequest)
 4491              		.loc 1 2994 0
 4492 2884 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4493 2888 830052E3 		cmp	r2, #131
 4494 288c 9800008A 		bhi	.L402
 4495 2890 810052E3 		cmp	r2, #129
 4496 2894 7D00003A 		bcc	.L449
 4497              	.L408:
3055:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4498              		.loc 1 3055 0
 4499 2898 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3057:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4500              		.loc 1 3057 0
 4501 289c 0B00A0E3 		mov	r0, #11
3055:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4502              		.loc 1 3055 0
 4503 28a0 030053E3 		cmp	r3, #3
3057:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4504              		.loc 1 3057 0
 4505 28a4 84159F05 		ldreq	r1, .L452+56
3061:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4506              		.loc 1 3061 0
 4507 28a8 84159F15 		ldrne	r1, .L452+60
 4508 28ac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4509 28b0 30309DE5 		ldr	r3, [sp, #48]
 4510 28b4 02FFFFEA 		b	.L370
 4511              	.L373:
2883:../uvc.c      ****             switch (bRequest)
 4512              		.loc 1 2883 0
 4513 28b8 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4514 28bc 830052E3 		cmp	r2, #131
 4515 28c0 2F00008A 		bhi	.L384
 4516 28c4 810052E3 		cmp	r2, #129
 4517 28c8 1400003A 		bcc	.L450
 4518              	.L381:
2898:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4519              		.loc 1 2898 0
 4520 28cc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4521 28d0 030053E3 		cmp	r3, #3
 4522 28d4 F800000A 		beq	.L451
 4523              	.L421:
3116:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4524              		.loc 1 3116 0
 4525 28d8 1A00A0E3 		mov	r0, #26
 4526 28dc 54159FE5 		ldr	r1, .L452+64
 4527 28e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4528 28e4 30309DE5 		ldr	r3, [sp, #48]
 4529 28e8 F5FEFFEA 		b	.L370
 4530              	.LVL332:
 4531              	.L335:
 4532              	.LBE105:
 4533              	.LBE130:
 4534              	.LBB131:
 4535              	.LBB98:
2586:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4536              		.loc 1 2586 0
 4537 28ec 0500A0E3 		mov	r0, #5
 4538 28f0 FEFFFFEB 		bl	CTControlHandle
 4539              	.LVL333:
 4540 28f4 30309DE5 		ldr	r3, [sp, #48]
 4541 28f8 E7FEFFEA 		b	.L308
 4542              	.L368:
 4543              	.LBE98:
 4544              	.LBE131:
 4545              	.LBB132:
 4546              	.LBB118:
2785:../uvc.c      ****     switch (wValue)
 4547              		.loc 1 2785 0
 4548 28fc 110C53E3 		cmp	r3, #4352
 4549 2900 E900000A 		beq	.L362
 4550 2904 2D00008A 		bhi	.L369
 4551 2908 010A53E3 		cmp	r3, #4096
 4552 290c DDFEFF1A 		bne	.L309
 4553              	.LVL334:
2848:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4554              		.loc 1 2848 0
 4555 2910 1F00A0E3 		mov	r0, #31
 4556 2914 FEFFFFEB 		bl	ControlHandle
 4557              	.LVL335:
 4558 2918 30309DE5 		ldr	r3, [sp, #48]
 4559 291c DEFEFFEA 		b	.L308
 4560              	.LVL336:
 4561              	.L450:
 4562              	.LBE118:
 4563              	.LBE132:
 4564              	.LBB133:
 4565              	.LBB109:
2883:../uvc.c      ****             switch (bRequest)
 4566              		.loc 1 2883 0
 4567 2920 010052E3 		cmp	r2, #1
 4568 2924 58FFFF1A 		bne	.L406
2908:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4569              		.loc 1 2908 0
 4570 2928 2000A0E3 		mov	r0, #32
 4571 292c F0149FE5 		ldr	r1, .L452+44
 4572 2930 36208DE2 		add	r2, sp, #54
 4573 2934 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4574              	.LVL337:
2910:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4575              		.loc 1 2910 0
 4576 2938 000050E3 		cmp	r0, #0
 4577 293c DFFEFF1A 		bne	.L432
2912:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4578              		.loc 1 2912 0
 4579 2940 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4580 2944 030051E3 		cmp	r1, #3
 4581 2948 DCFEFF1A 		bne	.L432
2919:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4582              		.loc 1 2919 0
 4583 294c 8130D4E5 		ldrb	r3, [r4, #129]	@ zero_extendqisi2
2916:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4584              		.loc 1 2916 0
 4585 2950 7EE0D4E5 		ldrb	lr, [r4, #126]	@ zero_extendqisi2
2917:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4586              		.loc 1 2917 0
 4587 2954 7FC0D4E5 		ldrb	ip, [r4, #127]	@ zero_extendqisi2
2918:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4588              		.loc 1 2918 0
 4589 2958 8000D4E5 		ldrb	r0, [r4, #128]	@ zero_extendqisi2
 4590              	.LVL338:
2920:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4591              		.loc 1 2920 0
 4592 295c 8220D4E5 		ldrb	r2, [r4, #130]	@ zero_extendqisi2
2921:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4593              		.loc 1 2921 0
 4594 2960 83B0D4E5 		ldrb	fp, [r4, #131]	@ zero_extendqisi2
2919:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4595              		.loc 1 2919 0
 4596 2964 1536C6E5 		strb	r3, [r6, #1557]
2916:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4597              		.loc 1 2916 0
 4598 2968 12E6C6E5 		strb	lr, [r6, #1554]
2917:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4599              		.loc 1 2917 0
 4600 296c 13C6C6E5 		strb	ip, [r6, #1555]
2918:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4601              		.loc 1 2918 0
 4602 2970 1406C6E5 		strb	r0, [r6, #1556]
2920:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4603              		.loc 1 2920 0
 4604 2974 1626C6E5 		strb	r2, [r6, #1558]
2921:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4605              		.loc 1 2921 0
 4606 2978 17B6C6E5 		strb	fp, [r6, #1559]
 4607 297c 30309DE5 		ldr	r3, [sp, #48]
 4608 2980 CFFEFFEA 		b	.L370
 4609              	.LVL339:
 4610              	.L384:
2883:../uvc.c      ****             switch (bRequest)
 4611              		.loc 1 2883 0
 4612 2984 860052E3 		cmp	r2, #134
 4613 2988 3900000A 		beq	.L436
 4614 298c 870052E3 		cmp	r2, #135
 4615 2990 CDFFFF0A 		beq	.L381
 4616              	.L441:
2994:../uvc.c      ****                 switch (bRequest)
 4617              		.loc 1 2994 0
 4618 2994 850052E3 		cmp	r2, #133
 4619 2998 3BFFFF1A 		bne	.L406
 4620              	.L409:
3052:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4621              		.loc 1 3052 0
 4622 299c 98149FE5 		ldr	r1, .L452+68
 4623 29a0 0200A0E3 		mov	r0, #2
3050:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4624              		.loc 1 3050 0
 4625 29a4 1A30A0E3 		mov	r3, #26
 4626              	.L433:
3106:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4627              		.loc 1 3106 0
 4628 29a8 0020A0E3 		mov	r2, #0
3105:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4629              		.loc 1 3105 0
 4630 29ac 5830C4E5 		strb	r3, [r4, #88]
3106:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4631              		.loc 1 3106 0
 4632 29b0 5920C4E5 		strb	r2, [r4, #89]
3107:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4633              		.loc 1 3107 0
 4634 29b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4635 29b8 30309DE5 		ldr	r3, [sp, #48]
 4636 29bc C0FEFFEA 		b	.L370
 4637              	.LVL340:
 4638              	.L369:
 4639              	.LBE109:
 4640              	.LBE133:
 4641              	.LBB134:
 4642              	.LBB121:
2785:../uvc.c      ****     switch (wValue)
 4643              		.loc 1 2785 0
 4644 29c0 120C53E3 		cmp	r3, #4608
 4645 29c4 0701000A 		beq	.L363
 4646 29c8 130C53E3 		cmp	r3, #4864
 4647 29cc ADFEFF1A 		bne	.L309
 4648              	.LVL341:
2860:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4649              		.loc 1 2860 0
 4650 29d0 2200A0E3 		mov	r0, #34
 4651 29d4 FEFFFFEB 		bl	ControlHandle
 4652              	.LVL342:
 4653 29d8 30309DE5 		ldr	r3, [sp, #48]
 4654 29dc AEFEFFEA 		b	.L308
 4655              	.L342:
 4656              	.LBE121:
 4657              	.LBE134:
 4658              	.LBB135:
 4659              	.LBB94:
2560:../uvc.c      ****     switch (wValue)
 4660              		.loc 1 2560 0
 4661 29e0 010B52E3 		cmp	r2, #1024
 4662 29e4 0900000A 		beq	.L333
 4663 29e8 050C52E3 		cmp	r2, #1280
 4664 29ec A1FEFF1A 		bne	.L329
 4665              	.LVL343:
2582:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4666              		.loc 1 2582 0
 4667 29f0 0400A0E3 		mov	r0, #4
 4668 29f4 FEFFFFEB 		bl	CTControlHandle
 4669              	.LVL344:
 4670 29f8 30309DE5 		ldr	r3, [sp, #48]
 4671 29fc A6FEFFEA 		b	.L308
 4672              	.L332:
 4673              	.LVL345:
2572:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4674              		.loc 1 2572 0
 4675 2a00 0200A0E3 		mov	r0, #2
 4676 2a04 FEFFFFEB 		bl	CTControlHandle
 4677              	.LVL346:
 4678 2a08 30309DE5 		ldr	r3, [sp, #48]
 4679 2a0c A2FEFFEA 		b	.L308
 4680              	.L333:
 4681              	.LVL347:
2577:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4682              		.loc 1 2577 0
 4683 2a10 0300A0E3 		mov	r0, #3
 4684 2a14 FEFFFFEB 		bl	CTControlHandle
 4685              	.LVL348:
 4686 2a18 30309DE5 		ldr	r3, [sp, #48]
 4687 2a1c 9EFEFFEA 		b	.L308
 4688              	.L444:
 4689              	.LVL349:
 4690              	.LBE94:
 4691              	.LBE135:
 4692              	.LBB136:
 4693              	.LBB88:
2493:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4694              		.loc 1 2493 0
 4695 2a20 0100A0E3 		mov	r0, #1
 4696 2a24 FEFFFFEB 		bl	ControlHandle
 4697              	.LVL350:
 4698 2a28 30309DE5 		ldr	r3, [sp, #48]
 4699 2a2c 9AFEFFEA 		b	.L308
 4700              	.L316:
 4701              	.LVL351:
2489:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4702              		.loc 1 2489 0
 4703 2a30 0000A0E3 		mov	r0, #0
 4704 2a34 FEFFFFEB 		bl	ControlHandle
 4705              	.LVL352:
 4706 2a38 30309DE5 		ldr	r3, [sp, #48]
 4707 2a3c 96FEFFEA 		b	.L308
 4708              	.LVL353:
 4709              	.L448:
 4710              	.LBE88:
 4711              	.LBE136:
3301:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4712              		.loc 1 3301 0
 4713 2a40 0400A0E3 		mov	r0, #4
 4714              	.LVL354:
 4715 2a44 F4139FE5 		ldr	r1, .L452+72
 4716 2a48 FEFFFFEB 		bl	CyU3PDebugPrint
 4717              	.LVL355:
 4718              	.L428:
 4719              	.LBB137:
 4720              	.LBB138:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4721              		.loc 1 1273 0
 4722 2a4c F0139FE5 		ldr	r1, .L452+76
 4723 2a50 0400A0E3 		mov	r0, #4
 4724 2a54 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 4725              		.loc 1 1274 0
 4726 2a58 FA0FA0E3 		mov	r0, #1000
 4727 2a5c FEFFFFEB 		bl	_tx_thread_sleep
 4728 2a60 F9FFFFEA 		b	.L428
 4729              	.LVL356:
 4730              	.L411:
 4731              	.LBE138:
 4732              	.LBE137:
 4733              	.LBB139:
 4734              	.LBB104:
3043:../uvc.c      ****                 switch (bRequest)
 4735              		.loc 1 3043 0
 4736 2a64 85005BE3 		cmp	fp, #133
 4737 2a68 CBFFFF0A 		beq	.L409
 4738 2a6c 86005BE3 		cmp	fp, #134
 4739 2a70 05FFFF1A 		bne	.L406
 4740              	.L436:
3047:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4741              		.loc 1 3047 0
 4742 2a74 0300A0E1 		mov	r0, r3
 4743              	.L431:
2942:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4744              		.loc 1 2942 0
 4745 2a78 BC139FE5 		ldr	r1, .L452+68
2941:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4746              		.loc 1 2941 0
 4747 2a7c 03B0A0E3 		mov	fp, #3
 4748 2a80 58B0C4E5 		strb	fp, [r4, #88]
2942:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4749              		.loc 1 2942 0
 4750 2a84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4751 2a88 30309DE5 		ldr	r3, [sp, #48]
 4752 2a8c 8CFEFFEA 		b	.L370
 4753              	.L449:
2994:../uvc.c      ****                 switch (bRequest)
 4754              		.loc 1 2994 0
 4755 2a90 010052E3 		cmp	r2, #1
 4756 2a94 FCFEFF1A 		bne	.L406
3019:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4757              		.loc 1 3019 0
 4758 2a98 2000A0E3 		mov	r0, #32
 4759 2a9c 80139FE5 		ldr	r1, .L452+44
 4760 2aa0 36208DE2 		add	r2, sp, #54
 4761 2aa4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4762              	.LVL357:
3021:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4763              		.loc 1 3021 0
 4764 2aa8 000050E3 		cmp	r0, #0
 4765 2aac 83FEFF1A 		bne	.L432
3023:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4766              		.loc 1 3023 0
 4767 2ab0 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4768 2ab4 030051E3 		cmp	r1, #3
 4769 2ab8 80FEFF1A 		bne	.L432
3032:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4770              		.loc 1 3032 0
 4771 2abc 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
3027:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4772              		.loc 1 3027 0
 4773 2ac0 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
3028:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4774              		.loc 1 3028 0
 4775 2ac4 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
3029:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4776              		.loc 1 3029 0
 4777 2ac8 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4778              	.LVL358:
3030:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4779              		.loc 1 3030 0
 4780 2acc 80B0D5E5 		ldrb	fp, [r5, #128]	@ zero_extendqisi2
3031:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4781              		.loc 1 3031 0
 4782 2ad0 8120D5E5 		ldrb	r2, [r5, #129]	@ zero_extendqisi2
3032:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4783              		.loc 1 3032 0
 4784 2ad4 6A36C6E5 		strb	r3, [r6, #1642]
3027:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4785              		.loc 1 3027 0
 4786 2ad8 65E6C6E5 		strb	lr, [r6, #1637]
3028:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4787              		.loc 1 3028 0
 4788 2adc 66C6C6E5 		strb	ip, [r6, #1638]
3029:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4789              		.loc 1 3029 0
 4790 2ae0 6706C6E5 		strb	r0, [r6, #1639]
3030:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4791              		.loc 1 3030 0
 4792 2ae4 68B6C6E5 		strb	fp, [r6, #1640]
3031:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4793              		.loc 1 3031 0
 4794 2ae8 6926C6E5 		strb	r2, [r6, #1641]
3032:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4795              		.loc 1 3032 0
 4796 2aec 30309DE5 		ldr	r3, [sp, #48]
 4797 2af0 73FEFFEA 		b	.L370
 4798              	.LVL359:
 4799              	.L402:
2994:../uvc.c      ****                 switch (bRequest)
 4800              		.loc 1 2994 0
 4801 2af4 860052E3 		cmp	r2, #134
 4802 2af8 DDFFFF0A 		beq	.L436
 4803 2afc 870052E3 		cmp	r2, #135
 4804 2b00 A3FFFF1A 		bne	.L441
 4805 2b04 63FFFFEA 		b	.L408
 4806              	.LVL360:
 4807              	.L330:
 4808              	.LBE104:
 4809              	.LBE139:
 4810              	.LBB140:
 4811              	.LBB99:
2564:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4812              		.loc 1 2564 0
 4813 2b08 0000A0E3 		mov	r0, #0
 4814 2b0c FEFFFFEB 		bl	CTControlHandle
 4815              	.LVL361:
 4816 2b10 30309DE5 		ldr	r3, [sp, #48]
 4817 2b14 60FEFFEA 		b	.L308
 4818              	.LVL362:
 4819              	.L446:
 4820              	.LBE99:
 4821              	.LBE140:
3277:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4822              		.loc 1 3277 0
 4823 2b18 0400A0E3 		mov	r0, #4
 4824              	.LVL363:
 4825 2b1c 1C139FE5 		ldr	r1, .L452+72
 4826 2b20 FEFFFFEB 		bl	CyU3PDebugPrint
 4827              	.LVL364:
 4828              	.L426:
 4829              	.LBB141:
 4830              	.LBB142:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4831              		.loc 1 1273 0
 4832 2b24 18139FE5 		ldr	r1, .L452+76
 4833 2b28 0400A0E3 		mov	r0, #4
 4834 2b2c FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 4835              		.loc 1 1274 0
 4836 2b30 FA0FA0E3 		mov	r0, #1000
 4837 2b34 FEFFFFEB 		bl	_tx_thread_sleep
 4838 2b38 F9FFFFEA 		b	.L426
 4839              	.LVL365:
 4840              	.L393:
 4841              	.LBE142:
 4842              	.LBE141:
 4843              	.LBB143:
 4844              	.LBB110:
2938:../uvc.c      ****             switch (bRequest)
 4845              		.loc 1 2938 0
 4846 2b3c 850053E3 		cmp	r3, #133
 4847 2b40 95FFFF0A 		beq	.L409
 4848 2b44 860053E3 		cmp	r3, #134
 4849 2b48 CFFEFF1A 		bne	.L406
 4850              	.L437:
2942:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4851              		.loc 1 2942 0
 4852 2b4c 0100A0E3 		mov	r0, #1
 4853 2b50 C8FFFFEA 		b	.L431
 4854              	.LVL366:
 4855              	.L321:
 4856              	.LBE110:
 4857              	.LBE143:
 4858              	.LBB144:
 4859              	.LBB91:
2512:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4860              		.loc 1 2512 0
 4861 2b54 0600A0E3 		mov	r0, #6
 4862 2b58 FEFFFFEB 		bl	ControlHandle
 4863              	.LVL367:
 4864 2b5c 30309DE5 		ldr	r3, [sp, #48]
 4865 2b60 4DFEFFEA 		b	.L308
 4866              	.L328:
2485:../uvc.c      ****     switch (wValue)
 4867              		.loc 1 2485 0
 4868 2b64 0D0C52E3 		cmp	r2, #3328
 4869 2b68 0700000A 		beq	.L323
 4870 2b6c 0E0C52E3 		cmp	r2, #3584
 4871 2b70 0900000A 		beq	.L325
 4872 2b74 030B52E3 		cmp	r2, #3072
 4873 2b78 3EFEFF1A 		bne	.L329
 4874              	.LVL368:
2526:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4875              		.loc 1 2526 0
 4876 2b7c 0B00A0E3 		mov	r0, #11
 4877 2b80 FEFFFFEB 		bl	ControlHandle
 4878              	.LVL369:
 4879 2b84 30309DE5 		ldr	r3, [sp, #48]
 4880 2b88 43FEFFEA 		b	.L308
 4881              	.L323:
 4882              	.LVL370:
2522:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4883              		.loc 1 2522 0
 4884 2b8c 0900A0E3 		mov	r0, #9
 4885 2b90 FEFFFFEB 		bl	ControlHandle
 4886              	.LVL371:
 4887 2b94 30309DE5 		ldr	r3, [sp, #48]
 4888 2b98 3FFEFFEA 		b	.L308
 4889              	.L325:
 4890              	.LVL372:
2530:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4891              		.loc 1 2530 0
 4892 2b9c 0E00A0E3 		mov	r0, #14
 4893 2ba0 FEFFFFEB 		bl	ControlHandle
 4894              	.LVL373:
 4895 2ba4 30309DE5 		ldr	r3, [sp, #48]
 4896 2ba8 3BFEFFEA 		b	.L308
 4897              	.L327:
2485:../uvc.c      ****     switch (wValue)
 4898              		.loc 1 2485 0
 4899 2bac 010B52E3 		cmp	r2, #1024
 4900 2bb0 39FEFF0A 		beq	.L308
 4901 2bb4 050C52E3 		cmp	r2, #1280
 4902 2bb8 2EFEFF1A 		bne	.L329
 4903              	.LVL374:
2504:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4904              		.loc 1 2504 0
 4905 2bbc 0400A0E3 		mov	r0, #4
 4906 2bc0 FEFFFFEB 		bl	ControlHandle
 4907              	.LVL375:
 4908 2bc4 30309DE5 		ldr	r3, [sp, #48]
 4909 2bc8 33FEFFEA 		b	.L308
 4910              	.L318:
 4911              	.LVL376:
2497:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4912              		.loc 1 2497 0
 4913 2bcc 0200A0E3 		mov	r0, #2
 4914 2bd0 FEFFFFEB 		bl	ControlHandle
 4915              	.LVL377:
 4916 2bd4 30309DE5 		ldr	r3, [sp, #48]
 4917 2bd8 2FFEFFEA 		b	.L308
 4918              	.L320:
 4919              	.LVL378:
2508:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4920              		.loc 1 2508 0
 4921 2bdc 0500A0E3 		mov	r0, #5
 4922 2be0 FEFFFFEB 		bl	ControlHandle
 4923              	.LVL379:
 4924 2be4 30309DE5 		ldr	r3, [sp, #48]
 4925 2be8 2BFEFFEA 		b	.L308
 4926              	.LVL380:
 4927              	.L420:
 4928              	.LBE91:
 4929              	.LBE144:
 4930              	.LBB145:
 4931              	.LBB103:
3098:../uvc.c      ****                 switch (bRequest)
 4932              		.loc 1 3098 0
 4933 2bec 850052E3 		cmp	r2, #133
 4934 2bf0 7900000A 		beq	.L418
 4935 2bf4 860052E3 		cmp	r2, #134
 4936 2bf8 2CFEFF1A 		bne	.L372
 4937 2bfc D2FFFFEA 		b	.L437
 4938              	.LVL381:
 4939              	.L366:
 4940              	.LBE103:
 4941              	.LBE145:
 4942              	.LBB146:
 4943              	.LBB117:
2785:../uvc.c      ****     switch (wValue)
 4944              		.loc 1 2785 0
 4945 2c00 060C53E3 		cmp	r3, #1536
 4946 2c04 7000000A 		beq	.L353
 4947 2c08 0900008A 		bhi	.L367
 4948 2c0c 050C53E3 		cmp	r3, #1280
 4949 2c10 1CFEFF1A 		bne	.L309
 4950              	.LVL382:
2805:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4951              		.loc 1 2805 0
 4952 2c14 1400A0E3 		mov	r0, #20
 4953 2c18 FEFFFFEB 		bl	ControlHandle
 4954              	.LVL383:
 4955 2c1c 30309DE5 		ldr	r3, [sp, #48]
 4956 2c20 1DFEFFEA 		b	.L308
 4957              	.L336:
 4958              	.LVL384:
 4959              	.LBE117:
 4960              	.LBE146:
 4961              	.LBB147:
 4962              	.LBB93:
2590:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4963              		.loc 1 2590 0
 4964 2c24 0600A0E3 		mov	r0, #6
 4965 2c28 FEFFFFEB 		bl	CTControlHandle
 4966              	.LVL385:
 4967 2c2c 30309DE5 		ldr	r3, [sp, #48]
 4968 2c30 19FEFFEA 		b	.L308
 4969              	.L367:
 4970              	.LBE93:
 4971              	.LBE147:
 4972              	.LBB148:
 4973              	.LBB122:
2785:../uvc.c      ****     switch (wValue)
 4974              		.loc 1 2785 0
 4975 2c34 070C53E3 		cmp	r3, #1792
 4976 2c38 5F00000A 		beq	.L354
 4977 2c3c 020B53E3 		cmp	r3, #2048
 4978 2c40 10FEFF1A 		bne	.L309
 4979              	.LVL386:
2817:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4980              		.loc 1 2817 0
 4981 2c44 1700A0E3 		mov	r0, #23
 4982 2c48 FEFFFFEB 		bl	ControlHandle
 4983              	.LVL387:
 4984 2c4c 30309DE5 		ldr	r3, [sp, #48]
 4985 2c50 11FEFFEA 		b	.L308
 4986              	.L343:
 4987              	.LBE122:
 4988              	.LBE148:
 4989              	.LBB149:
 4990              	.LBB100:
2560:../uvc.c      ****     switch (wValue)
 4991              		.loc 1 2560 0
 4992 2c54 0B0C52E3 		cmp	r2, #2816
 4993 2c58 0F00000A 		beq	.L339
 4994 2c5c 030B52E3 		cmp	r2, #3072
 4995 2c60 0900000A 		beq	.L340
 4996 2c64 0A0C52E3 		cmp	r2, #2560
 4997 2c68 02FEFF1A 		bne	.L329
 4998              	.LVL388:
2601:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4999              		.loc 1 2601 0
 5000 2c6c 0800A0E3 		mov	r0, #8
 5001 2c70 FEFFFFEB 		bl	CTControlHandle
 5002              	.LVL389:
 5003 2c74 30309DE5 		ldr	r3, [sp, #48]
 5004 2c78 07FEFFEA 		b	.L308
 5005              	.L337:
 5006              	.LVL390:
2596:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5007              		.loc 1 2596 0
 5008 2c7c 0700A0E3 		mov	r0, #7
 5009 2c80 FEFFFFEB 		bl	CTControlHandle
 5010              	.LVL391:
 5011 2c84 30309DE5 		ldr	r3, [sp, #48]
 5012 2c88 03FEFFEA 		b	.L308
 5013              	.L340:
 5014              	.LVL392:
2609:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5015              		.loc 1 2609 0
 5016 2c8c 0A00A0E3 		mov	r0, #10
 5017 2c90 FEFFFFEB 		bl	CTControlHandle
 5018              	.LVL393:
 5019 2c94 30309DE5 		ldr	r3, [sp, #48]
 5020 2c98 FFFDFFEA 		b	.L308
 5021              	.L339:
 5022              	.LVL394:
2605:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5023              		.loc 1 2605 0
 5024 2c9c 0900A0E3 		mov	r0, #9
 5025 2ca0 FEFFFFEB 		bl	CTControlHandle
 5026              	.LVL395:
 5027 2ca4 30309DE5 		ldr	r3, [sp, #48]
 5028 2ca8 FBFDFFEA 		b	.L308
 5029              	.L362:
 5030              	.LVL396:
 5031              	.LBE100:
 5032              	.LBE149:
 5033              	.LBB150:
 5034              	.LBB116:
2852:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5035              		.loc 1 2852 0
 5036 2cac 2000A0E3 		mov	r0, #32
 5037 2cb0 FEFFFFEB 		bl	ControlHandle
 5038              	.LVL397:
 5039 2cb4 30309DE5 		ldr	r3, [sp, #48]
 5040 2cb8 F7FDFFEA 		b	.L308
 5041              	.LVL398:
 5042              	.L451:
 5043              	.LBE116:
 5044              	.LBE150:
 5045              	.LBB151:
 5046              	.LBB111:
2900:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5047              		.loc 1 2900 0
 5048 2cbc 1A00A0E3 		mov	r0, #26
 5049 2cc0 80119FE5 		ldr	r1, .L452+80
 5050 2cc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5051 2cc8 30309DE5 		ldr	r3, [sp, #48]
 5052 2ccc FCFDFFEA 		b	.L370
 5053              	.LVL399:
 5054              	.L359:
 5055              	.LBE111:
 5056              	.LBE151:
 5057              	.LBB152:
 5058              	.LBB123:
2836:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5059              		.loc 1 2836 0
 5060 2cd0 1C00A0E3 		mov	r0, #28
 5061 2cd4 FEFFFFEB 		bl	ControlHandle
 5062              	.LVL400:
 5063 2cd8 30309DE5 		ldr	r3, [sp, #48]
 5064 2cdc EEFDFFEA 		b	.L308
 5065              	.L358:
 5066              	.LVL401:
2832:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5067              		.loc 1 2832 0
 5068 2ce0 1A00A0E3 		mov	r0, #26
 5069 2ce4 FEFFFFEB 		bl	ControlHandle
 5070              	.LVL402:
 5071 2ce8 30309DE5 		ldr	r3, [sp, #48]
 5072 2cec EAFDFFEA 		b	.L308
 5073              	.L360:
 5074              	.LVL403:
2844:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5075              		.loc 1 2844 0
 5076 2cf0 1E00A0E3 		mov	r0, #30
 5077 2cf4 FEFFFFEB 		bl	ControlHandle
 5078              	.LVL404:
 5079 2cf8 30309DE5 		ldr	r3, [sp, #48]
 5080 2cfc E6FDFFEA 		b	.L308
 5081              	.LVL405:
 5082              	.L422:
 5083              	.LBE123:
 5084              	.LBE152:
 5085              	.LBB153:
 5086              	.LBB102:
3139:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5087              		.loc 1 3139 0
 5088 2d00 44119FE5 		ldr	r1, .L452+84
 5089 2d04 B623DDE1 		ldrh	r2, [sp, #54]
 5090 2d08 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5091 2d0c 0400A0E3 		mov	r0, #4
 5092              	.LVL406:
 5093 2d10 FEFFFFEB 		bl	CyU3PDebugPrint
 5094 2d14 E5FDFFEA 		b	.L372
 5095              	.LVL407:
 5096              	.L447:
2963:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5097              		.loc 1 2963 0
 5098 2d18 2000A0E3 		mov	r0, #32
 5099 2d1c 00119FE5 		ldr	r1, .L452+44
 5100 2d20 36208DE2 		add	r2, sp, #54
 5101 2d24 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5102              	.LVL408:
2965:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5103              		.loc 1 2965 0
 5104 2d28 000050E3 		cmp	r0, #0
 5105 2d2c E3FDFF1A 		bne	.L432
2978:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5106              		.loc 1 2978 0
 5107 2d30 0020A0E3 		mov	r2, #0
 5108 2d34 BC009FE5 		ldr	r0, .L452
 5109              	.LVL409:
 5110 2d38 0110A0E3 		mov	r1, #1
 5111 2d3c FEFFFFEB 		bl	_txe_event_flags_set
 5112              	.LVL410:
2979:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5113              		.loc 1 2979 0
 5114 2d40 002050E2 		subs	r2, r0, #0
 5115 2d44 DDFDFF0A 		beq	.L432
 5116              	.L414:
3086:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5117              		.loc 1 3086 0
 5118 2d48 0400A0E3 		mov	r0, #4
 5119              	.LVL411:
 5120 2d4c D4109FE5 		ldr	r1, .L452+48
 5121 2d50 FEFFFFEB 		bl	CyU3PDebugPrint
 5122              	.LVL412:
 5123 2d54 30309DE5 		ldr	r3, [sp, #48]
 5124 2d58 D9FDFFEA 		b	.L370
 5125              	.LVL413:
 5126              	.L417:
3110:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5127              		.loc 1 3110 0
 5128 2d5c 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5129 2d60 030051E3 		cmp	r1, #3
 5130 2d64 DBFEFF1A 		bne	.L421
3112:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5131              		.loc 1 3112 0
 5132 2d68 1A00A0E3 		mov	r0, #26
 5133 2d6c DC109FE5 		ldr	r1, .L452+88
 5134 2d70 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5135 2d74 30309DE5 		ldr	r3, [sp, #48]
 5136 2d78 D1FDFFEA 		b	.L370
 5137              	.LVL414:
 5138              	.L350:
 5139              	.LBE102:
 5140              	.LBE153:
 5141              	.LBB154:
 5142              	.LBB115:
2797:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5143              		.loc 1 2797 0
 5144 2d7c 1200A0E3 		mov	r0, #18
 5145 2d80 FEFFFFEB 		bl	ControlHandle
 5146              	.LVL415:
 5147 2d84 30309DE5 		ldr	r3, [sp, #48]
 5148 2d88 C3FDFFEA 		b	.L308
 5149              	.L349:
 5150              	.LVL416:
2793:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5151              		.loc 1 2793 0
 5152 2d8c 1100A0E3 		mov	r0, #17
 5153 2d90 FEFFFFEB 		bl	ControlHandle
 5154              	.LVL417:
 5155 2d94 30309DE5 		ldr	r3, [sp, #48]
 5156 2d98 BFFDFFEA 		b	.L308
 5157              	.L351:
 5158              	.LVL418:
2801:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5159              		.loc 1 2801 0
 5160 2d9c 1300A0E3 		mov	r0, #19
 5161 2da0 FEFFFFEB 		bl	ControlHandle
 5162              	.LVL419:
 5163 2da4 30309DE5 		ldr	r3, [sp, #48]
 5164 2da8 BBFDFFEA 		b	.L308
 5165              	.L356:
 5166              	.LVL420:
2821:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5167              		.loc 1 2821 0
 5168 2dac 1800A0E3 		mov	r0, #24
 5169 2db0 FEFFFFEB 		bl	ControlHandle
 5170              	.LVL421:
 5171 2db4 30309DE5 		ldr	r3, [sp, #48]
 5172 2db8 B7FDFFEA 		b	.L308
 5173              	.L354:
 5174              	.LVL422:
2813:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5175              		.loc 1 2813 0
 5176 2dbc 1600A0E3 		mov	r0, #22
 5177 2dc0 FEFFFFEB 		bl	ControlHandle
 5178              	.LVL423:
 5179 2dc4 30309DE5 		ldr	r3, [sp, #48]
 5180 2dc8 B3FDFFEA 		b	.L308
 5181              	.L353:
 5182              	.LVL424:
2809:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5183              		.loc 1 2809 0
 5184 2dcc 1500A0E3 		mov	r0, #21
 5185 2dd0 FEFFFFEB 		bl	ControlHandle
 5186              	.LVL425:
 5187 2dd4 30309DE5 		ldr	r3, [sp, #48]
 5188 2dd8 AFFDFFEA 		b	.L308
 5189              	.LVL426:
 5190              	.L418:
 5191              	.LBE115:
 5192              	.LBE154:
 5193              	.LBB155:
 5194              	.LBB112:
3107:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5195              		.loc 1 3107 0
 5196 2ddc 0200A0E3 		mov	r0, #2
 5197 2de0 54109FE5 		ldr	r1, .L452+68
 5198 2de4 EFFEFFEA 		b	.L433
 5199              	.LVL427:
 5200              	.L363:
 5201              	.LBE112:
 5202              	.LBE155:
 5203              	.LBB156:
 5204              	.LBB124:
2856:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5205              		.loc 1 2856 0
 5206 2de8 2100A0E3 		mov	r0, #33
 5207 2dec FEFFFFEB 		bl	ControlHandle
 5208              	.LVL428:
 5209 2df0 30309DE5 		ldr	r3, [sp, #48]
 5210 2df4 A8FDFFEA 		b	.L308
 5211              	.L453:
 5212              		.align	2
 5213              	.L452:
 5214 2df8 00000000 		.word	.LANCHOR0
 5215 2dfc 00000000 		.word	.LANCHOR1
 5216 2e00 00000000 		.word	bRequest
 5217 2e04 00000000 		.word	wValue
 5218 2e08 00000000 		.word	wIndex
 5219 2e0c 00000000 		.word	glInterStaBuffer
 5220 2e10 E8040000 		.word	.LC26
 5221 2e14 00000000 		.word	glChHandleInterStat
 5222 2e18 00000000 		.word	bmReqType
 5223 2e1c 00000000 		.word	wLength
 5224 2e20 6C040000 		.word	.LC25
 5225 2e24 7C000000 		.word	.LANCHOR0+124
 5226 2e28 14050000 		.word	.LC27
 5227 2e2c 3C050000 		.word	.LC28
 5228 2e30 64060000 		.word	.LANCHOR1+1636
 5229 2e34 70060000 		.word	.LANCHOR1+1648
 5230 2e38 2C060000 		.word	.LANCHOR1+1580
 5231 2e3c 58000000 		.word	.LANCHOR0+88
 5232 2e40 8C050000 		.word	.LC30
 5233 2e44 D8010000 		.word	.LC12
 5234 2e48 10060000 		.word	.LANCHOR1+1552
 5235 2e4c 64050000 		.word	.LC29
 5236 2e50 48060000 		.word	.LANCHOR1+1608
 5237              	.LBE124:
 5238              	.LBE156:
 5239              		.cfi_endproc
 5240              	.LFE24:
 5242              		.align	2
 5243              		.global	CamDefSet
 5245              	CamDefSet:
 5246              	.LFB4:
1170:../uvc.c      **** {
 5247              		.loc 1 1170 0
 5248              		.cfi_startproc
 5249              		@ args = 0, pretend = 0, frame = 24
 5250              		@ frame_needed = 0, uses_anonymous_args = 0
 5251              	.LVL429:
 5252 2e54 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5253              	.LCFI19:
 5254              		.cfi_def_cfa_offset 36
1176:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5255              		.loc 1 1176 0
 5256 2e58 AC429FE5 		ldr	r4, .L457
 5257              		.cfi_offset 14, -4
 5258              		.cfi_offset 11, -8
 5259              		.cfi_offset 10, -12
 5260              		.cfi_offset 9, -16
 5261              		.cfi_offset 8, -20
 5262              		.cfi_offset 7, -24
 5263              		.cfi_offset 6, -28
 5264              		.cfi_offset 5, -32
 5265              		.cfi_offset 4, -36
1181:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5266              		.loc 1 1181 0
 5267 2e5c AC229FE5 		ldr	r2, .L457+4
1178:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5268              		.loc 1 1178 0
 5269 2e60 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1170:../uvc.c      **** {
 5270              		.loc 1 1170 0
 5271 2e64 2CD04DE2 		sub	sp, sp, #44
 5272              	.LCFI20:
 5273              		.cfi_def_cfa_offset 80
1181:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5274              		.loc 1 1181 0
 5275 2e68 1C0092E5 		ldr	r0, [r2, #28]
 5276 2e6c 0010E0E3 		mvn	r1, #0
1183:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5277              		.loc 1 1183 0
 5278 2e70 2963A0E1 		mov	r6, r9, lsr #6
1177:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5279              		.loc 1 1177 0
 5280 2e74 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1176:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5281              		.loc 1 1176 0
 5282 2e78 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5283              	.LVL430:
1181:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5284              		.loc 1 1181 0
 5285 2e7c FEFFFFEB 		bl	_txe_mutex_get
1182:../uvc.c      ****     if(Data1&0x80){
 5286              		.loc 1 1182 0
 5287 2e80 800019E3 		tst	r9, #128
1183:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5288              		.loc 1 1183 0
 5289 2e84 01600612 		andne	r6, r6, #1
 5290 2e88 0660E011 		mvnne	r6, r6
 5291 2e8c 3B600612 		andne	r6, r6, #59
 5292 2e90 0660E011 		mvnne	r6, r6
 5293 2e94 FF600612 		andne	r6, r6, #255
 5294              	.LVL431:
1185:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5295              		.loc 1 1185 0
 5296 2e98 C6608603 		orreq	r6, r6, #198
 5297              	.LVL432:
1189:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5298              		.loc 1 1189 0
 5299 2e9c 0080A0E3 		mov	r8, #0
 5300 2ea0 0A20A0E1 		mov	r2, sl
 5301 2ea4 0730A0E1 		mov	r3, r7
 5302 2ea8 0110A0E3 		mov	r1, #1
1187:../uvc.c      ****     Data0 = (Data0 << 2);
 5303              		.loc 1 1187 0
 5304 2eac 0951A0E1 		mov	r5, r9, asl #2
1189:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5305              		.loc 1 1189 0
 5306 2eb0 58029FE5 		ldr	r0, .L457+4
1192:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5307              		.loc 1 1192 0
 5308 2eb4 0190A0E3 		mov	r9, #1
 5309              	.LVL433:
1187:../uvc.c      ****     Data0 = (Data0 << 2);
 5310              		.loc 1 1187 0
 5311 2eb8 FF5005E2 		and	r5, r5, #255
 5312              	.LVL434:
1189:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5313              		.loc 1 1189 0
 5314 2ebc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5315 2ec0 FEFFFFEB 		bl	cmdSet
 5316              	.LVL435:
1192:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5317              		.loc 1 1192 0
 5318 2ec4 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5319 2ec8 0910A0E1 		mov	r1, r9
 5320 2ecc 0730A0E1 		mov	r3, r7
 5321 2ed0 38029FE5 		ldr	r0, .L457+4
 5322 2ed4 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5323 2ed8 FEFFFFEB 		bl	cmdSet
 5324              	.LVL436:
1195:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5325              		.loc 1 1195 0
 5326 2edc 0620A0E1 		mov	r2, r6
 5327 2ee0 0530A0E1 		mov	r3, r5
 5328 2ee4 28129FE5 		ldr	r1, .L457+8
 5329 2ee8 0400A0E3 		mov	r0, #4
1194:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5330              		.loc 1 1194 0
 5331 2eec A661C4E5 		strb	r6, [r4, #422]
1193:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5332              		.loc 1 1193 0
 5333 2ef0 A551C4E5 		strb	r5, [r4, #421]
1195:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5334              		.loc 1 1195 0
 5335 2ef4 FEFFFFEB 		bl	CyU3PDebugPrint
 5336              	.LVL437:
1200:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5337              		.loc 1 1200 0
 5338 2ef8 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5339              	.LVL438:
1201:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5340              		.loc 1 1201 0
 5341 2efc B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5342 2f00 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5343 2f04 0210A0E3 		mov	r1, #2
 5344 2f08 00029FE5 		ldr	r0, .L457+4
 5345 2f0c 00B08DE5 		str	fp, [sp, #0]
 5346 2f10 04808DE5 		str	r8, [sp, #4]
 5347 2f14 FEFFFFEB 		bl	cmdSet
 5348              	.LVL439:
1203:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5349              		.loc 1 1203 0
 5350 2f18 0B20A0E1 		mov	r2, fp
 5351 2f1c 0530A0E1 		mov	r3, r5
 5352 2f20 EC119FE5 		ldr	r1, .L457+8
 5353 2f24 0400A0E3 		mov	r0, #4
1202:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5354              		.loc 1 1202 0
 5355 2f28 BD51C4E5 		strb	r5, [r4, #445]
1203:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5356              		.loc 1 1203 0
 5357 2f2c FEFFFFEB 		bl	CyU3PDebugPrint
 5358              	.LVL440:
1208:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5359              		.loc 1 1208 0
 5360 2f30 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1207:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5361              		.loc 1 1207 0
 5362 2f34 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5363              	.LVL441:
1209:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5364              		.loc 1 1209 0
 5365 2f38 80B047E2 		sub	fp, r7, #128
 5366 2f3c FF100BE2 		and	r1, fp, #255
 5367 2f40 14108DE5 		str	r1, [sp, #20]
 5368 2f44 14C09DE5 		ldr	ip, [sp, #20]
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5369              		.loc 1 1210 0
 5370 2f48 760047E2 		sub	r0, r7, #118
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5371              		.loc 1 1211 0
 5372 2f4c 7EE087E2 		add	lr, r7, #126
1209:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5373              		.loc 1 1209 0
 5374 2f50 0630A0E1 		mov	r3, r6
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5375              		.loc 1 1210 0
 5376 2f54 18008DE5 		str	r0, [sp, #24]
1209:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5377              		.loc 1 1209 0
 5378 2f58 0510A0E3 		mov	r1, #5
 5379 2f5c DF20A0E3 		mov	r2, #223
 5380 2f60 A8019FE5 		ldr	r0, .L457+4
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5381              		.loc 1 1211 0
 5382 2f64 1CE08DE5 		str	lr, [sp, #28]
1209:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5383              		.loc 1 1209 0
 5384 2f68 00C08DE5 		str	ip, [sp, #0]
 5385 2f6c 04808DE5 		str	r8, [sp, #4]
 5386 2f70 FEFFFFEB 		bl	cmdSet
 5387              	.LVL442:
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5388              		.loc 1 1210 0
 5389 2f74 18A09DE5 		ldr	sl, [sp, #24]
1212:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5390              		.loc 1 1212 0
 5391 2f78 72E087E2 		add	lr, r7, #114
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5392              		.loc 1 1210 0
 5393 2f7c FFC00AE2 		and	ip, sl, #255
 5394 2f80 0630A0E1 		mov	r3, r6
 5395 2f84 0510A0E3 		mov	r1, #5
 5396 2f88 DC20A0E3 		mov	r2, #220
 5397 2f8c 7C019FE5 		ldr	r0, .L457+4
1212:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5398              		.loc 1 1212 0
 5399 2f90 20E08DE5 		str	lr, [sp, #32]
1210:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5400              		.loc 1 1210 0
 5401 2f94 00C08DE5 		str	ip, [sp, #0]
 5402 2f98 04908DE5 		str	r9, [sp, #4]
 5403 2f9c FEFFFFEB 		bl	cmdSet
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5404              		.loc 1 1211 0
 5405 2fa0 1C009DE5 		ldr	r0, [sp, #28]
 5406 2fa4 02E0A0E3 		mov	lr, #2
 5407 2fa8 FFC000E2 		and	ip, r0, #255
 5408 2fac 0630A0E1 		mov	r3, r6
1213:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5409              		.loc 1 1213 0
 5410 2fb0 6FA047E2 		sub	sl, r7, #111
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5411              		.loc 1 1211 0
 5412 2fb4 0510A0E3 		mov	r1, #5
 5413 2fb8 DE20A0E3 		mov	r2, #222
 5414 2fbc 4C019FE5 		ldr	r0, .L457+4
 5415 2fc0 04E08DE5 		str	lr, [sp, #4]
1213:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5416              		.loc 1 1213 0
 5417 2fc4 24A08DE5 		str	sl, [sp, #36]
1211:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5418              		.loc 1 1211 0
 5419 2fc8 00C08DE5 		str	ip, [sp, #0]
 5420 2fcc FEFFFFEB 		bl	cmdSet
1212:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5421              		.loc 1 1212 0
 5422 2fd0 20A09DE5 		ldr	sl, [sp, #32]
 5423 2fd4 0630A0E1 		mov	r3, r6
 5424 2fd8 FFC00AE2 		and	ip, sl, #255
 5425 2fdc 00C08DE5 		str	ip, [sp, #0]
 5426 2fe0 0510A0E3 		mov	r1, #5
 5427 2fe4 03C0A0E3 		mov	ip, #3
 5428 2fe8 E020A0E3 		mov	r2, #224
 5429 2fec 1C019FE5 		ldr	r0, .L457+4
 5430 2ff0 04C08DE5 		str	ip, [sp, #4]
 5431 2ff4 FEFFFFEB 		bl	cmdSet
1213:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5432              		.loc 1 1213 0
 5433 2ff8 24009DE5 		ldr	r0, [sp, #36]
 5434 2ffc 04A0A0E3 		mov	sl, #4
 5435 3000 FFC000E2 		and	ip, r0, #255
 5436 3004 0630A0E1 		mov	r3, r6
 5437 3008 0510A0E3 		mov	r1, #5
 5438 300c DD20A0E3 		mov	r2, #221
 5439 3010 F8009FE5 		ldr	r0, .L457+4
 5440 3014 00C08DE5 		str	ip, [sp, #0]
1214:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5441              		.loc 1 1214 0
 5442 3018 7F7087E2 		add	r7, r7, #127
 5443              	.LVL443:
1213:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5444              		.loc 1 1213 0
 5445 301c 04A08DE5 		str	sl, [sp, #4]
 5446 3020 FEFFFFEB 		bl	cmdSet
1214:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5447              		.loc 1 1214 0
 5448 3024 05E0A0E3 		mov	lr, #5
 5449 3028 0E10A0E1 		mov	r1, lr
 5450 302c 0630A0E1 		mov	r3, r6
 5451 3030 E120A0E3 		mov	r2, #225
 5452 3034 FF6007E2 		and	r6, r7, #255
 5453              	.LVL444:
 5454 3038 D0009FE5 		ldr	r0, .L457+4
 5455 303c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5456 3040 FEFFFFEB 		bl	cmdSet
 5457              	.LVL445:
1215:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5458              		.loc 1 1215 0
 5459 3044 14C09DE5 		ldr	ip, [sp, #20]
1216:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5460              		.loc 1 1216 0
 5461 3048 24E09DE5 		ldr	lr, [sp, #36]
 5462 304c 1C609DE5 		ldr	r6, [sp, #28]
1215:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5463              		.loc 1 1215 0
 5464 3050 05C2C4E5 		strb	ip, [r4, #517]
1216:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5465              		.loc 1 1216 0
 5466 3054 20C09DE5 		ldr	ip, [sp, #32]
 5467 3058 0B20A0E1 		mov	r2, fp
 5468 305c 18309DE5 		ldr	r3, [sp, #24]
 5469 3060 B0109FE5 		ldr	r1, .L457+12
 5470 3064 0A00A0E1 		mov	r0, sl
 5471 3068 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5472 306c 0C708DE5 		str	r7, [sp, #12]
 5473 3070 FEFFFFEB 		bl	CyU3PDebugPrint
 5474              	.LVL446:
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5475              		.loc 1 1220 0
 5476 3074 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5477              	.LVL447:
1221:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5478              		.loc 1 1221 0
 5479 3078 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5480              	.LVL448:
1222:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5481              		.loc 1 1222 0
 5482 307c 0730A0E1 		mov	r3, r7
 5483 3080 0610A0E3 		mov	r1, #6
 5484 3084 8520A0E3 		mov	r2, #133
 5485 3088 80009FE5 		ldr	r0, .L457+4
 5486 308c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5487 3090 FEFFFFEB 		bl	cmdSet
1223:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5488              		.loc 1 1223 0
 5489 3094 0730A0E1 		mov	r3, r7
 5490 3098 0610A0E3 		mov	r1, #6
 5491 309c 8620A0E3 		mov	r2, #134
 5492 30a0 68009FE5 		ldr	r0, .L457+4
 5493 30a4 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5494 30a8 FEFFFFEB 		bl	cmdSet
1225:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5495              		.loc 1 1225 0
 5496 30ac 0620A0E1 		mov	r2, r6
 5497 30b0 0530A0E1 		mov	r3, r5
 5498 30b4 58109FE5 		ldr	r1, .L457+8
 5499 30b8 0A00A0E1 		mov	r0, sl
1224:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5500              		.loc 1 1224 0
 5501 30bc 1D62C4E5 		strb	r6, [r4, #541]
1225:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5502              		.loc 1 1225 0
 5503 30c0 FEFFFFEB 		bl	CyU3PDebugPrint
 5504              	.LVL449:
1230:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5505              		.loc 1 1230 0
 5506 30c4 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5507              	.LVL450:
1231:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5508              		.loc 1 1231 0
 5509 30c8 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5510 30cc 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5511 30d0 0710A0E3 		mov	r1, #7
 5512 30d4 34009FE5 		ldr	r0, .L457+4
 5513 30d8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5514 30dc FEFFFFEB 		bl	cmdSet
 5515              	.LVL451:
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5516              		.loc 1 1233 0
 5517 30e0 0530A0E1 		mov	r3, r5
 5518 30e4 0A00A0E1 		mov	r0, sl
 5519 30e8 24109FE5 		ldr	r1, .L457+8
 5520 30ec 0620A0E1 		mov	r2, r6
1232:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5521              		.loc 1 1232 0
 5522 30f0 3552C4E5 		strb	r5, [r4, #565]
1233:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5523              		.loc 1 1233 0
 5524 30f4 FEFFFFEB 		bl	CyU3PDebugPrint
1235:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5525              		.loc 1 1235 0
 5526 30f8 10309FE5 		ldr	r3, .L457+4
 5527 30fc 1C0093E5 		ldr	r0, [r3, #28]
1238:../uvc.c      **** }
 5528              		.loc 1 1238 0
 5529 3100 2CD08DE2 		add	sp, sp, #44
 5530 3104 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1235:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5531              		.loc 1 1235 0
 5532 3108 FEFFFFEA 		b	_txe_mutex_put
 5533              	.L458:
 5534              		.align	2
 5535              	.L457:
 5536 310c 00000000 		.word	.LANCHOR1
 5537 3110 00000000 		.word	cmdQu
 5538 3114 C0050000 		.word	.LC31
 5539 3118 E0050000 		.word	.LC32
 5540              		.cfi_endproc
 5541              	.LFE4:
 5543              		.align	2
 5544              		.global	CyFxUVCAddHeader
 5546              	CyFxUVCAddHeader:
 5547              	.LFB5:
1246:../uvc.c      **** {
 5548              		.loc 1 1246 0
 5549              		.cfi_startproc
 5550              		@ args = 0, pretend = 0, frame = 0
 5551              		@ frame_needed = 0, uses_anonymous_args = 0
 5552              	.LVL452:
 5553 311c 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5554              	.LCFI21:
 5555              		.cfi_def_cfa_offset 16
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5556              		.loc 1 1248 0
 5557 3120 0C20A0E3 		mov	r2, #12
1246:../uvc.c      **** {
 5558              		.loc 1 1246 0
 5559 3124 0150A0E1 		mov	r5, r1
 5560              		.cfi_offset 14, -4
 5561              		.cfi_offset 5, -8
 5562              		.cfi_offset 4, -12
 5563              		.cfi_offset 3, -16
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5564              		.loc 1 1248 0
 5565 3128 18109FE5 		ldr	r1, .L461
 5566              	.LVL453:
1246:../uvc.c      **** {
 5567              		.loc 1 1246 0
 5568 312c 0040A0E1 		mov	r4, r0
1248:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5569              		.loc 1 1248 0
 5570 3130 FEFFFFEB 		bl	CyU3PMemCopy
 5571              	.LVL454:
1251:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5572              		.loc 1 1251 0
 5573 3134 020015E3 		tst	r5, #2
1253:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5574              		.loc 1 1253 0
 5575 3138 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5576 313c 02308313 		orrne	r3, r3, #2
 5577 3140 0130C415 		strneb	r3, [r4, #1]
 5578 3144 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5579              	.L462:
 5580              		.align	2
 5581              	.L461:
 5582 3148 80040000 		.word	.LANCHOR1+1152
 5583              		.cfi_endproc
 5584              	.LFE5:
 5586              		.align	2
 5587              		.global	CyFxAppErrorHandler
 5589              	CyFxAppErrorHandler:
 5590              	.LFB6:
1263:../uvc.c      **** {
 5591              		.loc 1 1263 0
 5592              		.cfi_startproc
 5593              		@ args = 0, pretend = 0, frame = 0
 5594              		@ frame_needed = 0, uses_anonymous_args = 0
 5595              	.LVL455:
 5596 314c 08402DE9 		stmfd	sp!, {r3, lr}
 5597              	.LCFI22:
 5598              		.cfi_def_cfa_offset 8
 5599              	.LVL456:
 5600              	.L464:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5601              		.loc 1 1273 0 discriminator 1
 5602 3150 10109FE5 		ldr	r1, .L465
 5603 3154 0400A0E3 		mov	r0, #4
 5604              		.cfi_offset 14, -4
 5605              		.cfi_offset 3, -8
 5606 3158 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 5607              		.loc 1 1274 0 discriminator 1
 5608 315c FA0FA0E3 		mov	r0, #1000
 5609 3160 FEFFFFEB 		bl	_tx_thread_sleep
 5610 3164 F9FFFFEA 		b	.L464
 5611              	.L466:
 5612              		.align	2
 5613              	.L465:
 5614 3168 D8010000 		.word	.LC12
 5615              		.cfi_endproc
 5616              	.LFE6:
 5618              		.align	2
 5619              		.global	UVCAppThread_Entry
 5621              	UVCAppThread_Entry:
 5622              	.LFB18:
2229:../uvc.c      **** {
 5623              		.loc 1 2229 0
 5624              		.cfi_startproc
 5625              		@ args = 0, pretend = 0, frame = 176
 5626              		@ frame_needed = 0, uses_anonymous_args = 0
 5627              	.LVL457:
 5628 316c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5629              	.LCFI23:
 5630              		.cfi_def_cfa_offset 28
 5631 3170 BCD04DE2 		sub	sp, sp, #188
 5632              	.LCFI24:
 5633              		.cfi_def_cfa_offset 216
 5634              	.LBB209:
 5635              	.LBB210:
1686:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5636              		.loc 1 1686 0
 5637              		.cfi_offset 14, -4
 5638              		.cfi_offset 10, -8
 5639              		.cfi_offset 8, -12
 5640              		.cfi_offset 7, -16
 5641              		.cfi_offset 6, -20
 5642              		.cfi_offset 5, -24
 5643              		.cfi_offset 4, -28
 5644 3174 FEFFFFEB 		bl	CyU3PUartInit
 5645              	.LVL458:
1687:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5646              		.loc 1 1687 0
 5647 3178 004050E2 		subs	r4, r0, #0
 5648 317c 0400000A 		beq	.L468
1689:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5649              		.loc 1 1689 0
 5650 3180 0400A0E3 		mov	r0, #4
 5651              	.LVL459:
 5652 3184 4C1A9FE5 		ldr	r1, .L558
 5653 3188 FEFFFFEB 		bl	CyU3PDebugPrint
1690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5654              		.loc 1 1690 0
 5655 318c 0400A0E1 		mov	r0, r4
 5656 3190 FEFFFFEB 		bl	CyFxAppErrorHandler
 5657              	.L468:
1694:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5658              		.loc 1 1694 0
 5659 3194 40CA9FE5 		ldr	ip, .L558+4
1696:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5660              		.loc 1 1696 0
 5661 3198 0030A0E3 		mov	r3, #0
1695:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5662              		.loc 1 1695 0
 5663 319c 0120A0E3 		mov	r2, #1
1703:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5664              		.loc 1 1703 0
 5665 31a0 50008DE2 		add	r0, sp, #80
 5666 31a4 0310A0E1 		mov	r1, r3
1694:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5667              		.loc 1 1694 0
 5668 31a8 60C08DE5 		str	ip, [sp, #96]
1695:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5669              		.loc 1 1695 0
 5670 31ac 6420CDE5 		strb	r2, [sp, #100]
1696:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5671              		.loc 1 1696 0
 5672 31b0 6530CDE5 		strb	r3, [sp, #101]
1697:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5673              		.loc 1 1697 0
 5674 31b4 50208DE5 		str	r2, [sp, #80]
1698:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5675              		.loc 1 1698 0
 5676 31b8 54308DE5 		str	r3, [sp, #84]
1699:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5677              		.loc 1 1699 0
 5678 31bc 58308DE5 		str	r3, [sp, #88]
1700:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5679              		.loc 1 1700 0
 5680 31c0 5C208DE5 		str	r2, [sp, #92]
1703:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5681              		.loc 1 1703 0
 5682 31c4 FEFFFFEB 		bl	CyU3PUartSetConfig
 5683              	.LVL460:
1704:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5684              		.loc 1 1704 0
 5685 31c8 000050E3 		cmp	r0, #0
 5686 31cc 0000000A 		beq	.L469
1706:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5687              		.loc 1 1706 0
 5688 31d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5689              	.LVL461:
 5690              	.L469:
1710:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5691              		.loc 1 1710 0
 5692 31d4 0000E0E3 		mvn	r0, #0
 5693 31d8 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5694              	.LVL462:
1711:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5695              		.loc 1 1711 0
 5696 31dc 000050E3 		cmp	r0, #0
 5697 31e0 0000000A 		beq	.L470
1713:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5698              		.loc 1 1713 0
 5699 31e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5700              	.LVL463:
 5701              	.L470:
1717:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5702              		.loc 1 1717 0
 5703 31e8 0300A0E3 		mov	r0, #3
 5704 31ec 0410A0E3 		mov	r1, #4
 5705 31f0 FEFFFFEB 		bl	CyU3PDebugInit
 5706              	.LVL464:
1718:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5707              		.loc 1 1718 0
 5708 31f4 000050E3 		cmp	r0, #0
 5709 31f8 0000000A 		beq	.L471
1720:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5710              		.loc 1 1720 0
 5711 31fc FEFFFFEB 		bl	CyFxAppErrorHandler
 5712              	.LVL465:
 5713              	.L471:
1724:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5714              		.loc 1 1724 0
 5715 3200 0000A0E3 		mov	r0, #0
 5716 3204 FEFFFFEB 		bl	CyU3PDebugPreamble
 5717              	.LVL466:
 5718              	.LBE210:
 5719              	.LBE209:
2245:../uvc.c      **** 		CyU3PThreadSleep(500);
 5720              		.loc 1 2245 0
 5721 3208 7D0FA0E3 		mov	r0, #500
 5722 320c FEFFFFEB 		bl	_tx_thread_sleep
 5723              	.LVL467:
 5724 3210 7D0FA0E3 		mov	r0, #500
 5725 3214 FEFFFFEB 		bl	_tx_thread_sleep
 5726 3218 7D0FA0E3 		mov	r0, #500
 5727 321c FEFFFFEB 		bl	_tx_thread_sleep
 5728 3220 7D0FA0E3 		mov	r0, #500
 5729 3224 FEFFFFEB 		bl	_tx_thread_sleep
 5730 3228 7D0FA0E3 		mov	r0, #500
 5731 322c FEFFFFEB 		bl	_tx_thread_sleep
 5732 3230 7D0FA0E3 		mov	r0, #500
 5733 3234 FEFFFFEB 		bl	_tx_thread_sleep
 5734              	.LBB211:
 5735              	.LBB212:
1734:../uvc.c      ****     status = CyU3PI2cInit ();
 5736              		.loc 1 1734 0
 5737 3238 FEFFFFEB 		bl	CyU3PI2cInit
 5738              	.LVL468:
1735:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5739              		.loc 1 1735 0
 5740 323c 004050E2 		subs	r4, r0, #0
 5741 3240 0400000A 		beq	.L472
1737:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5742              		.loc 1 1737 0
 5743 3244 0400A0E3 		mov	r0, #4
 5744              	.LVL469:
 5745 3248 90199FE5 		ldr	r1, .L558+8
 5746 324c FEFFFFEB 		bl	CyU3PDebugPrint
1738:../uvc.c      ****         CyFxAppErrorHandler (status);
 5747              		.loc 1 1738 0
 5748 3250 0400A0E1 		mov	r0, r4
 5749 3254 FEFFFFEB 		bl	CyFxAppErrorHandler
 5750              	.L472:
1742:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5751              		.loc 1 1742 0
 5752 3258 84699FE5 		ldr	r6, .L558+12
1743:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5753              		.loc 1 1743 0
 5754 325c 0050A0E3 		mov	r5, #0
1744:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5755              		.loc 1 1744 0
 5756 3260 0040E0E3 		mvn	r4, #0
 5757              	.LVL470:
1747:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5758              		.loc 1 1747 0
 5759 3264 8C008DE2 		add	r0, sp, #140
 5760 3268 0510A0E1 		mov	r1, r5
1744:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5761              		.loc 1 1744 0
 5762 326c 94408DE5 		str	r4, [sp, #148]
1745:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5763              		.loc 1 1745 0
 5764 3270 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1742:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5765              		.loc 1 1742 0
 5766 3274 8C608DE5 		str	r6, [sp, #140]
1743:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5767              		.loc 1 1743 0
 5768 3278 90508DE5 		str	r5, [sp, #144]
1747:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5769              		.loc 1 1747 0
 5770 327c FEFFFFEB 		bl	CyU3PI2cSetConfig
 5771              	.LVL471:
1748:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5772              		.loc 1 1748 0
 5773 3280 004050E2 		subs	r4, r0, #0
 5774 3284 0400000A 		beq	.L473
1750:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 5775              		.loc 1 1750 0
 5776 3288 0400A0E3 		mov	r0, #4
 5777              	.LVL472:
 5778 328c 54199FE5 		ldr	r1, .L558+16
 5779 3290 FEFFFFEB 		bl	CyU3PDebugPrint
1751:../uvc.c      ****         CyFxAppErrorHandler (status);
 5780              		.loc 1 1751 0
 5781 3294 0400A0E1 		mov	r0, r4
 5782 3298 FEFFFFEB 		bl	CyFxAppErrorHandler
 5783              	.L473:
 5784              	.LBE212:
 5785              	.LBE211:
 5786              	.LBB213:
 5787              	.LBB216:
1821:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5788              		.loc 1 1821 0
 5789 329c 48699FE5 		ldr	r6, .L558+20
 5790 32a0 2820A0E3 		mov	r2, #40
 5791 32a4 0010A0E3 		mov	r1, #0
 5792 32a8 0600A0E1 		mov	r0, r6
 5793 32ac FEFFFFEB 		bl	_txe_event_flags_create
 5794              	.LVL473:
1822:../uvc.c      ****     if (apiRetStatus != 0)
 5795              		.loc 1 1822 0
 5796 32b0 002050E2 		subs	r2, r0, #0
 5797 32b4 F300001A 		bne	.L535
1836:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5798              		.loc 1 1836 0
 5799 32b8 0250A0E3 		mov	r5, #2
1843:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5800              		.loc 1 1843 0
 5801 32bc 0210A0E1 		mov	r1, r2
1832:../uvc.c      ****     isUsbConnected = CyFalse;
 5802              		.loc 1 1832 0
 5803 32c0 402086E5 		str	r2, [r6, #64]
1833:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5804              		.loc 1 1833 0
 5805 32c4 442086E5 		str	r2, [r6, #68]
1839:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5806              		.loc 1 1839 0
 5807 32c8 0370A0E3 		mov	r7, #3
1843:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5808              		.loc 1 1843 0
 5809 32cc 9C008DE2 		add	r0, sp, #156
 5810              	.LVL474:
1838:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5811              		.loc 1 1838 0
 5812 32d0 A420CDE5 		strb	r2, [sp, #164]
1840:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5813              		.loc 1 1840 0
 5814 32d4 A0208DE5 		str	r2, [sp, #160]
1836:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5815              		.loc 1 1836 0
 5816 32d8 9C50CDE5 		strb	r5, [sp, #156]
1837:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5817              		.loc 1 1837 0
 5818 32dc 9D50CDE5 		strb	r5, [sp, #157]
1839:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5819              		.loc 1 1839 0
 5820 32e0 A570CDE5 		strb	r7, [sp, #165]
1843:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5821              		.loc 1 1843 0
 5822 32e4 FEFFFFEB 		bl	CyU3PGpioInit
 5823              	.LVL475:
1844:../uvc.c      ****     if (apiRetStatus != 0)
 5824              		.loc 1 1844 0
 5825 32e8 002050E2 		subs	r2, r0, #0
 5826 32ec F700001A 		bne	.L536
1852:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5827              		.loc 1 1852 0
 5828 32f0 1600A0E3 		mov	r0, #22
 5829              	.LVL476:
 5830 32f4 0110A0E3 		mov	r1, #1
 5831 32f8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5832              	.LVL477:
1853:../uvc.c      ****     if (apiRetStatus != 0)
 5833              		.loc 1 1853 0
 5834 32fc 002050E2 		subs	r2, r0, #0
 5835 3300 E900001A 		bne	.L537
1858:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5836              		.loc 1 1858 0
 5837 3304 1400A0E3 		mov	r0, #20
 5838              	.LVL478:
 5839 3308 0110A0E3 		mov	r1, #1
 5840 330c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5841              	.LVL479:
1859:../uvc.c      ****     if (apiRetStatus != 0)
 5842              		.loc 1 1859 0
 5843 3310 002050E2 		subs	r2, r0, #0
 5844 3314 F600001A 		bne	.L538
1864:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5845              		.loc 1 1864 0
 5846 3318 1800A0E3 		mov	r0, #24
 5847              	.LVL480:
 5848 331c 0110A0E3 		mov	r1, #1
 5849 3320 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5850              	.LVL481:
1865:../uvc.c      ****     if (apiRetStatus != 0)
 5851              		.loc 1 1865 0
 5852 3324 002050E2 		subs	r2, r0, #0
 5853 3328 DB01001A 		bne	.L539
1872:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5854              		.loc 1 1872 0
 5855 332c 0140A0E3 		mov	r4, #1
 5856              	.LVL482:
1877:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5857              		.loc 1 1877 0
 5858 3330 1600A0E3 		mov	r0, #22
 5859              	.LVL483:
 5860 3334 68108DE2 		add	r1, sp, #104
1875:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5861              		.loc 1 1875 0
 5862 3338 74208DE5 		str	r2, [sp, #116]
1876:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5863              		.loc 1 1876 0
 5864 333c 7820CDE5 		strb	r2, [sp, #120]
1872:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5865              		.loc 1 1872 0
 5866 3340 68408DE5 		str	r4, [sp, #104]
1873:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5867              		.loc 1 1873 0
 5868 3344 6C408DE5 		str	r4, [sp, #108]
1874:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5869              		.loc 1 1874 0
 5870 3348 70408DE5 		str	r4, [sp, #112]
1877:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5871              		.loc 1 1877 0
 5872 334c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5873              	.LVL484:
1878:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5874              		.loc 1 1878 0
 5875 3350 002050E2 		subs	r2, r0, #0
 5876 3354 C701001A 		bne	.L540
1891:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5877              		.loc 1 1891 0
 5878 3358 1400A0E3 		mov	r0, #20
 5879              	.LVL485:
 5880 335c 68108DE2 		add	r1, sp, #104
1889:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5881              		.loc 1 1889 0
 5882 3360 74208DE5 		str	r2, [sp, #116]
1890:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5883              		.loc 1 1890 0
 5884 3364 7820CDE5 		strb	r2, [sp, #120]
1886:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5885              		.loc 1 1886 0
 5886 3368 68408DE5 		str	r4, [sp, #104]
1887:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5887              		.loc 1 1887 0
 5888 336c 6C408DE5 		str	r4, [sp, #108]
1888:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5889              		.loc 1 1888 0
 5890 3370 70408DE5 		str	r4, [sp, #112]
1891:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5891              		.loc 1 1891 0
 5892 3374 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5893              	.LVL486:
1892:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5894              		.loc 1 1892 0
 5895 3378 002050E2 		subs	r2, r0, #0
 5896 337c CF01001A 		bne	.L541
1905:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5897              		.loc 1 1905 0
 5898 3380 1800A0E3 		mov	r0, #24
 5899              	.LVL487:
 5900 3384 68108DE2 		add	r1, sp, #104
1900:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5901              		.loc 1 1900 0
 5902 3388 68208DE5 		str	r2, [sp, #104]
1901:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5903              		.loc 1 1901 0
 5904 338c 6C208DE5 		str	r2, [sp, #108]
1902:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5905              		.loc 1 1902 0
 5906 3390 70208DE5 		str	r2, [sp, #112]
1904:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5907              		.loc 1 1904 0
 5908 3394 7820CDE5 		strb	r2, [sp, #120]
1903:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5909              		.loc 1 1903 0
 5910 3398 74408DE5 		str	r4, [sp, #116]
1905:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5911              		.loc 1 1905 0
 5912 339c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5913              	.LVL488:
1906:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5914              		.loc 1 1906 0
 5915 33a0 002050E2 		subs	r2, r0, #0
 5916 33a4 AA01001A 		bne	.L542
1918:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5917              		.loc 1 1918 0
 5918 33a8 0400A0E1 		mov	r0, r4
 5919              	.LVL489:
 5920 33ac 7C108DE2 		add	r1, sp, #124
1915:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5921              		.loc 1 1915 0
 5922 33b0 84208DE5 		str	r2, [sp, #132]
1916:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5923              		.loc 1 1916 0
 5924 33b4 80208DE5 		str	r2, [sp, #128]
1913:../uvc.c      ****     pibclock.clkDiv      = 2;
 5925              		.loc 1 1913 0
 5926 33b8 BC57CDE1 		strh	r5, [sp, #124]	@ movhi
1914:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5927              		.loc 1 1914 0
 5928 33bc 8870CDE5 		strb	r7, [sp, #136]
1918:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5929              		.loc 1 1918 0
 5930 33c0 FEFFFFEB 		bl	CyU3PPibInit
 5931              	.LVL490:
1919:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5932              		.loc 1 1919 0
 5933 33c4 002050E2 		subs	r2, r0, #0
 5934 33c8 9801001A 		bne	.L543
1926:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5935              		.loc 1 1926 0
 5936 33cc 1C089FE5 		ldr	r0, .L558+24
 5937              	.LVL491:
 5938 33d0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5939              	.LVL492:
1934:../uvc.c      ****     SensorReset ();
 5940              		.loc 1 1934 0
 5941 33d4 FEFFFFEB 		bl	SensorReset
1935:../uvc.c      ****     CyU3PThreadSleep(5000);
 5942              		.loc 1 1935 0
 5943 33d8 14089FE5 		ldr	r0, .L558+28
 5944 33dc FEFFFFEB 		bl	_tx_thread_sleep
1939:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5945              		.loc 1 1939 0
 5946 33e0 FEFFFFEB 		bl	CyU3PUsbStart
 5947              	.LVL493:
1940:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5948              		.loc 1 1940 0
 5949 33e4 002050E2 		subs	r2, r0, #0
 5950 33e8 8701001A 		bne	.L544
1946:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5951              		.loc 1 1946 0
 5952 33ec 0010A0E3 		mov	r1, #0
 5953 33f0 00089FE5 		ldr	r0, .L558+32
 5954              	.LVL494:
 5955 33f4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5956              	.LVL495:
1949:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5957              		.loc 1 1949 0
 5958 33f8 FC079FE5 		ldr	r0, .L558+36
 5959 33fc FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1955:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5960              		.loc 1 1955 0
 5961 3400 0010A0E3 		mov	r1, #0
 5962 3404 F4279FE5 		ldr	r2, .L558+40
 5963 3408 0100A0E3 		mov	r0, #1
 5964 340c FEFFFFEB 		bl	CyU3PUsbSetDesc
1956:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5965              		.loc 1 1956 0
 5966 3410 0000A0E3 		mov	r0, #0
 5967 3414 0010A0E1 		mov	r1, r0
 5968 3418 E4279FE5 		ldr	r2, .L558+44
 5969 341c FEFFFFEB 		bl	CyU3PUsbSetDesc
1959:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5970              		.loc 1 1959 0
 5971 3420 0010A0E3 		mov	r1, #0
 5972 3424 DC279FE5 		ldr	r2, .L558+48
 5973 3428 0200A0E3 		mov	r0, #2
 5974 342c FEFFFFEB 		bl	CyU3PUsbSetDesc
1960:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5975              		.loc 1 1960 0
 5976 3430 0010A0E3 		mov	r1, #0
 5977 3434 D0279FE5 		ldr	r2, .L558+52
 5978 3438 0700A0E3 		mov	r0, #7
 5979 343c FEFFFFEB 		bl	CyU3PUsbSetDesc
1963:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5980              		.loc 1 1963 0
 5981 3440 0010A0E3 		mov	r1, #0
 5982 3444 C4279FE5 		ldr	r2, .L558+56
 5983 3448 0400A0E3 		mov	r0, #4
 5984 344c FEFFFFEB 		bl	CyU3PUsbSetDesc
1964:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5985              		.loc 1 1964 0
 5986 3450 0010A0E3 		mov	r1, #0
 5987 3454 B8279FE5 		ldr	r2, .L558+60
 5988 3458 0300A0E3 		mov	r0, #3
 5989 345c FEFFFFEB 		bl	CyU3PUsbSetDesc
1965:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5990              		.loc 1 1965 0
 5991 3460 0010A0E3 		mov	r1, #0
 5992 3464 AC279FE5 		ldr	r2, .L558+64
 5993 3468 0600A0E3 		mov	r0, #6
 5994 346c FEFFFFEB 		bl	CyU3PUsbSetDesc
1968:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5995              		.loc 1 1968 0
 5996 3470 0010A0E3 		mov	r1, #0
 5997 3474 A0279FE5 		ldr	r2, .L558+68
 5998 3478 0500A0E3 		mov	r0, #5
 5999 347c FEFFFFEB 		bl	CyU3PUsbSetDesc
1969:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6000              		.loc 1 1969 0
 6001 3480 0110A0E3 		mov	r1, #1
 6002 3484 94279FE5 		ldr	r2, .L558+72
 6003 3488 0500A0E3 		mov	r0, #5
 6004 348c FEFFFFEB 		bl	CyU3PUsbSetDesc
1970:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6005              		.loc 1 1970 0
 6006 3490 0210A0E3 		mov	r1, #2
 6007 3494 88279FE5 		ldr	r2, .L558+76
 6008 3498 0500A0E3 		mov	r0, #5
 6009 349c FEFFFFEB 		bl	CyU3PUsbSetDesc
1980:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6010              		.loc 1 1980 0
 6011 34a0 0070A0E3 		mov	r7, #0
1977:../uvc.c      ****     endPointConfig.enable   = 1;
 6012              		.loc 1 1977 0
 6013 34a4 0140A0E3 		mov	r4, #1
1978:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6014              		.loc 1 1978 0
 6015 34a8 03A0A0E3 		mov	sl, #3
1983:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6016              		.loc 1 1983 0
 6017 34ac 8200A0E3 		mov	r0, #130
 6018 34b0 A8108DE2 		add	r1, sp, #168
1979:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6019              		.loc 1 1979 0
 6020 34b4 4080A0E3 		mov	r8, #64	@ movhi
1978:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6021              		.loc 1 1978 0
 6022 34b8 ACA0CDE5 		strb	sl, [sp, #172]
1977:../uvc.c      ****     endPointConfig.enable   = 1;
 6023              		.loc 1 1977 0
 6024 34bc A8408DE5 		str	r4, [sp, #168]
1979:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6025              		.loc 1 1979 0
 6026 34c0 B08BCDE1 		strh	r8, [sp, #176]	@ movhi
1980:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6027              		.loc 1 1980 0
 6028 34c4 B370CDE5 		strb	r7, [sp, #179]
1981:../uvc.c      ****     endPointConfig.streams  = 0;
 6029              		.loc 1 1981 0
 6030 34c8 BE7ACDE1 		strh	r7, [sp, #174]	@ movhi
1982:../uvc.c      ****     endPointConfig.burstLen = 1;
 6031              		.loc 1 1982 0
 6032 34cc B240CDE5 		strb	r4, [sp, #178]
1983:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6033              		.loc 1 1983 0
 6034 34d0 FEFFFFEB 		bl	CyU3PSetEpConfig
 6035              	.LVL496:
1981:../uvc.c      ****     endPointConfig.streams  = 0;
 6036              		.loc 1 1981 0
 6037 34d4 07A0A0E1 		mov	sl, r7	@ movhi
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6038              		.loc 1 1984 0
 6039 34d8 003050E2 		subs	r3, r0, #0
 6040 34dc 4001001A 		bne	.L545
1994:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6041              		.loc 1 1994 0
 6042 34e0 40C79FE5 		ldr	ip, .L558+80
1995:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6043              		.loc 1 1995 0
 6044 34e4 40E79FE5 		ldr	lr, .L558+84
1992:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6045              		.loc 1 1992 0
 6046 34e8 015BA0E3 		mov	r5, #1024	@ movhi
2001:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6047              		.loc 1 2001 0
 6048 34ec 1070A0E3 		mov	r7, #16
2003:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6049              		.loc 1 2003 0
 6050 34f0 38079FE5 		ldr	r0, .L558+88
 6051              	.LVL497:
 6052 34f4 0410A0E3 		mov	r1, #4
 6053 34f8 34208DE2 		add	r2, sp, #52
1992:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6054              		.loc 1 1992 0
 6055 34fc B453CDE1 		strh	r5, [sp, #52]	@ movhi
1993:../uvc.c      ****     dmaInterConfig.count          = 1;
 6056              		.loc 1 1993 0
 6057 3500 B643CDE1 		strh	r4, [sp, #54]	@ movhi
1994:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6058              		.loc 1 1994 0
 6059 3504 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1995:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6060              		.loc 1 1995 0
 6061 3508 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1996:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6062              		.loc 1 1996 0
 6063 350c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1997:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6064              		.loc 1 1997 0
 6065 3510 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1998:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6066              		.loc 1 1998 0
 6067 3514 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1999:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6068              		.loc 1 1999 0
 6069 3518 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2000:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6070              		.loc 1 2000 0
 6071 351c 44A0CDE5 		strb	sl, [sp, #68]
2001:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6072              		.loc 1 2001 0
 6073 3520 48708DE5 		str	r7, [sp, #72]
2002:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6074              		.loc 1 2002 0
 6075 3524 4C308DE5 		str	r3, [sp, #76]
2003:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6076              		.loc 1 2003 0
 6077 3528 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6078              	.LVL498:
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6079              		.loc 1 2005 0
 6080 352c 005050E2 		subs	r5, r0, #0
 6081 3530 E400001A 		bne	.L546
2012:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6082              		.loc 1 2012 0
 6083 3534 010BA0E3 		mov	r0, #1024
 6084              	.LVL499:
 6085 3538 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6086 353c F0169FE5 		ldr	r1, .L558+92
2013:../uvc.c      ****     if (glInterStaBuffer == 0)
 6087              		.loc 1 2013 0
 6088 3540 000050E3 		cmp	r0, #0
2012:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6089              		.loc 1 2012 0
 6090 3544 000081E5 		str	r0, [r1, #0]
2013:../uvc.c      ****     if (glInterStaBuffer == 0)
 6091              		.loc 1 2013 0
 6092 3548 D500000A 		beq	.L547
2021:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6093              		.loc 1 2021 0
 6094 354c 0430A0E3 		mov	r3, #4	@ movhi
 6095 3550 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2025:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6096              		.loc 1 2025 0
 6097 3554 DC369FE5 		ldr	r3, .L558+96
2020:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6098              		.loc 1 2020 0
 6099 3558 01E9A0E3 		mov	lr, #16384	@ movhi
 6100 355c BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
2024:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6101              		.loc 1 2024 0
 6102 3560 D4E69FE5 		ldr	lr, .L558+100
2025:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6103              		.loc 1 2025 0
 6104 3564 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
2032:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6105              		.loc 1 2032 0
 6106 3568 D0369FE5 		ldr	r3, .L558+104
2023:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6107              		.loc 1 2023 0
 6108 356c 01CCA0E3 		mov	ip, #256	@ movhi
2033:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6109              		.loc 1 2033 0
 6110 3570 0C208DE2 		add	r2, sp, #12
2023:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6111              		.loc 1 2023 0
 6112 3574 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2024:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6113              		.loc 1 2024 0
 6114 3578 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
2027:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6115              		.loc 1 2027 0
 6116 357c 0CC0A0E3 		mov	ip, #12	@ movhi
2028:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6117              		.loc 1 2028 0
 6118 3580 04E0A0E3 		mov	lr, #4	@ movhi
2030:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6119              		.loc 1 2030 0
 6120 3584 2AA0CDE5 		strb	sl, [sp, #42]
2022:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6121              		.loc 1 2022 0
 6122 3588 0280A0E3 		mov	r8, #2	@ movhi
2033:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6123              		.loc 1 2033 0
 6124 358c B0069FE5 		ldr	r0, .L558+108
 6125 3590 0710A0E3 		mov	r1, #7
2031:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6126              		.loc 1 2031 0
 6127 3594 18A0A0E3 		mov	sl, #24
2022:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6128              		.loc 1 2022 0
 6129 3598 B081CDE1 		strh	r8, [sp, #16]	@ movhi
2026:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6130              		.loc 1 2026 0
 6131 359c B252CDE1 		strh	r5, [sp, #34]	@ movhi
2027:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6132              		.loc 1 2027 0
 6133 35a0 B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
2028:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6134              		.loc 1 2028 0
 6135 35a4 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
2029:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6136              		.loc 1 2029 0
 6137 35a8 B852CDE1 		strh	r5, [sp, #40]	@ movhi
2031:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6138              		.loc 1 2031 0
 6139 35ac 2CA08DE5 		str	sl, [sp, #44]
2032:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6140              		.loc 1 2032 0
 6141 35b0 30308DE5 		str	r3, [sp, #48]
2033:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6142              		.loc 1 2033 0
 6143 35b4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6144              	.LVL500:
2035:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6145              		.loc 1 2035 0
 6146 35b8 002050E2 		subs	r2, r0, #0
 6147 35bc AF00001A 		bne	.L548
2126:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6148              		.loc 1 2126 0
 6149 35c0 0400A0E1 		mov	r0, r4
 6150              	.LVL501:
 6151 35c4 0410A0E1 		mov	r1, r4
 6152 35c8 FEFFFFEB 		bl	CyU3PConnectState
 6153              	.LVL502:
2127:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6154              		.loc 1 2127 0
 6155 35cc 002050E2 		subs	r2, r0, #0
 6156 35d0 A100001A 		bne	.L549
2133:../uvc.c      ****     CyU3PBusyWait(100);
 6157              		.loc 1 2133 0
 6158 35d4 6400A0E3 		mov	r0, #100
 6159              	.LVL503:
 6160 35d8 FEFFFFEB 		bl	CyU3PBusyWait
 6161              	.LVL504:
2135:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6162              		.loc 1 2135 0
 6163 35dc FEFFFFEB 		bl	CyU3PUsbGetSpeed
2149:../uvc.c      ****     endPointConfig.streams  = 0;
 6164              		.loc 1 2149 0
 6165 35e0 0020A0E3 		mov	r2, #0	@ movhi
2138:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6166              		.loc 1 2138 0
 6167 35e4 AC80CDE5 		strb	r8, [sp, #172]
2150:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6168              		.loc 1 2150 0
 6169 35e8 A8108DE2 		add	r1, sp, #168
2149:../uvc.c      ****     endPointConfig.streams  = 0;
 6170              		.loc 1 2149 0
 6171 35ec BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2137:../uvc.c      ****     endPointConfig.enable   = 1;
 6172              		.loc 1 2137 0
 6173 35f0 A8408DE5 		str	r4, [sp, #168]
2139:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6174              		.loc 1 2139 0
 6175 35f4 030050E3 		cmp	r0, #3
2135:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6176              		.loc 1 2135 0
 6177 35f8 4800C6E5 		strb	r0, [r6, #72]
2146:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6178              		.loc 1 2146 0
 6179 35fc 020CA013 		movne	r0, #512	@ movhi
2141:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6180              		.loc 1 2141 0
 6181 3600 018BA003 		moveq	r8, #1024	@ movhi
2146:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6182              		.loc 1 2146 0
 6183 3604 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2150:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6184              		.loc 1 2150 0
 6185 3608 8300A0E3 		mov	r0, #131
2141:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6186              		.loc 1 2141 0
 6187 360c B08BCD01 		streqh	r8, [sp, #176]	@ movhi
2142:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6188              		.loc 1 2142 0
 6189 3610 B270CD05 		streqb	r7, [sp, #178]
2147:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6190              		.loc 1 2147 0
 6191 3614 B240CD15 		strneb	r4, [sp, #178]
2150:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6192              		.loc 1 2150 0
 6193 3618 FEFFFFEB 		bl	CyU3PSetEpConfig
 6194              	.LVL505:
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6195              		.loc 1 2151 0
 6196 361c 002050E2 		subs	r2, r0, #0
 6197 3620 4F00001A 		bne	.L532
 6198 3624 1C869FE5 		ldr	r8, .L558+112
 6199              	.LBE216:
 6200              	.LBE213:
2271:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6201              		.loc 1 2271 0
 6202 3628 BC559FE5 		ldr	r5, .L558+20
 6203 362c 0240A0E1 		mov	r4, r2
2342:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6204              		.loc 1 2342 0
 6205 3630 0870A0E1 		mov	r7, r8
 6206              	.LVL506:
 6207              	.L506:
2271:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6208              		.loc 1 2271 0
 6209 3634 B0059FE5 		ldr	r0, .L558+20
 6210 3638 0110A0E3 		mov	r1, #1
 6211 363c 0220A0E3 		mov	r2, #2
 6212 3640 B4308DE2 		add	r3, sp, #180
 6213 3644 00408DE5 		str	r4, [sp, #0]
 6214 3648 FEFFFFEB 		bl	_txe_event_flags_get
 6215 364c 000050E3 		cmp	r0, #0
 6216 3650 3000001A 		bne	.L508
2317:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6217              		.loc 1 2317 0
 6218 3654 301095E5 		ldr	r1, [r5, #48]
 6219 3658 000051E3 		cmp	r1, #0
 6220 365c 0300000A 		beq	.L509
2317:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6221              		.loc 1 2317 0 is_stmt 0 discriminator 1
 6222 3660 B4A3D5E1 		ldrh	sl, [r5, #52]
 6223 3664 B6C3D5E1 		ldrh	ip, [r5, #54]
 6224 3668 0C005AE1 		cmp	sl, ip
 6225 366c 1C01000A 		beq	.L550
 6226              	.L509:
2466:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6227              		.loc 1 2466 0 is_stmt 1
 6228 3670 4010A0E3 		mov	r1, #64
 6229 3674 0020A0E3 		mov	r2, #0
 6230 3678 6C059FE5 		ldr	r0, .L558+20
 6231 367c FEFFFFEB 		bl	_txe_event_flags_set
2469:../uvc.c      ****         CyU3PThreadRelinquish ();
 6232              		.loc 1 2469 0
 6233 3680 FEFFFFEB 		bl	_txe_thread_relinquish
2470:../uvc.c      ****     }
 6234              		.loc 1 2470 0
 6235 3684 EAFFFFEA 		b	.L506
 6236              	.LVL507:
 6237              	.L535:
 6238              	.LBB251:
 6239              	.LBB215:
1824:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6240              		.loc 1 1824 0
 6241 3688 0400A0E3 		mov	r0, #4
 6242              	.LVL508:
 6243 368c B8159FE5 		ldr	r1, .L558+116
 6244 3690 FEFFFFEB 		bl	CyU3PDebugPrint
 6245              	.LVL509:
 6246              	.L475:
 6247              	.LBB231:
 6248              	.LBB232:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6249              		.loc 1 1273 0
 6250 3694 B4159FE5 		ldr	r1, .L558+120
 6251 3698 0400A0E3 		mov	r0, #4
 6252 369c FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6253              		.loc 1 1274 0
 6254 36a0 FA0FA0E3 		mov	r0, #1000
 6255 36a4 FEFFFFEB 		bl	_tx_thread_sleep
 6256 36a8 F9FFFFEA 		b	.L475
 6257              	.LVL510:
 6258              	.L537:
 6259              	.LBE232:
 6260              	.LBE231:
1855:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6261              		.loc 1 1855 0
 6262 36ac 0400A0E3 		mov	r0, #4
 6263              	.LVL511:
 6264 36b0 9C159FE5 		ldr	r1, .L558+124
 6265 36b4 FEFFFFEB 		bl	CyU3PDebugPrint
 6266              	.LVL512:
 6267              	.L479:
 6268              	.LBB229:
 6269              	.LBB230:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6270              		.loc 1 1273 0
 6271 36b8 90159FE5 		ldr	r1, .L558+120
 6272 36bc 0400A0E3 		mov	r0, #4
 6273 36c0 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6274              		.loc 1 1274 0
 6275 36c4 FA0FA0E3 		mov	r0, #1000
 6276 36c8 FEFFFFEB 		bl	_tx_thread_sleep
 6277 36cc F9FFFFEA 		b	.L479
 6278              	.LVL513:
 6279              	.L536:
 6280              	.LBE230:
 6281              	.LBE229:
1846:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6282              		.loc 1 1846 0
 6283 36d0 0400A0E3 		mov	r0, #4
 6284              	.LVL514:
 6285 36d4 7C159FE5 		ldr	r1, .L558+128
 6286 36d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6287              	.LVL515:
 6288              	.L477:
 6289              	.LBB227:
 6290              	.LBB228:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6291              		.loc 1 1273 0
 6292 36dc 6C159FE5 		ldr	r1, .L558+120
 6293 36e0 0400A0E3 		mov	r0, #4
 6294 36e4 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6295              		.loc 1 1274 0
 6296 36e8 FA0FA0E3 		mov	r0, #1000
 6297 36ec FEFFFFEB 		bl	_tx_thread_sleep
 6298 36f0 F9FFFFEA 		b	.L477
 6299              	.LVL516:
 6300              	.L538:
 6301              	.LBE228:
 6302              	.LBE227:
1861:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6303              		.loc 1 1861 0
 6304 36f4 0400A0E3 		mov	r0, #4
 6305              	.LVL517:
 6306 36f8 5C159FE5 		ldr	r1, .L558+132
 6307 36fc FEFFFFEB 		bl	CyU3PDebugPrint
 6308              	.LVL518:
 6309              	.L481:
 6310              	.LBB225:
 6311              	.LBB226:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6312              		.loc 1 1273 0
 6313 3700 48159FE5 		ldr	r1, .L558+120
 6314 3704 0400A0E3 		mov	r0, #4
 6315 3708 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6316              		.loc 1 1274 0
 6317 370c FA0FA0E3 		mov	r0, #1000
 6318 3710 FEFFFFEB 		bl	_tx_thread_sleep
 6319 3714 F9FFFFEA 		b	.L481
 6320              	.LVL519:
 6321              	.L508:
 6322              	.LBE226:
 6323              	.LBE225:
 6324              	.LBE215:
 6325              	.LBE251:
2376:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6326              		.loc 1 2376 0
 6327 3718 CC049FE5 		ldr	r0, .L558+20
 6328 371c 0210A0E3 		mov	r1, #2
 6329 3720 0320A0E3 		mov	r2, #3
 6330 3724 B4308DE2 		add	r3, sp, #180
 6331 3728 00408DE5 		str	r4, [sp, #0]
 6332 372c FEFFFFEB 		bl	_txe_event_flags_get
 6333 3730 000050E3 		cmp	r0, #0
 6334 3734 2500001A 		bne	.L516
2391:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6335              		.loc 1 2391 0
 6336 3738 441095E5 		ldr	r1, [r5, #68]
2379:../uvc.c      ****                 hitFV     = CyFalse;
 6337              		.loc 1 2379 0
 6338 373c 304085E5 		str	r4, [r5, #48]
2391:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6339              		.loc 1 2391 0
 6340 3740 000051E3 		cmp	r1, #0
2380:../uvc.c      ****                 prodCount = 0;
 6341              		.loc 1 2380 0
 6342 3744 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2387:../uvc.c      ****                 fb=0;
 6343              		.loc 1 2387 0
 6344 3748 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2381:../uvc.c      ****                 consCount = 0;
 6345              		.loc 1 2381 0
 6346 374c B643C5E1 		strh	r4, [r5, #54]	@ movhi
2388:../uvc.c      ****                 pb=0;
 6347              		.loc 1 2388 0
 6348 3750 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2389:../uvc.c      ****                 pbc=0;
 6349              		.loc 1 2389 0
 6350 3754 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2391:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6351              		.loc 1 2391 0
 6352 3758 0A00000A 		beq	.L551
 6353              	.L517:
2403:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6354              		.loc 1 2403 0
 6355 375c 444086E5 		str	r4, [r6, #68]
 6356 3760 C2FFFFEA 		b	.L509
 6357              	.LVL520:
 6358              	.L532:
 6359              	.LBB252:
 6360              	.LBB249:
2154:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6361              		.loc 1 2154 0
 6362 3764 0400A0E3 		mov	r0, #4
 6363              	.LVL521:
 6364 3768 F0149FE5 		ldr	r1, .L558+136
 6365 376c FEFFFFEB 		bl	CyU3PDebugPrint
 6366              	.LVL522:
 6367              	.L507:
 6368              	.LBB233:
 6369              	.LBB234:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6370              		.loc 1 1273 0
 6371 3770 D8149FE5 		ldr	r1, .L558+120
 6372 3774 0400A0E3 		mov	r0, #4
 6373 3778 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6374              		.loc 1 1274 0
 6375 377c FA0FA0E3 		mov	r0, #1000
 6376 3780 FEFFFFEB 		bl	_tx_thread_sleep
 6377 3784 F9FFFFEA 		b	.L507
 6378              	.LVL523:
 6379              	.L551:
 6380              	.LBE234:
 6381              	.LBE233:
 6382              	.LBE249:
 6383              	.LBE252:
2393:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6384              		.loc 1 2393 0
 6385 3788 B4049FE5 		ldr	r0, .L558+108
 6386 378c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6387              	.LVL524:
2394:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6388              		.loc 1 2394 0
 6389 3790 000050E3 		cmp	r0, #0
 6390 3794 0200001A 		bne	.L533
2400:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6391              		.loc 1 2400 0
 6392 3798 8300A0E3 		mov	r0, #131
 6393              	.LVL525:
 6394 379c FEFFFFEB 		bl	CyU3PUsbFlushEp
 6395 37a0 EDFFFFEA 		b	.L517
 6396              	.L533:
 6397              	.LBB253:
 6398              	.LBB254:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6399              		.loc 1 1273 0
 6400 37a4 A4149FE5 		ldr	r1, .L558+120
 6401 37a8 0400A0E3 		mov	r0, #4
 6402 37ac FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6403              		.loc 1 1274 0
 6404 37b0 FA0FA0E3 		mov	r0, #1000
 6405 37b4 FEFFFFEB 		bl	_tx_thread_sleep
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6406              		.loc 1 1273 0
 6407 37b8 90149FE5 		ldr	r1, .L558+120
 6408 37bc 0400A0E3 		mov	r0, #4
 6409 37c0 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6410              		.loc 1 1274 0
 6411 37c4 FA0FA0E3 		mov	r0, #1000
 6412 37c8 FEFFFFEB 		bl	_tx_thread_sleep
 6413 37cc F4FFFFEA 		b	.L533
 6414              	.L516:
 6415              	.LBE254:
 6416              	.LBE253:
2408:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6417              		.loc 1 2408 0
 6418 37d0 00C0E0E3 		mvn	ip, #0
 6419 37d4 0110A0E3 		mov	r1, #1
 6420 37d8 0220A0E3 		mov	r2, #2
 6421 37dc B4308DE2 		add	r3, sp, #180
 6422 37e0 04049FE5 		ldr	r0, .L558+20
 6423 37e4 00C08DE5 		str	ip, [sp, #0]
 6424 37e8 FEFFFFEB 		bl	_txe_event_flags_get
2412:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6425              		.loc 1 2412 0
 6426 37ec 0420A0E1 		mov	r2, r4
 6427 37f0 4C049FE5 		ldr	r0, .L558+108
 6428 37f4 0410A0E1 		mov	r1, r4
 6429 37f8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6430              	.LVL526:
2413:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6431              		.loc 1 2413 0
 6432 37fc 002050E2 		subs	r2, r0, #0
 6433 3800 6E00001A 		bne	.L552
2421:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6434              		.loc 1 2421 0
 6435 3804 3C3095E5 		ldr	r3, [r5, #60]
 6436 3808 000053E3 		cmp	r3, #0
 6437 380c 6300001A 		bne	.L522
2450:../uvc.c      ****                     CyU3PThreadSleep(1000);
 6438              		.loc 1 2450 0
 6439 3810 FA0FA0E3 		mov	r0, #1000
 6440              	.LVL527:
 6441 3814 FEFFFFEB 		bl	_tx_thread_sleep
 6442              	.LVL528:
2451:../uvc.c      ****                     SensorSetIrisControl(0x1, 0x30, 0x20, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
 6443              		.loc 1 2451 0
 6444 3818 5230A0E3 		mov	r3, #82
 6445 381c 3010A0E3 		mov	r1, #48
 6446 3820 2020A0E3 		mov	r2, #32
 6447 3824 0100A0E3 		mov	r0, #1
 6448 3828 FEFFFFEB 		bl	SensorSetIrisControl
2452:../uvc.c      ****                     CyU3PThreadSleep(1000);
 6449              		.loc 1 2452 0
 6450 382c FA0FA0E3 		mov	r0, #1000
 6451 3830 FEFFFFEB 		bl	_tx_thread_sleep
 6452              	.LVL529:
 6453              	.LBB255:
 6454              	.LBB256:
2179:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6455              		.loc 1 2179 0
 6456 3834 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6457 3838 030053E3 		cmp	r3, #3
 6458 383c 4700000A 		beq	.L553
2184:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6459              		.loc 1 2184 0
 6460 3840 020053E3 		cmp	r3, #2
 6461 3844 2900000A 		beq	.L554
 6462              	.LVL530:
 6463              	.L525:
 6464              	.LBE256:
 6465              	.LBE255:
2454:../uvc.c      ****                     gpif_initialized = CyTrue;
 6466              		.loc 1 2454 0
 6467 3848 01E0A0E3 		mov	lr, #1
 6468 384c 3CE086E5 		str	lr, [r6, #60]
2455:../uvc.c      ****                     CyU3PThreadSleep(200);
 6469              		.loc 1 2455 0
 6470 3850 C800A0E3 		mov	r0, #200
 6471 3854 FEFFFFEB 		bl	_tx_thread_sleep
 6472 3858 84FFFFEA 		b	.L509
 6473              	.LVL531:
 6474              	.L549:
 6475              	.LBB262:
 6476              	.LBB214:
2129:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6477              		.loc 1 2129 0
 6478 385c 0400A0E3 		mov	r0, #4
 6479              	.LVL532:
 6480 3860 FC139FE5 		ldr	r1, .L558+140
 6481 3864 FEFFFFEB 		bl	CyU3PDebugPrint
 6482              	.LVL533:
 6483              	.L503:
 6484              	.LBB223:
 6485              	.LBB224:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6486              		.loc 1 1273 0
 6487 3868 E0139FE5 		ldr	r1, .L558+120
 6488 386c 0400A0E3 		mov	r0, #4
 6489 3870 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6490              		.loc 1 1274 0
 6491 3874 FA0FA0E3 		mov	r0, #1000
 6492 3878 FEFFFFEB 		bl	_tx_thread_sleep
 6493 387c F9FFFFEA 		b	.L503
 6494              	.LVL534:
 6495              	.L548:
 6496              	.LBE224:
 6497              	.LBE223:
2038:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6498              		.loc 1 2038 0
 6499 3880 0400A0E3 		mov	r0, #4
 6500              	.LVL535:
 6501 3884 DC139FE5 		ldr	r1, .L558+144
 6502 3888 FEFFFFEB 		bl	CyU3PDebugPrint
 6503              	.LVL536:
 6504              	.L501:
 6505              	.LBB221:
 6506              	.LBB222:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6507              		.loc 1 1273 0
 6508 388c BC139FE5 		ldr	r1, .L558+120
 6509 3890 0400A0E3 		mov	r0, #4
 6510 3894 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6511              		.loc 1 1274 0
 6512 3898 FA0FA0E3 		mov	r0, #1000
 6513 389c FEFFFFEB 		bl	_tx_thread_sleep
 6514 38a0 F9FFFFEA 		b	.L501
 6515              	.LVL537:
 6516              	.L547:
 6517              	.LBE222:
 6518              	.LBE221:
2015:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6519              		.loc 1 2015 0
 6520 38a4 040080E2 		add	r0, r0, #4
 6521 38a8 BC139FE5 		ldr	r1, .L558+148
 6522 38ac FEFFFFEB 		bl	CyU3PDebugPrint
 6523              	.LVL538:
 6524              	.L499:
 6525              	.LBB219:
 6526              	.LBB220:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6527              		.loc 1 1273 0
 6528 38b0 98139FE5 		ldr	r1, .L558+120
 6529 38b4 0400A0E3 		mov	r0, #4
 6530 38b8 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6531              		.loc 1 1274 0
 6532 38bc FA0FA0E3 		mov	r0, #1000
 6533 38c0 FEFFFFEB 		bl	_tx_thread_sleep
 6534 38c4 F9FFFFEA 		b	.L499
 6535              	.LVL539:
 6536              	.L546:
 6537              	.LBE220:
 6538              	.LBE219:
2008:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6539              		.loc 1 2008 0
 6540 38c8 0400A0E3 		mov	r0, #4
 6541 38cc 9C139FE5 		ldr	r1, .L558+152
 6542 38d0 0520A0E1 		mov	r2, r5
 6543 38d4 FEFFFFEB 		bl	CyU3PDebugPrint
 6544              	.L497:
 6545              	.LBB217:
 6546              	.LBB218:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6547              		.loc 1 1273 0
 6548 38d8 70139FE5 		ldr	r1, .L558+120
 6549 38dc 0400A0E3 		mov	r0, #4
 6550 38e0 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6551              		.loc 1 1274 0
 6552 38e4 FA0FA0E3 		mov	r0, #1000
 6553 38e8 FEFFFFEB 		bl	_tx_thread_sleep
 6554 38ec F9FFFFEA 		b	.L497
 6555              	.LVL540:
 6556              	.L554:
 6557              	.LBE218:
 6558              	.LBE217:
 6559              	.LBE214:
 6560              	.LBE262:
 6561              	.LBB263:
 6562              	.LBB261:
2186:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6563              		.loc 1 2186 0
 6564 38f0 7C139FE5 		ldr	r1, .L558+156
 6565 38f4 0100A0E3 		mov	r0, #1
 6566 38f8 FEFFFFEB 		bl	CyU3PDebugPrint
2187:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6567              		.loc 1 2187 0
 6568 38fc 74039FE5 		ldr	r0, .L558+160
 6569 3900 FEFFFFEB 		bl	CyU3PGpifLoad
 6570 3904 0020A0E1 		mov	r2, r0
 6571              	.LVL541:
 6572              	.L524:
2189:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6573              		.loc 1 2189 0
 6574 3908 000052E3 		cmp	r2, #0
 6575 390c 1A00001A 		bne	.L555
2197:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6576              		.loc 1 2197 0
 6577 3910 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6578 3914 030053E3 		cmp	r3, #3
 6579 3918 0100000A 		beq	.L534
2201:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6580              		.loc 1 2201 0
 6581 391c 020053E3 		cmp	r3, #2
 6582 3920 C8FFFF1A 		bne	.L525
 6583              	.L534:
2203:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6584              		.loc 1 2203 0
 6585 3924 0200A0E1 		mov	r0, r2
 6586              	.LVL542:
 6587 3928 0210A0E1 		mov	r1, r2
 6588 392c FEFFFFEB 		bl	CyU3PGpifSMStart
 6589              	.LVL543:
2205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6590              		.loc 1 2205 0
 6591 3930 000050E3 		cmp	r0, #0
2203:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6592              		.loc 1 2203 0
 6593 3934 0020A0E1 		mov	r2, r0
 6594              	.LVL544:
2205:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6595              		.loc 1 2205 0
 6596 3938 C2FFFF0A 		beq	.L525
2208:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6597              		.loc 1 2208 0
 6598 393c 0400A0E3 		mov	r0, #4
 6599              	.LVL545:
 6600 3940 34139FE5 		ldr	r1, .L558+164
 6601 3944 FEFFFFEB 		bl	CyU3PDebugPrint
 6602              	.LVL546:
 6603              	.L530:
 6604              	.LBB257:
 6605              	.LBB258:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6606              		.loc 1 1273 0
 6607 3948 00139FE5 		ldr	r1, .L558+120
 6608 394c 0400A0E3 		mov	r0, #4
 6609 3950 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6610              		.loc 1 1274 0
 6611 3954 FA0FA0E3 		mov	r0, #1000
 6612 3958 FEFFFFEB 		bl	_tx_thread_sleep
 6613 395c F9FFFFEA 		b	.L530
 6614              	.LVL547:
 6615              	.L553:
 6616              	.LBE258:
 6617              	.LBE257:
2181:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6618              		.loc 1 2181 0
 6619 3960 18139FE5 		ldr	r1, .L558+168
 6620 3964 0100A0E3 		mov	r0, #1
 6621 3968 FEFFFFEB 		bl	CyU3PDebugPrint
2182:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6622              		.loc 1 2182 0
 6623 396c 10039FE5 		ldr	r0, .L558+172
 6624 3970 FEFFFFEB 		bl	CyU3PGpifLoad
 6625 3974 0020A0E1 		mov	r2, r0
 6626              	.LVL548:
 6627 3978 E2FFFFEA 		b	.L524
 6628              	.L555:
2192:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6629              		.loc 1 2192 0
 6630 397c 0400A0E3 		mov	r0, #4
 6631              	.LVL549:
 6632 3980 00139FE5 		ldr	r1, .L558+176
 6633 3984 FEFFFFEB 		bl	CyU3PDebugPrint
 6634              	.LVL550:
 6635              	.L527:
 6636              	.LBB259:
 6637              	.LBB260:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6638              		.loc 1 1273 0
 6639 3988 C0129FE5 		ldr	r1, .L558+120
 6640 398c 0400A0E3 		mov	r0, #4
 6641 3990 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6642              		.loc 1 1274 0
 6643 3994 FA0FA0E3 		mov	r0, #1000
 6644 3998 FEFFFFEB 		bl	_tx_thread_sleep
 6645 399c F9FFFFEA 		b	.L527
 6646              	.LVL551:
 6647              	.L522:
 6648              	.LBE260:
 6649              	.LBE259:
 6650              	.LBE261:
 6651              	.LBE263:
2462:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6652              		.loc 1 2462 0
 6653 39a0 94029FE5 		ldr	r0, .L558+100
 6654              	.LVL552:
 6655 39a4 02A0A0E3 		mov	sl, #2
 6656 39a8 0410A0E1 		mov	r1, r4
 6657 39ac 0020A0E1 		mov	r2, r0
 6658              	.LVL553:
 6659 39b0 0430A0E1 		mov	r3, r4
 6660 39b4 00A08DE5 		str	sl, [sp, #0]
 6661 39b8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6662 39bc 2BFFFFEA 		b	.L509
 6663              	.LVL554:
 6664              	.L552:
2416:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6665              		.loc 1 2416 0
 6666 39c0 0400A0E3 		mov	r0, #4
 6667              	.LVL555:
 6668 39c4 C0129FE5 		ldr	r1, .L558+180
 6669 39c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6670              	.LVL556:
 6671              	.L521:
 6672              	.LBB264:
 6673              	.LBB265:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6674              		.loc 1 1273 0
 6675 39cc 7C129FE5 		ldr	r1, .L558+120
 6676 39d0 0400A0E3 		mov	r0, #4
 6677 39d4 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6678              		.loc 1 1274 0
 6679 39d8 FA0FA0E3 		mov	r0, #1000
 6680 39dc FEFFFFEB 		bl	_tx_thread_sleep
 6681 39e0 F9FFFFEA 		b	.L521
 6682              	.LVL557:
 6683              	.L545:
 6684              	.LBE265:
 6685              	.LBE264:
 6686              	.LBB266:
 6687              	.LBB250:
1987:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6688              		.loc 1 1987 0
 6689 39e4 0400A0E3 		mov	r0, #4
 6690              	.LVL558:
 6691 39e8 70129FE5 		ldr	r1, .L558+136
 6692 39ec 0320A0E1 		mov	r2, r3
 6693 39f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6694              	.LVL559:
 6695              	.L495:
 6696              	.LBB235:
 6697              	.LBB236:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6698              		.loc 1 1273 0
 6699 39f4 54129FE5 		ldr	r1, .L558+120
 6700 39f8 0400A0E3 		mov	r0, #4
 6701 39fc FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6702              		.loc 1 1274 0
 6703 3a00 FA0FA0E3 		mov	r0, #1000
 6704 3a04 FEFFFFEB 		bl	_tx_thread_sleep
 6705 3a08 F9FFFFEA 		b	.L495
 6706              	.LVL560:
 6707              	.L544:
 6708              	.LBE236:
 6709              	.LBE235:
1942:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6710              		.loc 1 1942 0
 6711 3a0c 0400A0E3 		mov	r0, #4
 6712              	.LVL561:
 6713 3a10 78129FE5 		ldr	r1, .L558+184
 6714 3a14 FEFFFFEB 		bl	CyU3PDebugPrint
 6715              	.LVL562:
 6716              	.L493:
 6717              	.LBB237:
 6718              	.LBB238:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6719              		.loc 1 1273 0
 6720 3a18 30129FE5 		ldr	r1, .L558+120
 6721 3a1c 0400A0E3 		mov	r0, #4
 6722 3a20 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6723              		.loc 1 1274 0
 6724 3a24 FA0FA0E3 		mov	r0, #1000
 6725 3a28 FEFFFFEB 		bl	_tx_thread_sleep
 6726 3a2c F9FFFFEA 		b	.L493
 6727              	.LVL563:
 6728              	.L543:
 6729              	.LBE238:
 6730              	.LBE237:
1921:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6731              		.loc 1 1921 0
 6732 3a30 0400A0E3 		mov	r0, #4
 6733              	.LVL564:
 6734 3a34 58129FE5 		ldr	r1, .L558+188
 6735 3a38 FEFFFFEB 		bl	CyU3PDebugPrint
 6736              	.LVL565:
 6737              	.L491:
 6738              	.LBB239:
 6739              	.LBB240:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6740              		.loc 1 1273 0
 6741 3a3c 0C129FE5 		ldr	r1, .L558+120
 6742 3a40 0400A0E3 		mov	r0, #4
 6743 3a44 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6744              		.loc 1 1274 0
 6745 3a48 FA0FA0E3 		mov	r0, #1000
 6746 3a4c FEFFFFEB 		bl	_tx_thread_sleep
 6747 3a50 F9FFFFEA 		b	.L491
 6748              	.LVL566:
 6749              	.L542:
 6750              	.LBE240:
 6751              	.LBE239:
1908:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6752              		.loc 1 1908 0
 6753 3a54 0400A0E3 		mov	r0, #4
 6754              	.LVL567:
 6755 3a58 38129FE5 		ldr	r1, .L558+192
 6756 3a5c FEFFFFEB 		bl	CyU3PDebugPrint
 6757              	.LVL568:
 6758              	.L489:
 6759              	.LBB241:
 6760              	.LBB242:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6761              		.loc 1 1273 0
 6762 3a60 E8119FE5 		ldr	r1, .L558+120
 6763 3a64 0400A0E3 		mov	r0, #4
 6764 3a68 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6765              		.loc 1 1274 0
 6766 3a6c FA0FA0E3 		mov	r0, #1000
 6767 3a70 FEFFFFEB 		bl	_tx_thread_sleep
 6768 3a74 F9FFFFEA 		b	.L489
 6769              	.LVL569:
 6770              	.L540:
 6771              	.LBE242:
 6772              	.LBE241:
1880:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6773              		.loc 1 1880 0
 6774 3a78 0400A0E3 		mov	r0, #4
 6775              	.LVL570:
 6776 3a7c 18129FE5 		ldr	r1, .L558+196
 6777 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
 6778              	.LVL571:
 6779              	.L485:
 6780              	.LBB243:
 6781              	.LBB244:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6782              		.loc 1 1273 0
 6783 3a84 C4119FE5 		ldr	r1, .L558+120
 6784 3a88 0400A0E3 		mov	r0, #4
 6785 3a8c FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6786              		.loc 1 1274 0
 6787 3a90 FA0FA0E3 		mov	r0, #1000
 6788 3a94 FEFFFFEB 		bl	_tx_thread_sleep
 6789 3a98 F9FFFFEA 		b	.L485
 6790              	.LVL572:
 6791              	.L539:
 6792              	.LBE244:
 6793              	.LBE243:
1867:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6794              		.loc 1 1867 0
 6795 3a9c 0400A0E3 		mov	r0, #4
 6796              	.LVL573:
 6797 3aa0 F8119FE5 		ldr	r1, .L558+200
 6798 3aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 6799              	.LVL574:
 6800              	.L483:
 6801              	.LBB245:
 6802              	.LBB246:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6803              		.loc 1 1273 0
 6804 3aa8 A0119FE5 		ldr	r1, .L558+120
 6805 3aac 0400A0E3 		mov	r0, #4
 6806 3ab0 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6807              		.loc 1 1274 0
 6808 3ab4 FA0FA0E3 		mov	r0, #1000
 6809 3ab8 FEFFFFEB 		bl	_tx_thread_sleep
 6810 3abc F9FFFFEA 		b	.L483
 6811              	.LVL575:
 6812              	.L541:
 6813              	.LBE246:
 6814              	.LBE245:
1894:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6815              		.loc 1 1894 0
 6816 3ac0 0400A0E3 		mov	r0, #4
 6817              	.LVL576:
 6818 3ac4 D8119FE5 		ldr	r1, .L558+204
 6819 3ac8 FEFFFFEB 		bl	CyU3PDebugPrint
 6820              	.LVL577:
 6821              	.L487:
 6822              	.LBB247:
 6823              	.LBB248:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6824              		.loc 1 1273 0
 6825 3acc 7C119FE5 		ldr	r1, .L558+120
 6826 3ad0 0400A0E3 		mov	r0, #4
 6827 3ad4 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6828              		.loc 1 1274 0
 6829 3ad8 FA0FA0E3 		mov	r0, #1000
 6830 3adc FEFFFFEB 		bl	_tx_thread_sleep
 6831 3ae0 F9FFFFEA 		b	.L487
 6832              	.LVL578:
 6833              	.L550:
 6834              	.LBE248:
 6835              	.LBE247:
 6836              	.LBE250:
 6837              	.LBE266:
2327:../uvc.c      ****                 prodCount = 0;
 6838              		.loc 1 2327 0
 6839 3ae4 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2328:../uvc.c      ****                 consCount = 0;
 6840              		.loc 1 2328 0
 6841 3ae8 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2329:../uvc.c      ****                 hitFV     = CyFalse;
 6842              		.loc 1 2329 0
 6843 3aec 304085E5 		str	r4, [r5, #48]
2342:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6844              		.loc 1 2342 0
 6845 3af0 8124D8E5 		ldrb	r2, [r8, #1153]	@ zero_extendqisi2
2324:../uvc.c      ****             	fb=0;
 6846              		.loc 1 2324 0
 6847 3af4 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2342:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6848              		.loc 1 2342 0
 6849 3af8 01E022E2 		eor	lr, r2, #1
 6850 3afc 81E4C8E5 		strb	lr, [r8, #1153]
2343:../uvc.c      ****                 if(stiflag){
 6851              		.loc 1 2343 0
 6852 3b00 9C3095E5 		ldr	r3, [r5, #156]
2325:../uvc.c      ****             	pb=0;
 6853              		.loc 1 2325 0
 6854 3b04 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2343:../uvc.c      ****                 if(stiflag){
 6855              		.loc 1 2343 0
 6856 3b08 000053E3 		cmp	r3, #0
2350:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6857              		.loc 1 2350 0
 6858 3b0c 8134D705 		ldreqb	r3, [r7, #1153]	@ zero_extendqisi2
2326:../uvc.c      ****             	pbc=0;
 6859              		.loc 1 2326 0
 6860 3b10 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2350:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6861              		.loc 1 2350 0
 6862 3b14 DF300302 		andeq	r3, r3, #223
 6863 3b18 8134C705 		streqb	r3, [r7, #1153]
2343:../uvc.c      ****                 if(stiflag){
 6864              		.loc 1 2343 0
 6865 3b1c 0A00000A 		beq	.L511
2344:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
 6866              		.loc 1 2344 0
 6867 3b20 C4009FE5 		ldr	r0, .L558+20
 6868 3b24 8010A0E3 		mov	r1, #128
 6869 3b28 0320A0E3 		mov	r2, #3
 6870 3b2c B4308DE2 		add	r3, sp, #180
 6871 3b30 00408DE5 		str	r4, [sp, #0]
 6872 3b34 FEFFFFEB 		bl	_txe_event_flags_get
 6873 3b38 000050E3 		cmp	r0, #0
2346:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
 6874              		.loc 1 2346 0
 6875 3b3c 8104D705 		ldreqb	r0, [r7, #1153]	@ zero_extendqisi2
 6876 3b40 20008003 		orreq	r0, r0, #32
 6877 3b44 8104C705 		streqb	r0, [r7, #1153]
2347:../uvc.c      ****                 		stiflag = CyFalse;
 6878              		.loc 1 2347 0
 6879 3b48 9C408505 		streq	r4, [r5, #156]
 6880              	.L511:
2353:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6881              		.loc 1 2353 0
 6882 3b4c F0009FE5 		ldr	r0, .L558+108
 6883 3b50 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6884              	.LVL579:
2354:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6885              		.loc 1 2354 0
 6886 3b54 002050E2 		subs	r2, r0, #0
 6887 3b58 0C00001A 		bne	.L556
2361:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6888              		.loc 1 2361 0
 6889 3b5c 0210A0E1 		mov	r1, r2
 6890 3b60 DC009FE5 		ldr	r0, .L558+108
 6891              	.LVL580:
 6892 3b64 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6893              	.LVL581:
2362:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6894              		.loc 1 2362 0
 6895 3b68 002050E2 		subs	r2, r0, #0
 6896 3b6c 1000001A 		bne	.L557
2370:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6897              		.loc 1 2370 0
 6898 3b70 C4009FE5 		ldr	r0, .L558+100
 6899              	.LVL582:
 6900 3b74 0210A0E1 		mov	r1, r2
 6901 3b78 02A0A0E3 		mov	sl, #2
 6902 3b7c 0020A0E1 		mov	r2, r0
 6903              	.LVL583:
 6904 3b80 0130A0E1 		mov	r3, r1
 6905 3b84 00A08DE5 		str	sl, [sp, #0]
 6906 3b88 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6907              	.LVL584:
 6908 3b8c B7FEFFEA 		b	.L509
 6909              	.LVL585:
 6910              	.L556:
2356:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6911              		.loc 1 2356 0
 6912 3b90 0400A0E3 		mov	r0, #4
 6913              	.LVL586:
 6914 3b94 0C119FE5 		ldr	r1, .L558+208
 6915 3b98 FEFFFFEB 		bl	CyU3PDebugPrint
 6916              	.LVL587:
 6917              	.L513:
 6918              	.LBB267:
 6919              	.LBB268:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6920              		.loc 1 1273 0
 6921 3b9c AC109FE5 		ldr	r1, .L558+120
 6922 3ba0 0400A0E3 		mov	r0, #4
 6923 3ba4 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6924              		.loc 1 1274 0
 6925 3ba8 FA0FA0E3 		mov	r0, #1000
 6926 3bac FEFFFFEB 		bl	_tx_thread_sleep
 6927 3bb0 F9FFFFEA 		b	.L513
 6928              	.LVL588:
 6929              	.L557:
 6930              	.LBE268:
 6931              	.LBE267:
2364:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6932              		.loc 1 2364 0
 6933 3bb4 0400A0E3 		mov	r0, #4
 6934              	.LVL589:
 6935 3bb8 EC109FE5 		ldr	r1, .L558+212
 6936 3bbc FEFFFFEB 		bl	CyU3PDebugPrint
 6937              	.LVL590:
 6938              	.L515:
 6939              	.LBB269:
 6940              	.LBB270:
1273:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6941              		.loc 1 1273 0
 6942 3bc0 88109FE5 		ldr	r1, .L558+120
 6943 3bc4 0400A0E3 		mov	r0, #4
 6944 3bc8 FEFFFFEB 		bl	CyU3PDebugPrint
1274:../uvc.c      ****         CyU3PThreadSleep (1000);
 6945              		.loc 1 1274 0
 6946 3bcc FA0FA0E3 		mov	r0, #1000
 6947 3bd0 FEFFFFEB 		bl	_tx_thread_sleep
 6948 3bd4 F9FFFFEA 		b	.L515
 6949              	.L559:
 6950              		.align	2
 6951              	.L558:
 6952 3bd8 18060000 		.word	.LC33
 6953 3bdc 00C20100 		.word	115200
 6954 3be0 38060000 		.word	.LC34
 6955 3be4 A0860100 		.word	100000
 6956 3be8 54060000 		.word	.LC35
 6957 3bec 00000000 		.word	.LANCHOR0
 6958 3bf0 00000000 		.word	CyFxGpifCB
 6959 3bf4 88130000 		.word	5000
 6960 3bf8 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6961 3bfc 00000000 		.word	CyFxUVCApplnUSBEventCB
 6962 3c00 00000000 		.word	CyFxUSBDeviceDscr
 6963 3c04 00000000 		.word	CyFxUSBDeviceDscrSS
 6964 3c08 00000000 		.word	CyFxUSBDeviceQualDscr
 6965 3c0c 00000000 		.word	CyFxUSBBOSDscr
 6966 3c10 00000000 		.word	CyFxUSBHSConfigDscr
 6967 3c14 00000000 		.word	CyFxUSBFSConfigDscr
 6968 3c18 00000000 		.word	CyFxUSBSSConfigDscr
 6969 3c1c 00000000 		.word	CyFxUSBStringLangIDDscr
 6970 3c20 00000000 		.word	CyFxUSBManufactureDscr
 6971 3c24 00000000 		.word	CyFxUSBProductDscr
 6972 3c28 013F0000 		.word	16129
 6973 3c2c 02030000 		.word	770
 6974 3c30 00000000 		.word	glChHandleInterStat
 6975 3c34 00000000 		.word	glInterStaBuffer
 6976 3c38 03030000 		.word	771
 6977 3c3c 01010000 		.word	257
 6978 3c40 00000000 		.word	CyFxUvcApplnDmaCallback
 6979 3c44 00000000 		.word	glChHandleUVCStream
 6980 3c48 00000000 		.word	.LANCHOR1
 6981 3c4c 70060000 		.word	.LC36
 6982 3c50 D8010000 		.word	.LC12
 6983 3c54 C0060000 		.word	.LC38
 6984 3c58 9C060000 		.word	.LC37
 6985 3c5c E8060000 		.word	.LC39
 6986 3c60 40080000 		.word	.LC46
 6987 3c64 1C090000 		.word	.LC50
 6988 3c68 EC080000 		.word	.LC49
 6989 3c6c B4080000 		.word	.LC48
 6990 3c70 74080000 		.word	.LC47
 6991 3c74 E8090000 		.word	.LC55
 6992 3c78 2C000000 		.word	.LANCHOR2+44
 6993 3c7c 300A0000 		.word	.LC57
 6994 3c80 D8090000 		.word	.LC54
 6995 3c84 10000000 		.word	.LANCHOR2+16
 6996 3c88 F8090000 		.word	.LC56
 6997 3c8c A4090000 		.word	.LC53
 6998 3c90 10080000 		.word	.LC45
 6999 3c94 E0070000 		.word	.LC44
 7000 3c98 A8070000 		.word	.LC43
 7001 3c9c 40070000 		.word	.LC41
 7002 3ca0 14070000 		.word	.LC40
 7003 3ca4 74070000 		.word	.LC42
 7004 3ca8 44090000 		.word	.LC51
 7005 3cac 70090000 		.word	.LC52
 7006              	.LBE270:
 7007              	.LBE269:
 7008              		.cfi_endproc
 7009              	.LFE18:
 7011              		.align	2
 7012              		.global	CyFxApplicationDefine
 7014              	CyFxApplicationDefine:
 7015              	.LFB26:
3700:../uvc.c      **** }
3701:../uvc.c      **** 
3702:../uvc.c      **** 
3703:../uvc.c      **** /*
3704:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3705:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3706:../uvc.c      ****  */
3707:../uvc.c      **** void
3708:../uvc.c      **** CyFxApplicationDefine (
3709:../uvc.c      ****         void)
3710:../uvc.c      **** {
 7016              		.loc 1 3710 0
 7017              		.cfi_startproc
 7018              		@ args = 0, pretend = 0, frame = 40
 7019              		@ frame_needed = 0, uses_anonymous_args = 0
 7020              	.LVL591:
 7021 3cb0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7022              	.LCFI25:
 7023              		.cfi_def_cfa_offset 36
3711:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3712:../uvc.c      ****     uint32_t retThrdCreate;
3713:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3714:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3715:../uvc.c      **** 
3716:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3717:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7024              		.loc 1 3717 0
 7025 3cb4 010AA0E3 		mov	r0, #4096
3710:../uvc.c      **** {
 7026              		.loc 1 3710 0
 7027 3cb8 4CD04DE2 		sub	sp, sp, #76
 7028              	.LCFI26:
 7029              		.cfi_def_cfa_offset 112
 7030              		.loc 1 3717 0
 7031              		.cfi_offset 14, -4
 7032              		.cfi_offset 11, -8
 7033              		.cfi_offset 10, -12
 7034              		.cfi_offset 9, -16
 7035              		.cfi_offset 8, -20
 7036              		.cfi_offset 7, -24
 7037              		.cfi_offset 6, -28
 7038              		.cfi_offset 5, -32
 7039              		.cfi_offset 4, -36
 7040 3cbc FEFFFFEB 		bl	CyU3PMemAlloc
 7041 3cc0 00A0A0E1 		mov	sl, r0
 7042              	.LVL592:
3718:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7043              		.loc 1 3718 0
 7044 3cc4 010AA0E3 		mov	r0, #4096
 7045              	.LVL593:
 7046 3cc8 FEFFFFEB 		bl	CyU3PMemAlloc
 7047 3ccc 00B0A0E1 		mov	fp, r0
 7048              	.LVL594:
3719:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7049              		.loc 1 3719 0
 7050 3cd0 010AA0E3 		mov	r0, #4096
 7051              	.LVL595:
 7052 3cd4 FEFFFFEB 		bl	CyU3PMemAlloc
3720:../uvc.c      **** 
3721:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7053              		.loc 1 3721 0
 7054 3cd8 00005AE3 		cmp	sl, #0
 7055 3cdc 00005B13 		cmpne	fp, #0
 7056 3ce0 0090A013 		movne	r9, #0
 7057 3ce4 0190A003 		moveq	r9, #1
3719:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7058              		.loc 1 3719 0
 7059 3ce8 24008DE5 		str	r0, [sp, #36]
 7060              	.LVL596:
 7061              		.loc 1 3721 0
 7062 3cec 0000001A 		bne	.L564
 7063              	.LVL597:
 7064              	.L561:
 7065              	.L563:
 7066 3cf0 FEFFFFEA 		b	.L563
 7067              	.L564:
 7068              		.loc 1 3721 0 is_stmt 0 discriminator 1
 7069 3cf4 000050E3 		cmp	r0, #0
 7070 3cf8 FCFFFF0A 		beq	.L561
3722:../uvc.c      ****         goto fatalErrorHandler;
3723:../uvc.c      **** 
3724:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3725:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7071              		.loc 1 3725 0 is_stmt 1
 7072 3cfc 28408DE2 		add	r4, sp, #40
 7073 3d00 0400A0E1 		mov	r0, r4
 7074 3d04 4010A0E3 		mov	r1, #64
 7075 3d08 18219FE5 		ldr	r2, .L565
 7076 3d0c FEFFFFEB 		bl	cmdbufCreate
 7077 3d10 0450A0E1 		mov	r5, r4
 7078 3d14 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7079 3d18 0C719FE5 		ldr	r7, .L565+4
3726:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7080              		.loc 1 3726 0
 7081 3d1c 0C819FE5 		ldr	r8, .L565+8
3725:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7082              		.loc 1 3725 0
 7083 3d20 07C0A0E1 		mov	ip, r7
 7084 3d24 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7085 3d28 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3727:../uvc.c      **** 
3728:../uvc.c      **** 	/****** initialize command descriptor ***********/
3729:../uvc.c      **** 	cmdquInit(cmdQuptr);
3730:../uvc.c      **** 	cmdquInit(statQuptr);
3731:../uvc.c      **** 
3732:../uvc.c      ****     /* Create the UVC application thread. */
3733:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7086              		.loc 1 3733 0
 7087 3d2c 0860A0E3 		mov	r6, #8
3725:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7088              		.loc 1 3725 0
 7089 3d30 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3726:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7090              		.loc 1 3726 0
 7091 3d34 F8209FE5 		ldr	r2, .L565+12
 7092 3d38 0400A0E1 		mov	r0, r4
 7093 3d3c 2010A0E3 		mov	r1, #32
 7094 3d40 FEFFFFEB 		bl	cmdbufCreate
 7095 3d44 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7096 3d48 08C0A0E1 		mov	ip, r8
 7097 3d4c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7098 3d50 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7099              		.loc 1 3733 0
 7100 3d54 0140A0E3 		mov	r4, #1
3726:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7101              		.loc 1 3726 0
 7102 3d58 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3729:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7103              		.loc 1 3729 0
 7104 3d5c 0700A0E1 		mov	r0, r7
 7105 3d60 FEFFFFEB 		bl	cmdquInit
3730:../uvc.c      **** 	cmdquInit(statQuptr);
 7106              		.loc 1 3730 0
 7107 3d64 0800A0E1 		mov	r0, r8
 7108 3d68 FEFFFFEB 		bl	cmdquInit
 7109              		.loc 1 3733 0
 7110 3d6c A850A0E3 		mov	r5, #168
 7111 3d70 01CAA0E3 		mov	ip, #4096
 7112 3d74 BC009FE5 		ldr	r0, .L565+16
 7113 3d78 BC109FE5 		ldr	r1, .L565+20
 7114 3d7c BC209FE5 		ldr	r2, .L565+24
 7115 3d80 0930A0E1 		mov	r3, r9
 7116 3d84 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7117 3d88 08608DE5 		str	r6, [sp, #8]
 7118 3d8c 0C608DE5 		str	r6, [sp, #12]
 7119 3d90 10908DE5 		str	r9, [sp, #16]
 7120 3d94 14408DE5 		str	r4, [sp, #20]
 7121 3d98 18508DE5 		str	r5, [sp, #24]
 7122 3d9c FEFFFFEB 		bl	_txe_thread_create
 7123              	.LVL598:
3734:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3735:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3736:../uvc.c      ****             0,                                          /* No input parameter to thread */
3737:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3738:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3739:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3740:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3741:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3742:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3743:../uvc.c      ****             );
3744:../uvc.c      ****     if (retThrdCreate != 0)
 7124              		.loc 1 3744 0
 7125 3da0 00C050E2 		subs	ip, r0, #0
 7126 3da4 D1FFFF1A 		bne	.L561
3745:../uvc.c      ****     {
3746:../uvc.c      ****         goto fatalErrorHandler;
3747:../uvc.c      ****     }
3748:../uvc.c      **** 
3749:../uvc.c      ****     /* Create the control request handling thread. */
3750:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7127              		.loc 1 3750 0
 7128 3da8 0C30A0E1 		mov	r3, ip
 7129 3dac 027BA0E3 		mov	r7, #2048
 7130 3db0 8C009FE5 		ldr	r0, .L565+28
 7131              	.LVL599:
 7132 3db4 8C109FE5 		ldr	r1, .L565+32
 7133 3db8 8C209FE5 		ldr	r2, .L565+36
 7134 3dbc 10C08DE5 		str	ip, [sp, #16]
 7135 3dc0 00B08DE5 		str	fp, [sp, #0]
 7136 3dc4 04708DE5 		str	r7, [sp, #4]
 7137 3dc8 08608DE5 		str	r6, [sp, #8]
 7138 3dcc 0C608DE5 		str	r6, [sp, #12]
 7139 3dd0 14408DE5 		str	r4, [sp, #20]
 7140 3dd4 18508DE5 		str	r5, [sp, #24]
 7141 3dd8 FEFFFFEB 		bl	_txe_thread_create
 7142              	.LVL600:
3751:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3752:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3753:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3754:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3755:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3756:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3757:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3758:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3759:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3760:../uvc.c      ****             );
3761:../uvc.c      ****     if (retThrdCreate != 0)
 7143              		.loc 1 3761 0
 7144 3ddc 00C050E2 		subs	ip, r0, #0
 7145 3de0 C2FFFF1A 		bne	.L561
3762:../uvc.c      ****     {
3763:../uvc.c      ****         goto fatalErrorHandler;
3764:../uvc.c      ****     }
3765:../uvc.c      **** #if 1
3766:../uvc.c      ****     /* Create the I2C control command handling thread. */
3767:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7146              		.loc 1 3767 0
 7147 3de4 24E09DE5 		ldr	lr, [sp, #36]
 7148 3de8 60009FE5 		ldr	r0, .L565+40
 7149              	.LVL601:
 7150 3dec 60109FE5 		ldr	r1, .L565+44
 7151 3df0 60209FE5 		ldr	r2, .L565+48
 7152 3df4 0C30A0E1 		mov	r3, ip
 7153 3df8 00E08DE5 		str	lr, [sp, #0]
 7154 3dfc 04708DE5 		str	r7, [sp, #4]
 7155 3e00 08608DE5 		str	r6, [sp, #8]
 7156 3e04 0C608DE5 		str	r6, [sp, #12]
 7157 3e08 10C08DE5 		str	ip, [sp, #16]
 7158 3e0c 14408DE5 		str	r4, [sp, #20]
 7159 3e10 18508DE5 		str	r5, [sp, #24]
 7160 3e14 FEFFFFEB 		bl	_txe_thread_create
 7161              	.LVL602:
3768:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3769:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3770:../uvc.c      ****             0,                                          /* No input parameter to thread */
3771:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3772:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3773:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3774:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3775:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3776:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3777:../uvc.c      ****             );
3778:../uvc.c      ****     if (retThrdCreate != 0)
 7162              		.loc 1 3778 0
 7163 3e18 000050E3 		cmp	r0, #0
 7164 3e1c B3FFFF1A 		bne	.L561
3779:../uvc.c      ****     {
3780:../uvc.c      ****         goto fatalErrorHandler;
3781:../uvc.c      ****     }
3782:../uvc.c      **** #endif
3783:../uvc.c      **** 
3784:../uvc.c      ****     return;
3785:../uvc.c      **** 
3786:../uvc.c      **** fatalErrorHandler:
3787:../uvc.c      ****     /* Add custom recovery or debug actions here */
3788:../uvc.c      ****     /* Loop indefinitely */
3789:../uvc.c      ****     while (1);
3790:../uvc.c      **** }
 7165              		.loc 1 3790 0
 7166 3e20 4CD08DE2 		add	sp, sp, #76
 7167 3e24 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7168              	.L566:
 7169              		.align	2
 7170              	.L565:
 7171 3e28 00000000 		.word	cmdQuMux
 7172 3e2c 00000000 		.word	cmdQu
 7173 3e30 00000000 		.word	statQu
 7174 3e34 00000000 		.word	staQuMux
 7175 3e38 A0000000 		.word	.LANCHOR0+160
 7176 3e3c 680A0000 		.word	.LC58
 7177 3e40 00000000 		.word	UVCAppThread_Entry
 7178 3e44 48010000 		.word	.LANCHOR0+328
 7179 3e48 7C0A0000 		.word	.LC59
 7180 3e4c 00000000 		.word	UVCAppEP0Thread_Entry
 7181 3e50 F0010000 		.word	.LANCHOR0+496
 7182 3e54 940A0000 		.word	.LC60
 7183 3e58 00000000 		.word	I2cAppThread_Entry
 7184              		.cfi_endproc
 7185              	.LFE26:
 7187              		.align	2
 7188              		.global	main
 7190              	main:
 7191              	.LFB27:
3791:../uvc.c      **** 
3792:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3793:../uvc.c      ****  * the ThreadX RTOS here.
3794:../uvc.c      ****  */
3795:../uvc.c      **** int
3796:../uvc.c      **** main (
3797:../uvc.c      ****         void)
3798:../uvc.c      **** {
 7192              		.loc 1 3798 0
 7193              		.cfi_startproc
 7194              		@ args = 0, pretend = 0, frame = 56
 7195              		@ frame_needed = 0, uses_anonymous_args = 0
 7196 3e5c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7197              	.LCFI27:
 7198              		.cfi_def_cfa_offset 12
3799:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3800:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3801:../uvc.c      **** 
3802:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3803:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3804:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3805:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3806:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3807:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7199              		.loc 1 3807 0
 7200 3e60 0010A0E3 		mov	r1, #0
3798:../uvc.c      **** {
 7201              		.loc 1 3798 0
 7202 3e64 3CD04DE2 		sub	sp, sp, #60
 7203              	.LCFI28:
 7204              		.cfi_def_cfa_offset 72
3804:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7205              		.loc 1 3804 0
 7206 3e68 0220A0E3 		mov	r2, #2
3808:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7207              		.loc 1 3808 0
 7208 3e6c 033081E2 		add	r3, r1, #3
3803:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7209              		.loc 1 3803 0
 7210 3e70 0150A0E3 		mov	r5, #1
 7211              		.cfi_offset 14, -4
 7212              		.cfi_offset 5, -8
 7213              		.cfi_offset 4, -12
3809:../uvc.c      **** 
3810:../uvc.c      ****     /* Initialize the device */
3811:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7214              		.loc 1 3811 0
 7215 3e74 28008DE2 		add	r0, sp, #40
3803:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7216              		.loc 1 3803 0
 7217 3e78 28508DE5 		str	r5, [sp, #40]
3804:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7218              		.loc 1 3804 0
 7219 3e7c 2C20CDE5 		strb	r2, [sp, #44]
3805:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7220              		.loc 1 3805 0
 7221 3e80 2D20CDE5 		strb	r2, [sp, #45]
3806:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7222              		.loc 1 3806 0
 7223 3e84 2E20CDE5 		strb	r2, [sp, #46]
3807:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7224              		.loc 1 3807 0
 7225 3e88 30108DE5 		str	r1, [sp, #48]
3808:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7226              		.loc 1 3808 0
 7227 3e8c 3430CDE5 		strb	r3, [sp, #52]
 7228              		.loc 1 3811 0
 7229 3e90 FEFFFFEB 		bl	CyU3PDeviceInit
 7230              	.LVL603:
3812:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7231              		.loc 1 3812 0
 7232 3e94 004050E2 		subs	r4, r0, #0
 7233 3e98 0000000A 		beq	.L570
 7234              	.L568:
 7235              	.L569:
 7236 3e9c FEFFFFEA 		b	.L569
 7237              	.L570:
3813:../uvc.c      ****     {
3814:../uvc.c      ****         goto handle_fatal_error;
3815:../uvc.c      ****     }
3816:../uvc.c      **** 
3817:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3818:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7238              		.loc 1 3818 0
 7239 3ea0 0410A0E1 		mov	r1, r4
 7240 3ea4 0420A0E1 		mov	r2, r4
 7241 3ea8 0500A0E1 		mov	r0, r5
 7242              	.LVL604:
 7243 3eac FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7244              	.LVL605:
3819:../uvc.c      **** 
3820:../uvc.c      ****     /* Configure the IO matrix for the device. */
3821:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3822:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3823:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3824:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3825:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3826:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3827:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3828:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3829:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3830:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3831:../uvc.c      **** 
3832:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7245              		.loc 1 3832 0
 7246 3eb0 0D00A0E1 		mov	r0, sp
3822:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7247              		.loc 1 3822 0
 7248 3eb4 1640CDE5 		strb	r4, [sp, #22]
3823:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7249              		.loc 1 3823 0
 7250 3eb8 18408DE5 		str	r4, [sp, #24]
3824:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7251              		.loc 1 3824 0
 7252 3ebc 1C408DE5 		str	r4, [sp, #28]
3825:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7253              		.loc 1 3825 0
 7254 3ec0 20408DE5 		str	r4, [sp, #32]
3826:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7255              		.loc 1 3826 0
 7256 3ec4 24408DE5 		str	r4, [sp, #36]
3829:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7257              		.loc 1 3829 0
 7258 3ec8 0C408DE5 		str	r4, [sp, #12]
3830:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7259              		.loc 1 3830 0
 7260 3ecc 10408DE5 		str	r4, [sp, #16]
3821:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7261              		.loc 1 3821 0
 7262 3ed0 00508DE5 		str	r5, [sp, #0]
3827:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7263              		.loc 1 3827 0
 7264 3ed4 04508DE5 		str	r5, [sp, #4]
3828:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7265              		.loc 1 3828 0
 7266 3ed8 08508DE5 		str	r5, [sp, #8]
 7267              		.loc 1 3832 0
 7268 3edc FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7269              	.LVL606:
3833:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7270              		.loc 1 3833 0
 7271 3ee0 004050E2 		subs	r4, r0, #0
 7272 3ee4 ECFFFF1A 		bne	.L568
3834:../uvc.c      ****     {
3835:../uvc.c      ****         goto handle_fatal_error;
3836:../uvc.c      ****     }
3837:../uvc.c      **** 
3838:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3839:../uvc.c      ****     CyU3PKernelEntry ();
 7273              		.loc 1 3839 0
 7274 3ee8 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7275              	.LVL607:
3840:../uvc.c      **** 
3841:../uvc.c      ****     /* Dummy return to make the compiler happy */
3842:../uvc.c      ****     return 0;
3843:../uvc.c      **** 
3844:../uvc.c      **** handle_fatal_error:
3845:../uvc.c      ****     /* Cannot recover from this error. */
3846:../uvc.c      ****     while (1);
3847:../uvc.c      **** }
 7276              		.loc 1 3847 0
 7277 3eec 0400A0E1 		mov	r0, r4
 7278 3ef0 3CD08DE2 		add	sp, sp, #60
 7279 3ef4 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7280              		.cfi_endproc
 7281              	.LFE27:
 7283              		.global	CyFxGpifTransition
 7284              		.global	CyFxGpifWavedata
 7285              		.global	CyFxGpifWavedataPosition
 7286              		.global	CyFxGpifRegValue
 7287              		.global	CyFxGpifConfig
 7288              		.global	CyFxGpifTransition_usb2
 7289              		.global	CyFxGpifWavedata_usb2
 7290              		.global	CyFxGpifWavedataPosition_usb2
 7291              		.global	CyFxGpifRegValue_usb2
 7292              		.global	CyFxGpifConfig_usb2
 7293              		.global	snapButFlag
 7294              		.global	testSnap
 7295              		.global	fb
 7296              		.global	pb
 7297              		.global	pbc
 7298              		.global	fbbak
 7299              		.global	pbbak
 7300              		.global	pbcbak
 7301              		.global	pbcpbak
 7302              		.global	isUsbConnected
 7303              		.global	usbSpeed
 7304              		.global	clearFeatureRqtReceived
 7305              		.global	streamingStarted
 7306              		.global	glProbeCtrl
 7307              		.global	glProbeCtrlFull
 7308              		.global	glProbeStilCtrl
 7309              		.global	glProbeCtrl20
 7310              		.global	glProbeStilCtrl20
 7311              		.global	glUVCHeader
 7312              		.comm	glChHandleUVCStream,220,4
 7313              		.comm	glChHandleStillStream,220,4
 7314              		.comm	glChHandleInterStat,160,4
 7315              		.comm	glInterStaBuffer,4,4
 7316              		.comm	cmdQu,32,4
 7317              		.comm	statQu,32,4
 7318              		.comm	cmdQuMux,56,4
 7319              		.comm	staQuMux,56,4
 7320              		.comm	timMux,56,4
 7321              		.comm	bmReqType,1,1
 7322              		.comm	bRequest,1,1
 7323              		.comm	wValue,2,2
 7324              		.comm	wIndex,2,2
 7325              		.comm	wLength,2,2
 7326              		.comm	posTick,4,4
 7327              		.comm	I2CCmdTimer,44,4
 7328              		.section	.rodata
 7329              		.align	2
 7330              		.set	.LANCHOR2,. + 0
 7333              	ExTime:
 7334 0000 9C       		.byte	-100
 7335 0001 00       		.byte	0
 7336 0002 4E       		.byte	78
 7337 0003 00       		.byte	0
 7338 0004 27       		.byte	39
 7339 0005 00       		.byte	0
 7340 0006 14       		.byte	20
 7341 0007 00       		.byte	0
 7342 0008 0A       		.byte	10
 7343 0009 00       		.byte	0
 7344 000a 05       		.byte	5
 7345 000b 00       		.byte	0
 7346 000c 02       		.byte	2
 7347 000d 00       		.byte	0
 7348 000e 01       		.byte	1
 7349 000f 00       		.byte	0
 7352              	CyFxGpifConfig:
 7353 0010 0F00     		.short	15
 7354 0012 0000     		.space	2
 7355 0014 00000000 		.word	CyFxGpifWavedata
 7356 0018 00000000 		.word	CyFxGpifWavedataPosition
 7357 001c 0500     		.short	5
 7358 001e 0000     		.space	2
 7359 0020 00000000 		.word	CyFxGpifTransition
 7360 0024 4C00     		.short	76
 7361 0026 0000     		.space	2
 7362 0028 00000000 		.word	CyFxGpifRegValue
 7365              	CyFxGpifConfig_usb2:
 7366 002c 9300     		.short	147
 7367 002e 0000     		.space	2
 7368 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7369 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7370 0038 0800     		.short	8
 7371 003a 0000     		.space	2
 7372 003c 00000000 		.word	CyFxGpifTransition_usb2
 7373 0040 4C00     		.short	76
 7374 0042 0000     		.space	2
 7375 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7376              		.data
 7377              		.align	2
 7378              		.set	.LANCHOR1,. + 0
 7381              	ExUCtrlParArry:
 7382 0000 13       		.byte	19
 7383 0001 14       		.byte	20
 7384 0002 02       		.byte	2
 7385 0003 01       		.byte	1
 7386 0004 00       		.byte	0
 7387 0005 03       		.byte	3
 7388 0006 00       		.byte	0
 7389 0007 01       		.byte	1
 7390 0008 00       		.byte	0
 7391 0009 03       		.byte	3
 7392 000a 00       		.byte	0
 7393 000b 23       		.byte	35
 7394 000c 37       		.byte	55
 7395 000d 23       		.byte	35
 7396 000e 37       		.byte	55
 7397 000f 30       		.byte	48
 7398 0010 01       		.byte	1
 7399 0011 00       		.byte	0
 7400 0012 00       		.byte	0
 7401 0013 00000000 		.space	5
 7401      00
 7402 0018 11       		.byte	17
 7403 0019 00       		.byte	0
 7404 001a 02       		.byte	2
 7405 001b 01       		.byte	1
 7406 001c 00       		.byte	0
 7407 001d 03       		.byte	3
 7408 001e 00       		.byte	0
 7409 001f 01       		.byte	1
 7410 0020 00       		.byte	0
 7411 0021 03       		.byte	3
 7412 0022 00       		.byte	0
 7413 0023 01       		.byte	1
 7414 0024 00       		.byte	0
 7415 0025 01       		.byte	1
 7416 0026 00       		.byte	0
 7417 0027 30       		.byte	48
 7418 0028 01       		.byte	1
 7419 0029 01       		.byte	1
 7420 002a 00       		.byte	0
 7421 002b 00000000 		.space	5
 7421      00
 7422 0030 17       		.byte	23
 7423 0031 00       		.byte	0
 7424 0032 01       		.byte	1
 7425 0033 01       		.byte	1
 7426 0034 00       		.byte	0
 7427 0035 02       		.byte	2
 7428 0036 00       		.byte	0
 7429 0037 01       		.byte	1
 7430 0038 00       		.byte	0
 7431 0039 03       		.byte	3
 7432 003a 00       		.byte	0
 7433 003b 00       		.byte	0
 7434 003c 00       		.byte	0
 7435 003d 00       		.byte	0
 7436 003e 00       		.byte	0
 7437 003f 30       		.byte	48
 7438 0040 01       		.byte	1
 7439 0041 01       		.byte	1
 7440 0042 00       		.byte	0
 7441 0043 00000000 		.space	5
 7441      00
 7442 0048 00       		.byte	0
 7443 0049 00       		.byte	0
 7444 004a 04       		.byte	4
 7445 004b 01       		.byte	1
 7446 004c 00       		.byte	0
 7447 004d 38       		.byte	56
 7448 004e 01       		.byte	1
 7449 004f 01       		.byte	1
 7450 0050 00       		.byte	0
 7451 0051 03       		.byte	3
 7452 0052 00       		.byte	0
 7453 0053 4E       		.byte	78
 7454 0054 00       		.byte	0
 7455 0055 4E       		.byte	78
 7456 0056 00       		.byte	0
 7457 0057 30       		.byte	48
 7458 0058 01       		.byte	1
 7459 0059 00       		.byte	0
 7460 005a 00       		.byte	0
 7461 005b 00000000 		.space	5
 7461      00
 7462 0060 00       		.byte	0
 7463 0061 00       		.byte	0
 7464 0062 01       		.byte	1
 7465 0063 00       		.byte	0
 7466 0064 00       		.byte	0
 7467 0065 00       		.byte	0
 7468 0066 00       		.byte	0
 7469 0067 01       		.byte	1
 7470 0068 00       		.byte	0
 7471 0069 03       		.byte	3
 7472 006a 00       		.byte	0
 7473 006b 00       		.byte	0
 7474 006c 00       		.byte	0
 7475 006d 00       		.byte	0
 7476 006e 00       		.byte	0
 7477 006f 30       		.byte	48
 7478 0070 01       		.byte	1
 7479 0071 00       		.byte	0
 7480 0072 00       		.byte	0
 7481 0073 00000000 		.space	5
 7481      00
 7482 0078 00       		.byte	0
 7483 0079 00       		.byte	0
 7484 007a 02       		.byte	2
 7485 007b 00       		.byte	0
 7486 007c 00       		.byte	0
 7487 007d FF       		.byte	-1
 7488 007e 00       		.byte	0
 7489 007f 01       		.byte	1
 7490 0080 00       		.byte	0
 7491 0081 03       		.byte	3
 7492 0082 00       		.byte	0
 7493 0083 01       		.byte	1
 7494 0084 00       		.byte	0
 7495 0085 00       		.byte	0
 7496 0086 00       		.byte	0
 7497 0087 30       		.byte	48
 7498 0088 01       		.byte	1
 7499 0089 01       		.byte	1
 7500 008a 00       		.byte	0
 7501 008b 00000000 		.space	5
 7501      00
 7502 0090 00       		.byte	0
 7503 0091 00       		.byte	0
 7504 0092 02       		.byte	2
 7505 0093 00       		.byte	0
 7506 0094 00       		.byte	0
 7507 0095 00       		.byte	0
 7508 0096 00       		.byte	0
 7509 0097 00       		.byte	0
 7510 0098 00       		.byte	0
 7511 0099 03       		.byte	3
 7512 009a 00       		.byte	0
 7513 009b 00       		.byte	0
 7514 009c 00       		.byte	0
 7515 009d 00       		.byte	0
 7516 009e 00       		.byte	0
 7517 009f 30       		.byte	48
 7518 00a0 01       		.byte	1
 7519 00a1 01       		.byte	1
 7520 00a2 00       		.byte	0
 7521 00a3 00000000 		.space	5
 7521      00
 7522 00a8 00       		.byte	0
 7523 00a9 00       		.byte	0
 7524 00aa 02       		.byte	2
 7525 00ab 00       		.byte	0
 7526 00ac 00       		.byte	0
 7527 00ad 30       		.byte	48
 7528 00ae 00       		.byte	0
 7529 00af 01       		.byte	1
 7530 00b0 00       		.byte	0
 7531 00b1 03       		.byte	3
 7532 00b2 0A       		.byte	10
 7533 00b3 00       		.byte	0
 7534 00b4 00       		.byte	0
 7535 00b5 0A       		.byte	10
 7536 00b6 00       		.byte	0
 7537 00b7 30       		.byte	48
 7538 00b8 01       		.byte	1
 7539 00b9 01       		.byte	1
 7540 00ba 00       		.byte	0
 7541 00bb 00000000 		.space	5
 7541      00
 7542 00c0 00       		.byte	0
 7543 00c1 00       		.byte	0
 7544 00c2 01       		.byte	1
 7545 00c3 00       		.byte	0
 7546 00c4 00       		.byte	0
 7547 00c5 7F       		.byte	127
 7548 00c6 00       		.byte	0
 7549 00c7 01       		.byte	1
 7550 00c8 00       		.byte	0
 7551 00c9 03       		.byte	3
 7552 00ca 00       		.byte	0
 7553 00cb 00       		.byte	0
 7554 00cc 00       		.byte	0
 7555 00cd 00       		.byte	0
 7556 00ce 00       		.byte	0
 7557 00cf 30       		.byte	48
 7558 00d0 01       		.byte	1
 7559 00d1 00       		.byte	0
 7560 00d2 00       		.byte	0
 7561 00d3 00000000 		.space	5
 7561      00
 7562 00d8 00       		.byte	0
 7563 00d9 00       		.byte	0
 7564 00da 02       		.byte	2
 7565 00db 00       		.byte	0
 7566 00dc 00       		.byte	0
 7567 00dd 05       		.byte	5
 7568 00de 00       		.byte	0
 7569 00df 01       		.byte	1
 7570 00e0 00       		.byte	0
 7571 00e1 03       		.byte	3
 7572 00e2 00       		.byte	0
 7573 00e3 00       		.byte	0
 7574 00e4 00       		.byte	0
 7575 00e5 00       		.byte	0
 7576 00e6 00       		.byte	0
 7577 00e7 30       		.byte	48
 7578 00e8 01       		.byte	1
 7579 00e9 00       		.byte	0
 7580 00ea 00       		.byte	0
 7581 00eb 00000000 		.space	5
 7581      00
 7582 00f0 00       		.byte	0
 7583 00f1 00       		.byte	0
 7584 00f2 03       		.byte	3
 7585 00f3 00       		.byte	0
 7586 00f4 00       		.byte	0
 7587 00f5 0A       		.byte	10
 7588 00f6 00       		.byte	0
 7589 00f7 01       		.byte	1
 7590 00f8 00       		.byte	0
 7591 00f9 03       		.byte	3
 7592 00fa 00       		.byte	0
 7593 00fb 00       		.byte	0
 7594 00fc 00       		.byte	0
 7595 00fd 00       		.byte	0
 7596 00fe 00       		.byte	0
 7597 00ff 30       		.byte	48
 7598 0100 01       		.byte	1
 7599 0101 00       		.byte	0
 7600 0102 00       		.byte	0
 7601 0103 00000000 		.space	5
 7601      00
 7602 0108 00       		.byte	0
 7603 0109 00       		.byte	0
 7604 010a 02       		.byte	2
 7605 010b 00       		.byte	0
 7606 010c 00       		.byte	0
 7607 010d 40       		.byte	64
 7608 010e 00       		.byte	0
 7609 010f 01       		.byte	1
 7610 0110 00       		.byte	0
 7611 0111 03       		.byte	3
 7612 0112 00       		.byte	0
 7613 0113 0F       		.byte	15
 7614 0114 11       		.byte	17
 7615 0115 00       		.byte	0
 7616 0116 00       		.byte	0
 7617 0117 30       		.byte	48
 7618 0118 01       		.byte	1
 7619 0119 00       		.byte	0
 7620 011a 00       		.byte	0
 7621 011b 00000000 		.space	5
 7621      00
 7622 0120 00       		.byte	0
 7623 0121 00       		.byte	0
 7624 0122 02       		.byte	2
 7625 0123 00       		.byte	0
 7626 0124 00       		.byte	0
 7627 0125 64       		.byte	100
 7628 0126 00       		.byte	0
 7629 0127 01       		.byte	1
 7630 0128 00       		.byte	0
 7631 0129 03       		.byte	3
 7632 012a 00       		.byte	0
 7633 012b 00       		.byte	0
 7634 012c 00       		.byte	0
 7635 012d 00       		.byte	0
 7636 012e 00       		.byte	0
 7637 012f 30       		.byte	48
 7638 0130 01       		.byte	1
 7639 0131 00       		.byte	0
 7640 0132 00       		.byte	0
 7641 0133 00000000 		.space	5
 7641      00
 7642 0138 00       		.byte	0
 7643 0139 00       		.byte	0
 7644 013a 02       		.byte	2
 7645 013b 00       		.byte	0
 7646 013c 00       		.byte	0
 7647 013d 64       		.byte	100
 7648 013e 00       		.byte	0
 7649 013f 01       		.byte	1
 7650 0140 00       		.byte	0
 7651 0141 03       		.byte	3
 7652 0142 00       		.byte	0
 7653 0143 00       		.byte	0
 7654 0144 00       		.byte	0
 7655 0145 00       		.byte	0
 7656 0146 00       		.byte	0
 7657 0147 30       		.byte	48
 7658 0148 01       		.byte	1
 7659 0149 00       		.byte	0
 7660 014a 00       		.byte	0
 7661 014b 00000000 		.space	5
 7661      00
 7662 0150 00       		.byte	0
 7663 0151 00       		.byte	0
 7664 0152 02       		.byte	2
 7665 0153 00       		.byte	0
 7666 0154 00       		.byte	0
 7667 0155 64       		.byte	100
 7668 0156 00       		.byte	0
 7669 0157 01       		.byte	1
 7670 0158 00       		.byte	0
 7671 0159 03       		.byte	3
 7672 015a 00       		.byte	0
 7673 015b 00       		.byte	0
 7674 015c 00       		.byte	0
 7675 015d 00       		.byte	0
 7676 015e 00       		.byte	0
 7677 015f 30       		.byte	48
 7678 0160 01       		.byte	1
 7679 0161 00       		.byte	0
 7680 0162 00       		.byte	0
 7681 0163 00000000 		.space	5
 7681      00
 7682 0168 00       		.byte	0
 7683 0169 00       		.byte	0
 7684 016a 02       		.byte	2
 7685 016b 00       		.byte	0
 7686 016c 00       		.byte	0
 7687 016d 64       		.byte	100
 7688 016e 00       		.byte	0
 7689 016f 01       		.byte	1
 7690 0170 00       		.byte	0
 7691 0171 03       		.byte	3
 7692 0172 00       		.byte	0
 7693 0173 00       		.byte	0
 7694 0174 00       		.byte	0
 7695 0175 00       		.byte	0
 7696 0176 00       		.byte	0
 7697 0177 30       		.byte	48
 7698 0178 01       		.byte	1
 7699 0179 00       		.byte	0
 7700 017a 00       		.byte	0
 7701 017b 00000000 		.space	5
 7701      00
 7704              	CtrlParArry:
 7705 0180 10       		.byte	16
 7706 0181 10       		.byte	16
 7707 0182 02       		.byte	2
 7708 0183 00       		.byte	0
 7709 0184 00       		.byte	0
 7710 0185 03       		.byte	3
 7711 0186 00       		.byte	0
 7712 0187 01       		.byte	1
 7713 0188 00       		.byte	0
 7714 0189 03       		.byte	3
 7715 018a 00       		.byte	0
 7716 018b 03       		.byte	3
 7717 018c 00       		.byte	0
 7718 018d 03       		.byte	3
 7719 018e 00       		.byte	0
 7720 018f 30       		.byte	48
 7721 0190 01       		.byte	1
 7722 0191 00       		.byte	0
 7723 0192 00       		.byte	0
 7724 0193 00000000 		.space	5
 7724      00
 7725 0198 15       		.byte	21
 7726 0199 15       		.byte	21
 7727 019a 02       		.byte	2
 7728 019b 00       		.byte	0
 7729 019c 00       		.byte	0
 7730 019d FF       		.byte	-1
 7731 019e 00       		.byte	0
 7732 019f 01       		.byte	1
 7733 01a0 00       		.byte	0
 7734 01a1 03       		.byte	3
 7735 01a2 00       		.byte	0
 7736 01a3 76       		.byte	118
 7737 01a4 00       		.byte	0
 7738 01a5 76       		.byte	118
 7739 01a6 C7       		.byte	-57
 7740 01a7 30       		.byte	48
 7741 01a8 01       		.byte	1
 7742 01a9 01       		.byte	1
 7743 01aa 00       		.byte	0
 7744 01ab 00000000 		.space	5
 7744      00
 7745 01b0 02       		.byte	2
 7746 01b1 02       		.byte	2
 7747 01b2 02       		.byte	2
 7748 01b3 00       		.byte	0
 7749 01b4 00       		.byte	0
 7750 01b5 FF       		.byte	-1
 7751 01b6 00       		.byte	0
 7752 01b7 01       		.byte	1
 7753 01b8 00       		.byte	0
 7754 01b9 03       		.byte	3
 7755 01ba 00       		.byte	0
 7756 01bb 70       		.byte	112
 7757 01bc 00       		.byte	0
 7758 01bd 70       		.byte	112
 7759 01be 00       		.byte	0
 7760 01bf C6       		.byte	-58
 7761 01c0 01       		.byte	1
 7762 01c1 01       		.byte	1
 7763 01c2 00       		.byte	0
 7764 01c3 00000000 		.space	5
 7764      00
 7765 01c8 00       		.byte	0
 7766 01c9 00       		.byte	0
 7767 01ca 02       		.byte	2
 7768 01cb 00       		.byte	0
 7769 01cc 00       		.byte	0
 7770 01cd 64       		.byte	100
 7771 01ce 00       		.byte	0
 7772 01cf 01       		.byte	1
 7773 01d0 00       		.byte	0
 7774 01d1 03       		.byte	3
 7775 01d2 00       		.byte	0
 7776 01d3 00       		.byte	0
 7777 01d4 00       		.byte	0
 7778 01d5 00       		.byte	0
 7779 01d6 00       		.byte	0
 7780 01d7 30       		.byte	48
 7781 01d8 01       		.byte	1
 7782 01d9 00       		.byte	0
 7783 01da 00       		.byte	0
 7784 01db 00000000 		.space	5
 7784      00
 7785 01e0 07       		.byte	7
 7786 01e1 07       		.byte	7
 7787 01e2 02       		.byte	2
 7788 01e3 00       		.byte	0
 7789 01e4 00       		.byte	0
 7790 01e5 01       		.byte	1
 7791 01e6 00       		.byte	0
 7792 01e7 01       		.byte	1
 7793 01e8 00       		.byte	0
 7794 01e9 03       		.byte	3
 7795 01ea 00       		.byte	0
 7796 01eb 01       		.byte	1
 7797 01ec 00       		.byte	0
 7798 01ed 01       		.byte	1
 7799 01ee 00       		.byte	0
 7800 01ef 30       		.byte	48
 7801 01f0 01       		.byte	1
 7802 01f1 00       		.byte	0
 7803 01f2 00       		.byte	0
 7804 01f3 00000000 		.space	5
 7804      00
 7805 01f8 DF       		.byte	-33
 7806 01f9 E1       		.byte	-31
 7807 01fa 02       		.byte	2
 7808 01fb 00       		.byte	0
 7809 01fc 00       		.byte	0
 7810 01fd FF       		.byte	-1
 7811 01fe 00       		.byte	0
 7812 01ff 01       		.byte	1
 7813 0200 00       		.byte	0
 7814 0201 03       		.byte	3
 7815 0202 00       		.byte	0
 7816 0203 80       		.byte	-128
 7817 0204 00       		.byte	0
 7818 0205 00       		.byte	0
 7819 0206 00       		.byte	0
 7820 0207 C6       		.byte	-58
 7821 0208 01       		.byte	1
 7822 0209 01       		.byte	1
 7823 020a 00       		.byte	0
 7824 020b 00000000 		.space	5
 7824      00
 7825 0210 85       		.byte	-123
 7826 0211 86       		.byte	-122
 7827 0212 02       		.byte	2
 7828 0213 00       		.byte	0
 7829 0214 00       		.byte	0
 7830 0215 64       		.byte	100
 7831 0216 00       		.byte	0
 7832 0217 01       		.byte	1
 7833 0218 00       		.byte	0
 7834 0219 03       		.byte	3
 7835 021a 00       		.byte	0
 7836 021b 32       		.byte	50
 7837 021c 00       		.byte	0
 7838 021d 32       		.byte	50
 7839 021e 00       		.byte	0
 7840 021f F2       		.byte	-14
 7841 0220 01       		.byte	1
 7842 0221 01       		.byte	1
 7843 0222 00       		.byte	0
 7844 0223 00000000 		.space	5
 7844      00
 7845 0228 06       		.byte	6
 7846 0229 06       		.byte	6
 7847 022a 02       		.byte	2
 7848 022b 00       		.byte	0
 7849 022c 00       		.byte	0
 7850 022d 40       		.byte	64
 7851 022e 00       		.byte	0
 7852 022f 01       		.byte	1
 7853 0230 00       		.byte	0
 7854 0231 03       		.byte	3
 7855 0232 00       		.byte	0
 7856 0233 20       		.byte	32
 7857 0234 00       		.byte	0
 7858 0235 20       		.byte	32
 7859 0236 00       		.byte	0
 7860 0237 30       		.byte	48
 7861 0238 01       		.byte	1
 7862 0239 01       		.byte	1
 7863 023a 00       		.byte	0
 7864 023b 00000000 		.space	5
 7864      00
 7865 0240 00       		.byte	0
 7866 0241 00       		.byte	0
 7867 0242 02       		.byte	2
 7868 0243 00       		.byte	0
 7869 0244 00       		.byte	0
 7870 0245 64       		.byte	100
 7871 0246 00       		.byte	0
 7872 0247 01       		.byte	1
 7873 0248 00       		.byte	0
 7874 0249 03       		.byte	3
 7875 024a 00       		.byte	0
 7876 024b 00       		.byte	0
 7877 024c 00       		.byte	0
 7878 024d 00       		.byte	0
 7879 024e 00       		.byte	0
 7880 024f 30       		.byte	48
 7881 0250 01       		.byte	1
 7882 0251 00       		.byte	0
 7883 0252 00       		.byte	0
 7884 0253 00000000 		.space	5
 7884      00
 7885 0258 08       		.byte	8
 7886 0259 08       		.byte	8
 7887 025a 02       		.byte	2
 7888 025b 00       		.byte	0
 7889 025c 00       		.byte	0
 7890 025d 05       		.byte	5
 7891 025e 00       		.byte	0
 7892 025f 01       		.byte	1
 7893 0260 00       		.byte	0
 7894 0261 03       		.byte	3
 7895 0262 00       		.byte	0
 7896 0263 00       		.byte	0
 7897 0264 00       		.byte	0
 7898 0265 00       		.byte	0
 7899 0266 00       		.byte	0
 7900 0267 30       		.byte	48
 7901 0268 01       		.byte	1
 7902 0269 00       		.byte	0
 7903 026a 00       		.byte	0
 7904 026b 00000000 		.space	5
 7904      00
 7905 0270 00       		.byte	0
 7906 0271 00       		.byte	0
 7907 0272 02       		.byte	2
 7908 0273 00       		.byte	0
 7909 0274 00       		.byte	0
 7910 0275 40       		.byte	64
 7911 0276 00       		.byte	0
 7912 0277 01       		.byte	1
 7913 0278 00       		.byte	0
 7914 0279 03       		.byte	3
 7915 027a 00       		.byte	0
 7916 027b 00       		.byte	0
 7917 027c 00       		.byte	0
 7918 027d 00       		.byte	0
 7919 027e 00       		.byte	0
 7920 027f 30       		.byte	48
 7921 0280 01       		.byte	1
 7922 0281 00       		.byte	0
 7923 0282 00       		.byte	0
 7924 0283 00000000 		.space	5
 7924      00
 7925 0288 09       		.byte	9
 7926 0289 0A       		.byte	10
 7927 028a 04       		.byte	4
 7928 028b 00       		.byte	0
 7929 028c 00       		.byte	0
 7930 028d 40       		.byte	64
 7931 028e 00       		.byte	0
 7932 028f 01       		.byte	1
 7933 0290 00       		.byte	0
 7934 0291 03       		.byte	3
 7935 0292 00       		.byte	0
 7936 0293 20       		.byte	32
 7937 0294 38       		.byte	56
 7938 0295 20       		.byte	32
 7939 0296 38       		.byte	56
 7940 0297 30       		.byte	48
 7941 0298 01       		.byte	1
 7942 0299 00       		.byte	0
 7943 029a 00       		.byte	0
 7944 029b 00000000 		.space	5
 7944      00
 7945 02a0 00       		.byte	0
 7946 02a1 00       		.byte	0
 7947 02a2 02       		.byte	2
 7948 02a3 00       		.byte	0
 7949 02a4 00       		.byte	0
 7950 02a5 64       		.byte	100
 7951 02a6 00       		.byte	0
 7952 02a7 01       		.byte	1
 7953 02a8 00       		.byte	0
 7954 02a9 03       		.byte	3
 7955 02aa 00       		.byte	0
 7956 02ab 00       		.byte	0
 7957 02ac 00       		.byte	0
 7958 02ad 00       		.byte	0
 7959 02ae 00       		.byte	0
 7960 02af 30       		.byte	48
 7961 02b0 01       		.byte	1
 7962 02b1 00       		.byte	0
 7963 02b2 00       		.byte	0
 7964 02b3 00000000 		.space	5
 7964      00
 7965 02b8 00       		.byte	0
 7966 02b9 00       		.byte	0
 7967 02ba 02       		.byte	2
 7968 02bb 00       		.byte	0
 7969 02bc 00       		.byte	0
 7970 02bd 64       		.byte	100
 7971 02be 00       		.byte	0
 7972 02bf 01       		.byte	1
 7973 02c0 00       		.byte	0
 7974 02c1 03       		.byte	3
 7975 02c2 00       		.byte	0
 7976 02c3 00       		.byte	0
 7977 02c4 00       		.byte	0
 7978 02c5 00       		.byte	0
 7979 02c6 00       		.byte	0
 7980 02c7 30       		.byte	48
 7981 02c8 01       		.byte	1
 7982 02c9 00       		.byte	0
 7983 02ca 00       		.byte	0
 7984 02cb 00000000 		.space	5
 7984      00
 7985 02d0 2A       		.byte	42
 7986 02d1 2A       		.byte	42
 7987 02d2 02       		.byte	2
 7988 02d3 00       		.byte	0
 7989 02d4 00       		.byte	0
 7990 02d5 1B       		.byte	27
 7991 02d6 00       		.byte	0
 7992 02d7 01       		.byte	1
 7993 02d8 00       		.byte	0
 7994 02d9 03       		.byte	3
 7995 02da 00       		.byte	0
 7996 02db 00       		.byte	0
 7997 02dc 00       		.byte	0
 7998 02dd 00       		.byte	0
 7999 02de 00       		.byte	0
 8000 02df 30       		.byte	48
 8001 02e0 01       		.byte	1
 8002 02e1 00       		.byte	0
 8003 02e2 00       		.byte	0
 8004 02e3 00000000 		.space	5
 8004      00
 8005 02e8 00       		.byte	0
 8006 02e9 00       		.byte	0
 8007 02ea 02       		.byte	2
 8008 02eb 00       		.byte	0
 8009 02ec 00       		.byte	0
 8010 02ed 64       		.byte	100
 8011 02ee 00       		.byte	0
 8012 02ef 01       		.byte	1
 8013 02f0 00       		.byte	0
 8014 02f1 03       		.byte	3
 8015 02f2 00       		.byte	0
 8016 02f3 00       		.byte	0
 8017 02f4 00       		.byte	0
 8018 02f5 00       		.byte	0
 8019 02f6 00       		.byte	0
 8020 02f7 30       		.byte	48
 8021 02f8 01       		.byte	1
 8022 02f9 00       		.byte	0
 8023 02fa 00       		.byte	0
 8024 02fb 00000000 		.space	5
 8024      00
 8025 0300 00       		.byte	0
 8026 0301 00       		.byte	0
 8027 0302 02       		.byte	2
 8028 0303 00       		.byte	0
 8029 0304 00       		.byte	0
 8030 0305 12       		.byte	18
 8031 0306 00       		.byte	0
 8032 0307 01       		.byte	1
 8033 0308 00       		.byte	0
 8034 0309 03       		.byte	3
 8035 030a 00       		.byte	0
 8036 030b 00       		.byte	0
 8037 030c 00       		.byte	0
 8038 030d 00       		.byte	0
 8039 030e 00       		.byte	0
 8040 030f 30       		.byte	48
 8041 0310 01       		.byte	1
 8042 0311 00       		.byte	0
 8043 0312 00       		.byte	0
 8044 0313 00000000 		.space	5
 8044      00
 8045 0318 01       		.byte	1
 8046 0319 01       		.byte	1
 8047 031a 02       		.byte	2
 8048 031b 00       		.byte	0
 8049 031c 00       		.byte	0
 8050 031d 09       		.byte	9
 8051 031e 00       		.byte	0
 8052 031f 01       		.byte	1
 8053 0320 00       		.byte	0
 8054 0321 03       		.byte	3
 8055 0322 00       		.byte	0
 8056 0323 00       		.byte	0
 8057 0324 00       		.byte	0
 8058 0325 01       		.byte	1
 8059 0326 00       		.byte	0
 8060 0327 30       		.byte	48
 8061 0328 01       		.byte	1
 8062 0329 00       		.byte	0
 8063 032a 00       		.byte	0
 8064 032b 00000000 		.space	5
 8064      00
 8065 0330 05       		.byte	5
 8066 0331 05       		.byte	5
 8067 0332 02       		.byte	2
 8068 0333 00       		.byte	0
 8069 0334 00       		.byte	0
 8070 0335 03       		.byte	3
 8071 0336 00       		.byte	0
 8072 0337 01       		.byte	1
 8073 0338 00       		.byte	0
 8074 0339 03       		.byte	3
 8075 033a 00       		.byte	0
 8076 033b 00       		.byte	0
 8077 033c 00       		.byte	0
 8078 033d 02       		.byte	2
 8079 033e 00       		.byte	0
 8080 033f 30       		.byte	48
 8081 0340 01       		.byte	1
 8082 0341 00       		.byte	0
 8083 0342 00       		.byte	0
 8084 0343 00000000 		.space	5
 8084      00
 8085 0348 18       		.byte	24
 8086 0349 18       		.byte	24
 8087 034a 02       		.byte	2
 8088 034b 00       		.byte	0
 8089 034c 00       		.byte	0
 8090 034d 01       		.byte	1
 8091 034e 00       		.byte	0
 8092 034f 01       		.byte	1
 8093 0350 00       		.byte	0
 8094 0351 03       		.byte	3
 8095 0352 00       		.byte	0
 8096 0353 00       		.byte	0
 8097 0354 00       		.byte	0
 8098 0355 00       		.byte	0
 8099 0356 00       		.byte	0
 8100 0357 30       		.byte	48
 8101 0358 01       		.byte	1
 8102 0359 00       		.byte	0
 8103 035a 00       		.byte	0
 8104 035b 00000000 		.space	5
 8104      00
 8105 0360 19       		.byte	25
 8106 0361 19       		.byte	25
 8107 0362 01       		.byte	1
 8108 0363 00       		.byte	0
 8109 0364 00       		.byte	0
 8110 0365 40       		.byte	64
 8111 0366 00       		.byte	0
 8112 0367 01       		.byte	1
 8113 0368 00       		.byte	0
 8114 0369 03       		.byte	3
 8115 036a 00       		.byte	0
 8116 036b 20       		.byte	32
 8117 036c 00       		.byte	0
 8118 036d 20       		.byte	32
 8119 036e 00       		.byte	0
 8120 036f 30       		.byte	48
 8121 0370 01       		.byte	1
 8122 0371 00       		.byte	0
 8123 0372 00       		.byte	0
 8124 0373 00000000 		.space	5
 8124      00
 8125 0378 20       		.byte	32
 8126 0379 20       		.byte	32
 8127 037a 02       		.byte	2
 8128 037b 00       		.byte	0
 8129 037c 00       		.byte	0
 8130 037d 02       		.byte	2
 8131 037e 00       		.byte	0
 8132 037f 01       		.byte	1
 8133 0380 00       		.byte	0
 8134 0381 03       		.byte	3
 8135 0382 00       		.byte	0
 8136 0383 00       		.byte	0
 8137 0384 00       		.byte	0
 8138 0385 00       		.byte	0
 8139 0386 00       		.byte	0
 8140 0387 30       		.byte	48
 8141 0388 01       		.byte	1
 8142 0389 00       		.byte	0
 8143 038a 00       		.byte	0
 8144 038b 00000000 		.space	5
 8144      00
 8145 0390 22       		.byte	34
 8146 0391 22       		.byte	34
 8147 0392 02       		.byte	2
 8148 0393 00       		.byte	0
 8149 0394 00       		.byte	0
 8150 0395 3F       		.byte	63
 8151 0396 00       		.byte	0
 8152 0397 01       		.byte	1
 8153 0398 00       		.byte	0
 8154 0399 03       		.byte	3
 8155 039a 00       		.byte	0
 8156 039b 00       		.byte	0
 8157 039c 00       		.byte	0
 8158 039d 00       		.byte	0
 8159 039e 00       		.byte	0
 8160 039f 30       		.byte	48
 8161 03a0 01       		.byte	1
 8162 03a1 00       		.byte	0
 8163 03a2 00       		.byte	0
 8164 03a3 00000000 		.space	5
 8164      00
 8165 03a8 23       		.byte	35
 8166 03a9 23       		.byte	35
 8167 03aa 02       		.byte	2
 8168 03ab 00       		.byte	0
 8169 03ac 00       		.byte	0
 8170 03ad 64       		.byte	100
 8171 03ae 00       		.byte	0
 8172 03af 01       		.byte	1
 8173 03b0 00       		.byte	0
 8174 03b1 03       		.byte	3
 8175 03b2 00       		.byte	0
 8176 03b3 10       		.byte	16
 8177 03b4 00       		.byte	0
 8178 03b5 10       		.byte	16
 8179 03b6 00       		.byte	0
 8180 03b7 30       		.byte	48
 8181 03b8 01       		.byte	1
 8182 03b9 00       		.byte	0
 8183 03ba 00       		.byte	0
 8184 03bb 00000000 		.space	5
 8184      00
 8185 03c0 24       		.byte	36
 8186 03c1 24       		.byte	36
 8187 03c2 02       		.byte	2
 8188 03c3 00       		.byte	0
 8189 03c4 00       		.byte	0
 8190 03c5 64       		.byte	100
 8191 03c6 00       		.byte	0
 8192 03c7 01       		.byte	1
 8193 03c8 00       		.byte	0
 8194 03c9 03       		.byte	3
 8195 03ca 00       		.byte	0
 8196 03cb 10       		.byte	16
 8197 03cc 00       		.byte	0
 8198 03cd 10       		.byte	16
 8199 03ce 00       		.byte	0
 8200 03cf 30       		.byte	48
 8201 03d0 01       		.byte	1
 8202 03d1 00       		.byte	0
 8203 03d2 00       		.byte	0
 8204 03d3 00000000 		.space	5
 8204      00
 8205 03d8 02       		.byte	2
 8206 03d9 03       		.byte	3
 8207 03da 04       		.byte	4
 8208 03db 00       		.byte	0
 8209 03dc 00       		.byte	0
 8210 03dd 7F       		.byte	127
 8211 03de 00       		.byte	0
 8212 03df 01       		.byte	1
 8213 03e0 00       		.byte	0
 8214 03e1 03       		.byte	3
 8215 03e2 00       		.byte	0
 8216 03e3 00       		.byte	0
 8217 03e4 20       		.byte	32
 8218 03e5 00       		.byte	0
 8219 03e6 20       		.byte	32
 8220 03e7 30       		.byte	48
 8221 03e8 01       		.byte	1
 8222 03e9 00       		.byte	0
 8223 03ea 00       		.byte	0
 8224 03eb 00000000 		.space	5
 8224      00
 8225 03f0 04       		.byte	4
 8226 03f1 04       		.byte	4
 8227 03f2 02       		.byte	2
 8228 03f3 00       		.byte	0
 8229 03f4 00       		.byte	0
 8230 03f5 40       		.byte	64
 8231 03f6 00       		.byte	0
 8232 03f7 01       		.byte	1
 8233 03f8 00       		.byte	0
 8234 03f9 03       		.byte	3
 8235 03fa 00       		.byte	0
 8236 03fb 20       		.byte	32
 8237 03fc 00       		.byte	0
 8238 03fd 20       		.byte	32
 8239 03fe 00       		.byte	0
 8240 03ff 30       		.byte	48
 8241 0400 01       		.byte	1
 8242 0401 00       		.byte	0
 8243 0402 00       		.byte	0
 8244 0403 00000000 		.space	5
 8244      00
 8245 0408 00       		.byte	0
 8246 0409 00       		.byte	0
 8247 040a 02       		.byte	2
 8248 040b 00       		.byte	0
 8249 040c 00       		.byte	0
 8250 040d 19       		.byte	25
 8251 040e 00       		.byte	0
 8252 040f 01       		.byte	1
 8253 0410 00       		.byte	0
 8254 0411 03       		.byte	3
 8255 0412 00       		.byte	0
 8256 0413 00       		.byte	0
 8257 0414 00       		.byte	0
 8258 0415 00       		.byte	0
 8259 0416 00       		.byte	0
 8260 0417 30       		.byte	48
 8261 0418 01       		.byte	1
 8262 0419 00       		.byte	0
 8263 041a 00       		.byte	0
 8264 041b 00000000 		.space	5
 8264      00
 8265 0420 10       		.byte	16
 8266 0421 10       		.byte	16
 8267 0422 02       		.byte	2
 8268 0423 00       		.byte	0
 8269 0424 00       		.byte	0
 8270 0425 06       		.byte	6
 8271 0426 00       		.byte	0
 8272 0427 01       		.byte	1
 8273 0428 00       		.byte	0
 8274 0429 03       		.byte	3
 8275 042a 00       		.byte	0
 8276 042b 03       		.byte	3
 8277 042c 00       		.byte	0
 8278 042d 03       		.byte	3
 8279 042e 00       		.byte	0
 8280 042f 30       		.byte	48
 8281 0430 01       		.byte	1
 8282 0431 00       		.byte	0
 8283 0432 00       		.byte	0
 8284 0433 00000000 		.space	5
 8284      00
 8285 0438 00       		.byte	0
 8286 0439 00       		.byte	0
 8287 043a 02       		.byte	2
 8288 043b 00       		.byte	0
 8289 043c 00       		.byte	0
 8290 043d 03       		.byte	3
 8291 043e 00       		.byte	0
 8292 043f 01       		.byte	1
 8293 0440 00       		.byte	0
 8294 0441 03       		.byte	3
 8295 0442 00       		.byte	0
 8296 0443 00       		.byte	0
 8297 0444 00       		.byte	0
 8298 0445 00       		.byte	0
 8299 0446 00       		.byte	0
 8300 0447 30       		.byte	48
 8301 0448 01       		.byte	1
 8302 0449 00       		.byte	0
 8303 044a 00       		.byte	0
 8304 044b 00000000 		.space	5
 8304      00
 8305 0450 50       		.byte	80
 8306 0451 50       		.byte	80
 8307 0452 01       		.byte	1
 8308 0453 00       		.byte	0
 8309 0454 00       		.byte	0
 8310 0455 03       		.byte	3
 8311 0456 00       		.byte	0
 8312 0457 01       		.byte	1
 8313 0458 00       		.byte	0
 8314 0459 03       		.byte	3
 8315 045a 00       		.byte	0
 8316 045b 00       		.byte	0
 8317 045c 00       		.byte	0
 8318 045d 00       		.byte	0
 8319 045e 00       		.byte	0
 8320 045f 30       		.byte	48
 8321 0460 01       		.byte	1
 8322 0461 00       		.byte	0
 8323 0462 00       		.byte	0
 8324 0463 00000000 		.space	5
 8324      00
 8325 0468 00       		.byte	0
 8326 0469 00       		.byte	0
 8327 046a 0B       		.byte	11
 8328 046b 00       		.byte	0
 8329 046c 00       		.byte	0
 8330 046d FF       		.byte	-1
 8331 046e FF       		.byte	-1
 8332 046f 01       		.byte	1
 8333 0470 00       		.byte	0
 8334 0471 03       		.byte	3
 8335 0472 00       		.byte	0
 8336 0473 00       		.byte	0
 8337 0474 00       		.byte	0
 8338 0475 00       		.byte	0
 8339 0476 00       		.byte	0
 8340 0477 00       		.byte	0
 8341 0478 01       		.byte	1
 8342 0479 00       		.byte	0
 8343 047a 00       		.byte	0
 8344 047b 00000000 		.space	5
 8344      00
 8347              	glUVCHeader:
 8348 0480 0C       		.byte	12
 8349 0481 8C       		.byte	-116
 8350 0482 00       		.byte	0
 8351 0483 00       		.byte	0
 8352 0484 00       		.byte	0
 8353 0485 00       		.byte	0
 8354 0486 00       		.byte	0
 8355 0487 00       		.byte	0
 8356 0488 00       		.byte	0
 8357 0489 00       		.byte	0
 8358 048a 00       		.byte	0
 8359 048b 00       		.byte	0
 8362              	WBMenuCmpArry:
 8363 048c 20       		.byte	32
 8364 048d 0F       		.byte	15
 8365 048e 38       		.byte	56
 8366 048f F0       		.byte	-16
 8369              	CTCtrlParArry:
 8370 0490 00       		.byte	0
 8371 0491 00       		.byte	0
 8372 0492 01       		.byte	1
 8373 0493 00       		.byte	0
 8374 0494 00       		.byte	0
 8375 0495 03       		.byte	3
 8376 0496 00       		.byte	0
 8377 0497 01       		.byte	1
 8378 0498 00       		.byte	0
 8379 0499 03       		.byte	3
 8380 049a 00       		.byte	0
 8381 049b 03       		.byte	3
 8382 049c 00       		.byte	0
 8383 049d 03       		.byte	3
 8384 049e 00       		.byte	0
 8385 049f 30       		.byte	48
 8386 04a0 01       		.byte	1
 8387 04a1 00       		.byte	0
 8388 04a2 00       		.byte	0
 8389 04a3 00000000 		.space	5
 8389      00
 8390 04a8 00       		.byte	0
 8391 04a9 00       		.byte	0
 8392 04aa 01       		.byte	1
 8393 04ab 01       		.byte	1
 8394 04ac 00       		.byte	0
 8395 04ad 0F       		.byte	15
 8396 04ae 00       		.byte	0
 8397 04af 0F       		.byte	15
 8398 04b0 00       		.byte	0
 8399 04b1 03       		.byte	3
 8400 04b2 00       		.byte	0
 8401 04b3 02       		.byte	2
 8402 04b4 00       		.byte	0
 8403 04b5 02       		.byte	2
 8404 04b6 00       		.byte	0
 8405 04b7 30       		.byte	48
 8406 04b8 01       		.byte	1
 8407 04b9 01       		.byte	1
 8408 04ba 00       		.byte	0
 8409 04bb 00000000 		.space	5
 8409      00
 8410 04c0 02       		.byte	2
 8411 04c1 00       		.byte	0
 8412 04c2 01       		.byte	1
 8413 04c3 00       		.byte	0
 8414 04c4 00       		.byte	0
 8415 04c5 01       		.byte	1
 8416 04c6 00       		.byte	0
 8417 04c7 01       		.byte	1
 8418 04c8 00       		.byte	0
 8419 04c9 03       		.byte	3
 8420 04ca 00       		.byte	0
 8421 04cb 00       		.byte	0
 8422 04cc 00       		.byte	0
 8423 04cd 00       		.byte	0
 8424 04ce 00       		.byte	0
 8425 04cf 30       		.byte	48
 8426 04d0 01       		.byte	1
 8427 04d1 01       		.byte	1
 8428 04d2 00       		.byte	0
 8429 04d3 00000000 		.space	5
 8429      00
 8430 04d8 00       		.byte	0
 8431 04d9 00       		.byte	0
 8432 04da 04       		.byte	4
 8433 04db 01       		.byte	1
 8434 04dc 00       		.byte	0
 8435 04dd 38       		.byte	56
 8436 04de 01       		.byte	1
 8437 04df 01       		.byte	1
 8438 04e0 00       		.byte	0
 8439 04e1 03       		.byte	3
 8440 04e2 00       		.byte	0
 8441 04e3 4E       		.byte	78
 8442 04e4 00       		.byte	0
 8443 04e5 4E       		.byte	78
 8444 04e6 00       		.byte	0
 8445 04e7 30       		.byte	48
 8446 04e8 01       		.byte	1
 8447 04e9 00       		.byte	0
 8448 04ea 00       		.byte	0
 8449 04eb 00000000 		.space	5
 8449      00
 8450 04f0 04       		.byte	4
 8451 04f1 00       		.byte	0
 8452 04f2 01       		.byte	1
 8453 04f3 00       		.byte	0
 8454 04f4 00       		.byte	0
 8455 04f5 00       		.byte	0
 8456 04f6 00       		.byte	0
 8457 04f7 01       		.byte	1
 8458 04f8 00       		.byte	0
 8459 04f9 03       		.byte	3
 8460 04fa 00       		.byte	0
 8461 04fb 00       		.byte	0
 8462 04fc 00       		.byte	0
 8463 04fd 00       		.byte	0
 8464 04fe 00       		.byte	0
 8465 04ff 30       		.byte	48
 8466 0500 01       		.byte	1
 8467 0501 00       		.byte	0
 8468 0502 00       		.byte	0
 8469 0503 00000000 		.space	5
 8469      00
 8470 0508 05       		.byte	5
 8471 0509 00       		.byte	0
 8472 050a 02       		.byte	2
 8473 050b 00       		.byte	0
 8474 050c 00       		.byte	0
 8475 050d FF       		.byte	-1
 8476 050e 00       		.byte	0
 8477 050f 01       		.byte	1
 8478 0510 00       		.byte	0
 8479 0511 03       		.byte	3
 8480 0512 00       		.byte	0
 8481 0513 01       		.byte	1
 8482 0514 00       		.byte	0
 8483 0515 00       		.byte	0
 8484 0516 00       		.byte	0
 8485 0517 30       		.byte	48
 8486 0518 01       		.byte	1
 8487 0519 01       		.byte	1
 8488 051a 00       		.byte	0
 8489 051b 00000000 		.space	5
 8489      00
 8490 0520 06       		.byte	6
 8491 0521 00       		.byte	0
 8492 0522 02       		.byte	2
 8493 0523 00       		.byte	0
 8494 0524 00       		.byte	0
 8495 0525 00       		.byte	0
 8496 0526 00       		.byte	0
 8497 0527 00       		.byte	0
 8498 0528 00       		.byte	0
 8499 0529 03       		.byte	3
 8500 052a 00       		.byte	0
 8501 052b 00       		.byte	0
 8502 052c 00       		.byte	0
 8503 052d 00       		.byte	0
 8504 052e 00       		.byte	0
 8505 052f 30       		.byte	48
 8506 0530 01       		.byte	1
 8507 0531 01       		.byte	1
 8508 0532 00       		.byte	0
 8509 0533 00000000 		.space	5
 8509      00
 8510 0538 23       		.byte	35
 8511 0539 00       		.byte	0
 8512 053a 02       		.byte	2
 8513 053b 00       		.byte	0
 8514 053c 00       		.byte	0
 8515 053d 30       		.byte	48
 8516 053e 00       		.byte	0
 8517 053f 01       		.byte	1
 8518 0540 00       		.byte	0
 8519 0541 03       		.byte	3
 8520 0542 0A       		.byte	10
 8521 0543 00       		.byte	0
 8522 0544 00       		.byte	0
 8523 0545 0A       		.byte	10
 8524 0546 00       		.byte	0
 8525 0547 30       		.byte	48
 8526 0548 01       		.byte	1
 8527 0549 01       		.byte	1
 8528 054a 00       		.byte	0
 8529 054b 00000000 		.space	5
 8529      00
 8530 0550 08       		.byte	8
 8531 0551 00       		.byte	0
 8532 0552 01       		.byte	1
 8533 0553 00       		.byte	0
 8534 0554 00       		.byte	0
 8535 0555 7F       		.byte	127
 8536 0556 00       		.byte	0
 8537 0557 01       		.byte	1
 8538 0558 00       		.byte	0
 8539 0559 03       		.byte	3
 8540 055a 00       		.byte	0
 8541 055b 00       		.byte	0
 8542 055c 00       		.byte	0
 8543 055d 00       		.byte	0
 8544 055e 00       		.byte	0
 8545 055f 30       		.byte	48
 8546 0560 01       		.byte	1
 8547 0561 00       		.byte	0
 8548 0562 00       		.byte	0
 8549 0563 00000000 		.space	5
 8549      00
 8550 0568 09       		.byte	9
 8551 0569 00       		.byte	0
 8552 056a 02       		.byte	2
 8553 056b 00       		.byte	0
 8554 056c 00       		.byte	0
 8555 056d 05       		.byte	5
 8556 056e 00       		.byte	0
 8557 056f 01       		.byte	1
 8558 0570 00       		.byte	0
 8559 0571 03       		.byte	3
 8560 0572 00       		.byte	0
 8561 0573 00       		.byte	0
 8562 0574 00       		.byte	0
 8563 0575 00       		.byte	0
 8564 0576 00       		.byte	0
 8565 0577 30       		.byte	48
 8566 0578 01       		.byte	1
 8567 0579 00       		.byte	0
 8568 057a 00       		.byte	0
 8569 057b 00000000 		.space	5
 8569      00
 8570 0580 10       		.byte	16
 8571 0581 00       		.byte	0
 8572 0582 03       		.byte	3
 8573 0583 00       		.byte	0
 8574 0584 00       		.byte	0
 8575 0585 00       		.byte	0
 8576 0586 00       		.byte	0
 8577 0587 00       		.byte	0
 8578 0588 00       		.byte	0
 8579 0589 03       		.byte	3
 8580 058a 00       		.byte	0
 8581 058b 00       		.byte	0
 8582 058c 00       		.byte	0
 8583 058d 00       		.byte	0
 8584 058e 00       		.byte	0
 8585 058f 30       		.byte	48
 8586 0590 01       		.byte	1
 8587 0591 00       		.byte	0
 8588 0592 00       		.byte	0
 8589 0593 00000000 		.space	5
 8589      00
 8590 0598 00       		.byte	0
 8591 0599 00       		.byte	0
 8592 059a 02       		.byte	2
 8593 059b 00       		.byte	0
 8594 059c 00       		.byte	0
 8595 059d 40       		.byte	64
 8596 059e 00       		.byte	0
 8597 059f 01       		.byte	1
 8598 05a0 00       		.byte	0
 8599 05a1 03       		.byte	3
 8600 05a2 00       		.byte	0
 8601 05a3 0F       		.byte	15
 8602 05a4 11       		.byte	17
 8603 05a5 00       		.byte	0
 8604 05a6 00       		.byte	0
 8605 05a7 30       		.byte	48
 8606 05a8 01       		.byte	1
 8607 05a9 00       		.byte	0
 8608 05aa 00       		.byte	0
 8609 05ab 00000000 		.space	5
 8609      00
 8610 05b0 00       		.byte	0
 8611 05b1 00       		.byte	0
 8612 05b2 02       		.byte	2
 8613 05b3 00       		.byte	0
 8614 05b4 00       		.byte	0
 8615 05b5 64       		.byte	100
 8616 05b6 00       		.byte	0
 8617 05b7 01       		.byte	1
 8618 05b8 00       		.byte	0
 8619 05b9 03       		.byte	3
 8620 05ba 00       		.byte	0
 8621 05bb 00       		.byte	0
 8622 05bc 00       		.byte	0
 8623 05bd 00       		.byte	0
 8624 05be 00       		.byte	0
 8625 05bf 30       		.byte	48
 8626 05c0 01       		.byte	1
 8627 05c1 00       		.byte	0
 8628 05c2 00       		.byte	0
 8629 05c3 00000000 		.space	5
 8629      00
 8630 05c8 00       		.byte	0
 8631 05c9 00       		.byte	0
 8632 05ca 02       		.byte	2
 8633 05cb 00       		.byte	0
 8634 05cc 00       		.byte	0
 8635 05cd 64       		.byte	100
 8636 05ce 00       		.byte	0
 8637 05cf 01       		.byte	1
 8638 05d0 00       		.byte	0
 8639 05d1 03       		.byte	3
 8640 05d2 00       		.byte	0
 8641 05d3 00       		.byte	0
 8642 05d4 00       		.byte	0
 8643 05d5 00       		.byte	0
 8644 05d6 00       		.byte	0
 8645 05d7 30       		.byte	48
 8646 05d8 01       		.byte	1
 8647 05d9 00       		.byte	0
 8648 05da 00       		.byte	0
 8649 05db 00000000 		.space	5
 8649      00
 8650 05e0 00       		.byte	0
 8651 05e1 00       		.byte	0
 8652 05e2 02       		.byte	2
 8653 05e3 00       		.byte	0
 8654 05e4 00       		.byte	0
 8655 05e5 64       		.byte	100
 8656 05e6 00       		.byte	0
 8657 05e7 01       		.byte	1
 8658 05e8 00       		.byte	0
 8659 05e9 03       		.byte	3
 8660 05ea 00       		.byte	0
 8661 05eb 00       		.byte	0
 8662 05ec 00       		.byte	0
 8663 05ed 00       		.byte	0
 8664 05ee 00       		.byte	0
 8665 05ef 30       		.byte	48
 8666 05f0 01       		.byte	1
 8667 05f1 00       		.byte	0
 8668 05f2 00       		.byte	0
 8669 05f3 00000000 		.space	5
 8669      00
 8670 05f8 00       		.byte	0
 8671 05f9 00       		.byte	0
 8672 05fa 02       		.byte	2
 8673 05fb 00       		.byte	0
 8674 05fc 00       		.byte	0
 8675 05fd 64       		.byte	100
 8676 05fe 00       		.byte	0
 8677 05ff 01       		.byte	1
 8678 0600 00       		.byte	0
 8679 0601 03       		.byte	3
 8680 0602 00       		.byte	0
 8681 0603 00       		.byte	0
 8682 0604 00       		.byte	0
 8683 0605 00       		.byte	0
 8684 0606 00       		.byte	0
 8685 0607 30       		.byte	48
 8686 0608 01       		.byte	1
 8687 0609 00       		.byte	0
 8688 060a 00       		.byte	0
 8689 060b 00000000 		.space	5
 8689      00
 8692              	glProbeCtrlFull:
 8693 0610 00       		.byte	0
 8694 0611 00       		.byte	0
 8695 0612 01       		.byte	1
 8696 0613 01       		.byte	1
 8697 0614 15       		.byte	21
 8698 0615 16       		.byte	22
 8699 0616 05       		.byte	5
 8700 0617 00       		.byte	0
 8701 0618 00       		.byte	0
 8702 0619 00       		.byte	0
 8703 061a 00       		.byte	0
 8704 061b 00       		.byte	0
 8705 061c 00       		.byte	0
 8706 061d 00       		.byte	0
 8707 061e 00       		.byte	0
 8708 061f 00       		.byte	0
 8709 0620 00       		.byte	0
 8710 0621 00       		.byte	0
 8711 0622 00       		.byte	0
 8712 0623 C6       		.byte	-58
 8713 0624 99       		.byte	-103
 8714 0625 00       		.byte	0
 8715 0626 00       		.byte	0
 8716 0627 40       		.byte	64
 8717 0628 00       		.byte	0
 8718 0629 00       		.byte	0
 8719 062a 0000     		.space	2
 8722              	glProbeCtrl20:
 8723 062c 00       		.byte	0
 8724 062d 00       		.byte	0
 8725 062e 01       		.byte	1
 8726 062f 01       		.byte	1
 8727 0630 80       		.byte	-128
 8728 0631 1A       		.byte	26
 8729 0632 06       		.byte	6
 8730 0633 00       		.byte	0
 8731 0634 00       		.byte	0
 8732 0635 00       		.byte	0
 8733 0636 00       		.byte	0
 8734 0637 00       		.byte	0
 8735 0638 00       		.byte	0
 8736 0639 00       		.byte	0
 8737 063a 00       		.byte	0
 8738 063b 00       		.byte	0
 8739 063c 00       		.byte	0
 8740 063d 00       		.byte	0
 8741 063e 00       		.byte	0
 8742 063f D2       		.byte	-46
 8743 0640 0F       		.byte	15
 8744 0641 00       		.byte	0
 8745 0642 00       		.byte	0
 8746 0643 40       		.byte	64
 8747 0644 00       		.byte	0
 8748 0645 00       		.byte	0
 8749 0646 0000     		.space	2
 8752              	glProbeCtrl:
 8753 0648 00       		.byte	0
 8754 0649 00       		.byte	0
 8755 064a 01       		.byte	1
 8756 064b 01       		.byte	1
 8757 064c 15       		.byte	21
 8758 064d 16       		.byte	22
 8759 064e 05       		.byte	5
 8760 064f 00       		.byte	0
 8761 0650 00       		.byte	0
 8762 0651 00       		.byte	0
 8763 0652 00       		.byte	0
 8764 0653 00       		.byte	0
 8765 0654 00       		.byte	0
 8766 0655 00       		.byte	0
 8767 0656 00       		.byte	0
 8768 0657 00       		.byte	0
 8769 0658 00       		.byte	0
 8770 0659 00       		.byte	0
 8771 065a 00       		.byte	0
 8772 065b 48       		.byte	72
 8773 065c 3F       		.byte	63
 8774 065d 00       		.byte	0
 8775 065e 00       		.byte	0
 8776 065f 40       		.byte	64
 8777 0660 00       		.byte	0
 8778 0661 00       		.byte	0
 8779 0662 0000     		.space	2
 8782              	glProbeStilCtrl:
 8783 0664 01       		.byte	1
 8784 0665 02       		.byte	2
 8785 0666 00       		.byte	0
 8786 0667 00       		.byte	0
 8787 0668 C6       		.byte	-58
 8788 0669 99       		.byte	-103
 8789 066a 00       		.byte	0
 8790 066b 00       		.byte	0
 8791 066c 40       		.byte	64
 8792 066d 00       		.byte	0
 8793 066e 00       		.byte	0
 8794 066f 00       		.space	1
 8797              	glProbeStilCtrl20:
 8798 0670 01       		.byte	1
 8799 0671 01       		.byte	1
 8800 0672 00       		.byte	0
 8801 0673 00       		.byte	0
 8802 0674 D2       		.byte	-46
 8803 0675 0F       		.byte	15
 8804 0676 00       		.byte	0
 8805 0677 00       		.byte	0
 8806 0678 40       		.byte	64
 8807 0679 00       		.byte	0
 8808 067a 00       		.byte	0
 8811              	snapButFlag:
 8812 067b 01       		.byte	1
 8815              	CyFxGpifTransition:
 8816 067c 0000     		.short	0
 8817 067e 5555     		.short	21845
 8818 0680 8888     		.short	-30584
 8819 0682 AAAA     		.short	-21846
 8820 0684 3333     		.short	13107
 8821 0686 0000     		.space	2
 8824              	CyFxGpifWavedata:
 8825 0688 0181731E 		.word	510886145
 8826 068c 00000000 		.word	0
 8827 0690 00000080 		.word	-2147483648
 8828 0694 00000000 		.word	0
 8829 0698 00000000 		.word	0
 8830 069c 00000000 		.word	0
 8831 06a0 0201702E 		.word	779092226
 8832 06a4 00010000 		.word	256
 8833 06a8 A0000080 		.word	-2147483488
 8834 06ac 00000000 		.word	0
 8835 06b0 00000000 		.word	0
 8836 06b4 00000000 		.word	0
 8837 06b8 0380722E 		.word	779255811
 8838 06bc 02010020 		.word	536871170
 8839 06c0 60000080 		.word	-2147483552
 8840 06c4 00000000 		.word	0
 8841 06c8 00000000 		.word	0
 8842 06cc 00000000 		.word	0
 8843 06d0 0460722E 		.word	779247620
 8844 06d4 02010024 		.word	603980034
 8845 06d8 90000080 		.word	-2147483504
 8846 06dc 0594731E 		.word	510891013
 8847 06e0 06000000 		.word	6
 8848 06e4 00000080 		.word	-2147483648
 8849 06e8 0380722E 		.word	779255811
 8850 06ec 02010020 		.word	536871170
 8851 06f0 60000080 		.word	-2147483552
 8852 06f4 0693731E 		.word	510890758
 8853 06f8 06000000 		.word	6
 8854 06fc 00000080 		.word	-2147483648
 8855 0700 0720703E 		.word	1047535623
 8856 0704 08010000 		.word	264
 8857 0708 00000080 		.word	-2147483648
 8858 070c 0820703E 		.word	1047535624
 8859 0710 08010000 		.word	264
 8860 0714 00000080 		.word	-2147483648
 8861 0718 0920703E 		.word	1047535625
 8862 071c 08010000 		.word	264
 8863 0720 00000080 		.word	-2147483648
 8864 0724 0A20703E 		.word	1047535626
 8865 0728 08010000 		.word	264
 8866 072c 00000080 		.word	-2147483648
 8867 0730 0380722E 		.word	779255811
 8868 0734 02010020 		.word	536871170
 8869 0738 60000080 		.word	-2147483552
 8870 073c 0B000000 		.word	11
 8871 0740 00000000 		.word	0
 8872 0744 00010080 		.word	-2147483392
 8873 0748 0460722E 		.word	779247620
 8874 074c 02010024 		.word	603980034
 8875 0750 90000080 		.word	-2147483504
 8876 0754 0D000000 		.word	13
 8877 0758 00000000 		.word	0
 8878 075c 00010080 		.word	-2147483392
 8879 0760 0460722E 		.word	779247620
 8880 0764 02010024 		.word	603980034
 8881 0768 90000080 		.word	-2147483504
 8882 076c 0C000000 		.word	12
 8883 0770 00000000 		.word	0
 8884 0774 00010080 		.word	-2147483392
 8885 0778 0380722E 		.word	779255811
 8886 077c 02010020 		.word	536871170
 8887 0780 60000080 		.word	-2147483552
 8888 0784 0E000000 		.word	14
 8889 0788 00000000 		.word	0
 8890 078c 00010080 		.word	-2147483392
 8891 0790 00000000 		.word	0
 8892 0794 00000000 		.word	0
 8893 0798 00000000 		.word	0
 8894 079c 00000000 		.word	0
 8895 07a0 00000000 		.word	0
 8896 07a4 00000000 		.word	0
 8899              	CyFxGpifWavedataPosition:
 8900 07a8 00       		.byte	0
 8901 07a9 01       		.byte	1
 8902 07aa 02       		.byte	2
 8903 07ab 03       		.byte	3
 8904 07ac 04       		.byte	4
 8905 07ad 05       		.byte	5
 8906 07ae 06       		.byte	6
 8907 07af 07       		.byte	7
 8908 07b0 08       		.byte	8
 8909 07b1 09       		.byte	9
 8910 07b2 0A       		.byte	10
 8911 07b3 0B       		.byte	11
 8912 07b4 0B       		.byte	11
 8913 07b5 0B       		.byte	11
 8914 07b6 0B       		.byte	11
 8915 07b7 00       		.space	1
 8918              	CyFxGpifRegValue:
 8919 07b8 08830080 		.word	-2147450104
 8920 07bc 67000000 		.word	103
 8921 07c0 00000000 		.word	0
 8922 07c4 46000000 		.word	70
 8923 07c8 00000000 		.word	0
 8924 07cc 00000000 		.word	0
 8925 07d0 02000000 		.word	2
 8926 07d4 82000000 		.word	130
 8927 07d8 82070000 		.word	1922
 8928 07dc 40040000 		.word	1088
 8929 07e0 FCFF0000 		.word	65532
 8930 07e4 28000000 		.word	40
 8931 07e8 00000000 		.word	0
 8932 07ec 00000000 		.word	0
 8933 07f0 00000000 		.word	0
 8934 07f4 00000000 		.word	0
 8935 07f8 01000000 		.word	1
 8936 07fc 00000000 		.word	0
 8937 0800 00000000 		.word	0
 8938 0804 00000000 		.word	0
 8939 0808 00000000 		.word	0
 8940 080c 00000000 		.word	0
 8941 0810 00000000 		.word	0
 8942 0814 00000000 		.word	0
 8943 0818 00000000 		.word	0
 8944 081c 00000000 		.word	0
 8945 0820 00000000 		.word	0
 8946 0824 00000000 		.word	0
 8947 0828 00000000 		.word	0
 8948 082c 06000000 		.word	6
 8949 0830 00000000 		.word	0
 8950 0834 FFFF0000 		.word	65535
 8951 0838 09010000 		.word	265
 8952 083c 00000000 		.word	0
 8953 0840 F71F0000 		.word	8183
 8954 0844 00000000 		.word	0
 8955 0848 FFFF0000 		.word	65535
 8956 084c 09010000 		.word	265
 8957 0850 00000000 		.word	0
 8958 0854 F71F0000 		.word	8183
 8959 0858 00000000 		.word	0
 8960 085c 00000000 		.word	0
 8961 0860 00000000 		.word	0
 8962 0864 00000000 		.word	0
 8963 0868 00000000 		.word	0
 8964 086c 00000000 		.word	0
 8965 0870 00000000 		.word	0
 8966 0874 00000000 		.word	0
 8967 0878 00000000 		.word	0
 8968 087c 00000000 		.word	0
 8969 0880 00000000 		.word	0
 8970 0884 00000000 		.word	0
 8971 0888 00000000 		.word	0
 8972 088c 00000000 		.word	0
 8973 0890 00000000 		.word	0
 8974 0894 00000000 		.word	0
 8975 0898 00000000 		.word	0
 8976 089c 00000000 		.word	0
 8977 08a0 00000000 		.word	0
 8978 08a4 00000000 		.word	0
 8979 08a8 00000000 		.word	0
 8980 08ac 00000000 		.word	0
 8981 08b0 00000000 		.word	0
 8982 08b4 00040180 		.word	-2147417088
 8983 08b8 01040180 		.word	-2147417087
 8984 08bc 02040180 		.word	-2147417086
 8985 08c0 03040180 		.word	-2147417085
 8986 08c4 00000000 		.word	0
 8987 08c8 00000000 		.word	0
 8988 08cc 00000000 		.word	0
 8989 08d0 00000000 		.word	0
 8990 08d4 00000000 		.word	0
 8991 08d8 00000000 		.word	0
 8992 08dc 00000000 		.word	0
 8993 08e0 00000000 		.word	0
 8994 08e4 C1FFFFFF 		.word	-63
 8997              	CyFxGpifTransition_usb2:
 8998 08e8 0000     		.short	0
 8999 08ea 5555     		.short	21845
 9000 08ec AAAA     		.short	-21846
 9001 08ee 8888     		.short	-30584
 9002 08f0 1111     		.short	4369
 9003 08f2 4444     		.short	17476
 9004 08f4 3333     		.short	13107
 9005 08f6 CCCC     		.short	-13108
 9008              	CyFxGpifWavedata_usb2:
 9009 08f8 0181731E 		.word	510886145
 9010 08fc 00000000 		.word	0
 9011 0900 00000080 		.word	-2147483648
 9012 0904 00000000 		.word	0
 9013 0908 00000000 		.word	0
 9014 090c 00000000 		.word	0
 9015 0910 0201703E 		.word	1047527682
 9016 0914 00010000 		.word	256
 9017 0918 A00000C0 		.word	-1073741664
 9018 091c 00000000 		.word	0
 9019 0920 00000000 		.word	0
 9020 0924 00000000 		.word	0
 9021 0928 0394731E 		.word	510891011
 9022 092c 04000020 		.word	536870916
 9023 0930 60004080 		.word	-2143289248
 9024 0934 00000000 		.word	0
 9025 0938 00000000 		.word	0
 9026 093c 00000000 		.word	0
 9027 0940 0620702E 		.word	779100166
 9028 0944 0C000000 		.word	12
 9029 0948 00000080 		.word	-2147483648
 9030 094c 0620702E 		.word	779100166
 9031 0950 0C000000 		.word	12
 9032 0954 00000080 		.word	-2147483648
 9033 0958 0394731E 		.word	510891011
 9034 095c 04000020 		.word	536870916
 9035 0960 60004080 		.word	-2143289248
 9036 0964 0620702E 		.word	779100166
 9037 0968 0C000000 		.word	12
 9038 096c 00000080 		.word	-2147483648
 9039 0970 0C93731E 		.word	510890764
 9040 0974 04000024 		.word	603979780
 9041 0978 90004080 		.word	-2143289200
 9042 097c 0D20702E 		.word	779100173
 9043 0980 0C000000 		.word	12
 9044 0984 00000080 		.word	-2147483648
 9045 0988 0780724E 		.word	1316126727
 9046 098c 0A000000 		.word	10
 9047 0990 00000080 		.word	-2147483648
 9048 0994 08000000 		.word	8
 9049 0998 00000000 		.word	0
 9050 099c 00010080 		.word	-2147483392
 9051 09a0 0920702E 		.word	779100169
 9052 09a4 0C010000 		.word	268
 9053 09a8 00000080 		.word	-2147483648
 9054 09ac 0A01701E 		.word	510656778
 9055 09b0 0E000100 		.word	65550
 9056 09b4 00000080 		.word	-2147483648
 9057 09b8 00000000 		.word	0
 9058 09bc 00000000 		.word	0
 9059 09c0 00000000 		.word	0
 9060 09c4 00000000 		.word	0
 9061 09c8 00000000 		.word	0
 9062 09cc 00000000 		.word	0
 9063 09d0 0394731E 		.word	510891011
 9064 09d4 04000020 		.word	536870916
 9065 09d8 60004080 		.word	-2143289248
 9066 09dc 08000000 		.word	8
 9067 09e0 00000000 		.word	0
 9068 09e4 00010080 		.word	-2147483392
 9069 09e8 0B000000 		.word	11
 9070 09ec 00000000 		.word	0
 9071 09f0 00010080 		.word	-2147483392
 9072 09f4 0C93731E 		.word	510890764
 9073 09f8 04000024 		.word	603979780
 9074 09fc 90004080 		.word	-2143289200
 9075 0a00 0D20702E 		.word	779100173
 9076 0a04 0C000000 		.word	12
 9077 0a08 00000080 		.word	-2147483648
 9078 0a0c 0D20702E 		.word	779100173
 9079 0a10 0C000000 		.word	12
 9080 0a14 00000080 		.word	-2147483648
 9081 0a18 0E60724E 		.word	1316118542
 9082 0a1c 0A000000 		.word	10
 9083 0a20 00000080 		.word	-2147483648
 9084 0a24 0F000000 		.word	15
 9085 0a28 00000000 		.word	0
 9086 0a2c 00010080 		.word	-2147483392
 9087 0a30 1020702E 		.word	779100176
 9088 0a34 0C010000 		.word	268
 9089 0a38 00000080 		.word	-2147483648
 9090 0a3c 1101701E 		.word	510656785
 9091 0a40 0E000100 		.word	65550
 9092 0a44 00000080 		.word	-2147483648
 9093 0a48 0C93731E 		.word	510890764
 9094 0a4c 04000024 		.word	603979780
 9095 0a50 90004080 		.word	-2143289200
 9096 0a54 0F000000 		.word	15
 9097 0a58 00000000 		.word	0
 9098 0a5c 00010080 		.word	-2147483392
 9099 0a60 12000000 		.word	18
 9100 0a64 00000000 		.word	0
 9101 0a68 00010080 		.word	-2147483392
 9102 0a6c 0394731E 		.word	510891011
 9103 0a70 04000020 		.word	536870916
 9104 0a74 60004080 		.word	-2143289248
 9105 0a78 0480732E 		.word	779321348
 9106 0a7c 02010000 		.word	258
 9107 0a80 0000C0C0 		.word	-1061158912
 9108 0a84 0580732E 		.word	779321349
 9109 0a88 02010000 		.word	258
 9110 0a8c 0000C0C0 		.word	-1061158912
 9111 0a90 0580732E 		.word	779321349
 9112 0a94 02010000 		.word	258
 9113 0a98 0000C0C0 		.word	-1061158912
 9114 0a9c 0480732E 		.word	779321348
 9115 0aa0 02010000 		.word	258
 9116 0aa4 0000C0C0 		.word	-1061158912
 9119              	CyFxGpifWavedataPosition_usb2:
 9120 0aa8 00       		.byte	0
 9121 0aa9 01       		.byte	1
 9122 0aaa 02       		.byte	2
 9123 0aab 03       		.byte	3
 9124 0aac 04       		.byte	4
 9125 0aad 05       		.byte	5
 9126 0aae 06       		.byte	6
 9127 0aaf 07       		.byte	7
 9128 0ab0 08       		.byte	8
 9129 0ab1 09       		.byte	9
 9130 0ab2 0A       		.byte	10
 9131 0ab3 08       		.byte	8
 9132 0ab4 0B       		.byte	11
 9133 0ab5 0C       		.byte	12
 9134 0ab6 0D       		.byte	13
 9135 0ab7 08       		.byte	8
 9136 0ab8 0E       		.byte	14
 9137 0ab9 0F       		.byte	15
 9138 0aba 08       		.byte	8
 9139 0abb 08       		.byte	8
 9140 0abc 08       		.byte	8
 9141 0abd 08       		.byte	8
 9142 0abe 08       		.byte	8
 9143 0abf 08       		.byte	8
 9144 0ac0 08       		.byte	8
 9145 0ac1 08       		.byte	8
 9146 0ac2 08       		.byte	8
 9147 0ac3 08       		.byte	8
 9148 0ac4 08       		.byte	8
 9149 0ac5 08       		.byte	8
 9150 0ac6 08       		.byte	8
 9151 0ac7 08       		.byte	8
 9152 0ac8 08       		.byte	8
 9153 0ac9 08       		.byte	8
 9154 0aca 08       		.byte	8
 9155 0acb 08       		.byte	8
 9156 0acc 08       		.byte	8
 9157 0acd 08       		.byte	8
 9158 0ace 08       		.byte	8
 9159 0acf 08       		.byte	8
 9160 0ad0 08       		.byte	8
 9161 0ad1 08       		.byte	8
 9162 0ad2 08       		.byte	8
 9163 0ad3 08       		.byte	8
 9164 0ad4 08       		.byte	8
 9165 0ad5 08       		.byte	8
 9166 0ad6 08       		.byte	8
 9167 0ad7 08       		.byte	8
 9168 0ad8 08       		.byte	8
 9169 0ad9 08       		.byte	8
 9170 0ada 08       		.byte	8
 9171 0adb 08       		.byte	8
 9172 0adc 08       		.byte	8
 9173 0add 08       		.byte	8
 9174 0ade 08       		.byte	8
 9175 0adf 08       		.byte	8
 9176 0ae0 08       		.byte	8
 9177 0ae1 08       		.byte	8
 9178 0ae2 08       		.byte	8
 9179 0ae3 08       		.byte	8
 9180 0ae4 08       		.byte	8
 9181 0ae5 08       		.byte	8
 9182 0ae6 08       		.byte	8
 9183 0ae7 08       		.byte	8
 9184 0ae8 08       		.byte	8
 9185 0ae9 08       		.byte	8
 9186 0aea 08       		.byte	8
 9187 0aeb 08       		.byte	8
 9188 0aec 08       		.byte	8
 9189 0aed 08       		.byte	8
 9190 0aee 08       		.byte	8
 9191 0aef 08       		.byte	8
 9192 0af0 08       		.byte	8
 9193 0af1 08       		.byte	8
 9194 0af2 08       		.byte	8
 9195 0af3 08       		.byte	8
 9196 0af4 08       		.byte	8
 9197 0af5 08       		.byte	8
 9198 0af6 08       		.byte	8
 9199 0af7 08       		.byte	8
 9200 0af8 08       		.byte	8
 9201 0af9 08       		.byte	8
 9202 0afa 08       		.byte	8
 9203 0afb 08       		.byte	8
 9204 0afc 08       		.byte	8
 9205 0afd 08       		.byte	8
 9206 0afe 08       		.byte	8
 9207 0aff 08       		.byte	8
 9208 0b00 08       		.byte	8
 9209 0b01 08       		.byte	8
 9210 0b02 08       		.byte	8
 9211 0b03 08       		.byte	8
 9212 0b04 08       		.byte	8
 9213 0b05 08       		.byte	8
 9214 0b06 08       		.byte	8
 9215 0b07 08       		.byte	8
 9216 0b08 08       		.byte	8
 9217 0b09 08       		.byte	8
 9218 0b0a 08       		.byte	8
 9219 0b0b 08       		.byte	8
 9220 0b0c 08       		.byte	8
 9221 0b0d 08       		.byte	8
 9222 0b0e 08       		.byte	8
 9223 0b0f 08       		.byte	8
 9224 0b10 08       		.byte	8
 9225 0b11 08       		.byte	8
 9226 0b12 08       		.byte	8
 9227 0b13 08       		.byte	8
 9228 0b14 08       		.byte	8
 9229 0b15 08       		.byte	8
 9230 0b16 08       		.byte	8
 9231 0b17 08       		.byte	8
 9232 0b18 08       		.byte	8
 9233 0b19 08       		.byte	8
 9234 0b1a 08       		.byte	8
 9235 0b1b 08       		.byte	8
 9236 0b1c 08       		.byte	8
 9237 0b1d 08       		.byte	8
 9238 0b1e 08       		.byte	8
 9239 0b1f 08       		.byte	8
 9240 0b20 08       		.byte	8
 9241 0b21 08       		.byte	8
 9242 0b22 08       		.byte	8
 9243 0b23 08       		.byte	8
 9244 0b24 08       		.byte	8
 9245 0b25 08       		.byte	8
 9246 0b26 08       		.byte	8
 9247 0b27 08       		.byte	8
 9248 0b28 00       		.byte	0
 9249 0b29 01       		.byte	1
 9250 0b2a 02       		.byte	2
 9251 0b2b 10       		.byte	16
 9252 0b2c 04       		.byte	4
 9253 0b2d 05       		.byte	5
 9254 0b2e 06       		.byte	6
 9255 0b2f 07       		.byte	7
 9256 0b30 08       		.byte	8
 9257 0b31 09       		.byte	9
 9258 0b32 0A       		.byte	10
 9259 0b33 08       		.byte	8
 9260 0b34 11       		.byte	17
 9261 0b35 0C       		.byte	12
 9262 0b36 0D       		.byte	13
 9263 0b37 08       		.byte	8
 9264 0b38 0E       		.byte	14
 9265 0b39 0F       		.byte	15
 9266 0b3a 08       		.byte	8
 9267 0b3b 00       		.space	1
 9270              	CyFxGpifRegValue_usb2:
 9271 0b3c 08830080 		.word	-2147450104
 9272 0b40 67000000 		.word	103
 9273 0b44 01000000 		.word	1
 9274 0b48 46000000 		.word	70
 9275 0b4c 00000000 		.word	0
 9276 0b50 00000000 		.word	0
 9277 0b54 02000000 		.word	2
 9278 0b58 82000000 		.word	130
 9279 0b5c 82070000 		.word	1922
 9280 0b60 40040000 		.word	1088
 9281 0b64 FCFF0000 		.word	65532
 9282 0b68 28000000 		.word	40
 9283 0b6c 00000000 		.word	0
 9284 0b70 00000000 		.word	0
 9285 0b74 00000000 		.word	0
 9286 0b78 00000000 		.word	0
 9287 0b7c 01000000 		.word	1
 9288 0b80 00000000 		.word	0
 9289 0b84 00000000 		.word	0
 9290 0b88 00000000 		.word	0
 9291 0b8c 00000000 		.word	0
 9292 0b90 00000000 		.word	0
 9293 0b94 00000000 		.word	0
 9294 0b98 00000000 		.word	0
 9295 0b9c 00000000 		.word	0
 9296 0ba0 00000000 		.word	0
 9297 0ba4 00000000 		.word	0
 9298 0ba8 00000000 		.word	0
 9299 0bac 00000000 		.word	0
 9300 0bb0 06000000 		.word	6
 9301 0bb4 00000000 		.word	0
 9302 0bb8 FFFF0000 		.word	65535
 9303 0bbc 09010000 		.word	265
 9304 0bc0 00000000 		.word	0
 9305 0bc4 F71F0000 		.word	8183
 9306 0bc8 00000000 		.word	0
 9307 0bcc FFFF0000 		.word	65535
 9308 0bd0 09010000 		.word	265
 9309 0bd4 00000000 		.word	0
 9310 0bd8 F71F0000 		.word	8183
 9311 0bdc 00000000 		.word	0
 9312 0be0 00000000 		.word	0
 9313 0be4 00000000 		.word	0
 9314 0be8 00000000 		.word	0
 9315 0bec 00000000 		.word	0
 9316 0bf0 00000000 		.word	0
 9317 0bf4 00000000 		.word	0
 9318 0bf8 00000000 		.word	0
 9319 0bfc 00000000 		.word	0
 9320 0c00 00000000 		.word	0
 9321 0c04 00000000 		.word	0
 9322 0c08 00000000 		.word	0
 9323 0c0c 00000000 		.word	0
 9324 0c10 00000000 		.word	0
 9325 0c14 00000000 		.word	0
 9326 0c18 00000000 		.word	0
 9327 0c1c 00000000 		.word	0
 9328 0c20 00000000 		.word	0
 9329 0c24 00000000 		.word	0
 9330 0c28 00000000 		.word	0
 9331 0c2c 00000000 		.word	0
 9332 0c30 00000000 		.word	0
 9333 0c34 00000000 		.word	0
 9334 0c38 00040180 		.word	-2147417088
 9335 0c3c 01040180 		.word	-2147417087
 9336 0c40 02040180 		.word	-2147417086
 9337 0c44 03040180 		.word	-2147417085
 9338 0c48 00000000 		.word	0
 9339 0c4c 00000000 		.word	0
 9340 0c50 00000000 		.word	0
 9341 0c54 00000000 		.word	0
 9342 0c58 00000000 		.word	0
 9343 0c5c 00000000 		.word	0
 9344 0c60 00000000 		.word	0
 9345 0c64 00000000 		.word	0
 9346 0c68 C1FFFFFF 		.word	-63
 9347              		.section	.rodata.str1.4,"aMS",%progbits,1
 9348              		.align	2
 9349              	.LC0:
 9350 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9350      7065722D 
 9350      74696D65 
 9350      72202564 
 9350      0D0A00
 9351 0013 00       		.space	1
 9352              	.LC1:
 9353 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9353      636F6D6D 
 9353      616E6420 
 9353      71756575 
 9353      65206973 
 9354 0037 00       		.space	1
 9355              	.LC2:
 9356 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9356      7220696E 
 9356      206D756C 
 9356      74696368 
 9356      616E6E65 
 9357 006b 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9357      2025782C 
 9357      20646D61 
 9357      446F6E65 
 9357      20256420 
 9358              	.LC3:
 9359 0084 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9359      5420656E 
 9359      636F756E 
 9359      74657265 
 9359      642E2E2E 
 9360              	.LC4:
 9361 00a4 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9361      454E4420 
 9361      656E636F 
 9361      756E7465 
 9361      7265642E 
 9362 00c6 0000     		.space	2
 9363              	.LC5:
 9364 00c8 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9364      64697363 
 9364      6F6E6E65 
 9364      63746564 
 9364      2E2E2E30 
 9365 00e7 00       		.space	1
 9366              	.LC6:
 9367 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9367      43595F46 
 9367      585F5556 
 9367      435F5649 
 9367      44454F5F 
 9368 011b 0A00     		.ascii	"\012\000"
 9369 011d 000000   		.space	3
 9370              	.LC7:
 9371 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9371      43595F46 
 9371      585F5556 
 9371      435F5649 
 9371      44454F5F 
 9372 0153 00       		.ascii	"\000"
 9373              	.LC8:
 9374 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9374      726E6174 
 9374      65207365 
 9374      7474696E 
 9374      6720302E 
 9375              	.LC9:
 9376 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9376      72206665 
 9376      61747572 
 9376      65207265 
 9376      71756573 
 9377 018f 00       		.space	1
 9378              	.LC10:
 9379 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9379      6F6D6D69 
 9379      74656F66 
 9379      20737461 
 9379      7465203D 
 9380              	.LC11:
 9381 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9381      6E656C20 
 9381      53657420 
 9381      57726170 
 9381      55702066 
 9382 01d5 000000   		.space	3
 9383              	.LC12:
 9384 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9384      72206861 
 9384      6E646C65 
 9384      722E2E2E 
 9384      0D0A00
 9385 01eb 00       		.space	1
 9386              	.LC13:
 9387 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9387      69742045 
 9387      4F462066 
 9387      61696C65 
 9387      64210D0A 
 9388 0201 000000   		.space	3
 9389              	.LC14:
 9390 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9390      49324320 
 9390      636F6D6D 
 9390      616E6420 
 9390      69732030 
 9391 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9391      78257820 
 9391      30782578 
 9391      20307825 
 9391      78203078 
 9392              	.LC15:
 9393 0250 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9393      206C6967 
 9393      68742063 
 9393      6F6D7065 
 9393      6E736174 
 9394 0283 25640D0A 		.ascii	"%d\015\012\000"
 9394      00
 9395              	.LC16:
 9396 0288 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9396      49324320 
 9396      63757272 
 9396      656E7420 
 9396      64617461 
 9397 02bb 64202564 		.ascii	"d %d\015\012\000"
 9397      0D0A00
 9398 02c2 0000     		.space	2
 9399              	.LC17:
 9400 02c4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9400      26414743 
 9400      2073656E 
 9400      7420746F 
 9400      20686F73 
 9401 02ea 0000     		.space	2
 9402              	.LC18:
 9403 02ec 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9403      26414743 
 9403      20676F74 
 9403      74656E20 
 9403      66726F6D 
 9404 0316 0000     		.space	2
 9405              	.LC19:
 9406 0318 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9406      67657420 
 9406      64617461 
 9406      2066726F 
 9406      6D20686F 
 9407 0345 000000   		.space	3
 9408              	.LC20:
 9409 0348 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9409      52657175 
 9409      65737420 
 9409      30782578 
 9409      20706172 
 9410 037b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9410      6E642074 
 9410      6F20686F 
 9410      73742030 
 9410      78257820 
 9411 0396 0000     		.space	2
 9412              	.LC21:
 9413 0398 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9413      204F7020 
 9413      72656365 
 9413      69766573 
 9413      20284354 
 9414 03bf 00       		.space	1
 9415              	.LC22:
 9416 03c0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9416      756C7420 
 9416      73656C65 
 9416      63746F72 
 9416      20284354 
 9417 03e2 0000     		.space	2
 9418              	.LC23:
 9419 03e4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9419      756C7420 
 9419      72657175 
 9419      65737420 
 9419      28435429 
 9420 0405 000000   		.space	3
 9421              	.LC24:
 9422 0408 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9422      52657175 
 9422      65737420 
 9422      30782578 
 9422      20706172 
 9423 043b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9423      20307825 
 9423      78202F20 
 9423      73656E64 
 9423      20746F20 
 9424 0468 00       		.ascii	"\000"
 9425 0469 000000   		.space	3
 9426              	.LC25:
 9427 046c 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9427      73706565 
 9427      64203D20 
 9427      25642065 
 9427      76656E66 
 9428 049c 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9428      71756573 
 9428      74203D20 
 9428      30782578 
 9428      20775661 
 9429 04cc 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9429      203D2030 
 9429      78257820 
 9429      6973666C 
 9429      61672030 
 9430 04e6 0000     		.space	2
 9431              	.LC26:
 9432 04e8 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9432      64656661 
 9432      756C7420 
 9432      73657475 
 9432      70207265 
 9433              	.LC27:
 9434 0514 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9434      43595F46 
 9434      585F5556 
 9434      435F5354 
 9434      5245414D 
 9435 053a 0000     		.space	2
 9436              	.LC28:
 9437 053c 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9437      55564320 
 9437      7374696C 
 9437      6C207472 
 9437      69676765 
 9438 0562 0000     		.space	2
 9439              	.LC29:
 9440 0564 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9440      7374696C 
 9440      6C207472 
 9440      69676765 
 9440      7220636F 
 9441 058b 00       		.space	1
 9442              	.LC30:
 9443 058c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9443      65642074 
 9443      6F207365 
 9443      6E642069 
 9443      6E746572 
 9444 05bd 0A00     		.ascii	"\012\000"
 9445 05bf 00       		.space	1
 9446              	.LC31:
 9447 05c0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9447      73657420 
 9447      64656620 
 9447      64617461 
 9447      20307825 
 9448 05df 00       		.space	1
 9449              	.LC32:
 9450 05e0 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9450      73657420 
 9450      64656620 
 9450      64617461 
 9450      20307825 
 9451 0613 2E0D0A00 		.ascii	".\015\012\000"
 9452 0617 00       		.space	1
 9453              	.LC33:
 9454 0618 55415254 		.ascii	"UART initialization failed!\012\000"
 9454      20696E69 
 9454      7469616C 
 9454      697A6174 
 9454      696F6E20 
 9455 0635 000000   		.space	3
 9456              	.LC34:
 9457 0638 49324320 		.ascii	"I2C initialization failed!\012\000"
 9457      696E6974 
 9457      69616C69 
 9457      7A617469 
 9457      6F6E2066 
 9458              	.LC35:
 9459 0654 49324320 		.ascii	"I2C configuration failed!\012\000"
 9459      636F6E66 
 9459      69677572 
 9459      6174696F 
 9459      6E206661 
 9460 066f 00       		.space	1
 9461              	.LC36:
 9462 0670 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9462      43726561 
 9462      74652045 
 9462      76656E74 
 9462      20666169 
 9463 069a 0000     		.space	2
 9464              	.LC37:
 9465 069c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9465      20496E69 
 9465      74206661 
 9465      696C6564 
 9465      2C204572 
 9466 06bf 00       		.space	1
 9467              	.LC38:
 9468 06c0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9468      204F7665 
 9468      72726964 
 9468      65206661 
 9468      696C6564 
 9469 06e7 00       		.space	1
 9470              	.LC39:
 9471 06e8 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9471      28323029 
 9471      204F7665 
 9471      72726964 
 9471      65206661 
 9472 0713 00       		.space	1
 9473              	.LC40:
 9474 0714 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9474      28323429 
 9474      204F7665 
 9474      72726964 
 9474      65206661 
 9475 073f 00       		.space	1
 9476              	.LC41:
 9477 0740 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9477      20536574 
 9477      20287265 
 9477      73657420 
 9477      32322920 
 9478 0772 00       		.ascii	"\000"
 9479 0773 00       		.space	1
 9480              	.LC42:
 9481 0774 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9481      20536574 
 9481      2028706F 
 9481      77657220 
 9481      32302920 
 9482 07a6 00       		.ascii	"\000"
 9483 07a7 00       		.space	1
 9484              	.LC43:
 9485 07a8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9485      20536574 
 9485      2028736E 
 9485      61702073 
 9485      686F7420 
 9486 07db 25640A00 		.ascii	"%d\012\000"
 9487 07df 00       		.space	1
 9488              	.LC44:
 9489 07e0 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9489      46756E63 
 9489      74696F6E 
 9489      20466169 
 9489      6C656420 
 9490 080f 00       		.space	1
 9491              	.LC45:
 9492 0810 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9492      46756E63 
 9492      74696F6E 
 9492      20466169 
 9492      6C656420 
 9493 083f 00       		.space	1
 9494              	.LC46:
 9495 0840 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9495      53657420 
 9495      456E6470 
 9495      6F696E74 
 9495      20636F6E 
 9496 0870 00       		.ascii	"\000"
 9497 0871 000000   		.space	3
 9498              	.LC47:
 9499 0874 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9499      496E7465 
 9499      72727570 
 9499      74205374 
 9499      61747573 
 9500 08a7 20436F64 		.ascii	" Code = %d\012\000"
 9500      65203D20 
 9500      25640A00 
 9501 08b3 00       		.space	1
 9502              	.LC48:
 9503 08b4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9503      65642074 
 9503      6F20616C 
 9503      6C6F6361 
 9503      7465206D 
 9504 08e7 65720D0A 		.ascii	"er\015\012\000"
 9504      00
 9505              	.LC49:
 9506 08ec 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9506      4368616E 
 9506      6E656C20 
 9506      43726561 
 9506      74696F6E 
 9507 091a 0000     		.space	2
 9508              	.LC50:
 9509 091c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9509      436F6E6E 
 9509      65637420 
 9509      6661696C 
 9509      65642C20 
 9510 0941 000000   		.space	3
 9511              	.LC51:
 9512 0944 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9512      4368616E 
 9512      6E656C20 
 9512      52657365 
 9512      74204661 
 9513 096f 00       		.space	1
 9514              	.LC52:
 9515 0970 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9515      4368616E 
 9515      6E656C20 
 9515      53657420 
 9515      5472616E 
 9516 09a1 00       		.ascii	"\000"
 9517 09a2 0000     		.space	2
 9518              	.LC53:
 9519 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9519      4368616E 
 9519      6E656C20 
 9519      53657420 
 9519      5472616E 
 9520 09d5 0A00     		.ascii	"\012\000"
 9521 09d7 00       		.space	1
 9522              	.LC54:
 9523 09d8 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9523      75706572 
 9523      20677069 
 9523      6600
 9524 09e6 0000     		.space	2
 9525              	.LC55:
 9526 09e8 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9526      69676820 
 9526      67706966 
 9526      00
 9527 09f5 000000   		.space	3
 9528              	.LC56:
 9529 09f8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9529      696E6720 
 9529      47504946 
 9529      20436F6E 
 9529      66696775 
 9530 0a2b 0A00     		.ascii	"\012\000"
 9531 0a2d 000000   		.space	3
 9532              	.LC57:
 9533 0a30 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9533      74696E67 
 9533      20475049 
 9533      46207374 
 9533      61746520 
 9534 0a63 0D0A00   		.ascii	"\015\012\000"
 9535 0a66 0000     		.space	2
 9536              	.LC58:
 9537 0a68 33303A55 		.ascii	"30:UVC App Thread\000"
 9537      56432041 
 9537      70702054 
 9537      68726561 
 9537      6400
 9538 0a7a 0000     		.space	2
 9539              	.LC59:
 9540 0a7c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9540      56432041 
 9540      70702045 
 9540      50302054 
 9540      68726561 
 9541 0a92 0000     		.space	2
 9542              	.LC60:
 9543 0a94 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9543      32432041 
 9543      70702043 
 9543      54524C20 
 9543      54687265 
 9544 0aab 00       		.bss
 9545              		.align	2
 9546              		.set	.LANCHOR0,. + 0
 9549              	glFxUVCEvent:
 9550 0000 00000000 		.space	40
 9550      00000000 
 9550      00000000 
 9550      00000000 
 9550      00000000 
 9553              	fb:
 9554 0028 0000     		.space	2
 9557              	pb:
 9558 002a 0000     		.space	2
 9561              	pbc:
 9562 002c 0000     		.space	2
 9563 002e 0000     		.space	2
 9566              	hitFV:
 9567 0030 00000000 		.space	4
 9570              	prodCount:
 9571 0034 0000     		.space	2
 9574              	consCount:
 9575 0036 0000     		.space	2
 9578              	streamingStarted:
 9579 0038 00000000 		.space	4
 9582              	gpif_initialized:
 9583 003c 00000000 		.space	4
 9586              	isUsbConnected:
 9587 0040 00000000 		.space	4
 9590              	clearFeatureRqtReceived:
 9591 0044 00000000 		.space	4
 9594              	usbSpeed:
 9595 0048 00       		.space	1
 9596 0049 000000   		.space	3
 9599              	I2CCMDArry:
 9600 004c 00000000 		.space	12
 9600      00000000 
 9600      00000000 
 9603              	glEp0Buffer:
 9604 0058 00000000 		.space	32
 9604      00000000 
 9604      00000000 
 9604      00000000 
 9604      00000000 
 9607              	CamMode:
 9608 0078 00       		.space	1
 9609 0079 000000   		.space	3
 9612              	glCommitCtrl:
 9613 007c 00000000 		.space	32
 9613      00000000 
 9613      00000000 
 9613      00000000 
 9613      00000000 
 9616              	stiflag:
 9617 009c 00000000 		.space	4
 9620              	uvcAppThread:
 9621 00a0 00000000 		.space	168
 9621      00000000 
 9621      00000000 
 9621      00000000 
 9621      00000000 
 9624              	uvcAppEP0Thread:
 9625 0148 00000000 		.space	168
 9625      00000000 
 9625      00000000 
 9625      00000000 
 9625      00000000 
 9628              	i2cAppThread:
 9629 01f0 00000000 		.space	168
 9629      00000000 
 9629      00000000 
 9629      00000000 
 9629      00000000 
 9632              	testSnap:
 9633 0298 00       		.space	1
 9634 0299 00       		.space	1
 9637              	fbbak:
 9638 029a 0000     		.space	2
 9641              	pbbak:
 9642 029c 0000     		.space	2
 9645              	pbcbak:
 9646 029e 0000     		.space	2
 9649              	pbcpbak:
 9650 02a0 0000     		.space	2
 9651 02a2 0000     		.text
 9652              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:331    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:494    .text:00000380 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:502    .text:00000394 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:504    .text:00000394 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:683    .text:000004f4 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:692    .text:00000504 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:694    .text:00000504 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1019   .text:000007cc $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1035   .text:000007f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1038   .text:000007f8 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1075   .text:00000830 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1088   .text:0000085c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1135   .text:000008b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1142   .text:000008c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1160   .text:000008dc $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1169   .text:000008f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1172   .text:000008f4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1379   .text:00000b08 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1385   .text:00000b14 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1388   .text:00000b14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1451   .text:00000b94 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1658   .text:00000d30 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1696   .text:00000dbc $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1760   .text:00000e40 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:1796   .text:00000ec8 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:2999   .text:000019f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3017   .text:00001a2c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3020   .text:00001a2c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3188   .text:00001b88 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3201   .text:00001bb0 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3696   .text:000020c0 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3707   .text:000020e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3962   .text:00002398 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3975   .text:000023c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:3978   .text:000023c0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:4040   .text:0000243c $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:4048   .text:0000244c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5214   .text:00002df8 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5242   .text:00002e54 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5245   .text:00002e54 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5536   .text:0000310c $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5543   .text:0000311c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5546   .text:0000311c CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5582   .text:00003148 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5586   .text:0000314c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5589   .text:0000314c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5614   .text:00003168 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5618   .text:0000316c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:5621   .text:0000316c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:6952   .text:00003bd8 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7011   .text:00003cb0 $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7014   .text:00003cb0 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7171   .text:00003e28 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7187   .text:00003e5c $a
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7190   .text:00003e5c main
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8815   .data:0000067c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8824   .data:00000688 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8899   .data:000007a8 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8918   .data:000007b8 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7352   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8997   .data:000008e8 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9008   .data:000008f8 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9119   .data:00000aa8 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9270   .data:00000b3c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7365   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8811   .data:0000067b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9632   .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9553   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9557   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9561   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9637   .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9641   .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9645   .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9649   .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9586   .bss:00000040 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9594   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9590   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9578   .bss:00000038 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8752   .data:00000648 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8692   .data:00000610 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8782   .data:00000664 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8722   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8797   .data:00000670 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8347   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7329   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7333   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7377   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7381   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:7704   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8362   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:8369   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9348   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9545   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9549   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9566   .bss:00000030 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9570   .bss:00000034 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9574   .bss:00000036 consCount
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9582   .bss:0000003c gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9599   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9603   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9607   .bss:00000078 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9612   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9616   .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9620   .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9624   .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccvNibq9.s:9628   .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
SensorRead2B2
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
