   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 233:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 234:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 237:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 238:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 239:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 250:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 251:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 253:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 254:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 255:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 256:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 257:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 258:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 259:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 261:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //volatile static SensorCtrl PUCBLC;
 277:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 278:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 279:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 280:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 281:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 282:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 283:../uvc.c      **** //volatile static SensorCtrl PUCSharp;
 284:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 285:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 286:../uvc.c      **** /* the Camera terminal control request */
 287:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 288:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 289:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 290:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 291:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 292:../uvc.c      **** /* the Extentsion control request */
 293:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 294:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 295:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 296:../uvc.c      **** 		 2,					//UVCLn: the command length
 297:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 298:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 299:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 300:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 301:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 302:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 303:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 304:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 305:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 306:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 307:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 308:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 309:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 310:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 311:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 312:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 313:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 314:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 315:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 316:../uvc.c      **** 		 2,					//UVCLn: the command length
 317:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 318:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 319:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 320:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 321:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 322:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 323:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 324:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 325:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 326:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 327:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 328:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 329:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 330:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 331:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 332:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 333:../uvc.c      **** */
 334:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 335:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 336:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 337:../uvc.c      **** 		 2,					//UVCLn: the command length
 338:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 339:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 340:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 341:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 342:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 343:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 344:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 345:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 346:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 347:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 348:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 349:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 350:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 351:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 352:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 353:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 354:../uvc.c      **** */
 355:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 356:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 357:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 358:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 359:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 360:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 361:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 362:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 363:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 364:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 365:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 366:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 367:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 368:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 369:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 370:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 371:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 372:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 373:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 374:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 375:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 376:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 377:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 378:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 379:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 380:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 381:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 382:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 383:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 384:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 385:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 386:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 387:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 388:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 389:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 390:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 391:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 392:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 393:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 394:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 395:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 396:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 397:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 398:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 399:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 400:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 401:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 402:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 403:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 404:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 405:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 406:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 407:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 408:../uvc.c      **** 
 409:../uvc.c      **** volatile static SensorCtrl *pSensorCtrl[0x20] = {
 410:../uvc.c      **** 		&EXTShutter,
 411:../uvc.c      **** 		0,//&EXTSensUp,
 412:../uvc.c      **** 		0,//&EXTMirror,
 413:../uvc.c      **** 		0,//&EXT3DnoiseReduceMode,
 414:../uvc.c      **** 		0,//&EXT3DNoiseLev,
 415:../uvc.c      **** 		0,//&EXTDayNightMode,
 416:../uvc.c      **** 		0,//&EXTDayNightdely,
 417:../uvc.c      **** 		0,//&EXTDayNightlev,
 418:../uvc.c      **** 		0,//&EXTNightDaylev,
 419:../uvc.c      **** 		&EXTAexModGainlev,
 420:../uvc.c      **** 		0,//&EXTExpReflev,
 421:../uvc.c      **** 		&EXTShutlev,
 422:../uvc.c      **** 		0,//&EXTCamMode,
 423:../uvc.c      **** 		0,//&EXTSnapshot,
 424:../uvc.c      **** 		0,//&EXTSensorPare,
 425:../uvc.c      **** 		0,//&EXTI2Ccmd
 426:../uvc.c      **** 		0
 427:../uvc.c      **** };
 428:../uvc.c      **** #endif
 429:../uvc.c      **** 
 430:../uvc.c      **** #ifndef CAM720
 431:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 432:../uvc.c      **** #else
 433:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 434:../uvc.c      **** #endif
 435:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 436:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 437:../uvc.c      **** 
 438:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 439:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 440:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 441:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 442:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 443:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 444:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 445:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 446:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 447:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 448:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 449:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 450:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 451:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 452:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 453:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 454:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 455:../uvc.c      **** };
 456:../uvc.c      **** 
 457:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 458:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 459:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 460:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 461:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 462:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 463:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 464:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 465:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 466:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 467:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 468:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 469:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 470:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 471:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 472:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 473:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 474:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 475:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 476:../uvc.c      **** };
 477:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 478:../uvc.c      **** //static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}
 479:../uvc.c      **** /*
 480:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 481:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 482:../uvc.c      ****  */
 483:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 484:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 485:../uvc.c      **** };
 486:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 487:../uvc.c      **** 		0
 488:../uvc.c      **** };
 489:../uvc.c      **** 
 490:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 491:../uvc.c      **** 
 492:../uvc.c      **** void I2CCmdHandler(){
 493:../uvc.c      **** 	uint8_t buf[2];
 494:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 495:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 496:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 497:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 498:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 499:../uvc.c      **** 	uint8_t i;
 500:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 501:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 502:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 503:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 504:../uvc.c      **** 	{
 505:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 506:../uvc.c      **** 		if(is60Hz==CyFalse)
 507:../uvc.c      **** 			{
 508:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 509:../uvc.c      **** 			}
 510:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 511:../uvc.c      **** 
 512:../uvc.c      **** 	}
 513:../uvc.c      **** 	if(CmdType == 0)//I2C read
 514:../uvc.c      **** 	{
 515:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 516:../uvc.c      **** #if 0 //for debugging
 517:../uvc.c      **** 		/* test still image operation */
 518:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 519:../uvc.c      **** 			snapButFlag = 0; //press
 520:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 521:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 522:../uvc.c      **** 			snapButFlag = 0xf; //release
 523:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 524:../uvc.c      **** 		}
 525:../uvc.c      **** 
 526:../uvc.c      **** 		/* end of the test */
 527:../uvc.c      **** #endif
 528:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 529:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 530:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 531:../uvc.c      **** 				if(CmdDataLen == 2){
 532:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 533:../uvc.c      **** 				}
 534:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 535:../uvc.c      **** 		}else{//not support currently
 536:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 537:../uvc.c      **** 		}
 538:../uvc.c      **** 	}else if(CmdType == 1){
 539:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 540:../uvc.c      **** 			if(CmdRegLen == 2){
 541:../uvc.c      **** 				for(i = 0; i<4; i++)
 542:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 543:../uvc.c      **** 			}
 544:../uvc.c      **** 			else{
 545:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 546:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 547:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 548:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 549:../uvc.c      **** 				}
 550:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 551:../uvc.c      **** 			}
 552:../uvc.c      **** 		}else{//not support currently
 553:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 554:../uvc.c      **** 		}
 555:../uvc.c      **** 
 556:../uvc.c      **** 	}
 557:../uvc.c      **** }
 558:../uvc.c      **** 
 559:../uvc.c      **** /************************************
 560:../uvc.c      ****  * set Iris mode
 561:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 562:../uvc.c      ****  */
 563:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 564:../uvc.c      **** 	uint8_t dataIdx;
 565:../uvc.c      **** 	  dataIdx = 0;
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 570:../uvc.c      **** }
 571:../uvc.c      **** 
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 573:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 574:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 575:../uvc.c      ****     uint16_t readCount;
 576:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 577:../uvc.c      ****     uint8_t devAdd;
 578:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 579:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 580:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 581:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 582:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 583:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 584:../uvc.c      ****     }else{
 585:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 586:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 587:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 588:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 589:../uvc.c      ****     }
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 591:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 592:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 593:../uvc.c      **** #endif
 594:../uvc.c      ****     reqData = bRequest;
 595:../uvc.c      ****     /*
 596:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 597:../uvc.c      ****      */
 598:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 599:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 600:../uvc.c      ****     	goto EndofSet;
 601:../uvc.c      ****     }
 602:../uvc.c      ****     switch (bRequest)
 603:../uvc.c      **** 		 {
 604:../uvc.c      **** 
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 606:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 607:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 608:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 609:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 610:../uvc.c      **** 			  break;
 611:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 612:../uvc.c      **** 
 613:../uvc.c      **** 			 switch(CtrlID)
 614:../uvc.c      **** 			 {
 615:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 616:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 617:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 618:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 619:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 620:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 621:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 622:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 623:../uvc.c      **** 			 	 		 break;
 624:../uvc.c      **** 			 	 }
 625:../uvc.c      **** 			 	 case ExtShutCtlID0:
 626:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 627:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 628:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 629:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 630:../uvc.c      **** 			 		 break;
 631:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 632:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 633:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 634:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 635:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 636:../uvc.c      **** 			 		 break;
 637:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 638:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 639:../uvc.c      **** 					 if(CamMode == 1){//720p
 640:../uvc.c      **** 						if(sendData >= 3){
 641:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 642:../uvc.c      **** 							sendData = 0; //set back to default
 643:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 644:../uvc.c      **** 						}
 645:../uvc.c      **** 						sendData += 4;
 646:../uvc.c      **** 					 }
 647:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 648:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 649:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 650:../uvc.c      **** 					 break;
 651:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 652:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 653:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 654:../uvc.c      **** 			 		 }
 655:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 656:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 657:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 658:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 659:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 660:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 661:../uvc.c      **** #endif
 662:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 663:../uvc.c      **** 			 		 {
 664:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 665:../uvc.c      **** 			 		 }
 666:../uvc.c      **** 			 		 break;
 667:../uvc.c      **** 				 case ExtAexModCtlID9:
 668:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 669:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 670:../uvc.c      **** 
 671:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 672:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 673:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 674:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 675:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 676:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 677:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 678:../uvc.c      **** 					 break;
 679:../uvc.c      **** 
 680:../uvc.c      **** 			 	 case BrgtCtlID1:
 681:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 682:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 683:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 684:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 685:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 686:../uvc.c      **** 					 }else{
 687:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 688:../uvc.c      **** 					 }
 689:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 690:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 691:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 692:../uvc.c      **** 					 */
 693:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 694:../uvc.c      **** 					  if(Data0&0x80){
 695:../uvc.c      **** 						  Data0 = ~Data0;
 696:../uvc.c      **** 					  }else{
 697:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 698:../uvc.c      **** 					  }
 699:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 700:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 701:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 702:../uvc.c      **** 			 		 break;
 703:../uvc.c      **** 				 case HueCtlID5:
 704:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 705:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 706:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 707:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 708:../uvc.c      **** 					 break;
 709:../uvc.c      **** 				 case WBTLevCtlID11:
 710:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 711:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 712:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 713:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 714:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 715:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 716:../uvc.c      **** 					 break;
 717:../uvc.c      **** 				 case SaturCtlID6:
 718:../uvc.c      **** 				 default:
 719:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 720:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 721:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 722:../uvc.c      **** 					 break;
 723:../uvc.c      **** 			 }
 724:../uvc.c      **** 
 725:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 726:../uvc.c      **** 
 727:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 728:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 729:../uvc.c      **** #endif
 730:../uvc.c      **** 			  break;
 731:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 732:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 733:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 734:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 735:../uvc.c      **** 		 	 }
 736:../uvc.c      **** 
 737:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 738:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 739:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 740:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 741:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 742:../uvc.c      **** 			 }else
 743:../uvc.c      **** 			 {
 744:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 745:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 746:../uvc.c      **** 			 }
 747:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 748:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 749:../uvc.c      **** 			  break;
 750:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 751:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 752:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 753:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 754:../uvc.c      **** 		 	 }
 755:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 756:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 757:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 758:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 759:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 760:../uvc.c      **** 			 }else
 761:../uvc.c      **** 			 {
 762:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 763:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 764:../uvc.c      **** 			 }
 765:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 766:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 767:../uvc.c      **** 			  break;
 768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 769:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 770:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 771:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 772:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 773:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 774:../uvc.c      **** 		 	 }
 775:../uvc.c      **** 		 	 else{
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 777:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 778:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 779:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 780:../uvc.c      **** 		 	 }
 781:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 782:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 783:../uvc.c      **** 			  break;
 784:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 785:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 786:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 787:../uvc.c      **** 		 	 }
 788:../uvc.c      **** 		 	 else{
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 790:../uvc.c      **** 		 	 }
 791:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 792:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 793:../uvc.c      **** 			  Len = 1;
 794:../uvc.c      **** 			  break;
 795:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 796:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 797:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 798:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 799:../uvc.c      **** 		 	 }
 800:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 801:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 802:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 803:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 804:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 805:../uvc.c      **** 			 }else{
 806:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 807:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 808:../uvc.c      **** 			 }
 809:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 810:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 811:../uvc.c      **** 			  break;
 812:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 813:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 814:../uvc.c      **** 				  glEp0Buffer, &readCount);
 815:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 816:../uvc.c      **** 			   {
 817:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 818:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 819:../uvc.c      **** 				  getData = glEp0Buffer[0];
 820:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 821:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 822:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 823:../uvc.c      **** #endif
 824:../uvc.c      **** 				  switch(CtrlID)
 825:../uvc.c      **** 					 {
 826:../uvc.c      **** 						 case ExtShutCtlID0:
 827:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 828:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 829:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 830:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 831:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 832:../uvc.c      **** 						     {
 833:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 834:../uvc.c      **** 						    	 dataIdx = 0;
 835:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 836:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 837:../uvc.c      **** 								 dataIdx++;
 838:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 839:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 840:../uvc.c      **** 						     }
 841:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 842:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 843:../uvc.c      **** 						     break;
 844:../uvc.c      **** 						     /*
 845:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 846:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 847:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 848:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 849:../uvc.c      **** 									 }else{
 850:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 851:../uvc.c      **** 									 }
 852:../uvc.c      **** 								 }
 853:../uvc.c      **** 							 }else{
 854:../uvc.c      **** 								 Data1 = Data0 - 1;
 855:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 856:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 857:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 858:../uvc.c      **** 									 }else{
 859:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 860:../uvc.c      **** 									 }
 861:../uvc.c      **** 								 }
 862:../uvc.c      **** 								 if(Data1 < 8){
 863:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 864:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 865:../uvc.c      **** 								 }else{
 866:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 867:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 868:../uvc.c      **** 								 }
 869:../uvc.c      **** 							 }
 870:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 873:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 874:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 875:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 876:../uvc.c      **** 							 break;
 877:../uvc.c      **** 							 */
 878:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 879:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 880:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 881:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 882:../uvc.c      **** 						     dataIdx = 0;
 883:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 884:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 885:../uvc.c      **** 							 {
 886:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 887:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 888:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 889:../uvc.c      **** 								 /*
 890:../uvc.c      **** 								 dataIdx++;
 891:../uvc.c      **** 								 if(getData == 1 || getData == 3){
 892:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
 893:../uvc.c      **** 									 dataIdx++;
 894:../uvc.c      **** 								 }else{
 895:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
 896:../uvc.c      **** 									 dataIdx++;
 897:../uvc.c      **** 								 }
 898:../uvc.c      **** 								 */
 899:../uvc.c      **** 							 }
 900:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 901:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 902:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 903:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 904:../uvc.c      **** 								 }
 905:../uvc.c      **** 							 }
 906:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
 907:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 908:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 909:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 910:../uvc.c      **** 							 break;
 911:../uvc.c      **** 
 912:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
 913:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 914:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 915:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 916:../uvc.c      **** 						     dataIdx = 0;
 917:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 918:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 919:../uvc.c      **** 							 {
 920:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
 921:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 922:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 923:../uvc.c      **** 								 dataIdx++;
 924:../uvc.c      **** 							 }
 925:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 926:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 927:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 928:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 929:../uvc.c      **** 									 dataIdx++;
 930:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 931:../uvc.c      **** 								 }
 932:../uvc.c      **** 							 }
 933:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
 934:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 937:../uvc.c      **** 							 break;
 938:../uvc.c      **** 						 case ExtCamMCtlID12:
 939:../uvc.c      **** 							 dataIdx = 0;
 940:../uvc.c      **** 							 if(Data0 <= 3){
 941:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 942:../uvc.c      **** 								 Data1 = Data0;
 943:../uvc.c      **** 							 }else{
 944:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 945:../uvc.c      **** 								 Data1 = Data0-4;
 946:../uvc.c      **** 							 }
 947:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 948:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 950:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 951:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 952:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 953:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 954:../uvc.c      **** 							 break;
 955:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 956:../uvc.c      **** 							 dataIdx = 0;
 957:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 958:../uvc.c      **** 								 Data0 = 1;
 959:../uvc.c      **** 							 }else{ //save current sensor parameters.
 960:../uvc.c      **** 								 Data0 = 0;
 961:../uvc.c      **** 							 }
 962:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 963:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 964:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 965:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 966:../uvc.c      **** 							 break;
 967:../uvc.c      **** 						 case ExtI2CCtlID15:
 968:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 969:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 970:../uvc.c      **** 					 		 }
 971:../uvc.c      **** 					 		I2CCmdHandler();
 972:../uvc.c      **** 							 break;
 973:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 974:../uvc.c      **** 							 dataIdx = 0;
 975:../uvc.c      **** #if 0 //seperate version
 976:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 977:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 978:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 979:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 980:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 981:../uvc.c      **** 							 }else{ //disable BLD window
 982:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 983:../uvc.c      **** 							 }
 984:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 985:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 986:../uvc.c      **** 							 dataIdx++;
 987:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 988:../uvc.c      **** 							 dataIdx++;
 989:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 990:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 991:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 992:../uvc.c      **** 							 dataIdx++;
 993:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 994:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 995:../uvc.c      **** #else //combination version
 996:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 997:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 998:../uvc.c      **** 						     /* end test */
 999:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1000:../uvc.c      **** 							 dataIdx++;
1001:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1002:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1003:../uvc.c      **** 							 getData1 = Data1;
1004:../uvc.c      **** #endif
1005:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
1006:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
1007:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1008:../uvc.c      **** 							 break;
1009:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
1010:../uvc.c      **** 							 dataIdx = 0;
1011:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1012:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1013:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1014:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1015:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1016:../uvc.c      **** 							 break;
1017:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
1018:../uvc.c      **** 							 dataIdx = 0;
1019:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1020:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1021:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1022:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1023:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1024:../uvc.c      **** 							 break;
1025:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1026:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1027:../uvc.c      **** 							 dataIdx = 0;
1028:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1029:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1030:../uvc.c      **** 							  if(Data0&0x80){
1031:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1032:../uvc.c      **** 							  }else{
1033:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1034:../uvc.c      **** 							  }
1035:../uvc.c      **** 							 Data1 |= ~0x03;
1036:../uvc.c      **** 							 Data1 &= 0xC7;
1037:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1038:../uvc.c      **** 						  	 dataIdx++;
1039:../uvc.c      **** 
1040:../uvc.c      **** 							 Data0 = (Data0 << 2);
1041:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1042:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 
1044:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1045:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1046:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1047:../uvc.c      **** #endif
1048:../uvc.c      **** 							 dataIdx = 0;
1049:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1050:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1051:../uvc.c      **** 							  if(Data0&0x80){
1052:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1053:../uvc.c      **** 							  }else{
1054:../uvc.c      **** 								  Data0 = ~Data0;
1055:../uvc.c      **** 							  }
1056:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1057:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1058:../uvc.c      **** 
1059:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1060:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1061:../uvc.c      **** 
1062:../uvc.c      **** 
1063:../uvc.c      **** 							 break;
1064:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1065:../uvc.c      **** 							 dataIdx = 0;
1066:../uvc.c      **** 
1067:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1068:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1069:../uvc.c      **** 							 dataIdx++;
1070:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1071:../uvc.c      **** 							 dataIdx++;
1072:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1073:../uvc.c      **** 							 dataIdx++;
1074:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1075:../uvc.c      **** 							 dataIdx++;
1076:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1077:../uvc.c      **** 							 dataIdx++;
1078:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1079:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1080:../uvc.c      **** 
1081:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1082:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1083:../uvc.c      **** 							 break;
1084:../uvc.c      **** 						 case SaturCtlID6:
1085:../uvc.c      **** 							 dataIdx = 0;
1086:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1087:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1088:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1089:../uvc.c      **** 							 dataIdx++;
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1092:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1093:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1094:../uvc.c      **** 							 break;
1095:../uvc.c      **** 
1096:../uvc.c      **** 						 case WBTLevCtlID11:
1097:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1098:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1099:../uvc.c      **** 							 dataIdx = 0;
1100:../uvc.c      **** 
1101:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1102:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1103:../uvc.c      **** 							 dataIdx++;
1104:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1105:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1106:../uvc.c      **** 
1107:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1108:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1109:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1110:../uvc.c      **** 							 break;
1111:../uvc.c      **** 						 case MFreqCtlID4:
1112:../uvc.c      **** 							 dataIdx = 0;
1113:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1114:../uvc.c      **** 							 Data0 = Data0 - 1;
1115:../uvc.c      **** 							 is60Hz = Data0;
1116:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1117:../uvc.c      **** 							 {
1118:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1119:../uvc.c      **** 								 is60Hz = CyFalse;
1120:../uvc.c      **** 							 }
1121:../uvc.c      **** 							 else if(Data0 >2)
1122:../uvc.c      **** 							 {
1123:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1124:../uvc.c      **** 								 is60Hz = CyTrue;
1125:../uvc.c      **** 							 }
1126:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1127:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1128:../uvc.c      **** 							 {
1129:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1130:../uvc.c      **** 			                       switch (setRes)
1131:../uvc.c      **** 			                         {
1132:../uvc.c      **** 			                         	case 1: //1944
1133:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1134:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1135:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
1136:../uvc.c      **** 			                         		break;
1137:../uvc.c      **** 			                         	case 2: //1080
1138:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1139:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1140:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
1141:../uvc.c      **** 			                         		break;
1142:../uvc.c      **** 			                         	case 3: //720
1143:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1144:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1145:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is
1146:../uvc.c      **** 			                         		break;
1147:../uvc.c      **** 			                         	default:
1148:../uvc.c      **** 			                         		break;
1149:../uvc.c      **** 			                         }
1150:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1151:../uvc.c      **** 							 }
1152:../uvc.c      **** 
1153:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1154:../uvc.c      **** 							 break;
1155:../uvc.c      **** 					 	 case BLCCtlID0:
1156:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1157:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1158:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1159:../uvc.c      **** 							 {
1160:../uvc.c      **** 								 if(Data0 < 3){
1161:../uvc.c      **** 					 				 Data0 += 4;
1162:../uvc.c      **** 					 			 }else{
1163:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1164:../uvc.c      **** 									Data0 = 4; //set to default.
1165:../uvc.c      **** 					 			 }
1166:../uvc.c      **** 					 		 }
1167:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
1168:../uvc.c      **** 							 dataIdx = 0;
1169:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1170:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1171:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1172:../uvc.c      **** 
1173:../uvc.c      **** 					 		 break;
1174:../uvc.c      **** 						 default:
1175:../uvc.c      **** 							 dataIdx = 0;
1176:../uvc.c      **** 
1177:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1179:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1180:../uvc.c      **** 
1181:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1182:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1183:../uvc.c      **** 							 break;
1184:../uvc.c      **** 					 }
1185:../uvc.c      **** 			   }else{
1186:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1187:../uvc.c      **** 			   }
1188:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1189:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1190:../uvc.c      **** #endif
1191:../uvc.c      **** 
1192:../uvc.c      **** 			  break;
1193:../uvc.c      **** 		  default:
1194:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 }
1197:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1198:../uvc.c      **** }
1199:../uvc.c      **** /************** CT control requests handler *************************/
1200:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1201:../uvc.c      **** 
1202:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1203:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1204:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1205:../uvc.c      ****     uint16_t readCount;
1206:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1207:../uvc.c      ****     uint16_t diff, value, diffRd;
1208:../uvc.c      ****     uint8_t i, shutter, index;
1209:../uvc.c      ****     diff = 0xffff;
1210:../uvc.c      ****     shutter = 1;
1211:../uvc.c      ****     index = 1;
1212:../uvc.c      **** 
1213:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1214:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1215:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1216:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1217:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1218:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1219:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1220:../uvc.c      **** #endif
1221:../uvc.c      ****     reqData = bRequest;
1222:../uvc.c      **** 
1223:../uvc.c      ****     switch (bRequest)
1224:../uvc.c      **** 		 {
1225:../uvc.c      **** 
1226:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1227:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1228:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1230:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1231:../uvc.c      **** 			  break;
1232:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1233:../uvc.c      **** 
1234:../uvc.c      **** 			 switch(CtrlID)
1235:../uvc.c      **** 			 {
1236:../uvc.c      **** 				 default:
1237:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1238:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1239:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1240:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1241:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1242:../uvc.c      **** 					 break;
1243:../uvc.c      **** 			 }
1244:../uvc.c      **** 
1245:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1246:../uvc.c      **** 
1247:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1248:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1249:../uvc.c      **** #endif
1250:../uvc.c      **** 			  break;
1251:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1252:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1253:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1254:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1255:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1256:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1257:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1258:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1259:../uvc.c      **** 			  break;
1260:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1261:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1262:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1263:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1264:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1265:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1266:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1267:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1268:../uvc.c      **** 			  break;
1269:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1270:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1271:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1272:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1273:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1274:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1275:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1276:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1277:../uvc.c      **** 			  break;
1278:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1279:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1280:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1281:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1282:../uvc.c      **** 			  Len = 1;
1283:../uvc.c      **** 			  break;
1284:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1285:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1288:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1289:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1290:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1291:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1292:../uvc.c      **** 			  break;
1293:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1294:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1295:../uvc.c      **** 			  glEp0Buffer, &readCount);
1296:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1297:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1298:../uvc.c      **** 			  value = Data1;
1299:../uvc.c      **** 
1300:../uvc.c      **** 			  switch(CtrlID)
1301:../uvc.c      **** 			  {
1302:../uvc.c      **** 		  	      case AutoExMCtlID1:
1303:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1304:../uvc.c      **** 
1305:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1306:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1307:../uvc.c      **** 				    getData = glEp0Buffer[0];
1308:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1309:../uvc.c      **** 		  		    switch (getData){
1310:../uvc.c      **** 						case 1:
1311:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1312:../uvc.c      **** 							break;
1313:../uvc.c      **** 						case 2:
1314:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1315:../uvc.c      **** 							dataIdx = 0;
1316:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1317:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1318:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1319:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1320:../uvc.c      **** 
1321:../uvc.c      **** 							break;
1322:../uvc.c      **** 						case 4:
1323:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1324:../uvc.c      **** 							break;
1325:../uvc.c      **** 						case 8:
1326:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1327:../uvc.c      **** 			  		    	dataIdx = 0;
1328:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1329:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1330:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1331:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1332:../uvc.c      **** 							break;
1333:../uvc.c      **** 		  		    }
1334:../uvc.c      **** #if 0
1335:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1336:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1337:../uvc.c      **** 						  dataIdx = 0;
1338:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1339:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1340:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1341:../uvc.c      **** 		  		    }
1342:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1343:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1344:../uvc.c      **** 		  		    }
1345:../uvc.c      **** #endif
1346:../uvc.c      **** 				    break;
1347:../uvc.c      **** 
1348:../uvc.c      **** 			  	  case ExTmACtlID3:
1349:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1350:../uvc.c      **** 
1351:../uvc.c      **** 					  value = (value << 8)|Data0;
1352:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1353:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1354:../uvc.c      **** 					  {
1355:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1356:../uvc.c      **** 						  {
1357:../uvc.c      **** 							if(value > ShutValueArry[i]){
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1359:../uvc.c      **** 							}else{
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1361:../uvc.c      **** 							}
1362:../uvc.c      **** 							  if(diff > diffRd){
1363:../uvc.c      **** 								  diff = diffRd;
1364:../uvc.c      **** 								  index = i;
1365:../uvc.c      **** 							  }
1366:../uvc.c      **** 						  }
1367:../uvc.c      **** 						  shutter = shutter+index;
1368:../uvc.c      **** 
1369:../uvc.c      **** 						  dataIdx = 0;
1370:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1371:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1372:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1373:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1374:../uvc.c      **** 
1375:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1376:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1377:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1378:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1379:../uvc.c      **** 					  }else{
1380:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1381:../uvc.c      **** 					  }
1382:../uvc.c      **** 					  getData = glEp0Buffer[0];
1383:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1384:../uvc.c      **** 					  break;
1385:../uvc.c      **** 			  	  case IriACtlID7:
1386:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1387:../uvc.c      **** 					  {
1388:../uvc.c      **** 							 dataIdx = 0;
1389:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1390:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1391:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1392:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1393:../uvc.c      **** 
1394:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1395:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1396:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1397:../uvc.c      **** 					  }else{
1398:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1399:../uvc.c      **** 					  }
1400:../uvc.c      **** 					  getData = glEp0Buffer[0];
1401:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1402:../uvc.c      **** 
1403:../uvc.c      **** 					  break;
1404:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1405:../uvc.c      **** 					  getData = glEp0Buffer[0];
1406:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1407:../uvc.c      **** #if 1
1408:../uvc.c      **** 					  dataIdx = 0;
1409:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1410:../uvc.c      **** 					  if(getData == 1)
1411:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1412:../uvc.c      **** 					  else if(getData == 0xff)
1413:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1414:../uvc.c      **** 					  else
1415:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1416:../uvc.c      **** 					  //dataIdx++;
1417:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1418:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1419:../uvc.c      **** #endif
1420:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1421:../uvc.c      **** 					  break;
1422:../uvc.c      **** 
1423:../uvc.c      **** 			  	  default:
1424:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1425:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1426:../uvc.c      **** 			  		 break;
1427:../uvc.c      **** 			  }
1428:../uvc.c      **** 			  break;
1429:../uvc.c      **** 		  default:
1430:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1431:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1432:../uvc.c      **** 			  break;
1433:../uvc.c      **** 		 }
1434:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1435:../uvc.c      **** 
1436:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1437:../uvc.c      **** }
1438:../uvc.c      **** 
1439:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1440:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1441:../uvc.c      **** {
1442:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1443:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1444:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1445:../uvc.c      **** 
1446:../uvc.c      ****     CtrlID = BrgtCtlID1;
1447:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1448:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1449:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1450:../uvc.c      ****     Data1 = Data0;
1451:../uvc.c      **** 
1452:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1453:../uvc.c      ****     if(Data1&0x80){
1454:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1455:../uvc.c      ****     }else{
1456:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1457:../uvc.c      ****     }
1458:../uvc.c      ****     Data0 = (Data0 << 2);
1459:../uvc.c      **** 
1460:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1461:../uvc.c      **** 
1462:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1463:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1464:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1465:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1466:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1467:../uvc.c      **** 
1468:../uvc.c      ****     CtrlID = ConsCtlID2;
1469:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1470:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1471:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1472:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1473:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1474:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1475:../uvc.c      **** 
1476:../uvc.c      ****     CtrlID = HueCtlID5;
1477:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1478:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1479:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1480:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1483:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1484:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1485:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1486:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1487:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1488:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1489:../uvc.c      **** 
1490:../uvc.c      ****     CtrlID = SaturCtlID6;
1491:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1492:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1493:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1494:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1495:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1496:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1497:../uvc.c      **** 
1498:../uvc.c      ****     CtrlID = ShapCtlID7;
1499:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1500:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1501:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1502:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1503:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1504:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1505:../uvc.c      **** 
1506:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1507:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1508:../uvc.c      **** 	return;
1509:../uvc.c      **** }
1510:../uvc.c      **** 
1511:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1512:../uvc.c      **** void
1513:../uvc.c      **** CyFxUVCAddHeader (
1514:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1515:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1516:../uvc.c      ****         )
1517:../uvc.c      **** {
1518:../uvc.c      ****     /* Copy header to buffer */
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1520:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1521:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1522:../uvc.c      **** 
1523:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1524:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1525:../uvc.c      ****     {
1526:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1527:../uvc.c      ****     }
1528:../uvc.c      **** }
1529:../uvc.c      **** 
1530:../uvc.c      **** 
1531:../uvc.c      **** /* Application Error Handler */
1532:../uvc.c      **** void
1533:../uvc.c      **** CyFxAppErrorHandler (
1534:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1535:../uvc.c      ****         )
1536:../uvc.c      **** {
1537:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1538:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1539:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1540:../uvc.c      **** 
1541:../uvc.c      ****        This function can be modified to take additional error handling actions such
1542:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1543:../uvc.c      ****      */
1544:../uvc.c      ****     for (;;)
1545:../uvc.c      ****     {
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
1548:../uvc.c      ****     }
1549:../uvc.c      **** }
1550:../uvc.c      **** 
1551:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1552:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1553:../uvc.c      ****  */
1554:../uvc.c      **** static void
1555:../uvc.c      **** CyFxUVCApplnAbortHandler (
1556:../uvc.c      ****         void)
1557:../uvc.c      **** {
1558:../uvc.c      **** 	uint32_t flag;
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1560:../uvc.c      **** 	{
1561:../uvc.c      ****         /* Clear the Video Stream Request Event */
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1563:../uvc.c      **** 
1564:../uvc.c      ****         /* Set Video Stream Abort Event */
1565:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1566:../uvc.c      **** 	}
1567:../uvc.c      **** }
1568:../uvc.c      **** 
1569:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1570:../uvc.c      **** static void
1571:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1572:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1573:../uvc.c      ****         uint16_t             evdata  /* Event data */
1574:../uvc.c      ****         )
1575:../uvc.c      **** {
1576:../uvc.c      ****     switch (evtype)
1577:../uvc.c      ****     {
1578:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1579:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1580:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1581:../uvc.c      ****             gpif_initialized = 0;
1582:../uvc.c      ****             streamingStarted = CyFalse;
1583:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1584:../uvc.c      ****             break;
1585:../uvc.c      **** 
1586:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1587:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1588:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1589:../uvc.c      ****             gpif_initialized = 0;
1590:../uvc.c      ****             streamingStarted = CyFalse;
1591:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1592:../uvc.c      ****             break;
1593:../uvc.c      **** 
1594:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1595:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1596:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1597:../uvc.c      ****             gpif_initialized = 0;
1598:../uvc.c      ****             isUsbConnected = CyFalse;
1599:../uvc.c      ****             streamingStarted = CyFalse;
1600:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1601:../uvc.c      ****             break;
1602:../uvc.c      **** 
1603:../uvc.c      **** #ifdef BACKFLOW_DETECT
1604:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1605:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1606:../uvc.c      ****             break;
1607:../uvc.c      **** #endif
1608:../uvc.c      **** 
1609:../uvc.c      ****         default:
1610:../uvc.c      ****             break;
1611:../uvc.c      ****     }
1612:../uvc.c      **** }
1613:../uvc.c      **** 
1614:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1615:../uvc.c      **** static CyBool_t
1616:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1617:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1618:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1619:../uvc.c      ****         )
1620:../uvc.c      **** {
1621:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1622:../uvc.c      ****     uint32_t status;
1623:../uvc.c      **** 
1624:../uvc.c      ****     /* Obtain Request Type and Request */
1625:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1626:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1627:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1628:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1629:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1630:../uvc.c      **** 
1631:../uvc.c      ****     /* Check for UVC Class Requests */
1632:../uvc.c      ****     switch (bmReqType)
1633:../uvc.c      ****     {
1634:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1635:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1636:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1637:../uvc.c      ****             switch (wIndex & 0xFF)
1638:../uvc.c      ****             {
1639:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1640:../uvc.c      ****                     {
1641:../uvc.c      ****                         uvcHandleReq = CyTrue;
1642:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1643:../uvc.c      ****                                 CYU3P_EVENT_OR);
1644:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1645:../uvc.c      ****                         {
1646:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1647:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1648:../uvc.c      ****                         }
1649:../uvc.c      ****                     }
1650:../uvc.c      ****                     break;
1651:../uvc.c      **** 
1652:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1653:../uvc.c      ****                     {
1654:../uvc.c      ****                         uvcHandleReq = CyTrue;
1655:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1656:../uvc.c      ****                                 CYU3P_EVENT_OR);
1657:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1658:../uvc.c      ****                         {
1659:../uvc.c      ****                             /* Error handling */
1660:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1661:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1662:../uvc.c      ****                         }
1663:../uvc.c      ****                     }
1664:../uvc.c      ****                     break;
1665:../uvc.c      **** 
1666:../uvc.c      ****                 default:
1667:../uvc.c      ****                     break;
1668:../uvc.c      ****             }
1669:../uvc.c      ****             break;
1670:../uvc.c      **** 
1671:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1672:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1673:../uvc.c      ****             {
1674:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1675:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1676:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1677:../uvc.c      ****                 {
1678:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1679:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1680:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1681:../uvc.c      ****                     gpif_initialized = 0;
1682:../uvc.c      ****                     streamingStarted = CyFalse;
1683:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1684:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1685:../uvc.c      ****                     CyU3PBusyWait (100);
1686:../uvc.c      **** 
1687:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1688:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1689:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1690:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1691:../uvc.c      ****                     CyU3PBusyWait (100);
1692:../uvc.c      **** 
1693:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1694:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1695:../uvc.c      ****                     uvcHandleReq = CyTrue;
1696:../uvc.c      ****                     /* Complete Control request handshake */
1697:../uvc.c      ****                     CyU3PUsbAckSetup ();
1698:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1699:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1700:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1701:../uvc.c      **** 
1702:../uvc.c      ****                 }
1703:../uvc.c      ****             }
1704:../uvc.c      ****             break;
1705:../uvc.c      **** 
1706:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1707:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1708:../uvc.c      ****             {
1709:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1710:../uvc.c      ****                 {
1711:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1712:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1713:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1714:../uvc.c      ****                 	 * has started. */
1715:../uvc.c      ****                     if (streamingStarted == CyTrue)
1716:../uvc.c      ****                     {
1717:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1718:../uvc.c      **** 
1719:../uvc.c      ****                         /* Disable the GPIF state machine. */
1720:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1721:../uvc.c      ****                         gpif_initialized = 0;
1722:../uvc.c      ****                         streamingStarted = CyFalse;
1723:../uvc.c      **** 
1724:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1725:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1726:../uvc.c      ****                         CyU3PBusyWait (100);
1727:../uvc.c      **** 
1728:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1729:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1730:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1731:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1732:../uvc.c      ****                         CyU3PBusyWait (100);
1733:../uvc.c      **** 
1734:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1735:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1736:../uvc.c      **** 
1737:../uvc.c      ****                         uvcHandleReq = CyTrue;
1738:../uvc.c      ****                         /* Complete Control request handshake */
1739:../uvc.c      ****                         CyU3PUsbAckSetup ();
1740:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1741:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1742:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1743:../uvc.c      ****                     }
1744:../uvc.c      ****                     else
1745:../uvc.c      ****                     {
1746:../uvc.c      ****                         uvcHandleReq = CyTrue;
1747:../uvc.c      ****                         CyU3PUsbAckSetup ();
1748:../uvc.c      ****                     }
1749:../uvc.c      ****                 }
1750:../uvc.c      ****             }
1751:../uvc.c      ****             break;
1752:../uvc.c      **** 
1753:../uvc.c      ****         default:
1754:../uvc.c      ****             break;
1755:../uvc.c      ****     }
1756:../uvc.c      **** 
1757:../uvc.c      ****     /* Return status of request handling to the USB driver */
1758:../uvc.c      ****     return uvcHandleReq;
1759:../uvc.c      **** }
1760:../uvc.c      **** 
1761:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1762:../uvc.c      **** 
1763:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1764:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1765:../uvc.c      ****  */
1766:../uvc.c      **** void
1767:../uvc.c      **** CyFxUvcApplnDmaCallback (
1768:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1769:../uvc.c      ****         CyU3PDmaCbType_t      type,
1770:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1771:../uvc.c      ****         )
1772:../uvc.c      **** {
1773:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1774:../uvc.c      **** #if 1
1775:../uvc.c      ****     CyU3PReturnStatus_t status;
1776:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1777:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1778:../uvc.c      **** 
1779:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1780:../uvc.c      ****     {
1781:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1782:../uvc.c      ****             {
1783:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
1784:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
1785:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1786:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
1787:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1788:../uvc.c      ****                 	stiflag = 0x03;
1789:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
1790:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1791:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1792:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1793:../uvc.c      ****                 }
1794:../uvc.c      **** #endif
1795:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
1796:../uvc.c      ****                 fb++;
1797:../uvc.c      ****             }
1798:../uvc.c      ****             else
1799:../uvc.c      ****             {
1800:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1801:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1802:../uvc.c      ****                 pb++;
1803:../uvc.c      ****                 pbc = input->buffer_p.count;
1804:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1805:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1806:../uvc.c      ****                 //lineCount = 0; //res test
1807:../uvc.c      **** #if 1   //remove the still flag clearing here
1808:../uvc.c      ****                 if(stiflag == 0x0F){
1809:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1810:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1811:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1812:../uvc.c      ****                 	stiflag = 0xAA;
1813:../uvc.c      ****                 }
1814:../uvc.c      **** #endif
1815:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1816:../uvc.c      ****             }
1817:../uvc.c      **** 
1818:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1819:../uvc.c      ****             prodCount++;
1820:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1821:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1822:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1823:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1824:../uvc.c      ****             {
1825:../uvc.c      ****                 prodCount--;
1826:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1827:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1828:../uvc.c      ****             }
1829:../uvc.c      ****     }
1830:../uvc.c      **** #endif
1831:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1832:../uvc.c      ****     {
1833:../uvc.c      ****         consCount++;
1834:../uvc.c      ****         streamingStarted = CyTrue;
1835:../uvc.c      ****     }
1836:../uvc.c      **** }
1837:../uvc.c      **** 
1838:../uvc.c      **** /*
1839:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1840:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1841:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1842:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1843:../uvc.c      ****  * to commit the buffer.
1844:../uvc.c      ****  */
1845:../uvc.c      **** static uint8_t
1846:../uvc.c      **** CyFxUvcAppCommitEOF (
1847:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1848:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1849:../uvc.c      ****         )
1850:../uvc.c      **** {
1851:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1852:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1853:../uvc.c      **** 
1854:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1855:../uvc.c      **** 
1856:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1857:../uvc.c      ****     {
1858:../uvc.c      ****         switch (stateId)
1859:../uvc.c      ****         {
1860:../uvc.c      **** 
1861:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1862:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1863:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1864:../uvc.c      ****                 break;
1865:../uvc.c      **** 
1866:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1867:../uvc.c      ****                 socket = 0;
1868:../uvc.c      ****                 break;
1869:../uvc.c      **** 
1870:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1871:../uvc.c      ****                 socket = 1;
1872:../uvc.c      ****                 break;
1873:../uvc.c      **** 
1874:../uvc.c      ****             default:
1875:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1876:../uvc.c      ****                 /* Unexpected current state. Return error. */
1877:../uvc.c      ****             	//lineCount++;
1878:../uvc.c      ****             	return 1;
1879:../uvc.c      ****         }
1880:../uvc.c      ****     }
1881:../uvc.c      **** 
1882:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1883:../uvc.c      ****     {
1884:../uvc.c      ****         switch (stateId)
1885:../uvc.c      ****         {
1886:../uvc.c      **** #ifndef CAM720
1887:../uvc.c      **** #ifdef GPIFIIM
1888:../uvc.c      ****             case 13:
1889:../uvc.c      ****             case 24:
1890:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1891:../uvc.c      ****                 break;
1892:../uvc.c      **** 
1893:../uvc.c      ****             case 8:
1894:../uvc.c      ****                 socket = 0;
1895:../uvc.c      ****                 break;
1896:../uvc.c      **** 
1897:../uvc.c      ****             case 20:
1898:../uvc.c      ****                 socket = 1;
1899:../uvc.c      ****                 break;
1900:../uvc.c      **** #else
1901:../uvc.c      ****             case 11:
1902:../uvc.c      ****             case 18:
1903:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1904:../uvc.c      ****                 break;
1905:../uvc.c      **** 
1906:../uvc.c      ****             case 8:
1907:../uvc.c      ****                 socket = 0;
1908:../uvc.c      ****                 break;
1909:../uvc.c      **** 
1910:../uvc.c      ****             case 15:
1911:../uvc.c      ****                 socket = 1;
1912:../uvc.c      ****                 break;
1913:../uvc.c      **** #endif
1914:../uvc.c      **** #else
1915:../uvc.c      ****             case 11:
1916:../uvc.c      ****             case 18:
1917:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1918:../uvc.c      ****                 break;
1919:../uvc.c      **** 
1920:../uvc.c      ****             case 8:
1921:../uvc.c      ****                 socket = 0;
1922:../uvc.c      ****                 break;
1923:../uvc.c      **** 
1924:../uvc.c      ****             case 15:
1925:../uvc.c      ****                 socket = 1;
1926:../uvc.c      ****                 break;
1927:../uvc.c      **** 
1928:../uvc.c      **** #endif
1929:../uvc.c      ****              default:
1930:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1931:../uvc.c      ****                 /* Unexpected current state. Return error. */
1932:../uvc.c      ****                return 1;
1933:../uvc.c      ****         }
1934:../uvc.c      ****     }
1935:../uvc.c      **** 
1936:../uvc.c      ****     if (socket != 0xFF)
1937:../uvc.c      ****     {
1938:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1939:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1940:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1941:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1942:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1943:../uvc.c      ****         {
1944:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1945:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1946:../uvc.c      ****         }
1947:../uvc.c      ****     }
1948:../uvc.c      **** 
1949:../uvc.c      ****     return 0;
1950:../uvc.c      **** }
1951:../uvc.c      **** 
1952:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1953:../uvc.c      **** void
1954:../uvc.c      **** CyFxGpifCB (
1955:../uvc.c      ****         CyU3PGpifEventType event,
1956:../uvc.c      ****         uint8_t currentState
1957:../uvc.c      ****         )
1958:../uvc.c      **** {
1959:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1960:../uvc.c      ****     {
1961:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1962:../uvc.c      ****     	           in the UVC implementation. */
1963:../uvc.c      ****     	//hitFV = CyTrue;
1964:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1965:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1966:../uvc.c      ****     }
1967:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1968:../uvc.c      **** }
1969:../uvc.c      **** 
1970:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1971:../uvc.c      **** static void
1972:../uvc.c      **** CyFxUVCApplnDebugInit (
1973:../uvc.c      ****         void)
1974:../uvc.c      **** {
1975:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1976:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1977:../uvc.c      **** 
1978:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1979:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1980:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1981:../uvc.c      ****     {
1982:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1983:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1984:../uvc.c      ****     }
1985:../uvc.c      **** 
1986:../uvc.c      ****     /* Set UART Configuration */
1987:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1988:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1989:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1990:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1991:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1992:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1993:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1994:../uvc.c      **** 
1995:../uvc.c      ****     /* Set the UART configuration */
1996:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1998:../uvc.c      ****     {
1999:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2000:../uvc.c      ****     }
2001:../uvc.c      **** 
2002:../uvc.c      ****     /* Set the UART transfer */
2003:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2004:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2005:../uvc.c      ****     {
2006:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2007:../uvc.c      ****     }
2008:../uvc.c      **** 
2009:../uvc.c      ****     /* Initialize the Debug logger module. */
2010:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2011:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2012:../uvc.c      ****     {
2013:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2014:../uvc.c      ****     }
2015:../uvc.c      **** 
2016:../uvc.c      ****     /* Disable log message headers. */
2017:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2018:../uvc.c      **** }
2019:../uvc.c      **** 
2020:../uvc.c      **** /* I2C initialization. */
2021:../uvc.c      **** static void
2022:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2023:../uvc.c      **** {
2024:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2025:../uvc.c      ****     CyU3PReturnStatus_t status;
2026:../uvc.c      **** 
2027:../uvc.c      ****     status = CyU3PI2cInit ();
2028:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2029:../uvc.c      ****     {
2030:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2031:../uvc.c      ****         CyFxAppErrorHandler (status);
2032:../uvc.c      ****     }
2033:../uvc.c      **** 
2034:../uvc.c      ****     /*  Set I2C Configuration */
2035:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2036:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2037:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2038:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2039:../uvc.c      **** 
2040:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2041:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2042:../uvc.c      ****     {
2043:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2044:../uvc.c      ****         CyFxAppErrorHandler (status);
2045:../uvc.c      ****     }
2046:../uvc.c      **** }
2047:../uvc.c      **** 
2048:../uvc.c      **** #ifdef BACKFLOW_DETECT
2049:../uvc.c      **** static void CyFxUvcAppPibCallback (
2050:../uvc.c      ****         CyU3PPibIntrType cbType,
2051:../uvc.c      ****         uint16_t cbArg)
2052:../uvc.c      **** {
2053:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2054:../uvc.c      ****     {
2055:../uvc.c      ****         if (!back_flow_detected)
2056:../uvc.c      ****         {
2057:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2058:../uvc.c      ****             back_flow_detected = 1;
2059:../uvc.c      ****         }
2060:../uvc.c      ****     }
2061:../uvc.c      **** }
2062:../uvc.c      **** #endif
2063:../uvc.c      **** 
2064:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2065:../uvc.c      **** static void
2066:../uvc.c      **** CyFxUvcAppDebugCallback (
2067:../uvc.c      ****         CyU3PDmaChannel   *handle,
2068:../uvc.c      ****         CyU3PDmaCbType_t   type,
2069:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2070:../uvc.c      **** {
2071:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2074:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2075:../uvc.c      ****     }
2076:../uvc.c      **** }
2077:../uvc.c      **** #endif
2078:../uvc.c      **** 
2079:../uvc.c      **** #if 0
2080:../uvc.c      **** static void CyFxAppIntEpCb(
2081:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2082:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2083:../uvc.c      **** 		uint8_t  ebNum)
2084:../uvc.c      **** 		{
2085:../uvc.c      **** 			//CyBool_t value;
2086:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2087:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2088:../uvc.c      **** 
2089:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2090:../uvc.c      **** 		}
2091:../uvc.c      **** #endif
2092:../uvc.c      **** 
2093:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2094:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2095:../uvc.c      ****    configures the DMA module for the UVC Application */
2096:../uvc.c      **** static void
2097:../uvc.c      **** CyFxUVCApplnInit (void)
2098:../uvc.c      **** {
2099:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2100:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2101:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2102:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2103:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2104:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2105:../uvc.c      **** 
2106:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2107:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2108:../uvc.c      **** 
2109:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2110:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2111:../uvc.c      **** #endif
2112:../uvc.c      **** 
2113:../uvc.c      ****     /* Create UVC event group */
2114:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2115:../uvc.c      ****     if (apiRetStatus != 0)
2116:../uvc.c      ****     {
2117:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2118:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2119:../uvc.c      ****     }
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2122:../uvc.c      ****     CyFxUvcAppPTZInit ();
2123:../uvc.c      **** #endif
2124:../uvc.c      **** 
2125:../uvc.c      ****     isUsbConnected = CyFalse;
2126:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2127:../uvc.c      **** 
2128:../uvc.c      ****     /* Init the GPIO module */
2129:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2130:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2131:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2132:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2133:../uvc.c      ****     gpioClock.halfDiv    = 0;
2134:../uvc.c      **** 
2135:../uvc.c      ****     /* Initialize Gpio interface */
2136:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2137:../uvc.c      ****     if (apiRetStatus != 0)
2138:../uvc.c      ****     {
2139:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2140:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2141:../uvc.c      ****     }
2142:../uvc.c      **** 
2143:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2144:../uvc.c      ****      * must use GpioOverride to configure it */
2145:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2146:../uvc.c      ****     if (apiRetStatus != 0)
2147:../uvc.c      ****     {
2148:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2149:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2150:../uvc.c      ****     }
2151:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2152:../uvc.c      ****     if (apiRetStatus != 0)
2153:../uvc.c      ****     {
2154:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2155:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2156:../uvc.c      ****     }
2157:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2158:../uvc.c      ****     if (apiRetStatus != 0)
2159:../uvc.c      ****     {
2160:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2161:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2162:../uvc.c      ****     }
2163:../uvc.c      **** 
2164:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2165:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2166:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2167:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2168:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2169:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2170:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2171:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2172:../uvc.c      ****     {
2173:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2174:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2175:../uvc.c      ****     }
2176:../uvc.c      **** 
2177:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2178:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2179:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2180:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2181:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2182:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2183:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2184:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2185:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2186:../uvc.c      ****     {
2187:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2188:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2189:../uvc.c      ****     }
2190:../uvc.c      **** 
2191:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2192:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2193:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2194:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2195:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2196:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2197:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2198:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2199:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2200:../uvc.c      ****     {
2201:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2202:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2203:../uvc.c      ****     }
2204:../uvc.c      **** 
2205:../uvc.c      ****     /* Initialize the P-port. */
2206:../uvc.c      ****     pibclock.clkDiv      = 2;
2207:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2208:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2209:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2210:../uvc.c      **** 
2211:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2213:../uvc.c      ****     {
2214:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2215:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2216:../uvc.c      ****     }
2217:../uvc.c      **** 
2218:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2219:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2220:../uvc.c      **** 
2221:../uvc.c      **** #ifdef BACKFLOW_DETECT
2222:../uvc.c      ****     back_flow_detected = 0;
2223:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2224:../uvc.c      **** #endif
2225:../uvc.c      **** 
2226:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2227:../uvc.c      ****     SensorReset ();
2228:../uvc.c      ****     CyU3PThreadSleep(5000);
2229:../uvc.c      ****     //SensorInit ();
2230:../uvc.c      **** 
2231:../uvc.c      ****     /* USB initialization. */
2232:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2233:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2234:../uvc.c      ****     {
2235:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2236:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2237:../uvc.c      ****     }
2238:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2239:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2240:../uvc.c      **** 
2241:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2242:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2243:../uvc.c      **** 
2244:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2245:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2246:../uvc.c      **** 
2247:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2248:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2249:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2250:../uvc.c      **** 
2251:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2252:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2253:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2254:../uvc.c      **** 
2255:../uvc.c      ****     /* Configuration descriptors. */
2256:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2257:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2258:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2259:../uvc.c      **** 
2260:../uvc.c      ****     /* String Descriptors */
2261:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2262:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2263:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2264:../uvc.c      **** 
2265:../uvc.c      ****     /* Configure the status interrupt endpoint.
2266:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2267:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2268:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2269:../uvc.c      ****      */
2270:../uvc.c      ****     endPointConfig.enable   = 1;
2271:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2272:../uvc.c      ****     endPointConfig.pcktSize = 64;
2273:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2274:../uvc.c      ****     endPointConfig.streams  = 0;
2275:../uvc.c      ****     endPointConfig.burstLen = 1;
2276:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2277:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2278:../uvc.c      ****     {
2279:../uvc.c      ****         /* Error Handling */
2280:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2281:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2282:../uvc.c      ****     }
2283:../uvc.c      **** 
2284:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2285:../uvc.c      ****     dmaInterConfig.size           = 1024;
2286:../uvc.c      ****     dmaInterConfig.count          = 1;
2287:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2288:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2289:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2290:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2291:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2292:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2293:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2294:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2295:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2296:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2297:../uvc.c      ****             &dmaInterConfig);
2298:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2299:../uvc.c      ****     {
2300:../uvc.c      ****         /* Error handling */
2301:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2302:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2303:../uvc.c      ****     }
2304:../uvc.c      **** 
2305:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2306:../uvc.c      ****     if (glInterStaBuffer == 0)
2307:../uvc.c      ****     {
2308:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2309:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2310:../uvc.c      ****     }
2311:../uvc.c      **** 
2312:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2313:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2314:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2315:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2316:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2317:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2318:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2319:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2320:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2321:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2322:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2323:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2324:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2325:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2326:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2327:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2328:../uvc.c      ****             &dmaMultiConfig);
2329:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2330:../uvc.c      ****     {
2331:../uvc.c      ****         /* Error handling */
2332:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2333:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2334:../uvc.c      ****     }
2335:../uvc.c      **** 
2336:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2337:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2338:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2339:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2340:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2341:../uvc.c      ****      */
2342:../uvc.c      **** 
2343:../uvc.c      ****     endPointConfig.enable   = 1;
2344:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2345:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2346:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2347:../uvc.c      ****     endPointConfig.streams  = 0;
2348:../uvc.c      ****     endPointConfig.burstLen = 1;
2349:../uvc.c      **** 
2350:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2351:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2352:../uvc.c      ****     {
2353:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2354:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2355:../uvc.c      ****     }
2356:../uvc.c      **** 
2357:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2358:../uvc.c      **** 
2359:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2360:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2363:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2364:../uvc.c      ****     }
2365:../uvc.c      **** 
2366:../uvc.c      ****     channelConfig.size           = 1024;
2367:../uvc.c      ****     channelConfig.count          = 1;
2368:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2369:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2370:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2371:../uvc.c      ****     channelConfig.prodHeader     = 0;
2372:../uvc.c      ****     channelConfig.prodFooter     = 0;
2373:../uvc.c      ****     channelConfig.consHeader     = 0;
2374:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2375:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2376:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2377:../uvc.c      **** 
2378:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2379:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2380:../uvc.c      ****     {
2381:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2382:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2383:../uvc.c      ****     }
2384:../uvc.c      **** 
2385:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2386:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2387:../uvc.c      ****     {
2388:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2389:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2390:../uvc.c      ****     }
2391:../uvc.c      **** 
2392:../uvc.c      ****     channelConfig.size           = 1024;
2393:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2394:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2395:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2396:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2397:../uvc.c      ****     channelConfig.prodHeader     = 0;
2398:../uvc.c      ****     channelConfig.prodFooter     = 0;
2399:../uvc.c      ****     channelConfig.consHeader     = 0;
2400:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2401:../uvc.c      ****     channelConfig.notification   = 0;
2402:../uvc.c      ****     channelConfig.cb             = 0;
2403:../uvc.c      **** 
2404:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2405:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2406:../uvc.c      ****     {
2407:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2408:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2409:../uvc.c      ****     }
2410:../uvc.c      **** 
2411:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2412:../uvc.c      ****     if (glDebugRspBuffer == 0)
2413:../uvc.c      ****     {
2414:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2415:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2416:../uvc.c      ****     }
2417:../uvc.c      **** #endif
2418:../uvc.c      **** 
2419:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2420:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2421:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2422:../uvc.c      ****     {
2423:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2424:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2425:../uvc.c      ****     }
2426:../uvc.c      **** 
2427:../uvc.c      ****     CyU3PBusyWait(100);
2428:../uvc.c      **** 
2429:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2430:../uvc.c      **** 
2431:../uvc.c      ****     endPointConfig.enable   = 1;
2432:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2433:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2434:../uvc.c      ****     {
2435:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2436:../uvc.c      ****     	endPointConfig.burstLen = 16;
2437:../uvc.c      ****     }
2438:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2439:../uvc.c      ****     {
2440:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2441:../uvc.c      ****     	endPointConfig.burstLen = 1;
2442:../uvc.c      ****     }
2443:../uvc.c      ****     endPointConfig.streams  = 0;
2444:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2445:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2446:../uvc.c      ****     {
2447:../uvc.c      ****         /* Error Handling */
2448:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2449:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2450:../uvc.c      ****     }
2451:../uvc.c      **** #if 0    //for still image method 3 using
2452:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2453:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2454:../uvc.c      ****     {
2455:../uvc.c      ****         /* Error Handling */
2456:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2457:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2458:../uvc.c      ****     }
2459:../uvc.c      **** #endif
2460:../uvc.c      **** 
2461:../uvc.c      **** }
2462:../uvc.c      **** 
2463:../uvc.c      **** /*
2464:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2465:../uvc.c      ****  * streaming session is started.
2466:../uvc.c      ****  */
2467:../uvc.c      **** static void
2468:../uvc.c      **** CyFxUvcAppGpifInit (
2469:../uvc.c      ****         void)
2470:../uvc.c      **** {
2471:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2472:../uvc.c      **** 
2473:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2474:../uvc.c      ****     {
2475:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2476:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2477:../uvc.c      ****     }
2478:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2479:../uvc.c      ****     {
2480:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2481:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2482:../uvc.c      ****     }
2483:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2484:../uvc.c      ****     {
2485:../uvc.c      ****         /* Error Handling */
2486:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2487:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2488:../uvc.c      ****     }
2489:../uvc.c      **** 
2490:../uvc.c      ****     /* Start the state machine from the designated start state. */
2491:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2492:../uvc.c      ****     {
2493:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2494:../uvc.c      ****     }
2495:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2496:../uvc.c      ****     {
2497:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2498:../uvc.c      ****     }
2499:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2500:../uvc.c      ****     {
2501:../uvc.c      ****         /* Error Handling */
2502:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2503:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2504:../uvc.c      ****     }
2505:../uvc.c      **** }
2506:../uvc.c      **** 
2507:../uvc.c      **** /*
2508:../uvc.c      ****  * Entry function for the UVC Application Thread
2509:../uvc.c      ****  */
2510:../uvc.c      **** 
2511:../uvc.c      **** uint32_t posTick;
2512:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2513:../uvc.c      **** 
2514:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2515:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2516:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2517:../uvc.c      **** }
2518:../uvc.c      **** 
2519:../uvc.c      **** 
2520:../uvc.c      **** void
2521:../uvc.c      **** UVCAppThread_Entry (
2522:../uvc.c      ****         uint32_t input)
2523:../uvc.c      **** {
2524:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2525:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2526:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2527:../uvc.c      ****     uint8_t i = 0;
2528:../uvc.c      ****     uint32_t flag;
2529:../uvc.c      ****     uint32_t prinflag = 0;
2530:../uvc.c      **** static uint8_t IMcount = 0;
2531:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2532:../uvc.c      ****     uint32_t frameCnt = 0;
2533:../uvc.c      **** #endif
2534:../uvc.c      ****     /* Initialize the Uart Debug Module */
2535:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2536:../uvc.c      **** 
2537:../uvc.c      ****     /* Initialize the I2C interface */
2538:../uvc.c      **** 	while (i++ < 6){
2539:../uvc.c      **** 		CyU3PThreadSleep(500);
2540:../uvc.c      **** 	}
2541:../uvc.c      **** 
2542:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2543:../uvc.c      **** 
2544:../uvc.c      ****     /* Initialize the UVC Application */
2545:../uvc.c      ****     CyFxUVCApplnInit ();
2546:../uvc.c      ****     /*
2547:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2548:../uvc.c      **** 
2549:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2550:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2551:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2552:../uvc.c      **** 
2553:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2554:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2555:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2556:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2557:../uvc.c      **** 
2558:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2559:../uvc.c      ****        of handling the abort request.
2560:../uvc.c      ****      */
2561:../uvc.c      **** 
2562:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2563:../uvc.c      ****     //CyU3PThreadSleep(1000);
2564:../uvc.c      **** 
2565:../uvc.c      ****     for (;;)
2566:../uvc.c      ****     {
2567:../uvc.c      ****         /* Waiting for the Video Stream Event */
2568:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2569:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2570:../uvc.c      ****         {
2571:../uvc.c      **** #if 0 //test for new firmware no video bring up
2572:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2573:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2574:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2575:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2576:../uvc.c      ****             {
2577:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2578:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2579:../uvc.c      ****                 {
2580:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2581:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2582:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2583:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2584:../uvc.c      **** #endif
2585:../uvc.c      **** #endif
2586:../uvc.c      ****                     }
2587:../uvc.c      ****                 else
2588:../uvc.c      ****                 {
2589:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2590:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2591:../uvc.c      **** #ifdef USB_LOWRES_IMG
2592:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2593:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2594:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2595:../uvc.c      **** #endif
2596:../uvc.c      **** #endif
2597:../uvc.c      ****                 }
2598:../uvc.c      **** 
2599:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2600:../uvc.c      ****                 prodCount++;
2601:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2602:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2603:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2604:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2605:../uvc.c      ****                 {
2606:../uvc.c      ****                     prodCount--;
2607:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2608:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2609:../uvc.c      ****                 }
2610:../uvc.c      ****             }
2611:../uvc.c      **** #endif
2612:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2613:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2614:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2615:../uvc.c      ****             {
2616:../uvc.c      ****             	if(0&&(prinflag == 0)){
2617:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2618:../uvc.c      ****             		prinflag = 1;
2619:../uvc.c      ****             	}
2620:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2621:../uvc.c      ****             	fb=0;
2622:../uvc.c      ****             	pb=0;
2623:../uvc.c      ****             	pbc=0;
2624:../uvc.c      ****                 prodCount = 0;
2625:../uvc.c      ****                 consCount = 0;
2626:../uvc.c      ****                 hitFV     = CyFalse;
2627:../uvc.c      **** 
2628:../uvc.c      **** #ifdef BACKFLOW_DETECT
2629:../uvc.c      ****                 back_flow_detected = 0;
2630:../uvc.c      **** #endif
2631:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2632:../uvc.c      ****                 frameCnt++;
2633:../uvc.c      **** #endif
2634:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2635:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2636:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2637:../uvc.c      ****                 //}
2638:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2639:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2640:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2641:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2642:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2643:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2644:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2645:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2646:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2647:../uvc.c      ****                 		stiflag = 0xFF;
2648:../uvc.c      ****                 		IMcount = 0;
2649:../uvc.c      ****                 	}
2650:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2651:../uvc.c      **** 
2652:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2653:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2654:../uvc.c      ****                 		stiflag = 0x0F;
2655:../uvc.c      ****                 		IMcount = 0;
2656:../uvc.c      ****                 		}
2657:../uvc.c      ****                  		/*if(IMcount > 0x4){
2658:../uvc.c      ****                 			stiflag = 0x0F;
2659:../uvc.c      ****                 			IMcount = 0;
2660:../uvc.c      ****                 		}*/
2661:../uvc.c      **** 
2662:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2663:../uvc.c      ****                     //CyU3PThreadSleep(400);
2664:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2665:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2666:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2667:../uvc.c      **** 
2668:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2669:../uvc.c      ****                 	{
2670:../uvc.c      ****                     switch (setRes)
2671:../uvc.c      ****                      {
2672:../uvc.c      ****                  	case 1: //1944
2673:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2674:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2675:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x64:0xE
2676:../uvc.c      ****                  		break;
2677:../uvc.c      ****                  	case 2: //1080
2678:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2679:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2680:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x54:0xD
2681:../uvc.c      ****                  		break;
2682:../uvc.c      ****                  	case 3: //720
2683:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2684:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2685:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 0x45:0
2686:../uvc.c      ****                  		break;
2687:../uvc.c      ****                  	default:
2688:../uvc.c      ****                  		break;
2689:../uvc.c      ****                      }
2690:../uvc.c      ****                     IMcount = 0;
2691:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2692:../uvc.c      ****                 	stiflag = 0x0;
2693:../uvc.c      ****                 	}
2694:../uvc.c      ****                 }
2695:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2696:../uvc.c      ****                 /* Reset the DMA channel. */
2697:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2698:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2699:../uvc.c      ****                 {
2700:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2701:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2702:../uvc.c      ****                 }
2703:../uvc.c      **** 
2704:../uvc.c      ****                 /* Start Channel Immediately */
2705:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2706:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2707:../uvc.c      ****                 {
2708:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2709:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2710:../uvc.c      ****                 }
2711:../uvc.c      **** 
2712:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2713:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2714:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2715:../uvc.c      ****                 }
2716:../uvc.c      ****         }
2717:../uvc.c      ****         else
2718:../uvc.c      ****         {
2719:../uvc.c      ****             /* If we have a stream abort request pending. */
2720:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2721:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2722:../uvc.c      ****             {
2723:../uvc.c      ****                 hitFV     = CyFalse;
2724:../uvc.c      ****                 prodCount = 0;
2725:../uvc.c      ****                 consCount = 0;
2726:../uvc.c      ****                 if(0&&(prinflag == 0)){
2727:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2728:../uvc.c      ****                 	prinflag = 1;
2729:../uvc.c      ****                 }
2730:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2731:../uvc.c      ****                 fb=0;
2732:../uvc.c      ****                 pb=0;
2733:../uvc.c      ****                 pbc=0;
2734:../uvc.c      **** 
2735:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2736:../uvc.c      ****                 {
2737:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2738:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2739:../uvc.c      ****                     {
2740:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2741:../uvc.c      ****                     }
2742:../uvc.c      **** 
2743:../uvc.c      ****                     /* Flush the Endpoint memory */
2744:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2745:../uvc.c      ****                 }
2746:../uvc.c      **** 
2747:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2748:../uvc.c      ****             }
2749:../uvc.c      ****             else
2750:../uvc.c      ****             {
2751:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2752:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2753:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2754:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2755:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2756:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2757:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2758:../uvc.c      ****                 {
2759:../uvc.c      ****                     /* Error handling */
2760:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2761:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2762:../uvc.c      ****                 }
2763:../uvc.c      **** 
2764:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2765:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2766:../uvc.c      ****                 {
2767:../uvc.c      **** #if 0
2768:../uvc.c      ****                 	//for start up of the AF Lens
2769:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2770:../uvc.c      ****                     CyU3PThreadSleep(500);
2771:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2772:../uvc.c      ****                     CyU3PThreadSleep(500);
2773:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2774:../uvc.c      ****                    	CyU3PThreadSleep(300);
2775:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2776:../uvc.c      ****                     CyU3PThreadSleep(500);
2777:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2778:../uvc.c      ****                     CyU3PThreadSleep(500);
2779:../uvc.c      **** #endif
2780:../uvc.c      **** #if 0
2781:../uvc.c      ****                     switch (setRes)
2782:../uvc.c      ****                     {
2783:../uvc.c      ****                     	case 1: //1944
2784:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2785:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2786:../uvc.c      ****                     		break;
2787:../uvc.c      ****                     	case 2: //1080
2788:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2789:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2790:../uvc.c      ****                     		break;
2791:../uvc.c      ****                     	case 3: //720
2792:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2793:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2794:../uvc.c      ****                     		break;
2795:../uvc.c      ****                     	default:
2796:../uvc.c      ****                     		break;
2797:../uvc.c      ****                     }
2798:../uvc.c      **** #endif
2799:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2800:../uvc.c      **** 
2801:../uvc.c      ****                     gpif_initialized = CyTrue;
2802:../uvc.c      ****                     CyU3PThreadSleep(200);
2803:../uvc.c      ****                     
2804:../uvc.c      ****                 }
2805:../uvc.c      ****                 else
2806:../uvc.c      ****                 {
2807:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2808:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2809:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2810:../uvc.c      ****                 }
2811:../uvc.c      ****             }
2812:../uvc.c      ****         }
2813:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2814:../uvc.c      **** 
2815:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2816:../uvc.c      ****         CyU3PThreadRelinquish ();
2817:../uvc.c      ****     }
2818:../uvc.c      **** }
2819:../uvc.c      **** 
2820:../uvc.c      **** /*
2821:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2822:../uvc.c      ****  */
2823:../uvc.c      **** 
2824:../uvc.c      **** static void
2825:../uvc.c      **** UVCHandleProcessingUnitRqts (
2826:../uvc.c      ****         void)
2827:../uvc.c      **** {
2828:../uvc.c      ****     uint8_t CtrlAdd;
2829:../uvc.c      **** #ifdef DbgInfo
2830:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2831:../uvc.c      **** #endif
2832:../uvc.c      ****     switch (wValue)
2833:../uvc.c      ****     {
2834:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2835:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2836:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2837:../uvc.c      ****     		break;
2838:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2839:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2840:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2841:../uvc.c      ****     		break;
2842:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2843:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2844:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2845:../uvc.c      **** 			break;
2846:../uvc.c      **** 
2847:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2848:../uvc.c      **** 
2849:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2850:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2851:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2852:../uvc.c      ****       		break;
2853:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2854:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2855:../uvc.c      ****      		ControlHandle(HueCtlID5);
2856:../uvc.c      ****      		break;
2857:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2858:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2859:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2860:../uvc.c      ****           		break;
2861:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2862:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2863:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2864:../uvc.c      ****           		break;
2865:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2866:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2867:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2868:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2869:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2870:../uvc.c      ****     		break;
2871:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2872:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2873:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2874:../uvc.c      ****     		break;
2875:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2876:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2877:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2878:../uvc.c      ****     		break;
2879:../uvc.c      **** 
2880:../uvc.c      ****         default:
2881:../uvc.c      ****             /*
2882:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2883:../uvc.c      ****              * other controls.
2884:../uvc.c      ****              */
2885:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2886:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2887:../uvc.c      ****             break;
2888:../uvc.c      ****     }
2889:../uvc.c      **** }
2890:../uvc.c      **** 
2891:../uvc.c      **** /*
2892:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2893:../uvc.c      ****  */
2894:../uvc.c      **** static void
2895:../uvc.c      **** UVCHandleCameraTerminalRqts (
2896:../uvc.c      ****         void)
2897:../uvc.c      **** {
2898:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2899:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2900:../uvc.c      ****     uint16_t readCount;
2901:../uvc.c      ****     uint16_t zoomVal;
2902:../uvc.c      ****     int32_t  panVal, tiltVal;
2903:../uvc.c      ****     CyBool_t sendData = CyFalse;
2904:../uvc.c      **** #endif
2905:../uvc.c      ****     uint8_t CtrlAdd;
2906:../uvc.c      **** 
2907:../uvc.c      ****     switch (wValue)
2908:../uvc.c      ****     {
2909:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2910:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2911:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2912:../uvc.c      ****     		break;
2913:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2914:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2915:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2916:../uvc.c      ****     		break;
2917:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2918:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2919:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2920:../uvc.c      **** 			break;
2921:../uvc.c      **** 
2922:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2923:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2924:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2925:../uvc.c      **** 			break;
2926:../uvc.c      **** 
2927:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2928:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2929:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2930:../uvc.c      ****       		break;
2931:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2932:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2933:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2934:../uvc.c      ****      		break;
2935:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2936:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2937:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2938:../uvc.c      ****           		break;
2939:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2940:../uvc.c      ****           		break;
2941:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2942:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2943:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2944:../uvc.c      ****      		break;
2945:../uvc.c      **** 
2946:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2947:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2948:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2949:../uvc.c      ****     		break;
2950:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2951:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2952:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2953:../uvc.c      ****     		break;
2954:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2955:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2956:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2957:../uvc.c      ****     		break;
2958:../uvc.c      **** 
2959:../uvc.c      ****         default:
2960:../uvc.c      ****             /*
2961:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2962:../uvc.c      ****              * other controls.
2963:../uvc.c      ****              */
2964:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2965:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2966:../uvc.c      ****             break;
2967:../uvc.c      ****     }
2968:../uvc.c      **** 
2969:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2970:../uvc.c      ****     switch (wValue)
2971:../uvc.c      ****     {
2972:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2973:../uvc.c      ****             switch (bRequest)
2974:../uvc.c      ****             {
2975:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2976:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2977:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2978:../uvc.c      ****                     break;
2979:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2980:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2981:../uvc.c      ****                     sendData = CyTrue;
2982:../uvc.c      ****                     break;
2983:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2984:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2985:../uvc.c      ****                     sendData = CyTrue;
2986:../uvc.c      ****                     break;
2987:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2988:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2989:../uvc.c      ****                     sendData = CyTrue;
2990:../uvc.c      ****                     break;
2991:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2992:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2993:../uvc.c      ****                     sendData = CyTrue;
2994:../uvc.c      ****                     break;
2995:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2996:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2997:../uvc.c      ****                     sendData = CyTrue;
2998:../uvc.c      ****                     break;
2999:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3000:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3001:../uvc.c      ****                             glEp0Buffer, &readCount);
3002:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3003:../uvc.c      ****                     {
3004:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3005:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3006:../uvc.c      ****                     }
3007:../uvc.c      ****                     break;
3008:../uvc.c      ****                 default:
3009:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3010:../uvc.c      ****                     break;
3011:../uvc.c      ****             }
3012:../uvc.c      **** 
3013:../uvc.c      ****             if (sendData)
3014:../uvc.c      ****             {
3015:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3016:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3017:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3018:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3019:../uvc.c      ****             }
3020:../uvc.c      ****             break;
3021:../uvc.c      **** 
3022:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3023:../uvc.c      ****             switch (bRequest)
3024:../uvc.c      ****             {
3025:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3026:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3027:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3028:../uvc.c      ****                     break;
3029:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3030:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3031:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3032:../uvc.c      ****                     sendData = CyTrue;
3033:../uvc.c      ****                     break;
3034:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3035:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3036:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3037:../uvc.c      ****                     sendData = CyTrue;
3038:../uvc.c      ****                     break;
3039:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3040:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3041:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3042:../uvc.c      ****                     sendData = CyTrue;
3043:../uvc.c      ****                     break;
3044:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3045:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3046:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3047:../uvc.c      ****                     sendData = CyTrue;
3048:../uvc.c      ****                     break;
3049:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3050:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3051:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3052:../uvc.c      ****                     sendData = CyTrue;
3053:../uvc.c      ****                     break;
3054:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3055:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3056:../uvc.c      ****                             glEp0Buffer, &readCount);
3057:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3058:../uvc.c      ****                     {
3059:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3060:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3061:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3062:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3063:../uvc.c      **** 
3064:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3065:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3066:../uvc.c      ****                     }
3067:../uvc.c      ****                     break;
3068:../uvc.c      ****                 default:
3069:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3070:../uvc.c      ****                     break;
3071:../uvc.c      ****             }
3072:../uvc.c      **** 
3073:../uvc.c      ****             if (sendData)
3074:../uvc.c      ****             {
3075:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3076:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3077:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3078:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3079:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3080:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3081:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3082:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3083:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3084:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3085:../uvc.c      ****             }
3086:../uvc.c      ****             break;
3087:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3088:../uvc.c      ****         default:
3089:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3090:../uvc.c      ****             break;
3091:../uvc.c      ****     }
3092:../uvc.c      **** #endif
3093:../uvc.c      **** }
3094:../uvc.c      **** 
3095:../uvc.c      **** /*
3096:../uvc.c      ****  * Handler for UVC Interface control requests.
3097:../uvc.c      ****  */
3098:../uvc.c      **** static void
3099:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3100:../uvc.c      ****         void)
3101:../uvc.c      **** {
3102:../uvc.c      **** 
3103:../uvc.c      ****     switch (wValue)
3104:../uvc.c      ****     {
3105:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3106:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3107:../uvc.c      ****     		break;
3108:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3109:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3110:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3111:../uvc.c      ****     		break;
3112:../uvc.c      ****     	default:
3113:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3114:../uvc.c      ****      		break;
3115:../uvc.c      ****     }
3116:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3117:../uvc.c      **** 
3118:../uvc.c      **** }
3119:../uvc.c      **** 
3120:../uvc.c      **** /*
3121:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3122:../uvc.c      ****  */
3123:../uvc.c      **** static void
3124:../uvc.c      **** UVCHandleExtensionUnitRqts (
3125:../uvc.c      ****         void)
3126:../uvc.c      **** {
3127:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3128:../uvc.c      **** 
3129:../uvc.c      **** #ifdef DbgInfo
3130:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3131:../uvc.c      **** #endif
3132:../uvc.c      ****     switch (wValue)
3133:../uvc.c      ****     {
3134:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3135:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3136:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3137:../uvc.c      ****     		break;
3138:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3139:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3140:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3141:../uvc.c      ****     		break;
3142:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3143:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3144:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3145:../uvc.c      ****      		break;
3146:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3147:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3148:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3149:../uvc.c      ****     		break;
3150:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3151:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3152:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3153:../uvc.c      ****     		break;
3154:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3155:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3156:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3157:../uvc.c      ****      		break;
3158:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3159:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3160:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3161:../uvc.c      ****     		break;
3162:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3163:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3164:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3165:../uvc.c      ****     		break;
3166:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3167:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3168:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3169:../uvc.c      ****      		break;
3170:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3171:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3172:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3173:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3174:../uvc.c      ****     		}else/* no support for 1080p camera */
3175:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3176:../uvc.c      ****     		break;
3177:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3178:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3179:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3180:../uvc.c      ****     		break;
3181:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3182:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3183:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3184:../uvc.c      ****     		break;
3185:../uvc.c      **** 
3186:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3187:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3188:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3189:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3190:../uvc.c      ****     		break;
3191:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3192:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3193:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3194:../uvc.c      ****     		//break;
3195:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3196:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3197:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3198:../uvc.c      ****     		break;
3199:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3200:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3201:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3202:../uvc.c      ****     		break;
3203:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3204:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
3205:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
3206:../uvc.c      ****     		break;
3207:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3208:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
3209:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
3210:../uvc.c      ****     		break;
3211:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3212:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
3213:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
3214:../uvc.c      ****     		break;
3215:../uvc.c      ****    	default:
3216:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3217:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3218:../uvc.c      ****     		break;
3219:../uvc.c      ****     }
3220:../uvc.c      **** 
3221:../uvc.c      **** }
3222:../uvc.c      **** 
3223:../uvc.c      **** /*
3224:../uvc.c      ****  * Handler for the video streaming control requests.
3225:../uvc.c      ****  */
3226:../uvc.c      **** static void
3227:../uvc.c      **** UVCHandleVideoStreamingRqts (
3228:../uvc.c      ****         void)
3229:../uvc.c      **** {
3230:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3231:../uvc.c      ****     uint16_t readCount;
3232:../uvc.c      **** 
3233:../uvc.c      ****     switch (wValue)
3234:../uvc.c      ****     {
3235:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3236:../uvc.c      ****             switch (bRequest)
3237:../uvc.c      ****             {
3238:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3239:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3240:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3241:../uvc.c      ****                     break;
3242:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3243:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3244:../uvc.c      ****                     glEp0Buffer[1] = 0;
3245:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3246:../uvc.c      ****                     break;
3247:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3248:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3249:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3250:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3251:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3252:../uvc.c      ****                     {
3253:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3254:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3255:../uvc.c      **** 
3256:../uvc.c      ****                     }
3257:../uvc.c      ****                     else
3258:../uvc.c      ****                     {
3259:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3260:../uvc.c      ****                     }
3261:../uvc.c      ****                     break;
3262:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3263:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3264:../uvc.c      ****                             glCommitCtrl, &readCount);
3265:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3266:../uvc.c      ****                     {
3267:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3268:../uvc.c      ****                         {
3269:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3270:../uvc.c      ****                                active data structure. */
3271:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3272:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3273:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3274:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3275:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3276:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3277:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3278:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3279:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3280:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3281:../uvc.c      **** #if 0
3282:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3283:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3284:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3285:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3286:../uvc.c      **** #endif
3287:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3288:../uvc.c      ****                        }
3289:../uvc.c      ****                     }
3290:../uvc.c      ****                     break;
3291:../uvc.c      ****                 default:
3292:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3293:../uvc.c      ****                     break;
3294:../uvc.c      ****             }
3295:../uvc.c      ****             break;
3296:../uvc.c      **** 
3297:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3298:../uvc.c      ****             switch (bRequest)
3299:../uvc.c      ****             {
3300:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3301:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3302:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3303:../uvc.c      ****                     break;
3304:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3305:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3306:../uvc.c      ****                     glEp0Buffer[1] = 0;
3307:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3308:../uvc.c      ****                     break;
3309:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3310:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3311:../uvc.c      ****                     {
3312:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3313:../uvc.c      ****                     }
3314:../uvc.c      ****                     else
3315:../uvc.c      ****                     {
3316:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3317:../uvc.c      ****                     }
3318:../uvc.c      ****                     break;
3319:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3320:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3321:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3322:../uvc.c      ****                        */
3323:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3324:../uvc.c      ****                             glCommitCtrl, &readCount);
3325:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3326:../uvc.c      ****                     {
3327:../uvc.c      ****                         switch (glCommitCtrl[3])
3328:../uvc.c      ****                          {
3329:../uvc.c      ****                          	case 1: //1944
3330:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3331:../uvc.c      ****                          		CyU3PThreadSleep(500);
3332:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3333:../uvc.c      ****                          		break;
3334:../uvc.c      ****                          	case 2: //1080
3335:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3336:../uvc.c      ****                          		CyU3PThreadSleep(500);
3337:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3338:../uvc.c      ****                          		break;
3339:../uvc.c      ****                          	case 3: //720
3340:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3341:../uvc.c      ****                          		CyU3PThreadSleep(500);
3342:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz
3343:../uvc.c      ****                          		break;
3344:../uvc.c      ****                          	default:
3345:../uvc.c      ****                          		break;
3346:../uvc.c      ****                          }
3347:../uvc.c      ****                         setRes = glCommitCtrl[3];
3348:../uvc.c      **** #if 0
3349:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3350:../uvc.c      ****                         {
3351:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3352:../uvc.c      ****                         }
3353:../uvc.c      ****                         else
3354:../uvc.c      ****                         {
3355:../uvc.c      ****                             SensorScaling_VGA ();
3356:../uvc.c      ****                         }
3357:../uvc.c      **** #endif
3358:../uvc.c      ****                         /* We can start streaming video now. */
3359:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3360:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3361:../uvc.c      ****                         {
3362:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3363:../uvc.c      ****                         }
3364:../uvc.c      ****                     }
3365:../uvc.c      ****                     break;
3366:../uvc.c      **** 
3367:../uvc.c      ****                 default:
3368:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3369:../uvc.c      ****                     break;
3370:../uvc.c      ****             }
3371:../uvc.c      ****             break;
3372:../uvc.c      **** 
3373:../uvc.c      **** /* still image streaming handler */
3374:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3375:../uvc.c      ****                 switch (bRequest)
3376:../uvc.c      ****                 {
3377:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3378:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3379:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3380:../uvc.c      ****                         break;
3381:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3382:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3383:../uvc.c      ****                         glEp0Buffer[1] = 0;
3384:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3385:../uvc.c      ****                         break;
3386:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3387:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3388:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3389:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3390:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3391:../uvc.c      ****                         {
3392:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3393:../uvc.c      ****                         }
3394:../uvc.c      ****                         else
3395:../uvc.c      ****                         {
3396:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3397:../uvc.c      ****                         }
3398:../uvc.c      ****                         break;
3399:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3400:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3401:../uvc.c      ****                                 glCommitCtrl, &readCount);
3402:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3403:../uvc.c      ****                         {
3404:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3405:../uvc.c      ****                             {
3406:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3407:../uvc.c      ****                                    active data structure. */
3408:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3409:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3410:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3411:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3412:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3413:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3414:../uvc.c      ****                             }
3415:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3416:../uvc.c      ****                         }
3417:../uvc.c      ****                         break;
3418:../uvc.c      ****                     default:
3419:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3420:../uvc.c      ****                         break;
3421:../uvc.c      ****                 }
3422:../uvc.c      ****                 break;
3423:../uvc.c      **** 
3424:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3425:../uvc.c      ****                 switch (bRequest)
3426:../uvc.c      ****                 {
3427:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3428:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3429:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3430:../uvc.c      ****                         break;
3431:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3432:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3433:../uvc.c      ****                         glEp0Buffer[1] = 0;
3434:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3435:../uvc.c      ****                         break;
3436:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3437:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3438:../uvc.c      ****                         {
3439:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3440:../uvc.c      ****                         }
3441:../uvc.c      ****                         else
3442:../uvc.c      ****                         {
3443:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3444:../uvc.c      ****                         }
3445:../uvc.c      ****                         break;
3446:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3447:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3448:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3449:../uvc.c      ****                            */
3450:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3451:../uvc.c      ****                                 glCommitCtrl, &readCount);
3452:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3453:../uvc.c      ****                         {
3454:../uvc.c      ****     #if 0
3455:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3456:../uvc.c      ****                             {
3457:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3458:../uvc.c      ****                             }
3459:../uvc.c      ****                             else
3460:../uvc.c      ****                             {
3461:../uvc.c      ****                                 SensorScaling_VGA ();
3462:../uvc.c      ****                             }
3463:../uvc.c      ****                             /* We can start streaming video now. */
3464:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3465:../uvc.c      **** 
3466:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3467:../uvc.c      ****                             {
3468:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3469:../uvc.c      ****                             }
3470:../uvc.c      **** 	#endif
3471:../uvc.c      ****                            switch (glCommitCtrl[1])
3472:../uvc.c      ****                              {
3473:../uvc.c      ****                              	case 3: //1944
3474:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3475:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3476:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3477:../uvc.c      ****                              		break;
3478:../uvc.c      ****                              	case 2: //1080
3479:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3480:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3481:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3482:../uvc.c      ****                              		break;
3483:../uvc.c      ****                              	case 1: //720
3484:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3485:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3486:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is
3487:../uvc.c      ****                              		break;
3488:../uvc.c      ****                              	default:
3489:../uvc.c      ****                              		break;
3490:../uvc.c      ****                              }
3491:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3492:../uvc.c      **** 
3493:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3494:../uvc.c      **** 
3495:../uvc.c      ****                         }
3496:../uvc.c      ****                         break;
3497:../uvc.c      **** 
3498:../uvc.c      ****                     default:
3499:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3500:../uvc.c      ****                         break;
3501:../uvc.c      ****                 }
3502:../uvc.c      ****                 break;
3503:../uvc.c      **** 
3504:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3505:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3506:../uvc.c      ****             	switch (bRequest)
3507:../uvc.c      ****                 {
3508:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3509:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3510:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3511:../uvc.c      ****                         break;
3512:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3513:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3514:../uvc.c      ****                         glEp0Buffer[1] = 0;
3515:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3516:../uvc.c      ****                         break;
3517:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3518:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3519:../uvc.c      ****                         {
3520:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3521:../uvc.c      ****                         }
3522:../uvc.c      ****                         else
3523:../uvc.c      ****                         {
3524:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3525:../uvc.c      ****                         }
3526:../uvc.c      ****                         break;
3527:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3528:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3529:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3530:../uvc.c      ****                            */
3531:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3532:../uvc.c      ****                                 glCommitCtrl, &readCount);
3533:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3534:../uvc.c      ****                         {
3535:../uvc.c      ****     #if 1
3536:../uvc.c      ****                             /* We can start still streaming video now. */
3537:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3538:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3539:../uvc.c      ****                             {
3540:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3541:../uvc.c      ****                             }
3542:../uvc.c      ****     #endif
3543:../uvc.c      ****                             else{
3544:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3545:../uvc.c      ****                             //stillcont = 0;
3546:../uvc.c      ****                             }
3547:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3548:../uvc.c      ****                         }else{
3549:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3550:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3551:../uvc.c      ****                         }
3552:../uvc.c      ****                         break;
3553:../uvc.c      **** 
3554:../uvc.c      ****                     default:
3555:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3556:../uvc.c      ****                         break;
3557:../uvc.c      ****                 }
3558:../uvc.c      ****                 break;
3559:../uvc.c      **** 
3560:../uvc.c      ****         default:
3561:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3562:../uvc.c      ****             break;
3563:../uvc.c      ****     }
3564:../uvc.c      **** }
3565:../uvc.c      **** 
3566:../uvc.c      **** /*
3567:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3568:../uvc.c      ****  */
3569:../uvc.c      **** void
3570:../uvc.c      **** UVCAppEP0Thread_Entry (
3571:../uvc.c      ****         uint32_t input)
3572:../uvc.c      **** {
3573:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3574:../uvc.c      ****     uint32_t eventFlag;
3575:../uvc.c      **** 	CyBool_t value;
3576:../uvc.c      **** 	CyBool_t *valueptr = &value;
3577:../uvc.c      **** 
3578:../uvc.c      **** 
3579:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3580:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3581:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3582:../uvc.c      **** 
3583:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3584:../uvc.c      **** #endif
3585:../uvc.c      **** 
3586:../uvc.c      ****     /* for interrupt status test */
3587:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3588:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3589:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3590:../uvc.c      **** 
3591:../uvc.c      ****     for (;;)
3592:../uvc.c      ****     {
3593:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3594:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3595:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3596:../uvc.c      ****         {
3597:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3598:../uvc.c      ****             if (!isUsbConnected)
3599:../uvc.c      ****             {
3600:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3601:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3602:../uvc.c      ****                 {
3603:../uvc.c      ****                     isUsbConnected = CyTrue;
3604:../uvc.c      ****                 }
3605:../uvc.c      ****             }
3606:../uvc.c      **** //#ifdef DbgInfo
3607:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3608:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3609:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3610:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3611:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3612:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3613:../uvc.c      **** //#endif
3614:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3615:../uvc.c      ****             {
3616:../uvc.c      ****             	switch ((wIndex >> 8))
3617:../uvc.c      ****                 {
3618:../uvc.c      **** 
3619:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3620:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3621:../uvc.c      ****                         break;
3622:../uvc.c      **** 
3623:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3624:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3625:../uvc.c      ****                         break;
3626:../uvc.c      **** 
3627:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3628:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3629:../uvc.c      ****                         break;
3630:../uvc.c      **** 
3631:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3632:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3633:../uvc.c      ****                         break;
3634:../uvc.c      **** 
3635:../uvc.c      ****                     default:
3636:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3637:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3638:../uvc.c      ****                         break;
3639:../uvc.c      ****                 }
3640:../uvc.c      ****             }
3641:../uvc.c      **** 
3642:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3643:../uvc.c      ****             {
3644:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3645:../uvc.c      **** 
3646:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3647:../uvc.c      ****                 {
3648:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3649:../uvc.c      ****                 }
3650:../uvc.c      ****                 else
3651:../uvc.c      ****                 {
3652:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3653:../uvc.c      ****                 }
3654:../uvc.c      ****             }
3655:../uvc.c      **** 
3656:../uvc.c      ****             /* handle interrupt status event */
3657:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3658:../uvc.c      ****             {
3659:../uvc.c      **** 
3660:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3661:../uvc.c      ****             	/** preparing interrupt status data **/
3662:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3663:../uvc.c      **** 
3664:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3665:../uvc.c      **** 
3666:../uvc.c      **** #if 0 //for real button
3667:../uvc.c      **** 				if(value&&(!snapButFlag)){
3668:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3669:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3670:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3671:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3672:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3673:../uvc.c      **** 
3674:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3675:../uvc.c      **** 					interStabuf.size   = 1024;
3676:../uvc.c      **** 					interStabuf.status = 0;
3677:../uvc.c      **** 
3678:../uvc.c      **** 					interStabuf.count = 4;
3679:../uvc.c      **** 
3680:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3681:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3682:../uvc.c      **** 
3683:../uvc.c      **** 					/** send a interrupt status data **/
3684:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3685:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3686:../uvc.c      **** 					{
3687:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3688:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3689:../uvc.c      **** 					}
3690:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3691:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3692:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3693:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3694:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3695:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3696:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3697:../uvc.c      **** 
3698:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3699:../uvc.c      **** 					interStabuf.size   = 1024;
3700:../uvc.c      **** 					interStabuf.status = 0;
3701:../uvc.c      **** 
3702:../uvc.c      **** 					interStabuf.count = 4;
3703:../uvc.c      **** 
3704:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3705:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3706:../uvc.c      **** 
3707:../uvc.c      **** 					/** send a interrupt status data **/
3708:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3709:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3710:../uvc.c      **** 					{
3711:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3712:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3713:../uvc.c      **** 					}
3714:../uvc.c      **** 
3715:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3716:../uvc.c      **** 					stiflag = 0xFF;
3717:../uvc.c      **** 				}
3718:../uvc.c      **** #else			//for botton simulation
3719:../uvc.c      **** 				if(snapButFlag == 0x0f){
3720:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3721:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3722:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3723:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3724:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3725:../uvc.c      **** 
3726:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3727:../uvc.c      **** 					interStabuf.size   = 1024;
3728:../uvc.c      **** 					interStabuf.status = 0;
3729:../uvc.c      **** 
3730:../uvc.c      **** 					interStabuf.count = 4;
3731:../uvc.c      **** 
3732:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3733:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3734:../uvc.c      **** 
3735:../uvc.c      **** 					/** send a interrupt status data **/
3736:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3737:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3738:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3739:../uvc.c      **** 					{
3740:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3741:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3742:../uvc.c      **** 					}
3743:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3744:../uvc.c      **** 
3745:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3746:../uvc.c      **** 				}else if(!snapButFlag){
3747:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3748:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3749:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3750:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3751:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3752:../uvc.c      **** 
3753:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3754:../uvc.c      **** 					interStabuf.size   = 1024;
3755:../uvc.c      **** 					interStabuf.status = 0;
3756:../uvc.c      **** 
3757:../uvc.c      **** 					interStabuf.count = 4;
3758:../uvc.c      **** 
3759:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3760:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3761:../uvc.c      **** 
3762:../uvc.c      **** 					/** send a interrupt status data **/
3763:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3764:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3765:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3766:../uvc.c      **** 					{
3767:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3768:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3769:../uvc.c      **** 					}
3770:../uvc.c      **** 
3771:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3772:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3773:../uvc.c      **** 				}
3774:../uvc.c      **** #endif
3775:../uvc.c      **** 
3776:../uvc.c      ****             }
3777:../uvc.c      **** 
3778:../uvc.c      **** 
3779:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3780:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3781:../uvc.c      ****             {
3782:../uvc.c      ****                 /* Get the command buffer */
3783:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3784:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3785:../uvc.c      ****                 {
3786:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3787:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3788:../uvc.c      ****                 }
3789:../uvc.c      **** 
3790:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3791:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3792:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3793:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3794:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3795:../uvc.c      ****                  * register value high byte and register value low byte.
3796:../uvc.c      ****                  */
3797:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3798:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3799:../uvc.c      ****                 {
3800:../uvc.c      ****                     if (dmaInfo.count == 3)
3801:../uvc.c      ****                     {
3802:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3803:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3804:../uvc.c      ****                         dmaInfo.count = 3;
3805:../uvc.c      ****                     }
3806:../uvc.c      ****                     else if (dmaInfo.count == 4)
3807:../uvc.c      ****                     {
3808:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3809:../uvc.c      ****                         {
3810:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3811:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3812:../uvc.c      ****                         }
3813:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3814:../uvc.c      ****                     }
3815:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3816:../uvc.c      ****                 }
3817:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3818:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3819:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3820:../uvc.c      ****                  */
3821:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3822:../uvc.c      ****                 {
3823:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3824:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3825:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3826:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3827:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3828:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3829:../uvc.c      ****                         	break;
3830:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3831:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3832:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3833:../uvc.c      ****                         	break;*/
3834:../uvc.c      ****                     dmaInfo.count -= 2;
3835:../uvc.c      ****                 }
3836:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3837:../uvc.c      ****                 else
3838:../uvc.c      ****                 {
3839:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3840:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3841:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3842:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3843:../uvc.c      ****                 }
3844:../uvc.c      **** 
3845:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3846:../uvc.c      ****                 dmaInfo.size   = 1024;
3847:../uvc.c      ****                 dmaInfo.status = 0;
3848:../uvc.c      **** 
3849:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3850:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3851:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3852:../uvc.c      ****                 {
3853:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3854:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3855:../uvc.c      ****                 }
3856:../uvc.c      **** 
3857:../uvc.c      ****                 /* Wait until the response has gone out. */
3858:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3859:../uvc.c      **** 
3860:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3861:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3862:../uvc.c      ****                 {
3863:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3864:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3865:../uvc.c      ****                 }
3866:../uvc.c      ****             }
3867:../uvc.c      **** #endif
3868:../uvc.c      ****         }
3869:../uvc.c      ****         /* Allow other ready threads to run. */
3870:../uvc.c      ****         CyU3PThreadRelinquish ();
3871:../uvc.c      ****     }
3872:../uvc.c      **** }
3873:../uvc.c      **** 
3874:../uvc.c      **** /*
3875:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3876:../uvc.c      ****  * added 10/2013
3877:../uvc.c      ****  */
3878:../uvc.c      **** /*
3879:../uvc.c      **** static uint8_t timeDelay[64] = {
3880:../uvc.c      **** 
3881:../uvc.c      **** };
3882:../uvc.c      **** */
3883:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3883 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3884:../uvc.c      **** 
3885:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3886:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3887:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3888:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3889:../uvc.c      **** 	VdstateDes *lcStaDes;
3890:../uvc.c      **** 	uint32_t flag = 0;
3891:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3892:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3893:../uvc.c      **** 	uint8_t i;
3894:../uvc.c      **** 	uint16_t delaytime;
3895:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3896:../uvc.c      **** 
3897:../uvc.c      **** #if 0 //for test the command queue
3898:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3899:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3900:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3901:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3902:../uvc.c      **** 		lcCmdDes += 1;
3903:../uvc.c      **** 	}
3904:../uvc.c      **** #endif
3905:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3906:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3906 0
  36 0004 10229FE5 		ldr	r2, .L22
3890:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3890 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3883:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3883 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3906 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3890:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3890 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3906 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3907:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3907 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3908:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3908 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3909:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3909 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3910:../uvc.c      **** 
3911:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3911 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3912:../uvc.c      ****         /* Allow other ready threads to run. */
3913:../uvc.c      **** 
3914:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3914 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3911:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3911 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3915:../uvc.c      **** 	}
3916:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3916 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3917:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3918:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3919:../uvc.c      **** 	//CyU3PThreadSleep(100);
3920:../uvc.c      **** 	//SetCurCmd();
3921:../uvc.c      **** 	/*********** the loop of the thread ***********/
3922:../uvc.c      **** 	for(;;){
3923:../uvc.c      **** 
3924:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3924 0
 101 0098 0060E0E3 		mvn	r6, #0
3925:../uvc.c      **** /*  // for test GPIO output
3926:../uvc.c      **** 		if(trigger)
3927:../uvc.c      **** 		{
3928:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3929:../uvc.c      **** 			{
3930:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3931:../uvc.c      **** 			}
3932:../uvc.c      **** 
3933:../uvc.c      **** 		}else{
3934:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3935:../uvc.c      **** 			{
3936:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3937:../uvc.c      **** 			}
3938:../uvc.c      **** 
3939:../uvc.c      **** 		}
3940:../uvc.c      **** */
3941:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3942:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3943:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3944:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3945:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3946:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3947:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3948:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3950:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3951:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3952:../uvc.c      **** #endif
3953:../uvc.c      **** 				}
3954:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3955:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3956:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3957:../uvc.c      **** 			}
3958:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3959:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3960:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3961:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3962:../uvc.c      **** 
3963:../uvc.c      **** 				/*
3964:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3965:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3966:../uvc.c      **** 				*/
3967:../uvc.c      **** 
3968:../uvc.c      **** 				/* find a available command */
3969:../uvc.c      **** 				i = 0;
3970:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3970 0
 103 009c 0090A0E3 		mov	r9, #0
3971:../uvc.c      **** 					i++;
3972:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3973:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3974:../uvc.c      **** 				}
3975:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3976:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3977:../uvc.c      **** 					i = lcCmdDes->curNum;
3978:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3979:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3980:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3981:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3982:../uvc.c      **** #if 1
3983:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3984:../uvc.c      **** 						case 20:
3985:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3986:../uvc.c      **** 							delaytime = 500;
3987:../uvc.c      **** 							break;
3988:../uvc.c      **** 						case 21:
3989:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3990:../uvc.c      **** 							delaytime = 500;
3991:../uvc.c      **** 							break;
3992:../uvc.c      **** 						case 22:
3993:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3994:../uvc.c      **** 							delaytime = 300;
3995:../uvc.c      **** 							break;
3996:../uvc.c      **** 						case 23:
3997:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3998:../uvc.c      **** 							delaytime = 300;
3999:../uvc.c      **** 							break;
4000:../uvc.c      **** 						default:
4001:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4002:../uvc.c      **** 							break;
4003:../uvc.c      **** 					}
4004:../uvc.c      **** #endif
4005:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4006:../uvc.c      **** 					/** timer's ticket modify **/
4007:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4008:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4009:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4010:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4011:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4012:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4013:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4014:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4015:../uvc.c      **** #endif
4016:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4017:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4018:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4019:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4020:../uvc.c      **** 						}else{
4021:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4022:../uvc.c      **** 						}
4023:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4024:../uvc.c      **** 					}else{
4025:../uvc.c      **** 						lcCmdDes->curNum ++;
4026:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4026 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3924:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3924 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3941:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3941 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3958:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3958 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3960:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3960 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3961:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3961 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3970:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3970 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3972:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3972 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3971:../uvc.c      **** 					i++;
 140              		.loc 1 3971 0
 141 00f4 011083E2 		add	r1, r3, #1
3970:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3970 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3971:../uvc.c      **** 					i++;
 144              		.loc 1 3971 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3970:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3970 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3976:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3976 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3978:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3978 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3983:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3983 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3978:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3978 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3983:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3983 0
 166 0128 14C042E2 		sub	ip, r2, #20
3978:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3978 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3979:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3979 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3980:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3980 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3981:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3981 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3983:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3983 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3997:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3997 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3999:../uvc.c      **** 							break;
 193              		.loc 1 3999 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
4008:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 4008 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
4009:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 4009 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
4016:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 4016 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
4025:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 4025 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 4026 0
 213 018c 3C808415 		strne	r8, [r4, #60]
4016:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 4016 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
4027:../uvc.c      **** 					}
4028:../uvc.c      **** 				}else{
4029:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4030:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4031:../uvc.c      **** 				}
4032:../uvc.c      **** 			}
4033:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 4033 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
4034:../uvc.c      **** /*
4035:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4036:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4037:../uvc.c      **** */
4038:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4039:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4040:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4041:../uvc.c      **** #endif
4042:../uvc.c      **** 
4043:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4044:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4045:../uvc.c      **** #if 0
4046:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4047:../uvc.c      **** 
4048:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4049:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4050:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4051:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4052:../uvc.c      **** 			    i = 0;
4053:../uvc.c      **** 				 switch(cmdCopyIdx)
4054:../uvc.c      **** 				 {
4055:../uvc.c      **** 					 case BrgtCtlID1:
4056:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4057:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4058:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4059:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4060:../uvc.c      **** 							 i++;
4061:../uvc.c      **** 						 }
4062:../uvc.c      **** 						 else{
4063:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4064:../uvc.c      **** 						 }
4065:../uvc.c      **** 
4066:../uvc.c      **** 						 CyU3PBusyWait(500);
4067:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4068:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4069:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4070:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4071:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4072:../uvc.c      **** 						 }
4073:../uvc.c      **** 						 else{
4074:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4075:../uvc.c      **** 						 }
4076:../uvc.c      **** 						 break;
4077:../uvc.c      **** 					 case HueCtlID5:
4078:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4079:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4080:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4081:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4082:../uvc.c      **** 						 }
4083:../uvc.c      **** 						 else{
4084:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4085:../uvc.c      **** 						 }
4086:../uvc.c      **** 						 break;
4087:../uvc.c      **** 					 case SaturCtlID6:
4088:../uvc.c      **** 					 case WBTLevCtlID10:
4089:../uvc.c      **** 					 default:
4090:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4092:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4094:../uvc.c      **** 						 }
4095:../uvc.c      **** 						 else{
4096:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4097:../uvc.c      **** 						 }
4098:../uvc.c      **** 						 break;
4099:../uvc.c      **** 				 }
4100:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4101:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4102:../uvc.c      **** 			}
4103:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4104:../uvc.c      **** #endif
4105:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4106:../uvc.c      **** 		/* Allow other ready threads to run. */
4107:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4108:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 4108 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
4109:../uvc.c      **** 		}
 224              		.loc 1 4109 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3989:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3989 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3991:../uvc.c      **** 							break;
 232              		.loc 1 3991 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
4001:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 4001 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
4002:../uvc.c      **** 							break;
 241              		.loc 1 4002 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3985:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3985 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3987:../uvc.c      **** 							break;
 249              		.loc 1 3987 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
4029:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 4029 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
4030:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 4030 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
4018:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 4018 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4017:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 4017 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
4018:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 4018 0
 269 01f0 1F005CE3 		cmp	ip, #31
4019:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 4019 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
4021:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 4021 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
4019:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 4019 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
4021:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 4021 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
4019:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 4019 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
4021:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 4021 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
4023:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 4023 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2514:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2514 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2516:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2516 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2517:../uvc.c      **** }
 318              		.loc 1 2517 0
2516:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2516 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB8:
1575:../uvc.c      **** {
 332              		.loc 1 1575 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1576:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1576 0
 338 0250 020050E3 		cmp	r0, #2
1575:../uvc.c      **** {
 339              		.loc 1 1575 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1575:../uvc.c      **** {
 347              		.loc 1 1575 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1576:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1576 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1612:../uvc.c      **** }
 361              		.loc 1 1612 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1597:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1597 0
 367 0280 28519FE5 		ldr	r5, .L34
1595:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1595 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1596:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1596 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1597:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1597 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1559 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1597:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1597 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1598:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1598 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1599:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1599 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1559 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1562 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1565:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1565 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1581:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1581 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1579:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1579 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1580:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1580 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1581:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1581 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1559 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1581:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1581 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1582:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1582 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1559 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1562 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1559 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1589:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1589 0
 462 0344 64509FE5 		ldr	r5, .L34
1587:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1587 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1588:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1588 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1589:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1589 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1559 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1589:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1589 0
 485 0374 286085E5 		str	r6, [r5, #40]
1590:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1590 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1559 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1562 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1565:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1565 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE8:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB10:
1772:../uvc.c      **** {
 523              		.loc 1 1772 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
1779:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 1779 0
 529 03c0 080051E3 		cmp	r1, #8
1772:../uvc.c      **** {
 530              		.loc 1 1772 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
1779:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 1779 0
 544 03d0 0B00000A 		beq	.L42
1831:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 1831 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
1833:../uvc.c      ****         consCount++;
 548              		.loc 1 1833 0
 549 03dc 7C319FE5 		ldr	r3, .L45
1834:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 1834 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
1833:../uvc.c      ****         consCount++;
 553              		.loc 1 1833 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
1834:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 1834 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
1833:../uvc.c      ****         consCount++;
 558              		.loc 1 1833 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
1836:../uvc.c      **** }
 565              		.loc 1 1836 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
1781:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 1781 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
1801:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 1801 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1520:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1520 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1519 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
1801:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 1801 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1519 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1520:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1520 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1521:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1521 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1526:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1526 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
1802:../uvc.c      ****                 pb++;
 607              		.loc 1 1802 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1526:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1526 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
1802:../uvc.c      ****                 pb++;
 617              		.loc 1 1802 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
1808:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 1808 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
1803:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 1803 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
1802:../uvc.c      ****                 pb++;
 623              		.loc 1 1802 0
 624 0460 013080E2 		add	r3, r0, #1
1808:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 1808 0
 626 0464 0F0052E3 		cmp	r2, #15
1802:../uvc.c      ****                 pb++;
 627              		.loc 1 1802 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1803:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 1803 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1808:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 1808 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
1815:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 1815 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
1819:../uvc.c      ****             prodCount++;
 639              		.loc 1 1819 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
1820:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 1820 0
 642 0480 0C1081E2 		add	r1, r1, #12
1819:../uvc.c      ****             prodCount++;
 643              		.loc 1 1819 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
1820:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 1820 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
1819:../uvc.c      ****             prodCount++;
 652              		.loc 1 1819 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
1820:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 1820 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
1819:../uvc.c      ****             prodCount++;
 657              		.loc 1 1819 0
 658 04a8 B0109FE5 		ldr	r1, .L45
1823:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 1823 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
1825:../uvc.c      ****                 prodCount--;
 662              		.loc 1 1825 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
1826:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 1826 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
1825:../uvc.c      ****                 prodCount--;
 667              		.loc 1 1825 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
1826:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 1826 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
1795:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 1795 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1519 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
1796:../uvc.c      ****                 fb++;
 693              		.loc 1 1796 0
 694 04f4 64409FE5 		ldr	r4, .L45
1795:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 1795 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1519 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1520:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1520 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1521:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1521 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
1796:../uvc.c      ****                 fb++;
 714              		.loc 1 1796 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
1809:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 1809 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
1810:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 1810 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1811:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 1811 0
 729 0540 24009FE5 		ldr	r0, .L45+12
1810:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 1810 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
1811:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 1811 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
1812:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 1812 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE10:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB9:
1620:../uvc.c      **** {
 757              		.loc 1 1620 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1625:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1625 0
 763 057c C0329FE5 		ldr	r3, .L72
1620:../uvc.c      **** {
 764              		.loc 1 1620 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1626:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1626 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1625:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1625 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1626:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1626 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1627:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1627 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1625:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1625 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1627:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1627 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1628:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1628 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1629:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1629 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1628:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1628 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1626:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1626 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1628:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1628 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1629:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1629 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1632:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1632 0
 801 05b4 020054E3 		cmp	r4, #2
1620:../uvc.c      **** {
 802              		.loc 1 1620 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1626:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1626 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1627:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1627 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1628:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1628 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1629:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1629 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1632:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1632 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1621:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1621 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1759:../uvc.c      **** }
 826              		.loc 1 1759 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1632:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1632 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1672:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1672 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1676:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1676 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1676:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1676 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1681:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1681 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1679:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1679 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1680:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1680 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1684:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1684 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1681:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1681 0
 856 0630 287084E5 		str	r7, [r4, #40]
1682:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1682 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1684:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1684 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1685:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1685 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1688:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1688 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1689:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1689 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1690:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1690 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1691:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1691 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1694:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1694 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1697:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1697 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1699:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1699 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1559 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1562 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1565:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1565 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1695:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1695 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1637:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1637 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1642:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1642 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1644:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1644 0
 926 06e0 002050E2 		subs	r2, r0, #0
1641:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1641 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1644:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1644 0
 931 06e8 BEFFFF0A 		beq	.L48
1646:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1646 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1647:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1647 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1641:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1641 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1707:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1707 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1709:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1709 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1715:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1715 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1747:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1747 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1746:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1746 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1637:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1637 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1655:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1655 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1657:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1657 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1695:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1695 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1660:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1660 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1661:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1661 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1654:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1654 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1717:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1717 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1721:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1721 0
 1011 0794 0080A0E3 		mov	r8, #0
1720:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1720 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1725:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1725 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1721:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1721 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1722:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1722 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1725:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1725 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1726:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1726 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1729:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1729 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1730:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1730 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1731:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1731 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1732:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1732 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1735:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1735 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1739:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1739 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1741:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1741 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1559 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1737:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1737 0
 1061 0814 0600A011 		movne	r0, r6
1559:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1559 0
 1063 0818 72FFFF1A 		bne	.L48
1562:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1562 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1565:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1565 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1737:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1737 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE9:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB12:
1958:../uvc.c      **** {
 1101              		.loc 1 1958 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
1959:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 1959 0
 1107 0870 010050E3 		cmp	r0, #1
1958:../uvc.c      **** {
 1108              		.loc 1 1958 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
1958:../uvc.c      **** {
 1112              		.loc 1 1958 0
 1113 0878 0120A0E1 		mov	r2, r1
1959:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 1959 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
1856:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 1856 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
1882:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 1882 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
1884:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1884 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
1867:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 1867 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
1941:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 1941 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
1942:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 1942 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
1944:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 1944 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1546 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1547 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
1911:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 1911 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
1858:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 1858 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
1930:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 1930 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
1965:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 1965 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
1968:../uvc.c      **** }
 1214              		.loc 1 1968 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
1965:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 1965 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE12:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 492:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 492 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 495:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 495 0
 1243 0970 40429FE5 		ldr	r4, .L106
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 492:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 492 0
 1254 0974 3CD04DE2 		sub	sp, sp, #60
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 96
 500:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 500 0
 1258 0978 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 495:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 495 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 496:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 496 0
 1263 0980 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 497:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1265              		.loc 1 497 0
 1266 0984 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1267              	.LVL99:
 500:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1268              		.loc 1 500 0
 1269 0988 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1270 098c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1271 0990 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1272 0994 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1273 0998 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1274 099c 14208DE5 		str	r2, [sp, #20]
 1275 09a0 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1276 09a4 0730A0E1 		mov	r3, r7
 1277 09a8 1C108DE5 		str	r1, [sp, #28]
 1278 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1279 09b0 0400A0E3 		mov	r0, #4
 1280 09b4 00129FE5 		ldr	r1, .L106+4
 1281 09b8 0520A0E1 		mov	r2, r5
 1282 09bc 00E08DE5 		str	lr, [sp, #0]
 1283 09c0 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1284 09c4 0C908DE5 		str	r9, [sp, #12]
 1285 09c8 10B08DE5 		str	fp, [sp, #16]
 1286 09cc 18608DE5 		str	r6, [sp, #24]
 1287 09d0 20C08DE5 		str	ip, [sp, #32]
 1288 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 503:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1289              		.loc 1 503 0
 1290 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1291 09dc 520053E3 		cmp	r3, #82
 1292 09e0 2C00000A 		beq	.L102
 1293              	.L92:
 513:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1294              		.loc 1 513 0
 1295 09e4 000055E3 		cmp	r5, #0
 1296 09e8 1600000A 		beq	.L103
 538:../uvc.c      **** 	}else if(CmdType == 1){
 1297              		.loc 1 538 0
 1298 09ec 010055E3 		cmp	r5, #1
 1299 09f0 0100000A 		beq	.L104
 1300              	.LVL100:
 1301              	.L91:
 557:../uvc.c      **** }
 1302              		.loc 1 557 0
 1303 09f4 3CD08DE2 		add	sp, sp, #60
 1304 09f8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1305              	.LVL101:
 1306              	.L104:
 540:../uvc.c      **** 			if(CmdRegLen == 2){
 1307              		.loc 1 540 0
 1308 09fc 020057E3 		cmp	r7, #2
 1309 0a00 3700000A 		beq	.L105
 545:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1310              		.loc 1 545 0
 1311 0a04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1312 0a08 A8319FE5 		ldr	r3, .L106
 1313 0a0c FE1001E2 		and	r1, r1, #254
 1314 0a10 820051E3 		cmp	r1, #130
 548:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1315              		.loc 1 548 0
 1316 0a14 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1317              	.LVL102:
 545:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1318              		.loc 1 545 0
 1319 0a18 0200001A 		bne	.L101
 545:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1320              		.loc 1 545 0 is_stmt 0 discriminator 1
 1321 0a1c 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1322 0a20 300055E3 		cmp	r5, #48
 1323 0a24 4F00000A 		beq	.L99
 1324              	.L101:
 548:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1325              		.loc 1 548 0 is_stmt 1
 1326 0a28 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1327              	.L100:
 550:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1328              		.loc 1 550 0
 1329 0a2c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1330 0a30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1331 0a34 FE0002E2 		and	r0, r2, #254
 1332 0a38 0520A0E1 		mov	r2, r5
 1333 0a3c 00E08DE5 		str	lr, [sp, #0]
 1334 0a40 FEFFFFEB 		bl	SensorWrite2B
 1335 0a44 EAFFFFEA 		b	.L91
 1336              	.LVL103:
 1337              	.L103:
 529:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1338              		.loc 1 529 0
 1339 0a48 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1340 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 515:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1341              		.loc 1 515 0
 1342 0a50 0FE0A0E3 		mov	lr, #15
 529:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1343              		.loc 1 529 0
 1344 0a54 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1345 0a58 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 515:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1346              		.loc 1 515 0
 1347 0a5c 57E0C4E5 		strb	lr, [r4, #87]
 529:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1348              		.loc 1 529 0
 1349 0a60 34C08DE2 		add	ip, sp, #52
 1350 0a64 010080E3 		orr	r0, r0, #1
 1351 0a68 011081E3 		orr	r1, r1, #1
 1352 0a6c 00C08DE5 		str	ip, [sp, #0]
 1353 0a70 FEFFFFEB 		bl	SensorRead2B
 530:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1354              		.loc 1 530 0
 1355 0a74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 531:../uvc.c      **** 				if(CmdDataLen == 2){
 1356              		.loc 1 531 0
 1357 0a78 020056E3 		cmp	r6, #2
 530:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1358              		.loc 1 530 0
 1359 0a7c 5530C4E5 		strb	r3, [r4, #85]
 532:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1360              		.loc 1 532 0
 1361 0a80 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1362 0a84 2C319F05 		ldreq	r3, .L106
 534:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1363              		.loc 1 534 0
 1364 0a88 0020E0E3 		mvn	r2, #0
 1365 0a8c 5720C4E5 		strb	r2, [r4, #87]
 532:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1366              		.loc 1 532 0
 1367 0a90 5600C305 		streqb	r0, [r3, #86]
 1368 0a94 D6FFFFEA 		b	.L91
 1369              	.L102:
 503:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1370              		.loc 1 503 0 discriminator 1
 1371 0a98 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1372 0a9c 300050E3 		cmp	r0, #48
 1373 0aa0 CFFFFF1A 		bne	.L92
 1374 0aa4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1375 0aa8 010053E3 		cmp	r3, #1
 1376 0aac CCFFFF1A 		bne	.L92
 505:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1377              		.loc 1 505 0
 1378 0ab0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1379 0ab4 04C19FE5 		ldr	ip, .L106+8
 1380 0ab8 031002E2 		and	r1, r2, #3
 1381 0abc 8C14CCE5 		strb	r1, [ip, #1164]
 506:../uvc.c      **** 		if(is60Hz==CyFalse)
 1382              		.loc 1 506 0
 1383 0ac0 58E094E5 		ldr	lr, [r4, #88]
 510:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1384              		.loc 1 510 0
 1385 0ac4 F8109FE5 		ldr	r1, .L106+12
 506:../uvc.c      **** 		if(is60Hz==CyFalse)
 1386              		.loc 1 506 0
 1387 0ac8 00005EE3 		cmp	lr, #0
 508:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1388              		.loc 1 508 0
 1389 0acc 80208203 		orreq	r2, r2, #128
 1390 0ad0 5520C405 		streqb	r2, [r4, #85]
 510:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1391              		.loc 1 510 0
 1392 0ad4 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1393 0ad8 0400A0E3 		mov	r0, #4
 1394 0adc FEFFFFEB 		bl	CyU3PDebugPrint
 1395 0ae0 BFFFFFEA 		b	.L92
 1396              	.L105:
 542:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1397              		.loc 1 542 0
 1398 0ae4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1399 0ae8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1400 0aec 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1401 0af0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1402 0af4 0020A0E3 		mov	r2, #0
 1403 0af8 FE0000E2 		and	r0, r0, #254
 1404 0afc 00E08DE5 		str	lr, [sp, #0]
 1405 0b00 FEFFFFEB 		bl	SensorWrite2B2
 1406 0b04 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1407 0b08 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1408 0b0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1409 0b10 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1410 0b14 FE0002E2 		and	r0, r2, #254
 1411 0b18 0020A0E3 		mov	r2, #0
 1412 0b1c 00C08DE5 		str	ip, [sp, #0]
 1413 0b20 FEFFFFEB 		bl	SensorWrite2B2
 1414              	.LVL104:
 1415 0b24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1416 0b28 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1417 0b2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1418 0b30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1419 0b34 0020A0E3 		mov	r2, #0
 1420 0b38 FE0000E2 		and	r0, r0, #254
 1421 0b3c 00C08DE5 		str	ip, [sp, #0]
 1422 0b40 FEFFFFEB 		bl	SensorWrite2B2
 1423 0b44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1424 0b48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1425 0b4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1426 0b50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1427 0b54 FE0002E2 		and	r0, r2, #254
 1428 0b58 0020A0E3 		mov	r2, #0
 1429 0b5c 00C08DE5 		str	ip, [sp, #0]
 1430 0b60 FEFFFFEB 		bl	SensorWrite2B2
 1431 0b64 A2FFFFEA 		b	.L91
 1432              	.LVL105:
 1433              	.L99:
 545:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1434              		.loc 1 545 0 discriminator 1
 1435 0b68 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1436 0b6c 100053E3 		cmp	r3, #16
 1437 0b70 ADFFFF1A 		bne	.L100
 546:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1438              		.loc 1 546 0
 1439 0b74 4C409FE5 		ldr	r4, .L106+16
 1440 0b78 0010E0E3 		mvn	r1, #0
 1441 0b7c 1C0094E5 		ldr	r0, [r4, #28]
 1442 0b80 2C308DE5 		str	r3, [sp, #44]
 1443 0b84 FEFFFFEB 		bl	_txe_mutex_get
 547:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1444              		.loc 1 547 0
 1445 0b88 2C309DE5 		ldr	r3, [sp, #44]
 1446 0b8c 00C0A0E3 		mov	ip, #0
 1447 0b90 0320A0E1 		mov	r2, r3
 1448 0b94 0400A0E1 		mov	r0, r4
 1449 0b98 1710A0E3 		mov	r1, #23
 1450 0b9c 0530A0E1 		mov	r3, r5
 1451 0ba0 00C08DE5 		str	ip, [sp, #0]
 1452 0ba4 04C08DE5 		str	ip, [sp, #4]
 1453 0ba8 FEFFFFEB 		bl	cmdSet
 548:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1454              		.loc 1 548 0
 1455 0bac 1C0094E5 		ldr	r0, [r4, #28]
 1456 0bb0 FEFFFFEB 		bl	_txe_mutex_put
 1457 0bb4 8EFFFFEA 		b	.L91
 1458              	.L107:
 1459              		.align	2
 1460              	.L106:
 1461 0bb8 00000000 		.word	.LANCHOR0
 1462 0bbc 04020000 		.word	.LC14
 1463 0bc0 00000000 		.word	.LANCHOR1
 1464 0bc4 50020000 		.word	.LC15
 1465 0bc8 00000000 		.word	cmdQu
 1466              		.cfi_endproc
 1467              	.LFE0:
 1469              		.align	2
 1470              		.global	setIrisauto
 1472              	setIrisauto:
 1473              	.LFB1:
 563:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1474              		.loc 1 563 0
 1475              		.cfi_startproc
 1476              		@ args = 0, pretend = 0, frame = 0
 1477              		@ frame_needed = 0, uses_anonymous_args = 0
 1478              	.LVL106:
 1479 0bcc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1480              	.LCFI11:
 1481              		.cfi_def_cfa_offset 16
 1482 0bd0 0160A0E1 		mov	r6, r1
 1483              		.cfi_offset 14, -4
 1484              		.cfi_offset 6, -8
 1485              		.cfi_offset 5, -12
 1486              		.cfi_offset 4, -16
 1487 0bd4 08D04DE2 		sub	sp, sp, #8
 1488              	.LCFI12:
 1489              		.cfi_def_cfa_offset 24
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1490              		.loc 1 567 0
 1491 0bd8 0050A0E3 		mov	r5, #0
 563:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1492              		.loc 1 563 0
 1493 0bdc 0040A0E1 		mov	r4, r0
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1494              		.loc 1 566 0
 1495 0be0 0010E0E3 		mvn	r1, #0
 1496              	.LVL107:
 1497 0be4 1C0090E5 		ldr	r0, [r0, #28]
 1498              	.LVL108:
 1499 0be8 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1500              		.loc 1 567 0
 1501 0bec 060065E0 		rsb	r0, r5, r6
 1502 0bf0 00C070E2 		rsbs	ip, r0, #0
 1503 0bf4 00C0ACE0 		adc	ip, ip, r0
 1504 0bf8 1410A0E3 		mov	r1, #20
 1505 0bfc 2720A0E3 		mov	r2, #39
 1506 0c00 3030A0E3 		mov	r3, #48
 1507 0c04 0400A0E1 		mov	r0, r4
 1508 0c08 00C08DE5 		str	ip, [sp, #0]
 1509 0c0c 04508DE5 		str	r5, [sp, #4]
 1510 0c10 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1511              		.loc 1 568 0
 1512 0c14 050056E1 		cmp	r6, r5
 1513 0c18 0260A003 		moveq	r6, #2
 1514 0c1c 0560A011 		movne	r6, r5
 1515 0c20 0400A0E1 		mov	r0, r4
 1516 0c24 1510A0E3 		mov	r1, #21
 1517 0c28 2520A0E3 		mov	r2, #37
 1518 0c2c 3030A0E3 		mov	r3, #48
 1519 0c30 00608DE5 		str	r6, [sp, #0]
 1520 0c34 04508DE5 		str	r5, [sp, #4]
 1521 0c38 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1522              		.loc 1 569 0
 1523 0c3c 1C0094E5 		ldr	r0, [r4, #28]
 570:../uvc.c      **** }
 1524              		.loc 1 570 0
 1525 0c40 08D08DE2 		add	sp, sp, #8
 1526 0c44 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1527              		.loc 1 569 0
 1528 0c48 FEFFFFEA 		b	_txe_mutex_put
 1529              		.cfi_endproc
 1530              	.LFE1:
 1532              		.align	2
 1533              		.global	ControlHandle
 1535              	ControlHandle:
 1536              	.LFB2:
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1537              		.loc 1 572 0
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 24
 1540              		@ frame_needed = 0, uses_anonymous_args = 0
 1541              	.LVL109:
 1542 0c4c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1543              	.LCFI13:
 1544              		.cfi_def_cfa_offset 36
 579:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1545              		.loc 1 579 0
 1546 0c50 1F0050E3 		cmp	r0, #31
 578:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1547              		.loc 1 578 0
 1548 0c54 207040E2 		sub	r7, r0, #32
 1549              		.cfi_offset 14, -4
 1550              		.cfi_offset 11, -8
 1551              		.cfi_offset 10, -12
 1552              		.cfi_offset 9, -16
 1553              		.cfi_offset 8, -20
 1554              		.cfi_offset 7, -24
 1555              		.cfi_offset 6, -28
 1556              		.cfi_offset 5, -32
 1557              		.cfi_offset 4, -36
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1558              		.loc 1 572 0
 1559 0c58 2CD04DE2 		sub	sp, sp, #44
 1560              	.LCFI14:
 1561              		.cfi_def_cfa_offset 80
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1562              		.loc 1 572 0
 1563 0c5c 0040A0E1 		mov	r4, r0
 578:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1564              		.loc 1 578 0
 1565 0c60 FF7007E2 		and	r7, r7, #255
 1566              	.LVL110:
 579:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1567              		.loc 1 579 0
 1568 0c64 2400009A 		bls	.L112
 580:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1569              		.loc 1 580 0
 1570 0c68 586F9FE5 		ldr	r6, .L234
 1571 0c6c 872087E0 		add	r2, r7, r7, asl #1
 1572 0c70 8221A0E1 		mov	r2, r2, asl #3
 1573 0c74 023086E0 		add	r3, r6, r2
 581:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1574              		.loc 1 581 0
 1575 0c78 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 582:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1576              		.loc 1 582 0
 1577 0c7c 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 583:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1578              		.loc 1 583 0
 1579 0c80 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 594:../uvc.c      ****     reqData = bRequest;
 1580              		.loc 1 594 0
 1581 0c84 403F9FE5 		ldr	r3, .L234+4
 580:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1582              		.loc 1 580 0
 1583 0c88 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1584              	.LVL111:
 594:../uvc.c      ****     reqData = bRequest;
 1585              		.loc 1 594 0
 1586 0c8c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1587              	.LVL112:
 602:../uvc.c      ****     switch (bRequest)
 1588              		.loc 1 602 0
 1589 0c90 830055E3 		cmp	r5, #131
 1590 0c94 2300000A 		beq	.L118
 1591              	.LVL113:
 1592              	.L226:
 1593 0c98 2C00009A 		bls	.L224
 1594 0c9c 850055E3 		cmp	r5, #133
 1595 0ca0 8700000A 		beq	.L120
 1596 0ca4 7500003A 		bcc	.L119
 1597 0ca8 860055E3 		cmp	r5, #134
 1598 0cac C000000A 		beq	.L121
 1599 0cb0 870055E3 		cmp	r5, #135
 1600 0cb4 B400000A 		beq	.L225
 1601              	.L114:
1194:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1602              		.loc 1 1194 0
 1603 0cb8 0000A0E3 		mov	r0, #0
 1604 0cbc 0110A0E3 		mov	r1, #1
 1605 0cc0 0020A0E1 		mov	r2, r0
 1606 0cc4 FEFFFFEB 		bl	CyU3PUsbStall
1195:../uvc.c      **** 			  break;
 1607              		.loc 1 1195 0
 1608 0cc8 FFC0A0E3 		mov	ip, #255
 1609 0ccc 0C40A0E1 		mov	r4, ip
 1610 0cd0 0C70A0E1 		mov	r7, ip
 1611              	.LVL114:
 1612 0cd4 0C80A0E1 		mov	r8, ip
 1613              	.LVL115:
 1614              	.L124:
1197:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1615              		.loc 1 1197 0
 1616 0cd8 F01E9FE5 		ldr	r1, .L234+8
 1617 0cdc 0520A0E1 		mov	r2, r5
 1618 0ce0 0830A0E1 		mov	r3, r8
 1619 0ce4 0400A0E3 		mov	r0, #4
 1620 0ce8 00708DE5 		str	r7, [sp, #0]
 1621 0cec 10108DE9 		stmib	sp, {r4, ip}	@ phole stm
 1622 0cf0 FEFFFFEB 		bl	CyU3PDebugPrint
1198:../uvc.c      **** }
 1623              		.loc 1 1198 0
 1624 0cf4 2CD08DE2 		add	sp, sp, #44
 1625 0cf8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1626              	.LVL116:
 1627              	.L112:
 585:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1628              		.loc 1 585 0
 1629 0cfc C46E9FE5 		ldr	r6, .L234
 594:../uvc.c      ****     reqData = bRequest;
 1630              		.loc 1 594 0
 1631 0d00 C43E9FE5 		ldr	r3, .L234+4
 585:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1632              		.loc 1 585 0
 1633 0d04 805080E0 		add	r5, r0, r0, asl #1
 1634 0d08 850186E0 		add	r0, r6, r5, asl #3
 1635              	.LVL117:
 594:../uvc.c      ****     reqData = bRequest;
 1636              		.loc 1 594 0
 1637 0d0c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 585:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1638              		.loc 1 585 0
 1639 0d10 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1640              	.LVL118:
 602:../uvc.c      ****     switch (bRequest)
 1641              		.loc 1 602 0
 1642 0d14 830055E3 		cmp	r5, #131
 586:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1643              		.loc 1 586 0
 1644 0d18 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1645              	.LVL119:
 587:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1646              		.loc 1 587 0
 1647 0d1c 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1648              	.LVL120:
 588:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1649              		.loc 1 588 0
 1650 0d20 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1651              	.LVL121:
 602:../uvc.c      ****     switch (bRequest)
 1652              		.loc 1 602 0
 1653 0d24 DBFFFF1A 		bne	.L226
 1654              	.LVL122:
 1655              	.L118:
 751:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1656              		.loc 1 751 0
 1657 0d28 1F0054E3 		cmp	r4, #31
 1658 0d2c BE00009A 		bls	.L150
 752:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1659              		.loc 1 752 0
 1660 0d30 872087E0 		add	r2, r7, r7, asl #1
 1661 0d34 826186E0 		add	r6, r6, r2, asl #3
 1662 0d38 C8AE9FE5 		ldr	sl, .L234+64
 1663 0d3c 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 753:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1664              		.loc 1 753 0
 1665 0d40 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 752:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1666              		.loc 1 752 0
 1667 0d44 5C00CAE5 		strb	r0, [sl, #92]
 753:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1668              		.loc 1 753 0
 1669 0d48 5DE0CAE5 		strb	lr, [sl, #93]
 1670 0d4c 0B0000EA 		b	.L158
 1671              	.L224:
 602:../uvc.c      ****     switch (bRequest)
 1672              		.loc 1 602 0
 1673 0d50 810055E3 		cmp	r5, #129
 1674 0d54 6600000A 		beq	.L116
 1675 0d58 1000009A 		bls	.L227
 732:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1676              		.loc 1 732 0
 1677 0d5c 1F0054E3 		cmp	r4, #31
 1678 0d60 A500009A 		bls	.L147
 733:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1679              		.loc 1 733 0
 1680 0d64 87A087E0 		add	sl, r7, r7, asl #1
 1681 0d68 8A6186E0 		add	r6, r6, sl, asl #3
 1682 0d6c 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 1683              	.LVL123:
 1684 0d70 90AE9FE5 		ldr	sl, .L234+64
 734:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1685              		.loc 1 734 0
 1686 0d74 04C0D6E5 		ldrb	ip, [r6, #4]	@ zero_extendqisi2
 733:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1687              		.loc 1 733 0
 1688 0d78 5C70CAE5 		strb	r7, [sl, #92]
 734:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1689              		.loc 1 734 0
 1690 0d7c 5DC0CAE5 		strb	ip, [sl, #93]
 1691              	.L158:
 809:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1692              		.loc 1 809 0
 1693 0d80 0800A0E1 		mov	r0, r8
 1694 0d84 481E9FE5 		ldr	r1, .L234+12
 1695 0d88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1696              	.LVL124:
 811:../uvc.c      **** 			  break;
 1697              		.loc 1 811 0
 1698 0d8c FFC0A0E3 		mov	ip, #255
 809:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1699              		.loc 1 809 0
 1700 0d90 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 811:../uvc.c      **** 			  break;
 1701              		.loc 1 811 0
 1702 0d94 0C70A0E1 		mov	r7, ip
 1703 0d98 0C80A0E1 		mov	r8, ip
 1704 0d9c CDFFFFEA 		b	.L124
 1705              	.LVL125:
 1706              	.L227:
 602:../uvc.c      ****     switch (bRequest)
 1707              		.loc 1 602 0
 1708 0da0 010055E3 		cmp	r5, #1
 1709 0da4 C3FFFF1A 		bne	.L114
 813:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1710              		.loc 1 813 0
 1711 0da8 581E9FE5 		ldr	r1, .L234+64
 1712 0dac 26208DE2 		add	r2, sp, #38
 1713 0db0 2000A0E3 		mov	r0, #32
 1714 0db4 5C1081E2 		add	r1, r1, #92
 1715 0db8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1716              	.LVL126:
 815:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1717              		.loc 1 815 0
 1718 0dbc 002050E2 		subs	r2, r0, #0
 1719 0dc0 5703001A 		bne	.L160
 817:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1720              		.loc 1 817 0
 1721 0dc4 3C3E9FE5 		ldr	r3, .L234+64
 818:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1722              		.loc 1 818 0
 1723 0dc8 38CE9FE5 		ldr	ip, .L234+64
 820:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1724              		.loc 1 820 0
 1725 0dcc 340E9FE5 		ldr	r0, .L234+64
 1726              	.LVL127:
 817:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1727              		.loc 1 817 0
 1728 0dd0 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
 818:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1729              		.loc 1 818 0
 1730 0dd4 5DC0DCE5 		ldrb	ip, [ip, #93]	@ zero_extendqisi2
 820:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1731              		.loc 1 820 0
 1732 0dd8 5EE0D0E5 		ldrb	lr, [r0, #94]	@ zero_extendqisi2
 817:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1733              		.loc 1 817 0
 1734 0ddc 14308DE5 		str	r3, [sp, #20]
 1735              	.LVL128:
 818:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1736              		.loc 1 818 0
 1737 0de0 1CC08DE5 		str	ip, [sp, #28]
 1738              	.LVL129:
 820:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1739              		.loc 1 820 0
 1740 0de4 18E08DE5 		str	lr, [sp, #24]
 1741              	.LVL130:
 824:../uvc.c      **** 				  switch(CtrlID)
 1742              		.loc 1 824 0
 1743 0de8 220054E3 		cmp	r4, #34
 1744 0dec 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1745 0df0 6E0200EA 		b	.L161
 1746              	.L177:
 1747 0df4 18180000 		.word	.L162
 1748 0df8 48170000 		.word	.L163
 1749 0dfc B0170000 		.word	.L161
 1750 0e00 B0170000 		.word	.L161
 1751 0e04 F4160000 		.word	.L164
 1752 0e08 B0150000 		.word	.L165
 1753 0e0c 30150000 		.word	.L166
 1754 0e10 B0170000 		.word	.L161
 1755 0e14 B0170000 		.word	.L161
 1756 0e18 B0170000 		.word	.L161
 1757 0e1c B0170000 		.word	.L161
 1758 0e20 B0140000 		.word	.L167
 1759 0e24 B0170000 		.word	.L161
 1760 0e28 B0170000 		.word	.L161
 1761 0e2c B0170000 		.word	.L161
 1762 0e30 B0170000 		.word	.L161
 1763 0e34 581A0000 		.word	.L168
 1764 0e38 B0170000 		.word	.L161
 1765 0e3c B0170000 		.word	.L161
 1766 0e40 B0170000 		.word	.L161
 1767 0e44 B0170000 		.word	.L161
 1768 0e48 B0170000 		.word	.L161
 1769 0e4c B0170000 		.word	.L161
 1770 0e50 B0170000 		.word	.L161
 1771 0e54 B0170000 		.word	.L161
 1772 0e58 F4180000 		.word	.L169
 1773 0e5c B0170000 		.word	.L161
 1774 0e60 C4190000 		.word	.L170
 1775 0e64 88180000 		.word	.L171
 1776 0e68 B0170000 		.word	.L161
 1777 0e6c 54140000 		.word	.L172
 1778 0e70 D0130000 		.word	.L173
 1779 0e74 38130000 		.word	.L174
 1780 0e78 20130000 		.word	.L175
 1781 0e7c BC120000 		.word	.L176
 1782              	.LVL131:
 1783              	.L119:
 769:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1784              		.loc 1 769 0
 1785 0e80 1F0054E3 		cmp	r4, #31
 770:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1786              		.loc 1 770 0
 1787 0e84 87708780 		addhi	r7, r7, r7, asl #1
 1788              	.LVL132:
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1789              		.loc 1 776 0
 1790 0e88 84408490 		addls	r4, r4, r4, asl #1
 770:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1791              		.loc 1 770 0
 1792 0e8c 87618680 		addhi	r6, r6, r7, asl #3
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1793              		.loc 1 776 0
 1794 0e90 84618690 		addls	r6, r6, r4, asl #3
 770:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1795              		.loc 1 770 0
 1796 0e94 6CAD9F85 		ldrhi	sl, .L234+64
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1797              		.loc 1 776 0
 1798 0e98 68AD9F95 		ldrls	sl, .L234+64
 770:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1799              		.loc 1 770 0
 1800 0e9c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 771:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1801              		.loc 1 771 0
 1802 0ea0 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1803              		.loc 1 776 0
 1804 0ea4 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 777:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1805              		.loc 1 777 0
 1806 0ea8 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 778:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1807              		.loc 1 778 0
 1808 0eac 0030A0E3 		mov	r3, #0
 776:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1809              		.loc 1 776 0
 1810 0eb0 5C10CAE5 		strb	r1, [sl, #92]
 777:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1811              		.loc 1 777 0
 1812 0eb4 5D20CAE5 		strb	r2, [sl, #93]
 778:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1813              		.loc 1 778 0
 1814 0eb8 5E30CAE5 		strb	r3, [sl, #94]
 779:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1815              		.loc 1 779 0
 1816 0ebc 5F30CAE5 		strb	r3, [sl, #95]
 1817 0ec0 AEFFFFEA 		b	.L158
 1818              	.LVL133:
 1819              	.L120:
 606:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1820              		.loc 1 606 0
 1821 0ec4 3C4D9FE5 		ldr	r4, .L234+64
 608:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1822              		.loc 1 608 0
 1823 0ec8 0200A0E3 		mov	r0, #2
 606:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1824              		.loc 1 606 0
 1825 0ecc 5C80C4E5 		strb	r8, [r4, #92]
 607:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1826              		.loc 1 607 0
 1827 0ed0 0080A0E3 		mov	r8, #0
 1828 0ed4 5D80C4E5 		strb	r8, [r4, #93]
 608:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1829              		.loc 1 608 0
 1830 0ed8 5C1084E2 		add	r1, r4, #92
 1831 0edc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1832              	.LVL134:
 610:../uvc.c      **** 			  break;
 1833              		.loc 1 610 0
 1834 0ee0 FFC0A0E3 		mov	ip, #255
 608:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1835              		.loc 1 608 0
 1836 0ee4 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 610:../uvc.c      **** 			  break;
 1837              		.loc 1 610 0
 1838 0ee8 0C70A0E1 		mov	r7, ip
 1839              	.LVL135:
 1840 0eec 0C80A0E1 		mov	r8, ip
 1841 0ef0 78FFFFEA 		b	.L124
 1842              	.LVL136:
 1843              	.L116:
 613:../uvc.c      **** 			 switch(CtrlID)
 1844              		.loc 1 613 0
 1845 0ef4 011044E2 		sub	r1, r4, #1
 1846 0ef8 210051E3 		cmp	r1, #33
 1847 0efc 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1848 0f00 C20000EA 		b	.L125
 1849              	.L135:
 1850 0f04 E4110000 		.word	.L126
 1851 0f08 10120000 		.word	.L125
 1852 0f0c 10120000 		.word	.L125
 1853 0f10 10120000 		.word	.L125
 1854 0f14 C4110000 		.word	.L127
 1855 0f18 10120000 		.word	.L125
 1856 0f1c 10120000 		.word	.L125
 1857 0f20 10120000 		.word	.L125
 1858 0f24 10120000 		.word	.L125
 1859 0f28 10120000 		.word	.L125
 1860 0f2c 54120000 		.word	.L128
 1861 0f30 10120000 		.word	.L125
 1862 0f34 10120000 		.word	.L125
 1863 0f38 10120000 		.word	.L125
 1864 0f3c 10120000 		.word	.L125
 1865 0f40 34120000 		.word	.L129
 1866 0f44 10120000 		.word	.L125
 1867 0f48 10120000 		.word	.L125
 1868 0f4c 10120000 		.word	.L125
 1869 0f50 10120000 		.word	.L125
 1870 0f54 10120000 		.word	.L125
 1871 0f58 10120000 		.word	.L125
 1872 0f5c 10120000 		.word	.L125
 1873 0f60 10120000 		.word	.L125
 1874 0f64 78120000 		.word	.L130
 1875 0f68 10120000 		.word	.L125
 1876 0f6c A4110000 		.word	.L131
 1877 0f70 7C110000 		.word	.L132
 1878 0f74 10120000 		.word	.L125
 1879 0f78 10120000 		.word	.L125
 1880 0f7c E0100000 		.word	.L133
 1881 0f80 A8100000 		.word	.L134
 1882 0f84 A8100000 		.word	.L134
 1883 0f88 A8100000 		.word	.L134
 1884              	.L225:
 796:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1885              		.loc 1 796 0
 1886 0f8c 1F0054E3 		cmp	r4, #31
 1887 0f90 3100009A 		bls	.L157
 797:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1888              		.loc 1 797 0
 1889 0f94 87C087E0 		add	ip, r7, r7, asl #1
 1890 0f98 8C6186E0 		add	r6, r6, ip, asl #3
 1891 0f9c 64AC9FE5 		ldr	sl, .L234+64
 1892 0fa0 0B40D6E5 		ldrb	r4, [r6, #11]	@ zero_extendqisi2
 798:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1893              		.loc 1 798 0
 1894 0fa4 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 797:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1895              		.loc 1 797 0
 1896 0fa8 5C40CAE5 		strb	r4, [sl, #92]
 798:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1897              		.loc 1 798 0
 1898 0fac 5D10CAE5 		strb	r1, [sl, #93]
 1899 0fb0 72FFFFEA 		b	.L158
 1900              	.L121:
 785:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1901              		.loc 1 785 0
 1902 0fb4 1F0054E3 		cmp	r4, #31
 786:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1903              		.loc 1 786 0
 1904 0fb8 87708780 		addhi	r7, r7, r7, asl #1
 1905              	.LVL137:
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1906              		.loc 1 789 0
 1907 0fbc 84408490 		addls	r4, r4, r4, asl #1
 786:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1908              		.loc 1 786 0
 1909 0fc0 87618680 		addhi	r6, r6, r7, asl #3
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1910              		.loc 1 789 0
 1911 0fc4 84618690 		addls	r6, r6, r4, asl #3
 786:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1912              		.loc 1 786 0
 1913 0fc8 388C9F85 		ldrhi	r8, .L234+64
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1914              		.loc 1 789 0
 1915 0fcc 348C9F95 		ldrls	r8, .L234+64
 786:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1916              		.loc 1 786 0
 1917 0fd0 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1918              		.loc 1 789 0
 1919 0fd4 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 791:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1920              		.loc 1 791 0
 1921 0fd8 0100A0E3 		mov	r0, #1
 789:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1922              		.loc 1 789 0
 1923 0fdc 5C30C8E5 		strb	r3, [r8, #92]
 791:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1924              		.loc 1 791 0
 1925 0fe0 EC1B9FE5 		ldr	r1, .L234+12
 1926 0fe4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1927              	.LVL138:
 794:../uvc.c      **** 			  break;
 1928              		.loc 1 794 0
 1929 0fe8 FFC0A0E3 		mov	ip, #255
 791:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1930              		.loc 1 791 0
 1931 0fec 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 794:../uvc.c      **** 			  break;
 1932              		.loc 1 794 0
 1933 0ff0 0C70A0E1 		mov	r7, ip
 1934 0ff4 0C80A0E1 		mov	r8, ip
 1935 0ff8 36FFFFEA 		b	.L124
 1936              	.LVL139:
 1937              	.L147:
 737:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1938              		.loc 1 737 0
 1939 0ffc 0B0054E3 		cmp	r4, #11
 744:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1940              		.loc 1 744 0
 1941 1000 84408410 		addne	r4, r4, r4, asl #1
 1942 1004 84618610 		addne	r6, r6, r4, asl #3
 1943 1008 F8AB9F15 		ldrne	sl, .L234+64
 738:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1944              		.loc 1 738 0
 1945 100c F4AB9F05 		ldreq	sl, .L234+64
 1946 1010 C03B9F05 		ldreq	r3, .L234+16
 744:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1947              		.loc 1 744 0
 1948 1014 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 745:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1949              		.loc 1 745 0
 1950 1018 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 738:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1951              		.loc 1 738 0
 1952 101c 5C308A05 		streq	r3, [sl, #92]
 744:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1953              		.loc 1 744 0
 1954 1020 5C20CA15 		strneb	r2, [sl, #92]
 745:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1955              		.loc 1 745 0
 1956 1024 5D30CA15 		strneb	r3, [sl, #93]
 1957 1028 54FFFFEA 		b	.L158
 1958              	.L150:
 755:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1959              		.loc 1 755 0
 1960 102c 0B0054E3 		cmp	r4, #11
 762:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1961              		.loc 1 762 0
 1962 1030 84408410 		addne	r4, r4, r4, asl #1
 1963 1034 84618610 		addne	r6, r6, r4, asl #3
 1964 1038 C8AB9F15 		ldrne	sl, .L234+64
 756:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1965              		.loc 1 756 0
 1966 103c C4AB9F05 		ldreq	sl, .L234+64
 1967 1040 943B9F05 		ldreq	r3, .L234+20
 762:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1968              		.loc 1 762 0
 1969 1044 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 763:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1970              		.loc 1 763 0
 1971 1048 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 756:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1972              		.loc 1 756 0
 1973 104c 5C308A05 		streq	r3, [sl, #92]
 762:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1974              		.loc 1 762 0
 1975 1050 5C20CA15 		strneb	r2, [sl, #92]
 763:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1976              		.loc 1 763 0
 1977 1054 5D30CA15 		strneb	r3, [sl, #93]
 1978 1058 48FFFFEA 		b	.L158
 1979              	.L157:
 800:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1980              		.loc 1 800 0
 1981 105c 0B0054E3 		cmp	r4, #11
 1982 1060 0700000A 		beq	.L228
 806:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1983              		.loc 1 806 0
 1984 1064 84A084E0 		add	sl, r4, r4, asl #1
 1985 1068 8A6186E0 		add	r6, r6, sl, asl #3
 1986 106c 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 1987 1070 90AB9FE5 		ldr	sl, .L234+64
 807:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1988              		.loc 1 807 0
 1989 1074 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 806:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1990              		.loc 1 806 0
 1991 1078 5C20CAE5 		strb	r2, [sl, #92]
 807:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1992              		.loc 1 807 0
 1993 107c 5D30CAE5 		strb	r3, [sl, #93]
 1994 1080 3EFFFFEA 		b	.L158
 1995              	.L228:
 801:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1996              		.loc 1 801 0
 1997 1084 7CAB9FE5 		ldr	sl, .L234+64
 1998 1088 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 803:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1999              		.loc 1 803 0
 2000 108c 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 802:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2001              		.loc 1 802 0
 2002 1090 0070A0E3 		mov	r7, #0
 2003              	.LVL140:
 801:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2004              		.loc 1 801 0
 2005 1094 5C00CAE5 		strb	r0, [sl, #92]
 802:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2006              		.loc 1 802 0
 2007 1098 5D70CAE5 		strb	r7, [sl, #93]
 803:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2008              		.loc 1 803 0
 2009 109c 5EE0CAE5 		strb	lr, [sl, #94]
 804:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2010              		.loc 1 804 0
 2011 10a0 5F70CAE5 		strb	r7, [sl, #95]
 2012 10a4 35FFFFEA 		b	.L158
 2013              	.LVL141:
 2014              	.L134:
 619:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2015              		.loc 1 619 0
 2016 10a8 87E087E0 		add	lr, r7, r7, asl #1
 2017 10ac 8E6186E0 		add	r6, r6, lr, asl #3
 2018 10b0 50CB9FE5 		ldr	ip, .L234+64
 2019 10b4 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 620:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2020              		.loc 1 620 0
 2021 10b8 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 619:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2022              		.loc 1 619 0
 2023 10bc 5C40CCE5 		strb	r4, [ip, #92]
 620:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2024              		.loc 1 620 0
 2025 10c0 5D60CCE5 		strb	r6, [ip, #93]
 2026              	.LVL142:
 2027              	.L138:
 725:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2028              		.loc 1 725 0
 2029 10c4 0800A0E1 		mov	r0, r8
 2030 10c8 041B9FE5 		ldr	r1, .L234+12
 2031 10cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 730:../uvc.c      **** 			  break;
 2032              		.loc 1 730 0
 2033 10d0 FF70A0E3 		mov	r7, #255
 725:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2034              		.loc 1 725 0
 2035 10d4 06C0A0E1 		mov	ip, r6
 730:../uvc.c      **** 			  break;
 2036              		.loc 1 730 0
 2037 10d8 0780A0E1 		mov	r8, r7
 2038 10dc FDFEFFEA 		b	.L124
 2039              	.LVL143:
 2040              	.L133:
 652:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2041              		.loc 1 652 0 discriminator 1
 2042 10e0 000058E3 		cmp	r8, #0
 2043 10e4 E302000A 		beq	.L220
 650:../uvc.c      **** 					 break;
 2044              		.loc 1 650 0
 2045 10e8 28E1A0E1 		mov	lr, r8, lsr #2
 2046 10ec 00005EE3 		cmp	lr, #0
 2047 10f0 03005813 		cmpne	r8, #3
 2048 10f4 0020A083 		movhi	r2, #0
 2049 10f8 0120A093 		movls	r2, #1
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2050              		.loc 1 572 0
 2051 10fc 0E31A0E1 		mov	r3, lr, asl #2
 650:../uvc.c      **** 					 break;
 2052              		.loc 1 650 0
 2053 1100 FE02009A 		bls	.L204
 2054 1104 C81A9FE5 		ldr	r1, .L234+12
 2055 1108 100041E2 		sub	r0, r1, #16
 2056              	.LVL144:
 2057              	.L142:
 653:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2058              		.loc 1 653 0 discriminator 2
 2059 110c 047090E4 		ldr	r7, [r0], #4
 2060 1110 012082E2 		add	r2, r2, #1
 2061 1114 FF2002E2 		and	r2, r2, #255
 2062 1118 02005EE1 		cmp	lr, r2
 2063 111c 047081E4 		str	r7, [r1], #4
 2064 1120 F9FFFF8A 		bhi	.L142
 653:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2065              		.loc 1 653 0 is_stmt 0
 2066 1124 030058E1 		cmp	r8, r3
 2067 1128 D80A9F15 		ldrne	r0, .L234+64
 2068 112c D102000A 		beq	.L220
 2069              	.L212:
 2070 1130 034080E0 		add	r4, r0, r3
 2071 1134 4C10D4E5 		ldrb	r1, [r4, #76]	@ zero_extendqisi2
 652:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2072              		.loc 1 652 0 is_stmt 1
 2073 1138 01C083E2 		add	ip, r3, #1
 2074 113c FF300CE2 		and	r3, ip, #255
 2075              	.LVL145:
 2076 1140 030058E1 		cmp	r8, r3
 653:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2077              		.loc 1 653 0
 2078 1144 5C10C4E5 		strb	r1, [r4, #92]
 652:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2079              		.loc 1 652 0
 2080 1148 F8FFFF8A 		bhi	.L212
 2081              	.LVL146:
 2082              	.L137:
 662:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2083              		.loc 1 662 0
 2084 114c 5760D0E5 		ldrb	r6, [r0, #87]	@ zero_extendqisi2
 655:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2085              		.loc 1 655 0
 2086 1150 B03A9FE5 		ldr	r3, .L234+64
 662:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2087              		.loc 1 662 0
 2088 1154 FF0056E3 		cmp	r6, #255
 655:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2089              		.loc 1 655 0
 2090 1158 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2091              	.LVL147:
 656:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2092              		.loc 1 656 0
 2093 115c 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2094              	.LVL148:
 662:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2095              		.loc 1 662 0
 2096 1160 D7FFFF0A 		beq	.L138
 664:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2097              		.loc 1 664 0
 2098 1164 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2099 1168 701A9FE5 		ldr	r1, .L234+24
 2100 116c 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2101 1170 0400A0E3 		mov	r0, #4
 2102 1174 FEFFFFEB 		bl	CyU3PDebugPrint
 2103 1178 D1FFFFEA 		b	.L138
 2104              	.LVL149:
 2105              	.L132:
 639:../uvc.c      **** 					 if(CamMode == 1){//720p
 2106              		.loc 1 639 0
 2107 117c 847A9FE5 		ldr	r7, .L234+64
 2108              	.LVL150:
 638:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2109              		.loc 1 638 0
 2110 1180 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2111              	.LVL151:
 639:../uvc.c      **** 					 if(CamMode == 1){//720p
 2112              		.loc 1 639 0
 2113 1184 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2114 1188 010052E3 		cmp	r2, #1
 2115 118c 6C02000A 		beq	.L229
 2116              	.LVL152:
 2117              	.L139:
 649:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2118              		.loc 1 649 0
 2119 1190 0030A0E3 		mov	r3, #0
 648:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2120              		.loc 1 648 0
 2121 1194 5C40C7E5 		strb	r4, [r7, #92]
 649:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2122              		.loc 1 649 0
 2123 1198 5D30C7E5 		strb	r3, [r7, #93]
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2124              		.loc 1 590 0
 2125 119c FF60A0E3 		mov	r6, #255
 650:../uvc.c      **** 					 break;
 2126              		.loc 1 650 0
 2127 11a0 C7FFFFEA 		b	.L138
 2128              	.LVL153:
 2129              	.L131:
 632:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 2130              		.loc 1 632 0
 2131 11a4 B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
 2132 11a8 581A9FE5 		ldr	r1, .L234+64
 634:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 2133              		.loc 1 634 0
 2134 11ac B204D6E5 		ldrb	r0, [r6, #1202]	@ zero_extendqisi2
 632:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 2135              		.loc 1 632 0
 2136 11b0 FF4004E2 		and	r4, r4, #255
 2137 11b4 5C40C1E5 		strb	r4, [r1, #92]
 634:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 2138              		.loc 1 634 0
 2139 11b8 5D00C1E5 		strb	r0, [r1, #93]
 2140              	.LVL154:
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2141              		.loc 1 590 0
 2142 11bc FF60A0E3 		mov	r6, #255
 636:../uvc.c      **** 			 		 break;
 2143              		.loc 1 636 0
 2144 11c0 BFFFFFEA 		b	.L138
 2145              	.LVL155:
 2146              	.L127:
 705:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2147              		.loc 1 705 0
 2148 11c4 0572D6E5 		ldrb	r7, [r6, #517]	@ zero_extendqisi2
 2149              	.LVL156:
 2150 11c8 386A9FE5 		ldr	r6, .L234+64
 2151 11cc 804027E2 		eor	r4, r7, #128
 706:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2152              		.loc 1 706 0
 2153 11d0 00C0A0E3 		mov	ip, #0
 705:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2154              		.loc 1 705 0
 2155 11d4 5C40C6E5 		strb	r4, [r6, #92]
 706:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2156              		.loc 1 706 0
 2157 11d8 5DC0C6E5 		strb	ip, [r6, #93]
 2158              	.LVL157:
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2159              		.loc 1 590 0
 2160 11dc FF60A0E3 		mov	r6, #255
 708:../uvc.c      **** 					 break;
 2161              		.loc 1 708 0
 2162 11e0 B7FFFFEA 		b	.L138
 2163              	.LVL158:
 2164              	.L126:
 693:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2165              		.loc 1 693 0
 2166 11e4 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2167              	.LVL159:
 699:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2168              		.loc 1 699 0
 2169 11e8 181A9FE5 		ldr	r1, .L234+64
 694:../uvc.c      **** 					  if(Data0&0x80){
 2170              		.loc 1 694 0
 2171 11ec 800014E3 		tst	r4, #128
 695:../uvc.c      **** 						  Data0 = ~Data0;
 2172              		.loc 1 695 0
 2173 11f0 0440E011 		mvnne	r4, r4
 2174              	.LVL160:
 697:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2175              		.loc 1 697 0
 2176 11f4 80404402 		subeq	r4, r4, #128
 2177 11f8 FF4004E2 		and	r4, r4, #255
 2178              	.LVL161:
 700:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2179              		.loc 1 700 0
 2180 11fc 0020A0E3 		mov	r2, #0
 699:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2181              		.loc 1 699 0
 2182 1200 5C40C1E5 		strb	r4, [r1, #92]
 700:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2183              		.loc 1 700 0
 2184 1204 5D20C1E5 		strb	r2, [r1, #93]
 2185              	.LVL162:
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2186              		.loc 1 590 0
 2187 1208 FF60A0E3 		mov	r6, #255
 702:../uvc.c      **** 			 		 break;
 2188              		.loc 1 702 0
 2189 120c ACFFFFEA 		b	.L138
 2190              	.LVL163:
 2191              	.L125:
 719:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2192              		.loc 1 719 0
 2193 1210 844084E0 		add	r4, r4, r4, asl #1
 2194 1214 841186E0 		add	r1, r6, r4, asl #3
 2195 1218 E8399FE5 		ldr	r3, .L234+64
 2196 121c 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 720:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2197              		.loc 1 720 0
 2198 1220 0020A0E3 		mov	r2, #0
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2199              		.loc 1 590 0
 2200 1224 FF60A0E3 		mov	r6, #255
 719:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2201              		.loc 1 719 0
 2202 1228 5C40C3E5 		strb	r4, [r3, #92]
 720:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2203              		.loc 1 720 0
 2204 122c 5D20C3E5 		strb	r2, [r3, #93]
 2205              	.LVL164:
 722:../uvc.c      **** 					 break;
 2206              		.loc 1 722 0
 2207 1230 A3FFFFEA 		b	.L138
 2208              	.LVL165:
 2209              	.L129:
 626:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 2210              		.loc 1 626 0
 2211 1234 9D24D6E5 		ldrb	r2, [r6, #1181]	@ zero_extendqisi2
 2212 1238 C8399FE5 		ldr	r3, .L234+64
 628:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 2213              		.loc 1 628 0
 2214 123c 9E74D6E5 		ldrb	r7, [r6, #1182]	@ zero_extendqisi2
 2215              	.LVL166:
 626:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 2216              		.loc 1 626 0
 2217 1240 FF4002E2 		and	r4, r2, #255
 2218 1244 5C40C3E5 		strb	r4, [r3, #92]
 628:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 2219              		.loc 1 628 0
 2220 1248 5D70C3E5 		strb	r7, [r3, #93]
 2221              	.LVL167:
 590:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2222              		.loc 1 590 0
 2223 124c FF60A0E3 		mov	r6, #255
 630:../uvc.c      **** 			 		 break;
 2224              		.loc 1 630 0
 2225 1250 9BFFFFEA 		b	.L138
 2226              	.LVL168:
 2227              	.L128:
 710:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2228              		.loc 1 710 0
 2229 1254 AC099FE5 		ldr	r0, .L234+64
 2230 1258 CC44D6E5 		ldrb	r4, [r6, #1228]	@ zero_extendqisi2
 712:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2231              		.loc 1 712 0
 2232 125c CE64D6E5 		ldrb	r6, [r6, #1230]	@ zero_extendqisi2
 711:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2233              		.loc 1 711 0
 2234 1260 00E0A0E3 		mov	lr, #0
 710:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2235              		.loc 1 710 0
 2236 1264 5C40C0E5 		strb	r4, [r0, #92]
 711:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2237              		.loc 1 711 0
 2238 1268 5DE0C0E5 		strb	lr, [r0, #93]
 712:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2239              		.loc 1 712 0
 2240 126c 5E60C0E5 		strb	r6, [r0, #94]
 713:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2241              		.loc 1 713 0
 2242 1270 5FE0C0E5 		strb	lr, [r0, #95]
 2243              	.LVL169:
 716:../uvc.c      **** 					 break;
 2244              		.loc 1 716 0
 2245 1274 92FFFFEA 		b	.L138
 2246              	.LVL170:
 2247              	.L130:
 668:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2248              		.loc 1 668 0
 2249 1278 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
 669:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2250              		.loc 1 669 0
 2251 127c C604D6E5 		ldrb	r0, [r6, #1222]	@ zero_extendqisi2
 668:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2252              		.loc 1 668 0
 2253 1280 80E99FE5 		ldr	lr, .L234+64
 672:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2254              		.loc 1 672 0
 2255 1284 0070A0E3 		mov	r7, #0
 2256              	.LVL171:
 668:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2257              		.loc 1 668 0
 2258 1288 FF4003E2 		and	r4, r3, #255
 669:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2259              		.loc 1 669 0
 2260 128c FF6000E2 		and	r6, r0, #255
 668:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2261              		.loc 1 668 0
 2262 1290 5C40CEE5 		strb	r4, [lr, #92]
 669:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2263              		.loc 1 669 0
 2264 1294 5E60CEE5 		strb	r6, [lr, #94]
 672:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2265              		.loc 1 672 0
 2266 1298 5D70CEE5 		strb	r7, [lr, #93]
 674:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2267              		.loc 1 674 0
 2268 129c 5F70CEE5 		strb	r7, [lr, #95]
 2269              	.LVL172:
 677:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2270              		.loc 1 677 0
 2271 12a0 3C199FE5 		ldr	r1, .L234+28
 2272 12a4 0420A0E1 		mov	r2, r4
 2273 12a8 0730A0E1 		mov	r3, r7
 2274 12ac 0400A0E3 		mov	r0, #4
 2275 12b0 C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 2276 12b4 FEFFFFEB 		bl	CyU3PDebugPrint
 678:../uvc.c      **** 					 break;
 2277              		.loc 1 678 0
 2278 12b8 81FFFFEA 		b	.L138
 2279              	.LVL173:
 2280              	.L176:
1019:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2281              		.loc 1 1019 0
 2282 12bc 40499FE5 		ldr	r4, .L234+60
 2283 12c0 0010E0E3 		mvn	r1, #0
 2284 12c4 1C0094E5 		ldr	r0, [r4, #28]
 2285 12c8 FEFFFFEB 		bl	_txe_mutex_get
 2286              	.LVL174:
1020:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2287              		.loc 1 1020 0
 2288 12cc 2210A0E3 		mov	r1, #34
 2289              	.L223:
 2290 12d0 14809DE5 		ldr	r8, [sp, #20]
 2291 12d4 0A30A0E1 		mov	r3, sl
 2292 12d8 00E0A0E3 		mov	lr, #0
 2293 12dc 0920A0E1 		mov	r2, r9
 2294 12e0 0400A0E1 		mov	r0, r4
 2295 12e4 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 2296 12e8 FEFFFFEB 		bl	cmdSet
1021:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2297              		.loc 1 1021 0
 2298 12ec 1C0094E5 		ldr	r0, [r4, #28]
 2299 12f0 FEFFFFEB 		bl	_txe_mutex_put
1022:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2300              		.loc 1 1022 0
 2301 12f4 14109DE5 		ldr	r1, [sp, #20]
 2302 12f8 877087E0 		add	r7, r7, r7, asl #1
 2303              	.LVL175:
 2304 12fc 876186E0 		add	r6, r6, r7, asl #3
1024:../uvc.c      **** 							 break;
 2305              		.loc 1 1024 0
 2306 1300 FFC0A0E3 		mov	ip, #255
1023:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2307              		.loc 1 1023 0
 2308 1304 0130A0E3 		mov	r3, #1
1022:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2309              		.loc 1 1022 0
 2310 1308 0D10C6E5 		strb	r1, [r6, #13]
1023:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2311              		.loc 1 1023 0
 2312 130c 1030C6E5 		strb	r3, [r6, #16]
 2313 1310 0180A0E1 		mov	r8, r1
 2314 1314 18709DE5 		ldr	r7, [sp, #24]
1024:../uvc.c      **** 							 break;
 2315              		.loc 1 1024 0
 2316 1318 0C40A0E1 		mov	r4, ip
 2317 131c 6DFEFFEA 		b	.L124
 2318              	.LVL176:
 2319              	.L175:
1011:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2320              		.loc 1 1011 0
 2321 1320 DC489FE5 		ldr	r4, .L234+60
 2322 1324 0010E0E3 		mvn	r1, #0
 2323 1328 1C0094E5 		ldr	r0, [r4, #28]
 2324 132c FEFFFFEB 		bl	_txe_mutex_get
 2325              	.LVL177:
1012:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2326              		.loc 1 1012 0
 2327 1330 2110A0E3 		mov	r1, #33
 2328 1334 E5FFFFEA 		b	.L223
 2329              	.LVL178:
 2330              	.L174:
 997:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2331              		.loc 1 997 0
 2332 1338 C4489FE5 		ldr	r4, .L234+60
 2333 133c 0010E0E3 		mvn	r1, #0
 2334 1340 1C0094E5 		ldr	r0, [r4, #28]
 2335 1344 FEFFFFEB 		bl	_txe_mutex_get
 2336              	.LVL179:
 996:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2337              		.loc 1 996 0
 2338 1348 14009DE5 		ldr	r0, [sp, #20]
 999:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2339              		.loc 1 999 0
 2340 134c 2010A0E3 		mov	r1, #32
 996:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2341              		.loc 1 996 0
 2342 1350 7F2000E2 		and	r2, r0, #127
 2343 1354 18208DE5 		str	r2, [sp, #24]
 2344              	.LVL180:
 999:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2345              		.loc 1 999 0
 2346 1358 18C09DE5 		ldr	ip, [sp, #24]
 2347 135c 0920A0E1 		mov	r2, r9
 2348 1360 0A30A0E1 		mov	r3, sl
 2349 1364 0400A0E1 		mov	r0, r4
 2350 1368 00C08DE5 		str	ip, [sp, #0]
 2351 136c 00C0A0E3 		mov	ip, #0
 2352 1370 04C08DE5 		str	ip, [sp, #4]
 2353 1374 FEFFFFEB 		bl	cmdSet
 2354              	.LVL181:
1001:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2355              		.loc 1 1001 0
 2356 1378 1CC09DE5 		ldr	ip, [sp, #28]
 2357 137c 0180A0E3 		mov	r8, #1
 2358 1380 2010A0E3 		mov	r1, #32
 2359 1384 0B20A0E1 		mov	r2, fp
 2360 1388 0A30A0E1 		mov	r3, sl
 2361 138c 0400A0E1 		mov	r0, r4
 2362 1390 00C08DE5 		str	ip, [sp, #0]
 2363 1394 04808DE5 		str	r8, [sp, #4]
 2364 1398 FEFFFFEB 		bl	cmdSet
1002:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2365              		.loc 1 1002 0
 2366 139c 1C0094E5 		ldr	r0, [r4, #28]
 2367 13a0 FEFFFFEB 		bl	_txe_mutex_put
 2368              	.LVL182:
1005:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2369              		.loc 1 1005 0
 2370 13a4 87C087E0 		add	ip, r7, r7, asl #1
 2371 13a8 18409DE5 		ldr	r4, [sp, #24]
1006:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2372              		.loc 1 1006 0
 2373 13ac 1C709DE5 		ldr	r7, [sp, #28]
 2374              	.LVL183:
1005:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2375              		.loc 1 1005 0
 2376 13b0 8C6186E0 		add	r6, r6, ip, asl #3
1008:../uvc.c      **** 							 break;
 2377              		.loc 1 1008 0
 2378 13b4 FFC0A0E3 		mov	ip, #255
1005:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2379              		.loc 1 1005 0
 2380 13b8 0D40C6E5 		strb	r4, [r6, #13]
1007:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2381              		.loc 1 1007 0
 2382 13bc 1080C6E5 		strb	r8, [r6, #16]
1006:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2383              		.loc 1 1006 0
 2384 13c0 0E70C6E5 		strb	r7, [r6, #14]
1007:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2385              		.loc 1 1007 0
 2386 13c4 14809DE5 		ldr	r8, [sp, #20]
1008:../uvc.c      **** 							 break;
 2387              		.loc 1 1008 0
 2388 13c8 0C40A0E1 		mov	r4, ip
 2389 13cc 41FEFFEA 		b	.L124
 2390              	.LVL184:
 2391              	.L173:
 968:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2392              		.loc 1 968 0 discriminator 1
 2393 13d0 000058E3 		cmp	r8, #0
 2394 13d4 1800000A 		beq	.L179
 966:../uvc.c      **** 							 break;
 2395              		.loc 1 966 0
 2396 13d8 28E1A0E1 		mov	lr, r8, lsr #2
 2397 13dc 00005EE3 		cmp	lr, #0
 2398 13e0 03005813 		cmpne	r8, #3
 2399 13e4 0020A083 		movhi	r2, #0
 2400 13e8 0120A093 		movls	r2, #1
 2401              	.LVL185:
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2402              		.loc 1 572 0
 2403 13ec 0E31A0E1 		mov	r3, lr, asl #2
 966:../uvc.c      **** 							 break;
 2404              		.loc 1 966 0
 2405 13f0 4502009A 		bls	.L206
 2406 13f4 EC179FE5 		ldr	r1, .L234+32
 2407 13f8 100081E2 		add	r0, r1, #16
 2408              	.LVL186:
 2409              	.L189:
 969:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2410              		.loc 1 969 0 discriminator 2
 2411 13fc 044090E4 		ldr	r4, [r0], #4
 2412 1400 012082E2 		add	r2, r2, #1
 2413 1404 FF2002E2 		and	r2, r2, #255
 2414 1408 02005EE1 		cmp	lr, r2
 2415 140c 044081E4 		str	r4, [r1], #4
 2416 1410 F9FFFF8A 		bhi	.L189
 969:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2417              		.loc 1 969 0 is_stmt 0
 2418 1414 030058E1 		cmp	r8, r3
 2419 1418 0700000A 		beq	.L179
 2420              	.L213:
 2421 141c E4179FE5 		ldr	r1, .L234+64
 2422 1420 030081E0 		add	r0, r1, r3
 2423 1424 5CE0D0E5 		ldrb	lr, [r0, #92]	@ zero_extendqisi2
 968:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2424              		.loc 1 968 0 is_stmt 1
 2425 1428 013083E2 		add	r3, r3, #1
 2426 142c FF3003E2 		and	r3, r3, #255
 2427              	.LVL187:
 2428 1430 030058E1 		cmp	r8, r3
 969:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2429              		.loc 1 969 0
 2430 1434 4CE0C0E5 		strb	lr, [r0, #76]
 968:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2431              		.loc 1 968 0
 2432 1438 F7FFFF8A 		bhi	.L213
 2433              	.LVL188:
 2434              	.L179:
 971:../uvc.c      **** 					 		I2CCmdHandler();
 2435              		.loc 1 971 0
 2436 143c FEFFFFEB 		bl	I2CCmdHandler
 972:../uvc.c      **** 							 break;
 2437              		.loc 1 972 0
 2438 1440 FFC0A0E3 		mov	ip, #255
 971:../uvc.c      **** 					 		I2CCmdHandler();
 2439              		.loc 1 971 0
 2440 1444 14809DE5 		ldr	r8, [sp, #20]
 2441 1448 18709DE5 		ldr	r7, [sp, #24]
 2442              	.LVL189:
 972:../uvc.c      **** 							 break;
 2443              		.loc 1 972 0
 2444 144c 0C40A0E1 		mov	r4, ip
 2445 1450 20FEFFEA 		b	.L124
 2446              	.LVL190:
 2447              	.L172:
 962:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2448              		.loc 1 962 0
 2449 1454 A8479FE5 		ldr	r4, .L234+60
 2450 1458 0010E0E3 		mvn	r1, #0
 2451 145c 1C0094E5 		ldr	r0, [r4, #28]
 2452 1460 FEFFFFEB 		bl	_txe_mutex_get
 2453              	.LVL191:
 963:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2454              		.loc 1 963 0
 2455 1464 14709DE5 		ldr	r7, [sp, #20]
 2456              	.LVL192:
 2457 1468 00C0A0E3 		mov	ip, #0
 2458 146c 018077E2 		rsbs	r8, r7, #1
 2459 1470 0080A033 		movcc	r8, #0
 2460 1474 1E10A0E3 		mov	r1, #30
 2461 1478 0920A0E1 		mov	r2, r9
 2462 147c 0A30A0E1 		mov	r3, sl
 2463 1480 0400A0E1 		mov	r0, r4
 2464 1484 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2465 1488 FEFFFFEB 		bl	cmdSet
 964:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2466              		.loc 1 964 0
 2467 148c 1C0094E5 		ldr	r0, [r4, #28]
 2468 1490 FEFFFFEB 		bl	_txe_mutex_put
 966:../uvc.c      **** 							 break;
 2469              		.loc 1 966 0
 2470 1494 FFC0A0E3 		mov	ip, #255
 965:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2471              		.loc 1 965 0
 2472 1498 0110A0E3 		mov	r1, #1
 2473 149c 6014C6E5 		strb	r1, [r6, #1120]
 2474 14a0 14809DE5 		ldr	r8, [sp, #20]
 2475 14a4 18709DE5 		ldr	r7, [sp, #24]
 966:../uvc.c      **** 							 break;
 2476              		.loc 1 966 0
 2477 14a8 0C40A0E1 		mov	r4, ip
 2478 14ac 09FEFFEA 		b	.L124
 2479              	.LVL193:
 2480              	.L167:
1101:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2481              		.loc 1 1101 0
 2482 14b0 4C879FE5 		ldr	r8, .L234+60
 2483 14b4 0010E0E3 		mvn	r1, #0
 2484 14b8 1C0098E5 		ldr	r0, [r8, #28]
 2485 14bc FEFFFFEB 		bl	_txe_mutex_get
 2486              	.LVL194:
1102:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2487              		.loc 1 1102 0
 2488 14c0 14409DE5 		ldr	r4, [sp, #20]
 2489 14c4 00C0A0E3 		mov	ip, #0
 2490 14c8 0B10A0E3 		mov	r1, #11
 2491 14cc 0920A0E1 		mov	r2, r9
 2492 14d0 0A30A0E1 		mov	r3, sl
 2493 14d4 0800A0E1 		mov	r0, r8
 2494 14d8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2495 14dc FEFFFFEB 		bl	cmdSet
 2496              	.LVL195:
1104:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2497              		.loc 1 1104 0
 2498 14e0 18409DE5 		ldr	r4, [sp, #24]
 2499 14e4 0170A0E3 		mov	r7, #1
 2500              	.LVL196:
 2501 14e8 0B20A0E1 		mov	r2, fp
 2502 14ec 0A30A0E1 		mov	r3, sl
 2503 14f0 0B10A0E3 		mov	r1, #11
 2504 14f4 0800A0E1 		mov	r0, r8
 2505 14f8 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2506 14fc FEFFFFEB 		bl	cmdSet
1105:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2507              		.loc 1 1105 0
 2508 1500 1C0098E5 		ldr	r0, [r8, #28]
 2509 1504 FEFFFFEB 		bl	_txe_mutex_put
1107:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2510              		.loc 1 1107 0
 2511 1508 14209DE5 		ldr	r2, [sp, #20]
1108:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2512              		.loc 1 1108 0
 2513 150c 18309DE5 		ldr	r3, [sp, #24]
1110:../uvc.c      **** 							 break;
 2514              		.loc 1 1110 0
 2515 1510 FFC0A0E3 		mov	ip, #255
1109:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2516              		.loc 1 1109 0
 2517 1514 9872C6E5 		strb	r7, [r6, #664]
1107:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2518              		.loc 1 1107 0
 2519 1518 CC24C6E5 		strb	r2, [r6, #1228]
1108:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2520              		.loc 1 1108 0
 2521 151c CE34C6E5 		strb	r3, [r6, #1230]
1109:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2522              		.loc 1 1109 0
 2523 1520 0280A0E1 		mov	r8, r2
 2524 1524 0370A0E1 		mov	r7, r3
1110:../uvc.c      **** 							 break;
 2525              		.loc 1 1110 0
 2526 1528 0C40A0E1 		mov	r4, ip
 2527 152c E9FDFFEA 		b	.L124
 2528              	.LVL197:
 2529              	.L166:
1087:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2530              		.loc 1 1087 0
 2531 1530 CC869FE5 		ldr	r8, .L234+60
 2532 1534 0010E0E3 		mvn	r1, #0
 2533 1538 1C0098E5 		ldr	r0, [r8, #28]
 2534 153c FEFFFFEB 		bl	_txe_mutex_get
 2535              	.LVL198:
1088:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2536              		.loc 1 1088 0
 2537 1540 14C09DE5 		ldr	ip, [sp, #20]
 2538 1544 0610A0E3 		mov	r1, #6
 2539 1548 0920A0E1 		mov	r2, r9
 2540 154c 0A30A0E1 		mov	r3, sl
 2541 1550 0800A0E1 		mov	r0, r8
 2542 1554 0040A0E3 		mov	r4, #0
 2543 1558 00C08DE5 		str	ip, [sp, #0]
 2544 155c 04408DE5 		str	r4, [sp, #4]
 2545 1560 FEFFFFEB 		bl	cmdSet
 2546              	.LVL199:
1090:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2547              		.loc 1 1090 0
 2548 1564 14C09DE5 		ldr	ip, [sp, #20]
 2549 1568 0170A0E3 		mov	r7, #1
 2550              	.LVL200:
 2551 156c 0610A0E3 		mov	r1, #6
 2552 1570 0B20A0E1 		mov	r2, fp
 2553 1574 0A30A0E1 		mov	r3, sl
 2554 1578 0800A0E1 		mov	r0, r8
 2555 157c 00C08DE5 		str	ip, [sp, #0]
 2556 1580 04708DE5 		str	r7, [sp, #4]
 2557 1584 FEFFFFEB 		bl	cmdSet
1091:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2558              		.loc 1 1091 0
 2559 1588 1C0098E5 		ldr	r0, [r8, #28]
 2560 158c FEFFFFEB 		bl	_txe_mutex_put
1092:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2561              		.loc 1 1092 0
 2562 1590 14409DE5 		ldr	r4, [sp, #20]
1094:../uvc.c      **** 							 break;
 2563              		.loc 1 1094 0
 2564 1594 FFC0A0E3 		mov	ip, #255
1092:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2565              		.loc 1 1092 0
 2566 1598 1D42C6E5 		strb	r4, [r6, #541]
1093:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2567              		.loc 1 1093 0
 2568 159c 2072C6E5 		strb	r7, [r6, #544]
 2569 15a0 0480A0E1 		mov	r8, r4
 2570 15a4 18709DE5 		ldr	r7, [sp, #24]
1094:../uvc.c      **** 							 break;
 2571              		.loc 1 1094 0
 2572 15a8 0C40A0E1 		mov	r4, ip
 2573 15ac C9FDFFEA 		b	.L124
 2574              	.LVL201:
 2575              	.L165:
1067:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2576              		.loc 1 1067 0
 2577 15b0 4C469FE5 		ldr	r4, .L234+60
 2578 15b4 0010E0E3 		mvn	r1, #0
 2579 15b8 1C0094E5 		ldr	r0, [r4, #28]
 2580 15bc FEFFFFEB 		bl	_txe_mutex_get
 2581              	.LVL202:
1068:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2582              		.loc 1 1068 0
 2583 15c0 14109DE5 		ldr	r1, [sp, #20]
 2584 15c4 00C0A0E3 		mov	ip, #0
 2585 15c8 800041E2 		sub	r0, r1, #128
 2586 15cc FF8000E2 		and	r8, r0, #255
 2587 15d0 0510A0E3 		mov	r1, #5
 2588 15d4 0920A0E1 		mov	r2, r9
 2589 15d8 0A30A0E1 		mov	r3, sl
 2590 15dc 0400A0E1 		mov	r0, r4
 2591 15e0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2592 15e4 FEFFFFEB 		bl	cmdSet
 2593              	.LVL203:
1070:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2594              		.loc 1 1070 0
 2595 15e8 14209DE5 		ldr	r2, [sp, #20]
 2596 15ec 0510A0E3 		mov	r1, #5
 2597 15f0 767042E2 		sub	r7, r2, #118
 2598              	.LVL204:
 2599 15f4 FF8007E2 		and	r8, r7, #255
 2600 15f8 DC20A0E3 		mov	r2, #220
 2601 15fc 0170A0E3 		mov	r7, #1
 2602 1600 0A30A0E1 		mov	r3, sl
 2603 1604 0400A0E1 		mov	r0, r4
 2604 1608 00808DE5 		str	r8, [sp, #0]
 2605 160c 04708DE5 		str	r7, [sp, #4]
 2606 1610 FEFFFFEB 		bl	cmdSet
 2607              	.LVL205:
1072:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2608              		.loc 1 1072 0
 2609 1614 14309DE5 		ldr	r3, [sp, #20]
 2610 1618 DE20A0E3 		mov	r2, #222
 2611 161c 7E1083E2 		add	r1, r3, #126
 2612 1620 FFC001E2 		and	ip, r1, #255
 2613 1624 0A30A0E1 		mov	r3, sl
 2614 1628 0510A0E3 		mov	r1, #5
 2615 162c 0400A0E1 		mov	r0, r4
 2616 1630 0280A0E3 		mov	r8, #2
 2617 1634 00C08DE5 		str	ip, [sp, #0]
 2618 1638 04808DE5 		str	r8, [sp, #4]
 2619 163c FEFFFFEB 		bl	cmdSet
 2620              	.LVL206:
1074:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2621              		.loc 1 1074 0
 2622 1640 14009DE5 		ldr	r0, [sp, #20]
 2623 1644 0510A0E3 		mov	r1, #5
 2624 1648 722080E2 		add	r2, r0, #114
 2625 164c FFC002E2 		and	ip, r2, #255
 2626 1650 0A30A0E1 		mov	r3, sl
 2627 1654 E020A0E3 		mov	r2, #224
 2628 1658 0400A0E1 		mov	r0, r4
 2629 165c 0380A0E3 		mov	r8, #3
 2630 1660 00C08DE5 		str	ip, [sp, #0]
 2631 1664 04808DE5 		str	r8, [sp, #4]
 2632 1668 FEFFFFEB 		bl	cmdSet
 2633              	.LVL207:
1076:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2634              		.loc 1 1076 0
 2635 166c 14309DE5 		ldr	r3, [sp, #20]
 2636 1670 DD20A0E3 		mov	r2, #221
 2637 1674 6F1043E2 		sub	r1, r3, #111
 2638 1678 FFC001E2 		and	ip, r1, #255
 2639 167c 0A30A0E1 		mov	r3, sl
 2640 1680 0510A0E3 		mov	r1, #5
 2641 1684 0400A0E1 		mov	r0, r4
 2642 1688 0480A0E3 		mov	r8, #4
 2643 168c 00C08DE5 		str	ip, [sp, #0]
 2644 1690 04808DE5 		str	r8, [sp, #4]
 2645 1694 FEFFFFEB 		bl	cmdSet
 2646              	.LVL208:
1078:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2647              		.loc 1 1078 0
 2648 1698 68059FE5 		ldr	r0, .L234+64
 2649 169c 05E0A0E3 		mov	lr, #5
 2650 16a0 5C20D0E5 		ldrb	r2, [r0, #92]	@ zero_extendqisi2
 2651 16a4 0E10A0E1 		mov	r1, lr
 2652 16a8 7FC082E2 		add	ip, r2, #127
 2653 16ac FF800CE2 		and	r8, ip, #255
 2654 16b0 0A30A0E1 		mov	r3, sl
 2655 16b4 0B20A0E1 		mov	r2, fp
 2656 16b8 0400A0E1 		mov	r0, r4
 2657 16bc 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 2658 16c0 FEFFFFEB 		bl	cmdSet
1079:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2659              		.loc 1 1079 0
 2660 16c4 1C0094E5 		ldr	r0, [r4, #28]
 2661 16c8 FEFFFFEB 		bl	_txe_mutex_put
1081:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2662              		.loc 1 1081 0
 2663 16cc 34359FE5 		ldr	r3, .L234+64
1083:../uvc.c      **** 							 break;
 2664              		.loc 1 1083 0
 2665 16d0 FFC0A0E3 		mov	ip, #255
1081:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2666              		.loc 1 1081 0
 2667 16d4 5C10D3E5 		ldrb	r1, [r3, #92]	@ zero_extendqisi2
1082:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2668              		.loc 1 1082 0
 2669 16d8 0872C6E5 		strb	r7, [r6, #520]
1081:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2670              		.loc 1 1081 0
 2671 16dc 800041E2 		sub	r0, r1, #128
 2672 16e0 0502C6E5 		strb	r0, [r6, #517]
1082:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2673              		.loc 1 1082 0
 2674 16e4 14809DE5 		ldr	r8, [sp, #20]
 2675 16e8 18709DE5 		ldr	r7, [sp, #24]
1083:../uvc.c      **** 							 break;
 2676              		.loc 1 1083 0
 2677 16ec 0C40A0E1 		mov	r4, ip
 2678 16f0 78FDFFEA 		b	.L124
 2679              	.LVL209:
 2680              	.L164:
1115:../uvc.c      **** 							 is60Hz = Data0;
 2681              		.loc 1 1115 0
 2682 16f4 0C059FE5 		ldr	r0, .L234+64
 2683 16f8 03E0A0E1 		mov	lr, r3
 2684              	.LVL210:
1114:../uvc.c      **** 							 Data0 = Data0 - 1;
 2685              		.loc 1 1114 0
 2686 16fc 013043E2 		sub	r3, r3, #1
 2687 1700 FF1003E2 		and	r1, r3, #255
 2688              	.LVL211:
1121:../uvc.c      **** 							 else if(Data0 >2)
 2689              		.loc 1 1121 0
 2690 1704 020051E3 		cmp	r1, #2
1115:../uvc.c      **** 							 is60Hz = Data0;
 2691              		.loc 1 1115 0
 2692 1708 581080E5 		str	r1, [r0, #88]
 2693              	.LVL212:
1127:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2694              		.loc 1 1127 0
 2695 170c F4149FE5 		ldr	r1, .L234+64
1113:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2696              		.loc 1 1113 0
 2697 1710 EDE1C6E5 		strb	lr, [r6, #493]
1124:../uvc.c      **** 								 is60Hz = CyTrue;
 2698              		.loc 1 1124 0
 2699 1714 01E0A083 		movhi	lr, #1
 2700 1718 58E08085 		strhi	lr, [r0, #88]
1127:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2701              		.loc 1 1127 0
 2702 171c 280091E5 		ldr	r0, [r1, #40]
 2703 1720 0130A0E1 		mov	r3, r1
 2704 1724 010050E3 		cmp	r0, #1
 2705 1728 1401000A 		beq	.L230
 2706              	.LVL213:
 2707              	.L195:
1153:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2708              		.loc 1 1153 0
 2709 172c 0180A0E3 		mov	r8, #1
1154:../uvc.c      **** 							 break;
 2710              		.loc 1 1154 0
 2711 1730 FFC0A0E3 		mov	ip, #255
1153:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2712              		.loc 1 1153 0
 2713 1734 F081C6E5 		strb	r8, [r6, #496]
 2714 1738 18709DE5 		ldr	r7, [sp, #24]
 2715 173c 14809DE5 		ldr	r8, [sp, #20]
1154:../uvc.c      **** 							 break;
 2716              		.loc 1 1154 0
 2717 1740 0C40A0E1 		mov	r4, ip
 2718 1744 63FDFFEA 		b	.L124
 2719              	.LVL214:
 2720              	.L163:
1049:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2721              		.loc 1 1049 0
 2722 1748 B4849FE5 		ldr	r8, .L234+60
 2723 174c 0010E0E3 		mvn	r1, #0
 2724 1750 1C0098E5 		ldr	r0, [r8, #28]
 2725 1754 FEFFFFEB 		bl	_txe_mutex_get
 2726              	.LVL215:
1051:../uvc.c      **** 							  if(Data0&0x80){
 2727              		.loc 1 1051 0
 2728 1758 14209DE5 		ldr	r2, [sp, #20]
1056:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2729              		.loc 1 1056 0
 2730 175c 00C0A0E3 		mov	ip, #0
1051:../uvc.c      **** 							  if(Data0&0x80){
 2731              		.loc 1 1051 0
 2732 1760 800012E3 		tst	r2, #128
1052:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2733              		.loc 1 1052 0
 2734 1764 80704212 		subne	r7, r2, #128
 2735              	.LVL216:
1054:../uvc.c      **** 								  Data0 = ~Data0;
 2736              		.loc 1 1054 0
 2737 1768 0270E001 		mvneq	r7, r2
 2738 176c FF7007E2 		and	r7, r7, #255
 2739              	.LVL217:
1056:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2740              		.loc 1 1056 0
 2741 1770 0110A0E3 		mov	r1, #1
 2742 1774 0B20A0E1 		mov	r2, fp
 2743 1778 0A30A0E1 		mov	r3, sl
 2744 177c 80049FE5 		ldr	r0, .L234+60
 2745 1780 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2746 1784 FEFFFFEB 		bl	cmdSet
1057:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2747              		.loc 1 1057 0
 2748 1788 1C0098E5 		ldr	r0, [r8, #28]
 2749 178c FEFFFFEB 		bl	_txe_mutex_put
1060:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2750              		.loc 1 1060 0
 2751 1790 0140A0E3 		mov	r4, #1
1063:../uvc.c      **** 							 break;
 2752              		.loc 1 1063 0
 2753 1794 FFC0A0E3 		mov	ip, #255
1059:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2754              		.loc 1 1059 0
 2755 1798 A571C6E5 		strb	r7, [r6, #421]
1060:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2756              		.loc 1 1060 0
 2757 179c A841C6E5 		strb	r4, [r6, #424]
 2758 17a0 14809DE5 		ldr	r8, [sp, #20]
 2759 17a4 18709DE5 		ldr	r7, [sp, #24]
 2760              	.LVL218:
1063:../uvc.c      **** 							 break;
 2761              		.loc 1 1063 0
 2762 17a8 0C40A0E1 		mov	r4, ip
 2763 17ac 49FDFFEA 		b	.L124
 2764              	.LVL219:
 2765              	.L161:
1177:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2766              		.loc 1 1177 0
 2767 17b0 4C749FE5 		ldr	r7, .L234+60
 2768              	.LVL220:
 2769 17b4 0010E0E3 		mvn	r1, #0
 2770 17b8 1C0097E5 		ldr	r0, [r7, #28]
 2771 17bc FEFFFFEB 		bl	_txe_mutex_get
 2772              	.LVL221:
1178:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2773              		.loc 1 1178 0
 2774 17c0 14C09DE5 		ldr	ip, [sp, #20]
 2775 17c4 0410A0E1 		mov	r1, r4
 2776 17c8 0920A0E1 		mov	r2, r9
 2777 17cc 0A30A0E1 		mov	r3, sl
 2778 17d0 0700A0E1 		mov	r0, r7
 2779 17d4 0080A0E3 		mov	r8, #0
 2780 17d8 00C08DE5 		str	ip, [sp, #0]
 2781 17dc 04808DE5 		str	r8, [sp, #4]
 2782 17e0 FEFFFFEB 		bl	cmdSet
1179:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2783              		.loc 1 1179 0
 2784 17e4 1C0097E5 		ldr	r0, [r7, #28]
 2785 17e8 FEFFFFEB 		bl	_txe_mutex_put
1181:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2786              		.loc 1 1181 0
 2787 17ec 14009DE5 		ldr	r0, [sp, #20]
 2788 17f0 84C084E0 		add	ip, r4, r4, asl #1
 2789 17f4 8C6186E0 		add	r6, r6, ip, asl #3
1182:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2790              		.loc 1 1182 0
 2791 17f8 0110A0E3 		mov	r1, #1
1183:../uvc.c      **** 							 break;
 2792              		.loc 1 1183 0
 2793 17fc FFC0A0E3 		mov	ip, #255
1181:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2794              		.loc 1 1181 0
 2795 1800 8D01C6E5 		strb	r0, [r6, #397]
1182:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2796              		.loc 1 1182 0
 2797 1804 9011C6E5 		strb	r1, [r6, #400]
 2798 1808 0080A0E1 		mov	r8, r0
 2799 180c 18709DE5 		ldr	r7, [sp, #24]
1183:../uvc.c      **** 							 break;
 2800              		.loc 1 1183 0
 2801 1810 0C40A0E1 		mov	r4, ip
 2802 1814 2FFDFFEA 		b	.L124
 2803              	.LVL222:
 2804              	.L162:
1158:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2805              		.loc 1 1158 0
 2806 1818 E8E39FE5 		ldr	lr, .L234+64
1157:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2807              		.loc 1 1157 0
 2808 181c 0140A0E3 		mov	r4, #1
1158:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2809              		.loc 1 1158 0
 2810 1820 7C20DEE5 		ldrb	r2, [lr, #124]	@ zero_extendqisi2
 2811              	.LVL223:
1156:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2812              		.loc 1 1156 0
 2813 1824 8D31C6E5 		strb	r3, [r6, #397]
1158:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2814              		.loc 1 1158 0
 2815 1828 010052E3 		cmp	r2, #1
1157:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2816              		.loc 1 1157 0
 2817 182c 9041C6E5 		strb	r4, [r6, #400]
 2818 1830 0370A011 		movne	r7, r3
 2819              	.LVL224:
1158:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2820              		.loc 1 1158 0
 2821 1834 C700000A 		beq	.L231
 2822              	.LVL225:
 2823              	.L202:
1169:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2824              		.loc 1 1169 0
 2825 1838 C4439FE5 		ldr	r4, .L234+60
 2826 183c 0010E0E3 		mvn	r1, #0
 2827 1840 1C0094E5 		ldr	r0, [r4, #28]
1167:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2828              		.loc 1 1167 0
 2829 1844 2D74C6E5 		strb	r7, [r6, #1069]
 2830              	.LVL226:
1169:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2831              		.loc 1 1169 0
 2832 1848 FEFFFFEB 		bl	_txe_mutex_get
1170:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2833              		.loc 1 1170 0
 2834 184c 00C0A0E3 		mov	ip, #0
 2835 1850 0C10A0E1 		mov	r1, ip
 2836 1854 0920A0E1 		mov	r2, r9
 2837 1858 0A30A0E1 		mov	r3, sl
 2838 185c 0400A0E1 		mov	r0, r4
 2839 1860 00708DE5 		str	r7, [sp, #0]
 2840              	.LVL227:
 2841              	.L222:
 2842 1864 04C08DE5 		str	ip, [sp, #4]
 2843 1868 FEFFFFEB 		bl	cmdSet
1171:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2844              		.loc 1 1171 0
 2845 186c 1C0094E5 		ldr	r0, [r4, #28]
 2846 1870 FEFFFFEB 		bl	_txe_mutex_put
1173:../uvc.c      **** 					 		 break;
 2847              		.loc 1 1173 0
 2848 1874 FFC0A0E3 		mov	ip, #255
1171:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2849              		.loc 1 1171 0
 2850 1878 14809DE5 		ldr	r8, [sp, #20]
 2851 187c 18709DE5 		ldr	r7, [sp, #24]
1173:../uvc.c      **** 					 		 break;
 2852              		.loc 1 1173 0
 2853 1880 0C40A0E1 		mov	r4, ip
 2854 1884 13FDFFEA 		b	.L124
 2855              	.LVL228:
 2856              	.L171:
 940:../uvc.c      **** 							 if(Data0 <= 3){
 2857              		.loc 1 940 0
 2858 1888 030053E3 		cmp	r3, #3
 941:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2859              		.loc 1 941 0
 2860 188c 74139F95 		ldrls	r1, .L234+64
 944:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2861              		.loc 1 944 0
 2862 1890 70C39F85 		ldrhi	ip, .L234+64
 950:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2863              		.loc 1 950 0
 2864 1894 68439FE5 		ldr	r4, .L234+60
 947:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2865              		.loc 1 947 0
 2866 1898 14709DE5 		ldr	r7, [sp, #20]
 2867              	.LVL229:
 2868 189c 0300A0E1 		mov	r0, r3
 2869              	.LVL230:
 944:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2870              		.loc 1 944 0
 2871 18a0 0120A083 		movhi	r2, #1
 2872              	.LVL231:
 941:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2873              		.loc 1 941 0
 2874 18a4 0030A093 		movls	r3, #0
 2875 18a8 7C30C195 		strlsb	r3, [r1, #124]
 2876              	.LVL232:
 945:../uvc.c      **** 								 Data1 = Data0-4;
 2877              		.loc 1 945 0
 2878 18ac 04304382 		subhi	r3, r3, #4
 941:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2879              		.loc 1 941 0
 2880 18b0 0030A091 		movls	r3, r0
 944:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2881              		.loc 1 944 0
 2882 18b4 7C20CC85 		strhib	r2, [ip, #124]
 2883              	.LVL233:
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2884              		.loc 1 949 0
 2885 18b8 0120A0E3 		mov	r2, #1
 950:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2886              		.loc 1 950 0
 2887 18bc 0010E0E3 		mvn	r1, #0
 948:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2888              		.loc 1 948 0
 2889 18c0 8D31C6E5 		strb	r3, [r6, #397]
 949:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2890              		.loc 1 949 0
 2891 18c4 3024C6E5 		strb	r2, [r6, #1072]
 950:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2892              		.loc 1 950 0
 2893 18c8 1C0094E5 		ldr	r0, [r4, #28]
 947:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2894              		.loc 1 947 0
 2895 18cc 2D74C6E5 		strb	r7, [r6, #1069]
 950:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2896              		.loc 1 950 0
 2897 18d0 FEFFFFEB 		bl	_txe_mutex_get
 2898              	.LVL234:
 951:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2899              		.loc 1 951 0
 2900 18d4 14809DE5 		ldr	r8, [sp, #20]
 2901 18d8 1C10A0E3 		mov	r1, #28
 2902 18dc 0920A0E1 		mov	r2, r9
 2903 18e0 0A30A0E1 		mov	r3, sl
 2904 18e4 0400A0E1 		mov	r0, r4
 2905 18e8 00808DE5 		str	r8, [sp, #0]
 2906 18ec 00C0A0E3 		mov	ip, #0
 2907 18f0 DBFFFFEA 		b	.L222
 2908              	.LVL235:
 2909              	.L169:
 883:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2910              		.loc 1 883 0
 2911 18f4 08439FE5 		ldr	r4, .L234+60
 879:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2912              		.loc 1 879 0
 2913 18f8 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 880:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2914              		.loc 1 880 0
 2915 18fc B9C4D6E5 		ldrb	ip, [r6, #1209]	@ zero_extendqisi2
 881:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 2916              		.loc 1 881 0
 2917 1900 C734D6E5 		ldrb	r3, [r6, #1223]	@ zero_extendqisi2
 883:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2918              		.loc 1 883 0
 2919 1904 1C0094E5 		ldr	r0, [r4, #28]
 2920 1908 0010E0E3 		mvn	r1, #0
 880:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2921              		.loc 1 880 0
 2922 190c FF900CE2 		and	r9, ip, #255
 881:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 2923              		.loc 1 881 0
 2924 1910 FF7003E2 		and	r7, r3, #255
 2925              	.LVL236:
 883:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2926              		.loc 1 883 0
 2927 1914 FEFFFFEB 		bl	_txe_mutex_get
 2928              	.LVL237:
 884:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2929              		.loc 1 884 0
 2930 1918 14C09DE5 		ldr	ip, [sp, #20]
 2931 191c C504D6E5 		ldrb	r0, [r6, #1221]	@ zero_extendqisi2
 879:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2932              		.loc 1 879 0
 2933 1920 FFA00AE2 		and	sl, sl, #255
 2934              	.LVL238:
 884:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2935              		.loc 1 884 0
 2936 1924 00005CE1 		cmp	ip, r0
 879:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2937              		.loc 1 879 0
 2938 1928 98229FE5 		ldr	r2, .L234
 2939 192c 0C80A001 		moveq	r8, ip
 884:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 2940              		.loc 1 884 0
 2941 1930 0A00000A 		beq	.L182
 886:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 2942              		.loc 1 886 0
 2943 1934 C5C4C2E5 		strb	ip, [r2, #1221]
 887:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 2944              		.loc 1 887 0
 2945 1938 9D14D2E5 		ldrb	r1, [r2, #1181]	@ zero_extendqisi2
 888:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 2946              		.loc 1 888 0
 2947 193c 00E0A0E3 		mov	lr, #0
 887:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 2948              		.loc 1 887 0
 2949 1940 01228CE1 		orr	r2, ip, r1, asl #4
 2950 1944 FF8002E2 		and	r8, r2, #255
 2951              	.LVL239:
 888:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 2952              		.loc 1 888 0
 2953 1948 0400A0E1 		mov	r0, r4
 2954 194c 1910A0E3 		mov	r1, #25
 2955 1950 0A20A0E1 		mov	r2, sl
 2956 1954 0730A0E1 		mov	r3, r7
 2957 1958 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 2958 195c FEFFFFEB 		bl	cmdSet
 2959              	.LVL240:
 2960              	.L182:
 900:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 2961              		.loc 1 900 0
 2962 1960 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 2963 1964 18009DE5 		ldr	r0, [sp, #24]
 2964 1968 000053E1 		cmp	r3, r0
 2965 196c 0500000A 		beq	.L183
 902:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2966              		.loc 1 902 0
 2967 1970 14209DE5 		ldr	r2, [sp, #20]
 901:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 2968              		.loc 1 901 0
 2969 1974 4CC29FE5 		ldr	ip, .L234
 902:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2970              		.loc 1 902 0
 2971 1978 02E042E2 		sub	lr, r2, #2
 2972 197c 01005EE3 		cmp	lr, #1
 901:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 2973              		.loc 1 901 0
 2974 1980 C604CCE5 		strb	r0, [ip, #1222]
 902:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 2975              		.loc 1 902 0
 2976 1984 BD00009A 		bls	.L232
 2977              	.LVL241:
 2978              	.L183:
 907:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2979              		.loc 1 907 0
 2980 1988 1C0094E5 		ldr	r0, [r4, #28]
 2981 198c FEFFFFEB 		bl	_txe_mutex_put
 909:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 2982              		.loc 1 909 0
 2983 1990 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 908:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2984              		.loc 1 908 0
 2985 1994 18709DE5 		ldr	r7, [sp, #24]
 909:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 2986              		.loc 1 909 0
 2987 1998 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 2988 199c 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 908:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2989              		.loc 1 908 0
 2990 19a0 0400A0E3 		mov	r0, #4
 2991 19a4 40129FE5 		ldr	r1, .L234+36
 2992 19a8 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 2993 19ac 08708DE5 		str	r7, [sp, #8]
 2994 19b0 FEFFFFEB 		bl	CyU3PDebugPrint
 910:../uvc.c      **** 							 break;
 2995              		.loc 1 910 0
 2996 19b4 FFC0A0E3 		mov	ip, #255
 908:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2997              		.loc 1 908 0
 2998 19b8 14809DE5 		ldr	r8, [sp, #20]
 2999              	.LVL242:
 910:../uvc.c      **** 							 break;
 3000              		.loc 1 910 0
 3001 19bc 0C40A0E1 		mov	r4, ip
 3002 19c0 C4FCFFEA 		b	.L124
 3003              	.LVL243:
 3004              	.L170:
 917:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3005              		.loc 1 917 0
 3006 19c4 38429FE5 		ldr	r4, .L234+60
 913:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3007              		.loc 1 913 0
 3008 19c8 A4A4D6E5 		ldrb	sl, [r6, #1188]	@ zero_extendqisi2
 914:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3009              		.loc 1 914 0
 3010 19cc A584D6E5 		ldrb	r8, [r6, #1189]	@ zero_extendqisi2
 915:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3011              		.loc 1 915 0
 3012 19d0 B334D6E5 		ldrb	r3, [r6, #1203]	@ zero_extendqisi2
 917:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3013              		.loc 1 917 0
 3014 19d4 0010E0E3 		mvn	r1, #0
 3015 19d8 1C0094E5 		ldr	r0, [r4, #28]
 915:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3016              		.loc 1 915 0
 3017 19dc FF7003E2 		and	r7, r3, #255
 3018              	.LVL244:
 917:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3019              		.loc 1 917 0
 3020 19e0 FEFFFFEB 		bl	_txe_mutex_get
 3021              	.LVL245:
 925:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3022              		.loc 1 925 0
 3023 19e4 B114D6E5 		ldrb	r1, [r6, #1201]	@ zero_extendqisi2
 3024 19e8 14009DE5 		ldr	r0, [sp, #20]
 913:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3025              		.loc 1 913 0
 3026 19ec FFA00AE2 		and	sl, sl, #255
 3027              	.LVL246:
 925:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3028              		.loc 1 925 0
 3029 19f0 010050E1 		cmp	r0, r1
 914:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3030              		.loc 1 914 0
 3031 19f4 FF8008E2 		and	r8, r8, #255
 3032              	.LVL247:
 913:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3033              		.loc 1 913 0
 3034 19f8 C8319FE5 		ldr	r3, .L234
 925:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3035              		.loc 1 925 0
 3036 19fc 0600000A 		beq	.L184
 926:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3037              		.loc 1 926 0
 3038 1a00 B104C3E5 		strb	r0, [r3, #1201]
 927:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3039              		.loc 1 927 0
 3040 1a04 C504D3E5 		ldrb	r0, [r3, #1221]	@ zero_extendqisi2
 3041 1a08 010050E3 		cmp	r0, #1
 3042 1a0c 7E00000A 		beq	.L185
 927:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3043              		.loc 1 927 0 is_stmt 0 discriminator 1
 3044 1a10 C5E4D3E5 		ldrb	lr, [r3, #1221]	@ zero_extendqisi2
 3045 1a14 03005EE3 		cmp	lr, #3
 3046 1a18 7B00000A 		beq	.L185
 3047              	.LVL248:
 3048              	.L184:
 934:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3049              		.loc 1 934 0 is_stmt 1
 3050 1a1c 1C0094E5 		ldr	r0, [r4, #28]
 3051 1a20 FEFFFFEB 		bl	_txe_mutex_put
 936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3052              		.loc 1 936 0
 3053 1a24 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3054              		.loc 1 935 0
 3055 1a28 14809DE5 		ldr	r8, [sp, #20]
 3056              	.LVL249:
 936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3057              		.loc 1 936 0
 3058 1a2c C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3059              		.loc 1 935 0
 3060 1a30 18709DE5 		ldr	r7, [sp, #24]
 936:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3061              		.loc 1 936 0
 3062 1a34 B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
 935:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3063              		.loc 1 935 0
 3064 1a38 0400A0E3 		mov	r0, #4
 3065 1a3c AC119FE5 		ldr	r1, .L234+40
 3066 1a40 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3067 1a44 08708DE5 		str	r7, [sp, #8]
 3068 1a48 FEFFFFEB 		bl	CyU3PDebugPrint
 937:../uvc.c      **** 							 break;
 3069              		.loc 1 937 0
 3070 1a4c FFC0A0E3 		mov	ip, #255
 3071 1a50 0C40A0E1 		mov	r4, ip
 3072 1a54 9FFCFFEA 		b	.L124
 3073              	.LVL250:
 3074              	.L168:
 827:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3075              		.loc 1 827 0
 3076 1a58 9074D6E5 		ldrb	r7, [r6, #1168]	@ zero_extendqisi2
 3077              	.LVL251:
 3078 1a5c 0310A0E1 		mov	r1, r3
 828:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3079              		.loc 1 828 0
 3080 1a60 9184D6E5 		ldrb	r8, [r6, #1169]	@ zero_extendqisi2
 829:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3081              		.loc 1 829 0
 3082 1a64 9F44D6E5 		ldrb	r4, [r6, #1183]	@ zero_extendqisi2
 830:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3083              		.loc 1 830 0
 3084 1a68 9D34C6E5 		strb	r3, [r6, #1181]
 831:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3085              		.loc 1 831 0
 3086 1a6c C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
 827:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3087              		.loc 1 827 0
 3088 1a70 FFA007E2 		and	sl, r7, #255
 3089              	.LVL252:
 831:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3090              		.loc 1 831 0
 3091 1a74 030013E3 		tst	r3, #3
 828:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3092              		.loc 1 828 0
 3093 1a78 FF8008E2 		and	r8, r8, #255
 3094              	.LVL253:
 829:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3095              		.loc 1 829 0
 3096 1a7c FF7004E2 		and	r7, r4, #255
 3097              	.LVL254:
 831:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3098              		.loc 1 831 0
 3099 1a80 0130A001 		moveq	r3, r1
 3100 1a84 1A00000A 		beq	.L181
 3101 1a88 0120A0E1 		mov	r2, r1
 3102              	.LVL255:
 833:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3103              		.loc 1 833 0
 3104 1a8c 34119FE5 		ldr	r1, .L234
 835:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3105              		.loc 1 835 0
 3106 1a90 6C419FE5 		ldr	r4, .L234+60
 833:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3107              		.loc 1 833 0
 3108 1a94 C5E4D1E5 		ldrb	lr, [r1, #1221]	@ zero_extendqisi2
 835:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3109              		.loc 1 835 0
 3110 1a98 1C0094E5 		ldr	r0, [r4, #28]
 3111 1a9c 0010E0E3 		mvn	r1, #0
 833:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3112              		.loc 1 833 0
 3113 1aa0 02928EE1 		orr	r9, lr, r2, asl #4
 835:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3114              		.loc 1 835 0
 3115 1aa4 FEFFFFEB 		bl	_txe_mutex_get
 836:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3116              		.loc 1 836 0
 3117 1aa8 00C0A0E3 		mov	ip, #0
 3118 1aac 1010A0E3 		mov	r1, #16
 3119 1ab0 0820A0E1 		mov	r2, r8
 3120 1ab4 0730A0E1 		mov	r3, r7
 3121 1ab8 0400A0E1 		mov	r0, r4
 833:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3122              		.loc 1 833 0
 3123 1abc FF9009E2 		and	r9, r9, #255
 3124              	.LVL256:
 836:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3125              		.loc 1 836 0
 3126 1ac0 00C08DE5 		str	ip, [sp, #0]
 3127 1ac4 04C08DE5 		str	ip, [sp, #4]
 3128 1ac8 FEFFFFEB 		bl	cmdSet
 3129              	.LVL257:
 838:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3130              		.loc 1 838 0
 3131 1acc 0730A0E1 		mov	r3, r7
 3132 1ad0 01C0A0E3 		mov	ip, #1
 3133 1ad4 1010A0E3 		mov	r1, #16
 3134 1ad8 0A20A0E1 		mov	r2, sl
 3135 1adc 0400A0E1 		mov	r0, r4
 3136 1ae0 00128DE8 		stmia	sp, {r9, ip}	@ phole stm
 3137 1ae4 FEFFFFEB 		bl	cmdSet
 839:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3138              		.loc 1 839 0
 3139 1ae8 1C0094E5 		ldr	r0, [r4, #28]
 3140 1aec FEFFFFEB 		bl	_txe_mutex_put
 3141 1af0 0930A0E1 		mov	r3, r9
 3142              	.LVL258:
 3143              	.L181:
 842:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3144              		.loc 1 842 0
 3145 1af4 C574D6E5 		ldrb	r7, [r6, #1221]	@ zero_extendqisi2
 3146              	.LVL259:
 3147 1af8 9D84D6E5 		ldrb	r8, [r6, #1181]	@ zero_extendqisi2
 3148              	.LVL260:
 841:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3149              		.loc 1 841 0
 3150 1afc 0400A0E3 		mov	r0, #4
 3151 1b00 EC109FE5 		ldr	r1, .L234+44
 3152 1b04 1C209DE5 		ldr	r2, [sp, #28]
 3153 1b08 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3154 1b0c FEFFFFEB 		bl	CyU3PDebugPrint
 843:../uvc.c      **** 						     break;
 3155              		.loc 1 843 0
 3156 1b10 FFC0A0E3 		mov	ip, #255
 841:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3157              		.loc 1 841 0
 3158 1b14 14809DE5 		ldr	r8, [sp, #20]
 3159 1b18 18709DE5 		ldr	r7, [sp, #24]
 843:../uvc.c      **** 						     break;
 3160              		.loc 1 843 0
 3161 1b1c 0C40A0E1 		mov	r4, ip
 3162 1b20 6CFCFFEA 		b	.L124
 3163              	.LVL261:
 3164              	.L160:
1186:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3165              		.loc 1 1186 0
 3166 1b24 0400A0E3 		mov	r0, #4
 3167              	.LVL262:
 3168 1b28 C8109FE5 		ldr	r1, .L234+48
 3169 1b2c FEFFFFEB 		bl	CyU3PDebugPrint
 3170              	.LVL263:
 3171 1b30 FFC0A0E3 		mov	ip, #255
 3172 1b34 0C40A0E1 		mov	r4, ip
 3173 1b38 0C70A0E1 		mov	r7, ip
 3174              	.LVL264:
 3175 1b3c 0C80A0E1 		mov	r8, ip
 3176 1b40 64FCFFEA 		b	.L124
 3177              	.LVL265:
 3178              	.L229:
 640:../uvc.c      **** 						if(sendData >= 3){
 3179              		.loc 1 640 0
 3180 1b44 020054E3 		cmp	r4, #2
 3181 1b48 4100008A 		bhi	.L233
 3182              	.LVL266:
 3183              	.L140:
 645:../uvc.c      **** 						sendData += 4;
 3184              		.loc 1 645 0
 3185 1b4c 04E084E2 		add	lr, r4, #4
 3186 1b50 FF400EE2 		and	r4, lr, #255
 3187              	.LVL267:
 3188 1b54 8DFDFFEA 		b	.L139
 3189              	.LVL268:
 3190              	.L231:
1160:../uvc.c      **** 								 if(Data0 < 3){
 3191              		.loc 1 1160 0
 3192 1b58 020053E3 		cmp	r3, #2
1161:../uvc.c      **** 					 				 Data0 += 4;
 3193              		.loc 1 1161 0
 3194 1b5c 04708392 		addls	r7, r3, #4
 3195 1b60 FF700792 		andls	r7, r7, #255
1160:../uvc.c      **** 								 if(Data0 < 3){
 3196              		.loc 1 1160 0
 3197 1b64 33FFFF9A 		bls	.L202
1163:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3198              		.loc 1 1163 0
 3199 1b68 0400A0E3 		mov	r0, #4
 3200 1b6c 88109FE5 		ldr	r1, .L234+52
 3201 1b70 14309DE5 		ldr	r3, [sp, #20]
 3202 1b74 FEFFFFEB 		bl	CyU3PDebugPrint
 3203              	.LVL269:
1164:../uvc.c      **** 									Data0 = 4; //set to default.
 3204              		.loc 1 1164 0
 3205 1b78 0470A0E3 		mov	r7, #4
 3206 1b7c 2DFFFFEA 		b	.L202
 3207              	.LVL270:
 3208              	.L230:
1130:../uvc.c      **** 			                       switch (setRes)
 3209              		.loc 1 1130 0
 3210 1b80 7D10D1E5 		ldrb	r1, [r1, #125]	@ zero_extendqisi2
 3211 1b84 020051E3 		cmp	r1, #2
 3212 1b88 5200000A 		beq	.L197
 3213 1b8c 030051E3 		cmp	r1, #3
 3214 1b90 4400000A 		beq	.L198
 3215 1b94 010051E3 		cmp	r1, #1
 3216 1b98 E3FEFF1A 		bne	.L195
1133:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3217              		.loc 1 1133 0
 3218 1b9c 582093E5 		ldr	r2, [r3, #88]
 3219              	.LVL271:
 3220 1ba0 0100A0E1 		mov	r0, r1
 3221 1ba4 000052E3 		cmp	r2, #0
 3222 1ba8 2F1081E2 		add	r1, r1, #47
 3223 1bac E420A003 		moveq	r2, #228
 3224 1bb0 6420A013 		movne	r2, #100
 3225 1bb4 5230A0E3 		mov	r3, #82
 3226 1bb8 FEFFFFEB 		bl	SensorSetIrisControl
1134:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3227              		.loc 1 1134 0
 3228 1bbc 7D0FA0E3 		mov	r0, #500
 3229 1bc0 FEFFFFEB 		bl	_tx_thread_sleep
1136:../uvc.c      **** 			                         		break;
 3230              		.loc 1 1136 0
 3231 1bc4 D8FEFFEA 		b	.L195
 3232              	.L235:
 3233              		.align	2
 3234              	.L234:
 3235 1bc8 00000000 		.word	.LANCHOR1
 3236 1bcc 00000000 		.word	bRequest
 3237 1bd0 DC030000 		.word	.LC23
 3238 1bd4 5C000000 		.word	.LANCHOR0+92
 3239 1bd8 01000100 		.word	65537
 3240 1bdc FF00FF00 		.word	16711935
 3241 1be0 B0020000 		.word	.LC17
 3242 1be4 EC020000 		.word	.LC18
 3243 1be8 4C000000 		.word	.LANCHOR0+76
 3244 1bec 40030000 		.word	.LC20
 3245 1bf0 74030000 		.word	.LC21
 3246 1bf4 14030000 		.word	.LC19
 3247 1bf8 AC030000 		.word	.LC22
 3248 1bfc 78020000 		.word	.LC16
 3249 1c00 00000000 		.word	.LANCHOR1
 3250 1c04 00000000 		.word	cmdQu
 3251 1c08 00000000 		.word	.LANCHOR0
 3252              	.LVL272:
 3253              	.L185:
 928:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3254              		.loc 1 928 0
 3255 1c0c 0A20A0E1 		mov	r2, sl
 3256 1c10 0730A0E1 		mov	r3, r7
 3257 1c14 80C0A0E3 		mov	ip, #128
 3258 1c18 00E0A0E3 		mov	lr, #0
 3259 1c1c 1B10A0E3 		mov	r1, #27
 3260 1c20 24001FE5 		ldr	r0, .L234+60
 3261 1c24 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3262 1c28 FEFFFFEB 		bl	cmdSet
 3263              	.LVL273:
 930:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 3264              		.loc 1 930 0
 3265 1c2c 14C09DE5 		ldr	ip, [sp, #20]
 3266 1c30 0730A0E1 		mov	r3, r7
 3267 1c34 1B10A0E3 		mov	r1, #27
 3268 1c38 0170A0E3 		mov	r7, #1
 3269              	.LVL274:
 3270 1c3c 0820A0E1 		mov	r2, r8
 3271 1c40 44001FE5 		ldr	r0, .L234+60
 3272 1c44 00C08DE5 		str	ip, [sp, #0]
 3273 1c48 04708DE5 		str	r7, [sp, #4]
 3274 1c4c FEFFFFEB 		bl	cmdSet
 3275              	.LVL275:
 3276 1c50 71FFFFEA 		b	.L184
 3277              	.LVL276:
 3278              	.L233:
 641:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3279              		.loc 1 641 0
 3280 1c54 0430A0E1 		mov	r3, r4
 3281 1c58 0400A0E3 		mov	r0, #4
 3282 1c5c 68101FE5 		ldr	r1, .L234+52
 3283 1c60 FEFFFFEB 		bl	CyU3PDebugPrint
 3284              	.LVL277:
 643:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3285              		.loc 1 643 0
 3286 1c64 6CC01FE5 		ldr	ip, .L234+56
 3287 1c68 0060A0E3 		mov	r6, #0
 642:../uvc.c      **** 							sendData = 0; //set back to default
 3288              		.loc 1 642 0
 3289 1c6c 0640A0E1 		mov	r4, r6
 643:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3290              		.loc 1 643 0
 3291 1c70 2D64CCE5 		strb	r6, [ip, #1069]
 3292 1c74 B4FFFFEA 		b	.L140
 3293              	.LVL278:
 3294              	.L220:
 3295 1c78 78001FE5 		ldr	r0, .L234+64
 3296 1c7c 32FDFFEA 		b	.L137
 3297              	.LVL279:
 3298              	.L232:
 903:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3299              		.loc 1 903 0
 3300 1c80 18C09DE5 		ldr	ip, [sp, #24]
 3301 1c84 0730A0E1 		mov	r3, r7
 3302 1c88 1910A0E3 		mov	r1, #25
 3303 1c8c 0070A0E3 		mov	r7, #0
 3304              	.LVL280:
 3305 1c90 0920A0E1 		mov	r2, r9
 3306 1c94 98001FE5 		ldr	r0, .L234+60
 3307 1c98 00C08DE5 		str	ip, [sp, #0]
 3308 1c9c 04708DE5 		str	r7, [sp, #4]
 3309 1ca0 FEFFFFEB 		bl	cmdSet
 3310              	.LVL281:
 3311 1ca4 37FFFFEA 		b	.L183
 3312              	.LVL282:
 3313              	.L198:
1143:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3314              		.loc 1 1143 0
 3315 1ca8 582093E5 		ldr	r2, [r3, #88]
 3316              	.LVL283:
 3317 1cac 8C74D6E5 		ldrb	r7, [r6, #1164]	@ zero_extendqisi2
 3318              	.LVL284:
 3319 1cb0 000052E3 		cmp	r2, #0
 3320 1cb4 C420A003 		moveq	r2, #196
 3321 1cb8 4420A013 		movne	r2, #68
 3322 1cbc 3010A0E3 		mov	r1, #48
 3323 1cc0 072082E1 		orr	r2, r2, r7
 3324 1cc4 5230A0E3 		mov	r3, #82
 3325 1cc8 FEFFFFEB 		bl	SensorSetIrisControl
1144:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3326              		.loc 1 1144 0
 3327 1ccc 7D0FA0E3 		mov	r0, #500
 3328 1cd0 FEFFFFEB 		bl	_tx_thread_sleep
1146:../uvc.c      **** 			                         		break;
 3329              		.loc 1 1146 0
 3330 1cd4 94FEFFEA 		b	.L195
 3331              	.LVL285:
 3332              	.L197:
1138:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3333              		.loc 1 1138 0
 3334 1cd8 582093E5 		ldr	r2, [r3, #88]
 3335              	.LVL286:
 3336 1cdc 3010A0E3 		mov	r1, #48
 3337 1ce0 000052E3 		cmp	r2, #0
 3338 1ce4 D420A003 		moveq	r2, #212
 3339 1ce8 5420A013 		movne	r2, #84
 3340 1cec 5230A0E3 		mov	r3, #82
 3341 1cf0 FEFFFFEB 		bl	SensorSetIrisControl
1139:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3342              		.loc 1 1139 0
 3343 1cf4 7D0FA0E3 		mov	r0, #500
 3344 1cf8 FEFFFFEB 		bl	_tx_thread_sleep
1141:../uvc.c      **** 			                         		break;
 3345              		.loc 1 1141 0
 3346 1cfc 8AFEFFEA 		b	.L195
 3347              	.LVL287:
 3348              	.L204:
 3349 1d00 00011FE5 		ldr	r0, .L234+64
 572:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3350              		.loc 1 572 0
 3351 1d04 0030A0E3 		mov	r3, #0
 3352 1d08 08FDFFEA 		b	.L212
 3353              	.LVL288:
 3354              	.L206:
 3355 1d0c 0030A0E3 		mov	r3, #0
 3356 1d10 C1FDFFEA 		b	.L213
 3357              		.cfi_endproc
 3358              	.LFE2:
 3360              		.align	2
 3361              		.global	CTControlHandle
 3363              	CTControlHandle:
 3364              	.LFB3:
1202:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3365              		.loc 1 1202 0
 3366              		.cfi_startproc
 3367              		@ args = 0, pretend = 0, frame = 64
 3368              		@ frame_needed = 0, uses_anonymous_args = 0
 3369              	.LVL289:
 3370 1d14 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3371              	.LCFI15:
 3372              		.cfi_def_cfa_offset 36
1221:../uvc.c      ****     reqData = bRequest;
 3373              		.loc 1 1221 0
 3374 1d18 60A99FE5 		ldr	sl, .L321
 3375              		.cfi_offset 14, -4
 3376              		.cfi_offset 11, -8
 3377              		.cfi_offset 10, -12
 3378              		.cfi_offset 9, -16
 3379              		.cfi_offset 8, -20
 3380              		.cfi_offset 7, -24
 3381              		.cfi_offset 6, -28
 3382              		.cfi_offset 5, -32
 3383              		.cfi_offset 4, -36
1213:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3384              		.loc 1 1213 0
 3385 1d1c 60899FE5 		ldr	r8, .L321+4
1221:../uvc.c      ****     reqData = bRequest;
 3386              		.loc 1 1221 0
 3387 1d20 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1213:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3388              		.loc 1 1213 0
 3389 1d24 8090A0E1 		mov	r9, r0, asl #1
 3390 1d28 002089E0 		add	r2, r9, r0
 3391 1d2c 822188E0 		add	r2, r8, r2, asl #3
1223:../uvc.c      ****     switch (bRequest)
 3392              		.loc 1 1223 0
 3393 1d30 830055E3 		cmp	r5, #131
1202:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3394              		.loc 1 1202 0
 3395 1d34 5CD04DE2 		sub	sp, sp, #92
 3396              	.LCFI16:
 3397              		.cfi_def_cfa_offset 128
1202:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3398              		.loc 1 1202 0
 3399 1d38 0060A0E1 		mov	r6, r0
1213:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3400              		.loc 1 1213 0
 3401 1d3c DF34D2E5 		ldrb	r3, [r2, #1247]	@ zero_extendqisi2
 3402              	.LVL290:
1214:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3403              		.loc 1 1214 0
 3404 1d40 D0B4D2E5 		ldrb	fp, [r2, #1232]	@ zero_extendqisi2
 3405              	.LVL291:
1216:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3406              		.loc 1 1216 0
 3407 1d44 D274D2E5 		ldrb	r7, [r2, #1234]	@ zero_extendqisi2
 3408              	.LVL292:
1223:../uvc.c      ****     switch (bRequest)
 3409              		.loc 1 1223 0
 3410 1d48 7600000A 		beq	.L241
 3411 1d4c 2100009A 		bls	.L316
 3412 1d50 850055E3 		cmp	r5, #133
 3413 1d54 5900000A 		beq	.L243
 3414 1d58 4E00003A 		bcc	.L242
 3415 1d5c 860055E3 		cmp	r5, #134
 3416 1d60 8000000A 		beq	.L244
 3417 1d64 870055E3 		cmp	r5, #135
 3418 1d68 7600000A 		beq	.L317
 3419              	.L237:
1430:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3420              		.loc 1 1430 0
 3421 1d6c 0000A0E3 		mov	r0, #0
 3422              	.LVL293:
 3423 1d70 0110A0E3 		mov	r1, #1
 3424 1d74 0020A0E1 		mov	r2, r0
 3425 1d78 FEFFFFEB 		bl	CyU3PUsbStall
 3426              	.LVL294:
 3427 1d7c 04499FE5 		ldr	r4, .L321+8
1431:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3428              		.loc 1 1431 0
 3429 1d80 0620A0E1 		mov	r2, r6
 3430 1d84 0400A0E3 		mov	r0, #4
 3431 1d88 FC189FE5 		ldr	r1, .L321+12
 3432 1d8c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3433 1d90 FEFFFFEB 		bl	CyU3PDebugPrint
1432:../uvc.c      **** 			  break;
 3434              		.loc 1 1432 0
 3435 1d94 FFC0A0E3 		mov	ip, #255
 3436 1d98 0C60A0E1 		mov	r6, ip
 3437 1d9c 0C80A0E1 		mov	r8, ip
 3438              	.LVL295:
 3439              	.L247:
1436:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3440              		.loc 1 1436 0
 3441 1da0 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3442 1da4 08C08DE5 		str	ip, [sp, #8]
 3443 1da8 E0189FE5 		ldr	r1, .L321+16
 3444 1dac FFC0A0E3 		mov	ip, #255
 3445 1db0 0520A0E1 		mov	r2, r5
 3446 1db4 0830A0E1 		mov	r3, r8
 3447 1db8 0400A0E3 		mov	r0, #4
 3448 1dbc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3449 1dc0 0CC08DE5 		str	ip, [sp, #12]
 3450 1dc4 10E08DE5 		str	lr, [sp, #16]
 3451 1dc8 14708DE5 		str	r7, [sp, #20]
 3452 1dcc FEFFFFEB 		bl	CyU3PDebugPrint
1437:../uvc.c      **** }
 3453              		.loc 1 1437 0
 3454 1dd0 5CD08DE2 		add	sp, sp, #92
 3455 1dd4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3456              	.LVL296:
 3457              	.L316:
1223:../uvc.c      ****     switch (bRequest)
 3458              		.loc 1 1223 0
 3459 1dd8 810055E3 		cmp	r5, #129
 3460 1ddc 4200000A 		beq	.L239
 3461 1de0 1100009A 		bls	.L318
1252:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3462              		.loc 1 1252 0
 3463 1de4 9C489FE5 		ldr	r4, .L321+8
 3464 1de8 D314D2E5 		ldrb	r1, [r2, #1235]	@ zero_extendqisi2
1253:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3465              		.loc 1 1253 0
 3466 1dec D464D2E5 		ldrb	r6, [r2, #1236]	@ zero_extendqisi2
1254:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3467              		.loc 1 1254 0
 3468 1df0 0A0050E3 		cmp	r0, #10
1252:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3469              		.loc 1 1252 0
 3470 1df4 5C10C4E5 		strb	r1, [r4, #92]
1253:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3471              		.loc 1 1253 0
 3472 1df8 5D60C4E5 		strb	r6, [r4, #93]
1254:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3473              		.loc 1 1254 0
 3474 1dfc 2C00000A 		beq	.L315
 3475              	.LVL297:
 3476              	.L254:
1288:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3477              		.loc 1 1288 0
 3478 1e00 00E0A0E3 		mov	lr, #0
 3479 1e04 5EE0C4E5 		strb	lr, [r4, #94]
 3480              	.L255:
1289:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3481              		.loc 1 1289 0
 3482 1e08 0030A0E3 		mov	r3, #0
1290:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3483              		.loc 1 1290 0
 3484 1e0c 0700A0E1 		mov	r0, r7
 3485              	.LVL298:
 3486 1e10 7C189FE5 		ldr	r1, .L321+20
1292:../uvc.c      **** 			  break;
 3487              		.loc 1 1292 0
 3488 1e14 FF60A0E3 		mov	r6, #255
1289:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3489              		.loc 1 1289 0
 3490 1e18 5F30C4E5 		strb	r3, [r4, #95]
1292:../uvc.c      **** 			  break;
 3491              		.loc 1 1292 0
 3492 1e1c 0680A0E1 		mov	r8, r6
1290:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3493              		.loc 1 1290 0
 3494 1e20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3495              	.LVL299:
 3496 1e24 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1292:../uvc.c      **** 			  break;
 3497              		.loc 1 1292 0
 3498 1e28 DCFFFFEA 		b	.L247
 3499              	.LVL300:
 3500              	.L318:
1223:../uvc.c      ****     switch (bRequest)
 3501              		.loc 1 1223 0
 3502 1e2c 010055E3 		cmp	r5, #1
 3503 1e30 CDFFFF1A 		bne	.L237
1294:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3504              		.loc 1 1294 0
 3505 1e34 4C489FE5 		ldr	r4, .L321+8
 3506 1e38 56208DE2 		add	r2, sp, #86
 3507 1e3c 2000A0E3 		mov	r0, #32
 3508              	.LVL301:
 3509 1e40 5C1084E2 		add	r1, r4, #92
 3510 1e44 2C308DE5 		str	r3, [sp, #44]
 3511 1e48 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3512              	.LVL302:
1296:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3513              		.loc 1 1296 0
 3514 1e4c 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1297:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3515              		.loc 1 1297 0
 3516 1e50 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1300:../uvc.c      **** 			  switch(CtrlID)
 3517              		.loc 1 1300 0
 3518 1e54 012046E2 		sub	r2, r6, #1
1296:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3519              		.loc 1 1296 0
 3520 1e58 30008DE5 		str	r0, [sp, #48]
 3521              	.LVL303:
1297:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3522              		.loc 1 1297 0
 3523 1e5c 34C08DE5 		str	ip, [sp, #52]
 3524              	.LVL304:
1300:../uvc.c      **** 			  switch(CtrlID)
 3525              		.loc 1 1300 0
 3526 1e60 2C309DE5 		ldr	r3, [sp, #44]
 3527 1e64 090052E3 		cmp	r2, #9
 3528 1e68 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3529 1e6c 550100EA 		b	.L256
 3530              	.L261:
 3531 1e70 84230000 		.word	.L257
 3532 1e74 C8230000 		.word	.L256
 3533 1e78 94200000 		.word	.L258
 3534 1e7c C8230000 		.word	.L256
 3535 1e80 C8230000 		.word	.L256
 3536 1e84 C8230000 		.word	.L256
 3537 1e88 10200000 		.word	.L259
 3538 1e8c C8230000 		.word	.L256
 3539 1e90 C8230000 		.word	.L256
 3540 1e94 941F0000 		.word	.L260
 3541              	.LVL305:
 3542              	.L242:
1270:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3543              		.loc 1 1270 0
 3544 1e98 E8479FE5 		ldr	r4, .L321+8
 3545 1e9c D784D2E5 		ldrb	r8, [r2, #1239]	@ zero_extendqisi2
1271:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3546              		.loc 1 1271 0
 3547 1ea0 D824D2E5 		ldrb	r2, [r2, #1240]	@ zero_extendqisi2
1272:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3548              		.loc 1 1272 0
 3549 1ea4 0A0050E3 		cmp	r0, #10
1270:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3550              		.loc 1 1270 0
 3551 1ea8 5C80C4E5 		strb	r8, [r4, #92]
1271:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3552              		.loc 1 1271 0
 3553 1eac 5D20C4E5 		strb	r2, [r4, #93]
1272:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3554              		.loc 1 1272 0
 3555 1eb0 D2FFFF1A 		bne	.L254
 3556              	.LVL306:
 3557              	.L315:
1287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3558              		.loc 1 1287 0 discriminator 1
 3559 1eb4 0110A0E3 		mov	r1, #1
 3560 1eb8 5E10C4E5 		strb	r1, [r4, #94]
 3561 1ebc D1FFFFEA 		b	.L255
 3562              	.LVL307:
 3563              	.L243:
1227:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3564              		.loc 1 1227 0
 3565 1ec0 C0479FE5 		ldr	r4, .L321+8
1228:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3566              		.loc 1 1228 0
 3567 1ec4 0030A0E3 		mov	r3, #0
 3568              	.LVL308:
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3569              		.loc 1 1229 0
 3570 1ec8 0200A0E3 		mov	r0, #2
 3571              	.LVL309:
 3572 1ecc 5C1084E2 		add	r1, r4, #92
1231:../uvc.c      **** 			  break;
 3573              		.loc 1 1231 0
 3574 1ed0 FF60A0E3 		mov	r6, #255
1227:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3575              		.loc 1 1227 0
 3576 1ed4 5C70C4E5 		strb	r7, [r4, #92]
1228:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3577              		.loc 1 1228 0
 3578 1ed8 5D30C4E5 		strb	r3, [r4, #93]
1231:../uvc.c      **** 			  break;
 3579              		.loc 1 1231 0
 3580 1edc 0680A0E1 		mov	r8, r6
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3581              		.loc 1 1229 0
 3582 1ee0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3583              	.LVL310:
 3584 1ee4 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1231:../uvc.c      **** 			  break;
 3585              		.loc 1 1231 0
 3586 1ee8 ACFFFFEA 		b	.L247
 3587              	.LVL311:
 3588              	.L239:
1237:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3589              		.loc 1 1237 0
 3590 1eec 94479FE5 		ldr	r4, .L321+8
 3591 1ef0 DDA4D2E5 		ldrb	sl, [r2, #1245]	@ zero_extendqisi2
1238:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3592              		.loc 1 1238 0
 3593 1ef4 DEC4D2E5 		ldrb	ip, [r2, #1246]	@ zero_extendqisi2
1239:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3594              		.loc 1 1239 0
 3595 1ef8 0080A0E3 		mov	r8, #0
1245:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3596              		.loc 1 1245 0
 3597 1efc 0700A0E1 		mov	r0, r7
 3598              	.LVL312:
 3599 1f00 5C1084E2 		add	r1, r4, #92
1250:../uvc.c      **** 			  break;
 3600              		.loc 1 1250 0
 3601 1f04 FF60A0E3 		mov	r6, #255
1238:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3602              		.loc 1 1238 0
 3603 1f08 5DC0C4E5 		strb	ip, [r4, #93]
1239:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3604              		.loc 1 1239 0
 3605 1f0c 5E80C4E5 		strb	r8, [r4, #94]
1240:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3606              		.loc 1 1240 0
 3607 1f10 5F80C4E5 		strb	r8, [r4, #95]
 3608              	.LVL313:
1237:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3609              		.loc 1 1237 0
 3610 1f14 5CA0C4E5 		strb	sl, [r4, #92]
1250:../uvc.c      **** 			  break;
 3611              		.loc 1 1250 0
 3612 1f18 0680A0E1 		mov	r8, r6
1245:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3613              		.loc 1 1245 0
 3614 1f1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3615              	.LVL314:
 3616 1f20 0AC0A0E1 		mov	ip, sl
1250:../uvc.c      **** 			  break;
 3617              		.loc 1 1250 0
 3618 1f24 9DFFFFEA 		b	.L247
 3619              	.LVL315:
 3620              	.L241:
1261:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3621              		.loc 1 1261 0
 3622 1f28 58479FE5 		ldr	r4, .L321+8
 3623 1f2c D534D2E5 		ldrb	r3, [r2, #1237]	@ zero_extendqisi2
 3624              	.LVL316:
1262:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3625              		.loc 1 1262 0
 3626 1f30 D6E4D2E5 		ldrb	lr, [r2, #1238]	@ zero_extendqisi2
1263:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3627              		.loc 1 1263 0
 3628 1f34 0A0050E3 		cmp	r0, #10
1261:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3629              		.loc 1 1261 0
 3630 1f38 5C30C4E5 		strb	r3, [r4, #92]
1262:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3631              		.loc 1 1262 0
 3632 1f3c 5DE0C4E5 		strb	lr, [r4, #93]
1263:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3633              		.loc 1 1263 0
 3634 1f40 AEFFFF1A 		bne	.L254
 3635 1f44 DAFFFFEA 		b	.L315
 3636              	.LVL317:
 3637              	.L317:
1285:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3638              		.loc 1 1285 0
 3639 1f48 38479FE5 		ldr	r4, .L321+8
 3640 1f4c DB64D2E5 		ldrb	r6, [r2, #1243]	@ zero_extendqisi2
1286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3641              		.loc 1 1286 0
 3642 1f50 DCC4D2E5 		ldrb	ip, [r2, #1244]	@ zero_extendqisi2
1287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3643              		.loc 1 1287 0
 3644 1f54 0A0050E3 		cmp	r0, #10
1285:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3645              		.loc 1 1285 0
 3646 1f58 5C60C4E5 		strb	r6, [r4, #92]
1286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3647              		.loc 1 1286 0
 3648 1f5c 5DC0C4E5 		strb	ip, [r4, #93]
1287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3649              		.loc 1 1287 0
 3650 1f60 A6FFFF1A 		bne	.L254
 3651 1f64 D2FFFFEA 		b	.L315
 3652              	.L244:
1279:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3653              		.loc 1 1279 0
 3654 1f68 18479FE5 		ldr	r4, .L321+8
 3655 1f6c D904D2E5 		ldrb	r0, [r2, #1241]	@ zero_extendqisi2
 3656              	.LVL318:
 3657 1f70 0410A0E1 		mov	r1, r4
 3658 1f74 5C00E1E5 		strb	r0, [r1, #92]!
1283:../uvc.c      **** 			  break;
 3659              		.loc 1 1283 0
 3660 1f78 FF60A0E3 		mov	r6, #255
1280:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3661              		.loc 1 1280 0
 3662 1f7c 0100A0E3 		mov	r0, #1
 3663 1f80 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3664              	.LVL319:
1283:../uvc.c      **** 			  break;
 3665              		.loc 1 1283 0
 3666 1f84 0680A0E1 		mov	r8, r6
1280:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3667              		.loc 1 1280 0
 3668 1f88 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1283:../uvc.c      **** 			  break;
 3669              		.loc 1 1283 0
 3670 1f8c 0170A0E3 		mov	r7, #1
 3671 1f90 82FFFFEA 		b	.L247
 3672              	.LVL320:
 3673              	.L260:
1409:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3674              		.loc 1 1409 0
 3675 1f94 FC669FE5 		ldr	r6, .L321+24
 3676 1f98 0010E0E3 		mvn	r1, #0
 3677 1f9c 1C0096E5 		ldr	r0, [r6, #28]
 3678 1fa0 2C308DE5 		str	r3, [sp, #44]
 3679 1fa4 FEFFFFEB 		bl	_txe_mutex_get
1410:../uvc.c      **** 					  if(getData == 1)
 3680              		.loc 1 1410 0
 3681 1fa8 30E09DE5 		ldr	lr, [sp, #48]
 3682 1fac 2C309DE5 		ldr	r3, [sp, #44]
 3683 1fb0 01005EE3 		cmp	lr, #1
 3684 1fb4 A901000A 		beq	.L319
1412:../uvc.c      **** 					  else if(getData == 0xff)
 3685              		.loc 1 1412 0
 3686 1fb8 FF005EE3 		cmp	lr, #255
 3687 1fbc 9E01000A 		beq	.L320
1415:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3688              		.loc 1 1415 0
 3689 1fc0 0080A0E3 		mov	r8, #0
 3690 1fc4 0600A0E1 		mov	r0, r6
 3691 1fc8 1710A0E3 		mov	r1, #23
 3692 1fcc 0B20A0E1 		mov	r2, fp
 3693 1fd0 00808DE5 		str	r8, [sp, #0]
 3694 1fd4 04808DE5 		str	r8, [sp, #4]
 3695 1fd8 FEFFFFEB 		bl	cmdSet
 3696              	.L313:
1418:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3697              		.loc 1 1418 0
 3698 1fdc 1C0096E5 		ldr	r0, [r6, #28]
 3699 1fe0 FEFFFFEB 		bl	_txe_mutex_put
1420:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3700              		.loc 1 1420 0
 3701 1fe4 30809DE5 		ldr	r8, [sp, #48]
 3702 1fe8 34609DE5 		ldr	r6, [sp, #52]
 3703 1fec 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3704 1ff0 0400A0E3 		mov	r0, #4
 3705 1ff4 A0169FE5 		ldr	r1, .L321+28
 3706 1ff8 0820A0E1 		mov	r2, r8
 3707 1ffc 0630A0E1 		mov	r3, r6
 3708 2000 00C08DE5 		str	ip, [sp, #0]
 3709 2004 FEFFFFEB 		bl	CyU3PDebugPrint
1421:../uvc.c      **** 					  break;
 3710              		.loc 1 1421 0
 3711 2008 FFC0A0E3 		mov	ip, #255
 3712 200c 63FFFFEA 		b	.L247
 3713              	.LVL321:
 3714              	.L259:
1386:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3715              		.loc 1 1386 0
 3716 2010 F584D8E5 		ldrb	r8, [r8, #1269]	@ zero_extendqisi2
 3717 2014 010058E3 		cmp	r8, #1
 3718 2018 08005813 		cmpne	r8, #8
 3719 201c 0000A013 		movne	r0, #0
 3720 2020 0100A003 		moveq	r0, #1
 3721 2024 8001001A 		bne	.L310
 3722              	.LVL322:
1389:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3723              		.loc 1 1389 0
 3724 2028 68869FE5 		ldr	r8, .L321+24
 3725 202c 0010E0E3 		mvn	r1, #0
 3726 2030 1C0098E5 		ldr	r0, [r8, #28]
 3727 2034 2C308DE5 		str	r3, [sp, #44]
 3728 2038 FEFFFFEB 		bl	_txe_mutex_get
1390:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3729              		.loc 1 1390 0
 3730 203c 30A09DE5 		ldr	sl, [sp, #48]
 3731 2040 1610A0E3 		mov	r1, #22
 3732 2044 0B20A0E1 		mov	r2, fp
 3733 2048 2C309DE5 		ldr	r3, [sp, #44]
 3734 204c 00C0A0E3 		mov	ip, #0
 3735 2050 0800A0E1 		mov	r0, r8
 3736 2054 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3737 2058 FEFFFFEB 		bl	cmdSet
1391:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3738              		.loc 1 1391 0
 3739 205c 1C0098E5 		ldr	r0, [r8, #28]
 3740 2060 FEFFFFEB 		bl	_txe_mutex_put
1394:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3741              		.loc 1 1394 0
 3742 2064 18069FE5 		ldr	r0, .L321+4
1395:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3743              		.loc 1 1395 0
 3744 2068 34209DE5 		ldr	r2, [sp, #52]
1394:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3745              		.loc 1 1394 0
 3746 206c 061089E0 		add	r1, r9, r6
 3747 2070 813180E0 		add	r3, r0, r1, asl #3
1396:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3748              		.loc 1 1396 0
 3749 2074 0160A0E3 		mov	r6, #1
1394:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3750              		.loc 1 1394 0
 3751 2078 DDA4C3E5 		strb	sl, [r3, #1245]
1395:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3752              		.loc 1 1395 0
 3753 207c DE24C3E5 		strb	r2, [r3, #1246]
1396:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3754              		.loc 1 1396 0
 3755 2080 E064C3E5 		strb	r6, [r3, #1248]
 3756              	.LVL323:
 3757              	.L311:
1398:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3758              		.loc 1 1398 0
 3759 2084 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3760 2088 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1403:../uvc.c      **** 					  break;
 3761              		.loc 1 1403 0
 3762 208c FFC0A0E3 		mov	ip, #255
 3763 2090 42FFFFEA 		b	.L247
 3764              	.LVL324:
 3765              	.L258:
1352:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3766              		.loc 1 1352 0
 3767 2094 F504D8E5 		ldrb	r0, [r8, #1269]	@ zero_extendqisi2
 3768 2098 010050E3 		cmp	r0, #1
 3769 209c 04005013 		cmpne	r0, #4
 3770 20a0 5C01001A 		bne	.L268
1351:../uvc.c      **** 					  value = (value << 8)|Data0;
 3771              		.loc 1 1351 0
 3772 20a4 30109DE5 		ldr	r1, [sp, #48]
 3773 20a8 34E09DE5 		ldr	lr, [sp, #52]
 3774 20ac 0E2481E1 		orr	r2, r1, lr, asl #8
1353:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3775              		.loc 1 1353 0
 3776 20b0 F90052E3 		cmp	r2, #249
 3777 20b4 5701008A 		bhi	.L268
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3778              		.loc 1 1358 0
 3779 20b8 C8A042E2 		sub	sl, r2, #200
 3780 20bc 0AC8A0E1 		mov	ip, sl, asl #16
 3781 20c0 3CC08DE5 		str	ip, [sp, #60]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3782              		.loc 1 1360 0
 3783 20c4 27A062E2 		rsb	sl, r2, #39
 3784 20c8 38A08DE5 		str	sl, [sp, #56]
 3785 20cc 3CA09DE5 		ldr	sl, [sp, #60]
 3786 20d0 C81062E2 		rsb	r1, r2, #200
 3787 20d4 C80052E3 		cmp	r2, #200
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3788              		.loc 1 1358 0
 3789 20d8 640042E2 		sub	r0, r2, #100
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3790              		.loc 1 1360 0
 3791 20dc 0118A0E1 		mov	r1, r1, asl #16
 3792 20e0 64E062E2 		rsb	lr, r2, #100
 3793 20e4 2A18A081 		movhi	r1, sl, lsr #16
 3794 20e8 2118A091 		movls	r1, r1, lsr #16
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3795              		.loc 1 1358 0
 3796 20ec 00C8A0E1 		mov	ip, r0, asl #16
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3797              		.loc 1 1360 0
 3798 20f0 640052E3 		cmp	r2, #100
 3799 20f4 0E08A0E1 		mov	r0, lr, asl #16
 3800 20f8 2C08A081 		movhi	r0, ip, lsr #16
 3801 20fc 38C09DE5 		ldr	ip, [sp, #56]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3802              		.loc 1 1358 0
 3803 2100 14A042E2 		sub	sl, r2, #20
 3804 2104 38A08DE5 		str	sl, [sp, #56]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3805              		.loc 1 1360 0
 3806 2108 2008A091 		movls	r0, r0, lsr #16
 3807 210c 14A062E2 		rsb	sl, r2, #20
 3808 2110 3CA08DE5 		str	sl, [sp, #60]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3809              		.loc 1 1358 0
 3810 2114 27E042E2 		sub	lr, r2, #39
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3811              		.loc 1 1360 0
 3812 2118 000051E1 		cmp	r1, r0
 3813 211c 01A0A031 		movcc	sl, r1
 3814 2120 00A0A021 		movcs	sl, r0
 3815 2124 0CC8A0E1 		mov	ip, ip, asl #16
 3816 2128 270052E3 		cmp	r2, #39
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3817              		.loc 1 1358 0
 3818 212c 0EE8A0E1 		mov	lr, lr, asl #16
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3819              		.loc 1 1360 0
 3820 2130 2CE8A091 		movls	lr, ip, lsr #16
 3821 2134 64C59FE5 		ldr	ip, .L321+32
 3822 2138 20A08DE5 		str	sl, [sp, #32]
 3823 213c 01A06CE0 		rsb	sl, ip, r1
 3824 2140 2EE8A081 		movhi	lr, lr, lsr #16
 3825 2144 00C07AE2 		rsbs	ip, sl, #0
 3826 2148 0AC0ACE0 		adc	ip, ip, sl
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3827              		.loc 1 1358 0
 3828 214c 38A09DE5 		ldr	sl, [sp, #56]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3829              		.loc 1 1360 0
 3830 2150 44C08DE5 		str	ip, [sp, #68]
 3831              	.LVL325:
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3832              		.loc 1 1358 0
 3833 2154 0AC8A0E1 		mov	ip, sl, asl #16
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3834              		.loc 1 1360 0
 3835 2158 3CA09DE5 		ldr	sl, [sp, #60]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3836              		.loc 1 1358 0
 3837 215c 4CC08DE5 		str	ip, [sp, #76]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3838              		.loc 1 1360 0
 3839 2160 0AC8A0E1 		mov	ip, sl, asl #16
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3840              		.loc 1 1358 0
 3841 2164 0AA042E2 		sub	sl, r2, #10
 3842 2168 48A08DE5 		str	sl, [sp, #72]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3843              		.loc 1 1360 0
 3844 216c 20A09DE5 		ldr	sl, [sp, #32]
 3845 2170 3CC08DE5 		str	ip, [sp, #60]
 3846 2174 0A005EE1 		cmp	lr, sl
 3847 2178 0EA0A031 		movcc	sl, lr
 3848 217c 0AC062E2 		rsb	ip, r2, #10
 3849 2180 40C08DE5 		str	ip, [sp, #64]
 3850 2184 38A08DE5 		str	sl, [sp, #56]
 3851 2188 3CC09DE5 		ldr	ip, [sp, #60]
 3852 218c 4CA09DE5 		ldr	sl, [sp, #76]
 3853 2190 140052E3 		cmp	r2, #20
 3854 2194 2CA8A091 		movls	sl, ip, lsr #16
 3855 2198 2AA8A081 		movhi	sl, sl, lsr #16
 3856 219c 44C09DE5 		ldr	ip, [sp, #68]
 3857 21a0 010050E1 		cmp	r0, r1
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3858              		.loc 1 1358 0
 3859 21a4 48109DE5 		ldr	r1, [sp, #72]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3860              		.loc 1 1360 0
 3861 21a8 01C0A033 		movcc	ip, #1
 3862 21ac 3CA08DE5 		str	sl, [sp, #60]
 3863 21b0 24C08DE5 		str	ip, [sp, #36]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3864              		.loc 1 1358 0
 3865 21b4 01A8A0E1 		mov	sl, r1, asl #16
 3866 21b8 05C042E2 		sub	ip, r2, #5
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3867              		.loc 1 1360 0
 3868 21bc 051062E2 		rsb	r1, r2, #5
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3869              		.loc 1 1358 0
 3870 21c0 48A08DE5 		str	sl, [sp, #72]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3871              		.loc 1 1360 0
 3872 21c4 40009DE5 		ldr	r0, [sp, #64]
 3873 21c8 38A09DE5 		ldr	sl, [sp, #56]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3874              		.loc 1 1358 0
 3875 21cc 40C08DE5 		str	ip, [sp, #64]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3876              		.loc 1 1360 0
 3877 21d0 3CC09DE5 		ldr	ip, [sp, #60]
 3878 21d4 4C108DE5 		str	r1, [sp, #76]
 3879 21d8 48109DE5 		ldr	r1, [sp, #72]
 3880 21dc 0008A0E1 		mov	r0, r0, asl #16
 3881 21e0 0A005CE1 		cmp	ip, sl
 3882 21e4 0AC0A021 		movcs	ip, sl
 3883 21e8 0A0052E3 		cmp	r2, #10
 3884 21ec 20A09DE5 		ldr	sl, [sp, #32]
 3885 21f0 2108A081 		movhi	r0, r1, lsr #16
 3886 21f4 2008A091 		movls	r0, r0, lsr #16
 3887 21f8 48008DE5 		str	r0, [sp, #72]
 3888 21fc 24009DE5 		ldr	r0, [sp, #36]
 3889 2200 0A005EE1 		cmp	lr, sl
 3890 2204 0200A033 		movcc	r0, #2
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3891              		.loc 1 1358 0
 3892 2208 02E042E2 		sub	lr, r2, #2
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3893              		.loc 1 1360 0
 3894 220c 44C08DE5 		str	ip, [sp, #68]
 3895 2210 24008DE5 		str	r0, [sp, #36]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3896              		.loc 1 1358 0
 3897 2214 40C09DE5 		ldr	ip, [sp, #64]
 3898 2218 1CE08DE5 		str	lr, [sp, #28]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3899              		.loc 1 1360 0
 3900 221c 44009DE5 		ldr	r0, [sp, #68]
 3901 2220 48E09DE5 		ldr	lr, [sp, #72]
 3902 2224 4C109DE5 		ldr	r1, [sp, #76]
 3903 2228 02A062E2 		rsb	sl, r2, #2
 3904 222c 00005EE1 		cmp	lr, r0
 3905 2230 00E0A021 		movcs	lr, r0
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3906              		.loc 1 1358 0
 3907 2234 0CC8A0E1 		mov	ip, ip, asl #16
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3908              		.loc 1 1360 0
 3909 2238 050052E3 		cmp	r2, #5
 3910 223c 40A08DE5 		str	sl, [sp, #64]
 3911 2240 0118A0E1 		mov	r1, r1, asl #16
 3912 2244 3CA09DE5 		ldr	sl, [sp, #60]
 3913 2248 2C18A081 		movhi	r1, ip, lsr #16
 3914 224c 38C09DE5 		ldr	ip, [sp, #56]
 3915 2250 4CE08DE5 		str	lr, [sp, #76]
 3916 2254 24009DE5 		ldr	r0, [sp, #36]
 3917 2258 40E09DE5 		ldr	lr, [sp, #64]
 3918 225c 2118A091 		movls	r1, r1, lsr #16
 3919 2260 0C005AE1 		cmp	sl, ip
 3920 2264 20108DE5 		str	r1, [sp, #32]
 3921 2268 0300A033 		movcc	r0, #3
 3922 226c 38008DE5 		str	r0, [sp, #56]
 3923 2270 4CA09DE5 		ldr	sl, [sp, #76]
 3924 2274 0E08A0E1 		mov	r0, lr, asl #16
 3925 2278 20E09DE5 		ldr	lr, [sp, #32]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3926              		.loc 1 1358 0
 3927 227c 1C109DE5 		ldr	r1, [sp, #28]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3928              		.loc 1 1360 0
 3929 2280 0A005EE1 		cmp	lr, sl
 3930 2284 0AE0A021 		movcs	lr, sl
 3931 2288 44C09DE5 		ldr	ip, [sp, #68]
 3932 228c 48A09DE5 		ldr	sl, [sp, #72]
 3933 2290 020052E3 		cmp	r2, #2
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3934              		.loc 1 1358 0
 3935 2294 0118A0E1 		mov	r1, r1, asl #16
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3936              		.loc 1 1360 0
 3937 2298 2018A091 		movls	r1, r0, lsr #16
 3938 229c 38009DE5 		ldr	r0, [sp, #56]
 3939 22a0 2118A081 		movhi	r1, r1, lsr #16
 3940 22a4 0C005AE1 		cmp	sl, ip
 3941 22a8 0400A033 		movcc	r0, #4
 3942 22ac 40008DE5 		str	r0, [sp, #64]
1358:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3943              		.loc 1 1358 0
 3944 22b0 010042E2 		sub	r0, r2, #1
 3945 22b4 38008DE5 		str	r0, [sp, #56]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3946              		.loc 1 1360 0
 3947 22b8 4CA09DE5 		ldr	sl, [sp, #76]
 3948 22bc 20009DE5 		ldr	r0, [sp, #32]
 3949 22c0 01C062E2 		rsb	ip, r2, #1
 3950 22c4 3CC08DE5 		str	ip, [sp, #60]
 3951 22c8 0A0050E1 		cmp	r0, sl
1367:../uvc.c      **** 						  shutter = shutter+index;
 3952              		.loc 1 1367 0
 3953 22cc 38A09DE5 		ldr	sl, [sp, #56]
 3954 22d0 3C009DE5 		ldr	r0, [sp, #60]
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3955              		.loc 1 1360 0
 3956 22d4 40C09DE5 		ldr	ip, [sp, #64]
 3957 22d8 05C0A033 		movcc	ip, #5
1367:../uvc.c      **** 						  shutter = shutter+index;
 3958              		.loc 1 1367 0
 3959 22dc 010052E3 		cmp	r2, #1
 3960 22e0 0028A091 		movls	r2, r0, asl #16
 3961 22e4 0A28A081 		movhi	r2, sl, asl #16
 3962 22e8 0E0051E1 		cmp	r1, lr
 3963 22ec 01A0A031 		movcc	sl, r1
 3964 22f0 0EA0A021 		movcs	sl, lr
1360:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3965              		.loc 1 1360 0
 3966 22f4 0E0051E1 		cmp	r1, lr
 3967 22f8 0C10A021 		movcs	r1, ip
 3968 22fc 0610A033 		movcc	r1, #6
1367:../uvc.c      **** 						  shutter = shutter+index;
 3969              		.loc 1 1367 0
 3970 2300 22085AE1 		cmp	sl, r2, lsr #16
1370:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3971              		.loc 1 1370 0
 3972 2304 8CA39FE5 		ldr	sl, .L321+24
1367:../uvc.c      **** 						  shutter = shutter+index;
 3973              		.loc 1 1367 0
 3974 2308 0120A091 		movls	r2, r1
 3975 230c 0720A083 		movhi	r2, #7
 3976 2310 012082E2 		add	r2, r2, #1
 3977 2314 FFE002E2 		and	lr, r2, #255
1370:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3978              		.loc 1 1370 0
 3979 2318 0010E0E3 		mvn	r1, #0
 3980 231c 1C009AE5 		ldr	r0, [sl, #28]
1367:../uvc.c      **** 						  shutter = shutter+index;
 3981              		.loc 1 1367 0
 3982 2320 38E08DE5 		str	lr, [sp, #56]
 3983              	.LVL326:
1370:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3984              		.loc 1 1370 0
 3985 2324 2C308DE5 		str	r3, [sp, #44]
 3986 2328 FEFFFFEB 		bl	_txe_mutex_get
1371:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3987              		.loc 1 1371 0
 3988 232c 38C09DE5 		ldr	ip, [sp, #56]
 3989 2330 0310A0E3 		mov	r1, #3
 3990 2334 0B20A0E1 		mov	r2, fp
 3991 2338 2C309DE5 		ldr	r3, [sp, #44]
 3992 233c 00C08DE5 		str	ip, [sp, #0]
 3993 2340 0A00A0E1 		mov	r0, sl
 3994 2344 00C0A0E3 		mov	ip, #0
 3995 2348 04C08DE5 		str	ip, [sp, #4]
 3996 234c FEFFFFEB 		bl	cmdSet
1372:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3997              		.loc 1 1372 0
 3998 2350 1C009AE5 		ldr	r0, [sl, #28]
 3999 2354 FEFFFFEB 		bl	_txe_mutex_put
1375:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4000              		.loc 1 1375 0
 4001 2358 30009DE5 		ldr	r0, [sp, #48]
1376:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4002              		.loc 1 1376 0
 4003 235c 34C09DE5 		ldr	ip, [sp, #52]
1378:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4004              		.loc 1 1378 0
 4005 2360 38309DE5 		ldr	r3, [sp, #56]
1375:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4006              		.loc 1 1375 0
 4007 2364 061089E0 		add	r1, r9, r6
 4008 2368 816188E0 		add	r6, r8, r1, asl #3
1377:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4009              		.loc 1 1377 0
 4010 236c 0120A0E3 		mov	r2, #1
1375:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4011              		.loc 1 1375 0
 4012 2370 DD04C6E5 		strb	r0, [r6, #1245]
1376:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4013              		.loc 1 1376 0
 4014 2374 DEC4C6E5 		strb	ip, [r6, #1246]
1377:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4015              		.loc 1 1377 0
 4016 2378 E024C6E5 		strb	r2, [r6, #1248]
1378:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4017              		.loc 1 1378 0
 4018 237c 0D33C8E5 		strb	r3, [r8, #781]
 4019 2380 3FFFFFEA 		b	.L311
 4020              	.LVL327:
 4021              	.L257:
1305:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4022              		.loc 1 1305 0
 4023 2384 062089E0 		add	r2, r9, r6
 4024 2388 826188E0 		add	r6, r8, r2, asl #3
1306:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4025              		.loc 1 1306 0
 4026 238c 0110A0E3 		mov	r1, #1
1309:../uvc.c      **** 		  		    switch (getData){
 4027              		.loc 1 1309 0
 4028 2390 01E040E2 		sub	lr, r0, #1
1305:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4029              		.loc 1 1305 0
 4030 2394 DD04C6E5 		strb	r0, [r6, #1245]
1306:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4031              		.loc 1 1306 0
 4032 2398 E014C6E5 		strb	r1, [r6, #1248]
 4033              	.LVL328:
1309:../uvc.c      **** 		  		    switch (getData){
 4034              		.loc 1 1309 0
 4035 239c 07005EE3 		cmp	lr, #7
 4036 23a0 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 4037 23a4 970000EA 		b	.L262
 4038              	.L267:
 4039 23a8 9C250000 		.word	.L263
 4040 23ac 00250000 		.word	.L264
 4041 23b0 08260000 		.word	.L262
 4042 23b4 9C240000 		.word	.L265
 4043 23b8 08260000 		.word	.L262
 4044 23bc 08260000 		.word	.L262
 4045 23c0 08260000 		.word	.L262
 4046 23c4 FC230000 		.word	.L266
 4047              	.LVL329:
 4048              	.L256:
1425:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4049              		.loc 1 1425 0
 4050 23c8 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1424:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4051              		.loc 1 1424 0
 4052 23cc 30A09DE5 		ldr	sl, [sp, #48]
 4053 23d0 069089E0 		add	r9, r9, r6
 4054 23d4 89E188E0 		add	lr, r8, r9, asl #3
1425:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4055              		.loc 1 1425 0
 4056 23d8 0620A0E1 		mov	r2, r6
 4057 23dc 0400A0E3 		mov	r0, #4
 4058 23e0 BC129FE5 		ldr	r1, .L321+36
1424:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4059              		.loc 1 1424 0
 4060 23e4 DDA4CEE5 		strb	sl, [lr, #1245]
1425:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4061              		.loc 1 1425 0
 4062 23e8 FEFFFFEB 		bl	CyU3PDebugPrint
1426:../uvc.c      **** 			  		 break;
 4063              		.loc 1 1426 0
 4064 23ec FFC0A0E3 		mov	ip, #255
 4065 23f0 0C60A0E1 		mov	r6, ip
 4066 23f4 0C80A0E1 		mov	r8, ip
 4067 23f8 68FEFFEA 		b	.L247
 4068              	.LVL330:
 4069              	.L266:
1328:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4070              		.loc 1 1328 0
 4071 23fc 94629FE5 		ldr	r6, .L321+24
1326:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4072              		.loc 1 1326 0
 4073 2400 00A0A0E3 		mov	sl, #0
1328:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4074              		.loc 1 1328 0
 4075 2404 1C0096E5 		ldr	r0, [r6, #28]
1326:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4076              		.loc 1 1326 0
 4077 2408 0DA3C8E5 		strb	sl, [r8, #781]
 4078              	.LVL331:
1328:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4079              		.loc 1 1328 0
 4080 240c 0010E0E3 		mvn	r1, #0
 4081 2410 2C308DE5 		str	r3, [sp, #44]
 4082 2414 FEFFFFEB 		bl	_txe_mutex_get
1329:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4083              		.loc 1 1329 0
 4084 2418 0B20A0E1 		mov	r2, fp
 4085 241c 2C309DE5 		ldr	r3, [sp, #44]
 4086 2420 1010A0E3 		mov	r1, #16
 4087 2424 0600A0E1 		mov	r0, r6
 4088 2428 00A08DE5 		str	sl, [sp, #0]
 4089 242c 04A08DE5 		str	sl, [sp, #4]
 4090 2430 FEFFFFEB 		bl	cmdSet
1330:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4091              		.loc 1 1330 0
 4092 2434 1C0096E5 		ldr	r0, [r6, #28]
 4093 2438 FEFFFFEB 		bl	_txe_mutex_put
 4094              	.LVL332:
 4095              	.LBB68:
 4096              	.LBB69:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4097              		.loc 1 566 0
 4098 243c 0010E0E3 		mvn	r1, #0
 4099 2440 1C0096E5 		ldr	r0, [r6, #28]
 4100 2444 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4101              		.loc 1 567 0
 4102 2448 0180A0E3 		mov	r8, #1
 4103 244c 1410A0E3 		mov	r1, #20
 4104 2450 2720A0E3 		mov	r2, #39
 4105 2454 3030A0E3 		mov	r3, #48
 4106 2458 0600A0E1 		mov	r0, r6
 4107 245c 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4108 2460 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4109              		.loc 1 568 0
 4110 2464 02C0A0E3 		mov	ip, #2
 4111 2468 1510A0E3 		mov	r1, #21
 4112 246c 2520A0E3 		mov	r2, #37
 4113 2470 3030A0E3 		mov	r3, #48
 4114 2474 0600A0E1 		mov	r0, r6
 4115 2478 00C08DE5 		str	ip, [sp, #0]
 4116 247c 04A08DE5 		str	sl, [sp, #4]
 4117 2480 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4118              		.loc 1 569 0
 4119 2484 1C0096E5 		ldr	r0, [r6, #28]
 4120 2488 FEFFFFEB 		bl	_txe_mutex_put
 4121              	.LBE69:
 4122              	.LBE68:
1332:../uvc.c      **** 							break;
 4123              		.loc 1 1332 0
 4124 248c FFC0A0E3 		mov	ip, #255
 4125 2490 0C60A0E1 		mov	r6, ip
 4126 2494 0880A0E3 		mov	r8, #8
 4127 2498 40FEFFEA 		b	.L247
 4128              	.LVL333:
 4129              	.L265:
 4130              	.LBB70:
 4131              	.LBB71:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4132              		.loc 1 566 0
 4133 249c F4819FE5 		ldr	r8, .L321+24
 4134 24a0 0010E0E3 		mvn	r1, #0
 4135 24a4 1C0098E5 		ldr	r0, [r8, #28]
 4136 24a8 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4137              		.loc 1 567 0
 4138 24ac 0060A0E3 		mov	r6, #0
 4139 24b0 1410A0E3 		mov	r1, #20
 4140 24b4 2720A0E3 		mov	r2, #39
 4141 24b8 3030A0E3 		mov	r3, #48
 4142 24bc 0800A0E1 		mov	r0, r8
 4143 24c0 00608DE5 		str	r6, [sp, #0]
 4144 24c4 04608DE5 		str	r6, [sp, #4]
 4145 24c8 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4146              		.loc 1 568 0
 4147 24cc 1510A0E3 		mov	r1, #21
 4148 24d0 2520A0E3 		mov	r2, #37
 4149 24d4 3030A0E3 		mov	r3, #48
 4150 24d8 0800A0E1 		mov	r0, r8
 4151 24dc 00608DE5 		str	r6, [sp, #0]
 4152 24e0 04608DE5 		str	r6, [sp, #4]
 4153 24e4 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4154              		.loc 1 569 0
 4155 24e8 1C0098E5 		ldr	r0, [r8, #28]
 4156 24ec FEFFFFEB 		bl	_txe_mutex_put
 4157 24f0 FFC0A0E3 		mov	ip, #255
 4158 24f4 0C60A0E1 		mov	r6, ip
 4159 24f8 0480A0E3 		mov	r8, #4
 4160 24fc 27FEFFEA 		b	.L247
 4161              	.LVL334:
 4162              	.L264:
 4163              	.LBE71:
 4164              	.LBE70:
1316:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4165              		.loc 1 1316 0
 4166 2500 90A19FE5 		ldr	sl, .L321+24
1314:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4167              		.loc 1 1314 0
 4168 2504 0060A0E3 		mov	r6, #0
 4169 2508 0D63C8E5 		strb	r6, [r8, #781]
 4170              	.LVL335:
1316:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4171              		.loc 1 1316 0
 4172 250c 0010E0E3 		mvn	r1, #0
 4173 2510 1C009AE5 		ldr	r0, [sl, #28]
 4174 2514 2C308DE5 		str	r3, [sp, #44]
 4175 2518 FEFFFFEB 		bl	_txe_mutex_get
1317:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4176              		.loc 1 1317 0
 4177 251c 0B20A0E1 		mov	r2, fp
 4178 2520 2C309DE5 		ldr	r3, [sp, #44]
 4179 2524 1010A0E3 		mov	r1, #16
 4180 2528 0A00A0E1 		mov	r0, sl
 4181 252c 00608DE5 		str	r6, [sp, #0]
 4182 2530 04608DE5 		str	r6, [sp, #4]
 4183 2534 FEFFFFEB 		bl	cmdSet
1318:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4184              		.loc 1 1318 0
 4185 2538 1C009AE5 		ldr	r0, [sl, #28]
 4186 253c FEFFFFEB 		bl	_txe_mutex_put
 4187              	.LVL336:
 4188              	.LBB72:
 4189              	.LBB73:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4190              		.loc 1 566 0
 4191 2540 0010E0E3 		mvn	r1, #0
 4192 2544 1C009AE5 		ldr	r0, [sl, #28]
 4193 2548 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4194              		.loc 1 567 0
 4195 254c 1410A0E3 		mov	r1, #20
 4196 2550 2720A0E3 		mov	r2, #39
 4197 2554 3030A0E3 		mov	r3, #48
 4198 2558 0A00A0E1 		mov	r0, sl
 4199 255c 00608DE5 		str	r6, [sp, #0]
 4200 2560 04608DE5 		str	r6, [sp, #4]
 4201 2564 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4202              		.loc 1 568 0
 4203 2568 1510A0E3 		mov	r1, #21
 4204 256c 2520A0E3 		mov	r2, #37
 4205 2570 3030A0E3 		mov	r3, #48
 4206 2574 0A00A0E1 		mov	r0, sl
 4207 2578 00608DE5 		str	r6, [sp, #0]
 4208 257c 04608DE5 		str	r6, [sp, #4]
 4209 2580 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4210              		.loc 1 569 0
 4211 2584 1C009AE5 		ldr	r0, [sl, #28]
 4212 2588 FEFFFFEB 		bl	_txe_mutex_put
 4213 258c FFC0A0E3 		mov	ip, #255
 4214 2590 0C60A0E1 		mov	r6, ip
 4215 2594 0280A0E3 		mov	r8, #2
 4216 2598 00FEFFEA 		b	.L247
 4217              	.LVL337:
 4218              	.L263:
 4219              	.LBE73:
 4220              	.LBE72:
 4221              	.LBB74:
 4222              	.LBB75:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4223              		.loc 1 566 0
 4224 259c F4609FE5 		ldr	r6, .L321+24
 4225 25a0 0010E0E3 		mvn	r1, #0
 4226 25a4 1C0096E5 		ldr	r0, [r6, #28]
 4227 25a8 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4228              		.loc 1 567 0
 4229 25ac 0080A0E3 		mov	r8, #0
 4230 25b0 01A0A0E3 		mov	sl, #1
 4231 25b4 1410A0E3 		mov	r1, #20
 4232 25b8 2720A0E3 		mov	r2, #39
 4233 25bc 3030A0E3 		mov	r3, #48
 4234 25c0 0600A0E1 		mov	r0, r6
 4235 25c4 04808DE5 		str	r8, [sp, #4]
 4236 25c8 00A08DE5 		str	sl, [sp, #0]
 4237 25cc FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4238              		.loc 1 568 0
 4239 25d0 02C0A0E3 		mov	ip, #2
 4240 25d4 1510A0E3 		mov	r1, #21
 4241 25d8 2520A0E3 		mov	r2, #37
 4242 25dc 3030A0E3 		mov	r3, #48
 4243 25e0 0600A0E1 		mov	r0, r6
 4244 25e4 00C08DE5 		str	ip, [sp, #0]
 4245 25e8 04808DE5 		str	r8, [sp, #4]
 4246 25ec FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4247              		.loc 1 569 0
 4248 25f0 1C0096E5 		ldr	r0, [r6, #28]
 4249 25f4 FEFFFFEB 		bl	_txe_mutex_put
 4250              	.LBE75:
 4251              	.LBE74:
1312:../uvc.c      **** 							break;
 4252              		.loc 1 1312 0
 4253 25f8 FFC0A0E3 		mov	ip, #255
 4254 25fc 0C60A0E1 		mov	r6, ip
 4255 2600 0A80A0E1 		mov	r8, sl
 4256 2604 E5FDFFEA 		b	.L247
 4257              	.LVL338:
 4258              	.L262:
1309:../uvc.c      **** 		  		    switch (getData){
 4259              		.loc 1 1309 0
 4260 2608 FFC0A0E3 		mov	ip, #255
 4261 260c 0080A0E1 		mov	r8, r0
 4262 2610 0C60A0E1 		mov	r6, ip
 4263 2614 E1FDFFEA 		b	.L247
 4264              	.LVL339:
 4265              	.L268:
1380:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4266              		.loc 1 1380 0
 4267 2618 0000A0E3 		mov	r0, #0
 4268 261c 0110A0E3 		mov	r1, #1
 4269 2620 0020A0E1 		mov	r2, r0
 4270 2624 FEFFFFEB 		bl	CyU3PUsbStall
 4271              	.LVL340:
 4272 2628 95FEFFEA 		b	.L311
 4273              	.LVL341:
 4274              	.L310:
1398:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4275              		.loc 1 1398 0
 4276 262c 0110A0E3 		mov	r1, #1
 4277 2630 0020A0E1 		mov	r2, r0
 4278 2634 FEFFFFEB 		bl	CyU3PUsbStall
 4279 2638 91FEFFEA 		b	.L311
 4280              	.LVL342:
 4281              	.L320:
1413:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4282              		.loc 1 1413 0
 4283 263c 08E0A0E3 		mov	lr, #8
 4284 2640 00C0A0E3 		mov	ip, #0
 4285 2644 0600A0E1 		mov	r0, r6
 4286 2648 1710A0E3 		mov	r1, #23
 4287 264c 0B20A0E1 		mov	r2, fp
 4288 2650 00E08DE5 		str	lr, [sp, #0]
 4289 2654 04C08DE5 		str	ip, [sp, #4]
 4290 2658 FEFFFFEB 		bl	cmdSet
 4291 265c 5EFEFFEA 		b	.L313
 4292              	.L319:
1411:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4293              		.loc 1 1411 0
 4294 2660 0480A0E3 		mov	r8, #4
 4295 2664 00E0A0E3 		mov	lr, #0
 4296 2668 0600A0E1 		mov	r0, r6
 4297 266c 1710A0E3 		mov	r1, #23
 4298 2670 0B20A0E1 		mov	r2, fp
 4299 2674 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4300 2678 FEFFFFEB 		bl	cmdSet
 4301 267c 56FEFFEA 		b	.L313
 4302              	.L322:
 4303              		.align	2
 4304              	.L321:
 4305 2680 00000000 		.word	bRequest
 4306 2684 00000000 		.word	.LANCHOR1
 4307 2688 00000000 		.word	.LANCHOR0
 4308 268c 78040000 		.word	.LC26
 4309 2690 9C040000 		.word	.LC27
 4310 2694 5C000000 		.word	.LANCHOR0+92
 4311 2698 00000000 		.word	cmdQu
 4312 269c 2C040000 		.word	.LC24
 4313 26a0 FFFF0000 		.word	65535
 4314 26a4 54040000 		.word	.LC25
 4315              		.cfi_endproc
 4316              	.LFE3:
 4318              		.align	2
 4319              		.global	UVCAppEP0Thread_Entry
 4321              	UVCAppEP0Thread_Entry:
 4322              	.LFB24:
3572:../uvc.c      **** {
 4323              		.loc 1 3572 0
 4324              		.cfi_startproc
 4325              		@ args = 0, pretend = 0, frame = 24
 4326              		@ frame_needed = 0, uses_anonymous_args = 0
 4327              	.LVL343:
 4328 26a8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4329              	.LCFI17:
 4330              		.cfi_def_cfa_offset 36
 4331 26ac BC4B9FE5 		ldr	r4, .L494
 4332              		.cfi_offset 14, -4
 4333              		.cfi_offset 11, -8
 4334              		.cfi_offset 10, -12
 4335              		.cfi_offset 9, -16
 4336              		.cfi_offset 8, -20
 4337              		.cfi_offset 7, -24
 4338              		.cfi_offset 6, -28
 4339              		.cfi_offset 5, -32
 4340              		.cfi_offset 4, -36
 4341 26b0 BC6B9FE5 		ldr	r6, .L494+4
 4342 26b4 BC8B9FE5 		ldr	r8, .L494+8
 4343 26b8 BCAB9FE5 		ldr	sl, .L494+12
 4344 26bc BCBB9FE5 		ldr	fp, .L494+16
 4345 26c0 BC7B9FE5 		ldr	r7, .L494+20
 4346 26c4 34D04DE2 		sub	sp, sp, #52
 4347              	.LCFI18:
 4348              		.cfi_def_cfa_offset 88
 4349              	.LVL344:
3594:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4350              		.loc 1 3594 0
 4351 26c8 0450A0E1 		mov	r5, r4
 4352              	.LVL345:
 4353              	.L464:
 4354 26cc 00C0E0E3 		mvn	ip, #0
 4355 26d0 980B9FE5 		ldr	r0, .L494
 4356 26d4 4C10A0E3 		mov	r1, #76
 4357 26d8 0120A0E3 		mov	r2, #1
 4358 26dc 28308DE2 		add	r3, sp, #40
 4359 26e0 00C08DE5 		str	ip, [sp, #0]
 4360 26e4 FEFFFFEB 		bl	_txe_event_flags_get
 4361 26e8 000050E3 		cmp	r0, #0
 4362 26ec 3000001A 		bne	.L324
3598:../uvc.c      ****             if (!isUsbConnected)
 4363              		.loc 1 3598 0
 4364 26f0 303095E5 		ldr	r3, [r5, #48]
 4365 26f4 000053E3 		cmp	r3, #0
 4366 26f8 8C00000A 		beq	.L483
 4367              	.L325:
3607:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4368              		.loc 1 3607 0
 4369 26fc 28309DE5 		ldr	r3, [sp, #40]
 4370 2700 0C0013E3 		tst	r3, #12
 4371 2704 7500001A 		bne	.L484
 4372              	.L326:
3614:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4373              		.loc 1 3614 0
 4374 2708 040013E3 		tst	r3, #4
 4375 270c 1C00000A 		beq	.L327
3616:../uvc.c      ****             	switch ((wIndex >> 8))
 4376              		.loc 1 3616 0
 4377 2710 B0E0DBE1 		ldrh	lr, [fp, #0]
 4378 2714 2E24A0E1 		mov	r2, lr, lsr #8
 4379 2718 030052E3 		cmp	r2, #3
 4380 271c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4381 2720 120000EA 		b	.L328
 4382              	.L333:
 4383 2724 70270000 		.word	.L328
 4384 2728 60280000 		.word	.L330
 4385 272c 34270000 		.word	.L331
 4386 2730 9C280000 		.word	.L332
 4387              	.L331:
 4388              	.LBB90:
 4389              	.LBB94:
2832:../uvc.c      ****     switch (wValue)
 4390              		.loc 1 2832 0
 4391 2734 B020DAE1 		ldrh	r2, [sl, #0]
 4392 2738 060C52E3 		cmp	r2, #1536
 4393 273c 7202000A 		beq	.L339
 4394 2740 D900008A 		bhi	.L345
 4395 2744 030C52E3 		cmp	r2, #768
 4396 2748 6B02000A 		beq	.L337
 4397 274c B101008A 		bhi	.L346
 4398 2750 010C52E3 		cmp	r2, #256
 4399 2754 9A02000A 		beq	.L335
 4400 2758 020C52E3 		cmp	r2, #512
 4401 275c 9402000A 		beq	.L485
 4402              	.L348:
 4403              	.LBE94:
 4404              	.LBE90:
 4405              	.LBB99:
 4406              	.LBB104:
2964:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4407              		.loc 1 2964 0
 4408 2760 201B9FE5 		ldr	r1, .L494+24
 4409 2764 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4410 2768 0400A0E3 		mov	r0, #4
 4411 276c FEFFFFEB 		bl	CyU3PDebugPrint
 4412              	.L328:
 4413              	.LBE104:
 4414              	.LBE99:
3637:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4415              		.loc 1 3637 0
 4416 2770 0000A0E3 		mov	r0, #0
 4417 2774 0110A0E3 		mov	r1, #1
 4418 2778 0020A0E1 		mov	r2, r0
 4419 277c FEFFFFEB 		bl	CyU3PUsbStall
 4420 2780 28309DE5 		ldr	r3, [sp, #40]
 4421              	.L327:
3642:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4422              		.loc 1 3642 0
 4423 2784 080013E3 		tst	r3, #8
 4424 2788 0700000A 		beq	.L391
3646:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4425              		.loc 1 3646 0
 4426 278c B030DBE1 		ldrh	r3, [fp, #0]
 4427 2790 010053E3 		cmp	r3, #1
 4428 2794 6B00000A 		beq	.L392
 4429              	.L393:
 4430              	.LBB110:
 4431              	.LBB114:
3561:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4432              		.loc 1 3561 0
 4433 2798 0000A0E3 		mov	r0, #0
 4434 279c 0110A0E3 		mov	r1, #1
 4435 27a0 0020A0E1 		mov	r2, r0
 4436 27a4 FEFFFFEB 		bl	CyU3PUsbStall
 4437              	.L473:
 4438 27a8 28309DE5 		ldr	r3, [sp, #40]
 4439              	.L391:
 4440              	.LBE114:
 4441              	.LBE110:
3657:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4442              		.loc 1 3657 0
 4443 27ac 400013E3 		tst	r3, #64
 4444 27b0 0100001A 		bne	.L486
 4445              	.L324:
3870:../uvc.c      ****         CyU3PThreadRelinquish ();
 4446              		.loc 1 3870 0
 4447 27b4 FEFFFFEB 		bl	_txe_thread_relinquish
3871:../uvc.c      ****     }
 4448              		.loc 1 3871 0
 4449 27b8 C3FFFFEA 		b	.L464
 4450              	.L486:
3662:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4451              		.loc 1 3662 0
 4452 27bc 1800A0E3 		mov	r0, #24
 4453 27c0 24108DE2 		add	r1, sp, #36
 4454 27c4 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3719:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4455              		.loc 1 3719 0
 4456 27c8 BB36D6E5 		ldrb	r3, [r6, #1723]	@ zero_extendqisi2
 4457 27cc 0F0053E3 		cmp	r3, #15
 4458 27d0 9400000A 		beq	.L487
3746:../uvc.c      **** 				}else if(!snapButFlag){
 4459              		.loc 1 3746 0
 4460 27d4 000053E3 		cmp	r3, #0
 4461 27d8 F5FFFF1A 		bne	.L324
3748:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4462              		.loc 1 3748 0
 4463 27dc 002097E5 		ldr	r2, [r7, #0]
 4464 27e0 0290A0E3 		mov	r9, #2
 4465 27e4 0090C2E5 		strb	r9, [r2, #0]
3749:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4466              		.loc 1 3749 0
 4467 27e8 001097E5 		ldr	r1, [r7, #0]
 4468 27ec 0190A0E3 		mov	r9, #1
 4469 27f0 0190C1E5 		strb	r9, [r1, #1]
3750:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4470              		.loc 1 3750 0
 4471 27f4 000097E5 		ldr	r0, [r7, #0]
3754:../uvc.c      **** 					interStabuf.size   = 1024;
 4472              		.loc 1 3754 0
 4473 27f8 01CBA0E3 		mov	ip, #1024	@ movhi
3750:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4474              		.loc 1 3750 0
 4475 27fc 0230C0E5 		strb	r3, [r0, #2]
3751:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4476              		.loc 1 3751 0
 4477 2800 00E097E5 		ldr	lr, [r7, #0]
3760:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4478              		.loc 1 3760 0
 4479 2804 0010E0E3 		mvn	r1, #0
3751:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4480              		.loc 1 3751 0
 4481 2808 0390CEE5 		strb	r9, [lr, #3]
3753:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4482              		.loc 1 3753 0
 4483 280c 002097E5 		ldr	r2, [r7, #0]
3757:../uvc.c      **** 					interStabuf.count = 4;
 4484              		.loc 1 3757 0
 4485 2810 04E0A0E3 		mov	lr, #4	@ movhi
3760:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4486              		.loc 1 3760 0
 4487 2814 700A9FE5 		ldr	r0, .L494+28
3753:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4488              		.loc 1 3753 0
 4489 2818 18208DE5 		str	r2, [sp, #24]
3754:../uvc.c      **** 					interStabuf.size   = 1024;
 4490              		.loc 1 3754 0
 4491 281c BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3755:../uvc.c      **** 					interStabuf.status = 0;
 4492              		.loc 1 3755 0
 4493 2820 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3757:../uvc.c      **** 					interStabuf.count = 4;
 4494              		.loc 1 3757 0
 4495 2824 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3760:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4496              		.loc 1 3760 0
 4497 2828 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3763:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4498              		.loc 1 3763 0
 4499 282c 580A9FE5 		ldr	r0, .L494+28
 4500 2830 18108DE2 		add	r1, sp, #24
 4501 2834 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4502              	.LVL346:
3765:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4503              		.loc 1 3765 0
 4504 2838 002050E2 		subs	r2, r0, #0
 4505 283c 6C01001A 		bne	.L488
3771:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4506              		.loc 1 3771 0
 4507 2840 3010A0E3 		mov	r1, #48
 4508 2844 0920A0E1 		mov	r2, r9
 4509 2848 0500A0E3 		mov	r0, #5
 4510              	.LVL347:
 4511 284c FEFFFFEB 		bl	SensorSetControl
3772:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4512              		.loc 1 3772 0
 4513 2850 1C3A9FE5 		ldr	r3, .L494+4
 4514 2854 BB96C3E5 		strb	r9, [r3, #1723]
3870:../uvc.c      ****         CyU3PThreadRelinquish ();
 4515              		.loc 1 3870 0
 4516 2858 FEFFFFEB 		bl	_txe_thread_relinquish
 4517 285c 9AFFFFEA 		b	.L464
 4518              	.L330:
 4519              	.LBB118:
 4520              	.LBB105:
2907:../uvc.c      ****     switch (wValue)
 4521              		.loc 1 2907 0
 4522 2860 B020DAE1 		ldrh	r2, [sl, #0]
 4523 2864 060C52E3 		cmp	r2, #1536
 4524 2868 4D02000A 		beq	.L354
 4525 286c 9900008A 		bhi	.L360
 4526 2870 030C52E3 		cmp	r2, #768
 4527 2874 4602000A 		beq	.L351
 4528 2878 9201008A 		bhi	.L361
 4529 287c 010C52E3 		cmp	r2, #256
 4530 2880 2D02000A 		beq	.L349
 4531 2884 020C52E3 		cmp	r2, #512
 4532 2888 B4FFFF1A 		bne	.L348
 4533              	.LVL348:
2915:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4534              		.loc 1 2915 0
 4535 288c 0100A0E3 		mov	r0, #1
 4536 2890 FEFFFFEB 		bl	CTControlHandle
 4537              	.LVL349:
 4538 2894 28309DE5 		ldr	r3, [sp, #40]
 4539 2898 B9FFFFEA 		b	.L327
 4540              	.L332:
 4541              	.LBE105:
 4542              	.LBE118:
 4543              	.LBB119:
 4544              	.LBB125:
3132:../uvc.c      ****     switch (wValue)
 4545              		.loc 1 3132 0
 4546 289c B030DAE1 		ldrh	r3, [sl, #0]
 4547 28a0 090C53E3 		cmp	r3, #2304
 4548 28a4 2002000A 		beq	.L375
 4549 28a8 9200008A 		bhi	.L385
 4550 28ac 010B53E3 		cmp	r3, #1024
 4551 28b0 1902000A 		beq	.L370
 4552 28b4 6801008A 		bhi	.L386
 4553 28b8 020C53E3 		cmp	r3, #512
 4554 28bc FE01000A 		beq	.L368
 4555 28c0 030C53E3 		cmp	r3, #768
 4556 28c4 F801000A 		beq	.L369
 4557 28c8 010C53E3 		cmp	r3, #256
 4558 28cc A7FFFF1A 		bne	.L328
 4559              	.LVL350:
3136:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4560              		.loc 1 3136 0
 4561 28d0 1000A0E3 		mov	r0, #16
 4562 28d4 FEFFFFEB 		bl	ControlHandle
 4563              	.LVL351:
 4564 28d8 28309DE5 		ldr	r3, [sp, #40]
 4565 28dc A8FFFFEA 		b	.L327
 4566              	.L484:
 4567              	.LBE125:
 4568              	.LBE119:
3608:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4569              		.loc 1 3608 0
 4570 28e0 B0C0DAE1 		ldrh	ip, [sl, #0]
 4571 28e4 A4999FE5 		ldr	r9, .L494+32
 4572 28e8 A4199FE5 		ldr	r1, .L494+36
 4573 28ec 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4574 28f0 08C08DE5 		str	ip, [sp, #8]
 4575 28f4 B000DBE1 		ldrh	r0, [fp, #0]
 4576 28f8 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4577 28fc 0C008DE5 		str	r0, [sp, #12]
 4578 2900 B0C0D1E1 		ldrh	ip, [r1, #0]
 4579 2904 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4580 2908 04908DE5 		str	r9, [sp, #4]
 4581 290c 0400A0E3 		mov	r0, #4
 4582 2910 80199FE5 		ldr	r1, .L494+40
 4583 2914 0090A0E3 		mov	r9, #0
 4584 2918 00E08DE5 		str	lr, [sp, #0]
 4585 291c 10C08DE5 		str	ip, [sp, #16]
 4586 2920 14908DE5 		str	r9, [sp, #20]
 4587 2924 FEFFFFEB 		bl	CyU3PDebugPrint
 4588 2928 28309DE5 		ldr	r3, [sp, #40]
 4589 292c 75FFFFEA 		b	.L326
 4590              	.L483:
3600:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4591              		.loc 1 3600 0
 4592 2930 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3601:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4593              		.loc 1 3601 0
 4594 2934 000050E3 		cmp	r0, #0
3600:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4595              		.loc 1 3600 0
 4596 2938 4800C5E5 		strb	r0, [r5, #72]
3603:../uvc.c      ****                     isUsbConnected = CyTrue;
 4597              		.loc 1 3603 0
 4598 293c 0100A013 		movne	r0, #1
 4599 2940 30008515 		strne	r0, [r5, #48]
 4600 2944 6CFFFFEA 		b	.L325
 4601              	.L392:
 4602              	.LVL352:
 4603              	.LBB131:
 4604              	.LBB113:
3233:../uvc.c      ****     switch (wValue)
 4605              		.loc 1 3233 0
 4606 2948 B020DAE1 		ldrh	r2, [sl, #0]
 4607 294c 030C52E3 		cmp	r2, #768
 4608 2950 DE00000A 		beq	.L396
 4609 2954 0F00008A 		bhi	.L399
 4610 2958 010C52E3 		cmp	r2, #256
 4611 295c 9700000A 		beq	.L394
 4612 2960 020C52E3 		cmp	r2, #512
 4613 2964 8BFFFF1A 		bne	.L393
3298:../uvc.c      ****             switch (bRequest)
 4614              		.loc 1 3298 0
 4615 2968 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4616 296c 810053E3 		cmp	r3, #129
 4617 2970 C001000A 		beq	.L451
 4618 2974 E200008A 		bhi	.L414
 4619 2978 010053E3 		cmp	r3, #1
 4620 297c 8201000A 		beq	.L489
 4621              	.L434:
3499:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4622              		.loc 1 3499 0
 4623 2980 0000A0E3 		mov	r0, #0
 4624 2984 0110A0E3 		mov	r1, #1
 4625 2988 0020A0E1 		mov	r2, r0
 4626 298c FEFFFFEB 		bl	CyU3PUsbStall
 4627 2990 28309DE5 		ldr	r3, [sp, #40]
 4628 2994 84FFFFEA 		b	.L391
 4629              	.L399:
3233:../uvc.c      ****     switch (wValue)
 4630              		.loc 1 3233 0
 4631 2998 010B52E3 		cmp	r2, #1024
 4632 299c 6100000A 		beq	.L397
 4633 29a0 050C52E3 		cmp	r2, #1280
 4634 29a4 7BFFFF1A 		bne	.L393
3506:../uvc.c      ****             	switch (bRequest)
 4635              		.loc 1 3506 0
 4636 29a8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4637 29ac 810052E3 		cmp	r2, #129
 4638 29b0 B001000A 		beq	.L451
 4639 29b4 5501008A 		bhi	.L454
 4640 29b8 010052E3 		cmp	r2, #1
 4641 29bc 75FFFF1A 		bne	.L393
3531:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4642              		.loc 1 3531 0
 4643 29c0 2000A0E3 		mov	r0, #32
 4644 29c4 D0189FE5 		ldr	r1, .L494+44
 4645 29c8 2E208DE2 		add	r2, sp, #46
 4646 29cc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4647              	.LVL353:
3533:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4648              		.loc 1 3533 0
 4649 29d0 000050E3 		cmp	r0, #0
 4650 29d4 6601001A 		bne	.L456
3537:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4651              		.loc 1 3537 0
 4652 29d8 0020A0E3 		mov	r2, #0
 4653 29dc 8C089FE5 		ldr	r0, .L494
 4654              	.LVL354:
 4655 29e0 8010A0E3 		mov	r1, #128
 4656 29e4 FEFFFFEB 		bl	_txe_event_flags_set
 4657              	.LVL355:
3538:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4658              		.loc 1 3538 0
 4659 29e8 002050E2 		subs	r2, r0, #0
3544:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4660              		.loc 1 3544 0
 4661 29ec 0F00E003 		mvneq	r0, #15
 4662              	.LVL356:
 4663 29f0 3A00C505 		streqb	r0, [r5, #58]
3538:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4664              		.loc 1 3538 0
 4665 29f4 0200000A 		beq	.L458
3540:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4666              		.loc 1 3540 0
 4667 29f8 A0189FE5 		ldr	r1, .L494+48
 4668 29fc 0400A0E3 		mov	r0, #4
 4669 2a00 FEFFFFEB 		bl	CyU3PDebugPrint
 4670              	.LVL357:
 4671              	.L458:
3547:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 4672              		.loc 1 3547 0
 4673 2a04 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 4674 2a08 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4675 2a0c BE22DDE1 		ldrh	r2, [sp, #46]
 4676              	.LVL358:
 4677 2a10 0400A0E3 		mov	r0, #4
 4678 2a14 88189FE5 		ldr	r1, .L494+52
 4679 2a18 00C08DE5 		str	ip, [sp, #0]
 4680 2a1c FEFFFFEB 		bl	CyU3PDebugPrint
 4681 2a20 28309DE5 		ldr	r3, [sp, #40]
 4682 2a24 60FFFFEA 		b	.L391
 4683              	.LVL359:
 4684              	.L487:
 4685              	.LBE113:
 4686              	.LBE131:
3721:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4687              		.loc 1 3721 0
 4688 2a28 003097E5 		ldr	r3, [r7, #0]
 4689 2a2c 0290A0E3 		mov	r9, #2
 4690 2a30 0090C3E5 		strb	r9, [r3, #0]
3722:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4691              		.loc 1 3722 0
 4692 2a34 002097E5 		ldr	r2, [r7, #0]
 4693 2a38 0190A0E3 		mov	r9, #1
 4694 2a3c 0190C2E5 		strb	r9, [r2, #1]
3723:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4695              		.loc 1 3723 0
 4696 2a40 001097E5 		ldr	r1, [r7, #0]
 4697 2a44 0030A0E3 		mov	r3, #0
 4698 2a48 0230C1E5 		strb	r3, [r1, #2]
3724:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4699              		.loc 1 3724 0
 4700 2a4c 000097E5 		ldr	r0, [r7, #0]
3730:../uvc.c      **** 					interStabuf.count = 4;
 4701              		.loc 1 3730 0
 4702 2a50 0420A0E3 		mov	r2, #4	@ movhi
3724:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4703              		.loc 1 3724 0
 4704 2a54 0330C0E5 		strb	r3, [r0, #3]
3726:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4705              		.loc 1 3726 0
 4706 2a58 00C097E5 		ldr	ip, [r7, #0]
3727:../uvc.c      **** 					interStabuf.size   = 1024;
 4707              		.loc 1 3727 0
 4708 2a5c 01EBA0E3 		mov	lr, #1024	@ movhi
3733:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4709              		.loc 1 3733 0
 4710 2a60 0010E0E3 		mvn	r1, #0
 4711 2a64 20089FE5 		ldr	r0, .L494+28
3730:../uvc.c      **** 					interStabuf.count = 4;
 4712              		.loc 1 3730 0
 4713 2a68 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3726:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4714              		.loc 1 3726 0
 4715 2a6c 18C08DE5 		str	ip, [sp, #24]
3727:../uvc.c      **** 					interStabuf.size   = 1024;
 4716              		.loc 1 3727 0
 4717 2a70 BEE1CDE1 		strh	lr, [sp, #30]	@ movhi
3728:../uvc.c      **** 					interStabuf.status = 0;
 4718              		.loc 1 3728 0
 4719 2a74 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3733:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4720              		.loc 1 3733 0
 4721 2a78 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3736:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4722              		.loc 1 3736 0
 4723 2a7c 08089FE5 		ldr	r0, .L494+28
 4724 2a80 18108DE2 		add	r1, sp, #24
 4725 2a84 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4726              	.LVL360:
3738:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4727              		.loc 1 3738 0
 4728 2a88 002050E2 		subs	r2, r0, #0
 4729 2a8c E900001A 		bne	.L490
3743:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 4730              		.loc 1 3743 0
 4731 2a90 3010A0E3 		mov	r1, #48
 4732 2a94 0500A0E3 		mov	r0, #5
 4733              	.LVL361:
 4734 2a98 FEFFFFEB 		bl	SensorSetControl
 4735              	.LVL362:
3745:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 4736              		.loc 1 3745 0
 4737 2a9c D0C79FE5 		ldr	ip, .L494+4
 4738 2aa0 BB96CCE5 		strb	r9, [ip, #1723]
3870:../uvc.c      ****         CyU3PThreadRelinquish ();
 4739              		.loc 1 3870 0
 4740 2aa4 FEFFFFEB 		bl	_txe_thread_relinquish
 4741 2aa8 07FFFFEA 		b	.L464
 4742              	.L345:
 4743              	.LBB132:
 4744              	.LBB95:
2832:../uvc.c      ****     switch (wValue)
 4745              		.loc 1 2832 0
 4746 2aac 0A0C52E3 		cmp	r2, #2560
 4747 2ab0 2B01000A 		beq	.L342
 4748 2ab4 0B01008A 		bhi	.L347
 4749 2ab8 070C52E3 		cmp	r2, #1792
 4750 2abc 2401000A 		beq	.L340
 4751 2ac0 020B52E3 		cmp	r2, #2048
 4752 2ac4 25FFFF1A 		bne	.L348
 4753              	.LVL363:
2863:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4754              		.loc 1 2863 0
 4755 2ac8 0700A0E3 		mov	r0, #7
 4756 2acc FEFFFFEB 		bl	ControlHandle
 4757              	.LVL364:
 4758 2ad0 28309DE5 		ldr	r3, [sp, #40]
 4759 2ad4 2AFFFFEA 		b	.L327
 4760              	.L360:
 4761              	.LBE95:
 4762              	.LBE132:
 4763              	.LBB133:
 4764              	.LBB103:
2907:../uvc.c      ****     switch (wValue)
 4765              		.loc 1 2907 0
 4766 2ad8 090C52E3 		cmp	r2, #2304
 4767 2adc 8201000A 		beq	.L356
 4768 2ae0 E600008A 		bhi	.L362
 4769 2ae4 070C52E3 		cmp	r2, #1792
 4770 2ae8 7B01000A 		beq	.L355
 4771 2aec 020B52E3 		cmp	r2, #2048
 4772 2af0 1AFFFF1A 		bne	.L348
 4773 2af4 22FFFFEA 		b	.L327
 4774              	.L385:
 4775              	.LBE103:
 4776              	.LBE133:
 4777              	.LBB134:
 4778              	.LBB124:
3132:../uvc.c      ****     switch (wValue)
 4779              		.loc 1 3132 0
 4780 2af8 0F0C53E3 		cmp	r3, #3840
 4781 2afc 7201000A 		beq	.L380
 4782 2b00 B200008A 		bhi	.L388
 4783 2b04 0B0C53E3 		cmp	r3, #2816
 4784 2b08 0D01000A 		beq	.L377
 4785 2b0c A700008A 		bhi	.L389
 4786 2b10 0A0C53E3 		cmp	r3, #2560
 4787 2b14 15FFFF1A 		bne	.L328
 4788              	.LVL365:
3173:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4789              		.loc 1 3173 0
 4790 2b18 1900A0E3 		mov	r0, #25
 4791 2b1c FEFFFFEB 		bl	ControlHandle
 4792              	.LVL366:
 4793 2b20 28309DE5 		ldr	r3, [sp, #40]
 4794 2b24 16FFFFEA 		b	.L327
 4795              	.LVL367:
 4796              	.L397:
 4797              	.LBE124:
 4798              	.LBE134:
 4799              	.LBB135:
 4800              	.LBB115:
3425:../uvc.c      ****                 switch (bRequest)
 4801              		.loc 1 3425 0
 4802 2b28 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4803 2b2c 810052E3 		cmp	r2, #129
 4804 2b30 6B00000A 		beq	.L436
 4805 2b34 3200008A 		bhi	.L439
 4806 2b38 010052E3 		cmp	r2, #1
 4807 2b3c 8FFFFF1A 		bne	.L434
3450:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4808              		.loc 1 3450 0
 4809 2b40 2000A0E3 		mov	r0, #32
 4810 2b44 50179FE5 		ldr	r1, .L494+44
 4811 2b48 2E208DE2 		add	r2, sp, #46
 4812 2b4c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4813              	.LVL368:
3452:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4814              		.loc 1 3452 0
 4815 2b50 000050E3 		cmp	r0, #0
 4816 2b54 13FFFF1A 		bne	.L473
3471:../uvc.c      ****                            switch (glCommitCtrl[1])
 4817              		.loc 1 3471 0
 4818 2b58 8100D5E5 		ldrb	r0, [r5, #129]	@ zero_extendqisi2
 4819              	.LVL369:
 4820 2b5c 020050E3 		cmp	r0, #2
 4821 2b60 8201000A 		beq	.L444
 4822 2b64 030050E3 		cmp	r0, #3
 4823 2b68 7701000A 		beq	.L445
 4824 2b6c 010050E3 		cmp	r0, #1
 4825 2b70 0800001A 		bne	.L442
3484:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 4826              		.loc 1 3484 0
 4827 2b74 58C094E5 		ldr	ip, [r4, #88]
 4828 2b78 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 4829 2b7c 00005CE3 		cmp	ip, #0
 4830 2b80 C4C0A003 		moveq	ip, #196
 4831 2b84 44C0A013 		movne	ip, #68
 4832 2b88 03208CE1 		orr	r2, ip, r3
 4833 2b8c 3010A0E3 		mov	r1, #48
 4834 2b90 5230A0E3 		mov	r3, #82
 4835 2b94 FEFFFFEB 		bl	SensorSetIrisControl
 4836              	.L442:
3491:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4837              		.loc 1 3491 0
 4838 2b98 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3493:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4839              		.loc 1 3493 0
 4840 2b9c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 4841 2ba0 BE22DDE1 		ldrh	r2, [sp, #46]
 4842              	.LVL370:
 4843 2ba4 0400A0E3 		mov	r0, #4
 4844 2ba8 F8169FE5 		ldr	r1, .L494+56
3491:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 4845              		.loc 1 3491 0
 4846 2bac A0E0C4E5 		strb	lr, [r4, #160]
3493:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 4847              		.loc 1 3493 0
 4848 2bb0 00E08DE5 		str	lr, [sp, #0]
 4849 2bb4 FEFFFFEB 		bl	CyU3PDebugPrint
 4850 2bb8 28309DE5 		ldr	r3, [sp, #40]
 4851 2bbc FAFEFFEA 		b	.L391
 4852              	.LVL371:
 4853              	.L394:
3236:../uvc.c      ****             switch (bRequest)
 4854              		.loc 1 3236 0
 4855 2bc0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4856 2bc4 830052E3 		cmp	r2, #131
 4857 2bc8 3100008A 		bhi	.L405
 4858 2bcc 810052E3 		cmp	r2, #129
 4859 2bd0 1600003A 		bcc	.L491
 4860              	.L402:
3251:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4861              		.loc 1 3251 0
 4862 2bd4 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4863 2bd8 030053E3 		cmp	r3, #3
 4864 2bdc 2801001A 		bne	.L455
3253:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 4865              		.loc 1 3253 0
 4866 2be0 C4169FE5 		ldr	r1, .L494+60
 4867 2be4 1A00A0E3 		mov	r0, #26
 4868 2be8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3254:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 4869              		.loc 1 3254 0
 4870 2bec 0400A0E3 		mov	r0, #4
 4871 2bf0 B8169FE5 		ldr	r1, .L494+64
 4872 2bf4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4873 2bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 4874 2bfc 28309DE5 		ldr	r3, [sp, #40]
 4875 2c00 E9FEFFEA 		b	.L391
 4876              	.L439:
3425:../uvc.c      ****                 switch (bRequest)
 4877              		.loc 1 3425 0
 4878 2c04 850052E3 		cmp	r2, #133
 4879 2c08 2700000A 		beq	.L437
 4880 2c0c 860052E3 		cmp	r2, #134
 4881 2c10 5AFFFF1A 		bne	.L434
 4882              	.L477:
3429:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4883              		.loc 1 3429 0
 4884 2c14 0300A0E1 		mov	r0, r3
 4885              	.L472:
3302:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4886              		.loc 1 3302 0
 4887 2c18 94169FE5 		ldr	r1, .L494+68
3301:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4888              		.loc 1 3301 0
 4889 2c1c 0390A0E3 		mov	r9, #3
 4890 2c20 5C90C4E5 		strb	r9, [r4, #92]
3302:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4891              		.loc 1 3302 0
 4892 2c24 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4893 2c28 28309DE5 		ldr	r3, [sp, #40]
 4894 2c2c DEFEFFEA 		b	.L391
 4895              	.L491:
3236:../uvc.c      ****             switch (bRequest)
 4896              		.loc 1 3236 0
 4897 2c30 010052E3 		cmp	r2, #1
 4898 2c34 51FFFF1A 		bne	.L434
3263:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4899              		.loc 1 3263 0
 4900 2c38 2000A0E3 		mov	r0, #32
 4901 2c3c 58169FE5 		ldr	r1, .L494+44
 4902 2c40 2E208DE2 		add	r2, sp, #46
 4903 2c44 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4904              	.LVL372:
3265:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4905              		.loc 1 3265 0
 4906 2c48 000050E3 		cmp	r0, #0
 4907 2c4c D5FEFF1A 		bne	.L473
3267:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4908              		.loc 1 3267 0
 4909 2c50 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4910 2c54 030051E3 		cmp	r1, #3
 4911 2c58 D2FEFF1A 		bne	.L473
3274:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4912              		.loc 1 3274 0
 4913 2c5c 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3271:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4914              		.loc 1 3271 0
 4915 2c60 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3272:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4916              		.loc 1 3272 0
 4917 2c64 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3273:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4918              		.loc 1 3273 0
 4919 2c68 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 4920              	.LVL373:
3275:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4921              		.loc 1 3275 0
 4922 2c6c 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3276:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4923              		.loc 1 3276 0
 4924 2c70 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3274:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4925              		.loc 1 3274 0
 4926 2c74 5536C6E5 		strb	r3, [r6, #1621]
3271:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4927              		.loc 1 3271 0
 4928 2c78 52E6C6E5 		strb	lr, [r6, #1618]
3272:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4929              		.loc 1 3272 0
 4930 2c7c 53C6C6E5 		strb	ip, [r6, #1619]
3273:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4931              		.loc 1 3273 0
 4932 2c80 5406C6E5 		strb	r0, [r6, #1620]
3275:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4933              		.loc 1 3275 0
 4934 2c84 5626C6E5 		strb	r2, [r6, #1622]
3276:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4935              		.loc 1 3276 0
 4936 2c88 5796C6E5 		strb	r9, [r6, #1623]
 4937 2c8c 28309DE5 		ldr	r3, [sp, #40]
 4938 2c90 C5FEFFEA 		b	.L391
 4939              	.LVL374:
 4940              	.L405:
3236:../uvc.c      ****             switch (bRequest)
 4941              		.loc 1 3236 0
 4942 2c94 860052E3 		cmp	r2, #134
 4943 2c98 DDFFFF0A 		beq	.L477
 4944 2c9c 870052E3 		cmp	r2, #135
 4945 2ca0 CBFFFF0A 		beq	.L402
 4946              	.L482:
3375:../uvc.c      ****                 switch (bRequest)
 4947              		.loc 1 3375 0
 4948 2ca4 850052E3 		cmp	r2, #133
 4949 2ca8 34FFFF1A 		bne	.L434
 4950              	.L437:
3434:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4951              		.loc 1 3434 0
 4952 2cac 00169FE5 		ldr	r1, .L494+68
 4953 2cb0 0200A0E3 		mov	r0, #2
3432:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4954              		.loc 1 3432 0
 4955 2cb4 1A30A0E3 		mov	r3, #26
 4956              	.L474:
3514:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4957              		.loc 1 3514 0
 4958 2cb8 0090A0E3 		mov	r9, #0
3513:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4959              		.loc 1 3513 0
 4960 2cbc 5C30C4E5 		strb	r3, [r4, #92]
3514:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4961              		.loc 1 3514 0
 4962 2cc0 5D90C4E5 		strb	r9, [r4, #93]
3515:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4963              		.loc 1 3515 0
 4964 2cc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4965 2cc8 28309DE5 		ldr	r3, [sp, #40]
 4966 2ccc B6FEFFEA 		b	.L391
 4967              	.L396:
3375:../uvc.c      ****                 switch (bRequest)
 4968              		.loc 1 3375 0
 4969 2cd0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4970 2cd4 830052E3 		cmp	r2, #131
 4971 2cd8 2F00008A 		bhi	.L430
 4972 2cdc 810052E3 		cmp	r2, #129
 4973 2ce0 0D00003A 		bcc	.L492
 4974              	.L436:
3437:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4975              		.loc 1 3437 0
 4976 2ce4 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3439:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4977              		.loc 1 3439 0
 4978 2ce8 0B00A0E3 		mov	r0, #11
3437:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4979              		.loc 1 3437 0
 4980 2cec 030052E3 		cmp	r2, #3
3439:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4981              		.loc 1 3439 0
 4982 2cf0 C0159F05 		ldreq	r1, .L494+72
3443:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4983              		.loc 1 3443 0
 4984 2cf4 C0159F15 		ldrne	r1, .L494+76
 4985 2cf8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4986 2cfc 28309DE5 		ldr	r3, [sp, #40]
 4987 2d00 A9FEFFEA 		b	.L391
 4988              	.L414:
3298:../uvc.c      ****             switch (bRequest)
 4989              		.loc 1 3298 0
 4990 2d04 850053E3 		cmp	r3, #133
 4991 2d08 E7FFFF0A 		beq	.L437
 4992 2d0c 860053E3 		cmp	r3, #134
 4993 2d10 1AFFFF1A 		bne	.L434
 4994              	.L478:
3302:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4995              		.loc 1 3302 0
 4996 2d14 0100A0E3 		mov	r0, #1
 4997 2d18 BEFFFFEA 		b	.L472
 4998              	.L492:
3375:../uvc.c      ****                 switch (bRequest)
 4999              		.loc 1 3375 0
 5000 2d1c 010052E3 		cmp	r2, #1
 5001 2d20 16FFFF1A 		bne	.L434
3400:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5002              		.loc 1 3400 0
 5003 2d24 2000A0E3 		mov	r0, #32
 5004 2d28 6C159FE5 		ldr	r1, .L494+44
 5005 2d2c 2E208DE2 		add	r2, sp, #46
 5006 2d30 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5007              	.LVL375:
3402:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5008              		.loc 1 3402 0
 5009 2d34 000050E3 		cmp	r0, #0
 5010 2d38 9AFEFF1A 		bne	.L473
3404:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5011              		.loc 1 3404 0
 5012 2d3c 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 5013 2d40 030051E3 		cmp	r1, #3
 5014 2d44 0B00001A 		bne	.L433
3408:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5015              		.loc 1 3408 0
 5016 2d48 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3409:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5017              		.loc 1 3409 0
 5018 2d4c 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3410:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5019              		.loc 1 3410 0
 5020 2d50 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 5021              	.LVL376:
3411:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5022              		.loc 1 3411 0
 5023 2d54 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3412:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5024              		.loc 1 3412 0
 5025 2d58 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3413:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5026              		.loc 1 3413 0
 5027 2d5c 8690D5E5 		ldrb	r9, [r5, #134]	@ zero_extendqisi2
3408:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5028              		.loc 1 3408 0
 5029 2d60 A5E6C6E5 		strb	lr, [r6, #1701]
3409:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5030              		.loc 1 3409 0
 5031 2d64 A6C6C6E5 		strb	ip, [r6, #1702]
3410:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5032              		.loc 1 3410 0
 5033 2d68 A706C6E5 		strb	r0, [r6, #1703]
3411:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5034              		.loc 1 3411 0
 5035 2d6c A836C6E5 		strb	r3, [r6, #1704]
3412:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5036              		.loc 1 3412 0
 5037 2d70 A926C6E5 		strb	r2, [r6, #1705]
3413:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5038              		.loc 1 3413 0
 5039 2d74 AA96C6E5 		strb	r9, [r6, #1706]
 5040              	.L433:
3415:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 5041              		.loc 1 3415 0
 5042 2d78 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 5043 2d7c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5044 2d80 BE22DDE1 		ldrh	r2, [sp, #46]
 5045              	.LVL377:
 5046 2d84 0400A0E3 		mov	r0, #4
 5047 2d88 30159FE5 		ldr	r1, .L494+80
 5048 2d8c 00908DE5 		str	r9, [sp, #0]
 5049 2d90 FEFFFFEB 		bl	CyU3PDebugPrint
 5050 2d94 28309DE5 		ldr	r3, [sp, #40]
 5051 2d98 83FEFFEA 		b	.L391
 5052              	.LVL378:
 5053              	.L430:
3375:../uvc.c      ****                 switch (bRequest)
 5054              		.loc 1 3375 0
 5055 2d9c 860052E3 		cmp	r2, #134
 5056 2da0 9BFFFF0A 		beq	.L477
 5057 2da4 870052E3 		cmp	r2, #135
 5058 2da8 BDFFFF1A 		bne	.L482
 5059 2dac CCFFFFEA 		b	.L436
 5060              	.LVL379:
 5061              	.L389:
 5062              	.LBE115:
 5063              	.LBE135:
 5064              	.LBB136:
 5065              	.LBB126:
3132:../uvc.c      ****     switch (wValue)
 5066              		.loc 1 3132 0
 5067 2db0 030B53E3 		cmp	r3, #3072
 5068 2db4 2901000A 		beq	.L378
 5069 2db8 0D0C53E3 		cmp	r3, #3328
 5070 2dbc 6BFEFF1A 		bne	.L328
 5071              	.LVL380:
3189:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5072              		.loc 1 3189 0
 5073 2dc0 1C00A0E3 		mov	r0, #28
 5074 2dc4 FEFFFFEB 		bl	ControlHandle
 5075              	.LVL381:
 5076 2dc8 28309DE5 		ldr	r3, [sp, #40]
 5077 2dcc 6CFEFFEA 		b	.L327
 5078              	.L388:
3132:../uvc.c      ****     switch (wValue)
 5079              		.loc 1 3132 0
 5080 2dd0 110C53E3 		cmp	r3, #4352
 5081 2dd4 1D01000A 		beq	.L382
 5082 2dd8 5100008A 		bhi	.L390
 5083 2ddc 010A53E3 		cmp	r3, #4096
 5084 2de0 62FEFF1A 		bne	.L328
 5085              	.LVL382:
3201:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 5086              		.loc 1 3201 0
 5087 2de4 1F00A0E3 		mov	r0, #31
 5088 2de8 FEFFFFEB 		bl	ControlHandle
 5089              	.LVL383:
 5090 2dec 28309DE5 		ldr	r3, [sp, #40]
 5091 2df0 63FEFFEA 		b	.L327
 5092              	.LVL384:
 5093              	.L488:
 5094              	.LBE126:
 5095              	.LBE136:
3767:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5096              		.loc 1 3767 0
 5097 2df4 0400A0E3 		mov	r0, #4
 5098              	.LVL385:
 5099 2df8 C4149FE5 		ldr	r1, .L494+84
 5100 2dfc FEFFFFEB 		bl	CyU3PDebugPrint
 5101              	.LVL386:
 5102              	.L463:
 5103              	.LBB137:
 5104              	.LBB138:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5105              		.loc 1 1546 0
 5106 2e00 C0149FE5 		ldr	r1, .L494+88
 5107 2e04 0400A0E3 		mov	r0, #4
 5108 2e08 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 5109              		.loc 1 1547 0
 5110 2e0c FA0FA0E3 		mov	r0, #1000
 5111 2e10 FEFFFFEB 		bl	_tx_thread_sleep
 5112 2e14 F9FFFFEA 		b	.L463
 5113              	.L346:
 5114              	.LBE138:
 5115              	.LBE137:
 5116              	.LBB139:
 5117              	.LBB93:
2832:../uvc.c      ****     switch (wValue)
 5118              		.loc 1 2832 0
 5119 2e18 010B52E3 		cmp	r2, #1024
 5120 2e1c 58FEFF0A 		beq	.L327
 5121 2e20 050C52E3 		cmp	r2, #1280
 5122 2e24 4DFEFF1A 		bne	.L348
 5123              	.LVL387:
2851:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5124              		.loc 1 2851 0
 5125 2e28 0400A0E3 		mov	r0, #4
 5126 2e2c FEFFFFEB 		bl	ControlHandle
 5127              	.LVL388:
 5128 2e30 28309DE5 		ldr	r3, [sp, #40]
 5129 2e34 52FEFFEA 		b	.L327
 5130              	.LVL389:
 5131              	.L490:
 5132              	.LBE93:
 5133              	.LBE139:
3740:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5134              		.loc 1 3740 0
 5135 2e38 0400A0E3 		mov	r0, #4
 5136              	.LVL390:
 5137 2e3c 80149FE5 		ldr	r1, .L494+84
 5138 2e40 FEFFFFEB 		bl	CyU3PDebugPrint
 5139              	.LVL391:
 5140              	.L461:
 5141              	.LBB140:
 5142              	.LBB141:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5143              		.loc 1 1546 0
 5144 2e44 7C149FE5 		ldr	r1, .L494+88
 5145 2e48 0400A0E3 		mov	r0, #4
 5146 2e4c FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 5147              		.loc 1 1547 0
 5148 2e50 FA0FA0E3 		mov	r0, #1000
 5149 2e54 FEFFFFEB 		bl	_tx_thread_sleep
 5150 2e58 F9FFFFEA 		b	.L461
 5151              	.L386:
 5152              	.LBE141:
 5153              	.LBE140:
 5154              	.LBB142:
 5155              	.LBB123:
3132:../uvc.c      ****     switch (wValue)
 5156              		.loc 1 3132 0
 5157 2e5c 060C53E3 		cmp	r3, #1536
 5158 2e60 F600000A 		beq	.L372
 5159 2e64 0F00008A 		bhi	.L387
 5160 2e68 050C53E3 		cmp	r3, #1280
 5161 2e6c 3FFEFF1A 		bne	.L328
 5162              	.LVL392:
3152:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5163              		.loc 1 3152 0
 5164 2e70 1400A0E3 		mov	r0, #20
 5165 2e74 FEFFFFEB 		bl	ControlHandle
 5166              	.LVL393:
 5167 2e78 28309DE5 		ldr	r3, [sp, #40]
 5168 2e7c 40FEFFEA 		b	.L327
 5169              	.L362:
 5170              	.LBE123:
 5171              	.LBE142:
 5172              	.LBB143:
 5173              	.LBB106:
2907:../uvc.c      ****     switch (wValue)
 5174              		.loc 1 2907 0
 5175 2e80 0B0C52E3 		cmp	r2, #2816
 5176 2e84 E900000A 		beq	.L358
 5177 2e88 030B52E3 		cmp	r2, #3072
 5178 2e8c E300000A 		beq	.L359
 5179 2e90 0A0C52E3 		cmp	r2, #2560
 5180 2e94 31FEFF1A 		bne	.L348
 5181              	.LVL394:
2948:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5182              		.loc 1 2948 0
 5183 2e98 0800A0E3 		mov	r0, #8
 5184 2e9c FEFFFFEB 		bl	CTControlHandle
 5185              	.LVL395:
 5186 2ea0 28309DE5 		ldr	r3, [sp, #40]
 5187 2ea4 36FEFFEA 		b	.L327
 5188              	.L387:
 5189              	.LBE106:
 5190              	.LBE143:
 5191              	.LBB144:
 5192              	.LBB127:
3132:../uvc.c      ****     switch (wValue)
 5193              		.loc 1 3132 0
 5194 2ea8 070C53E3 		cmp	r3, #1792
 5195 2eac D700000A 		beq	.L373
 5196 2eb0 020B53E3 		cmp	r3, #2048
 5197 2eb4 2DFEFF1A 		bne	.L328
 5198              	.LVL396:
3164:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5199              		.loc 1 3164 0
 5200 2eb8 1700A0E3 		mov	r0, #23
 5201 2ebc FEFFFFEB 		bl	ControlHandle
 5202              	.LVL397:
 5203 2ec0 28309DE5 		ldr	r3, [sp, #40]
 5204 2ec4 2EFEFFEA 		b	.L327
 5205              	.L361:
 5206              	.LBE127:
 5207              	.LBE144:
 5208              	.LBB145:
 5209              	.LBB102:
2907:../uvc.c      ****     switch (wValue)
 5210              		.loc 1 2907 0
 5211 2ec8 010B52E3 		cmp	r2, #1024
 5212 2ecc CB00000A 		beq	.L352
 5213 2ed0 050C52E3 		cmp	r2, #1280
 5214 2ed4 21FEFF1A 		bne	.L348
 5215              	.LVL398:
2929:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 5216              		.loc 1 2929 0
 5217 2ed8 0400A0E3 		mov	r0, #4
 5218 2edc FEFFFFEB 		bl	CTControlHandle
 5219              	.LVL399:
 5220 2ee0 28309DE5 		ldr	r3, [sp, #40]
 5221 2ee4 26FEFFEA 		b	.L327
 5222              	.L347:
 5223              	.LBE102:
 5224              	.LBE145:
 5225              	.LBB146:
 5226              	.LBB96:
2832:../uvc.c      ****     switch (wValue)
 5227              		.loc 1 2832 0
 5228 2ee8 0D0C52E3 		cmp	r2, #3328
 5229 2eec 1C00000A 		beq	.L342
 5230 2ef0 0E0C52E3 		cmp	r2, #3584
 5231 2ef4 BD00000A 		beq	.L344
 5232 2ef8 030B52E3 		cmp	r2, #3072
 5233 2efc 17FEFF1A 		bne	.L348
 5234              	.LVL400:
2873:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5235              		.loc 1 2873 0
 5236 2f00 0B00A0E3 		mov	r0, #11
 5237 2f04 FEFFFFEB 		bl	ControlHandle
 5238              	.LVL401:
 5239 2f08 28309DE5 		ldr	r3, [sp, #40]
 5240 2f0c 1CFEFFEA 		b	.L327
 5241              	.LVL402:
 5242              	.L454:
 5243              	.LBE96:
 5244              	.LBE146:
 5245              	.LBB147:
 5246              	.LBB112:
3506:../uvc.c      ****             	switch (bRequest)
 5247              		.loc 1 3506 0
 5248 2f10 850052E3 		cmp	r2, #133
 5249 2f14 B200000A 		beq	.L452
 5250 2f18 860052E3 		cmp	r2, #134
 5251 2f1c 1DFEFF1A 		bne	.L393
 5252 2f20 7BFFFFEA 		b	.L478
 5253              	.LVL403:
 5254              	.L390:
 5255              	.LBE112:
 5256              	.LBE147:
 5257              	.LBB148:
 5258              	.LBB122:
3132:../uvc.c      ****     switch (wValue)
 5259              		.loc 1 3132 0
 5260 2f24 120C53E3 		cmp	r3, #4608
 5261 2f28 A900000A 		beq	.L383
 5262 2f2c 130C53E3 		cmp	r3, #4864
 5263 2f30 0EFEFF1A 		bne	.L328
 5264              	.LVL404:
3213:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 5265              		.loc 1 3213 0
 5266 2f34 2200A0E3 		mov	r0, #34
 5267 2f38 FEFFFFEB 		bl	ControlHandle
 5268              	.LVL405:
 5269 2f3c 28309DE5 		ldr	r3, [sp, #40]
 5270 2f40 0FFEFFEA 		b	.L327
 5271              	.L377:
 5272              	.LVL406:
3179:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5273              		.loc 1 3179 0
 5274 2f44 1A00A0E3 		mov	r0, #26
 5275 2f48 FEFFFFEB 		bl	ControlHandle
 5276              	.LVL407:
 5277 2f4c 28309DE5 		ldr	r3, [sp, #40]
 5278 2f50 0BFEFFEA 		b	.L327
 5279              	.L340:
 5280              	.LVL408:
 5281              	.LBE122:
 5282              	.LBE148:
 5283              	.LBB149:
 5284              	.LBB92:
2859:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5285              		.loc 1 2859 0
 5286 2f54 0600A0E3 		mov	r0, #6
 5287 2f58 FEFFFFEB 		bl	ControlHandle
 5288              	.LVL409:
 5289 2f5c 28309DE5 		ldr	r3, [sp, #40]
 5290 2f60 07FEFFEA 		b	.L327
 5291              	.L342:
 5292              	.LVL410:
2869:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5293              		.loc 1 2869 0
 5294 2f64 0900A0E3 		mov	r0, #9
 5295 2f68 FEFFFFEB 		bl	ControlHandle
 5296              	.LVL411:
 5297 2f6c 28309DE5 		ldr	r3, [sp, #40]
 5298 2f70 03FEFFEA 		b	.L327
 5299              	.LVL412:
 5300              	.L456:
 5301              	.LBE92:
 5302              	.LBE149:
 5303              	.LBB150:
 5304              	.LBB116:
3549:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5305              		.loc 1 3549 0
 5306 2f74 50139FE5 		ldr	r1, .L494+92
 5307 2f78 BE22DDE1 		ldrh	r2, [sp, #46]
 5308 2f7c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5309 2f80 0400A0E3 		mov	r0, #4
 5310              	.LVL413:
 5311 2f84 FEFFFFEB 		bl	CyU3PDebugPrint
 5312 2f88 02FEFFEA 		b	.L393
 5313              	.LVL414:
 5314              	.L489:
3323:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5315              		.loc 1 3323 0
 5316 2f8c 2000A0E3 		mov	r0, #32
 5317 2f90 04139FE5 		ldr	r1, .L494+44
 5318 2f94 2E208DE2 		add	r2, sp, #46
 5319 2f98 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5320              	.LVL415:
3325:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5321              		.loc 1 3325 0
 5322 2f9c 000050E3 		cmp	r0, #0
 5323 2fa0 00FEFF1A 		bne	.L473
3327:../uvc.c      ****                         switch (glCommitCtrl[3])
 5324              		.loc 1 3327 0
 5325 2fa4 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5326              	.LVL416:
 5327 2fa8 020050E3 		cmp	r0, #2
 5328 2fac 2600000A 		beq	.L419
 5329 2fb0 030050E3 		cmp	r0, #3
 5330 2fb4 1700000A 		beq	.L420
 5331 2fb8 010050E3 		cmp	r0, #1
 5332 2fbc 0800001A 		bne	.L417
3330:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5333              		.loc 1 3330 0
 5334 2fc0 582095E5 		ldr	r2, [r5, #88]
 5335 2fc4 3010A0E3 		mov	r1, #48
 5336 2fc8 000052E3 		cmp	r2, #0
 5337 2fcc E420A003 		moveq	r2, #228
 5338 2fd0 6420A013 		movne	r2, #100
 5339 2fd4 5230A0E3 		mov	r3, #82
 5340 2fd8 FEFFFFEB 		bl	SensorSetIrisControl
3331:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5341              		.loc 1 3331 0
 5342 2fdc 7D0FA0E3 		mov	r0, #500
 5343 2fe0 FEFFFFEB 		bl	_tx_thread_sleep
 5344              	.L417:
3347:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5345              		.loc 1 3347 0
 5346 2fe4 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3359:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5347              		.loc 1 3359 0
 5348 2fe8 0020A0E3 		mov	r2, #0
 5349 2fec 7C029FE5 		ldr	r0, .L494
 5350 2ff0 0110A0E3 		mov	r1, #1
3347:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5351              		.loc 1 3347 0
 5352 2ff4 7DC0C4E5 		strb	ip, [r4, #125]
3359:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5353              		.loc 1 3359 0
 5354 2ff8 FEFFFFEB 		bl	_txe_event_flags_set
 5355              	.LVL417:
3360:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5356              		.loc 1 3360 0
 5357 2ffc 002050E2 		subs	r2, r0, #0
 5358 3000 E8FDFF0A 		beq	.L473
3362:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5359              		.loc 1 3362 0
 5360 3004 0400A0E3 		mov	r0, #4
 5361              	.LVL418:
 5362 3008 90129FE5 		ldr	r1, .L494+48
 5363 300c FEFFFFEB 		bl	CyU3PDebugPrint
 5364              	.LVL419:
 5365 3010 28309DE5 		ldr	r3, [sp, #40]
 5366 3014 E4FDFFEA 		b	.L391
 5367              	.L420:
3340:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5368              		.loc 1 3340 0
 5369 3018 582095E5 		ldr	r2, [r5, #88]
 5370 301c 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5371 3020 000052E3 		cmp	r2, #0
 5372 3024 C420A003 		moveq	r2, #196
 5373 3028 4420A013 		movne	r2, #68
 5374 302c 032082E1 		orr	r2, r2, r3
 5375 3030 3010A0E3 		mov	r1, #48
 5376 3034 5230A0E3 		mov	r3, #82
 5377 3038 0100A0E3 		mov	r0, #1
 5378 303c FEFFFFEB 		bl	SensorSetIrisControl
3341:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5379              		.loc 1 3341 0
 5380 3040 7D0FA0E3 		mov	r0, #500
 5381 3044 FEFFFFEB 		bl	_tx_thread_sleep
 5382 3048 E5FFFFEA 		b	.L417
 5383              	.L419:
3335:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5384              		.loc 1 3335 0
 5385 304c 582095E5 		ldr	r2, [r5, #88]
 5386 3050 3010A0E3 		mov	r1, #48
 5387 3054 000052E3 		cmp	r2, #0
 5388 3058 D420A003 		moveq	r2, #212
 5389 305c 5420A013 		movne	r2, #84
 5390 3060 5230A0E3 		mov	r3, #82
 5391 3064 0100A0E3 		mov	r0, #1
 5392 3068 FEFFFFEB 		bl	SensorSetIrisControl
3336:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5393              		.loc 1 3336 0
 5394 306c 7D0FA0E3 		mov	r0, #500
 5395 3070 FEFFFFEB 		bl	_tx_thread_sleep
 5396 3074 DAFFFFEA 		b	.L417
 5397              	.LVL420:
 5398              	.L451:
3518:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5399              		.loc 1 3518 0
 5400 3078 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5401 307c 030051E3 		cmp	r1, #3
 5402 3080 0400000A 		beq	.L493
 5403              	.L455:
3524:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5404              		.loc 1 3524 0
 5405 3084 1A00A0E3 		mov	r0, #26
 5406 3088 40129FE5 		ldr	r1, .L494+96
 5407 308c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5408 3090 28309DE5 		ldr	r3, [sp, #40]
 5409 3094 C4FDFFEA 		b	.L391
 5410              	.L493:
3520:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5411              		.loc 1 3520 0
 5412 3098 1A00A0E3 		mov	r0, #26
 5413 309c 30129FE5 		ldr	r1, .L494+100
 5414 30a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5415 30a4 28309DE5 		ldr	r3, [sp, #40]
 5416 30a8 BFFDFFEA 		b	.L391
 5417              	.LVL421:
 5418              	.L369:
 5419              	.LBE116:
 5420              	.LBE150:
 5421              	.LBB151:
 5422              	.LBB128:
3144:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5423              		.loc 1 3144 0
 5424 30ac 1200A0E3 		mov	r0, #18
 5425 30b0 FEFFFFEB 		bl	ControlHandle
 5426              	.LVL422:
 5427 30b4 28309DE5 		ldr	r3, [sp, #40]
 5428 30b8 B1FDFFEA 		b	.L327
 5429              	.L368:
 5430              	.LVL423:
3140:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5431              		.loc 1 3140 0
 5432 30bc 1100A0E3 		mov	r0, #17
 5433 30c0 FEFFFFEB 		bl	ControlHandle
 5434              	.LVL424:
 5435 30c4 28309DE5 		ldr	r3, [sp, #40]
 5436 30c8 ADFDFFEA 		b	.L327
 5437              	.L380:
 5438              	.LVL425:
3197:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5439              		.loc 1 3197 0
 5440 30cc 1E00A0E3 		mov	r0, #30
 5441 30d0 FEFFFFEB 		bl	ControlHandle
 5442              	.LVL426:
 5443 30d4 28309DE5 		ldr	r3, [sp, #40]
 5444 30d8 A9FDFFEA 		b	.L327
 5445              	.L355:
 5446              	.LVL427:
 5447              	.LBE128:
 5448              	.LBE151:
 5449              	.LBB152:
 5450              	.LBB107:
2937:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5451              		.loc 1 2937 0
 5452 30dc 0600A0E3 		mov	r0, #6
 5453 30e0 FEFFFFEB 		bl	CTControlHandle
 5454              	.LVL428:
 5455 30e4 28309DE5 		ldr	r3, [sp, #40]
 5456 30e8 A5FDFFEA 		b	.L327
 5457              	.L356:
 5458              	.LVL429:
2943:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5459              		.loc 1 2943 0
 5460 30ec 0700A0E3 		mov	r0, #7
 5461 30f0 FEFFFFEB 		bl	CTControlHandle
 5462              	.LVL430:
 5463 30f4 28309DE5 		ldr	r3, [sp, #40]
 5464 30f8 A1FDFFEA 		b	.L327
 5465              	.L337:
 5466              	.LVL431:
 5467              	.LBE107:
 5468              	.LBE152:
 5469              	.LBB153:
 5470              	.LBB97:
2844:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5471              		.loc 1 2844 0
 5472 30fc 0200A0E3 		mov	r0, #2
 5473 3100 FEFFFFEB 		bl	ControlHandle
 5474              	.LVL432:
 5475 3104 28309DE5 		ldr	r3, [sp, #40]
 5476 3108 9DFDFFEA 		b	.L327
 5477              	.L339:
 5478              	.LVL433:
2855:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5479              		.loc 1 2855 0
 5480 310c 0500A0E3 		mov	r0, #5
 5481 3110 FEFFFFEB 		bl	ControlHandle
 5482              	.LVL434:
 5483 3114 28309DE5 		ldr	r3, [sp, #40]
 5484 3118 99FDFFEA 		b	.L327
 5485              	.L370:
 5486              	.LVL435:
 5487              	.LBE97:
 5488              	.LBE153:
 5489              	.LBB154:
 5490              	.LBB121:
3148:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5491              		.loc 1 3148 0
 5492 311c 1300A0E3 		mov	r0, #19
 5493 3120 FEFFFFEB 		bl	ControlHandle
 5494              	.LVL436:
 5495 3124 28309DE5 		ldr	r3, [sp, #40]
 5496 3128 95FDFFEA 		b	.L327
 5497              	.L375:
 5498              	.LVL437:
3168:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5499              		.loc 1 3168 0
 5500 312c 1800A0E3 		mov	r0, #24
 5501 3130 FEFFFFEB 		bl	ControlHandle
 5502              	.LVL438:
 5503 3134 28309DE5 		ldr	r3, [sp, #40]
 5504 3138 91FDFFEA 		b	.L327
 5505              	.L349:
 5506              	.LVL439:
 5507              	.LBE121:
 5508              	.LBE154:
 5509              	.LBB155:
 5510              	.LBB101:
2911:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5511              		.loc 1 2911 0
 5512 313c 0000A0E3 		mov	r0, #0
 5513 3140 FEFFFFEB 		bl	CTControlHandle
 5514              	.LVL440:
 5515 3144 28309DE5 		ldr	r3, [sp, #40]
 5516 3148 8DFDFFEA 		b	.L327
 5517              	.L445:
 5518              	.LBE101:
 5519              	.LBE155:
 5520              	.LBB156:
 5521              	.LBB111:
3474:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 5522              		.loc 1 3474 0
 5523 314c 582094E5 		ldr	r2, [r4, #88]
 5524 3150 3010A0E3 		mov	r1, #48
 5525 3154 000052E3 		cmp	r2, #0
 5526 3158 E420A003 		moveq	r2, #228
 5527 315c 6420A013 		movne	r2, #100
 5528 3160 5230A0E3 		mov	r3, #82
 5529 3164 0100A0E3 		mov	r0, #1
 5530 3168 FEFFFFEB 		bl	SensorSetIrisControl
 5531 316c 89FEFFEA 		b	.L442
 5532              	.L444:
3479:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 5533              		.loc 1 3479 0
 5534 3170 582094E5 		ldr	r2, [r4, #88]
 5535 3174 3010A0E3 		mov	r1, #48
 5536 3178 000052E3 		cmp	r2, #0
 5537 317c D420A003 		moveq	r2, #212
 5538 3180 5420A013 		movne	r2, #84
 5539 3184 5230A0E3 		mov	r3, #82
 5540 3188 0100A0E3 		mov	r0, #1
 5541 318c FEFFFFEB 		bl	SensorSetIrisControl
 5542 3190 80FEFFEA 		b	.L442
 5543              	.L351:
 5544              	.LVL441:
 5545              	.LBE111:
 5546              	.LBE156:
 5547              	.LBB157:
 5548              	.LBB108:
2919:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5549              		.loc 1 2919 0
 5550 3194 0200A0E3 		mov	r0, #2
 5551 3198 FEFFFFEB 		bl	CTControlHandle
 5552              	.LVL442:
 5553 319c 28309DE5 		ldr	r3, [sp, #40]
 5554 31a0 77FDFFEA 		b	.L327
 5555              	.L354:
 5556              	.LVL443:
2933:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 5557              		.loc 1 2933 0
 5558 31a4 0500A0E3 		mov	r0, #5
 5559 31a8 FEFFFFEB 		bl	CTControlHandle
 5560              	.LVL444:
 5561 31ac 28309DE5 		ldr	r3, [sp, #40]
 5562 31b0 73FDFFEA 		b	.L327
 5563              	.L485:
 5564              	.LVL445:
 5565              	.LBE108:
 5566              	.LBE157:
 5567              	.LBB158:
 5568              	.LBB91:
2840:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5569              		.loc 1 2840 0
 5570 31b4 0100A0E3 		mov	r0, #1
 5571 31b8 FEFFFFEB 		bl	ControlHandle
 5572              	.LVL446:
 5573 31bc 28309DE5 		ldr	r3, [sp, #40]
 5574 31c0 6FFDFFEA 		b	.L327
 5575              	.L335:
 5576              	.LVL447:
2836:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 5577              		.loc 1 2836 0
 5578 31c4 0000A0E3 		mov	r0, #0
 5579 31c8 FEFFFFEB 		bl	ControlHandle
 5580              	.LVL448:
 5581 31cc 28309DE5 		ldr	r3, [sp, #40]
 5582 31d0 6BFDFFEA 		b	.L327
 5583              	.L383:
 5584              	.LVL449:
 5585              	.LBE91:
 5586              	.LBE158:
 5587              	.LBB159:
 5588              	.LBB129:
3209:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5589              		.loc 1 3209 0
 5590 31d4 2100A0E3 		mov	r0, #33
 5591 31d8 FEFFFFEB 		bl	ControlHandle
 5592              	.LVL450:
 5593 31dc 28309DE5 		ldr	r3, [sp, #40]
 5594 31e0 67FDFFEA 		b	.L327
 5595              	.LVL451:
 5596              	.L452:
 5597              	.LBE129:
 5598              	.LBE159:
 5599              	.LBB160:
 5600              	.LBB117:
3515:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5601              		.loc 1 3515 0
 5602 31e4 0200A0E3 		mov	r0, #2
 5603 31e8 C4109FE5 		ldr	r1, .L494+68
 5604 31ec B1FEFFEA 		b	.L474
 5605              	.LVL452:
 5606              	.L344:
 5607              	.LBE117:
 5608              	.LBE160:
 5609              	.LBB161:
 5610              	.LBB98:
2877:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5611              		.loc 1 2877 0
 5612 31f0 0E00A0E3 		mov	r0, #14
 5613 31f4 FEFFFFEB 		bl	ControlHandle
 5614              	.LVL453:
 5615 31f8 28309DE5 		ldr	r3, [sp, #40]
 5616 31fc 60FDFFEA 		b	.L327
 5617              	.L352:
 5618              	.LVL454:
 5619              	.LBE98:
 5620              	.LBE161:
 5621              	.LBB162:
 5622              	.LBB100:
2924:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 5623              		.loc 1 2924 0
 5624 3200 0300A0E3 		mov	r0, #3
 5625 3204 FEFFFFEB 		bl	CTControlHandle
 5626              	.LVL455:
 5627 3208 28309DE5 		ldr	r3, [sp, #40]
 5628 320c 5CFDFFEA 		b	.L327
 5629              	.L373:
 5630              	.LVL456:
 5631              	.LBE100:
 5632              	.LBE162:
 5633              	.LBB163:
 5634              	.LBB120:
3160:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5635              		.loc 1 3160 0
 5636 3210 1600A0E3 		mov	r0, #22
 5637 3214 FEFFFFEB 		bl	ControlHandle
 5638              	.LVL457:
 5639 3218 28309DE5 		ldr	r3, [sp, #40]
 5640 321c 58FDFFEA 		b	.L327
 5641              	.L359:
 5642              	.LVL458:
 5643              	.LBE120:
 5644              	.LBE163:
 5645              	.LBB164:
 5646              	.LBB109:
2956:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5647              		.loc 1 2956 0
 5648 3220 0A00A0E3 		mov	r0, #10
 5649 3224 FEFFFFEB 		bl	CTControlHandle
 5650              	.LVL459:
 5651 3228 28309DE5 		ldr	r3, [sp, #40]
 5652 322c 54FDFFEA 		b	.L327
 5653              	.L358:
 5654              	.LVL460:
2952:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5655              		.loc 1 2952 0
 5656 3230 0900A0E3 		mov	r0, #9
 5657 3234 FEFFFFEB 		bl	CTControlHandle
 5658              	.LVL461:
 5659 3238 28309DE5 		ldr	r3, [sp, #40]
 5660 323c 50FDFFEA 		b	.L327
 5661              	.L372:
 5662              	.LVL462:
 5663              	.LBE109:
 5664              	.LBE164:
 5665              	.LBB165:
 5666              	.LBB130:
3156:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5667              		.loc 1 3156 0
 5668 3240 1500A0E3 		mov	r0, #21
 5669 3244 FEFFFFEB 		bl	ControlHandle
 5670              	.LVL463:
 5671 3248 28309DE5 		ldr	r3, [sp, #40]
 5672 324c 4CFDFFEA 		b	.L327
 5673              	.L382:
 5674              	.LVL464:
3205:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5675              		.loc 1 3205 0
 5676 3250 2000A0E3 		mov	r0, #32
 5677 3254 FEFFFFEB 		bl	ControlHandle
 5678              	.LVL465:
 5679 3258 28309DE5 		ldr	r3, [sp, #40]
 5680 325c 48FDFFEA 		b	.L327
 5681              	.L378:
 5682              	.LVL466:
3183:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 5683              		.loc 1 3183 0
 5684 3260 1B00A0E3 		mov	r0, #27
 5685 3264 FEFFFFEB 		bl	ControlHandle
 5686              	.LVL467:
 5687 3268 28309DE5 		ldr	r3, [sp, #40]
 5688 326c 44FDFFEA 		b	.L327
 5689              	.L495:
 5690              		.align	2
 5691              	.L494:
 5692 3270 00000000 		.word	.LANCHOR0
 5693 3274 00000000 		.word	.LANCHOR1
 5694 3278 00000000 		.word	bRequest
 5695 327c 00000000 		.word	wValue
 5696 3280 00000000 		.word	wIndex
 5697 3284 00000000 		.word	glInterStaBuffer
 5698 3288 7C050000 		.word	.LC29
 5699 328c 00000000 		.word	glChHandleInterStat
 5700 3290 00000000 		.word	bmReqType
 5701 3294 00000000 		.word	wLength
 5702 3298 00050000 		.word	.LC28
 5703 329c 80000000 		.word	.LANCHOR0+128
 5704 32a0 D0050000 		.word	.LC31
 5705 32a4 4C060000 		.word	.LC34
 5706 32a8 24060000 		.word	.LC33
 5707 32ac 50060000 		.word	.LANCHOR1+1616
 5708 32b0 A8050000 		.word	.LC30
 5709 32b4 5C000000 		.word	.LANCHOR0+92
 5710 32b8 A4060000 		.word	.LANCHOR1+1700
 5711 32bc B0060000 		.word	.LANCHOR1+1712
 5712 32c0 F8050000 		.word	.LC32
 5713 32c4 A0060000 		.word	.LC36
 5714 32c8 D8010000 		.word	.LC12
 5715 32cc 78060000 		.word	.LC35
 5716 32d0 6C060000 		.word	.LANCHOR1+1644
 5717 32d4 88060000 		.word	.LANCHOR1+1672
 5718              	.LBE130:
 5719              	.LBE165:
 5720              		.cfi_endproc
 5721              	.LFE24:
 5723              		.align	2
 5724              		.global	CamDefSet
 5726              	CamDefSet:
 5727              	.LFB4:
1441:../uvc.c      **** {
 5728              		.loc 1 1441 0
 5729              		.cfi_startproc
 5730              		@ args = 0, pretend = 0, frame = 24
 5731              		@ frame_needed = 0, uses_anonymous_args = 0
 5732              	.LVL468:
 5733 32d8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5734              	.LCFI19:
 5735              		.cfi_def_cfa_offset 36
1447:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5736              		.loc 1 1447 0
 5737 32dc AC429FE5 		ldr	r4, .L499
 5738              		.cfi_offset 14, -4
 5739              		.cfi_offset 11, -8
 5740              		.cfi_offset 10, -12
 5741              		.cfi_offset 9, -16
 5742              		.cfi_offset 8, -20
 5743              		.cfi_offset 7, -24
 5744              		.cfi_offset 6, -28
 5745              		.cfi_offset 5, -32
 5746              		.cfi_offset 4, -36
1452:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5747              		.loc 1 1452 0
 5748 32e0 AC229FE5 		ldr	r2, .L499+4
1449:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5749              		.loc 1 1449 0
 5750 32e4 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1441:../uvc.c      **** {
 5751              		.loc 1 1441 0
 5752 32e8 2CD04DE2 		sub	sp, sp, #44
 5753              	.LCFI20:
 5754              		.cfi_def_cfa_offset 80
1452:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5755              		.loc 1 1452 0
 5756 32ec 1C0092E5 		ldr	r0, [r2, #28]
 5757 32f0 0010E0E3 		mvn	r1, #0
1454:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5758              		.loc 1 1454 0
 5759 32f4 2963A0E1 		mov	r6, r9, lsr #6
1448:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5760              		.loc 1 1448 0
 5761 32f8 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1447:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5762              		.loc 1 1447 0
 5763 32fc 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5764              	.LVL469:
1452:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5765              		.loc 1 1452 0
 5766 3300 FEFFFFEB 		bl	_txe_mutex_get
1453:../uvc.c      ****     if(Data1&0x80){
 5767              		.loc 1 1453 0
 5768 3304 800019E3 		tst	r9, #128
1454:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5769              		.loc 1 1454 0
 5770 3308 01600612 		andne	r6, r6, #1
 5771 330c 0660E011 		mvnne	r6, r6
 5772 3310 3B600612 		andne	r6, r6, #59
 5773 3314 0660E011 		mvnne	r6, r6
 5774 3318 FF600612 		andne	r6, r6, #255
 5775              	.LVL470:
1456:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5776              		.loc 1 1456 0
 5777 331c C6608603 		orreq	r6, r6, #198
 5778              	.LVL471:
1460:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5779              		.loc 1 1460 0
 5780 3320 0080A0E3 		mov	r8, #0
 5781 3324 0A20A0E1 		mov	r2, sl
 5782 3328 0730A0E1 		mov	r3, r7
 5783 332c 0110A0E3 		mov	r1, #1
1458:../uvc.c      ****     Data0 = (Data0 << 2);
 5784              		.loc 1 1458 0
 5785 3330 0951A0E1 		mov	r5, r9, asl #2
1460:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5786              		.loc 1 1460 0
 5787 3334 58029FE5 		ldr	r0, .L499+4
1463:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5788              		.loc 1 1463 0
 5789 3338 0190A0E3 		mov	r9, #1
 5790              	.LVL472:
1458:../uvc.c      ****     Data0 = (Data0 << 2);
 5791              		.loc 1 1458 0
 5792 333c FF5005E2 		and	r5, r5, #255
 5793              	.LVL473:
1460:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5794              		.loc 1 1460 0
 5795 3340 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5796 3344 FEFFFFEB 		bl	cmdSet
 5797              	.LVL474:
1463:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5798              		.loc 1 1463 0
 5799 3348 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5800 334c 0910A0E1 		mov	r1, r9
 5801 3350 0730A0E1 		mov	r3, r7
 5802 3354 38029FE5 		ldr	r0, .L499+4
 5803 3358 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5804 335c FEFFFFEB 		bl	cmdSet
 5805              	.LVL475:
1466:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5806              		.loc 1 1466 0
 5807 3360 0620A0E1 		mov	r2, r6
 5808 3364 0530A0E1 		mov	r3, r5
 5809 3368 28129FE5 		ldr	r1, .L499+8
 5810 336c 0400A0E3 		mov	r0, #4
1465:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5811              		.loc 1 1465 0
 5812 3370 A661C4E5 		strb	r6, [r4, #422]
1464:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5813              		.loc 1 1464 0
 5814 3374 A551C4E5 		strb	r5, [r4, #421]
1466:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5815              		.loc 1 1466 0
 5816 3378 FEFFFFEB 		bl	CyU3PDebugPrint
 5817              	.LVL476:
1471:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5818              		.loc 1 1471 0
 5819 337c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5820              	.LVL477:
1472:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5821              		.loc 1 1472 0
 5822 3380 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5823 3384 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5824 3388 0210A0E3 		mov	r1, #2
 5825 338c 00029FE5 		ldr	r0, .L499+4
 5826 3390 00B08DE5 		str	fp, [sp, #0]
 5827 3394 04808DE5 		str	r8, [sp, #4]
 5828 3398 FEFFFFEB 		bl	cmdSet
 5829              	.LVL478:
1474:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5830              		.loc 1 1474 0
 5831 339c 0B20A0E1 		mov	r2, fp
 5832 33a0 0530A0E1 		mov	r3, r5
 5833 33a4 EC119FE5 		ldr	r1, .L499+8
 5834 33a8 0400A0E3 		mov	r0, #4
1473:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5835              		.loc 1 1473 0
 5836 33ac BD51C4E5 		strb	r5, [r4, #445]
1474:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5837              		.loc 1 1474 0
 5838 33b0 FEFFFFEB 		bl	CyU3PDebugPrint
 5839              	.LVL479:
1479:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5840              		.loc 1 1479 0
 5841 33b4 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1478:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5842              		.loc 1 1478 0
 5843 33b8 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5844              	.LVL480:
1480:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5845              		.loc 1 1480 0
 5846 33bc 80B047E2 		sub	fp, r7, #128
 5847 33c0 FF100BE2 		and	r1, fp, #255
 5848 33c4 14108DE5 		str	r1, [sp, #20]
 5849 33c8 14C09DE5 		ldr	ip, [sp, #20]
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5850              		.loc 1 1481 0
 5851 33cc 760047E2 		sub	r0, r7, #118
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5852              		.loc 1 1482 0
 5853 33d0 7EE087E2 		add	lr, r7, #126
1480:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5854              		.loc 1 1480 0
 5855 33d4 0630A0E1 		mov	r3, r6
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5856              		.loc 1 1481 0
 5857 33d8 18008DE5 		str	r0, [sp, #24]
1480:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5858              		.loc 1 1480 0
 5859 33dc 0510A0E3 		mov	r1, #5
 5860 33e0 DF20A0E3 		mov	r2, #223
 5861 33e4 A8019FE5 		ldr	r0, .L499+4
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5862              		.loc 1 1482 0
 5863 33e8 1CE08DE5 		str	lr, [sp, #28]
1480:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5864              		.loc 1 1480 0
 5865 33ec 00C08DE5 		str	ip, [sp, #0]
 5866 33f0 04808DE5 		str	r8, [sp, #4]
 5867 33f4 FEFFFFEB 		bl	cmdSet
 5868              	.LVL481:
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5869              		.loc 1 1481 0
 5870 33f8 18A09DE5 		ldr	sl, [sp, #24]
1483:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5871              		.loc 1 1483 0
 5872 33fc 72E087E2 		add	lr, r7, #114
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5873              		.loc 1 1481 0
 5874 3400 FFC00AE2 		and	ip, sl, #255
 5875 3404 0630A0E1 		mov	r3, r6
 5876 3408 0510A0E3 		mov	r1, #5
 5877 340c DC20A0E3 		mov	r2, #220
 5878 3410 7C019FE5 		ldr	r0, .L499+4
1483:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5879              		.loc 1 1483 0
 5880 3414 20E08DE5 		str	lr, [sp, #32]
1481:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5881              		.loc 1 1481 0
 5882 3418 00C08DE5 		str	ip, [sp, #0]
 5883 341c 04908DE5 		str	r9, [sp, #4]
 5884 3420 FEFFFFEB 		bl	cmdSet
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5885              		.loc 1 1482 0
 5886 3424 1C009DE5 		ldr	r0, [sp, #28]
 5887 3428 02E0A0E3 		mov	lr, #2
 5888 342c FFC000E2 		and	ip, r0, #255
 5889 3430 0630A0E1 		mov	r3, r6
1484:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5890              		.loc 1 1484 0
 5891 3434 6FA047E2 		sub	sl, r7, #111
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5892              		.loc 1 1482 0
 5893 3438 0510A0E3 		mov	r1, #5
 5894 343c DE20A0E3 		mov	r2, #222
 5895 3440 4C019FE5 		ldr	r0, .L499+4
 5896 3444 04E08DE5 		str	lr, [sp, #4]
1484:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5897              		.loc 1 1484 0
 5898 3448 24A08DE5 		str	sl, [sp, #36]
1482:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5899              		.loc 1 1482 0
 5900 344c 00C08DE5 		str	ip, [sp, #0]
 5901 3450 FEFFFFEB 		bl	cmdSet
1483:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5902              		.loc 1 1483 0
 5903 3454 20A09DE5 		ldr	sl, [sp, #32]
 5904 3458 0630A0E1 		mov	r3, r6
 5905 345c FFC00AE2 		and	ip, sl, #255
 5906 3460 00C08DE5 		str	ip, [sp, #0]
 5907 3464 0510A0E3 		mov	r1, #5
 5908 3468 03C0A0E3 		mov	ip, #3
 5909 346c E020A0E3 		mov	r2, #224
 5910 3470 1C019FE5 		ldr	r0, .L499+4
 5911 3474 04C08DE5 		str	ip, [sp, #4]
 5912 3478 FEFFFFEB 		bl	cmdSet
1484:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5913              		.loc 1 1484 0
 5914 347c 24009DE5 		ldr	r0, [sp, #36]
 5915 3480 04A0A0E3 		mov	sl, #4
 5916 3484 FFC000E2 		and	ip, r0, #255
 5917 3488 0630A0E1 		mov	r3, r6
 5918 348c 0510A0E3 		mov	r1, #5
 5919 3490 DD20A0E3 		mov	r2, #221
 5920 3494 F8009FE5 		ldr	r0, .L499+4
 5921 3498 00C08DE5 		str	ip, [sp, #0]
1485:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5922              		.loc 1 1485 0
 5923 349c 7F7087E2 		add	r7, r7, #127
 5924              	.LVL482:
1484:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5925              		.loc 1 1484 0
 5926 34a0 04A08DE5 		str	sl, [sp, #4]
 5927 34a4 FEFFFFEB 		bl	cmdSet
1485:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5928              		.loc 1 1485 0
 5929 34a8 05E0A0E3 		mov	lr, #5
 5930 34ac 0E10A0E1 		mov	r1, lr
 5931 34b0 0630A0E1 		mov	r3, r6
 5932 34b4 E120A0E3 		mov	r2, #225
 5933 34b8 FF6007E2 		and	r6, r7, #255
 5934              	.LVL483:
 5935 34bc D0009FE5 		ldr	r0, .L499+4
 5936 34c0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5937 34c4 FEFFFFEB 		bl	cmdSet
 5938              	.LVL484:
1486:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5939              		.loc 1 1486 0
 5940 34c8 14C09DE5 		ldr	ip, [sp, #20]
1487:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5941              		.loc 1 1487 0
 5942 34cc 24E09DE5 		ldr	lr, [sp, #36]
 5943 34d0 1C609DE5 		ldr	r6, [sp, #28]
1486:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5944              		.loc 1 1486 0
 5945 34d4 05C2C4E5 		strb	ip, [r4, #517]
1487:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5946              		.loc 1 1487 0
 5947 34d8 20C09DE5 		ldr	ip, [sp, #32]
 5948 34dc 0B20A0E1 		mov	r2, fp
 5949 34e0 18309DE5 		ldr	r3, [sp, #24]
 5950 34e4 B0109FE5 		ldr	r1, .L499+12
 5951 34e8 0A00A0E1 		mov	r0, sl
 5952 34ec 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5953 34f0 0C708DE5 		str	r7, [sp, #12]
 5954 34f4 FEFFFFEB 		bl	CyU3PDebugPrint
 5955              	.LVL485:
1491:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5956              		.loc 1 1491 0
 5957 34f8 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5958              	.LVL486:
1492:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5959              		.loc 1 1492 0
 5960 34fc 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5961              	.LVL487:
1493:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5962              		.loc 1 1493 0
 5963 3500 0730A0E1 		mov	r3, r7
 5964 3504 0610A0E3 		mov	r1, #6
 5965 3508 8520A0E3 		mov	r2, #133
 5966 350c 80009FE5 		ldr	r0, .L499+4
 5967 3510 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5968 3514 FEFFFFEB 		bl	cmdSet
1494:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5969              		.loc 1 1494 0
 5970 3518 0730A0E1 		mov	r3, r7
 5971 351c 0610A0E3 		mov	r1, #6
 5972 3520 8620A0E3 		mov	r2, #134
 5973 3524 68009FE5 		ldr	r0, .L499+4
 5974 3528 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5975 352c FEFFFFEB 		bl	cmdSet
1496:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5976              		.loc 1 1496 0
 5977 3530 0620A0E1 		mov	r2, r6
 5978 3534 0530A0E1 		mov	r3, r5
 5979 3538 58109FE5 		ldr	r1, .L499+8
 5980 353c 0A00A0E1 		mov	r0, sl
1495:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5981              		.loc 1 1495 0
 5982 3540 1D62C4E5 		strb	r6, [r4, #541]
1496:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5983              		.loc 1 1496 0
 5984 3544 FEFFFFEB 		bl	CyU3PDebugPrint
 5985              	.LVL488:
1501:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5986              		.loc 1 1501 0
 5987 3548 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5988              	.LVL489:
1502:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5989              		.loc 1 1502 0
 5990 354c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5991 3550 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5992 3554 0710A0E3 		mov	r1, #7
 5993 3558 34009FE5 		ldr	r0, .L499+4
 5994 355c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5995 3560 FEFFFFEB 		bl	cmdSet
 5996              	.LVL490:
1504:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5997              		.loc 1 1504 0
 5998 3564 0530A0E1 		mov	r3, r5
 5999 3568 0A00A0E1 		mov	r0, sl
 6000 356c 24109FE5 		ldr	r1, .L499+8
 6001 3570 0620A0E1 		mov	r2, r6
1503:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6002              		.loc 1 1503 0
 6003 3574 3552C4E5 		strb	r5, [r4, #565]
1504:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6004              		.loc 1 1504 0
 6005 3578 FEFFFFEB 		bl	CyU3PDebugPrint
1506:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6006              		.loc 1 1506 0
 6007 357c 10309FE5 		ldr	r3, .L499+4
 6008 3580 1C0093E5 		ldr	r0, [r3, #28]
1509:../uvc.c      **** }
 6009              		.loc 1 1509 0
 6010 3584 2CD08DE2 		add	sp, sp, #44
 6011 3588 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1506:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6012              		.loc 1 1506 0
 6013 358c FEFFFFEA 		b	_txe_mutex_put
 6014              	.L500:
 6015              		.align	2
 6016              	.L499:
 6017 3590 00000000 		.word	.LANCHOR1
 6018 3594 00000000 		.word	cmdQu
 6019 3598 D4060000 		.word	.LC37
 6020 359c F4060000 		.word	.LC38
 6021              		.cfi_endproc
 6022              	.LFE4:
 6024              		.align	2
 6025              		.global	CyFxUVCAddHeader
 6027              	CyFxUVCAddHeader:
 6028              	.LFB5:
1517:../uvc.c      **** {
 6029              		.loc 1 1517 0
 6030              		.cfi_startproc
 6031              		@ args = 0, pretend = 0, frame = 0
 6032              		@ frame_needed = 0, uses_anonymous_args = 0
 6033              	.LVL491:
 6034 35a0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6035              	.LCFI21:
 6036              		.cfi_def_cfa_offset 16
1517:../uvc.c      **** {
 6037              		.loc 1 1517 0
 6038 35a4 0040A0E1 		mov	r4, r0
 6039              		.cfi_offset 14, -4
 6040              		.cfi_offset 5, -8
 6041              		.cfi_offset 4, -12
 6042              		.cfi_offset 3, -16
 6043 35a8 0150A0E1 		mov	r5, r1
1519:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6044              		.loc 1 1519 0
 6045 35ac 30009FE5 		ldr	r0, .L503
 6046              	.LVL492:
 6047 35b0 0010E0E3 		mvn	r1, #0
 6048              	.LVL493:
 6049 35b4 FEFFFFEB 		bl	_txe_mutex_get
1520:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6050              		.loc 1 1520 0
 6051 35b8 0400A0E1 		mov	r0, r4
 6052 35bc 24109FE5 		ldr	r1, .L503+4
 6053 35c0 0C20A0E3 		mov	r2, #12
 6054 35c4 FEFFFFEB 		bl	CyU3PMemCopy
1521:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6055              		.loc 1 1521 0
 6056 35c8 14009FE5 		ldr	r0, .L503
 6057 35cc FEFFFFEB 		bl	_txe_mutex_put
1524:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 6058              		.loc 1 1524 0
 6059 35d0 020015E3 		tst	r5, #2
1526:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 6060              		.loc 1 1526 0
 6061 35d4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6062 35d8 02308313 		orrne	r3, r3, #2
 6063 35dc 0130C415 		strneb	r3, [r4, #1]
 6064 35e0 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6065              	.L504:
 6066              		.align	2
 6067              	.L503:
 6068 35e4 00000000 		.word	imgHdMux
 6069 35e8 80040000 		.word	.LANCHOR1+1152
 6070              		.cfi_endproc
 6071              	.LFE5:
 6073              		.align	2
 6074              		.global	CyFxAppErrorHandler
 6076              	CyFxAppErrorHandler:
 6077              	.LFB6:
1536:../uvc.c      **** {
 6078              		.loc 1 1536 0
 6079              		.cfi_startproc
 6080              		@ args = 0, pretend = 0, frame = 0
 6081              		@ frame_needed = 0, uses_anonymous_args = 0
 6082              	.LVL494:
 6083 35ec 08402DE9 		stmfd	sp!, {r3, lr}
 6084              	.LCFI22:
 6085              		.cfi_def_cfa_offset 8
 6086              	.LVL495:
 6087              	.L506:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6088              		.loc 1 1546 0 discriminator 1
 6089 35f0 10109FE5 		ldr	r1, .L507
 6090 35f4 0400A0E3 		mov	r0, #4
 6091              		.cfi_offset 14, -4
 6092              		.cfi_offset 3, -8
 6093 35f8 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6094              		.loc 1 1547 0 discriminator 1
 6095 35fc FA0FA0E3 		mov	r0, #1000
 6096 3600 FEFFFFEB 		bl	_tx_thread_sleep
 6097 3604 F9FFFFEA 		b	.L506
 6098              	.L508:
 6099              		.align	2
 6100              	.L507:
 6101 3608 D8010000 		.word	.LC12
 6102              		.cfi_endproc
 6103              	.LFE6:
 6105              		.align	2
 6106              		.global	UVCAppThread_Entry
 6108              	UVCAppThread_Entry:
 6109              	.LFB18:
2523:../uvc.c      **** {
 6110              		.loc 1 2523 0
 6111              		.cfi_startproc
 6112              		@ args = 0, pretend = 0, frame = 176
 6113              		@ frame_needed = 0, uses_anonymous_args = 0
 6114              	.LVL496:
 6115 360c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 6116              	.LCFI23:
 6117              		.cfi_def_cfa_offset 28
 6118 3610 BCD04DE2 		sub	sp, sp, #188
 6119              	.LCFI24:
 6120              		.cfi_def_cfa_offset 216
 6121              	.LBB218:
 6122              	.LBB219:
1979:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 6123              		.loc 1 1979 0
 6124              		.cfi_offset 14, -4
 6125              		.cfi_offset 10, -8
 6126              		.cfi_offset 8, -12
 6127              		.cfi_offset 7, -16
 6128              		.cfi_offset 6, -20
 6129              		.cfi_offset 5, -24
 6130              		.cfi_offset 4, -28
 6131 3614 FEFFFFEB 		bl	CyU3PUartInit
 6132              	.LVL497:
1980:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6133              		.loc 1 1980 0
 6134 3618 004050E2 		subs	r4, r0, #0
 6135 361c 0400000A 		beq	.L510
1982:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6136              		.loc 1 1982 0
 6137 3620 0400A0E3 		mov	r0, #4
 6138              	.LVL498:
 6139 3624 301B9FE5 		ldr	r1, .L614
 6140 3628 FEFFFFEB 		bl	CyU3PDebugPrint
1983:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6141              		.loc 1 1983 0
 6142 362c 0400A0E1 		mov	r0, r4
 6143 3630 FEFFFFEB 		bl	CyFxAppErrorHandler
 6144              	.L510:
1987:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6145              		.loc 1 1987 0
 6146 3634 24CB9FE5 		ldr	ip, .L614+4
1989:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6147              		.loc 1 1989 0
 6148 3638 0030A0E3 		mov	r3, #0
1988:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6149              		.loc 1 1988 0
 6150 363c 0120A0E3 		mov	r2, #1
1996:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6151              		.loc 1 1996 0
 6152 3640 50008DE2 		add	r0, sp, #80
 6153 3644 0310A0E1 		mov	r1, r3
1987:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6154              		.loc 1 1987 0
 6155 3648 60C08DE5 		str	ip, [sp, #96]
1988:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6156              		.loc 1 1988 0
 6157 364c 6420CDE5 		strb	r2, [sp, #100]
1989:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6158              		.loc 1 1989 0
 6159 3650 6530CDE5 		strb	r3, [sp, #101]
1990:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6160              		.loc 1 1990 0
 6161 3654 50208DE5 		str	r2, [sp, #80]
1991:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6162              		.loc 1 1991 0
 6163 3658 54308DE5 		str	r3, [sp, #84]
1992:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6164              		.loc 1 1992 0
 6165 365c 58308DE5 		str	r3, [sp, #88]
1993:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6166              		.loc 1 1993 0
 6167 3660 5C208DE5 		str	r2, [sp, #92]
1996:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6168              		.loc 1 1996 0
 6169 3664 FEFFFFEB 		bl	CyU3PUartSetConfig
 6170              	.LVL499:
1997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6171              		.loc 1 1997 0
 6172 3668 000050E3 		cmp	r0, #0
 6173 366c 0000000A 		beq	.L511
1999:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6174              		.loc 1 1999 0
 6175 3670 FEFFFFEB 		bl	CyFxAppErrorHandler
 6176              	.LVL500:
 6177              	.L511:
2003:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 6178              		.loc 1 2003 0
 6179 3674 0000E0E3 		mvn	r0, #0
 6180 3678 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6181              	.LVL501:
2004:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6182              		.loc 1 2004 0
 6183 367c 000050E3 		cmp	r0, #0
 6184 3680 0000000A 		beq	.L512
2006:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6185              		.loc 1 2006 0
 6186 3684 FEFFFFEB 		bl	CyFxAppErrorHandler
 6187              	.LVL502:
 6188              	.L512:
2010:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 6189              		.loc 1 2010 0
 6190 3688 0300A0E3 		mov	r0, #3
 6191 368c 0410A0E3 		mov	r1, #4
 6192 3690 FEFFFFEB 		bl	CyU3PDebugInit
 6193              	.LVL503:
2011:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6194              		.loc 1 2011 0
 6195 3694 000050E3 		cmp	r0, #0
 6196 3698 0000000A 		beq	.L513
2013:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6197              		.loc 1 2013 0
 6198 369c FEFFFFEB 		bl	CyFxAppErrorHandler
 6199              	.LVL504:
 6200              	.L513:
2017:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 6201              		.loc 1 2017 0
 6202 36a0 0000A0E3 		mov	r0, #0
 6203 36a4 FEFFFFEB 		bl	CyU3PDebugPreamble
 6204              	.LVL505:
 6205              	.LBE219:
 6206              	.LBE218:
2539:../uvc.c      **** 		CyU3PThreadSleep(500);
 6207              		.loc 1 2539 0
 6208 36a8 7D0FA0E3 		mov	r0, #500
 6209 36ac FEFFFFEB 		bl	_tx_thread_sleep
 6210              	.LVL506:
 6211 36b0 7D0FA0E3 		mov	r0, #500
 6212 36b4 FEFFFFEB 		bl	_tx_thread_sleep
 6213 36b8 7D0FA0E3 		mov	r0, #500
 6214 36bc FEFFFFEB 		bl	_tx_thread_sleep
 6215 36c0 7D0FA0E3 		mov	r0, #500
 6216 36c4 FEFFFFEB 		bl	_tx_thread_sleep
 6217 36c8 7D0FA0E3 		mov	r0, #500
 6218 36cc FEFFFFEB 		bl	_tx_thread_sleep
 6219 36d0 7D0FA0E3 		mov	r0, #500
 6220 36d4 FEFFFFEB 		bl	_tx_thread_sleep
 6221              	.LBB220:
 6222              	.LBB221:
2027:../uvc.c      ****     status = CyU3PI2cInit ();
 6223              		.loc 1 2027 0
 6224 36d8 FEFFFFEB 		bl	CyU3PI2cInit
 6225              	.LVL507:
2028:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6226              		.loc 1 2028 0
 6227 36dc 004050E2 		subs	r4, r0, #0
 6228 36e0 0400000A 		beq	.L514
2030:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6229              		.loc 1 2030 0
 6230 36e4 0400A0E3 		mov	r0, #4
 6231              	.LVL508:
 6232 36e8 741A9FE5 		ldr	r1, .L614+8
 6233 36ec FEFFFFEB 		bl	CyU3PDebugPrint
2031:../uvc.c      ****         CyFxAppErrorHandler (status);
 6234              		.loc 1 2031 0
 6235 36f0 0400A0E1 		mov	r0, r4
 6236 36f4 FEFFFFEB 		bl	CyFxAppErrorHandler
 6237              	.L514:
2035:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6238              		.loc 1 2035 0
 6239 36f8 686A9FE5 		ldr	r6, .L614+12
2036:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6240              		.loc 1 2036 0
 6241 36fc 0050A0E3 		mov	r5, #0
2037:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6242              		.loc 1 2037 0
 6243 3700 0040E0E3 		mvn	r4, #0
 6244              	.LVL509:
2040:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6245              		.loc 1 2040 0
 6246 3704 8C008DE2 		add	r0, sp, #140
 6247 3708 0510A0E1 		mov	r1, r5
2037:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6248              		.loc 1 2037 0
 6249 370c 94408DE5 		str	r4, [sp, #148]
2038:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6250              		.loc 1 2038 0
 6251 3710 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2035:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6252              		.loc 1 2035 0
 6253 3714 8C608DE5 		str	r6, [sp, #140]
2036:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6254              		.loc 1 2036 0
 6255 3718 90508DE5 		str	r5, [sp, #144]
2040:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6256              		.loc 1 2040 0
 6257 371c FEFFFFEB 		bl	CyU3PI2cSetConfig
 6258              	.LVL510:
2041:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6259              		.loc 1 2041 0
 6260 3720 004050E2 		subs	r4, r0, #0
 6261 3724 0400000A 		beq	.L515
2043:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6262              		.loc 1 2043 0
 6263 3728 0400A0E3 		mov	r0, #4
 6264              	.LVL511:
 6265 372c 381A9FE5 		ldr	r1, .L614+16
 6266 3730 FEFFFFEB 		bl	CyU3PDebugPrint
2044:../uvc.c      ****         CyFxAppErrorHandler (status);
 6267              		.loc 1 2044 0
 6268 3734 0400A0E1 		mov	r0, r4
 6269 3738 FEFFFFEB 		bl	CyFxAppErrorHandler
 6270              	.L515:
 6271              	.LBE221:
 6272              	.LBE220:
 6273              	.LBB222:
 6274              	.LBB225:
2114:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6275              		.loc 1 2114 0
 6276 373c 2C4A9FE5 		ldr	r4, .L614+20
 6277              	.LVL512:
 6278 3740 2820A0E3 		mov	r2, #40
 6279 3744 0010A0E3 		mov	r1, #0
 6280 3748 0400A0E1 		mov	r0, r4
 6281 374c FEFFFFEB 		bl	_txe_event_flags_create
 6282              	.LVL513:
2115:../uvc.c      ****     if (apiRetStatus != 0)
 6283              		.loc 1 2115 0
 6284 3750 002050E2 		subs	r2, r0, #0
 6285 3754 F800001A 		bne	.L588
2129:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6286              		.loc 1 2129 0
 6287 3758 0260A0E3 		mov	r6, #2
2136:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6288              		.loc 1 2136 0
 6289 375c 0210A0E1 		mov	r1, r2
2125:../uvc.c      ****     isUsbConnected = CyFalse;
 6290              		.loc 1 2125 0
 6291 3760 302084E5 		str	r2, [r4, #48]
2126:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6292              		.loc 1 2126 0
 6293 3764 442084E5 		str	r2, [r4, #68]
2132:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6294              		.loc 1 2132 0
 6295 3768 0370A0E3 		mov	r7, #3
2136:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6296              		.loc 1 2136 0
 6297 376c 9C008DE2 		add	r0, sp, #156
 6298              	.LVL514:
2131:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6299              		.loc 1 2131 0
 6300 3770 A420CDE5 		strb	r2, [sp, #164]
2133:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6301              		.loc 1 2133 0
 6302 3774 A0208DE5 		str	r2, [sp, #160]
2129:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6303              		.loc 1 2129 0
 6304 3778 9C60CDE5 		strb	r6, [sp, #156]
2130:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6305              		.loc 1 2130 0
 6306 377c 9D60CDE5 		strb	r6, [sp, #157]
2132:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6307              		.loc 1 2132 0
 6308 3780 A570CDE5 		strb	r7, [sp, #165]
2136:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6309              		.loc 1 2136 0
 6310 3784 FEFFFFEB 		bl	CyU3PGpioInit
 6311              	.LVL515:
2137:../uvc.c      ****     if (apiRetStatus != 0)
 6312              		.loc 1 2137 0
 6313 3788 002050E2 		subs	r2, r0, #0
 6314 378c FC00001A 		bne	.L589
2145:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6315              		.loc 1 2145 0
 6316 3790 1600A0E3 		mov	r0, #22
 6317              	.LVL516:
 6318 3794 0110A0E3 		mov	r1, #1
 6319 3798 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6320              	.LVL517:
2146:../uvc.c      ****     if (apiRetStatus != 0)
 6321              		.loc 1 2146 0
 6322 379c 002050E2 		subs	r2, r0, #0
 6323 37a0 EE00001A 		bne	.L590
2151:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6324              		.loc 1 2151 0
 6325 37a4 1400A0E3 		mov	r0, #20
 6326              	.LVL518:
 6327 37a8 0110A0E3 		mov	r1, #1
 6328 37ac FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6329              	.LVL519:
2152:../uvc.c      ****     if (apiRetStatus != 0)
 6330              		.loc 1 2152 0
 6331 37b0 002050E2 		subs	r2, r0, #0
 6332 37b4 FB00001A 		bne	.L591
2157:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6333              		.loc 1 2157 0
 6334 37b8 1800A0E3 		mov	r0, #24
 6335              	.LVL520:
 6336 37bc 0110A0E3 		mov	r1, #1
 6337 37c0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6338              	.LVL521:
2158:../uvc.c      ****     if (apiRetStatus != 0)
 6339              		.loc 1 2158 0
 6340 37c4 002050E2 		subs	r2, r0, #0
 6341 37c8 D601001A 		bne	.L592
2165:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6342              		.loc 1 2165 0
 6343 37cc 0150A0E3 		mov	r5, #1
2170:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6344              		.loc 1 2170 0
 6345 37d0 1600A0E3 		mov	r0, #22
 6346              	.LVL522:
 6347 37d4 68108DE2 		add	r1, sp, #104
2168:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6348              		.loc 1 2168 0
 6349 37d8 74208DE5 		str	r2, [sp, #116]
2169:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6350              		.loc 1 2169 0
 6351 37dc 7820CDE5 		strb	r2, [sp, #120]
2165:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6352              		.loc 1 2165 0
 6353 37e0 68508DE5 		str	r5, [sp, #104]
2166:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6354              		.loc 1 2166 0
 6355 37e4 6C508DE5 		str	r5, [sp, #108]
2167:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6356              		.loc 1 2167 0
 6357 37e8 70508DE5 		str	r5, [sp, #112]
2170:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6358              		.loc 1 2170 0
 6359 37ec FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6360              	.LVL523:
2171:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6361              		.loc 1 2171 0
 6362 37f0 002050E2 		subs	r2, r0, #0
 6363 37f4 C201001A 		bne	.L593
2184:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6364              		.loc 1 2184 0
 6365 37f8 1400A0E3 		mov	r0, #20
 6366              	.LVL524:
 6367 37fc 68108DE2 		add	r1, sp, #104
2182:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6368              		.loc 1 2182 0
 6369 3800 74208DE5 		str	r2, [sp, #116]
2183:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6370              		.loc 1 2183 0
 6371 3804 7820CDE5 		strb	r2, [sp, #120]
2179:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6372              		.loc 1 2179 0
 6373 3808 68508DE5 		str	r5, [sp, #104]
2180:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6374              		.loc 1 2180 0
 6375 380c 6C508DE5 		str	r5, [sp, #108]
2181:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6376              		.loc 1 2181 0
 6377 3810 70508DE5 		str	r5, [sp, #112]
2184:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6378              		.loc 1 2184 0
 6379 3814 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6380              	.LVL525:
2185:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6381              		.loc 1 2185 0
 6382 3818 002050E2 		subs	r2, r0, #0
 6383 381c CA01001A 		bne	.L594
2198:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6384              		.loc 1 2198 0
 6385 3820 1800A0E3 		mov	r0, #24
 6386              	.LVL526:
 6387 3824 68108DE2 		add	r1, sp, #104
2193:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6388              		.loc 1 2193 0
 6389 3828 68208DE5 		str	r2, [sp, #104]
2194:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6390              		.loc 1 2194 0
 6391 382c 6C208DE5 		str	r2, [sp, #108]
2195:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6392              		.loc 1 2195 0
 6393 3830 70208DE5 		str	r2, [sp, #112]
2197:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6394              		.loc 1 2197 0
 6395 3834 7820CDE5 		strb	r2, [sp, #120]
2196:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6396              		.loc 1 2196 0
 6397 3838 74508DE5 		str	r5, [sp, #116]
2198:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6398              		.loc 1 2198 0
 6399 383c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6400              	.LVL527:
2199:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6401              		.loc 1 2199 0
 6402 3840 002050E2 		subs	r2, r0, #0
 6403 3844 A501001A 		bne	.L595
2211:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6404              		.loc 1 2211 0
 6405 3848 0500A0E1 		mov	r0, r5
 6406              	.LVL528:
 6407 384c 7C108DE2 		add	r1, sp, #124
2208:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6408              		.loc 1 2208 0
 6409 3850 84208DE5 		str	r2, [sp, #132]
2209:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6410              		.loc 1 2209 0
 6411 3854 80208DE5 		str	r2, [sp, #128]
2206:../uvc.c      ****     pibclock.clkDiv      = 2;
 6412              		.loc 1 2206 0
 6413 3858 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2207:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6414              		.loc 1 2207 0
 6415 385c 8870CDE5 		strb	r7, [sp, #136]
2211:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6416              		.loc 1 2211 0
 6417 3860 FEFFFFEB 		bl	CyU3PPibInit
 6418              	.LVL529:
2212:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6419              		.loc 1 2212 0
 6420 3864 002050E2 		subs	r2, r0, #0
 6421 3868 9301001A 		bne	.L596
2219:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6422              		.loc 1 2219 0
 6423 386c 00099FE5 		ldr	r0, .L614+24
 6424              	.LVL530:
 6425 3870 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6426              	.LVL531:
2227:../uvc.c      ****     SensorReset ();
 6427              		.loc 1 2227 0
 6428 3874 FEFFFFEB 		bl	SensorReset
2228:../uvc.c      ****     CyU3PThreadSleep(5000);
 6429              		.loc 1 2228 0
 6430 3878 F8089FE5 		ldr	r0, .L614+28
 6431 387c FEFFFFEB 		bl	_tx_thread_sleep
2232:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6432              		.loc 1 2232 0
 6433 3880 FEFFFFEB 		bl	CyU3PUsbStart
 6434              	.LVL532:
2233:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6435              		.loc 1 2233 0
 6436 3884 002050E2 		subs	r2, r0, #0
 6437 3888 8201001A 		bne	.L597
2239:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6438              		.loc 1 2239 0
 6439 388c 0010A0E3 		mov	r1, #0
 6440 3890 E4089FE5 		ldr	r0, .L614+32
 6441              	.LVL533:
 6442 3894 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6443              	.LVL534:
2242:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6444              		.loc 1 2242 0
 6445 3898 E0089FE5 		ldr	r0, .L614+36
 6446 389c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2248:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6447              		.loc 1 2248 0
 6448 38a0 0010A0E3 		mov	r1, #0
 6449 38a4 D8289FE5 		ldr	r2, .L614+40
 6450 38a8 0100A0E3 		mov	r0, #1
 6451 38ac FEFFFFEB 		bl	CyU3PUsbSetDesc
2249:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6452              		.loc 1 2249 0
 6453 38b0 0000A0E3 		mov	r0, #0
 6454 38b4 0010A0E1 		mov	r1, r0
 6455 38b8 C8289FE5 		ldr	r2, .L614+44
 6456 38bc FEFFFFEB 		bl	CyU3PUsbSetDesc
2252:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6457              		.loc 1 2252 0
 6458 38c0 0010A0E3 		mov	r1, #0
 6459 38c4 C0289FE5 		ldr	r2, .L614+48
 6460 38c8 0200A0E3 		mov	r0, #2
 6461 38cc FEFFFFEB 		bl	CyU3PUsbSetDesc
2253:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6462              		.loc 1 2253 0
 6463 38d0 0010A0E3 		mov	r1, #0
 6464 38d4 B4289FE5 		ldr	r2, .L614+52
 6465 38d8 0700A0E3 		mov	r0, #7
 6466 38dc FEFFFFEB 		bl	CyU3PUsbSetDesc
2256:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6467              		.loc 1 2256 0
 6468 38e0 0010A0E3 		mov	r1, #0
 6469 38e4 A8289FE5 		ldr	r2, .L614+56
 6470 38e8 0400A0E3 		mov	r0, #4
 6471 38ec FEFFFFEB 		bl	CyU3PUsbSetDesc
2257:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6472              		.loc 1 2257 0
 6473 38f0 0010A0E3 		mov	r1, #0
 6474 38f4 9C289FE5 		ldr	r2, .L614+60
 6475 38f8 0300A0E3 		mov	r0, #3
 6476 38fc FEFFFFEB 		bl	CyU3PUsbSetDesc
2258:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6477              		.loc 1 2258 0
 6478 3900 0010A0E3 		mov	r1, #0
 6479 3904 90289FE5 		ldr	r2, .L614+64
 6480 3908 0600A0E3 		mov	r0, #6
 6481 390c FEFFFFEB 		bl	CyU3PUsbSetDesc
2261:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6482              		.loc 1 2261 0
 6483 3910 0010A0E3 		mov	r1, #0
 6484 3914 84289FE5 		ldr	r2, .L614+68
 6485 3918 0500A0E3 		mov	r0, #5
 6486 391c FEFFFFEB 		bl	CyU3PUsbSetDesc
2262:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6487              		.loc 1 2262 0
 6488 3920 0110A0E3 		mov	r1, #1
 6489 3924 78289FE5 		ldr	r2, .L614+72
 6490 3928 0500A0E3 		mov	r0, #5
 6491 392c FEFFFFEB 		bl	CyU3PUsbSetDesc
2263:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6492              		.loc 1 2263 0
 6493 3930 0210A0E3 		mov	r1, #2
 6494 3934 6C289FE5 		ldr	r2, .L614+76
 6495 3938 0500A0E3 		mov	r0, #5
 6496 393c FEFFFFEB 		bl	CyU3PUsbSetDesc
2273:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6497              		.loc 1 2273 0
 6498 3940 0080A0E3 		mov	r8, #0
2270:../uvc.c      ****     endPointConfig.enable   = 1;
 6499              		.loc 1 2270 0
 6500 3944 0150A0E3 		mov	r5, #1
2272:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6501              		.loc 1 2272 0
 6502 3948 4070A0E3 		mov	r7, #64	@ movhi
2276:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6503              		.loc 1 2276 0
 6504 394c 8200A0E3 		mov	r0, #130
 6505 3950 A8108DE2 		add	r1, sp, #168
2271:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6506              		.loc 1 2271 0
 6507 3954 03A0A0E3 		mov	sl, #3
2272:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6508              		.loc 1 2272 0
 6509 3958 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2270:../uvc.c      ****     endPointConfig.enable   = 1;
 6510              		.loc 1 2270 0
 6511 395c A8508DE5 		str	r5, [sp, #168]
2271:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6512              		.loc 1 2271 0
 6513 3960 ACA0CDE5 		strb	sl, [sp, #172]
2273:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6514              		.loc 1 2273 0
 6515 3964 B380CDE5 		strb	r8, [sp, #179]
2274:../uvc.c      ****     endPointConfig.streams  = 0;
 6516              		.loc 1 2274 0
 6517 3968 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2275:../uvc.c      ****     endPointConfig.burstLen = 1;
 6518              		.loc 1 2275 0
 6519 396c B250CDE5 		strb	r5, [sp, #178]
2276:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6520              		.loc 1 2276 0
 6521 3970 FEFFFFEB 		bl	CyU3PSetEpConfig
 6522              	.LVL535:
2274:../uvc.c      ****     endPointConfig.streams  = 0;
 6523              		.loc 1 2274 0
 6524 3974 0870A0E1 		mov	r7, r8	@ movhi
2277:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6525              		.loc 1 2277 0
 6526 3978 003050E2 		subs	r3, r0, #0
 6527 397c 3B01001A 		bne	.L598
2287:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6528              		.loc 1 2287 0
 6529 3980 24C89FE5 		ldr	ip, .L614+80
2288:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6530              		.loc 1 2288 0
 6531 3984 24E89FE5 		ldr	lr, .L614+84
2285:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6532              		.loc 1 2285 0
 6533 3988 016BA0E3 		mov	r6, #1024	@ movhi
2294:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6534              		.loc 1 2294 0
 6535 398c 1080A0E3 		mov	r8, #16
2296:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6536              		.loc 1 2296 0
 6537 3990 1C089FE5 		ldr	r0, .L614+88
 6538              	.LVL536:
 6539 3994 0410A0E3 		mov	r1, #4
 6540 3998 34208DE2 		add	r2, sp, #52
2285:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6541              		.loc 1 2285 0
 6542 399c B463CDE1 		strh	r6, [sp, #52]	@ movhi
2286:../uvc.c      ****     dmaInterConfig.count          = 1;
 6543              		.loc 1 2286 0
 6544 39a0 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2287:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6545              		.loc 1 2287 0
 6546 39a4 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2288:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6547              		.loc 1 2288 0
 6548 39a8 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2289:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6549              		.loc 1 2289 0
 6550 39ac BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2290:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6551              		.loc 1 2290 0
 6552 39b0 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2291:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6553              		.loc 1 2291 0
 6554 39b4 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2292:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6555              		.loc 1 2292 0
 6556 39b8 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2293:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6557              		.loc 1 2293 0
 6558 39bc 4470CDE5 		strb	r7, [sp, #68]
2294:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6559              		.loc 1 2294 0
 6560 39c0 48808DE5 		str	r8, [sp, #72]
2295:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6561              		.loc 1 2295 0
 6562 39c4 4C308DE5 		str	r3, [sp, #76]
2296:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6563              		.loc 1 2296 0
 6564 39c8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6565              	.LVL537:
2298:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6566              		.loc 1 2298 0
 6567 39cc 006050E2 		subs	r6, r0, #0
 6568 39d0 DF00001A 		bne	.L599
2305:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6569              		.loc 1 2305 0
 6570 39d4 010BA0E3 		mov	r0, #1024
 6571              	.LVL538:
 6572 39d8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6573 39dc D4179FE5 		ldr	r1, .L614+92
2306:../uvc.c      ****     if (glInterStaBuffer == 0)
 6574              		.loc 1 2306 0
 6575 39e0 000050E3 		cmp	r0, #0
2305:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6576              		.loc 1 2305 0
 6577 39e4 000081E5 		str	r0, [r1, #0]
2306:../uvc.c      ****     if (glInterStaBuffer == 0)
 6578              		.loc 1 2306 0
 6579 39e8 D000000A 		beq	.L600
2313:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6580              		.loc 1 2313 0
 6581 39ec 0610A0E1 		mov	r1, r6
 6582 39f0 0620A0E1 		mov	r2, r6
 6583 39f4 3830A0E3 		mov	r3, #56
 6584 39f8 BC079FE5 		ldr	r0, .L614+96
 6585 39fc FEFFFFEB 		bl	_txe_mutex_create
2315:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6586              		.loc 1 2315 0
 6587 3a00 0430A0E3 		mov	r3, #4	@ movhi
 6588 3a04 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2318:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6589              		.loc 1 2318 0
 6590 3a08 B0379FE5 		ldr	r3, .L614+100
2314:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6591              		.loc 1 2314 0
 6592 3a0c 01C9A0E3 		mov	ip, #16384	@ movhi
 6593 3a10 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2317:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6594              		.loc 1 2317 0
 6595 3a14 01CCA0E3 		mov	ip, #256	@ movhi
 6596 3a18 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2318:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6597              		.loc 1 2318 0
 6598 3a1c B431CDE1 		strh	r3, [sp, #20]	@ movhi
2319:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6599              		.loc 1 2319 0
 6600 3a20 9CC79FE5 		ldr	ip, .L614+104
2321:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6601              		.loc 1 2321 0
 6602 3a24 0C30A0E3 		mov	r3, #12	@ movhi
 6603 3a28 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2326:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6604              		.loc 1 2326 0
 6605 3a2c 94379FE5 		ldr	r3, .L614+108
2327:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6606              		.loc 1 2327 0
 6607 3a30 0C208DE2 		add	r2, sp, #12
2319:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6608              		.loc 1 2319 0
 6609 3a34 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2324:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6610              		.loc 1 2324 0
 6611 3a38 2A70CDE5 		strb	r7, [sp, #42]
2322:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6612              		.loc 1 2322 0
 6613 3a3c 04C0A0E3 		mov	ip, #4	@ movhi
2316:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6614              		.loc 1 2316 0
 6615 3a40 02A0A0E3 		mov	sl, #2	@ movhi
2327:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6616              		.loc 1 2327 0
 6617 3a44 80079FE5 		ldr	r0, .L614+112
 6618 3a48 0710A0E3 		mov	r1, #7
2325:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6619              		.loc 1 2325 0
 6620 3a4c 1870A0E3 		mov	r7, #24
2316:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6621              		.loc 1 2316 0
 6622 3a50 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2320:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6623              		.loc 1 2320 0
 6624 3a54 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2322:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6625              		.loc 1 2322 0
 6626 3a58 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2323:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6627              		.loc 1 2323 0
 6628 3a5c B862CDE1 		strh	r6, [sp, #40]	@ movhi
2325:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6629              		.loc 1 2325 0
 6630 3a60 2C708DE5 		str	r7, [sp, #44]
2326:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6631              		.loc 1 2326 0
 6632 3a64 30308DE5 		str	r3, [sp, #48]
2327:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6633              		.loc 1 2327 0
 6634 3a68 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6635              	.LVL539:
2329:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6636              		.loc 1 2329 0
 6637 3a6c 002050E2 		subs	r2, r0, #0
 6638 3a70 A500001A 		bne	.L601
2420:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6639              		.loc 1 2420 0
 6640 3a74 0500A0E1 		mov	r0, r5
 6641              	.LVL540:
 6642 3a78 0510A0E1 		mov	r1, r5
 6643 3a7c FEFFFFEB 		bl	CyU3PConnectState
 6644              	.LVL541:
2421:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6645              		.loc 1 2421 0
 6646 3a80 002050E2 		subs	r2, r0, #0
 6647 3a84 9700001A 		bne	.L602
2427:../uvc.c      ****     CyU3PBusyWait(100);
 6648              		.loc 1 2427 0
 6649 3a88 6400A0E3 		mov	r0, #100
 6650              	.LVL542:
 6651 3a8c FEFFFFEB 		bl	CyU3PBusyWait
 6652              	.LVL543:
2429:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6653              		.loc 1 2429 0
 6654 3a90 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2443:../uvc.c      ****     endPointConfig.streams  = 0;
 6655              		.loc 1 2443 0
 6656 3a94 0020A0E3 		mov	r2, #0	@ movhi
2432:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6657              		.loc 1 2432 0
 6658 3a98 ACA0CDE5 		strb	sl, [sp, #172]
2444:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6659              		.loc 1 2444 0
 6660 3a9c A8108DE2 		add	r1, sp, #168
2443:../uvc.c      ****     endPointConfig.streams  = 0;
 6661              		.loc 1 2443 0
 6662 3aa0 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2431:../uvc.c      ****     endPointConfig.enable   = 1;
 6663              		.loc 1 2431 0
 6664 3aa4 A8508DE5 		str	r5, [sp, #168]
2433:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6665              		.loc 1 2433 0
 6666 3aa8 030050E3 		cmp	r0, #3
2429:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6667              		.loc 1 2429 0
 6668 3aac 4800C4E5 		strb	r0, [r4, #72]
2440:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6669              		.loc 1 2440 0
 6670 3ab0 020CA013 		movne	r0, #512	@ movhi
2435:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6671              		.loc 1 2435 0
 6672 3ab4 01ABA003 		moveq	sl, #1024	@ movhi
2440:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6673              		.loc 1 2440 0
 6674 3ab8 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2444:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6675              		.loc 1 2444 0
 6676 3abc 8300A0E3 		mov	r0, #131
2435:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6677              		.loc 1 2435 0
 6678 3ac0 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2436:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6679              		.loc 1 2436 0
 6680 3ac4 B280CD05 		streqb	r8, [sp, #178]
2441:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6681              		.loc 1 2441 0
 6682 3ac8 B250CD15 		strneb	r5, [sp, #178]
2444:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6683              		.loc 1 2444 0
 6684 3acc FEFFFFEB 		bl	CyU3PSetEpConfig
 6685              	.LVL544:
2445:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6686              		.loc 1 2445 0
 6687 3ad0 002050E2 		subs	r2, r0, #0
 6688 3ad4 4F00001A 		bne	.L585
 6689 3ad8 F0769FE5 		ldr	r7, .L614+116
 6690              	.LBE225:
 6691              	.LBE222:
2568:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6692              		.loc 1 2568 0
 6693 3adc 8C569FE5 		ldr	r5, .L614+20
 6694 3ae0 0260A0E1 		mov	r6, r2
2752:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6695              		.loc 1 2752 0
 6696 3ae4 0080E0E3 		mvn	r8, #0
 6697              	.LVL545:
 6698              	.L548:
2568:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6699              		.loc 1 2568 0
 6700 3ae8 80069FE5 		ldr	r0, .L614+20
 6701 3aec 0110A0E3 		mov	r1, #1
 6702 3af0 0220A0E3 		mov	r2, #2
 6703 3af4 B4308DE2 		add	r3, sp, #180
 6704 3af8 00608DE5 		str	r6, [sp, #0]
 6705 3afc FEFFFFEB 		bl	_txe_event_flags_get
 6706 3b00 000050E3 		cmp	r0, #0
 6707 3b04 3000001A 		bne	.L550
2614:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6708              		.loc 1 2614 0
 6709 3b08 3CE095E5 		ldr	lr, [r5, #60]
 6710 3b0c 00005EE3 		cmp	lr, #0
 6711 3b10 0300000A 		beq	.L551
2614:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6712              		.loc 1 2614 0 is_stmt 0 discriminator 1
 6713 3b14 B014D5E1 		ldrh	r1, [r5, #64]
 6714 3b18 B234D5E1 		ldrh	r3, [r5, #66]
 6715 3b1c 030051E1 		cmp	r1, r3
 6716 3b20 1201000A 		beq	.L603
 6717              	.L551:
2813:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6718              		.loc 1 2813 0 is_stmt 1
 6719 3b24 4010A0E3 		mov	r1, #64
 6720 3b28 0020A0E3 		mov	r2, #0
 6721 3b2c 3C069FE5 		ldr	r0, .L614+20
 6722 3b30 FEFFFFEB 		bl	_txe_event_flags_set
2816:../uvc.c      ****         CyU3PThreadRelinquish ();
 6723              		.loc 1 2816 0
 6724 3b34 FEFFFFEB 		bl	_txe_thread_relinquish
2817:../uvc.c      ****     }
 6725              		.loc 1 2817 0
 6726 3b38 EAFFFFEA 		b	.L548
 6727              	.LVL546:
 6728              	.L588:
 6729              	.LBB260:
 6730              	.LBB224:
2117:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6731              		.loc 1 2117 0
 6732 3b3c 0400A0E3 		mov	r0, #4
 6733              	.LVL547:
 6734 3b40 8C169FE5 		ldr	r1, .L614+120
 6735 3b44 FEFFFFEB 		bl	CyU3PDebugPrint
 6736              	.LVL548:
 6737              	.L517:
 6738              	.LBB240:
 6739              	.LBB241:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6740              		.loc 1 1546 0
 6741 3b48 88169FE5 		ldr	r1, .L614+124
 6742 3b4c 0400A0E3 		mov	r0, #4
 6743 3b50 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6744              		.loc 1 1547 0
 6745 3b54 FA0FA0E3 		mov	r0, #1000
 6746 3b58 FEFFFFEB 		bl	_tx_thread_sleep
 6747 3b5c F9FFFFEA 		b	.L517
 6748              	.LVL549:
 6749              	.L590:
 6750              	.LBE241:
 6751              	.LBE240:
2148:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6752              		.loc 1 2148 0
 6753 3b60 0400A0E3 		mov	r0, #4
 6754              	.LVL550:
 6755 3b64 70169FE5 		ldr	r1, .L614+128
 6756 3b68 FEFFFFEB 		bl	CyU3PDebugPrint
 6757              	.LVL551:
 6758              	.L521:
 6759              	.LBB238:
 6760              	.LBB239:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6761              		.loc 1 1546 0
 6762 3b6c 64169FE5 		ldr	r1, .L614+124
 6763 3b70 0400A0E3 		mov	r0, #4
 6764 3b74 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6765              		.loc 1 1547 0
 6766 3b78 FA0FA0E3 		mov	r0, #1000
 6767 3b7c FEFFFFEB 		bl	_tx_thread_sleep
 6768 3b80 F9FFFFEA 		b	.L521
 6769              	.LVL552:
 6770              	.L589:
 6771              	.LBE239:
 6772              	.LBE238:
2139:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6773              		.loc 1 2139 0
 6774 3b84 0400A0E3 		mov	r0, #4
 6775              	.LVL553:
 6776 3b88 50169FE5 		ldr	r1, .L614+132
 6777 3b8c FEFFFFEB 		bl	CyU3PDebugPrint
 6778              	.LVL554:
 6779              	.L519:
 6780              	.LBB236:
 6781              	.LBB237:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6782              		.loc 1 1546 0
 6783 3b90 40169FE5 		ldr	r1, .L614+124
 6784 3b94 0400A0E3 		mov	r0, #4
 6785 3b98 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6786              		.loc 1 1547 0
 6787 3b9c FA0FA0E3 		mov	r0, #1000
 6788 3ba0 FEFFFFEB 		bl	_tx_thread_sleep
 6789 3ba4 F9FFFFEA 		b	.L519
 6790              	.LVL555:
 6791              	.L591:
 6792              	.LBE237:
 6793              	.LBE236:
2154:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6794              		.loc 1 2154 0
 6795 3ba8 0400A0E3 		mov	r0, #4
 6796              	.LVL556:
 6797 3bac 30169FE5 		ldr	r1, .L614+136
 6798 3bb0 FEFFFFEB 		bl	CyU3PDebugPrint
 6799              	.LVL557:
 6800              	.L523:
 6801              	.LBB234:
 6802              	.LBB235:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6803              		.loc 1 1546 0
 6804 3bb4 1C169FE5 		ldr	r1, .L614+124
 6805 3bb8 0400A0E3 		mov	r0, #4
 6806 3bbc FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6807              		.loc 1 1547 0
 6808 3bc0 FA0FA0E3 		mov	r0, #1000
 6809 3bc4 FEFFFFEB 		bl	_tx_thread_sleep
 6810 3bc8 F9FFFFEA 		b	.L523
 6811              	.LVL558:
 6812              	.L550:
 6813              	.LBE235:
 6814              	.LBE234:
 6815              	.LBE224:
 6816              	.LBE260:
2720:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6817              		.loc 1 2720 0
 6818 3bcc 9C059FE5 		ldr	r0, .L614+20
 6819 3bd0 0210A0E3 		mov	r1, #2
 6820 3bd4 0320A0E3 		mov	r2, #3
 6821 3bd8 B4308DE2 		add	r3, sp, #180
 6822 3bdc 00608DE5 		str	r6, [sp, #0]
 6823 3be0 FEFFFFEB 		bl	_txe_event_flags_get
 6824 3be4 000050E3 		cmp	r0, #0
 6825 3be8 2500001A 		bne	.L566
2735:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6826              		.loc 1 2735 0
 6827 3bec 441095E5 		ldr	r1, [r5, #68]
2723:../uvc.c      ****                 hitFV     = CyFalse;
 6828              		.loc 1 2723 0
 6829 3bf0 3C6085E5 		str	r6, [r5, #60]
2735:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6830              		.loc 1 2735 0
 6831 3bf4 000051E3 		cmp	r1, #0
2724:../uvc.c      ****                 prodCount = 0;
 6832              		.loc 1 2724 0
 6833 3bf8 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2731:../uvc.c      ****                 fb=0;
 6834              		.loc 1 2731 0
 6835 3bfc B463C5E1 		strh	r6, [r5, #52]	@ movhi
2725:../uvc.c      ****                 consCount = 0;
 6836              		.loc 1 2725 0
 6837 3c00 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2732:../uvc.c      ****                 pb=0;
 6838              		.loc 1 2732 0
 6839 3c04 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2733:../uvc.c      ****                 pbc=0;
 6840              		.loc 1 2733 0
 6841 3c08 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2735:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6842              		.loc 1 2735 0
 6843 3c0c 0A00000A 		beq	.L604
 6844              	.L567:
2747:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6845              		.loc 1 2747 0
 6846 3c10 446084E5 		str	r6, [r4, #68]
 6847 3c14 C2FFFFEA 		b	.L551
 6848              	.LVL559:
 6849              	.L585:
 6850              	.LBB261:
 6851              	.LBB258:
2448:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6852              		.loc 1 2448 0
 6853 3c18 0400A0E3 		mov	r0, #4
 6854              	.LVL560:
 6855 3c1c C4159FE5 		ldr	r1, .L614+140
 6856 3c20 FEFFFFEB 		bl	CyU3PDebugPrint
 6857              	.LVL561:
 6858              	.L549:
 6859              	.LBB242:
 6860              	.LBB243:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6861              		.loc 1 1546 0
 6862 3c24 AC159FE5 		ldr	r1, .L614+124
 6863 3c28 0400A0E3 		mov	r0, #4
 6864 3c2c FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6865              		.loc 1 1547 0
 6866 3c30 FA0FA0E3 		mov	r0, #1000
 6867 3c34 FEFFFFEB 		bl	_tx_thread_sleep
 6868 3c38 F9FFFFEA 		b	.L549
 6869              	.LVL562:
 6870              	.L604:
 6871              	.LBE243:
 6872              	.LBE242:
 6873              	.LBE258:
 6874              	.LBE261:
2737:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6875              		.loc 1 2737 0
 6876 3c3c 88059FE5 		ldr	r0, .L614+112
 6877 3c40 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6878              	.LVL563:
2738:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6879              		.loc 1 2738 0
 6880 3c44 000050E3 		cmp	r0, #0
 6881 3c48 0200001A 		bne	.L586
2744:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6882              		.loc 1 2744 0
 6883 3c4c 8300A0E3 		mov	r0, #131
 6884              	.LVL564:
 6885 3c50 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6886 3c54 EDFFFFEA 		b	.L567
 6887              	.L586:
 6888              	.LBB262:
 6889              	.LBB263:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6890              		.loc 1 1546 0
 6891 3c58 78159FE5 		ldr	r1, .L614+124
 6892 3c5c 0400A0E3 		mov	r0, #4
 6893 3c60 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6894              		.loc 1 1547 0
 6895 3c64 FA0FA0E3 		mov	r0, #1000
 6896 3c68 FEFFFFEB 		bl	_tx_thread_sleep
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6897              		.loc 1 1546 0
 6898 3c6c 64159FE5 		ldr	r1, .L614+124
 6899 3c70 0400A0E3 		mov	r0, #4
 6900 3c74 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6901              		.loc 1 1547 0
 6902 3c78 FA0FA0E3 		mov	r0, #1000
 6903 3c7c FEFFFFEB 		bl	_tx_thread_sleep
 6904 3c80 F4FFFFEA 		b	.L586
 6905              	.L566:
 6906              	.LBE263:
 6907              	.LBE262:
2752:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6908              		.loc 1 2752 0
 6909 3c84 0110A0E3 		mov	r1, #1
 6910 3c88 0220A0E3 		mov	r2, #2
 6911 3c8c B4308DE2 		add	r3, sp, #180
 6912 3c90 D8049FE5 		ldr	r0, .L614+20
 6913 3c94 00808DE5 		str	r8, [sp, #0]
 6914 3c98 FEFFFFEB 		bl	_txe_event_flags_get
2756:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6915              		.loc 1 2756 0
 6916 3c9c 0620A0E1 		mov	r2, r6
 6917 3ca0 24059FE5 		ldr	r0, .L614+112
 6918 3ca4 0610A0E1 		mov	r1, r6
 6919 3ca8 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6920              	.LVL565:
2757:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6921              		.loc 1 2757 0
 6922 3cac 002050E2 		subs	r2, r0, #0
 6923 3cb0 6500001A 		bne	.L605
2765:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6924              		.loc 1 2765 0
 6925 3cb4 282095E5 		ldr	r2, [r5, #40]
 6926 3cb8 000052E3 		cmp	r2, #0
 6927 3cbc 5A00001A 		bne	.L572
 6928              	.LVL566:
 6929              	.LBB264:
 6930              	.LBB265:
2473:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6931              		.loc 1 2473 0
 6932 3cc0 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6933 3cc4 030053E3 		cmp	r3, #3
 6934 3cc8 4700000A 		beq	.L606
2478:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6935              		.loc 1 2478 0
 6936 3ccc 020053E3 		cmp	r3, #2
 6937 3cd0 2900000A 		beq	.L607
 6938              	.LVL567:
 6939              	.L575:
 6940              	.LBE265:
 6941              	.LBE264:
2801:../uvc.c      ****                     gpif_initialized = CyTrue;
 6942              		.loc 1 2801 0
 6943 3cd4 01E0A0E3 		mov	lr, #1
 6944 3cd8 28E084E5 		str	lr, [r4, #40]
2802:../uvc.c      ****                     CyU3PThreadSleep(200);
 6945              		.loc 1 2802 0
 6946 3cdc C800A0E3 		mov	r0, #200
 6947 3ce0 FEFFFFEB 		bl	_tx_thread_sleep
 6948 3ce4 8EFFFFEA 		b	.L551
 6949              	.LVL568:
 6950              	.L602:
 6951              	.LBB271:
 6952              	.LBB223:
2423:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6953              		.loc 1 2423 0
 6954 3ce8 0400A0E3 		mov	r0, #4
 6955              	.LVL569:
 6956 3cec F8149FE5 		ldr	r1, .L614+144
 6957 3cf0 FEFFFFEB 		bl	CyU3PDebugPrint
 6958              	.LVL570:
 6959              	.L545:
 6960              	.LBB232:
 6961              	.LBB233:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6962              		.loc 1 1546 0
 6963 3cf4 DC149FE5 		ldr	r1, .L614+124
 6964 3cf8 0400A0E3 		mov	r0, #4
 6965 3cfc FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6966              		.loc 1 1547 0
 6967 3d00 FA0FA0E3 		mov	r0, #1000
 6968 3d04 FEFFFFEB 		bl	_tx_thread_sleep
 6969 3d08 F9FFFFEA 		b	.L545
 6970              	.LVL571:
 6971              	.L601:
 6972              	.LBE233:
 6973              	.LBE232:
2332:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6974              		.loc 1 2332 0
 6975 3d0c 0400A0E3 		mov	r0, #4
 6976              	.LVL572:
 6977 3d10 D8149FE5 		ldr	r1, .L614+148
 6978 3d14 FEFFFFEB 		bl	CyU3PDebugPrint
 6979              	.LVL573:
 6980              	.L543:
 6981              	.LBB230:
 6982              	.LBB231:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6983              		.loc 1 1546 0
 6984 3d18 B8149FE5 		ldr	r1, .L614+124
 6985 3d1c 0400A0E3 		mov	r0, #4
 6986 3d20 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 6987              		.loc 1 1547 0
 6988 3d24 FA0FA0E3 		mov	r0, #1000
 6989 3d28 FEFFFFEB 		bl	_tx_thread_sleep
 6990 3d2c F9FFFFEA 		b	.L543
 6991              	.LVL574:
 6992              	.L600:
 6993              	.LBE231:
 6994              	.LBE230:
2308:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6995              		.loc 1 2308 0
 6996 3d30 040080E2 		add	r0, r0, #4
 6997 3d34 B8149FE5 		ldr	r1, .L614+152
 6998 3d38 FEFFFFEB 		bl	CyU3PDebugPrint
 6999              	.LVL575:
 7000              	.L541:
 7001              	.LBB228:
 7002              	.LBB229:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7003              		.loc 1 1546 0
 7004 3d3c 94149FE5 		ldr	r1, .L614+124
 7005 3d40 0400A0E3 		mov	r0, #4
 7006 3d44 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7007              		.loc 1 1547 0
 7008 3d48 FA0FA0E3 		mov	r0, #1000
 7009 3d4c FEFFFFEB 		bl	_tx_thread_sleep
 7010 3d50 F9FFFFEA 		b	.L541
 7011              	.LVL576:
 7012              	.L599:
 7013              	.LBE229:
 7014              	.LBE228:
2301:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 7015              		.loc 1 2301 0
 7016 3d54 0400A0E3 		mov	r0, #4
 7017 3d58 98149FE5 		ldr	r1, .L614+156
 7018 3d5c 0620A0E1 		mov	r2, r6
 7019 3d60 FEFFFFEB 		bl	CyU3PDebugPrint
 7020              	.L539:
 7021              	.LBB226:
 7022              	.LBB227:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7023              		.loc 1 1546 0
 7024 3d64 6C149FE5 		ldr	r1, .L614+124
 7025 3d68 0400A0E3 		mov	r0, #4
 7026 3d6c FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7027              		.loc 1 1547 0
 7028 3d70 FA0FA0E3 		mov	r0, #1000
 7029 3d74 FEFFFFEB 		bl	_tx_thread_sleep
 7030 3d78 F9FFFFEA 		b	.L539
 7031              	.LVL577:
 7032              	.L607:
 7033              	.LBE227:
 7034              	.LBE226:
 7035              	.LBE223:
 7036              	.LBE271:
 7037              	.LBB272:
 7038              	.LBB270:
2480:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7039              		.loc 1 2480 0
 7040 3d7c 78149FE5 		ldr	r1, .L614+160
 7041 3d80 0100A0E3 		mov	r0, #1
 7042              	.LVL578:
 7043 3d84 FEFFFFEB 		bl	CyU3PDebugPrint
2481:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7044              		.loc 1 2481 0
 7045 3d88 70049FE5 		ldr	r0, .L614+164
 7046 3d8c FEFFFFEB 		bl	CyU3PGpifLoad
 7047 3d90 0020A0E1 		mov	r2, r0
 7048              	.LVL579:
 7049              	.L574:
2483:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7050              		.loc 1 2483 0
 7051 3d94 000052E3 		cmp	r2, #0
 7052 3d98 1A00001A 		bne	.L608
2491:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7053              		.loc 1 2491 0
 7054 3d9c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7055 3da0 030053E3 		cmp	r3, #3
 7056 3da4 0100000A 		beq	.L587
2495:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7057              		.loc 1 2495 0
 7058 3da8 020053E3 		cmp	r3, #2
 7059 3dac C8FFFF1A 		bne	.L575
 7060              	.L587:
2497:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7061              		.loc 1 2497 0
 7062 3db0 0200A0E1 		mov	r0, r2
 7063              	.LVL580:
 7064 3db4 0210A0E1 		mov	r1, r2
 7065 3db8 FEFFFFEB 		bl	CyU3PGpifSMStart
 7066              	.LVL581:
2499:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7067              		.loc 1 2499 0
 7068 3dbc 000050E3 		cmp	r0, #0
2497:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7069              		.loc 1 2497 0
 7070 3dc0 0020A0E1 		mov	r2, r0
 7071              	.LVL582:
2499:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7072              		.loc 1 2499 0
 7073 3dc4 C2FFFF0A 		beq	.L575
2502:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7074              		.loc 1 2502 0
 7075 3dc8 0400A0E3 		mov	r0, #4
 7076              	.LVL583:
 7077 3dcc 30149FE5 		ldr	r1, .L614+168
 7078 3dd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7079              	.LVL584:
 7080              	.L580:
 7081              	.LBB266:
 7082              	.LBB267:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7083              		.loc 1 1546 0
 7084 3dd4 FC139FE5 		ldr	r1, .L614+124
 7085 3dd8 0400A0E3 		mov	r0, #4
 7086 3ddc FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7087              		.loc 1 1547 0
 7088 3de0 FA0FA0E3 		mov	r0, #1000
 7089 3de4 FEFFFFEB 		bl	_tx_thread_sleep
 7090 3de8 F9FFFFEA 		b	.L580
 7091              	.LVL585:
 7092              	.L606:
 7093              	.LBE267:
 7094              	.LBE266:
2475:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7095              		.loc 1 2475 0
 7096 3dec 14149FE5 		ldr	r1, .L614+172
 7097 3df0 0100A0E3 		mov	r0, #1
 7098              	.LVL586:
 7099 3df4 FEFFFFEB 		bl	CyU3PDebugPrint
2476:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7100              		.loc 1 2476 0
 7101 3df8 0C049FE5 		ldr	r0, .L614+176
 7102 3dfc FEFFFFEB 		bl	CyU3PGpifLoad
 7103 3e00 0020A0E1 		mov	r2, r0
 7104              	.LVL587:
 7105 3e04 E2FFFFEA 		b	.L574
 7106              	.L608:
2486:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7107              		.loc 1 2486 0
 7108 3e08 0400A0E3 		mov	r0, #4
 7109              	.LVL588:
 7110 3e0c FC139FE5 		ldr	r1, .L614+180
 7111 3e10 FEFFFFEB 		bl	CyU3PDebugPrint
 7112              	.LVL589:
 7113              	.L577:
 7114              	.LBB268:
 7115              	.LBB269:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7116              		.loc 1 1546 0
 7117 3e14 BC139FE5 		ldr	r1, .L614+124
 7118 3e18 0400A0E3 		mov	r0, #4
 7119 3e1c FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7120              		.loc 1 1547 0
 7121 3e20 FA0FA0E3 		mov	r0, #1000
 7122 3e24 FEFFFFEB 		bl	_tx_thread_sleep
 7123 3e28 F9FFFFEA 		b	.L577
 7124              	.LVL590:
 7125              	.L572:
 7126              	.LBE269:
 7127              	.LBE268:
 7128              	.LBE270:
 7129              	.LBE272:
2809:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7130              		.loc 1 2809 0
 7131 3e2c 8C039FE5 		ldr	r0, .L614+100
 7132              	.LVL591:
 7133 3e30 02C0A0E3 		mov	ip, #2
 7134 3e34 0610A0E1 		mov	r1, r6
 7135 3e38 0020A0E1 		mov	r2, r0
 7136 3e3c 0630A0E1 		mov	r3, r6
 7137 3e40 00C08DE5 		str	ip, [sp, #0]
 7138 3e44 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7139 3e48 35FFFFEA 		b	.L551
 7140              	.LVL592:
 7141              	.L605:
2760:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7142              		.loc 1 2760 0
 7143 3e4c 0400A0E3 		mov	r0, #4
 7144              	.LVL593:
 7145 3e50 BC139FE5 		ldr	r1, .L614+184
 7146 3e54 FEFFFFEB 		bl	CyU3PDebugPrint
 7147              	.LVL594:
 7148              	.L571:
 7149              	.LBB273:
 7150              	.LBB274:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7151              		.loc 1 1546 0
 7152 3e58 78139FE5 		ldr	r1, .L614+124
 7153 3e5c 0400A0E3 		mov	r0, #4
 7154 3e60 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7155              		.loc 1 1547 0
 7156 3e64 FA0FA0E3 		mov	r0, #1000
 7157 3e68 FEFFFFEB 		bl	_tx_thread_sleep
 7158 3e6c F9FFFFEA 		b	.L571
 7159              	.LVL595:
 7160              	.L598:
 7161              	.LBE274:
 7162              	.LBE273:
 7163              	.LBB275:
 7164              	.LBB259:
2280:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7165              		.loc 1 2280 0
 7166 3e70 0400A0E3 		mov	r0, #4
 7167              	.LVL596:
 7168 3e74 6C139FE5 		ldr	r1, .L614+140
 7169 3e78 0320A0E1 		mov	r2, r3
 7170 3e7c FEFFFFEB 		bl	CyU3PDebugPrint
 7171              	.LVL597:
 7172              	.L537:
 7173              	.LBB244:
 7174              	.LBB245:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7175              		.loc 1 1546 0
 7176 3e80 50139FE5 		ldr	r1, .L614+124
 7177 3e84 0400A0E3 		mov	r0, #4
 7178 3e88 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7179              		.loc 1 1547 0
 7180 3e8c FA0FA0E3 		mov	r0, #1000
 7181 3e90 FEFFFFEB 		bl	_tx_thread_sleep
 7182 3e94 F9FFFFEA 		b	.L537
 7183              	.LVL598:
 7184              	.L597:
 7185              	.LBE245:
 7186              	.LBE244:
2235:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7187              		.loc 1 2235 0
 7188 3e98 0400A0E3 		mov	r0, #4
 7189              	.LVL599:
 7190 3e9c 74139FE5 		ldr	r1, .L614+188
 7191 3ea0 FEFFFFEB 		bl	CyU3PDebugPrint
 7192              	.LVL600:
 7193              	.L535:
 7194              	.LBB246:
 7195              	.LBB247:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7196              		.loc 1 1546 0
 7197 3ea4 2C139FE5 		ldr	r1, .L614+124
 7198 3ea8 0400A0E3 		mov	r0, #4
 7199 3eac FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7200              		.loc 1 1547 0
 7201 3eb0 FA0FA0E3 		mov	r0, #1000
 7202 3eb4 FEFFFFEB 		bl	_tx_thread_sleep
 7203 3eb8 F9FFFFEA 		b	.L535
 7204              	.LVL601:
 7205              	.L596:
 7206              	.LBE247:
 7207              	.LBE246:
2214:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7208              		.loc 1 2214 0
 7209 3ebc 0400A0E3 		mov	r0, #4
 7210              	.LVL602:
 7211 3ec0 54139FE5 		ldr	r1, .L614+192
 7212 3ec4 FEFFFFEB 		bl	CyU3PDebugPrint
 7213              	.LVL603:
 7214              	.L533:
 7215              	.LBB248:
 7216              	.LBB249:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7217              		.loc 1 1546 0
 7218 3ec8 08139FE5 		ldr	r1, .L614+124
 7219 3ecc 0400A0E3 		mov	r0, #4
 7220 3ed0 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7221              		.loc 1 1547 0
 7222 3ed4 FA0FA0E3 		mov	r0, #1000
 7223 3ed8 FEFFFFEB 		bl	_tx_thread_sleep
 7224 3edc F9FFFFEA 		b	.L533
 7225              	.LVL604:
 7226              	.L595:
 7227              	.LBE249:
 7228              	.LBE248:
2201:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7229              		.loc 1 2201 0
 7230 3ee0 0400A0E3 		mov	r0, #4
 7231              	.LVL605:
 7232 3ee4 34139FE5 		ldr	r1, .L614+196
 7233 3ee8 FEFFFFEB 		bl	CyU3PDebugPrint
 7234              	.LVL606:
 7235              	.L531:
 7236              	.LBB250:
 7237              	.LBB251:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7238              		.loc 1 1546 0
 7239 3eec E4129FE5 		ldr	r1, .L614+124
 7240 3ef0 0400A0E3 		mov	r0, #4
 7241 3ef4 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7242              		.loc 1 1547 0
 7243 3ef8 FA0FA0E3 		mov	r0, #1000
 7244 3efc FEFFFFEB 		bl	_tx_thread_sleep
 7245 3f00 F9FFFFEA 		b	.L531
 7246              	.LVL607:
 7247              	.L593:
 7248              	.LBE251:
 7249              	.LBE250:
2173:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7250              		.loc 1 2173 0
 7251 3f04 0400A0E3 		mov	r0, #4
 7252              	.LVL608:
 7253 3f08 14139FE5 		ldr	r1, .L614+200
 7254 3f0c FEFFFFEB 		bl	CyU3PDebugPrint
 7255              	.LVL609:
 7256              	.L527:
 7257              	.LBB252:
 7258              	.LBB253:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7259              		.loc 1 1546 0
 7260 3f10 C0129FE5 		ldr	r1, .L614+124
 7261 3f14 0400A0E3 		mov	r0, #4
 7262 3f18 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7263              		.loc 1 1547 0
 7264 3f1c FA0FA0E3 		mov	r0, #1000
 7265 3f20 FEFFFFEB 		bl	_tx_thread_sleep
 7266 3f24 F9FFFFEA 		b	.L527
 7267              	.LVL610:
 7268              	.L592:
 7269              	.LBE253:
 7270              	.LBE252:
2160:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7271              		.loc 1 2160 0
 7272 3f28 0400A0E3 		mov	r0, #4
 7273              	.LVL611:
 7274 3f2c F4129FE5 		ldr	r1, .L614+204
 7275 3f30 FEFFFFEB 		bl	CyU3PDebugPrint
 7276              	.LVL612:
 7277              	.L525:
 7278              	.LBB254:
 7279              	.LBB255:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7280              		.loc 1 1546 0
 7281 3f34 9C129FE5 		ldr	r1, .L614+124
 7282 3f38 0400A0E3 		mov	r0, #4
 7283 3f3c FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7284              		.loc 1 1547 0
 7285 3f40 FA0FA0E3 		mov	r0, #1000
 7286 3f44 FEFFFFEB 		bl	_tx_thread_sleep
 7287 3f48 F9FFFFEA 		b	.L525
 7288              	.LVL613:
 7289              	.L594:
 7290              	.LBE255:
 7291              	.LBE254:
2187:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7292              		.loc 1 2187 0
 7293 3f4c 0400A0E3 		mov	r0, #4
 7294              	.LVL614:
 7295 3f50 D4129FE5 		ldr	r1, .L614+208
 7296 3f54 FEFFFFEB 		bl	CyU3PDebugPrint
 7297              	.LVL615:
 7298              	.L529:
 7299              	.LBB256:
 7300              	.LBB257:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7301              		.loc 1 1546 0
 7302 3f58 78129FE5 		ldr	r1, .L614+124
 7303 3f5c 0400A0E3 		mov	r0, #4
 7304 3f60 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7305              		.loc 1 1547 0
 7306 3f64 FA0FA0E3 		mov	r0, #1000
 7307 3f68 FEFFFFEB 		bl	_tx_thread_sleep
 7308 3f6c F9FFFFEA 		b	.L529
 7309              	.LVL616:
 7310              	.L603:
 7311              	.LBE257:
 7312              	.LBE256:
 7313              	.LBE259:
 7314              	.LBE275:
2624:../uvc.c      ****                 prodCount = 0;
 7315              		.loc 1 2624 0
 7316 3f70 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2639:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7317              		.loc 1 2639 0
 7318 3f74 40029FE5 		ldr	r0, .L614+96
2625:../uvc.c      ****                 consCount = 0;
 7319              		.loc 1 2625 0
 7320 3f78 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2639:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7321              		.loc 1 2639 0
 7322 3f7c 0010E0E3 		mvn	r1, #0
2621:../uvc.c      ****             	fb=0;
 7323              		.loc 1 2621 0
 7324 3f80 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2622:../uvc.c      ****             	pb=0;
 7325              		.loc 1 2622 0
 7326 3f84 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2623:../uvc.c      ****             	pbc=0;
 7327              		.loc 1 2623 0
 7328 3f88 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2626:../uvc.c      ****                 hitFV     = CyFalse;
 7329              		.loc 1 2626 0
 7330 3f8c 3C6085E5 		str	r6, [r5, #60]
2639:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7331              		.loc 1 2639 0
 7332 3f90 FEFFFFEB 		bl	_txe_mutex_get
2640:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7333              		.loc 1 2640 0
 7334 3f94 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7335 3f98 012020E2 		eor	r2, r0, #1
 7336 3f9c 8124C7E5 		strb	r2, [r7, #1153]
2642:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7337              		.loc 1 2642 0
 7338 3fa0 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7339 3fa4 F0005CE3 		cmp	ip, #240
 7340 3fa8 1800000A 		beq	.L609
 7341              	.L552:
2650:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7342              		.loc 1 2650 0
 7343 3fac 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7344 3fb0 FF005AE3 		cmp	sl, #255
 7345 3fb4 5C00000A 		beq	.L610
2662:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7346              		.loc 1 2662 0
 7347 3fb8 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7348 3fbc AA0050E3 		cmp	r0, #170
 7349 3fc0 2F00000A 		beq	.L611
 7350              	.L553:
2695:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7351              		.loc 1 2695 0
 7352 3fc4 F0019FE5 		ldr	r0, .L614+96
 7353 3fc8 FEFFFFEB 		bl	_txe_mutex_put
2697:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7354              		.loc 1 2697 0
 7355 3fcc F8019FE5 		ldr	r0, .L614+112
 7356 3fd0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7357              	.LVL617:
2698:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7358              		.loc 1 2698 0
 7359 3fd4 002050E2 		subs	r2, r0, #0
 7360 3fd8 2000001A 		bne	.L612
2705:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7361              		.loc 1 2705 0
 7362 3fdc 0210A0E1 		mov	r1, r2
 7363 3fe0 E4019FE5 		ldr	r0, .L614+112
 7364              	.LVL618:
 7365 3fe4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7366              	.LVL619:
2706:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7367              		.loc 1 2706 0
 7368 3fe8 002050E2 		subs	r2, r0, #0
 7369 3fec 1200001A 		bne	.L613
2714:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7370              		.loc 1 2714 0
 7371 3ff0 C8019FE5 		ldr	r0, .L614+100
 7372              	.LVL620:
 7373 3ff4 0210A0E1 		mov	r1, r2
 7374 3ff8 02A0A0E3 		mov	sl, #2
 7375 3ffc 0020A0E1 		mov	r2, r0
 7376              	.LVL621:
 7377 4000 0130A0E1 		mov	r3, r1
 7378 4004 00A08DE5 		str	sl, [sp, #0]
 7379 4008 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7380              	.LVL622:
 7381 400c C4FEFFEA 		b	.L551
 7382              	.L609:
2642:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7383              		.loc 1 2642 0 discriminator 1
 7384 4010 58019FE5 		ldr	r0, .L614+20
 7385 4014 8010A0E3 		mov	r1, #128
 7386 4018 0320A0E3 		mov	r2, #3
 7387 401c B4308DE2 		add	r3, sp, #180
 7388 4020 00608DE5 		str	r6, [sp, #0]
 7389 4024 FEFFFFEB 		bl	_txe_event_flags_get
 7390 4028 000050E3 		cmp	r0, #0
2647:../uvc.c      ****                 		stiflag = 0xFF;
 7391              		.loc 1 2647 0 discriminator 1
 7392 402c 3A80C505 		streqb	r8, [r5, #58]
2648:../uvc.c      ****                 		IMcount = 0;
 7393              		.loc 1 2648 0 discriminator 1
 7394 4030 A160C505 		streqb	r6, [r5, #161]
2642:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7395              		.loc 1 2642 0 discriminator 1
 7396 4034 E2FFFF0A 		beq	.L553
 7397 4038 DBFFFFEA 		b	.L552
 7398              	.LVL623:
 7399              	.L613:
2708:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7400              		.loc 1 2708 0
 7401 403c 0400A0E3 		mov	r0, #4
 7402              	.LVL624:
 7403 4040 E8119FE5 		ldr	r1, .L614+212
 7404 4044 FEFFFFEB 		bl	CyU3PDebugPrint
 7405              	.LVL625:
 7406              	.L565:
 7407              	.LBB276:
 7408              	.LBB277:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7409              		.loc 1 1546 0
 7410 4048 88119FE5 		ldr	r1, .L614+124
 7411 404c 0400A0E3 		mov	r0, #4
 7412 4050 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7413              		.loc 1 1547 0
 7414 4054 FA0FA0E3 		mov	r0, #1000
 7415 4058 FEFFFFEB 		bl	_tx_thread_sleep
 7416 405c F9FFFFEA 		b	.L565
 7417              	.LVL626:
 7418              	.L612:
 7419              	.LBE277:
 7420              	.LBE276:
2700:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7421              		.loc 1 2700 0
 7422 4060 0400A0E3 		mov	r0, #4
 7423              	.LVL627:
 7424 4064 C8119FE5 		ldr	r1, .L614+216
 7425 4068 FEFFFFEB 		bl	CyU3PDebugPrint
 7426              	.LVL628:
 7427              	.L563:
 7428              	.LBB278:
 7429              	.LBB279:
1546:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7430              		.loc 1 1546 0
 7431 406c 64119FE5 		ldr	r1, .L614+124
 7432 4070 0400A0E3 		mov	r0, #4
 7433 4074 FEFFFFEB 		bl	CyU3PDebugPrint
1547:../uvc.c      ****         CyU3PThreadSleep (1000);
 7434              		.loc 1 1547 0
 7435 4078 FA0FA0E3 		mov	r0, #1000
 7436 407c FEFFFFEB 		bl	_tx_thread_sleep
 7437 4080 F9FFFFEA 		b	.L563
 7438              	.L611:
 7439              	.LBE279:
 7440              	.LBE278:
2668:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 7441              		.loc 1 2668 0
 7442 4084 A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 7443 4088 01A08EE2 		add	sl, lr, #1
 7444 408c 02005EE3 		cmp	lr, #2
 7445 4090 A1A0C5E5 		strb	sl, [r5, #161]
 7446 4094 CAFFFF9A 		bls	.L553
2670:../uvc.c      ****                     switch (setRes)
 7447              		.loc 1 2670 0
 7448 4098 7D00D5E5 		ldrb	r0, [r5, #125]	@ zero_extendqisi2
 7449 409c 020050E3 		cmp	r0, #2
 7450 40a0 1800000A 		beq	.L557
 7451 40a4 030050E3 		cmp	r0, #3
 7452 40a8 0B00000A 		beq	.L558
 7453 40ac 010050E3 		cmp	r0, #1
 7454 40b0 0600001A 		bne	.L555
2673:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 7455              		.loc 1 2673 0
 7456 40b4 582095E5 		ldr	r2, [r5, #88]
 7457 40b8 3010A0E3 		mov	r1, #48
 7458 40bc 000052E3 		cmp	r2, #0
 7459 40c0 E420A003 		moveq	r2, #228
 7460 40c4 6420A013 		movne	r2, #100
 7461 40c8 5230A0E3 		mov	r3, #82
 7462 40cc FEFFFFEB 		bl	SensorSetIrisControl
 7463              	.L555:
2690:../uvc.c      ****                     IMcount = 0;
 7464              		.loc 1 2690 0
 7465 40d0 A160C4E5 		strb	r6, [r4, #161]
2692:../uvc.c      ****                 	stiflag = 0x0;
 7466              		.loc 1 2692 0
 7467 40d4 3A60C4E5 		strb	r6, [r4, #58]
 7468 40d8 B9FFFFEA 		b	.L553
 7469              	.L558:
2683:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 7470              		.loc 1 2683 0
 7471 40dc 58C095E5 		ldr	ip, [r5, #88]
 7472 40e0 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 7473 40e4 00005CE3 		cmp	ip, #0
 7474 40e8 C4C0A003 		moveq	ip, #196
 7475 40ec 44C0A013 		movne	ip, #68
 7476 40f0 03208CE1 		orr	r2, ip, r3
 7477 40f4 3010A0E3 		mov	r1, #48
 7478 40f8 5230A0E3 		mov	r3, #82
 7479 40fc 0100A0E3 		mov	r0, #1
 7480 4100 FEFFFFEB 		bl	SensorSetIrisControl
2686:../uvc.c      ****                  		break;
 7481              		.loc 1 2686 0
 7482 4104 F1FFFFEA 		b	.L555
 7483              	.L557:
2678:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 7484              		.loc 1 2678 0
 7485 4108 582095E5 		ldr	r2, [r5, #88]
 7486 410c 3010A0E3 		mov	r1, #48
 7487 4110 000052E3 		cmp	r2, #0
 7488 4114 D420A003 		moveq	r2, #212
 7489 4118 5420A013 		movne	r2, #84
 7490 411c 5230A0E3 		mov	r3, #82
 7491 4120 0100A0E3 		mov	r0, #1
 7492 4124 FEFFFFEB 		bl	SensorSetIrisControl
2681:../uvc.c      ****                  		break;
 7493              		.loc 1 2681 0
 7494 4128 E8FFFFEA 		b	.L555
 7495              	.L610:
2652:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 7496              		.loc 1 2652 0
 7497 412c A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 7498 4130 01E081E2 		add	lr, r1, #1
 7499 4134 020051E3 		cmp	r1, #2
 7500 4138 A1E0C5E5 		strb	lr, [r5, #161]
 7501 413c A0FFFF9A 		bls	.L553
2653:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7502              		.loc 1 2653 0
 7503 4140 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2654:../uvc.c      ****                 		stiflag = 0x0F;
 7504              		.loc 1 2654 0
 7505 4144 0F30A0E3 		mov	r3, #15
2653:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7506              		.loc 1 2653 0
 7507 4148 20C082E3 		orr	ip, r2, #32
 7508 414c 81C4C7E5 		strb	ip, [r7, #1153]
2655:../uvc.c      ****                 		IMcount = 0;
 7509              		.loc 1 2655 0
 7510 4150 A160C5E5 		strb	r6, [r5, #161]
2654:../uvc.c      ****                 		stiflag = 0x0F;
 7511              		.loc 1 2654 0
 7512 4154 3A30C5E5 		strb	r3, [r5, #58]
 7513 4158 99FFFFEA 		b	.L553
 7514              	.L615:
 7515              		.align	2
 7516              	.L614:
 7517 415c 2C070000 		.word	.LC39
 7518 4160 00C20100 		.word	115200
 7519 4164 4C070000 		.word	.LC40
 7520 4168 A0860100 		.word	100000
 7521 416c 68070000 		.word	.LC41
 7522 4170 00000000 		.word	.LANCHOR0
 7523 4174 00000000 		.word	CyFxGpifCB
 7524 4178 88130000 		.word	5000
 7525 417c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7526 4180 00000000 		.word	CyFxUVCApplnUSBEventCB
 7527 4184 00000000 		.word	CyFxUSBDeviceDscr
 7528 4188 00000000 		.word	CyFxUSBDeviceDscrSS
 7529 418c 00000000 		.word	CyFxUSBDeviceQualDscr
 7530 4190 00000000 		.word	CyFxUSBBOSDscr
 7531 4194 00000000 		.word	CyFxUSBHSConfigDscr
 7532 4198 00000000 		.word	CyFxUSBFSConfigDscr
 7533 419c 00000000 		.word	CyFxUSBSSConfigDscr
 7534 41a0 00000000 		.word	CyFxUSBStringLangIDDscr
 7535 41a4 00000000 		.word	CyFxUSBManufactureDscr
 7536 41a8 00000000 		.word	CyFxUSBProductDscr
 7537 41ac 013F0000 		.word	16129
 7538 41b0 02030000 		.word	770
 7539 41b4 00000000 		.word	glChHandleInterStat
 7540 41b8 00000000 		.word	glInterStaBuffer
 7541 41bc 00000000 		.word	imgHdMux
 7542 41c0 01010000 		.word	257
 7543 41c4 03030000 		.word	771
 7544 41c8 00000000 		.word	CyFxUvcApplnDmaCallback
 7545 41cc 00000000 		.word	glChHandleUVCStream
 7546 41d0 00000000 		.word	.LANCHOR1
 7547 41d4 84070000 		.word	.LC42
 7548 41d8 D8010000 		.word	.LC12
 7549 41dc D4070000 		.word	.LC44
 7550 41e0 B0070000 		.word	.LC43
 7551 41e4 FC070000 		.word	.LC45
 7552 41e8 54090000 		.word	.LC52
 7553 41ec 300A0000 		.word	.LC56
 7554 41f0 000A0000 		.word	.LC55
 7555 41f4 C8090000 		.word	.LC54
 7556 41f8 88090000 		.word	.LC53
 7557 41fc FC0A0000 		.word	.LC61
 7558 4200 1C000000 		.word	.LANCHOR2+28
 7559 4204 440B0000 		.word	.LC63
 7560 4208 EC0A0000 		.word	.LC60
 7561 420c 00000000 		.word	.LANCHOR2
 7562 4210 0C0B0000 		.word	.LC62
 7563 4214 B80A0000 		.word	.LC59
 7564 4218 24090000 		.word	.LC51
 7565 421c F4080000 		.word	.LC50
 7566 4220 BC080000 		.word	.LC49
 7567 4224 54080000 		.word	.LC47
 7568 4228 28080000 		.word	.LC46
 7569 422c 88080000 		.word	.LC48
 7570 4230 840A0000 		.word	.LC58
 7571 4234 580A0000 		.word	.LC57
 7572              		.cfi_endproc
 7573              	.LFE18:
 7575              		.align	2
 7576              		.global	CyFxApplicationDefine
 7578              	CyFxApplicationDefine:
 7579              	.LFB26:
4110:../uvc.c      **** }
4111:../uvc.c      **** 
4112:../uvc.c      **** 
4113:../uvc.c      **** /*
4114:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4115:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4116:../uvc.c      ****  */
4117:../uvc.c      **** void
4118:../uvc.c      **** CyFxApplicationDefine (
4119:../uvc.c      ****         void)
4120:../uvc.c      **** {
 7580              		.loc 1 4120 0
 7581              		.cfi_startproc
 7582              		@ args = 0, pretend = 0, frame = 40
 7583              		@ frame_needed = 0, uses_anonymous_args = 0
 7584              	.LVL629:
 7585 4238 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7586              	.LCFI25:
 7587              		.cfi_def_cfa_offset 36
4121:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4122:../uvc.c      ****     uint32_t retThrdCreate;
4123:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4124:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4125:../uvc.c      **** 
4126:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4127:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7588              		.loc 1 4127 0
 7589 423c 010AA0E3 		mov	r0, #4096
4120:../uvc.c      **** {
 7590              		.loc 1 4120 0
 7591 4240 4CD04DE2 		sub	sp, sp, #76
 7592              	.LCFI26:
 7593              		.cfi_def_cfa_offset 112
 7594              		.loc 1 4127 0
 7595              		.cfi_offset 14, -4
 7596              		.cfi_offset 11, -8
 7597              		.cfi_offset 10, -12
 7598              		.cfi_offset 9, -16
 7599              		.cfi_offset 8, -20
 7600              		.cfi_offset 7, -24
 7601              		.cfi_offset 6, -28
 7602              		.cfi_offset 5, -32
 7603              		.cfi_offset 4, -36
 7604 4244 FEFFFFEB 		bl	CyU3PMemAlloc
 7605 4248 00A0A0E1 		mov	sl, r0
 7606              	.LVL630:
4128:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7607              		.loc 1 4128 0
 7608 424c 010AA0E3 		mov	r0, #4096
 7609              	.LVL631:
 7610 4250 FEFFFFEB 		bl	CyU3PMemAlloc
 7611 4254 00B0A0E1 		mov	fp, r0
 7612              	.LVL632:
4129:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7613              		.loc 1 4129 0
 7614 4258 010AA0E3 		mov	r0, #4096
 7615              	.LVL633:
 7616 425c FEFFFFEB 		bl	CyU3PMemAlloc
4130:../uvc.c      **** 
4131:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7617              		.loc 1 4131 0
 7618 4260 00005AE3 		cmp	sl, #0
 7619 4264 00005B13 		cmpne	fp, #0
 7620 4268 0090A013 		movne	r9, #0
 7621 426c 0190A003 		moveq	r9, #1
4129:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7622              		.loc 1 4129 0
 7623 4270 24008DE5 		str	r0, [sp, #36]
 7624              	.LVL634:
 7625              		.loc 1 4131 0
 7626 4274 0000001A 		bne	.L620
 7627              	.LVL635:
 7628              	.L617:
 7629              	.L619:
 7630 4278 FEFFFFEA 		b	.L619
 7631              	.L620:
 7632              		.loc 1 4131 0 is_stmt 0 discriminator 1
 7633 427c 000050E3 		cmp	r0, #0
 7634 4280 FCFFFF0A 		beq	.L617
4132:../uvc.c      ****         goto fatalErrorHandler;
4133:../uvc.c      **** 
4134:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4135:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7635              		.loc 1 4135 0 is_stmt 1
 7636 4284 28408DE2 		add	r4, sp, #40
 7637 4288 0400A0E1 		mov	r0, r4
 7638 428c 4010A0E3 		mov	r1, #64
 7639 4290 18219FE5 		ldr	r2, .L621
 7640 4294 FEFFFFEB 		bl	cmdbufCreate
 7641 4298 0450A0E1 		mov	r5, r4
 7642 429c 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7643 42a0 0C719FE5 		ldr	r7, .L621+4
4136:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7644              		.loc 1 4136 0
 7645 42a4 0C819FE5 		ldr	r8, .L621+8
4135:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7646              		.loc 1 4135 0
 7647 42a8 07C0A0E1 		mov	ip, r7
 7648 42ac 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7649 42b0 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4137:../uvc.c      **** 
4138:../uvc.c      **** 	/****** initialize command descriptor ***********/
4139:../uvc.c      **** 	cmdquInit(cmdQuptr);
4140:../uvc.c      **** 	cmdquInit(statQuptr);
4141:../uvc.c      **** 
4142:../uvc.c      ****     /* Create the UVC application thread. */
4143:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7650              		.loc 1 4143 0
 7651 42b4 0860A0E3 		mov	r6, #8
4135:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7652              		.loc 1 4135 0
 7653 42b8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4136:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7654              		.loc 1 4136 0
 7655 42bc F8209FE5 		ldr	r2, .L621+12
 7656 42c0 0400A0E1 		mov	r0, r4
 7657 42c4 2010A0E3 		mov	r1, #32
 7658 42c8 FEFFFFEB 		bl	cmdbufCreate
 7659 42cc 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7660 42d0 08C0A0E1 		mov	ip, r8
 7661 42d4 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7662 42d8 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7663              		.loc 1 4143 0
 7664 42dc 0140A0E3 		mov	r4, #1
4136:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7665              		.loc 1 4136 0
 7666 42e0 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4139:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7667              		.loc 1 4139 0
 7668 42e4 0700A0E1 		mov	r0, r7
 7669 42e8 FEFFFFEB 		bl	cmdquInit
4140:../uvc.c      **** 	cmdquInit(statQuptr);
 7670              		.loc 1 4140 0
 7671 42ec 0800A0E1 		mov	r0, r8
 7672 42f0 FEFFFFEB 		bl	cmdquInit
 7673              		.loc 1 4143 0
 7674 42f4 A850A0E3 		mov	r5, #168
 7675 42f8 01CAA0E3 		mov	ip, #4096
 7676 42fc BC009FE5 		ldr	r0, .L621+16
 7677 4300 BC109FE5 		ldr	r1, .L621+20
 7678 4304 BC209FE5 		ldr	r2, .L621+24
 7679 4308 0930A0E1 		mov	r3, r9
 7680 430c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7681 4310 08608DE5 		str	r6, [sp, #8]
 7682 4314 0C608DE5 		str	r6, [sp, #12]
 7683 4318 10908DE5 		str	r9, [sp, #16]
 7684 431c 14408DE5 		str	r4, [sp, #20]
 7685 4320 18508DE5 		str	r5, [sp, #24]
 7686 4324 FEFFFFEB 		bl	_txe_thread_create
 7687              	.LVL636:
4144:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4145:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4146:../uvc.c      ****             0,                                          /* No input parameter to thread */
4147:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4148:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4149:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4150:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4151:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4152:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4153:../uvc.c      ****             );
4154:../uvc.c      ****     if (retThrdCreate != 0)
 7688              		.loc 1 4154 0
 7689 4328 00C050E2 		subs	ip, r0, #0
 7690 432c D1FFFF1A 		bne	.L617
4155:../uvc.c      ****     {
4156:../uvc.c      ****         goto fatalErrorHandler;
4157:../uvc.c      ****     }
4158:../uvc.c      **** 
4159:../uvc.c      ****     /* Create the control request handling thread. */
4160:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7691              		.loc 1 4160 0
 7692 4330 0C30A0E1 		mov	r3, ip
 7693 4334 027BA0E3 		mov	r7, #2048
 7694 4338 8C009FE5 		ldr	r0, .L621+28
 7695              	.LVL637:
 7696 433c 8C109FE5 		ldr	r1, .L621+32
 7697 4340 8C209FE5 		ldr	r2, .L621+36
 7698 4344 10C08DE5 		str	ip, [sp, #16]
 7699 4348 00B08DE5 		str	fp, [sp, #0]
 7700 434c 04708DE5 		str	r7, [sp, #4]
 7701 4350 08608DE5 		str	r6, [sp, #8]
 7702 4354 0C608DE5 		str	r6, [sp, #12]
 7703 4358 14408DE5 		str	r4, [sp, #20]
 7704 435c 18508DE5 		str	r5, [sp, #24]
 7705 4360 FEFFFFEB 		bl	_txe_thread_create
 7706              	.LVL638:
4161:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4162:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4163:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4164:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4165:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4166:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4167:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4168:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4169:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4170:../uvc.c      ****             );
4171:../uvc.c      ****     if (retThrdCreate != 0)
 7707              		.loc 1 4171 0
 7708 4364 00C050E2 		subs	ip, r0, #0
 7709 4368 C2FFFF1A 		bne	.L617
4172:../uvc.c      ****     {
4173:../uvc.c      ****         goto fatalErrorHandler;
4174:../uvc.c      ****     }
4175:../uvc.c      **** #if 1
4176:../uvc.c      ****     /* Create the I2C control command handling thread. */
4177:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7710              		.loc 1 4177 0
 7711 436c 24E09DE5 		ldr	lr, [sp, #36]
 7712 4370 60009FE5 		ldr	r0, .L621+40
 7713              	.LVL639:
 7714 4374 60109FE5 		ldr	r1, .L621+44
 7715 4378 60209FE5 		ldr	r2, .L621+48
 7716 437c 0C30A0E1 		mov	r3, ip
 7717 4380 00E08DE5 		str	lr, [sp, #0]
 7718 4384 04708DE5 		str	r7, [sp, #4]
 7719 4388 08608DE5 		str	r6, [sp, #8]
 7720 438c 0C608DE5 		str	r6, [sp, #12]
 7721 4390 10C08DE5 		str	ip, [sp, #16]
 7722 4394 14408DE5 		str	r4, [sp, #20]
 7723 4398 18508DE5 		str	r5, [sp, #24]
 7724 439c FEFFFFEB 		bl	_txe_thread_create
 7725              	.LVL640:
4178:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4179:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4180:../uvc.c      ****             0,                                          /* No input parameter to thread */
4181:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4182:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4183:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4184:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4185:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4186:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4187:../uvc.c      ****             );
4188:../uvc.c      ****     if (retThrdCreate != 0)
 7726              		.loc 1 4188 0
 7727 43a0 000050E3 		cmp	r0, #0
 7728 43a4 B3FFFF1A 		bne	.L617
4189:../uvc.c      ****     {
4190:../uvc.c      ****         goto fatalErrorHandler;
4191:../uvc.c      ****     }
4192:../uvc.c      **** #endif
4193:../uvc.c      **** 
4194:../uvc.c      ****     return;
4195:../uvc.c      **** 
4196:../uvc.c      **** fatalErrorHandler:
4197:../uvc.c      ****     /* Add custom recovery or debug actions here */
4198:../uvc.c      ****     /* Loop indefinitely */
4199:../uvc.c      ****     while (1);
4200:../uvc.c      **** }
 7729              		.loc 1 4200 0
 7730 43a8 4CD08DE2 		add	sp, sp, #76
 7731 43ac F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7732              	.L622:
 7733              		.align	2
 7734              	.L621:
 7735 43b0 00000000 		.word	cmdQuMux
 7736 43b4 00000000 		.word	cmdQu
 7737 43b8 00000000 		.word	statQu
 7738 43bc 00000000 		.word	staQuMux
 7739 43c0 A4000000 		.word	.LANCHOR0+164
 7740 43c4 7C0B0000 		.word	.LC64
 7741 43c8 00000000 		.word	UVCAppThread_Entry
 7742 43cc 4C010000 		.word	.LANCHOR0+332
 7743 43d0 900B0000 		.word	.LC65
 7744 43d4 00000000 		.word	UVCAppEP0Thread_Entry
 7745 43d8 F4010000 		.word	.LANCHOR0+500
 7746 43dc A80B0000 		.word	.LC66
 7747 43e0 00000000 		.word	I2cAppThread_Entry
 7748              		.cfi_endproc
 7749              	.LFE26:
 7751              		.align	2
 7752              		.global	main
 7754              	main:
 7755              	.LFB27:
4201:../uvc.c      **** 
4202:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4203:../uvc.c      ****  * the ThreadX RTOS here.
4204:../uvc.c      ****  */
4205:../uvc.c      **** int
4206:../uvc.c      **** main (
4207:../uvc.c      ****         void)
4208:../uvc.c      **** {
 7756              		.loc 1 4208 0
 7757              		.cfi_startproc
 7758              		@ args = 0, pretend = 0, frame = 56
 7759              		@ frame_needed = 0, uses_anonymous_args = 0
 7760 43e4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7761              	.LCFI27:
 7762              		.cfi_def_cfa_offset 12
4209:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4210:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4211:../uvc.c      **** 
4212:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4213:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4214:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4215:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4216:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4217:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7763              		.loc 1 4217 0
 7764 43e8 0010A0E3 		mov	r1, #0
4208:../uvc.c      **** {
 7765              		.loc 1 4208 0
 7766 43ec 3CD04DE2 		sub	sp, sp, #60
 7767              	.LCFI28:
 7768              		.cfi_def_cfa_offset 72
4214:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7769              		.loc 1 4214 0
 7770 43f0 0220A0E3 		mov	r2, #2
4218:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7771              		.loc 1 4218 0
 7772 43f4 033081E2 		add	r3, r1, #3
4213:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7773              		.loc 1 4213 0
 7774 43f8 0150A0E3 		mov	r5, #1
 7775              		.cfi_offset 14, -4
 7776              		.cfi_offset 5, -8
 7777              		.cfi_offset 4, -12
4219:../uvc.c      **** 
4220:../uvc.c      ****     /* Initialize the device */
4221:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7778              		.loc 1 4221 0
 7779 43fc 28008DE2 		add	r0, sp, #40
4213:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7780              		.loc 1 4213 0
 7781 4400 28508DE5 		str	r5, [sp, #40]
4214:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7782              		.loc 1 4214 0
 7783 4404 2C20CDE5 		strb	r2, [sp, #44]
4215:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7784              		.loc 1 4215 0
 7785 4408 2D20CDE5 		strb	r2, [sp, #45]
4216:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7786              		.loc 1 4216 0
 7787 440c 2E20CDE5 		strb	r2, [sp, #46]
4217:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7788              		.loc 1 4217 0
 7789 4410 30108DE5 		str	r1, [sp, #48]
4218:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7790              		.loc 1 4218 0
 7791 4414 3430CDE5 		strb	r3, [sp, #52]
 7792              		.loc 1 4221 0
 7793 4418 FEFFFFEB 		bl	CyU3PDeviceInit
 7794              	.LVL641:
4222:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7795              		.loc 1 4222 0
 7796 441c 004050E2 		subs	r4, r0, #0
 7797 4420 0000000A 		beq	.L626
 7798              	.L624:
 7799              	.L625:
 7800 4424 FEFFFFEA 		b	.L625
 7801              	.L626:
4223:../uvc.c      ****     {
4224:../uvc.c      ****         goto handle_fatal_error;
4225:../uvc.c      ****     }
4226:../uvc.c      **** 
4227:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4228:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7802              		.loc 1 4228 0
 7803 4428 0410A0E1 		mov	r1, r4
 7804 442c 0420A0E1 		mov	r2, r4
 7805 4430 0500A0E1 		mov	r0, r5
 7806              	.LVL642:
 7807 4434 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7808              	.LVL643:
4229:../uvc.c      **** 
4230:../uvc.c      ****     /* Configure the IO matrix for the device. */
4231:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4232:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4233:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4234:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4235:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4236:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4237:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4238:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4239:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4240:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4241:../uvc.c      **** 
4242:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7809              		.loc 1 4242 0
 7810 4438 0D00A0E1 		mov	r0, sp
4232:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7811              		.loc 1 4232 0
 7812 443c 1640CDE5 		strb	r4, [sp, #22]
4233:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7813              		.loc 1 4233 0
 7814 4440 18408DE5 		str	r4, [sp, #24]
4234:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7815              		.loc 1 4234 0
 7816 4444 1C408DE5 		str	r4, [sp, #28]
4235:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7817              		.loc 1 4235 0
 7818 4448 20408DE5 		str	r4, [sp, #32]
4236:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7819              		.loc 1 4236 0
 7820 444c 24408DE5 		str	r4, [sp, #36]
4239:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7821              		.loc 1 4239 0
 7822 4450 0C408DE5 		str	r4, [sp, #12]
4240:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7823              		.loc 1 4240 0
 7824 4454 10408DE5 		str	r4, [sp, #16]
4231:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7825              		.loc 1 4231 0
 7826 4458 00508DE5 		str	r5, [sp, #0]
4237:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7827              		.loc 1 4237 0
 7828 445c 04508DE5 		str	r5, [sp, #4]
4238:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7829              		.loc 1 4238 0
 7830 4460 08508DE5 		str	r5, [sp, #8]
 7831              		.loc 1 4242 0
 7832 4464 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7833              	.LVL644:
4243:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7834              		.loc 1 4243 0
 7835 4468 004050E2 		subs	r4, r0, #0
 7836 446c ECFFFF1A 		bne	.L624
4244:../uvc.c      ****     {
4245:../uvc.c      ****         goto handle_fatal_error;
4246:../uvc.c      ****     }
4247:../uvc.c      **** 
4248:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4249:../uvc.c      ****     CyU3PKernelEntry ();
 7837              		.loc 1 4249 0
 7838 4470 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7839              	.LVL645:
4250:../uvc.c      **** 
4251:../uvc.c      ****     /* Dummy return to make the compiler happy */
4252:../uvc.c      ****     return 0;
4253:../uvc.c      **** 
4254:../uvc.c      **** handle_fatal_error:
4255:../uvc.c      ****     /* Cannot recover from this error. */
4256:../uvc.c      ****     while (1);
4257:../uvc.c      **** }
 7840              		.loc 1 4257 0
 7841 4474 0400A0E1 		mov	r0, r4
 7842 4478 3CD08DE2 		add	sp, sp, #60
 7843 447c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7844              		.cfi_endproc
 7845              	.LFE27:
 7847              		.global	CyFxGpifTransition
 7848              		.global	CyFxGpifWavedata
 7849              		.global	CyFxGpifWavedataPosition
 7850              		.global	CyFxGpifRegValue
 7851              		.global	CyFxGpifConfig
 7852              		.global	CyFxGpifTransition_usb2
 7853              		.global	CyFxGpifWavedata_usb2
 7854              		.global	CyFxGpifWavedataPosition_usb2
 7855              		.global	CyFxGpifRegValue_usb2
 7856              		.global	CyFxGpifConfig_usb2
 7857              		.global	snapButFlag
 7858              		.global	testSnap
 7859              		.global	fb
 7860              		.global	pb
 7861              		.global	pbc
 7862              		.global	fbbak
 7863              		.global	pbbak
 7864              		.global	pbcbak
 7865              		.global	pbcpbak
 7866              		.global	isUsbConnected
 7867              		.global	usbSpeed
 7868              		.global	clearFeatureRqtReceived
 7869              		.global	streamingStarted
 7870              		.global	glProbeCtrl
 7871              		.global	glProbeCtrlFull
 7872              		.global	glProbeStilCtrl
 7873              		.global	glProbeCtrl20
 7874              		.global	glProbeStilCtrl20
 7875              		.global	glUVCHeader
 7876              		.comm	glChHandleUVCStream,220,4
 7877              		.comm	glChHandleStillStream,220,4
 7878              		.comm	glChHandleInterStat,160,4
 7879              		.comm	glInterStaBuffer,4,4
 7880              		.comm	cmdQu,32,4
 7881              		.comm	statQu,32,4
 7882              		.comm	cmdQuMux,56,4
 7883              		.comm	staQuMux,56,4
 7884              		.comm	timMux,56,4
 7885              		.comm	imgHdMux,56,4
 7886              		.comm	bmReqType,1,1
 7887              		.comm	bRequest,1,1
 7888              		.comm	wValue,2,2
 7889              		.comm	wIndex,2,2
 7890              		.comm	wLength,2,2
 7891              		.comm	posTick,4,4
 7892              		.comm	I2CCmdTimer,44,4
 7893              		.section	.rodata
 7894              		.align	2
 7895              		.set	.LANCHOR2,. + 0
 7898              	CyFxGpifConfig:
 7899 0000 0F00     		.short	15
 7900 0002 0000     		.space	2
 7901 0004 00000000 		.word	CyFxGpifWavedata
 7902 0008 00000000 		.word	CyFxGpifWavedataPosition
 7903 000c 0500     		.short	5
 7904 000e 0000     		.space	2
 7905 0010 00000000 		.word	CyFxGpifTransition
 7906 0014 4C00     		.short	76
 7907 0016 0000     		.space	2
 7908 0018 00000000 		.word	CyFxGpifRegValue
 7911              	CyFxGpifConfig_usb2:
 7912 001c 9300     		.short	147
 7913 001e 0000     		.space	2
 7914 0020 00000000 		.word	CyFxGpifWavedata_usb2
 7915 0024 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7916 0028 0800     		.short	8
 7917 002a 0000     		.space	2
 7918 002c 00000000 		.word	CyFxGpifTransition_usb2
 7919 0030 4C00     		.short	76
 7920 0032 0000     		.space	2
 7921 0034 00000000 		.word	CyFxGpifRegValue_usb2
 7922              		.data
 7923              		.align	2
 7924              		.set	.LANCHOR1,. + 0
 7927              	ExUCtrlParArry:
 7928 0000 13       		.byte	19
 7929 0001 14       		.byte	20
 7930 0002 02       		.byte	2
 7931 0003 01       		.byte	1
 7932 0004 00       		.byte	0
 7933 0005 03       		.byte	3
 7934 0006 00       		.byte	0
 7935 0007 01       		.byte	1
 7936 0008 00       		.byte	0
 7937 0009 03       		.byte	3
 7938 000a 00       		.byte	0
 7939 000b 23       		.byte	35
 7940 000c 37       		.byte	55
 7941 000d 23       		.byte	35
 7942 000e 37       		.byte	55
 7943 000f 30       		.byte	48
 7944 0010 01       		.byte	1
 7945 0011 00       		.byte	0
 7946 0012 00       		.byte	0
 7947 0013 00000000 		.space	5
 7947      00
 7948 0018 11       		.byte	17
 7949 0019 00       		.byte	0
 7950 001a 02       		.byte	2
 7951 001b 01       		.byte	1
 7952 001c 00       		.byte	0
 7953 001d 03       		.byte	3
 7954 001e 00       		.byte	0
 7955 001f 01       		.byte	1
 7956 0020 00       		.byte	0
 7957 0021 03       		.byte	3
 7958 0022 00       		.byte	0
 7959 0023 01       		.byte	1
 7960 0024 00       		.byte	0
 7961 0025 01       		.byte	1
 7962 0026 00       		.byte	0
 7963 0027 30       		.byte	48
 7964 0028 01       		.byte	1
 7965 0029 01       		.byte	1
 7966 002a 00       		.byte	0
 7967 002b 00000000 		.space	5
 7967      00
 7968 0030 17       		.byte	23
 7969 0031 00       		.byte	0
 7970 0032 01       		.byte	1
 7971 0033 01       		.byte	1
 7972 0034 00       		.byte	0
 7973 0035 02       		.byte	2
 7974 0036 00       		.byte	0
 7975 0037 01       		.byte	1
 7976 0038 00       		.byte	0
 7977 0039 03       		.byte	3
 7978 003a 00       		.byte	0
 7979 003b 00       		.byte	0
 7980 003c 00       		.byte	0
 7981 003d 00       		.byte	0
 7982 003e 00       		.byte	0
 7983 003f 30       		.byte	48
 7984 0040 01       		.byte	1
 7985 0041 01       		.byte	1
 7986 0042 00       		.byte	0
 7987 0043 00000000 		.space	5
 7987      00
 7988 0048 00       		.byte	0
 7989 0049 00       		.byte	0
 7990 004a 04       		.byte	4
 7991 004b 01       		.byte	1
 7992 004c 00       		.byte	0
 7993 004d 38       		.byte	56
 7994 004e 01       		.byte	1
 7995 004f 01       		.byte	1
 7996 0050 00       		.byte	0
 7997 0051 03       		.byte	3
 7998 0052 00       		.byte	0
 7999 0053 4E       		.byte	78
 8000 0054 00       		.byte	0
 8001 0055 4E       		.byte	78
 8002 0056 00       		.byte	0
 8003 0057 30       		.byte	48
 8004 0058 01       		.byte	1
 8005 0059 00       		.byte	0
 8006 005a 00       		.byte	0
 8007 005b 00000000 		.space	5
 8007      00
 8008 0060 00       		.byte	0
 8009 0061 00       		.byte	0
 8010 0062 01       		.byte	1
 8011 0063 00       		.byte	0
 8012 0064 00       		.byte	0
 8013 0065 00       		.byte	0
 8014 0066 00       		.byte	0
 8015 0067 01       		.byte	1
 8016 0068 00       		.byte	0
 8017 0069 03       		.byte	3
 8018 006a 00       		.byte	0
 8019 006b 00       		.byte	0
 8020 006c 00       		.byte	0
 8021 006d 00       		.byte	0
 8022 006e 00       		.byte	0
 8023 006f 30       		.byte	48
 8024 0070 01       		.byte	1
 8025 0071 00       		.byte	0
 8026 0072 00       		.byte	0
 8027 0073 00000000 		.space	5
 8027      00
 8028 0078 00       		.byte	0
 8029 0079 00       		.byte	0
 8030 007a 02       		.byte	2
 8031 007b 00       		.byte	0
 8032 007c 00       		.byte	0
 8033 007d FF       		.byte	-1
 8034 007e 00       		.byte	0
 8035 007f 01       		.byte	1
 8036 0080 00       		.byte	0
 8037 0081 03       		.byte	3
 8038 0082 00       		.byte	0
 8039 0083 01       		.byte	1
 8040 0084 00       		.byte	0
 8041 0085 00       		.byte	0
 8042 0086 00       		.byte	0
 8043 0087 30       		.byte	48
 8044 0088 01       		.byte	1
 8045 0089 01       		.byte	1
 8046 008a 00       		.byte	0
 8047 008b 00000000 		.space	5
 8047      00
 8048 0090 00       		.byte	0
 8049 0091 00       		.byte	0
 8050 0092 02       		.byte	2
 8051 0093 00       		.byte	0
 8052 0094 00       		.byte	0
 8053 0095 00       		.byte	0
 8054 0096 00       		.byte	0
 8055 0097 00       		.byte	0
 8056 0098 00       		.byte	0
 8057 0099 03       		.byte	3
 8058 009a 00       		.byte	0
 8059 009b 00       		.byte	0
 8060 009c 00       		.byte	0
 8061 009d 00       		.byte	0
 8062 009e 00       		.byte	0
 8063 009f 30       		.byte	48
 8064 00a0 01       		.byte	1
 8065 00a1 01       		.byte	1
 8066 00a2 00       		.byte	0
 8067 00a3 00000000 		.space	5
 8067      00
 8068 00a8 00       		.byte	0
 8069 00a9 00       		.byte	0
 8070 00aa 02       		.byte	2
 8071 00ab 00       		.byte	0
 8072 00ac 00       		.byte	0
 8073 00ad 30       		.byte	48
 8074 00ae 00       		.byte	0
 8075 00af 01       		.byte	1
 8076 00b0 00       		.byte	0
 8077 00b1 03       		.byte	3
 8078 00b2 0A       		.byte	10
 8079 00b3 00       		.byte	0
 8080 00b4 00       		.byte	0
 8081 00b5 0A       		.byte	10
 8082 00b6 00       		.byte	0
 8083 00b7 30       		.byte	48
 8084 00b8 01       		.byte	1
 8085 00b9 01       		.byte	1
 8086 00ba 00       		.byte	0
 8087 00bb 00000000 		.space	5
 8087      00
 8088 00c0 00       		.byte	0
 8089 00c1 00       		.byte	0
 8090 00c2 01       		.byte	1
 8091 00c3 00       		.byte	0
 8092 00c4 00       		.byte	0
 8093 00c5 7F       		.byte	127
 8094 00c6 00       		.byte	0
 8095 00c7 01       		.byte	1
 8096 00c8 00       		.byte	0
 8097 00c9 03       		.byte	3
 8098 00ca 00       		.byte	0
 8099 00cb 00       		.byte	0
 8100 00cc 00       		.byte	0
 8101 00cd 00       		.byte	0
 8102 00ce 00       		.byte	0
 8103 00cf 30       		.byte	48
 8104 00d0 01       		.byte	1
 8105 00d1 00       		.byte	0
 8106 00d2 00       		.byte	0
 8107 00d3 00000000 		.space	5
 8107      00
 8108 00d8 00       		.byte	0
 8109 00d9 00       		.byte	0
 8110 00da 02       		.byte	2
 8111 00db 00       		.byte	0
 8112 00dc 00       		.byte	0
 8113 00dd 05       		.byte	5
 8114 00de 00       		.byte	0
 8115 00df 01       		.byte	1
 8116 00e0 00       		.byte	0
 8117 00e1 03       		.byte	3
 8118 00e2 00       		.byte	0
 8119 00e3 00       		.byte	0
 8120 00e4 00       		.byte	0
 8121 00e5 00       		.byte	0
 8122 00e6 00       		.byte	0
 8123 00e7 30       		.byte	48
 8124 00e8 01       		.byte	1
 8125 00e9 00       		.byte	0
 8126 00ea 00       		.byte	0
 8127 00eb 00000000 		.space	5
 8127      00
 8128 00f0 00       		.byte	0
 8129 00f1 00       		.byte	0
 8130 00f2 03       		.byte	3
 8131 00f3 00       		.byte	0
 8132 00f4 00       		.byte	0
 8133 00f5 0A       		.byte	10
 8134 00f6 00       		.byte	0
 8135 00f7 01       		.byte	1
 8136 00f8 00       		.byte	0
 8137 00f9 03       		.byte	3
 8138 00fa 00       		.byte	0
 8139 00fb 00       		.byte	0
 8140 00fc 00       		.byte	0
 8141 00fd 00       		.byte	0
 8142 00fe 00       		.byte	0
 8143 00ff 30       		.byte	48
 8144 0100 01       		.byte	1
 8145 0101 00       		.byte	0
 8146 0102 00       		.byte	0
 8147 0103 00000000 		.space	5
 8147      00
 8148 0108 00       		.byte	0
 8149 0109 00       		.byte	0
 8150 010a 02       		.byte	2
 8151 010b 00       		.byte	0
 8152 010c 00       		.byte	0
 8153 010d 40       		.byte	64
 8154 010e 00       		.byte	0
 8155 010f 01       		.byte	1
 8156 0110 00       		.byte	0
 8157 0111 03       		.byte	3
 8158 0112 00       		.byte	0
 8159 0113 0F       		.byte	15
 8160 0114 11       		.byte	17
 8161 0115 00       		.byte	0
 8162 0116 00       		.byte	0
 8163 0117 30       		.byte	48
 8164 0118 01       		.byte	1
 8165 0119 00       		.byte	0
 8166 011a 00       		.byte	0
 8167 011b 00000000 		.space	5
 8167      00
 8168 0120 00       		.byte	0
 8169 0121 00       		.byte	0
 8170 0122 02       		.byte	2
 8171 0123 00       		.byte	0
 8172 0124 00       		.byte	0
 8173 0125 64       		.byte	100
 8174 0126 00       		.byte	0
 8175 0127 01       		.byte	1
 8176 0128 00       		.byte	0
 8177 0129 03       		.byte	3
 8178 012a 00       		.byte	0
 8179 012b 00       		.byte	0
 8180 012c 00       		.byte	0
 8181 012d 00       		.byte	0
 8182 012e 00       		.byte	0
 8183 012f 30       		.byte	48
 8184 0130 01       		.byte	1
 8185 0131 00       		.byte	0
 8186 0132 00       		.byte	0
 8187 0133 00000000 		.space	5
 8187      00
 8188 0138 00       		.byte	0
 8189 0139 00       		.byte	0
 8190 013a 02       		.byte	2
 8191 013b 00       		.byte	0
 8192 013c 00       		.byte	0
 8193 013d 64       		.byte	100
 8194 013e 00       		.byte	0
 8195 013f 01       		.byte	1
 8196 0140 00       		.byte	0
 8197 0141 03       		.byte	3
 8198 0142 00       		.byte	0
 8199 0143 00       		.byte	0
 8200 0144 00       		.byte	0
 8201 0145 00       		.byte	0
 8202 0146 00       		.byte	0
 8203 0147 30       		.byte	48
 8204 0148 01       		.byte	1
 8205 0149 00       		.byte	0
 8206 014a 00       		.byte	0
 8207 014b 00000000 		.space	5
 8207      00
 8208 0150 00       		.byte	0
 8209 0151 00       		.byte	0
 8210 0152 02       		.byte	2
 8211 0153 00       		.byte	0
 8212 0154 00       		.byte	0
 8213 0155 64       		.byte	100
 8214 0156 00       		.byte	0
 8215 0157 01       		.byte	1
 8216 0158 00       		.byte	0
 8217 0159 03       		.byte	3
 8218 015a 00       		.byte	0
 8219 015b 00       		.byte	0
 8220 015c 00       		.byte	0
 8221 015d 00       		.byte	0
 8222 015e 00       		.byte	0
 8223 015f 30       		.byte	48
 8224 0160 01       		.byte	1
 8225 0161 00       		.byte	0
 8226 0162 00       		.byte	0
 8227 0163 00000000 		.space	5
 8227      00
 8228 0168 00       		.byte	0
 8229 0169 00       		.byte	0
 8230 016a 02       		.byte	2
 8231 016b 00       		.byte	0
 8232 016c 00       		.byte	0
 8233 016d 64       		.byte	100
 8234 016e 00       		.byte	0
 8235 016f 01       		.byte	1
 8236 0170 00       		.byte	0
 8237 0171 03       		.byte	3
 8238 0172 00       		.byte	0
 8239 0173 00       		.byte	0
 8240 0174 00       		.byte	0
 8241 0175 00       		.byte	0
 8242 0176 00       		.byte	0
 8243 0177 30       		.byte	48
 8244 0178 01       		.byte	1
 8245 0179 00       		.byte	0
 8246 017a 00       		.byte	0
 8247 017b 00000000 		.space	5
 8247      00
 8250              	CtrlParArry:
 8251 0180 10       		.byte	16
 8252 0181 10       		.byte	16
 8253 0182 02       		.byte	2
 8254 0183 00       		.byte	0
 8255 0184 00       		.byte	0
 8256 0185 03       		.byte	3
 8257 0186 00       		.byte	0
 8258 0187 01       		.byte	1
 8259 0188 00       		.byte	0
 8260 0189 03       		.byte	3
 8261 018a 00       		.byte	0
 8262 018b 03       		.byte	3
 8263 018c 00       		.byte	0
 8264 018d 03       		.byte	3
 8265 018e 00       		.byte	0
 8266 018f 30       		.byte	48
 8267 0190 01       		.byte	1
 8268 0191 00       		.byte	0
 8269 0192 00       		.byte	0
 8270 0193 00000000 		.space	5
 8270      00
 8271 0198 15       		.byte	21
 8272 0199 15       		.byte	21
 8273 019a 02       		.byte	2
 8274 019b 00       		.byte	0
 8275 019c 00       		.byte	0
 8276 019d FF       		.byte	-1
 8277 019e 00       		.byte	0
 8278 019f 01       		.byte	1
 8279 01a0 00       		.byte	0
 8280 01a1 03       		.byte	3
 8281 01a2 00       		.byte	0
 8282 01a3 76       		.byte	118
 8283 01a4 00       		.byte	0
 8284 01a5 76       		.byte	118
 8285 01a6 C7       		.byte	-57
 8286 01a7 30       		.byte	48
 8287 01a8 01       		.byte	1
 8288 01a9 01       		.byte	1
 8289 01aa 00       		.byte	0
 8290 01ab 00000000 		.space	5
 8290      00
 8291 01b0 02       		.byte	2
 8292 01b1 02       		.byte	2
 8293 01b2 02       		.byte	2
 8294 01b3 00       		.byte	0
 8295 01b4 00       		.byte	0
 8296 01b5 FF       		.byte	-1
 8297 01b6 00       		.byte	0
 8298 01b7 01       		.byte	1
 8299 01b8 00       		.byte	0
 8300 01b9 03       		.byte	3
 8301 01ba 00       		.byte	0
 8302 01bb 70       		.byte	112
 8303 01bc 00       		.byte	0
 8304 01bd 70       		.byte	112
 8305 01be 00       		.byte	0
 8306 01bf C6       		.byte	-58
 8307 01c0 01       		.byte	1
 8308 01c1 01       		.byte	1
 8309 01c2 00       		.byte	0
 8310 01c3 00000000 		.space	5
 8310      00
 8311 01c8 00       		.byte	0
 8312 01c9 00       		.byte	0
 8313 01ca 02       		.byte	2
 8314 01cb 00       		.byte	0
 8315 01cc 00       		.byte	0
 8316 01cd 64       		.byte	100
 8317 01ce 00       		.byte	0
 8318 01cf 01       		.byte	1
 8319 01d0 00       		.byte	0
 8320 01d1 03       		.byte	3
 8321 01d2 00       		.byte	0
 8322 01d3 00       		.byte	0
 8323 01d4 00       		.byte	0
 8324 01d5 00       		.byte	0
 8325 01d6 00       		.byte	0
 8326 01d7 30       		.byte	48
 8327 01d8 01       		.byte	1
 8328 01d9 00       		.byte	0
 8329 01da 00       		.byte	0
 8330 01db 00000000 		.space	5
 8330      00
 8331 01e0 07       		.byte	7
 8332 01e1 07       		.byte	7
 8333 01e2 02       		.byte	2
 8334 01e3 00       		.byte	0
 8335 01e4 00       		.byte	0
 8336 01e5 01       		.byte	1
 8337 01e6 00       		.byte	0
 8338 01e7 01       		.byte	1
 8339 01e8 00       		.byte	0
 8340 01e9 03       		.byte	3
 8341 01ea 00       		.byte	0
 8342 01eb 01       		.byte	1
 8343 01ec 00       		.byte	0
 8344 01ed 01       		.byte	1
 8345 01ee 00       		.byte	0
 8346 01ef 30       		.byte	48
 8347 01f0 01       		.byte	1
 8348 01f1 00       		.byte	0
 8349 01f2 00       		.byte	0
 8350 01f3 00000000 		.space	5
 8350      00
 8351 01f8 DF       		.byte	-33
 8352 01f9 E1       		.byte	-31
 8353 01fa 02       		.byte	2
 8354 01fb 00       		.byte	0
 8355 01fc 00       		.byte	0
 8356 01fd FF       		.byte	-1
 8357 01fe 00       		.byte	0
 8358 01ff 01       		.byte	1
 8359 0200 00       		.byte	0
 8360 0201 03       		.byte	3
 8361 0202 00       		.byte	0
 8362 0203 80       		.byte	-128
 8363 0204 00       		.byte	0
 8364 0205 00       		.byte	0
 8365 0206 00       		.byte	0
 8366 0207 C6       		.byte	-58
 8367 0208 01       		.byte	1
 8368 0209 01       		.byte	1
 8369 020a 00       		.byte	0
 8370 020b 00000000 		.space	5
 8370      00
 8371 0210 85       		.byte	-123
 8372 0211 86       		.byte	-122
 8373 0212 02       		.byte	2
 8374 0213 00       		.byte	0
 8375 0214 00       		.byte	0
 8376 0215 64       		.byte	100
 8377 0216 00       		.byte	0
 8378 0217 01       		.byte	1
 8379 0218 00       		.byte	0
 8380 0219 03       		.byte	3
 8381 021a 00       		.byte	0
 8382 021b 32       		.byte	50
 8383 021c 00       		.byte	0
 8384 021d 32       		.byte	50
 8385 021e 00       		.byte	0
 8386 021f F2       		.byte	-14
 8387 0220 01       		.byte	1
 8388 0221 01       		.byte	1
 8389 0222 00       		.byte	0
 8390 0223 00000000 		.space	5
 8390      00
 8391 0228 06       		.byte	6
 8392 0229 06       		.byte	6
 8393 022a 02       		.byte	2
 8394 022b 00       		.byte	0
 8395 022c 00       		.byte	0
 8396 022d 40       		.byte	64
 8397 022e 00       		.byte	0
 8398 022f 01       		.byte	1
 8399 0230 00       		.byte	0
 8400 0231 03       		.byte	3
 8401 0232 00       		.byte	0
 8402 0233 20       		.byte	32
 8403 0234 00       		.byte	0
 8404 0235 20       		.byte	32
 8405 0236 00       		.byte	0
 8406 0237 30       		.byte	48
 8407 0238 01       		.byte	1
 8408 0239 01       		.byte	1
 8409 023a 00       		.byte	0
 8410 023b 00000000 		.space	5
 8410      00
 8411 0240 00       		.byte	0
 8412 0241 00       		.byte	0
 8413 0242 02       		.byte	2
 8414 0243 00       		.byte	0
 8415 0244 00       		.byte	0
 8416 0245 64       		.byte	100
 8417 0246 00       		.byte	0
 8418 0247 01       		.byte	1
 8419 0248 00       		.byte	0
 8420 0249 03       		.byte	3
 8421 024a 00       		.byte	0
 8422 024b 00       		.byte	0
 8423 024c 00       		.byte	0
 8424 024d 00       		.byte	0
 8425 024e 00       		.byte	0
 8426 024f 30       		.byte	48
 8427 0250 01       		.byte	1
 8428 0251 00       		.byte	0
 8429 0252 00       		.byte	0
 8430 0253 00000000 		.space	5
 8430      00
 8431 0258 08       		.byte	8
 8432 0259 08       		.byte	8
 8433 025a 02       		.byte	2
 8434 025b 00       		.byte	0
 8435 025c 00       		.byte	0
 8436 025d 05       		.byte	5
 8437 025e 00       		.byte	0
 8438 025f 01       		.byte	1
 8439 0260 00       		.byte	0
 8440 0261 03       		.byte	3
 8441 0262 00       		.byte	0
 8442 0263 00       		.byte	0
 8443 0264 00       		.byte	0
 8444 0265 00       		.byte	0
 8445 0266 00       		.byte	0
 8446 0267 30       		.byte	48
 8447 0268 01       		.byte	1
 8448 0269 00       		.byte	0
 8449 026a 00       		.byte	0
 8450 026b 00000000 		.space	5
 8450      00
 8451 0270 00       		.byte	0
 8452 0271 00       		.byte	0
 8453 0272 02       		.byte	2
 8454 0273 00       		.byte	0
 8455 0274 00       		.byte	0
 8456 0275 40       		.byte	64
 8457 0276 00       		.byte	0
 8458 0277 01       		.byte	1
 8459 0278 00       		.byte	0
 8460 0279 03       		.byte	3
 8461 027a 00       		.byte	0
 8462 027b 00       		.byte	0
 8463 027c 00       		.byte	0
 8464 027d 00       		.byte	0
 8465 027e 00       		.byte	0
 8466 027f 30       		.byte	48
 8467 0280 01       		.byte	1
 8468 0281 00       		.byte	0
 8469 0282 00       		.byte	0
 8470 0283 00000000 		.space	5
 8470      00
 8471 0288 09       		.byte	9
 8472 0289 0A       		.byte	10
 8473 028a 04       		.byte	4
 8474 028b 00       		.byte	0
 8475 028c 00       		.byte	0
 8476 028d 40       		.byte	64
 8477 028e 00       		.byte	0
 8478 028f 01       		.byte	1
 8479 0290 00       		.byte	0
 8480 0291 03       		.byte	3
 8481 0292 00       		.byte	0
 8482 0293 20       		.byte	32
 8483 0294 38       		.byte	56
 8484 0295 20       		.byte	32
 8485 0296 38       		.byte	56
 8486 0297 30       		.byte	48
 8487 0298 01       		.byte	1
 8488 0299 00       		.byte	0
 8489 029a 00       		.byte	0
 8490 029b 00000000 		.space	5
 8490      00
 8491 02a0 00       		.byte	0
 8492 02a1 00       		.byte	0
 8493 02a2 02       		.byte	2
 8494 02a3 00       		.byte	0
 8495 02a4 00       		.byte	0
 8496 02a5 64       		.byte	100
 8497 02a6 00       		.byte	0
 8498 02a7 01       		.byte	1
 8499 02a8 00       		.byte	0
 8500 02a9 03       		.byte	3
 8501 02aa 00       		.byte	0
 8502 02ab 00       		.byte	0
 8503 02ac 00       		.byte	0
 8504 02ad 00       		.byte	0
 8505 02ae 00       		.byte	0
 8506 02af 30       		.byte	48
 8507 02b0 01       		.byte	1
 8508 02b1 00       		.byte	0
 8509 02b2 00       		.byte	0
 8510 02b3 00000000 		.space	5
 8510      00
 8511 02b8 00       		.byte	0
 8512 02b9 00       		.byte	0
 8513 02ba 02       		.byte	2
 8514 02bb 00       		.byte	0
 8515 02bc 00       		.byte	0
 8516 02bd 64       		.byte	100
 8517 02be 00       		.byte	0
 8518 02bf 01       		.byte	1
 8519 02c0 00       		.byte	0
 8520 02c1 03       		.byte	3
 8521 02c2 00       		.byte	0
 8522 02c3 00       		.byte	0
 8523 02c4 00       		.byte	0
 8524 02c5 00       		.byte	0
 8525 02c6 00       		.byte	0
 8526 02c7 30       		.byte	48
 8527 02c8 01       		.byte	1
 8528 02c9 00       		.byte	0
 8529 02ca 00       		.byte	0
 8530 02cb 00000000 		.space	5
 8530      00
 8531 02d0 2A       		.byte	42
 8532 02d1 2A       		.byte	42
 8533 02d2 02       		.byte	2
 8534 02d3 00       		.byte	0
 8535 02d4 00       		.byte	0
 8536 02d5 1B       		.byte	27
 8537 02d6 00       		.byte	0
 8538 02d7 01       		.byte	1
 8539 02d8 00       		.byte	0
 8540 02d9 03       		.byte	3
 8541 02da 00       		.byte	0
 8542 02db 00       		.byte	0
 8543 02dc 00       		.byte	0
 8544 02dd 00       		.byte	0
 8545 02de 00       		.byte	0
 8546 02df 30       		.byte	48
 8547 02e0 01       		.byte	1
 8548 02e1 00       		.byte	0
 8549 02e2 00       		.byte	0
 8550 02e3 00000000 		.space	5
 8550      00
 8551 02e8 00       		.byte	0
 8552 02e9 00       		.byte	0
 8553 02ea 02       		.byte	2
 8554 02eb 00       		.byte	0
 8555 02ec 00       		.byte	0
 8556 02ed 64       		.byte	100
 8557 02ee 00       		.byte	0
 8558 02ef 01       		.byte	1
 8559 02f0 00       		.byte	0
 8560 02f1 03       		.byte	3
 8561 02f2 00       		.byte	0
 8562 02f3 00       		.byte	0
 8563 02f4 00       		.byte	0
 8564 02f5 00       		.byte	0
 8565 02f6 00       		.byte	0
 8566 02f7 30       		.byte	48
 8567 02f8 01       		.byte	1
 8568 02f9 00       		.byte	0
 8569 02fa 00       		.byte	0
 8570 02fb 00000000 		.space	5
 8570      00
 8571 0300 00       		.byte	0
 8572 0301 00       		.byte	0
 8573 0302 02       		.byte	2
 8574 0303 00       		.byte	0
 8575 0304 00       		.byte	0
 8576 0305 12       		.byte	18
 8577 0306 00       		.byte	0
 8578 0307 01       		.byte	1
 8579 0308 00       		.byte	0
 8580 0309 03       		.byte	3
 8581 030a 00       		.byte	0
 8582 030b 00       		.byte	0
 8583 030c 00       		.byte	0
 8584 030d 00       		.byte	0
 8585 030e 00       		.byte	0
 8586 030f 30       		.byte	48
 8587 0310 01       		.byte	1
 8588 0311 00       		.byte	0
 8589 0312 00       		.byte	0
 8590 0313 00000000 		.space	5
 8590      00
 8591 0318 01       		.byte	1
 8592 0319 01       		.byte	1
 8593 031a 02       		.byte	2
 8594 031b 00       		.byte	0
 8595 031c 00       		.byte	0
 8596 031d 09       		.byte	9
 8597 031e 00       		.byte	0
 8598 031f 01       		.byte	1
 8599 0320 00       		.byte	0
 8600 0321 03       		.byte	3
 8601 0322 00       		.byte	0
 8602 0323 00       		.byte	0
 8603 0324 00       		.byte	0
 8604 0325 01       		.byte	1
 8605 0326 00       		.byte	0
 8606 0327 30       		.byte	48
 8607 0328 01       		.byte	1
 8608 0329 00       		.byte	0
 8609 032a 00       		.byte	0
 8610 032b 00000000 		.space	5
 8610      00
 8611 0330 05       		.byte	5
 8612 0331 05       		.byte	5
 8613 0332 02       		.byte	2
 8614 0333 00       		.byte	0
 8615 0334 00       		.byte	0
 8616 0335 03       		.byte	3
 8617 0336 00       		.byte	0
 8618 0337 01       		.byte	1
 8619 0338 00       		.byte	0
 8620 0339 03       		.byte	3
 8621 033a 00       		.byte	0
 8622 033b 00       		.byte	0
 8623 033c 00       		.byte	0
 8624 033d 00       		.byte	0
 8625 033e 00       		.byte	0
 8626 033f 30       		.byte	48
 8627 0340 01       		.byte	1
 8628 0341 00       		.byte	0
 8629 0342 00       		.byte	0
 8630 0343 00000000 		.space	5
 8630      00
 8631 0348 18       		.byte	24
 8632 0349 18       		.byte	24
 8633 034a 02       		.byte	2
 8634 034b 00       		.byte	0
 8635 034c 00       		.byte	0
 8636 034d 01       		.byte	1
 8637 034e 00       		.byte	0
 8638 034f 01       		.byte	1
 8639 0350 00       		.byte	0
 8640 0351 03       		.byte	3
 8641 0352 00       		.byte	0
 8642 0353 00       		.byte	0
 8643 0354 00       		.byte	0
 8644 0355 00       		.byte	0
 8645 0356 00       		.byte	0
 8646 0357 30       		.byte	48
 8647 0358 01       		.byte	1
 8648 0359 00       		.byte	0
 8649 035a 00       		.byte	0
 8650 035b 00000000 		.space	5
 8650      00
 8651 0360 19       		.byte	25
 8652 0361 19       		.byte	25
 8653 0362 01       		.byte	1
 8654 0363 00       		.byte	0
 8655 0364 00       		.byte	0
 8656 0365 40       		.byte	64
 8657 0366 00       		.byte	0
 8658 0367 01       		.byte	1
 8659 0368 00       		.byte	0
 8660 0369 03       		.byte	3
 8661 036a 00       		.byte	0
 8662 036b 20       		.byte	32
 8663 036c 00       		.byte	0
 8664 036d 20       		.byte	32
 8665 036e 00       		.byte	0
 8666 036f 30       		.byte	48
 8667 0370 01       		.byte	1
 8668 0371 00       		.byte	0
 8669 0372 00       		.byte	0
 8670 0373 00000000 		.space	5
 8670      00
 8671 0378 20       		.byte	32
 8672 0379 20       		.byte	32
 8673 037a 02       		.byte	2
 8674 037b 00       		.byte	0
 8675 037c 00       		.byte	0
 8676 037d 02       		.byte	2
 8677 037e 00       		.byte	0
 8678 037f 01       		.byte	1
 8679 0380 00       		.byte	0
 8680 0381 03       		.byte	3
 8681 0382 00       		.byte	0
 8682 0383 00       		.byte	0
 8683 0384 00       		.byte	0
 8684 0385 00       		.byte	0
 8685 0386 00       		.byte	0
 8686 0387 30       		.byte	48
 8687 0388 01       		.byte	1
 8688 0389 00       		.byte	0
 8689 038a 00       		.byte	0
 8690 038b 00000000 		.space	5
 8690      00
 8691 0390 22       		.byte	34
 8692 0391 22       		.byte	34
 8693 0392 02       		.byte	2
 8694 0393 00       		.byte	0
 8695 0394 00       		.byte	0
 8696 0395 3F       		.byte	63
 8697 0396 00       		.byte	0
 8698 0397 01       		.byte	1
 8699 0398 00       		.byte	0
 8700 0399 03       		.byte	3
 8701 039a 00       		.byte	0
 8702 039b 00       		.byte	0
 8703 039c 00       		.byte	0
 8704 039d 00       		.byte	0
 8705 039e 00       		.byte	0
 8706 039f 30       		.byte	48
 8707 03a0 01       		.byte	1
 8708 03a1 00       		.byte	0
 8709 03a2 00       		.byte	0
 8710 03a3 00000000 		.space	5
 8710      00
 8711 03a8 23       		.byte	35
 8712 03a9 23       		.byte	35
 8713 03aa 02       		.byte	2
 8714 03ab 00       		.byte	0
 8715 03ac 00       		.byte	0
 8716 03ad 64       		.byte	100
 8717 03ae 00       		.byte	0
 8718 03af 01       		.byte	1
 8719 03b0 00       		.byte	0
 8720 03b1 03       		.byte	3
 8721 03b2 00       		.byte	0
 8722 03b3 10       		.byte	16
 8723 03b4 00       		.byte	0
 8724 03b5 10       		.byte	16
 8725 03b6 00       		.byte	0
 8726 03b7 30       		.byte	48
 8727 03b8 01       		.byte	1
 8728 03b9 00       		.byte	0
 8729 03ba 00       		.byte	0
 8730 03bb 00000000 		.space	5
 8730      00
 8731 03c0 24       		.byte	36
 8732 03c1 24       		.byte	36
 8733 03c2 02       		.byte	2
 8734 03c3 00       		.byte	0
 8735 03c4 00       		.byte	0
 8736 03c5 64       		.byte	100
 8737 03c6 00       		.byte	0
 8738 03c7 01       		.byte	1
 8739 03c8 00       		.byte	0
 8740 03c9 03       		.byte	3
 8741 03ca 00       		.byte	0
 8742 03cb 10       		.byte	16
 8743 03cc 00       		.byte	0
 8744 03cd 10       		.byte	16
 8745 03ce 00       		.byte	0
 8746 03cf 30       		.byte	48
 8747 03d0 01       		.byte	1
 8748 03d1 00       		.byte	0
 8749 03d2 00       		.byte	0
 8750 03d3 00000000 		.space	5
 8750      00
 8751 03d8 02       		.byte	2
 8752 03d9 03       		.byte	3
 8753 03da 04       		.byte	4
 8754 03db 00       		.byte	0
 8755 03dc 00       		.byte	0
 8756 03dd 7F       		.byte	127
 8757 03de 00       		.byte	0
 8758 03df 01       		.byte	1
 8759 03e0 00       		.byte	0
 8760 03e1 03       		.byte	3
 8761 03e2 00       		.byte	0
 8762 03e3 00       		.byte	0
 8763 03e4 20       		.byte	32
 8764 03e5 00       		.byte	0
 8765 03e6 20       		.byte	32
 8766 03e7 30       		.byte	48
 8767 03e8 01       		.byte	1
 8768 03e9 00       		.byte	0
 8769 03ea 00       		.byte	0
 8770 03eb 00000000 		.space	5
 8770      00
 8771 03f0 04       		.byte	4
 8772 03f1 04       		.byte	4
 8773 03f2 02       		.byte	2
 8774 03f3 00       		.byte	0
 8775 03f4 00       		.byte	0
 8776 03f5 40       		.byte	64
 8777 03f6 00       		.byte	0
 8778 03f7 01       		.byte	1
 8779 03f8 00       		.byte	0
 8780 03f9 03       		.byte	3
 8781 03fa 00       		.byte	0
 8782 03fb 20       		.byte	32
 8783 03fc 00       		.byte	0
 8784 03fd 20       		.byte	32
 8785 03fe 00       		.byte	0
 8786 03ff 30       		.byte	48
 8787 0400 01       		.byte	1
 8788 0401 00       		.byte	0
 8789 0402 00       		.byte	0
 8790 0403 00000000 		.space	5
 8790      00
 8791 0408 00       		.byte	0
 8792 0409 00       		.byte	0
 8793 040a 02       		.byte	2
 8794 040b 00       		.byte	0
 8795 040c 00       		.byte	0
 8796 040d 19       		.byte	25
 8797 040e 00       		.byte	0
 8798 040f 01       		.byte	1
 8799 0410 00       		.byte	0
 8800 0411 03       		.byte	3
 8801 0412 00       		.byte	0
 8802 0413 00       		.byte	0
 8803 0414 00       		.byte	0
 8804 0415 00       		.byte	0
 8805 0416 00       		.byte	0
 8806 0417 30       		.byte	48
 8807 0418 01       		.byte	1
 8808 0419 00       		.byte	0
 8809 041a 00       		.byte	0
 8810 041b 00000000 		.space	5
 8810      00
 8811 0420 10       		.byte	16
 8812 0421 10       		.byte	16
 8813 0422 02       		.byte	2
 8814 0423 00       		.byte	0
 8815 0424 00       		.byte	0
 8816 0425 06       		.byte	6
 8817 0426 00       		.byte	0
 8818 0427 01       		.byte	1
 8819 0428 00       		.byte	0
 8820 0429 03       		.byte	3
 8821 042a 00       		.byte	0
 8822 042b 03       		.byte	3
 8823 042c 00       		.byte	0
 8824 042d 03       		.byte	3
 8825 042e 00       		.byte	0
 8826 042f 30       		.byte	48
 8827 0430 01       		.byte	1
 8828 0431 00       		.byte	0
 8829 0432 00       		.byte	0
 8830 0433 00000000 		.space	5
 8830      00
 8831 0438 00       		.byte	0
 8832 0439 00       		.byte	0
 8833 043a 02       		.byte	2
 8834 043b 00       		.byte	0
 8835 043c 00       		.byte	0
 8836 043d 03       		.byte	3
 8837 043e 00       		.byte	0
 8838 043f 01       		.byte	1
 8839 0440 00       		.byte	0
 8840 0441 03       		.byte	3
 8841 0442 00       		.byte	0
 8842 0443 00       		.byte	0
 8843 0444 00       		.byte	0
 8844 0445 00       		.byte	0
 8845 0446 00       		.byte	0
 8846 0447 30       		.byte	48
 8847 0448 01       		.byte	1
 8848 0449 00       		.byte	0
 8849 044a 00       		.byte	0
 8850 044b 00000000 		.space	5
 8850      00
 8851 0450 50       		.byte	80
 8852 0451 50       		.byte	80
 8853 0452 01       		.byte	1
 8854 0453 00       		.byte	0
 8855 0454 00       		.byte	0
 8856 0455 03       		.byte	3
 8857 0456 00       		.byte	0
 8858 0457 01       		.byte	1
 8859 0458 00       		.byte	0
 8860 0459 03       		.byte	3
 8861 045a 00       		.byte	0
 8862 045b 00       		.byte	0
 8863 045c 00       		.byte	0
 8864 045d 00       		.byte	0
 8865 045e 00       		.byte	0
 8866 045f 30       		.byte	48
 8867 0460 01       		.byte	1
 8868 0461 00       		.byte	0
 8869 0462 00       		.byte	0
 8870 0463 00000000 		.space	5
 8870      00
 8871 0468 00       		.byte	0
 8872 0469 00       		.byte	0
 8873 046a 0B       		.byte	11
 8874 046b 00       		.byte	0
 8875 046c 00       		.byte	0
 8876 046d FF       		.byte	-1
 8877 046e FF       		.byte	-1
 8878 046f 01       		.byte	1
 8879 0470 00       		.byte	0
 8880 0471 03       		.byte	3
 8881 0472 00       		.byte	0
 8882 0473 00       		.byte	0
 8883 0474 00       		.byte	0
 8884 0475 00       		.byte	0
 8885 0476 00       		.byte	0
 8886 0477 00       		.byte	0
 8887 0478 01       		.byte	1
 8888 0479 00       		.byte	0
 8889 047a 00       		.byte	0
 8890 047b 00000000 		.space	5
 8890      00
 8893              	glUVCHeader:
 8894 0480 0C       		.byte	12
 8895 0481 8C       		.byte	-116
 8896 0482 00       		.byte	0
 8897 0483 00       		.byte	0
 8898 0484 00       		.byte	0
 8899 0485 00       		.byte	0
 8900 0486 00       		.byte	0
 8901 0487 00       		.byte	0
 8902 0488 00       		.byte	0
 8903 0489 00       		.byte	0
 8904 048a 00       		.byte	0
 8905 048b 00       		.byte	0
 8908              	ROIMode:
 8909 048c 01       		.byte	1
 8910 048d 000000   		.space	3
 8913              	EXTShutter:
 8914 0490 00       		.byte	0
 8915 0491 02       		.byte	2
 8916 0492 02       		.byte	2
 8917 0493 00       		.byte	0
 8918 0494 00       		.byte	0
 8919 0495 08       		.byte	8
 8920 0496 00       		.byte	0
 8921 0497 01       		.byte	1
 8922 0498 00       		.byte	0
 8923 0499 03       		.byte	3
 8924 049a 00       		.byte	0
 8925 049b 00       		.byte	0
 8926 049c 00       		.byte	0
 8927 049d 00       		.byte	0
 8928 049e 00       		.byte	0
 8929 049f 30       		.byte	48
 8930 04a0 01       		.byte	1
 8931 04a1 00       		.byte	0
 8932 04a2 0000     		.space	2
 8935              	EXTShutlev:
 8936 04a4 02       		.byte	2
 8937 04a5 12       		.byte	18
 8938 04a6 02       		.byte	2
 8939 04a7 00       		.byte	0
 8940 04a8 00       		.byte	0
 8941 04a9 FF       		.byte	-1
 8942 04aa 7F       		.byte	127
 8943 04ab 01       		.byte	1
 8944 04ac 00       		.byte	0
 8945 04ad 03       		.byte	3
 8946 04ae 00       		.byte	0
 8947 04af 3F       		.byte	63
 8948 04b0 00       		.byte	0
 8949 04b1 3F       		.byte	63
 8950 04b2 00       		.byte	0
 8951 04b3 30       		.byte	48
 8952 04b4 01       		.byte	1
 8953 04b5 00       		.byte	0
 8954 04b6 0000     		.space	2
 8957              	EXTAexModGainlev:
 8958 04b8 00       		.byte	0
 8959 04b9 03       		.byte	3
 8960 04ba 04       		.byte	4
 8961 04bb 00       		.byte	0
 8962 04bc 00       		.byte	0
 8963 04bd 03       		.byte	3
 8964 04be 7F       		.byte	127
 8965 04bf 01       		.byte	1
 8966 04c0 00       		.byte	0
 8967 04c1 03       		.byte	3
 8968 04c2 00       		.byte	0
 8969 04c3 00       		.byte	0
 8970 04c4 3F       		.byte	63
 8971 04c5 00       		.byte	0
 8972 04c6 3F       		.byte	63
 8973 04c7 30       		.byte	48
 8974 04c8 01       		.byte	1
 8975 04c9 00       		.byte	0
 8976 04ca 0000     		.space	2
 8979              	WBMenuCmpArry:
 8980 04cc 20       		.byte	32
 8981 04cd 0F       		.byte	15
 8982 04ce 38       		.byte	56
 8983 04cf F0       		.byte	-16
 8986              	CTCtrlParArry:
 8987 04d0 00       		.byte	0
 8988 04d1 00       		.byte	0
 8989 04d2 01       		.byte	1
 8990 04d3 00       		.byte	0
 8991 04d4 00       		.byte	0
 8992 04d5 03       		.byte	3
 8993 04d6 00       		.byte	0
 8994 04d7 01       		.byte	1
 8995 04d8 00       		.byte	0
 8996 04d9 03       		.byte	3
 8997 04da 00       		.byte	0
 8998 04db 03       		.byte	3
 8999 04dc 00       		.byte	0
 9000 04dd 03       		.byte	3
 9001 04de 00       		.byte	0
 9002 04df 30       		.byte	48
 9003 04e0 01       		.byte	1
 9004 04e1 00       		.byte	0
 9005 04e2 00       		.byte	0
 9006 04e3 00000000 		.space	5
 9006      00
 9007 04e8 00       		.byte	0
 9008 04e9 00       		.byte	0
 9009 04ea 01       		.byte	1
 9010 04eb 01       		.byte	1
 9011 04ec 00       		.byte	0
 9012 04ed 0F       		.byte	15
 9013 04ee 00       		.byte	0
 9014 04ef 0F       		.byte	15
 9015 04f0 00       		.byte	0
 9016 04f1 03       		.byte	3
 9017 04f2 00       		.byte	0
 9018 04f3 02       		.byte	2
 9019 04f4 00       		.byte	0
 9020 04f5 02       		.byte	2
 9021 04f6 00       		.byte	0
 9022 04f7 30       		.byte	48
 9023 04f8 01       		.byte	1
 9024 04f9 01       		.byte	1
 9025 04fa 00       		.byte	0
 9026 04fb 00000000 		.space	5
 9026      00
 9027 0500 02       		.byte	2
 9028 0501 00       		.byte	0
 9029 0502 01       		.byte	1
 9030 0503 00       		.byte	0
 9031 0504 00       		.byte	0
 9032 0505 01       		.byte	1
 9033 0506 00       		.byte	0
 9034 0507 01       		.byte	1
 9035 0508 00       		.byte	0
 9036 0509 03       		.byte	3
 9037 050a 00       		.byte	0
 9038 050b 00       		.byte	0
 9039 050c 00       		.byte	0
 9040 050d 00       		.byte	0
 9041 050e 00       		.byte	0
 9042 050f 30       		.byte	48
 9043 0510 01       		.byte	1
 9044 0511 01       		.byte	1
 9045 0512 00       		.byte	0
 9046 0513 00000000 		.space	5
 9046      00
 9047 0518 00       		.byte	0
 9048 0519 00       		.byte	0
 9049 051a 04       		.byte	4
 9050 051b 01       		.byte	1
 9051 051c 00       		.byte	0
 9052 051d 38       		.byte	56
 9053 051e 01       		.byte	1
 9054 051f 01       		.byte	1
 9055 0520 00       		.byte	0
 9056 0521 03       		.byte	3
 9057 0522 00       		.byte	0
 9058 0523 4E       		.byte	78
 9059 0524 00       		.byte	0
 9060 0525 4E       		.byte	78
 9061 0526 00       		.byte	0
 9062 0527 30       		.byte	48
 9063 0528 01       		.byte	1
 9064 0529 00       		.byte	0
 9065 052a 00       		.byte	0
 9066 052b 00000000 		.space	5
 9066      00
 9067 0530 04       		.byte	4
 9068 0531 00       		.byte	0
 9069 0532 01       		.byte	1
 9070 0533 00       		.byte	0
 9071 0534 00       		.byte	0
 9072 0535 00       		.byte	0
 9073 0536 00       		.byte	0
 9074 0537 01       		.byte	1
 9075 0538 00       		.byte	0
 9076 0539 03       		.byte	3
 9077 053a 00       		.byte	0
 9078 053b 00       		.byte	0
 9079 053c 00       		.byte	0
 9080 053d 00       		.byte	0
 9081 053e 00       		.byte	0
 9082 053f 30       		.byte	48
 9083 0540 01       		.byte	1
 9084 0541 00       		.byte	0
 9085 0542 00       		.byte	0
 9086 0543 00000000 		.space	5
 9086      00
 9087 0548 05       		.byte	5
 9088 0549 00       		.byte	0
 9089 054a 02       		.byte	2
 9090 054b 00       		.byte	0
 9091 054c 00       		.byte	0
 9092 054d FF       		.byte	-1
 9093 054e 00       		.byte	0
 9094 054f 01       		.byte	1
 9095 0550 00       		.byte	0
 9096 0551 03       		.byte	3
 9097 0552 00       		.byte	0
 9098 0553 01       		.byte	1
 9099 0554 00       		.byte	0
 9100 0555 00       		.byte	0
 9101 0556 00       		.byte	0
 9102 0557 30       		.byte	48
 9103 0558 01       		.byte	1
 9104 0559 01       		.byte	1
 9105 055a 00       		.byte	0
 9106 055b 00000000 		.space	5
 9106      00
 9107 0560 06       		.byte	6
 9108 0561 00       		.byte	0
 9109 0562 02       		.byte	2
 9110 0563 00       		.byte	0
 9111 0564 00       		.byte	0
 9112 0565 00       		.byte	0
 9113 0566 00       		.byte	0
 9114 0567 00       		.byte	0
 9115 0568 00       		.byte	0
 9116 0569 03       		.byte	3
 9117 056a 00       		.byte	0
 9118 056b 00       		.byte	0
 9119 056c 00       		.byte	0
 9120 056d 00       		.byte	0
 9121 056e 00       		.byte	0
 9122 056f 30       		.byte	48
 9123 0570 01       		.byte	1
 9124 0571 01       		.byte	1
 9125 0572 00       		.byte	0
 9126 0573 00000000 		.space	5
 9126      00
 9127 0578 23       		.byte	35
 9128 0579 00       		.byte	0
 9129 057a 02       		.byte	2
 9130 057b 00       		.byte	0
 9131 057c 00       		.byte	0
 9132 057d 30       		.byte	48
 9133 057e 00       		.byte	0
 9134 057f 01       		.byte	1
 9135 0580 00       		.byte	0
 9136 0581 03       		.byte	3
 9137 0582 0A       		.byte	10
 9138 0583 00       		.byte	0
 9139 0584 00       		.byte	0
 9140 0585 0A       		.byte	10
 9141 0586 00       		.byte	0
 9142 0587 30       		.byte	48
 9143 0588 01       		.byte	1
 9144 0589 01       		.byte	1
 9145 058a 00       		.byte	0
 9146 058b 00000000 		.space	5
 9146      00
 9147 0590 08       		.byte	8
 9148 0591 00       		.byte	0
 9149 0592 01       		.byte	1
 9150 0593 00       		.byte	0
 9151 0594 00       		.byte	0
 9152 0595 7F       		.byte	127
 9153 0596 00       		.byte	0
 9154 0597 01       		.byte	1
 9155 0598 00       		.byte	0
 9156 0599 03       		.byte	3
 9157 059a 00       		.byte	0
 9158 059b 00       		.byte	0
 9159 059c 00       		.byte	0
 9160 059d 00       		.byte	0
 9161 059e 00       		.byte	0
 9162 059f 30       		.byte	48
 9163 05a0 01       		.byte	1
 9164 05a1 00       		.byte	0
 9165 05a2 00       		.byte	0
 9166 05a3 00000000 		.space	5
 9166      00
 9167 05a8 09       		.byte	9
 9168 05a9 00       		.byte	0
 9169 05aa 02       		.byte	2
 9170 05ab 00       		.byte	0
 9171 05ac 00       		.byte	0
 9172 05ad 05       		.byte	5
 9173 05ae 00       		.byte	0
 9174 05af 01       		.byte	1
 9175 05b0 00       		.byte	0
 9176 05b1 03       		.byte	3
 9177 05b2 00       		.byte	0
 9178 05b3 00       		.byte	0
 9179 05b4 00       		.byte	0
 9180 05b5 00       		.byte	0
 9181 05b6 00       		.byte	0
 9182 05b7 30       		.byte	48
 9183 05b8 01       		.byte	1
 9184 05b9 00       		.byte	0
 9185 05ba 00       		.byte	0
 9186 05bb 00000000 		.space	5
 9186      00
 9187 05c0 10       		.byte	16
 9188 05c1 00       		.byte	0
 9189 05c2 03       		.byte	3
 9190 05c3 00       		.byte	0
 9191 05c4 00       		.byte	0
 9192 05c5 00       		.byte	0
 9193 05c6 00       		.byte	0
 9194 05c7 00       		.byte	0
 9195 05c8 00       		.byte	0
 9196 05c9 03       		.byte	3
 9197 05ca 00       		.byte	0
 9198 05cb 00       		.byte	0
 9199 05cc 00       		.byte	0
 9200 05cd 00       		.byte	0
 9201 05ce 00       		.byte	0
 9202 05cf 30       		.byte	48
 9203 05d0 01       		.byte	1
 9204 05d1 00       		.byte	0
 9205 05d2 00       		.byte	0
 9206 05d3 00000000 		.space	5
 9206      00
 9207 05d8 00       		.byte	0
 9208 05d9 00       		.byte	0
 9209 05da 02       		.byte	2
 9210 05db 00       		.byte	0
 9211 05dc 00       		.byte	0
 9212 05dd 40       		.byte	64
 9213 05de 00       		.byte	0
 9214 05df 01       		.byte	1
 9215 05e0 00       		.byte	0
 9216 05e1 03       		.byte	3
 9217 05e2 00       		.byte	0
 9218 05e3 0F       		.byte	15
 9219 05e4 11       		.byte	17
 9220 05e5 00       		.byte	0
 9221 05e6 00       		.byte	0
 9222 05e7 30       		.byte	48
 9223 05e8 01       		.byte	1
 9224 05e9 00       		.byte	0
 9225 05ea 00       		.byte	0
 9226 05eb 00000000 		.space	5
 9226      00
 9227 05f0 00       		.byte	0
 9228 05f1 00       		.byte	0
 9229 05f2 02       		.byte	2
 9230 05f3 00       		.byte	0
 9231 05f4 00       		.byte	0
 9232 05f5 64       		.byte	100
 9233 05f6 00       		.byte	0
 9234 05f7 01       		.byte	1
 9235 05f8 00       		.byte	0
 9236 05f9 03       		.byte	3
 9237 05fa 00       		.byte	0
 9238 05fb 00       		.byte	0
 9239 05fc 00       		.byte	0
 9240 05fd 00       		.byte	0
 9241 05fe 00       		.byte	0
 9242 05ff 30       		.byte	48
 9243 0600 01       		.byte	1
 9244 0601 00       		.byte	0
 9245 0602 00       		.byte	0
 9246 0603 00000000 		.space	5
 9246      00
 9247 0608 00       		.byte	0
 9248 0609 00       		.byte	0
 9249 060a 02       		.byte	2
 9250 060b 00       		.byte	0
 9251 060c 00       		.byte	0
 9252 060d 64       		.byte	100
 9253 060e 00       		.byte	0
 9254 060f 01       		.byte	1
 9255 0610 00       		.byte	0
 9256 0611 03       		.byte	3
 9257 0612 00       		.byte	0
 9258 0613 00       		.byte	0
 9259 0614 00       		.byte	0
 9260 0615 00       		.byte	0
 9261 0616 00       		.byte	0
 9262 0617 30       		.byte	48
 9263 0618 01       		.byte	1
 9264 0619 00       		.byte	0
 9265 061a 00       		.byte	0
 9266 061b 00000000 		.space	5
 9266      00
 9267 0620 00       		.byte	0
 9268 0621 00       		.byte	0
 9269 0622 02       		.byte	2
 9270 0623 00       		.byte	0
 9271 0624 00       		.byte	0
 9272 0625 64       		.byte	100
 9273 0626 00       		.byte	0
 9274 0627 01       		.byte	1
 9275 0628 00       		.byte	0
 9276 0629 03       		.byte	3
 9277 062a 00       		.byte	0
 9278 062b 00       		.byte	0
 9279 062c 00       		.byte	0
 9280 062d 00       		.byte	0
 9281 062e 00       		.byte	0
 9282 062f 30       		.byte	48
 9283 0630 01       		.byte	1
 9284 0631 00       		.byte	0
 9285 0632 00       		.byte	0
 9286 0633 00000000 		.space	5
 9286      00
 9287 0638 00       		.byte	0
 9288 0639 00       		.byte	0
 9289 063a 02       		.byte	2
 9290 063b 00       		.byte	0
 9291 063c 00       		.byte	0
 9292 063d 64       		.byte	100
 9293 063e 00       		.byte	0
 9294 063f 01       		.byte	1
 9295 0640 00       		.byte	0
 9296 0641 03       		.byte	3
 9297 0642 00       		.byte	0
 9298 0643 00       		.byte	0
 9299 0644 00       		.byte	0
 9300 0645 00       		.byte	0
 9301 0646 00       		.byte	0
 9302 0647 30       		.byte	48
 9303 0648 01       		.byte	1
 9304 0649 00       		.byte	0
 9305 064a 00       		.byte	0
 9306 064b 00000000 		.space	5
 9306      00
 9309              	glProbeCtrlFull:
 9310 0650 00       		.byte	0
 9311 0651 00       		.byte	0
 9312 0652 01       		.byte	1
 9313 0653 01       		.byte	1
 9314 0654 15       		.byte	21
 9315 0655 16       		.byte	22
 9316 0656 05       		.byte	5
 9317 0657 00       		.byte	0
 9318 0658 00       		.byte	0
 9319 0659 00       		.byte	0
 9320 065a 00       		.byte	0
 9321 065b 00       		.byte	0
 9322 065c 00       		.byte	0
 9323 065d 00       		.byte	0
 9324 065e 00       		.byte	0
 9325 065f 00       		.byte	0
 9326 0660 00       		.byte	0
 9327 0661 00       		.byte	0
 9328 0662 00       		.byte	0
 9329 0663 C6       		.byte	-58
 9330 0664 99       		.byte	-103
 9331 0665 00       		.byte	0
 9332 0666 00       		.byte	0
 9333 0667 40       		.byte	64
 9334 0668 00       		.byte	0
 9335 0669 00       		.byte	0
 9336 066a 0000     		.space	2
 9339              	glProbeCtrl20:
 9340 066c 00       		.byte	0
 9341 066d 00       		.byte	0
 9342 066e 01       		.byte	1
 9343 066f 01       		.byte	1
 9344 0670 80       		.byte	-128
 9345 0671 1A       		.byte	26
 9346 0672 06       		.byte	6
 9347 0673 00       		.byte	0
 9348 0674 00       		.byte	0
 9349 0675 00       		.byte	0
 9350 0676 00       		.byte	0
 9351 0677 00       		.byte	0
 9352 0678 00       		.byte	0
 9353 0679 00       		.byte	0
 9354 067a 00       		.byte	0
 9355 067b 00       		.byte	0
 9356 067c 00       		.byte	0
 9357 067d 00       		.byte	0
 9358 067e 00       		.byte	0
 9359 067f D2       		.byte	-46
 9360 0680 0F       		.byte	15
 9361 0681 00       		.byte	0
 9362 0682 00       		.byte	0
 9363 0683 40       		.byte	64
 9364 0684 00       		.byte	0
 9365 0685 00       		.byte	0
 9366 0686 0000     		.space	2
 9369              	glProbeCtrl:
 9370 0688 00       		.byte	0
 9371 0689 00       		.byte	0
 9372 068a 01       		.byte	1
 9373 068b 01       		.byte	1
 9374 068c 15       		.byte	21
 9375 068d 16       		.byte	22
 9376 068e 05       		.byte	5
 9377 068f 00       		.byte	0
 9378 0690 00       		.byte	0
 9379 0691 00       		.byte	0
 9380 0692 00       		.byte	0
 9381 0693 00       		.byte	0
 9382 0694 00       		.byte	0
 9383 0695 00       		.byte	0
 9384 0696 00       		.byte	0
 9385 0697 00       		.byte	0
 9386 0698 00       		.byte	0
 9387 0699 00       		.byte	0
 9388 069a 00       		.byte	0
 9389 069b 48       		.byte	72
 9390 069c 3F       		.byte	63
 9391 069d 00       		.byte	0
 9392 069e 00       		.byte	0
 9393 069f 40       		.byte	64
 9394 06a0 00       		.byte	0
 9395 06a1 00       		.byte	0
 9396 06a2 0000     		.space	2
 9399              	glProbeStilCtrl:
 9400 06a4 01       		.byte	1
 9401 06a5 02       		.byte	2
 9402 06a6 00       		.byte	0
 9403 06a7 00       		.byte	0
 9404 06a8 C6       		.byte	-58
 9405 06a9 99       		.byte	-103
 9406 06aa 00       		.byte	0
 9407 06ab 00       		.byte	0
 9408 06ac 40       		.byte	64
 9409 06ad 00       		.byte	0
 9410 06ae 00       		.byte	0
 9411 06af 00       		.space	1
 9414              	glProbeStilCtrl20:
 9415 06b0 01       		.byte	1
 9416 06b1 01       		.byte	1
 9417 06b2 00       		.byte	0
 9418 06b3 00       		.byte	0
 9419 06b4 D2       		.byte	-46
 9420 06b5 0F       		.byte	15
 9421 06b6 00       		.byte	0
 9422 06b7 00       		.byte	0
 9423 06b8 40       		.byte	64
 9424 06b9 00       		.byte	0
 9425 06ba 00       		.byte	0
 9428              	snapButFlag:
 9429 06bb 01       		.byte	1
 9432              	CyFxGpifTransition:
 9433 06bc 0000     		.short	0
 9434 06be 5555     		.short	21845
 9435 06c0 8888     		.short	-30584
 9436 06c2 AAAA     		.short	-21846
 9437 06c4 3333     		.short	13107
 9438 06c6 0000     		.space	2
 9441              	CyFxGpifWavedata:
 9442 06c8 0181731E 		.word	510886145
 9443 06cc 00000000 		.word	0
 9444 06d0 00000080 		.word	-2147483648
 9445 06d4 00000000 		.word	0
 9446 06d8 00000000 		.word	0
 9447 06dc 00000000 		.word	0
 9448 06e0 0201702E 		.word	779092226
 9449 06e4 00010000 		.word	256
 9450 06e8 A0000080 		.word	-2147483488
 9451 06ec 00000000 		.word	0
 9452 06f0 00000000 		.word	0
 9453 06f4 00000000 		.word	0
 9454 06f8 0380722E 		.word	779255811
 9455 06fc 02010020 		.word	536871170
 9456 0700 60000080 		.word	-2147483552
 9457 0704 00000000 		.word	0
 9458 0708 00000000 		.word	0
 9459 070c 00000000 		.word	0
 9460 0710 0460722E 		.word	779247620
 9461 0714 02010024 		.word	603980034
 9462 0718 90000080 		.word	-2147483504
 9463 071c 0594731E 		.word	510891013
 9464 0720 06000000 		.word	6
 9465 0724 00000080 		.word	-2147483648
 9466 0728 0380722E 		.word	779255811
 9467 072c 02010020 		.word	536871170
 9468 0730 60000080 		.word	-2147483552
 9469 0734 0693731E 		.word	510890758
 9470 0738 06000000 		.word	6
 9471 073c 00000080 		.word	-2147483648
 9472 0740 0720703E 		.word	1047535623
 9473 0744 08010000 		.word	264
 9474 0748 00000080 		.word	-2147483648
 9475 074c 0820703E 		.word	1047535624
 9476 0750 08010000 		.word	264
 9477 0754 00000080 		.word	-2147483648
 9478 0758 0920703E 		.word	1047535625
 9479 075c 08010000 		.word	264
 9480 0760 00000080 		.word	-2147483648
 9481 0764 0A20703E 		.word	1047535626
 9482 0768 08010000 		.word	264
 9483 076c 00000080 		.word	-2147483648
 9484 0770 0380722E 		.word	779255811
 9485 0774 02010020 		.word	536871170
 9486 0778 60000080 		.word	-2147483552
 9487 077c 0B000000 		.word	11
 9488 0780 00000000 		.word	0
 9489 0784 00010080 		.word	-2147483392
 9490 0788 0460722E 		.word	779247620
 9491 078c 02010024 		.word	603980034
 9492 0790 90000080 		.word	-2147483504
 9493 0794 0D000000 		.word	13
 9494 0798 00000000 		.word	0
 9495 079c 00010080 		.word	-2147483392
 9496 07a0 0460722E 		.word	779247620
 9497 07a4 02010024 		.word	603980034
 9498 07a8 90000080 		.word	-2147483504
 9499 07ac 0C000000 		.word	12
 9500 07b0 00000000 		.word	0
 9501 07b4 00010080 		.word	-2147483392
 9502 07b8 0380722E 		.word	779255811
 9503 07bc 02010020 		.word	536871170
 9504 07c0 60000080 		.word	-2147483552
 9505 07c4 0E000000 		.word	14
 9506 07c8 00000000 		.word	0
 9507 07cc 00010080 		.word	-2147483392
 9508 07d0 00000000 		.word	0
 9509 07d4 00000000 		.word	0
 9510 07d8 00000000 		.word	0
 9511 07dc 00000000 		.word	0
 9512 07e0 00000000 		.word	0
 9513 07e4 00000000 		.word	0
 9516              	CyFxGpifWavedataPosition:
 9517 07e8 00       		.byte	0
 9518 07e9 01       		.byte	1
 9519 07ea 02       		.byte	2
 9520 07eb 03       		.byte	3
 9521 07ec 04       		.byte	4
 9522 07ed 05       		.byte	5
 9523 07ee 06       		.byte	6
 9524 07ef 07       		.byte	7
 9525 07f0 08       		.byte	8
 9526 07f1 09       		.byte	9
 9527 07f2 0A       		.byte	10
 9528 07f3 0B       		.byte	11
 9529 07f4 0B       		.byte	11
 9530 07f5 0B       		.byte	11
 9531 07f6 0B       		.byte	11
 9532 07f7 00       		.space	1
 9535              	CyFxGpifRegValue:
 9536 07f8 08830080 		.word	-2147450104
 9537 07fc 67000000 		.word	103
 9538 0800 00000000 		.word	0
 9539 0804 46000000 		.word	70
 9540 0808 00000000 		.word	0
 9541 080c 00000000 		.word	0
 9542 0810 02000000 		.word	2
 9543 0814 82000000 		.word	130
 9544 0818 82070000 		.word	1922
 9545 081c 40040000 		.word	1088
 9546 0820 FCFF0000 		.word	65532
 9547 0824 28000000 		.word	40
 9548 0828 00000000 		.word	0
 9549 082c 00000000 		.word	0
 9550 0830 00000000 		.word	0
 9551 0834 00000000 		.word	0
 9552 0838 01000000 		.word	1
 9553 083c 00000000 		.word	0
 9554 0840 00000000 		.word	0
 9555 0844 00000000 		.word	0
 9556 0848 00000000 		.word	0
 9557 084c 00000000 		.word	0
 9558 0850 00000000 		.word	0
 9559 0854 00000000 		.word	0
 9560 0858 00000000 		.word	0
 9561 085c 00000000 		.word	0
 9562 0860 00000000 		.word	0
 9563 0864 00000000 		.word	0
 9564 0868 00000000 		.word	0
 9565 086c 06000000 		.word	6
 9566 0870 00000000 		.word	0
 9567 0874 FFFF0000 		.word	65535
 9568 0878 09010000 		.word	265
 9569 087c 00000000 		.word	0
 9570 0880 F71F0000 		.word	8183
 9571 0884 00000000 		.word	0
 9572 0888 FFFF0000 		.word	65535
 9573 088c 09010000 		.word	265
 9574 0890 00000000 		.word	0
 9575 0894 F71F0000 		.word	8183
 9576 0898 00000000 		.word	0
 9577 089c 00000000 		.word	0
 9578 08a0 00000000 		.word	0
 9579 08a4 00000000 		.word	0
 9580 08a8 00000000 		.word	0
 9581 08ac 00000000 		.word	0
 9582 08b0 00000000 		.word	0
 9583 08b4 00000000 		.word	0
 9584 08b8 00000000 		.word	0
 9585 08bc 00000000 		.word	0
 9586 08c0 00000000 		.word	0
 9587 08c4 00000000 		.word	0
 9588 08c8 00000000 		.word	0
 9589 08cc 00000000 		.word	0
 9590 08d0 00000000 		.word	0
 9591 08d4 00000000 		.word	0
 9592 08d8 00000000 		.word	0
 9593 08dc 00000000 		.word	0
 9594 08e0 00000000 		.word	0
 9595 08e4 00000000 		.word	0
 9596 08e8 00000000 		.word	0
 9597 08ec 00000000 		.word	0
 9598 08f0 00000000 		.word	0
 9599 08f4 00040180 		.word	-2147417088
 9600 08f8 01040180 		.word	-2147417087
 9601 08fc 02040180 		.word	-2147417086
 9602 0900 03040180 		.word	-2147417085
 9603 0904 00000000 		.word	0
 9604 0908 00000000 		.word	0
 9605 090c 00000000 		.word	0
 9606 0910 00000000 		.word	0
 9607 0914 00000000 		.word	0
 9608 0918 00000000 		.word	0
 9609 091c 00000000 		.word	0
 9610 0920 00000000 		.word	0
 9611 0924 C1FFFFFF 		.word	-63
 9614              	CyFxGpifTransition_usb2:
 9615 0928 0000     		.short	0
 9616 092a 5555     		.short	21845
 9617 092c AAAA     		.short	-21846
 9618 092e 8888     		.short	-30584
 9619 0930 1111     		.short	4369
 9620 0932 4444     		.short	17476
 9621 0934 3333     		.short	13107
 9622 0936 CCCC     		.short	-13108
 9625              	CyFxGpifWavedata_usb2:
 9626 0938 0181731E 		.word	510886145
 9627 093c 00000000 		.word	0
 9628 0940 00000080 		.word	-2147483648
 9629 0944 00000000 		.word	0
 9630 0948 00000000 		.word	0
 9631 094c 00000000 		.word	0
 9632 0950 0201703E 		.word	1047527682
 9633 0954 00010000 		.word	256
 9634 0958 A00000C0 		.word	-1073741664
 9635 095c 00000000 		.word	0
 9636 0960 00000000 		.word	0
 9637 0964 00000000 		.word	0
 9638 0968 0394731E 		.word	510891011
 9639 096c 04000020 		.word	536870916
 9640 0970 60004080 		.word	-2143289248
 9641 0974 00000000 		.word	0
 9642 0978 00000000 		.word	0
 9643 097c 00000000 		.word	0
 9644 0980 0620702E 		.word	779100166
 9645 0984 0C000000 		.word	12
 9646 0988 00000080 		.word	-2147483648
 9647 098c 0620702E 		.word	779100166
 9648 0990 0C000000 		.word	12
 9649 0994 00000080 		.word	-2147483648
 9650 0998 0394731E 		.word	510891011
 9651 099c 04000020 		.word	536870916
 9652 09a0 60004080 		.word	-2143289248
 9653 09a4 0620702E 		.word	779100166
 9654 09a8 0C000000 		.word	12
 9655 09ac 00000080 		.word	-2147483648
 9656 09b0 0C93731E 		.word	510890764
 9657 09b4 04000024 		.word	603979780
 9658 09b8 90004080 		.word	-2143289200
 9659 09bc 0D20702E 		.word	779100173
 9660 09c0 0C000000 		.word	12
 9661 09c4 00000080 		.word	-2147483648
 9662 09c8 0780724E 		.word	1316126727
 9663 09cc 0A000000 		.word	10
 9664 09d0 00000080 		.word	-2147483648
 9665 09d4 08000000 		.word	8
 9666 09d8 00000000 		.word	0
 9667 09dc 00010080 		.word	-2147483392
 9668 09e0 0920702E 		.word	779100169
 9669 09e4 0C010000 		.word	268
 9670 09e8 00000080 		.word	-2147483648
 9671 09ec 0A01701E 		.word	510656778
 9672 09f0 0E000100 		.word	65550
 9673 09f4 00000080 		.word	-2147483648
 9674 09f8 00000000 		.word	0
 9675 09fc 00000000 		.word	0
 9676 0a00 00000000 		.word	0
 9677 0a04 00000000 		.word	0
 9678 0a08 00000000 		.word	0
 9679 0a0c 00000000 		.word	0
 9680 0a10 0394731E 		.word	510891011
 9681 0a14 04000020 		.word	536870916
 9682 0a18 60004080 		.word	-2143289248
 9683 0a1c 08000000 		.word	8
 9684 0a20 00000000 		.word	0
 9685 0a24 00010080 		.word	-2147483392
 9686 0a28 0B000000 		.word	11
 9687 0a2c 00000000 		.word	0
 9688 0a30 00010080 		.word	-2147483392
 9689 0a34 0C93731E 		.word	510890764
 9690 0a38 04000024 		.word	603979780
 9691 0a3c 90004080 		.word	-2143289200
 9692 0a40 0D20702E 		.word	779100173
 9693 0a44 0C000000 		.word	12
 9694 0a48 00000080 		.word	-2147483648
 9695 0a4c 0D20702E 		.word	779100173
 9696 0a50 0C000000 		.word	12
 9697 0a54 00000080 		.word	-2147483648
 9698 0a58 0E60724E 		.word	1316118542
 9699 0a5c 0A000000 		.word	10
 9700 0a60 00000080 		.word	-2147483648
 9701 0a64 0F000000 		.word	15
 9702 0a68 00000000 		.word	0
 9703 0a6c 00010080 		.word	-2147483392
 9704 0a70 1020702E 		.word	779100176
 9705 0a74 0C010000 		.word	268
 9706 0a78 00000080 		.word	-2147483648
 9707 0a7c 1101701E 		.word	510656785
 9708 0a80 0E000100 		.word	65550
 9709 0a84 00000080 		.word	-2147483648
 9710 0a88 0C93731E 		.word	510890764
 9711 0a8c 04000024 		.word	603979780
 9712 0a90 90004080 		.word	-2143289200
 9713 0a94 0F000000 		.word	15
 9714 0a98 00000000 		.word	0
 9715 0a9c 00010080 		.word	-2147483392
 9716 0aa0 12000000 		.word	18
 9717 0aa4 00000000 		.word	0
 9718 0aa8 00010080 		.word	-2147483392
 9719 0aac 0394731E 		.word	510891011
 9720 0ab0 04000020 		.word	536870916
 9721 0ab4 60004080 		.word	-2143289248
 9722 0ab8 0480732E 		.word	779321348
 9723 0abc 02010000 		.word	258
 9724 0ac0 0000C0C0 		.word	-1061158912
 9725 0ac4 0580732E 		.word	779321349
 9726 0ac8 02010000 		.word	258
 9727 0acc 0000C0C0 		.word	-1061158912
 9728 0ad0 0580732E 		.word	779321349
 9729 0ad4 02010000 		.word	258
 9730 0ad8 0000C0C0 		.word	-1061158912
 9731 0adc 0480732E 		.word	779321348
 9732 0ae0 02010000 		.word	258
 9733 0ae4 0000C0C0 		.word	-1061158912
 9736              	CyFxGpifWavedataPosition_usb2:
 9737 0ae8 00       		.byte	0
 9738 0ae9 01       		.byte	1
 9739 0aea 02       		.byte	2
 9740 0aeb 03       		.byte	3
 9741 0aec 04       		.byte	4
 9742 0aed 05       		.byte	5
 9743 0aee 06       		.byte	6
 9744 0aef 07       		.byte	7
 9745 0af0 08       		.byte	8
 9746 0af1 09       		.byte	9
 9747 0af2 0A       		.byte	10
 9748 0af3 08       		.byte	8
 9749 0af4 0B       		.byte	11
 9750 0af5 0C       		.byte	12
 9751 0af6 0D       		.byte	13
 9752 0af7 08       		.byte	8
 9753 0af8 0E       		.byte	14
 9754 0af9 0F       		.byte	15
 9755 0afa 08       		.byte	8
 9756 0afb 08       		.byte	8
 9757 0afc 08       		.byte	8
 9758 0afd 08       		.byte	8
 9759 0afe 08       		.byte	8
 9760 0aff 08       		.byte	8
 9761 0b00 08       		.byte	8
 9762 0b01 08       		.byte	8
 9763 0b02 08       		.byte	8
 9764 0b03 08       		.byte	8
 9765 0b04 08       		.byte	8
 9766 0b05 08       		.byte	8
 9767 0b06 08       		.byte	8
 9768 0b07 08       		.byte	8
 9769 0b08 08       		.byte	8
 9770 0b09 08       		.byte	8
 9771 0b0a 08       		.byte	8
 9772 0b0b 08       		.byte	8
 9773 0b0c 08       		.byte	8
 9774 0b0d 08       		.byte	8
 9775 0b0e 08       		.byte	8
 9776 0b0f 08       		.byte	8
 9777 0b10 08       		.byte	8
 9778 0b11 08       		.byte	8
 9779 0b12 08       		.byte	8
 9780 0b13 08       		.byte	8
 9781 0b14 08       		.byte	8
 9782 0b15 08       		.byte	8
 9783 0b16 08       		.byte	8
 9784 0b17 08       		.byte	8
 9785 0b18 08       		.byte	8
 9786 0b19 08       		.byte	8
 9787 0b1a 08       		.byte	8
 9788 0b1b 08       		.byte	8
 9789 0b1c 08       		.byte	8
 9790 0b1d 08       		.byte	8
 9791 0b1e 08       		.byte	8
 9792 0b1f 08       		.byte	8
 9793 0b20 08       		.byte	8
 9794 0b21 08       		.byte	8
 9795 0b22 08       		.byte	8
 9796 0b23 08       		.byte	8
 9797 0b24 08       		.byte	8
 9798 0b25 08       		.byte	8
 9799 0b26 08       		.byte	8
 9800 0b27 08       		.byte	8
 9801 0b28 08       		.byte	8
 9802 0b29 08       		.byte	8
 9803 0b2a 08       		.byte	8
 9804 0b2b 08       		.byte	8
 9805 0b2c 08       		.byte	8
 9806 0b2d 08       		.byte	8
 9807 0b2e 08       		.byte	8
 9808 0b2f 08       		.byte	8
 9809 0b30 08       		.byte	8
 9810 0b31 08       		.byte	8
 9811 0b32 08       		.byte	8
 9812 0b33 08       		.byte	8
 9813 0b34 08       		.byte	8
 9814 0b35 08       		.byte	8
 9815 0b36 08       		.byte	8
 9816 0b37 08       		.byte	8
 9817 0b38 08       		.byte	8
 9818 0b39 08       		.byte	8
 9819 0b3a 08       		.byte	8
 9820 0b3b 08       		.byte	8
 9821 0b3c 08       		.byte	8
 9822 0b3d 08       		.byte	8
 9823 0b3e 08       		.byte	8
 9824 0b3f 08       		.byte	8
 9825 0b40 08       		.byte	8
 9826 0b41 08       		.byte	8
 9827 0b42 08       		.byte	8
 9828 0b43 08       		.byte	8
 9829 0b44 08       		.byte	8
 9830 0b45 08       		.byte	8
 9831 0b46 08       		.byte	8
 9832 0b47 08       		.byte	8
 9833 0b48 08       		.byte	8
 9834 0b49 08       		.byte	8
 9835 0b4a 08       		.byte	8
 9836 0b4b 08       		.byte	8
 9837 0b4c 08       		.byte	8
 9838 0b4d 08       		.byte	8
 9839 0b4e 08       		.byte	8
 9840 0b4f 08       		.byte	8
 9841 0b50 08       		.byte	8
 9842 0b51 08       		.byte	8
 9843 0b52 08       		.byte	8
 9844 0b53 08       		.byte	8
 9845 0b54 08       		.byte	8
 9846 0b55 08       		.byte	8
 9847 0b56 08       		.byte	8
 9848 0b57 08       		.byte	8
 9849 0b58 08       		.byte	8
 9850 0b59 08       		.byte	8
 9851 0b5a 08       		.byte	8
 9852 0b5b 08       		.byte	8
 9853 0b5c 08       		.byte	8
 9854 0b5d 08       		.byte	8
 9855 0b5e 08       		.byte	8
 9856 0b5f 08       		.byte	8
 9857 0b60 08       		.byte	8
 9858 0b61 08       		.byte	8
 9859 0b62 08       		.byte	8
 9860 0b63 08       		.byte	8
 9861 0b64 08       		.byte	8
 9862 0b65 08       		.byte	8
 9863 0b66 08       		.byte	8
 9864 0b67 08       		.byte	8
 9865 0b68 00       		.byte	0
 9866 0b69 01       		.byte	1
 9867 0b6a 02       		.byte	2
 9868 0b6b 10       		.byte	16
 9869 0b6c 04       		.byte	4
 9870 0b6d 05       		.byte	5
 9871 0b6e 06       		.byte	6
 9872 0b6f 07       		.byte	7
 9873 0b70 08       		.byte	8
 9874 0b71 09       		.byte	9
 9875 0b72 0A       		.byte	10
 9876 0b73 08       		.byte	8
 9877 0b74 11       		.byte	17
 9878 0b75 0C       		.byte	12
 9879 0b76 0D       		.byte	13
 9880 0b77 08       		.byte	8
 9881 0b78 0E       		.byte	14
 9882 0b79 0F       		.byte	15
 9883 0b7a 08       		.byte	8
 9884 0b7b 00       		.space	1
 9887              	CyFxGpifRegValue_usb2:
 9888 0b7c 08830080 		.word	-2147450104
 9889 0b80 67000000 		.word	103
 9890 0b84 01000000 		.word	1
 9891 0b88 46000000 		.word	70
 9892 0b8c 00000000 		.word	0
 9893 0b90 00000000 		.word	0
 9894 0b94 02000000 		.word	2
 9895 0b98 82000000 		.word	130
 9896 0b9c 82070000 		.word	1922
 9897 0ba0 40040000 		.word	1088
 9898 0ba4 FCFF0000 		.word	65532
 9899 0ba8 28000000 		.word	40
 9900 0bac 00000000 		.word	0
 9901 0bb0 00000000 		.word	0
 9902 0bb4 00000000 		.word	0
 9903 0bb8 00000000 		.word	0
 9904 0bbc 01000000 		.word	1
 9905 0bc0 00000000 		.word	0
 9906 0bc4 00000000 		.word	0
 9907 0bc8 00000000 		.word	0
 9908 0bcc 00000000 		.word	0
 9909 0bd0 00000000 		.word	0
 9910 0bd4 00000000 		.word	0
 9911 0bd8 00000000 		.word	0
 9912 0bdc 00000000 		.word	0
 9913 0be0 00000000 		.word	0
 9914 0be4 00000000 		.word	0
 9915 0be8 00000000 		.word	0
 9916 0bec 00000000 		.word	0
 9917 0bf0 06000000 		.word	6
 9918 0bf4 00000000 		.word	0
 9919 0bf8 FFFF0000 		.word	65535
 9920 0bfc 09010000 		.word	265
 9921 0c00 00000000 		.word	0
 9922 0c04 F71F0000 		.word	8183
 9923 0c08 00000000 		.word	0
 9924 0c0c FFFF0000 		.word	65535
 9925 0c10 09010000 		.word	265
 9926 0c14 00000000 		.word	0
 9927 0c18 F71F0000 		.word	8183
 9928 0c1c 00000000 		.word	0
 9929 0c20 00000000 		.word	0
 9930 0c24 00000000 		.word	0
 9931 0c28 00000000 		.word	0
 9932 0c2c 00000000 		.word	0
 9933 0c30 00000000 		.word	0
 9934 0c34 00000000 		.word	0
 9935 0c38 00000000 		.word	0
 9936 0c3c 00000000 		.word	0
 9937 0c40 00000000 		.word	0
 9938 0c44 00000000 		.word	0
 9939 0c48 00000000 		.word	0
 9940 0c4c 00000000 		.word	0
 9941 0c50 00000000 		.word	0
 9942 0c54 00000000 		.word	0
 9943 0c58 00000000 		.word	0
 9944 0c5c 00000000 		.word	0
 9945 0c60 00000000 		.word	0
 9946 0c64 00000000 		.word	0
 9947 0c68 00000000 		.word	0
 9948 0c6c 00000000 		.word	0
 9949 0c70 00000000 		.word	0
 9950 0c74 00000000 		.word	0
 9951 0c78 00040180 		.word	-2147417088
 9952 0c7c 01040180 		.word	-2147417087
 9953 0c80 02040180 		.word	-2147417086
 9954 0c84 03040180 		.word	-2147417085
 9955 0c88 00000000 		.word	0
 9956 0c8c 00000000 		.word	0
 9957 0c90 00000000 		.word	0
 9958 0c94 00000000 		.word	0
 9959 0c98 00000000 		.word	0
 9960 0c9c 00000000 		.word	0
 9961 0ca0 00000000 		.word	0
 9962 0ca4 00000000 		.word	0
 9963 0ca8 C1FFFFFF 		.word	-63
 9964              		.section	.rodata.str1.4,"aMS",%progbits,1
 9965              		.align	2
 9966              	.LC0:
 9967 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9967      7065722D 
 9967      74696D65 
 9967      72202564 
 9967      0D0A00
 9968 0013 00       		.space	1
 9969              	.LC1:
 9970 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9970      636F6D6D 
 9970      616E6420 
 9970      71756575 
 9970      65206973 
 9971 0037 00       		.space	1
 9972              	.LC2:
 9973 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9973      5420656E 
 9973      636F756E 
 9973      74657265 
 9973      642E2E2E 
 9974              	.LC3:
 9975 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9975      454E4420 
 9975      656E636F 
 9975      756E7465 
 9975      7265642E 
 9976 007a 0000     		.space	2
 9977              	.LC4:
 9978 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9978      64697363 
 9978      6F6E6E65 
 9978      63746564 
 9978      2E2E2E30 
 9979 009b 00       		.space	1
 9980              	.LC5:
 9981 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9981      7220696E 
 9981      206D756C 
 9981      74696368 
 9981      616E6E65 
 9982 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9982      2025782C 
 9982      20646D61 
 9982      446F6E65 
 9982      20256420 
 9983              	.LC6:
 9984 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9984      43595F46 
 9984      585F5556 
 9984      435F5649 
 9984      44454F5F 
 9985 011b 0A00     		.ascii	"\012\000"
 9986 011d 000000   		.space	3
 9987              	.LC7:
 9988 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9988      43595F46 
 9988      585F5556 
 9988      435F5649 
 9988      44454F5F 
 9989 0153 00       		.ascii	"\000"
 9990              	.LC8:
 9991 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9991      726E6174 
 9991      65207365 
 9991      7474696E 
 9991      6720302E 
 9992              	.LC9:
 9993 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9993      72206665 
 9993      61747572 
 9993      65207265 
 9993      71756573 
 9994 018f 00       		.space	1
 9995              	.LC10:
 9996 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9996      6F6D6D69 
 9996      74656F66 
 9996      20737461 
 9996      7465203D 
 9997              	.LC11:
 9998 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9998      6E656C20 
 9998      53657420 
 9998      57726170 
 9998      55702066 
 9999 01d5 000000   		.space	3
 10000              	.LC12:
 10001 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 10001      72206861 
 10001      6E646C65 
 10001      722E2E2E 
 10001      0D0A00
 10002 01eb 00       		.space	1
 10003              	.LC13:
 10004 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 10004      69742045 
 10004      4F462066 
 10004      61696C65 
 10004      64210D0A 
 10005 0201 000000   		.space	3
 10006              	.LC14:
 10007 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 10007      49324320 
 10007      636F6D6D 
 10007      616E6420 
 10007      69732030 
 10008 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10008      78257820 
 10008      30782578 
 10008      20307825 
 10008      78203078 
 10009              	.LC15:
 10010 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 10010      49324320 
 10010      636F6D6D 
 10010      616E6420 
 10010      73657474 
 10011 0276 0000     		.space	2
 10012              	.LC16:
 10013 0278 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 10013      206C6967 
 10013      68742063 
 10013      6F6D7065 
 10013      6E736174 
 10014 02ab 25640D0A 		.ascii	"%d\015\012\000"
 10014      00
 10015              	.LC17:
 10016 02b0 54686520 		.ascii	"The I2C current data is not available. try again. %"
 10016      49324320 
 10016      63757272 
 10016      656E7420 
 10016      64617461 
 10017 02e3 64202564 		.ascii	"d %d\015\012\000"
 10017      0D0A00
 10018 02ea 0000     		.space	2
 10019              	.LC18:
 10020 02ec 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 10020      26414743 
 10020      2073656E 
 10020      7420746F 
 10020      20686F73 
 10021 0312 0000     		.space	2
 10022              	.LC19:
 10023 0314 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10023      73687574 
 10023      74657226 
 10023      6578706F 
 10023      73757265 
 10024 033f 00       		.space	1
 10025              	.LC20:
 10026 0340 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 10026      26414743 
 10026      20676F74 
 10026      74656E20 
 10026      66726F6D 
 10027 0371 0A00     		.ascii	"\012\000"
 10028 0373 00       		.space	1
 10029              	.LC21:
 10030 0374 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 10030      74657220 
 10030      6C657665 
 10030      6C20676F 
 10030      7474656E 
 10031 03a7 25640D0A 		.ascii	"%d\015\012\000"
 10031      00
 10032              	.LC22:
 10033 03ac 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 10033      67657420 
 10033      64617461 
 10033      2066726F 
 10033      6D20686F 
 10034 03d9 000000   		.space	3
 10035              	.LC23:
 10036 03dc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 10036      52657175 
 10036      65737420 
 10036      30782578 
 10036      20706172 
 10037 040f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 10037      6E642074 
 10037      6F20686F 
 10037      73742030 
 10037      78257820 
 10038 042a 0000     		.space	2
 10039              	.LC24:
 10040 042c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 10040      204F7020 
 10040      72656365 
 10040      69766573 
 10040      20284354 
 10041 0453 00       		.space	1
 10042              	.LC25:
 10043 0454 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 10043      756C7420 
 10043      73656C65 
 10043      63746F72 
 10043      20284354 
 10044 0476 0000     		.space	2
 10045              	.LC26:
 10046 0478 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 10046      756C7420 
 10046      72657175 
 10046      65737420 
 10046      28435429 
 10047 0499 000000   		.space	3
 10048              	.LC27:
 10049 049c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 10049      52657175 
 10049      65737420 
 10049      30782578 
 10049      20706172 
 10050 04cf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 10050      20307825 
 10050      78202F20 
 10050      73656E64 
 10050      20746F20 
 10051 04fc 00       		.ascii	"\000"
 10052 04fd 000000   		.space	3
 10053              	.LC28:
 10054 0500 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 10054      73706565 
 10054      64203D20 
 10054      25642065 
 10054      76656E66 
 10055 0530 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 10055      71756573 
 10055      74203D20 
 10055      30782578 
 10055      20775661 
 10056 0560 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 10056      203D2030 
 10056      78257820 
 10056      6973666C 
 10056      61672030 
 10057 057a 0000     		.space	2
 10058              	.LC29:
 10059 057c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 10059      64656661 
 10059      756C7420 
 10059      73657475 
 10059      70207265 
 10060              	.LC30:
 10061 05a8 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 10061      6F207374 
 10061      7265616D 
 10061      20474554 
 10061      20726571 
 10062 05cd 000000   		.space	3
 10063              	.LC31:
 10064 05d0 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 10064      43595F46 
 10064      585F5556 
 10064      435F5354 
 10064      5245414D 
 10065 05f6 0000     		.space	2
 10066              	.LC32:
 10067 05f8 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 10067      55564320 
 10067      7374696C 
 10067      6C205072 
 10067      6F622873 
 10068 0623 00       		.space	1
 10069              	.LC33:
 10070 0624 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 10070      7374696C 
 10070      6C20636F 
 10070      6D6D6974 
 10070      20636F6E 
 10071              	.LC34:
 10072 064c 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 10072      55564320 
 10072      7374696C 
 10072      6C207472 
 10072      69676765 
 10073 0675 000000   		.space	3
 10074              	.LC35:
 10075 0678 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 10075      7374696C 
 10075      6C207472 
 10075      69676765 
 10075      7220636F 
 10076 069f 00       		.space	1
 10077              	.LC36:
 10078 06a0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 10078      65642074 
 10078      6F207365 
 10078      6E642069 
 10078      6E746572 
 10079 06d1 0A00     		.ascii	"\012\000"
 10080 06d3 00       		.space	1
 10081              	.LC37:
 10082 06d4 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 10082      73657420 
 10082      64656620 
 10082      64617461 
 10082      20307825 
 10083 06f3 00       		.space	1
 10084              	.LC38:
 10085 06f4 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 10085      73657420 
 10085      64656620 
 10085      64617461 
 10085      20307825 
 10086 0727 2E0D0A00 		.ascii	".\015\012\000"
 10087 072b 00       		.space	1
 10088              	.LC39:
 10089 072c 55415254 		.ascii	"UART initialization failed!\012\000"
 10089      20696E69 
 10089      7469616C 
 10089      697A6174 
 10089      696F6E20 
 10090 0749 000000   		.space	3
 10091              	.LC40:
 10092 074c 49324320 		.ascii	"I2C initialization failed!\012\000"
 10092      696E6974 
 10092      69616C69 
 10092      7A617469 
 10092      6F6E2066 
 10093              	.LC41:
 10094 0768 49324320 		.ascii	"I2C configuration failed!\012\000"
 10094      636F6E66 
 10094      69677572 
 10094      6174696F 
 10094      6E206661 
 10095 0783 00       		.space	1
 10096              	.LC42:
 10097 0784 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 10097      43726561 
 10097      74652045 
 10097      76656E74 
 10097      20666169 
 10098 07ae 0000     		.space	2
 10099              	.LC43:
 10100 07b0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 10100      20496E69 
 10100      74206661 
 10100      696C6564 
 10100      2C204572 
 10101 07d3 00       		.space	1
 10102              	.LC44:
 10103 07d4 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 10103      204F7665 
 10103      72726964 
 10103      65206661 
 10103      696C6564 
 10104 07fb 00       		.space	1
 10105              	.LC45:
 10106 07fc 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 10106      28323029 
 10106      204F7665 
 10106      72726964 
 10106      65206661 
 10107 0827 00       		.space	1
 10108              	.LC46:
 10109 0828 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 10109      28323429 
 10109      204F7665 
 10109      72726964 
 10109      65206661 
 10110 0853 00       		.space	1
 10111              	.LC47:
 10112 0854 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 10112      20536574 
 10112      20287265 
 10112      73657420 
 10112      32322920 
 10113 0886 00       		.ascii	"\000"
 10114 0887 00       		.space	1
 10115              	.LC48:
 10116 0888 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 10116      20536574 
 10116      2028706F 
 10116      77657220 
 10116      32302920 
 10117 08ba 00       		.ascii	"\000"
 10118 08bb 00       		.space	1
 10119              	.LC49:
 10120 08bc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 10120      20536574 
 10120      2028736E 
 10120      61702073 
 10120      686F7420 
 10121 08ef 25640A00 		.ascii	"%d\012\000"
 10122 08f3 00       		.space	1
 10123              	.LC50:
 10124 08f4 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 10124      46756E63 
 10124      74696F6E 
 10124      20466169 
 10124      6C656420 
 10125 0923 00       		.space	1
 10126              	.LC51:
 10127 0924 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 10127      46756E63 
 10127      74696F6E 
 10127      20466169 
 10127      6C656420 
 10128 0953 00       		.space	1
 10129              	.LC52:
 10130 0954 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 10130      53657420 
 10130      456E6470 
 10130      6F696E74 
 10130      20636F6E 
 10131 0984 00       		.ascii	"\000"
 10132 0985 000000   		.space	3
 10133              	.LC53:
 10134 0988 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 10134      496E7465 
 10134      72727570 
 10134      74205374 
 10134      61747573 
 10135 09bb 20436F64 		.ascii	" Code = %d\012\000"
 10135      65203D20 
 10135      25640A00 
 10136 09c7 00       		.space	1
 10137              	.LC54:
 10138 09c8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 10138      65642074 
 10138      6F20616C 
 10138      6C6F6361 
 10138      7465206D 
 10139 09fb 65720D0A 		.ascii	"er\015\012\000"
 10139      00
 10140              	.LC55:
 10141 0a00 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 10141      4368616E 
 10141      6E656C20 
 10141      43726561 
 10141      74696F6E 
 10142 0a2e 0000     		.space	2
 10143              	.LC56:
 10144 0a30 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 10144      436F6E6E 
 10144      65637420 
 10144      6661696C 
 10144      65642C20 
 10145 0a55 000000   		.space	3
 10146              	.LC57:
 10147 0a58 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 10147      4368616E 
 10147      6E656C20 
 10147      52657365 
 10147      74204661 
 10148 0a83 00       		.space	1
 10149              	.LC58:
 10150 0a84 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 10150      4368616E 
 10150      6E656C20 
 10150      53657420 
 10150      5472616E 
 10151 0ab5 00       		.ascii	"\000"
 10152 0ab6 0000     		.space	2
 10153              	.LC59:
 10154 0ab8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 10154      4368616E 
 10154      6E656C20 
 10154      53657420 
 10154      5472616E 
 10155 0ae9 0A00     		.ascii	"\012\000"
 10156 0aeb 00       		.space	1
 10157              	.LC60:
 10158 0aec 0D0A2073 		.ascii	"\015\012 super gpif\000"
 10158      75706572 
 10158      20677069 
 10158      6600
 10159 0afa 0000     		.space	2
 10160              	.LC61:
 10161 0afc 0D0A2068 		.ascii	"\015\012 high gpif\000"
 10161      69676820 
 10161      67706966 
 10161      00
 10162 0b09 000000   		.space	3
 10163              	.LC62:
 10164 0b0c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 10164      696E6720 
 10164      47504946 
 10164      20436F6E 
 10164      66696775 
 10165 0b3f 0A00     		.ascii	"\012\000"
 10166 0b41 000000   		.space	3
 10167              	.LC63:
 10168 0b44 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 10168      74696E67 
 10168      20475049 
 10168      46207374 
 10168      61746520 
 10169 0b77 0D0A00   		.ascii	"\015\012\000"
 10170 0b7a 0000     		.space	2
 10171              	.LC64:
 10172 0b7c 33303A55 		.ascii	"30:UVC App Thread\000"
 10172      56432041 
 10172      70702054 
 10172      68726561 
 10172      6400
 10173 0b8e 0000     		.space	2
 10174              	.LC65:
 10175 0b90 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 10175      56432041 
 10175      70702045 
 10175      50302054 
 10175      68726561 
 10176 0ba6 0000     		.space	2
 10177              	.LC66:
 10178 0ba8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 10178      32432041 
 10178      70702043 
 10178      54524C20 
 10178      54687265 
 10179 0bbf 00       		.bss
 10180              		.align	2
 10181              		.set	.LANCHOR0,. + 0
 10184              	glFxUVCEvent:
 10185 0000 00000000 		.space	40
 10185      00000000 
 10185      00000000 
 10185      00000000 
 10185      00000000 
 10188              	gpif_initialized:
 10189 0028 00000000 		.space	4
 10192              	streamingStarted:
 10193 002c 00000000 		.space	4
 10196              	isUsbConnected:
 10197 0030 00000000 		.space	4
 10200              	fb:
 10201 0034 0000     		.space	2
 10204              	pb:
 10205 0036 0000     		.space	2
 10208              	pbc:
 10209 0038 0000     		.space	2
 10212              	stiflag:
 10213 003a 00       		.space	1
 10214 003b 00       		.space	1
 10217              	hitFV:
 10218 003c 00000000 		.space	4
 10221              	prodCount:
 10222 0040 0000     		.space	2
 10225              	consCount:
 10226 0042 0000     		.space	2
 10229              	clearFeatureRqtReceived:
 10230 0044 00000000 		.space	4
 10233              	usbSpeed:
 10234 0048 00       		.space	1
 10235 0049 000000   		.space	3
 10238              	I2CCMDArry:
 10239 004c 00000000 		.space	12
 10239      00000000 
 10239      00000000 
 10242              	is60Hz:
 10243 0058 00000000 		.space	4
 10246              	glEp0Buffer:
 10247 005c 00000000 		.space	32
 10247      00000000 
 10247      00000000 
 10247      00000000 
 10247      00000000 
 10250              	CamMode:
 10251 007c 00       		.space	1
 10254              	setRes:
 10255 007d 00       		.space	1
 10256 007e 0000     		.space	2
 10259              	glCommitCtrl:
 10260 0080 00000000 		.space	32
 10260      00000000 
 10260      00000000 
 10260      00000000 
 10260      00000000 
 10263              	setstilRes:
 10264 00a0 00       		.space	1
 10267              	IMcount.7815:
 10268 00a1 00       		.space	1
 10269 00a2 0000     		.space	2
 10272              	uvcAppThread:
 10273 00a4 00000000 		.space	168
 10273      00000000 
 10273      00000000 
 10273      00000000 
 10273      00000000 
 10276              	uvcAppEP0Thread:
 10277 014c 00000000 		.space	168
 10277      00000000 
 10277      00000000 
 10277      00000000 
 10277      00000000 
 10280              	i2cAppThread:
 10281 01f4 00000000 		.space	168
 10281      00000000 
 10281      00000000 
 10281      00000000 
 10281      00000000 
 10284              	testSnap:
 10285 029c 00       		.space	1
 10286 029d 00       		.space	1
 10289              	fbbak:
 10290 029e 0000     		.space	2
 10293              	pbbak:
 10294 02a0 0000     		.space	2
 10297              	pbcbak:
 10298 02a2 0000     		.space	2
 10301              	pbcpbak:
 10302 02a4 0000     		.space	2
 10303 02a6 0000     		.text
 10304              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1461   .text:00000bb8 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1469   .text:00000bcc $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1472   .text:00000bcc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1535   .text:00000c4c ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1747   .text:00000df4 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1785   .text:00000e80 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1850   .text:00000f04 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:1886   .text:00000f8c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:3235   .text:00001bc8 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:3255   .text:00001c0c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:3363   .text:00001d14 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:3531   .text:00001e70 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:3544   .text:00001e98 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4039   .text:000023a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4050   .text:000023c8 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4305   .text:00002680 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4318   .text:000026a8 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4321   .text:000026a8 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4383   .text:00002724 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:4391   .text:00002734 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:5692   .text:00003270 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:5723   .text:000032d8 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:5726   .text:000032d8 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6017   .text:00003590 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6024   .text:000035a0 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6027   .text:000035a0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6068   .text:000035e4 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6073   .text:000035ec $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6076   .text:000035ec CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6101   .text:00003608 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6105   .text:0000360c $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:6108   .text:0000360c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7517   .text:0000415c $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7575   .text:00004238 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7578   .text:00004238 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7735   .text:000043b0 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7751   .text:000043e4 $a
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7754   .text:000043e4 main
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9432   .data:000006bc CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9441   .data:000006c8 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9516   .data:000007e8 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9535   .data:000007f8 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7898   .rodata:00000000 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9614   .data:00000928 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9625   .data:00000938 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9736   .data:00000ae8 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9887   .data:00000b7c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7911   .rodata:0000001c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9428   .data:000006bb snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10284  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10200  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10204  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10208  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10289  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10293  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10297  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10301  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10196  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10233  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10229  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10192  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9369   .data:00000688 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9309   .data:00000650 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9399   .data:000006a4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9339   .data:0000066c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9414   .data:000006b0 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8893   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7894   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7923   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:7927   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8250   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8908   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8913   .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8935   .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8957   .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8979   .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:8986   .data:000004d0 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:9965   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10180  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10184  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10188  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10212  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10217  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10221  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10225  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10238  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10242  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10246  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10250  .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10254  .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10259  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10263  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10267  .bss:000000a1 IMcount.7815
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10272  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10276  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc1IBq3h.s:10280  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
