   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 594:../uvc.c      **** /*
 595:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 596:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 597:../uvc.c      ****  */
 598:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 599:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 600:../uvc.c      **** };
 601:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 602:../uvc.c      **** 		0
 603:../uvc.c      **** };
 604:../uvc.c      **** 
 605:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 606:../uvc.c      **** 
 607:../uvc.c      **** void I2CCmdHandler(){
 608:../uvc.c      **** 	uint8_t buf[2];
 609:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 611:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 612:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 613:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 614:../uvc.c      **** 	uint8_t i;
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 616:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 617:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 619:../uvc.c      **** 	{
 620:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 622:../uvc.c      **** 			{
 623:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 624:../uvc.c      **** 			}
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 626:../uvc.c      **** 
 627:../uvc.c      **** 	}
 628:../uvc.c      **** 	if(CmdType == 0)//I2C read
 629:../uvc.c      **** 	{
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 631:../uvc.c      **** #if 0 //for debugging
 632:../uvc.c      **** 		/* test still image operation */
 633:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 634:../uvc.c      **** 			snapButFlag = 0; //press
 635:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 636:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 637:../uvc.c      **** 			snapButFlag = 0xf; //release
 638:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 639:../uvc.c      **** 		}
 640:../uvc.c      **** 
 641:../uvc.c      **** 		/* end of the test */
 642:../uvc.c      **** #endif
 643:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 646:../uvc.c      **** 				if(CmdDataLen == 2){
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 648:../uvc.c      **** 				}
 649:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 650:../uvc.c      **** 		}else{//not support currently
 651:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 652:../uvc.c      **** 		}
 653:../uvc.c      **** 	}else if(CmdType == 1){
 654:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 655:../uvc.c      **** 			if(CmdRegLen == 2){
 656:../uvc.c      **** 				for(i = 0; i<4; i++)
 657:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 658:../uvc.c      **** 			}
 659:../uvc.c      **** 			else{
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 661:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 662:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 664:../uvc.c      **** 				}
 665:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 		}else{//not support currently
 668:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 669:../uvc.c      **** 		}
 670:../uvc.c      **** 
 671:../uvc.c      **** 	}
 672:../uvc.c      **** }
 673:../uvc.c      **** 
 674:../uvc.c      **** /************************************
 675:../uvc.c      ****  * set Iris mode
 676:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 677:../uvc.c      ****  */
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 679:../uvc.c      **** 	uint8_t dataIdx = 0;
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 684:../uvc.c      **** }
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** 
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 689:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 690:../uvc.c      **** 	uint16_t NumLn;
 691:../uvc.c      **** 	uint16_t fRate, shutTm;
 692:../uvc.c      **** 	uint8_t LnVal;
 693:../uvc.c      **** 	switch (Data){
 694:../uvc.c      **** 	case 1:
 695:../uvc.c      **** 	case 2:
 696:../uvc.c      **** 	case 3:
 697:../uvc.c      **** 	case 4:
 698:../uvc.c      **** 	case 5:
 699:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 700:../uvc.c      **** 		fRate = 30;
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 702:../uvc.c      **** 		if(NumLn > 1944)
 703:../uvc.c      **** 			NumLn =1944;
 704:../uvc.c      **** 		else if(NumLn < 8)
 705:../uvc.c      **** 			NumLn = 8;
 706:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 707:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 708:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 709:../uvc.c      **** 		break;
 710:../uvc.c      **** 	case 6:
 711:../uvc.c      **** 	case 7:
 712:../uvc.c      **** 	case 8:
 713:../uvc.c      **** 	case 9:
 714:../uvc.c      **** 	case 10:
 715:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 716:../uvc.c      **** 		fRate = 30;
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 718:../uvc.c      **** 		if(NumLn > 1944)
 719:../uvc.c      **** 			NumLn =1944;
 720:../uvc.c      **** 		else if(NumLn < 8)
 721:../uvc.c      **** 			NumLn = 8;
 722:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 723:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 724:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 725:../uvc.c      **** 		break;
 726:../uvc.c      **** 	case 0: //auto
 727:../uvc.c      **** 	default:
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 729:../uvc.c      **** 		LnVal = 1;
 730:../uvc.c      **** 		break;
 731:../uvc.c      **** 	}
 732:../uvc.c      **** 	return LnVal;
 733:../uvc.c      **** }
 734:../uvc.c      **** 
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 736:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 737:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 738:../uvc.c      ****     uint16_t readCount;
 739:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 740:../uvc.c      ****     uint8_t devAdd;
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 744:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 745:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 746:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 747:../uvc.c      ****     }else{
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 749:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 750:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 751:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 752:../uvc.c      ****     }
 753:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 754:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 755:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 756:../uvc.c      **** #endif
 757:../uvc.c      ****     reqData = bRequest;
 758:../uvc.c      ****     /*
 759:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 760:../uvc.c      ****      */
 761:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 762:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 763:../uvc.c      ****     	goto EndofSet;
 764:../uvc.c      ****     }
 765:../uvc.c      ****     switch (bRequest)
 766:../uvc.c      **** 		 {
 767:../uvc.c      **** 
 768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 772:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 773:../uvc.c      **** 			  break;
 774:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 775:../uvc.c      **** 
 776:../uvc.c      **** 			 switch(CtrlID)
 777:../uvc.c      **** 			 {
 778:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 779:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 780:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 781:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 782:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 783:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 784:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 785:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 786:../uvc.c      **** 			 	 		 }else{
 787:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 788:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 789:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 790:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 791:../uvc.c      **** 			 	 		 }
 792:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 793:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 794:../uvc.c      **** 			 	 		 break;
 795:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 796:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 797:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 798:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 799:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 800:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 801:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 802:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 803:../uvc.c      **** 			 	 		 }else{
 804:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 805:../uvc.c      **** 			 	 			if(Data0&0x80)
 806:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 807:../uvc.c      **** 			 	 			else
 808:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 809:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 810:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 811:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 812:../uvc.c      **** 			 	 		 }
 813:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 814:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 815:../uvc.c      **** 			 	 		 break;
 816:../uvc.c      **** 			 	 }
 817:../uvc.c      **** 			 	 case ExtShutCtlID0:
 818:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 819:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 820:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 821:../uvc.c      **** 
 822:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 823:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 824:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 825:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 826:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 827:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 828:../uvc.c      **** 		 	 		 }else{
 829:../uvc.c      **** 		 	 			Data0 = 0xb0;//SensorGetControl(RegAdd0, devAdd);
 830:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 831:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 832:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 833:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 834:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 835:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 836:../uvc.c      **** 
 837:../uvc.c      **** 		 	 		 }
 838:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 839:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 840:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 841:../uvc.c      **** 			 		 break;
 842:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 843:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 844:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 845:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 846:../uvc.c      **** 
 847:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 848:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 849:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 850:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 851:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 852:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 853:../uvc.c      **** 		 	 		 }else{
 854:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 855:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 856:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 857:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 858:../uvc.c      **** 		 	 		 }
 859:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 860:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 861:../uvc.c      **** 			 		 break;
 862:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 863:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 864:../uvc.c      **** 
 865:../uvc.c      **** 					 if(CamMode == 1){//720p
 866:../uvc.c      **** 						if(sendData >= 3){
 867:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 868:../uvc.c      **** 							sendData = 0; //set back to default
 869:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 870:../uvc.c      **** 						}
 871:../uvc.c      **** 						sendData += 4;
 872:../uvc.c      **** 					 }
 873:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 874:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 875:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 876:../uvc.c      **** 					 break;
 877:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 878:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 879:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 880:../uvc.c      **** 			 		 }
 881:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 882:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 883:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 884:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 885:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 886:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 887:../uvc.c      **** #endif
 888:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 889:../uvc.c      **** 			 		 {
 890:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 891:../uvc.c      **** 			 		 }
 892:../uvc.c      **** 			 		 break;
 893:../uvc.c      **** 				 case ExtAexModCtlID9:
 894:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 895:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 896:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 897:../uvc.c      **** 
 898:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 899:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 900:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 901:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 902:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 903:../uvc.c      **** 		 	 		 }else{
 904:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 905:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 906:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 907:../uvc.c      **** 
 908:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 909:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 910:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 911:../uvc.c      **** 		 	 		 }
 912:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 913:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 914:../uvc.c      **** 
 915:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 916:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 917:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 918:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 919:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 920:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 921:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 922:../uvc.c      **** 					 break;
 923:../uvc.c      **** 
 924:../uvc.c      **** 			 	 case BrgtCtlID1:
 925:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 926:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 927:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 928:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 929:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 930:../uvc.c      **** 					 }else{
 931:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 932:../uvc.c      **** 					 }
 933:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 934:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 935:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 936:../uvc.c      **** 					 */
 937:../uvc.c      **** 
 938:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 939:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 940:../uvc.c      **** 		 	 		 }else{
 941:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 942:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 943:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 944:../uvc.c      **** 		 	 		 }
 945:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
 946:../uvc.c      **** 					  if(Data0&0x80){
 947:../uvc.c      **** 						  Data0 = ~Data0;
 948:../uvc.c      **** 					  }else{
 949:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 950:../uvc.c      **** 					  }
 951:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 952:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 953:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 954:../uvc.c      **** 			 		 break;
 955:../uvc.c      **** 				 case HueCtlID5:
 956:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 957:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 958:../uvc.c      **** 		 	 		 }else{
 959:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 960:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 961:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 962:../uvc.c      **** 		 	 		 }
 963:../uvc.c      **** 
 964:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 966:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 967:../uvc.c      **** 					 break;
 968:../uvc.c      **** 				 case WBTLevCtlID11:
 969:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 970:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 971:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 973:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 974:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 975:../uvc.c      **** 					 break;
 976:../uvc.c      **** 				 case BLCCtlID0:
 977:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 978:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 979:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 980:../uvc.c      **** 		 	 		 }else{
 981:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 982:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 983:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 984:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 985:../uvc.c      **** 		 	 		 }
 986:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 987:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 988:../uvc.c      **** 					 break;
 989:../uvc.c      **** 				 case ShapCtlID7:
 990:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 991:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 992:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 993:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 994:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 995:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 996:../uvc.c      **** 		 	 		 }else{
 997:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 998:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 999:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1000:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1001:../uvc.c      **** 		 	 		 }
1002:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1003:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1004:../uvc.c      **** 					 break;
1005:../uvc.c      **** 				 case ExtExRefCtlID10:
1006:../uvc.c      **** 				 case ConsCtlID2:
1007:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1008:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1009:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1010:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1011:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1012:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1013:../uvc.c      **** 		 	 		 }else{
1014:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1015:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1016:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1017:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1018:../uvc.c      **** 		 	 		 }
1019:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1020:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1021:../uvc.c      **** 					 break;
1022:../uvc.c      **** 				 case WBTMdCtlID9:
1023:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1024:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1025:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1026:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1027:../uvc.c      **** 		 	 		 }else{
1028:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1030:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1031:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1032:../uvc.c      **** 
1033:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1034:../uvc.c      **** 		 	 		 }
1035:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1036:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1037:../uvc.c      **** 					 break;
1038:../uvc.c      **** 				 case MFreqCtlID4:
1039:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1040:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1041:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1042:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1043:../uvc.c      **** 		 	 		 }else{
1044:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1045:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1046:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1048:../uvc.c      **** 
1049:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1050:../uvc.c      **** 		 	 		 }
1051:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1052:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1053:../uvc.c      **** 					 break;
1054:../uvc.c      **** 				 case SaturCtlID6:
1055:../uvc.c      **** 				 default:
1056:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1057:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1058:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1059:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1060:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1061:../uvc.c      **** 		 	 		 }else{
1062:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1063:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1064:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1065:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1066:../uvc.c      **** 		 	 		 }
1067:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1068:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1069:../uvc.c      **** 
1070:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1071:../uvc.c      **** 					 break;
1072:../uvc.c      **** 			 }
1073:../uvc.c      **** 
1074:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1075:../uvc.c      **** 
1076:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1077:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1078:../uvc.c      **** #endif
1079:../uvc.c      **** 			  break;
1080:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1081:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1082:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1083:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1084:../uvc.c      **** 		 	 }
1085:../uvc.c      **** 
1086:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1087:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1088:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1089:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1090:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1091:../uvc.c      **** 			 }else
1092:../uvc.c      **** 			 {
1093:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1094:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1095:../uvc.c      **** 			 }
1096:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1097:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1098:../uvc.c      **** 			  break;
1099:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1100:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1101:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1102:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1103:../uvc.c      **** 		 	 }
1104:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1105:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1106:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1107:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1108:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1109:../uvc.c      **** 			 }else
1110:../uvc.c      **** 			 {
1111:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1112:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1113:../uvc.c      **** 			 }
1114:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1115:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1116:../uvc.c      **** 			  break;
1117:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1118:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1119:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1120:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1121:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1122:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1123:../uvc.c      **** 		 	 }
1124:../uvc.c      **** 		 	 else{
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1126:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1127:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1128:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1129:../uvc.c      **** 		 	 }
1130:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1132:../uvc.c      **** 			  break;
1133:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1134:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1136:../uvc.c      **** 		 	 }
1137:../uvc.c      **** 		 	 else{
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1139:../uvc.c      **** 		 	 }
1140:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1141:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1142:../uvc.c      **** 			  Len = 1;
1143:../uvc.c      **** 			  break;
1144:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1145:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1146:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1147:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1148:../uvc.c      **** 		 	 }
1149:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1150:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1151:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1152:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1153:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1154:../uvc.c      **** 			 }else{
1155:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1156:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1157:../uvc.c      **** 			 }
1158:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1159:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1160:../uvc.c      **** 			  break;
1161:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1162:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1163:../uvc.c      **** 				  glEp0Buffer, &readCount);
1164:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1165:../uvc.c      **** 			   {
1166:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1167:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1168:../uvc.c      **** 				  getData = glEp0Buffer[0];
1169:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1170:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1171:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1172:../uvc.c      **** #endif
1173:../uvc.c      **** 				  switch(CtrlID)
1174:../uvc.c      **** 					 {
1175:../uvc.c      **** 						 case ExtShutCtlID0:
1176:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1177:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1178:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1179:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1180:../uvc.c      **** #if 1	// register setting directly
1181:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1182:../uvc.c      **** 						     {
1183:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1184:../uvc.c      **** 						    	 dataIdx = 0;
1185:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1186:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1187:../uvc.c      **** 								 dataIdx++;
1188:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1189:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1190:../uvc.c      **** 						     }
1191:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1192:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1193:../uvc.c      **** 						     break;
1194:../uvc.c      **** #else	// old fashion
1195:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1196:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1197:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1198:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1199:../uvc.c      **** 									 }else{
1200:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1201:../uvc.c      **** 									 }
1202:../uvc.c      **** 								 }
1203:../uvc.c      **** 							 }else{
1204:../uvc.c      **** 								 Data1 = Data0 - 1;
1205:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1206:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1207:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1208:../uvc.c      **** 									 }else{
1209:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1210:../uvc.c      **** 									 }
1211:../uvc.c      **** 								 }
1212:../uvc.c      **** 								 if(Data1 < 8){
1213:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1214:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1215:../uvc.c      **** 								 }else{
1216:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1217:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1218:../uvc.c      **** 								 }
1219:../uvc.c      **** 							 }
1220:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1221:../uvc.c      **** 							 dataIdx = 0;
1222:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1223:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1224:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1225:../uvc.c      **** 							 if(AxMode){
1226:../uvc.c      **** 								 dataIdx++;
1227:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1228:../uvc.c      **** 								 dataIdx++;
1229:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1230:../uvc.c      **** 							 }
1231:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1232:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1233:../uvc.c      **** 							 break;
1234:../uvc.c      **** #endif
1235:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1236:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1237:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1238:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1239:../uvc.c      **** 						     dataIdx = 0;
1240:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1241:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1242:../uvc.c      **** 							 {
1243:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1244:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1245:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1246:../uvc.c      **** 								 /*
1247:../uvc.c      **** 								 dataIdx++;
1248:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1249:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1250:../uvc.c      **** 									 dataIdx++;
1251:../uvc.c      **** 								 }else{
1252:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1253:../uvc.c      **** 									 dataIdx++;
1254:../uvc.c      **** 								 }
1255:../uvc.c      **** 								 */
1256:../uvc.c      **** 							 }
1257:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1258:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1259:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1260:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1261:../uvc.c      **** 								 }
1262:../uvc.c      **** 							 }
1263:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1264:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1265:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1266:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1267:../uvc.c      **** 							 break;
1268:../uvc.c      **** 
1269:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1270:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1271:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1272:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1273:../uvc.c      **** 						     dataIdx = 0;
1274:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1275:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1276:../uvc.c      **** 							 {
1277:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1278:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1280:../uvc.c      **** 								 dataIdx++;
1281:../uvc.c      **** 							 }
1282:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1283:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1284:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1285:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1286:../uvc.c      **** 									 dataIdx++;
1287:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1288:../uvc.c      **** 								 }
1289:../uvc.c      **** 							 }
1290:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1291:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1293:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1294:../uvc.c      **** 							 break;
1295:../uvc.c      **** 						 case ExtCamMCtlID12:
1296:../uvc.c      **** 							 dataIdx = 0;
1297:../uvc.c      **** 							 if(Data0 <= 3){
1298:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1299:../uvc.c      **** 								 Data1 = Data0;
1300:../uvc.c      **** 							 }else{
1301:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1302:../uvc.c      **** 								 Data1 = Data0-4;
1303:../uvc.c      **** 							 }
1304:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1305:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1306:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1307:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1308:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1309:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1310:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1311:../uvc.c      **** 							 break;
1312:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1313:../uvc.c      **** 							 dataIdx = 0;
1314:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1315:../uvc.c      **** 								 Data0 = 1;
1316:../uvc.c      **** 							 }else{ //save current sensor parameters.
1317:../uvc.c      **** 								 Data0 = 0;
1318:../uvc.c      **** 							 }
1319:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1320:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1321:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1322:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1323:../uvc.c      **** 							 break;
1324:../uvc.c      **** 						 case ExtI2CCtlID15:
1325:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1326:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1327:../uvc.c      **** 					 		 }
1328:../uvc.c      **** 					 		I2CCmdHandler();
1329:../uvc.c      **** 							 break;
1330:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1331:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1332:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1333:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1334:../uvc.c      **** 
1335:../uvc.c      **** 							 dataIdx = 0;
1336:../uvc.c      **** #if 0 //seperate version
1337:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1338:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1339:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1340:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1341:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1342:../uvc.c      **** 							 }else{ //disable BLD window
1343:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1344:../uvc.c      **** 							 }
1345:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1346:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1347:../uvc.c      **** 							 dataIdx++;
1348:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1349:../uvc.c      **** 							 dataIdx++;
1350:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1351:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1352:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1353:../uvc.c      **** 							 dataIdx++;
1354:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1356:../uvc.c      **** #else //combination version
1357:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1358:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1359:../uvc.c      **** 						     /* end test */
1360:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1361:../uvc.c      **** 							 dataIdx++;
1362:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1363:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1364:../uvc.c      **** 							 getData1 = Data1;
1365:../uvc.c      **** #endif
1366:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1367:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1368:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1369:../uvc.c      **** 							 break;
1370:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1371:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1372:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1373:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1374:../uvc.c      **** 
1375:../uvc.c      **** 							 dataIdx = 0;
1376:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1377:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1378:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1379:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1380:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1381:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1382:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1383:../uvc.c      **** 							 break;
1384:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1385:../uvc.c      **** 							 dataIdx = 0;
1386:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1387:../uvc.c      **** 							 if(Data0 == 1){
1388:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1389:../uvc.c      **** 							 }else{
1390:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1391:../uvc.c      **** 							 }
1392:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1393:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1394:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1395:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1396:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1397:../uvc.c      **** 							 break;
1398:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1399:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1400:../uvc.c      **** 							 dataIdx = 0;
1401:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1402:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1403:../uvc.c      **** 							  if(Data0&0x80){
1404:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1405:../uvc.c      **** 							  }else{
1406:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1407:../uvc.c      **** 							  }
1408:../uvc.c      **** 							 Data1 |= ~0x03;
1409:../uvc.c      **** 							 Data1 &= 0xC7;
1410:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1411:../uvc.c      **** 						  	 dataIdx++;
1412:../uvc.c      **** 
1413:../uvc.c      **** 							 Data0 = (Data0 << 2);
1414:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1415:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1416:../uvc.c      **** 
1417:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1418:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1419:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1420:../uvc.c      **** #endif
1421:../uvc.c      **** 							 dataIdx = 0;
1422:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1423:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1424:../uvc.c      **** 							  if(Data0&0x80){
1425:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1426:../uvc.c      **** 							  }else{
1427:../uvc.c      **** 								  Data0 = ~Data0;
1428:../uvc.c      **** 							  }
1429:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1431:../uvc.c      **** 
1432:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1434:../uvc.c      **** 
1435:../uvc.c      **** 
1436:../uvc.c      **** 							 break;
1437:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1438:../uvc.c      **** 							 dataIdx = 0;
1439:../uvc.c      **** 
1440:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1441:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1442:../uvc.c      **** 							 dataIdx++;
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1444:../uvc.c      **** 							 dataIdx++;
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1446:../uvc.c      **** 							 dataIdx++;
1447:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1448:../uvc.c      **** 							 dataIdx++;
1449:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1450:../uvc.c      **** 							 dataIdx++;
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1452:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1453:../uvc.c      **** 
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1455:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1456:../uvc.c      **** 							 break;
1457:../uvc.c      **** 						 case SaturCtlID6:
1458:../uvc.c      **** 							 dataIdx = 0;
1459:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1460:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1461:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1462:../uvc.c      **** 							 dataIdx++;
1463:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1465:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1466:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1467:../uvc.c      **** 							 break;
1468:../uvc.c      **** 
1469:../uvc.c      **** 						 case WBTLevCtlID11:
1470:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1471:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1472:../uvc.c      **** 							 dataIdx = 0;
1473:../uvc.c      **** 
1474:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1475:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1476:../uvc.c      **** 							 dataIdx++;
1477:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1478:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1479:../uvc.c      **** 
1480:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1481:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1482:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1483:../uvc.c      **** 							 break;
1484:../uvc.c      **** 						 case MFreqCtlID4:
1485:../uvc.c      **** 							 dataIdx = 0;
1486:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1487:../uvc.c      **** 							 Data0 = Data0 - 1;
1488:../uvc.c      **** 							 is60Hz = Data0;
1489:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1490:../uvc.c      **** 							 {
1491:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1492:../uvc.c      **** 								 is60Hz = CyFalse;
1493:../uvc.c      **** 							 }
1494:../uvc.c      **** 							 else if(Data0 >2)
1495:../uvc.c      **** 							 {
1496:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1497:../uvc.c      **** 								 is60Hz = CyTrue;
1498:../uvc.c      **** 							 }
1499:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1500:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1501:../uvc.c      **** 							 {
1502:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1503:../uvc.c      **** 			                       switch (setRes)
1504:../uvc.c      **** 			                         {
1505:../uvc.c      **** 			                         	case 1: //1944
1506:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1507:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1508:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1509:../uvc.c      **** 			                         		break;
1510:../uvc.c      **** 			                         	case 2: //1080
1511:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1512:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1513:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1514:../uvc.c      **** 			                         		break;
1515:../uvc.c      **** 			                         	case 3: //720
1516:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1517:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1518:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1519:../uvc.c      **** 			                         		break;
1520:../uvc.c      **** 			                         	case 4: //VGA
1521:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1522:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1523:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1524:../uvc.c      **** 			                         	default:
1525:../uvc.c      **** 			                         		break;
1526:../uvc.c      **** 			                         }
1527:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1528:../uvc.c      **** 							 }
1529:../uvc.c      **** 
1530:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1531:../uvc.c      **** 							 break;
1532:../uvc.c      **** 					 	 case BLCCtlID0:
1533:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1534:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1535:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1536:../uvc.c      **** 						     dataIdx = 0;
1537:../uvc.c      **** 
1538:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1539:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1540:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1541:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1542:../uvc.c      **** 
1543:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1544:../uvc.c      **** 							 {
1545:../uvc.c      **** 								 if(Data0 < 3){
1546:../uvc.c      **** 					 				 Data0 += 4;
1547:../uvc.c      **** 					 			 }else{
1548:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1549:../uvc.c      **** 									Data0 = 4; //set to default.
1550:../uvc.c      **** 					 			 }
1551:../uvc.c      **** 					 		 }
1552:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1553:../uvc.c      **** 							 dataIdx = 0;
1554:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1555:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1556:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1557:../uvc.c      **** 
1558:../uvc.c      **** 					 		 break;
1559:../uvc.c      **** 					 	 case ShapCtlID7:
1560:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1561:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1562:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1563:../uvc.c      **** 						     dataIdx = 0;
1564:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1565:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1566:../uvc.c      **** 							 if(Data0 != 0){
1567:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1568:../uvc.c      **** #ifdef COLOR
1569:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1570:../uvc.c      **** #else
1571:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1572:../uvc.c      **** 								 dataIdx++;
1573:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1574:../uvc.c      **** #endif
1575:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1576:../uvc.c      **** 							 }else{
1577:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1578:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1579:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1580:../uvc.c      **** 
1581:../uvc.c      **** 							 }
1582:../uvc.c      **** 							 break;
1583:../uvc.c      **** 						 case ExtExRefCtlID10:
1584:../uvc.c      **** 						 case ConsCtlID2:
1585:../uvc.c      **** 							 dataIdx = 0;
1586:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1587:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1588:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1589:../uvc.c      **** 
1590:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1591:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1592:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1593:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1594:../uvc.c      **** 
1595:../uvc.c      **** 							 break;
1596:../uvc.c      **** 						 default:
1597:../uvc.c      **** 							 dataIdx = 0;
1598:../uvc.c      **** 
1599:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1600:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1601:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1602:../uvc.c      **** 
1603:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1604:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1605:../uvc.c      **** 							 break;
1606:../uvc.c      **** 					 }
1607:../uvc.c      **** 			   }else{
1608:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1609:../uvc.c      **** 			   }
1610:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1611:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1612:../uvc.c      **** #endif
1613:../uvc.c      **** 
1614:../uvc.c      **** 			  break;
1615:../uvc.c      **** 		  default:
1616:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1617:../uvc.c      **** 			  break;
1618:../uvc.c      **** 		 }
1619:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1620:../uvc.c      **** }
1621:../uvc.c      **** /************** CT control requests handler *************************/
1622:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1623:../uvc.c      **** 
1624:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1625:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1626:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1627:../uvc.c      ****     uint16_t readCount;
1628:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1629:../uvc.c      ****     uint16_t diff, value, diffRd;
1630:../uvc.c      ****     uint8_t i, shutter, index;
1631:../uvc.c      ****     diff = 0xffff;
1632:../uvc.c      ****     shutter = 1;
1633:../uvc.c      ****     index = 1;
1634:../uvc.c      **** 
1635:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1636:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1637:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1638:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1640:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1641:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1642:../uvc.c      **** #endif
1643:../uvc.c      ****     reqData = bRequest;
1644:../uvc.c      **** 
1645:../uvc.c      ****     switch (bRequest)
1646:../uvc.c      **** 		 {
1647:../uvc.c      **** 
1648:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1649:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1650:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1651:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1652:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1653:../uvc.c      **** 			  break;
1654:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1655:../uvc.c      **** 
1656:../uvc.c      **** 			 switch(CtrlID)
1657:../uvc.c      **** 			 {
1658:../uvc.c      **** 				 default:
1659:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1660:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1661:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1662:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1663:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1664:../uvc.c      **** 					 break;
1665:../uvc.c      **** 			 }
1666:../uvc.c      **** 
1667:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1668:../uvc.c      **** 
1669:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1670:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1671:../uvc.c      **** #endif
1672:../uvc.c      **** 			  break;
1673:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1674:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1675:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1676:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1677:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1678:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1679:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1680:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1681:../uvc.c      **** 			  break;
1682:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1683:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1684:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1685:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1686:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1687:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1688:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1689:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1690:../uvc.c      **** 			  break;
1691:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1692:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1693:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1694:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1695:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1696:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1697:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1698:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1699:../uvc.c      **** 			  break;
1700:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1701:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1702:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1703:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1704:../uvc.c      **** 			  Len = 1;
1705:../uvc.c      **** 			  break;
1706:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1707:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1708:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1709:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1710:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1711:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1712:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1713:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1714:../uvc.c      **** 			  break;
1715:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1716:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1717:../uvc.c      **** 			  glEp0Buffer, &readCount);
1718:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1719:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1720:../uvc.c      **** 			  value = Data1;
1721:../uvc.c      **** 
1722:../uvc.c      **** 			  switch(CtrlID)
1723:../uvc.c      **** 			  {
1724:../uvc.c      **** 		  	      case AutoExMCtlID1:
1725:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1726:../uvc.c      **** 
1727:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1728:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1729:../uvc.c      **** 				    getData = glEp0Buffer[0];
1730:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1731:../uvc.c      **** 		  		    switch (getData){
1732:../uvc.c      **** 						case 1:
1733:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1734:../uvc.c      **** 							break;
1735:../uvc.c      **** 						case 2:
1736:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1737:../uvc.c      **** 							dataIdx = 0;
1738:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1739:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1740:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1741:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1742:../uvc.c      **** 
1743:../uvc.c      **** 							break;
1744:../uvc.c      **** 						case 4:
1745:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1746:../uvc.c      **** 							break;
1747:../uvc.c      **** 						case 8:
1748:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1749:../uvc.c      **** 			  		    	dataIdx = 0;
1750:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1751:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1752:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1753:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1754:../uvc.c      **** 							break;
1755:../uvc.c      **** 		  		    }
1756:../uvc.c      **** #if 0
1757:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1758:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1759:../uvc.c      **** 						  dataIdx = 0;
1760:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1761:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1762:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1763:../uvc.c      **** 		  		    }
1764:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1765:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1766:../uvc.c      **** 		  		    }
1767:../uvc.c      **** #endif
1768:../uvc.c      **** 				    break;
1769:../uvc.c      **** 
1770:../uvc.c      **** 			  	  case ExTmACtlID3:
1771:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1772:../uvc.c      **** 
1773:../uvc.c      **** 					  value = (value << 8)|Data0;
1774:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1775:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1776:../uvc.c      **** 					  {
1777:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1778:../uvc.c      **** 						  {
1779:../uvc.c      **** 							if(value > ShutValueArry[i]){
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1781:../uvc.c      **** 							}else{
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1783:../uvc.c      **** 							}
1784:../uvc.c      **** 							  if(diff > diffRd){
1785:../uvc.c      **** 								  diff = diffRd;
1786:../uvc.c      **** 								  index = i;
1787:../uvc.c      **** 							  }
1788:../uvc.c      **** 						  }
1789:../uvc.c      **** 						  shutter = shutter+index;
1790:../uvc.c      **** 
1791:../uvc.c      **** 						  dataIdx = 0;
1792:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1793:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1794:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1795:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1796:../uvc.c      **** 
1797:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1798:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1799:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1800:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1801:../uvc.c      **** 					  }else{
1802:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1803:../uvc.c      **** 					  }
1804:../uvc.c      **** 					  getData = glEp0Buffer[0];
1805:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1806:../uvc.c      **** 					  break;
1807:../uvc.c      **** 			  	  case IriACtlID7:
1808:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1809:../uvc.c      **** 					  {
1810:../uvc.c      **** 							 dataIdx = 0;
1811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1812:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1814:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1815:../uvc.c      **** 
1816:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1817:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1818:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1819:../uvc.c      **** 					  }else{
1820:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1821:../uvc.c      **** 					  }
1822:../uvc.c      **** 					  getData = glEp0Buffer[0];
1823:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1824:../uvc.c      **** 
1825:../uvc.c      **** 					  break;
1826:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1827:../uvc.c      **** 					  getData = glEp0Buffer[0];
1828:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1829:../uvc.c      **** #if 1
1830:../uvc.c      **** 					  dataIdx = 0;
1831:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1832:../uvc.c      **** 					  if(getData == 1)
1833:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1834:../uvc.c      **** 					  else if(getData == 0xff)
1835:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1836:../uvc.c      **** 					  else
1837:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1838:../uvc.c      **** 					  //dataIdx++;
1839:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1840:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1841:../uvc.c      **** #endif
1842:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1843:../uvc.c      **** 					  break;
1844:../uvc.c      **** 
1845:../uvc.c      **** 			  	  default:
1846:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1847:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1848:../uvc.c      **** 			  		 break;
1849:../uvc.c      **** 			  }
1850:../uvc.c      **** 			  break;
1851:../uvc.c      **** 		  default:
1852:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1853:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1854:../uvc.c      **** 			  break;
1855:../uvc.c      **** 		 }
1856:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1857:../uvc.c      **** 
1858:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1859:../uvc.c      **** }
1860:../uvc.c      **** 
1861:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1862:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1863:../uvc.c      **** {
1864:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1865:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1866:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1867:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1868:../uvc.c      **** 
1869:../uvc.c      ****     CtrlID = BrgtCtlID1;
1870:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1871:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1872:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1873:../uvc.c      ****     Data1 = Data0;
1874:../uvc.c      **** 
1875:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1876:../uvc.c      ****     if(Data1&0x80){
1877:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1878:../uvc.c      ****     }else{
1879:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1880:../uvc.c      ****     }
1881:../uvc.c      ****     Data0 = (Data0 << 2);
1882:../uvc.c      **** 
1883:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1884:../uvc.c      **** 
1885:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1886:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1887:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1888:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1889:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1890:../uvc.c      **** 
1891:../uvc.c      ****     CtrlID = ConsCtlID2;
1892:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1893:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1894:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1895:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1896:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1897:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1898:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1899:../uvc.c      **** 
1900:../uvc.c      ****     CtrlID = HueCtlID5;
1901:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1902:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1903:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1904:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1907:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1908:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1909:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1910:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1911:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1912:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1913:../uvc.c      **** 
1914:../uvc.c      ****     CtrlID = SaturCtlID6;
1915:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1916:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1917:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1919:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1920:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1921:../uvc.c      **** 
1922:../uvc.c      ****     CtrlID = ShapCtlID7;
1923:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1924:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1925:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1926:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1927:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1928:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1929:../uvc.c      **** 
1930:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
1931:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1932:../uvc.c      **** 	return;
1933:../uvc.c      **** }
1934:../uvc.c      **** 
1935:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1936:../uvc.c      **** void
1937:../uvc.c      **** CyFxUVCAddHeader (
1938:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1939:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1940:../uvc.c      ****         )
1941:../uvc.c      **** {
1942:../uvc.c      ****     /* Copy header to buffer */
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1944:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1945:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1946:../uvc.c      **** 
1947:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1948:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1949:../uvc.c      ****     {
1950:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1951:../uvc.c      ****     }
1952:../uvc.c      **** }
1953:../uvc.c      **** 
1954:../uvc.c      **** 
1955:../uvc.c      **** /* Application Error Handler */
1956:../uvc.c      **** void
1957:../uvc.c      **** CyFxAppErrorHandler (
1958:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1959:../uvc.c      ****         )
1960:../uvc.c      **** {
1961:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1962:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1963:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1964:../uvc.c      **** 
1965:../uvc.c      ****        This function can be modified to take additional error handling actions such
1966:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1967:../uvc.c      ****      */
1968:../uvc.c      ****     for (;;)
1969:../uvc.c      ****     {
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
1972:../uvc.c      ****     }
1973:../uvc.c      **** }
1974:../uvc.c      **** 
1975:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1976:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1977:../uvc.c      ****  */
1978:../uvc.c      **** static void
1979:../uvc.c      **** CyFxUVCApplnAbortHandler (
1980:../uvc.c      ****         void)
1981:../uvc.c      **** {
1982:../uvc.c      **** 	uint32_t flag;
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1984:../uvc.c      **** 	{
1985:../uvc.c      ****         /* Clear the Video Stream Request Event */
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1987:../uvc.c      **** 
1988:../uvc.c      ****         /* Set Video Stream Abort Event */
1989:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1990:../uvc.c      **** 	}
1991:../uvc.c      **** }
1992:../uvc.c      **** 
1993:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1994:../uvc.c      **** static void
1995:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1996:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1997:../uvc.c      ****         uint16_t             evdata  /* Event data */
1998:../uvc.c      ****         )
1999:../uvc.c      **** {
2000:../uvc.c      ****     switch (evtype)
2001:../uvc.c      ****     {
2002:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2003:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2004:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2005:../uvc.c      ****             gpif_initialized = 0;
2006:../uvc.c      ****             streamingStarted = CyFalse;
2007:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2008:../uvc.c      ****             break;
2009:../uvc.c      **** 
2010:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2011:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2012:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2013:../uvc.c      ****             gpif_initialized = 0;
2014:../uvc.c      ****             streamingStarted = CyFalse;
2015:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2016:../uvc.c      ****             break;
2017:../uvc.c      **** 
2018:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2019:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2020:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2021:../uvc.c      ****             gpif_initialized = 0;
2022:../uvc.c      ****             isUsbConnected = CyFalse;
2023:../uvc.c      ****             streamingStarted = CyFalse;
2024:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2025:../uvc.c      ****             break;
2026:../uvc.c      **** 
2027:../uvc.c      **** #ifdef BACKFLOW_DETECT
2028:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2029:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2030:../uvc.c      ****             break;
2031:../uvc.c      **** #endif
2032:../uvc.c      **** 
2033:../uvc.c      ****         default:
2034:../uvc.c      ****             break;
2035:../uvc.c      ****     }
2036:../uvc.c      **** }
2037:../uvc.c      **** 
2038:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2039:../uvc.c      **** static CyBool_t
2040:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2041:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2042:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2043:../uvc.c      ****         )
2044:../uvc.c      **** {
2045:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2046:../uvc.c      ****     uint32_t status;
2047:../uvc.c      **** 
2048:../uvc.c      ****     /* Obtain Request Type and Request */
2049:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2050:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2051:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2052:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2053:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2054:../uvc.c      **** 
2055:../uvc.c      ****     /* Check for UVC Class Requests */
2056:../uvc.c      ****     switch (bmReqType)
2057:../uvc.c      ****     {
2058:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2059:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2060:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2061:../uvc.c      ****             switch (wIndex & 0xFF)
2062:../uvc.c      ****             {
2063:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2064:../uvc.c      ****                     {
2065:../uvc.c      ****                         uvcHandleReq = CyTrue;
2066:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2067:../uvc.c      ****                                 CYU3P_EVENT_OR);
2068:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2069:../uvc.c      ****                         {
2070:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2071:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2072:../uvc.c      ****                         }
2073:../uvc.c      ****                     }
2074:../uvc.c      ****                     break;
2075:../uvc.c      **** 
2076:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2077:../uvc.c      ****                     {
2078:../uvc.c      ****                         uvcHandleReq = CyTrue;
2079:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2080:../uvc.c      ****                                 CYU3P_EVENT_OR);
2081:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2082:../uvc.c      ****                         {
2083:../uvc.c      ****                             /* Error handling */
2084:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2085:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2086:../uvc.c      ****                         }
2087:../uvc.c      ****                     }
2088:../uvc.c      ****                     break;
2089:../uvc.c      **** 
2090:../uvc.c      ****                 default:
2091:../uvc.c      ****                     break;
2092:../uvc.c      ****             }
2093:../uvc.c      ****             break;
2094:../uvc.c      **** 
2095:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2096:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2097:../uvc.c      ****             {
2098:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2099:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2100:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2101:../uvc.c      ****                 {
2102:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2103:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2104:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2105:../uvc.c      ****                     gpif_initialized = 0;
2106:../uvc.c      ****                     streamingStarted = CyFalse;
2107:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2108:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2109:../uvc.c      ****                     CyU3PBusyWait (100);
2110:../uvc.c      **** 
2111:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2112:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2113:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2114:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2115:../uvc.c      ****                     CyU3PBusyWait (100);
2116:../uvc.c      **** 
2117:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2118:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2119:../uvc.c      ****                     uvcHandleReq = CyTrue;
2120:../uvc.c      ****                     /* Complete Control request handshake */
2121:../uvc.c      ****                     CyU3PUsbAckSetup ();
2122:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2123:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2124:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2125:../uvc.c      **** 
2126:../uvc.c      ****                 }
2127:../uvc.c      ****             }
2128:../uvc.c      ****             break;
2129:../uvc.c      **** 
2130:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2131:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2132:../uvc.c      ****             {
2133:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2134:../uvc.c      ****                 {
2135:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2136:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2137:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2138:../uvc.c      ****                 	 * has started. */
2139:../uvc.c      ****                     if (streamingStarted == CyTrue)
2140:../uvc.c      ****                     {
2141:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2142:../uvc.c      **** 
2143:../uvc.c      ****                         /* Disable the GPIF state machine. */
2144:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2145:../uvc.c      ****                         gpif_initialized = 0;
2146:../uvc.c      ****                         streamingStarted = CyFalse;
2147:../uvc.c      **** 
2148:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2149:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2150:../uvc.c      ****                         CyU3PBusyWait (100);
2151:../uvc.c      **** 
2152:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2153:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2154:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2155:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2156:../uvc.c      ****                         CyU3PBusyWait (100);
2157:../uvc.c      **** 
2158:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2159:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2160:../uvc.c      **** 
2161:../uvc.c      ****                         uvcHandleReq = CyTrue;
2162:../uvc.c      ****                         /* Complete Control request handshake */
2163:../uvc.c      ****                         CyU3PUsbAckSetup ();
2164:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2165:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2166:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2167:../uvc.c      ****                     }
2168:../uvc.c      ****                     else
2169:../uvc.c      ****                     {
2170:../uvc.c      ****                         uvcHandleReq = CyTrue;
2171:../uvc.c      ****                         CyU3PUsbAckSetup ();
2172:../uvc.c      ****                     }
2173:../uvc.c      ****                 }
2174:../uvc.c      ****             }
2175:../uvc.c      ****             break;
2176:../uvc.c      **** 
2177:../uvc.c      ****         default:
2178:../uvc.c      ****             break;
2179:../uvc.c      ****     }
2180:../uvc.c      **** 
2181:../uvc.c      ****     /* Return status of request handling to the USB driver */
2182:../uvc.c      ****     return uvcHandleReq;
2183:../uvc.c      **** }
2184:../uvc.c      **** 
2185:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2186:../uvc.c      **** 
2187:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2188:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2189:../uvc.c      ****  */
2190:../uvc.c      **** void
2191:../uvc.c      **** CyFxUvcApplnDmaCallback (
2192:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2193:../uvc.c      ****         CyU3PDmaCbType_t      type,
2194:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2195:../uvc.c      ****         )
2196:../uvc.c      **** {
2197:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2198:../uvc.c      **** #if 1
2199:../uvc.c      ****     CyU3PReturnStatus_t status;
2200:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2201:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2202:../uvc.c      **** 
2203:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2204:../uvc.c      ****     {
2205:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2206:../uvc.c      ****             {
2207:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2208:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2209:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2210:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2211:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2212:../uvc.c      ****                 	stiflag = 0x03;
2213:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2214:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2215:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2216:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2217:../uvc.c      ****                 }
2218:../uvc.c      **** #endif
2219:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2220:../uvc.c      ****                 fb++;
2221:../uvc.c      ****             }
2222:../uvc.c      ****             else
2223:../uvc.c      ****             {
2224:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2225:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2226:../uvc.c      ****                 pb++;
2227:../uvc.c      ****                 pbc = input->buffer_p.count;
2228:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2229:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2230:../uvc.c      ****                 //lineCount = 0; //res test
2231:../uvc.c      **** #if 1   //remove the still flag clearing here
2232:../uvc.c      ****                 if(stiflag == 0x0F){
2233:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2234:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2235:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2236:../uvc.c      ****                 	stiflag = 0xAA;
2237:../uvc.c      ****                 }
2238:../uvc.c      **** #endif
2239:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2240:../uvc.c      ****             }
2241:../uvc.c      **** 
2242:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2243:../uvc.c      ****             prodCount++;
2244:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2245:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2246:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2247:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2248:../uvc.c      ****             {
2249:../uvc.c      ****                 prodCount--;
2250:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2251:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2252:../uvc.c      ****             }
2253:../uvc.c      ****     }
2254:../uvc.c      **** #endif
2255:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2256:../uvc.c      ****     {
2257:../uvc.c      ****         consCount++;
2258:../uvc.c      ****         streamingStarted = CyTrue;
2259:../uvc.c      ****     }
2260:../uvc.c      **** }
2261:../uvc.c      **** 
2262:../uvc.c      **** /*
2263:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2264:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2265:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2266:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2267:../uvc.c      ****  * to commit the buffer.
2268:../uvc.c      ****  */
2269:../uvc.c      **** static uint8_t
2270:../uvc.c      **** CyFxUvcAppCommitEOF (
2271:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2272:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2273:../uvc.c      ****         )
2274:../uvc.c      **** {
2275:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2276:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2277:../uvc.c      **** 
2278:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2279:../uvc.c      **** 
2280:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2281:../uvc.c      ****     {
2282:../uvc.c      ****         switch (stateId)
2283:../uvc.c      ****         {
2284:../uvc.c      **** 
2285:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2286:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2287:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2288:../uvc.c      ****                 break;
2289:../uvc.c      **** 
2290:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2291:../uvc.c      ****                 socket = 0;
2292:../uvc.c      ****                 break;
2293:../uvc.c      **** 
2294:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2295:../uvc.c      ****                 socket = 1;
2296:../uvc.c      ****                 break;
2297:../uvc.c      **** 
2298:../uvc.c      ****             default:
2299:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2300:../uvc.c      ****                 /* Unexpected current state. Return error. */
2301:../uvc.c      ****             	//lineCount++;
2302:../uvc.c      ****             	return 1;
2303:../uvc.c      ****         }
2304:../uvc.c      ****     }
2305:../uvc.c      **** 
2306:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2307:../uvc.c      ****     {
2308:../uvc.c      ****         switch (stateId)
2309:../uvc.c      ****         {
2310:../uvc.c      **** #ifndef CAM720
2311:../uvc.c      **** #ifdef GPIFIIM
2312:../uvc.c      ****             case 13:
2313:../uvc.c      ****             case 24:
2314:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2315:../uvc.c      ****                 break;
2316:../uvc.c      **** 
2317:../uvc.c      ****             case 8:
2318:../uvc.c      ****                 socket = 0;
2319:../uvc.c      ****                 break;
2320:../uvc.c      **** 
2321:../uvc.c      ****             case 20:
2322:../uvc.c      ****                 socket = 1;
2323:../uvc.c      ****                 break;
2324:../uvc.c      **** #else
2325:../uvc.c      ****             case 11:
2326:../uvc.c      ****             case 18:
2327:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2328:../uvc.c      ****                 break;
2329:../uvc.c      **** 
2330:../uvc.c      ****             case 8:
2331:../uvc.c      ****                 socket = 0;
2332:../uvc.c      ****                 break;
2333:../uvc.c      **** 
2334:../uvc.c      ****             case 15:
2335:../uvc.c      ****                 socket = 1;
2336:../uvc.c      ****                 break;
2337:../uvc.c      **** #endif
2338:../uvc.c      **** #else
2339:../uvc.c      ****             case 11:
2340:../uvc.c      ****             case 18:
2341:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2342:../uvc.c      ****                 break;
2343:../uvc.c      **** 
2344:../uvc.c      ****             case 8:
2345:../uvc.c      ****                 socket = 0;
2346:../uvc.c      ****                 break;
2347:../uvc.c      **** 
2348:../uvc.c      ****             case 15:
2349:../uvc.c      ****                 socket = 1;
2350:../uvc.c      ****                 break;
2351:../uvc.c      **** 
2352:../uvc.c      **** #endif
2353:../uvc.c      ****              default:
2354:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2355:../uvc.c      ****                 /* Unexpected current state. Return error. */
2356:../uvc.c      ****                return 1;
2357:../uvc.c      ****         }
2358:../uvc.c      ****     }
2359:../uvc.c      **** 
2360:../uvc.c      ****     if (socket != 0xFF)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2363:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2364:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2365:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2366:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2367:../uvc.c      ****         {
2368:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2369:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2370:../uvc.c      ****         }
2371:../uvc.c      ****     }
2372:../uvc.c      **** 
2373:../uvc.c      ****     return 0;
2374:../uvc.c      **** }
2375:../uvc.c      **** 
2376:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2377:../uvc.c      **** void
2378:../uvc.c      **** CyFxGpifCB (
2379:../uvc.c      ****         CyU3PGpifEventType event,
2380:../uvc.c      ****         uint8_t currentState
2381:../uvc.c      ****         )
2382:../uvc.c      **** {
2383:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2384:../uvc.c      ****     {
2385:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2386:../uvc.c      ****     	           in the UVC implementation. */
2387:../uvc.c      ****     	//hitFV = CyTrue;
2388:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2389:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2390:../uvc.c      ****     }
2391:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2392:../uvc.c      **** }
2393:../uvc.c      **** 
2394:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2395:../uvc.c      **** static void
2396:../uvc.c      **** CyFxUVCApplnDebugInit (
2397:../uvc.c      ****         void)
2398:../uvc.c      **** {
2399:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2400:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2401:../uvc.c      **** 
2402:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2403:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2404:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2405:../uvc.c      ****     {
2406:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2407:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2408:../uvc.c      ****     }
2409:../uvc.c      **** 
2410:../uvc.c      ****     /* Set UART Configuration */
2411:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2412:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2413:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2414:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2415:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2416:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2417:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2418:../uvc.c      **** 
2419:../uvc.c      ****     /* Set the UART configuration */
2420:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2421:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2422:../uvc.c      ****     {
2423:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2424:../uvc.c      ****     }
2425:../uvc.c      **** 
2426:../uvc.c      ****     /* Set the UART transfer */
2427:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2428:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2429:../uvc.c      ****     {
2430:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2431:../uvc.c      ****     }
2432:../uvc.c      **** 
2433:../uvc.c      ****     /* Initialize the Debug logger module. */
2434:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2435:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2436:../uvc.c      ****     {
2437:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2438:../uvc.c      ****     }
2439:../uvc.c      **** 
2440:../uvc.c      ****     /* Disable log message headers. */
2441:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2442:../uvc.c      **** }
2443:../uvc.c      **** 
2444:../uvc.c      **** /* I2C initialization. */
2445:../uvc.c      **** static void
2446:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2447:../uvc.c      **** {
2448:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2449:../uvc.c      ****     CyU3PReturnStatus_t status;
2450:../uvc.c      **** 
2451:../uvc.c      ****     status = CyU3PI2cInit ();
2452:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2453:../uvc.c      ****     {
2454:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2455:../uvc.c      ****         CyFxAppErrorHandler (status);
2456:../uvc.c      ****     }
2457:../uvc.c      **** 
2458:../uvc.c      ****     /*  Set I2C Configuration */
2459:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2460:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2461:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2462:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2463:../uvc.c      **** 
2464:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2465:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2466:../uvc.c      ****     {
2467:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2468:../uvc.c      ****         CyFxAppErrorHandler (status);
2469:../uvc.c      ****     }
2470:../uvc.c      **** }
2471:../uvc.c      **** 
2472:../uvc.c      **** #ifdef BACKFLOW_DETECT
2473:../uvc.c      **** static void CyFxUvcAppPibCallback (
2474:../uvc.c      ****         CyU3PPibIntrType cbType,
2475:../uvc.c      ****         uint16_t cbArg)
2476:../uvc.c      **** {
2477:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2478:../uvc.c      ****     {
2479:../uvc.c      ****         if (!back_flow_detected)
2480:../uvc.c      ****         {
2481:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2482:../uvc.c      ****             back_flow_detected = 1;
2483:../uvc.c      ****         }
2484:../uvc.c      ****     }
2485:../uvc.c      **** }
2486:../uvc.c      **** #endif
2487:../uvc.c      **** 
2488:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2489:../uvc.c      **** static void
2490:../uvc.c      **** CyFxUvcAppDebugCallback (
2491:../uvc.c      ****         CyU3PDmaChannel   *handle,
2492:../uvc.c      ****         CyU3PDmaCbType_t   type,
2493:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2494:../uvc.c      **** {
2495:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2496:../uvc.c      ****     {
2497:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2498:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2499:../uvc.c      ****     }
2500:../uvc.c      **** }
2501:../uvc.c      **** #endif
2502:../uvc.c      **** 
2503:../uvc.c      **** #if 0
2504:../uvc.c      **** static void CyFxAppIntEpCb(
2505:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2506:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2507:../uvc.c      **** 		uint8_t  ebNum)
2508:../uvc.c      **** 		{
2509:../uvc.c      **** 			//CyBool_t value;
2510:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2511:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2512:../uvc.c      **** 
2513:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2514:../uvc.c      **** 		}
2515:../uvc.c      **** #endif
2516:../uvc.c      **** 
2517:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2518:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2519:../uvc.c      ****    configures the DMA module for the UVC Application */
2520:../uvc.c      **** static void
2521:../uvc.c      **** CyFxUVCApplnInit (void)
2522:../uvc.c      **** {
2523:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2524:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2525:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2526:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2527:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2528:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2529:../uvc.c      **** 
2530:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2531:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2532:../uvc.c      **** 
2533:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2534:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2535:../uvc.c      **** #endif
2536:../uvc.c      **** 
2537:../uvc.c      ****     /* Create UVC event group */
2538:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2539:../uvc.c      ****     if (apiRetStatus != 0)
2540:../uvc.c      ****     {
2541:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2546:../uvc.c      ****     CyFxUvcAppPTZInit ();
2547:../uvc.c      **** #endif
2548:../uvc.c      **** 
2549:../uvc.c      ****     isUsbConnected = CyFalse;
2550:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2551:../uvc.c      **** 
2552:../uvc.c      ****     /* Init the GPIO module */
2553:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2554:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2555:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2556:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2557:../uvc.c      ****     gpioClock.halfDiv    = 0;
2558:../uvc.c      **** 
2559:../uvc.c      ****     /* Initialize Gpio interface */
2560:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2561:../uvc.c      ****     if (apiRetStatus != 0)
2562:../uvc.c      ****     {
2563:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2564:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2565:../uvc.c      ****     }
2566:../uvc.c      **** 
2567:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2568:../uvc.c      ****      * must use GpioOverride to configure it */
2569:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2570:../uvc.c      ****     if (apiRetStatus != 0)
2571:../uvc.c      ****     {
2572:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2573:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2574:../uvc.c      ****     }
2575:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2576:../uvc.c      ****     if (apiRetStatus != 0)
2577:../uvc.c      ****     {
2578:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2579:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2580:../uvc.c      ****     }
2581:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2582:../uvc.c      ****     if (apiRetStatus != 0)
2583:../uvc.c      ****     {
2584:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2585:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2586:../uvc.c      ****     }
2587:../uvc.c      **** 
2588:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2589:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2590:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2591:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2592:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2593:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2594:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2595:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2596:../uvc.c      ****     {
2597:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2598:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2599:../uvc.c      ****     }
2600:../uvc.c      **** 
2601:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2602:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2603:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2604:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2605:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2606:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2607:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2608:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2609:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2610:../uvc.c      ****     {
2611:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2612:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2613:../uvc.c      ****     }
2614:../uvc.c      **** 
2615:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2616:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2617:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2618:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2619:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2620:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2621:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2622:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2623:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2624:../uvc.c      ****     {
2625:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2626:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2627:../uvc.c      ****     }
2628:../uvc.c      **** 
2629:../uvc.c      ****     /* Initialize the P-port. */
2630:../uvc.c      ****     pibclock.clkDiv      = 2;
2631:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2632:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2633:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2634:../uvc.c      **** 
2635:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2636:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2637:../uvc.c      ****     {
2638:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2639:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2640:../uvc.c      ****     }
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2643:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2644:../uvc.c      **** 
2645:../uvc.c      **** #ifdef BACKFLOW_DETECT
2646:../uvc.c      ****     back_flow_detected = 0;
2647:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2648:../uvc.c      **** #endif
2649:../uvc.c      **** 
2650:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2651:../uvc.c      ****     SensorReset ();
2652:../uvc.c      ****     CyU3PThreadSleep(5000);
2653:../uvc.c      ****     //SensorInit ();
2654:../uvc.c      **** 
2655:../uvc.c      ****     /* USB initialization. */
2656:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2658:../uvc.c      ****     {
2659:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2660:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2661:../uvc.c      ****     }
2662:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2663:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2664:../uvc.c      **** 
2665:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2666:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2667:../uvc.c      **** 
2668:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2669:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2670:../uvc.c      **** 
2671:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2672:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2673:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2674:../uvc.c      **** 
2675:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2676:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2677:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2678:../uvc.c      **** 
2679:../uvc.c      ****     /* Configuration descriptors. */
2680:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2681:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2682:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2683:../uvc.c      **** 
2684:../uvc.c      ****     /* String Descriptors */
2685:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2686:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2687:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2688:../uvc.c      **** 
2689:../uvc.c      ****     /* Configure the status interrupt endpoint.
2690:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2691:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2692:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2693:../uvc.c      ****      */
2694:../uvc.c      ****     endPointConfig.enable   = 1;
2695:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2696:../uvc.c      ****     endPointConfig.pcktSize = 64;
2697:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2698:../uvc.c      ****     endPointConfig.streams  = 0;
2699:../uvc.c      ****     endPointConfig.burstLen = 1;
2700:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2701:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2702:../uvc.c      ****     {
2703:../uvc.c      ****         /* Error Handling */
2704:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2705:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2706:../uvc.c      ****     }
2707:../uvc.c      **** 
2708:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2709:../uvc.c      ****     dmaInterConfig.size           = 1024;
2710:../uvc.c      ****     dmaInterConfig.count          = 1;
2711:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2712:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2713:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2714:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2715:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2716:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2717:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2718:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2719:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2720:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2721:../uvc.c      ****             &dmaInterConfig);
2722:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2723:../uvc.c      ****     {
2724:../uvc.c      ****         /* Error handling */
2725:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2726:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2727:../uvc.c      ****     }
2728:../uvc.c      **** 
2729:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2730:../uvc.c      ****     if (glInterStaBuffer == 0)
2731:../uvc.c      ****     {
2732:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2733:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2734:../uvc.c      ****     }
2735:../uvc.c      **** 
2736:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2737:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2738:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2739:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2740:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2741:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2742:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2743:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2744:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2745:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2746:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2747:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2748:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2749:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2750:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2751:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2752:../uvc.c      ****             &dmaMultiConfig);
2753:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2754:../uvc.c      ****     {
2755:../uvc.c      ****         /* Error handling */
2756:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2757:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2758:../uvc.c      ****     }
2759:../uvc.c      **** 
2760:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2761:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2762:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2763:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2764:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2765:../uvc.c      ****      */
2766:../uvc.c      **** 
2767:../uvc.c      ****     endPointConfig.enable   = 1;
2768:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2769:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2770:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2771:../uvc.c      ****     endPointConfig.streams  = 0;
2772:../uvc.c      ****     endPointConfig.burstLen = 1;
2773:../uvc.c      **** 
2774:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2775:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2776:../uvc.c      ****     {
2777:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2778:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2779:../uvc.c      ****     }
2780:../uvc.c      **** 
2781:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2782:../uvc.c      **** 
2783:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2784:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2785:../uvc.c      ****     {
2786:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2787:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2788:../uvc.c      ****     }
2789:../uvc.c      **** 
2790:../uvc.c      ****     channelConfig.size           = 1024;
2791:../uvc.c      ****     channelConfig.count          = 1;
2792:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2793:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2794:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2795:../uvc.c      ****     channelConfig.prodHeader     = 0;
2796:../uvc.c      ****     channelConfig.prodFooter     = 0;
2797:../uvc.c      ****     channelConfig.consHeader     = 0;
2798:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2799:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2800:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2801:../uvc.c      **** 
2802:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2803:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2804:../uvc.c      ****     {
2805:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2806:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2807:../uvc.c      ****     }
2808:../uvc.c      **** 
2809:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2810:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2811:../uvc.c      ****     {
2812:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2813:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2814:../uvc.c      ****     }
2815:../uvc.c      **** 
2816:../uvc.c      ****     channelConfig.size           = 1024;
2817:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2818:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2819:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2820:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2821:../uvc.c      ****     channelConfig.prodHeader     = 0;
2822:../uvc.c      ****     channelConfig.prodFooter     = 0;
2823:../uvc.c      ****     channelConfig.consHeader     = 0;
2824:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2825:../uvc.c      ****     channelConfig.notification   = 0;
2826:../uvc.c      ****     channelConfig.cb             = 0;
2827:../uvc.c      **** 
2828:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2829:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2830:../uvc.c      ****     {
2831:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2832:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2833:../uvc.c      ****     }
2834:../uvc.c      **** 
2835:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2836:../uvc.c      ****     if (glDebugRspBuffer == 0)
2837:../uvc.c      ****     {
2838:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2839:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2840:../uvc.c      ****     }
2841:../uvc.c      **** #endif
2842:../uvc.c      **** 
2843:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2844:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2845:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2846:../uvc.c      ****     {
2847:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2848:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2849:../uvc.c      ****     }
2850:../uvc.c      **** 
2851:../uvc.c      ****     CyU3PBusyWait(100);
2852:../uvc.c      **** 
2853:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2854:../uvc.c      **** 
2855:../uvc.c      ****     endPointConfig.enable   = 1;
2856:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2857:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2858:../uvc.c      ****     {
2859:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2860:../uvc.c      ****     	endPointConfig.burstLen = 16;
2861:../uvc.c      ****     }
2862:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2863:../uvc.c      ****     {
2864:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2865:../uvc.c      ****     	endPointConfig.burstLen = 1;
2866:../uvc.c      ****     }
2867:../uvc.c      ****     endPointConfig.streams  = 0;
2868:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2870:../uvc.c      ****     {
2871:../uvc.c      ****         /* Error Handling */
2872:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2873:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2874:../uvc.c      ****     }
2875:../uvc.c      **** #if 0    //for still image method 3 using
2876:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2877:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2878:../uvc.c      ****     {
2879:../uvc.c      ****         /* Error Handling */
2880:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2881:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2882:../uvc.c      ****     }
2883:../uvc.c      **** #endif
2884:../uvc.c      **** 
2885:../uvc.c      **** }
2886:../uvc.c      **** 
2887:../uvc.c      **** /*
2888:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2889:../uvc.c      ****  * streaming session is started.
2890:../uvc.c      ****  */
2891:../uvc.c      **** static void
2892:../uvc.c      **** CyFxUvcAppGpifInit (
2893:../uvc.c      ****         void)
2894:../uvc.c      **** {
2895:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2896:../uvc.c      **** 
2897:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2898:../uvc.c      ****     {
2899:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2900:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2901:../uvc.c      ****     }
2902:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2903:../uvc.c      ****     {
2904:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2905:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2906:../uvc.c      ****     }
2907:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2908:../uvc.c      ****     {
2909:../uvc.c      ****         /* Error Handling */
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2911:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2912:../uvc.c      ****     }
2913:../uvc.c      **** 
2914:../uvc.c      ****     /* Start the state machine from the designated start state. */
2915:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2916:../uvc.c      ****     {
2917:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2918:../uvc.c      ****     }
2919:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2920:../uvc.c      ****     {
2921:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2922:../uvc.c      ****     }
2923:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2924:../uvc.c      ****     {
2925:../uvc.c      ****         /* Error Handling */
2926:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2928:../uvc.c      ****     }
2929:../uvc.c      **** }
2930:../uvc.c      **** 
2931:../uvc.c      **** /*
2932:../uvc.c      ****  * Entry function for the UVC Application Thread
2933:../uvc.c      ****  */
2934:../uvc.c      **** 
2935:../uvc.c      **** uint32_t posTick;
2936:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2937:../uvc.c      **** 
2938:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2939:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2940:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2941:../uvc.c      **** }
2942:../uvc.c      **** 
2943:../uvc.c      **** 
2944:../uvc.c      **** void
2945:../uvc.c      **** UVCAppThread_Entry (
2946:../uvc.c      ****         uint32_t input)
2947:../uvc.c      **** {
2948:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2949:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2950:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2951:../uvc.c      ****     uint8_t i = 0;
2952:../uvc.c      ****     uint32_t flag;
2953:../uvc.c      ****     uint32_t prinflag = 0;
2954:../uvc.c      **** static uint8_t IMcount = 0;
2955:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2956:../uvc.c      ****     uint32_t frameCnt = 0;
2957:../uvc.c      **** #endif
2958:../uvc.c      ****     /* Initialize the Uart Debug Module */
2959:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2960:../uvc.c      **** 
2961:../uvc.c      ****     /* Initialize the I2C interface */
2962:../uvc.c      **** 	while (i++ < 6){
2963:../uvc.c      **** 		CyU3PThreadSleep(500);
2964:../uvc.c      **** 	}
2965:../uvc.c      **** 
2966:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2967:../uvc.c      **** 
2968:../uvc.c      ****     /* Initialize the UVC Application */
2969:../uvc.c      ****     CyFxUVCApplnInit ();
2970:../uvc.c      ****     /*
2971:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2972:../uvc.c      **** 
2973:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2974:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2975:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2976:../uvc.c      **** 
2977:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2978:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2979:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2980:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2981:../uvc.c      **** 
2982:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2983:../uvc.c      ****        of handling the abort request.
2984:../uvc.c      ****      */
2985:../uvc.c      **** 
2986:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2987:../uvc.c      ****     //CyU3PThreadSleep(1000);
2988:../uvc.c      **** 
2989:../uvc.c      ****     for (;;)
2990:../uvc.c      ****     {
2991:../uvc.c      ****         /* Waiting for the Video Stream Event */
2992:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2993:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2994:../uvc.c      ****         {
2995:../uvc.c      **** #if 0 //test for new firmware no video bring up
2996:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2997:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2998:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2999:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3000:../uvc.c      ****             {
3001:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3002:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3003:../uvc.c      ****                 {
3004:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3005:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3006:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3007:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3008:../uvc.c      **** #endif
3009:../uvc.c      **** #endif
3010:../uvc.c      ****                     }
3011:../uvc.c      ****                 else
3012:../uvc.c      ****                 {
3013:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3014:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3015:../uvc.c      **** #ifdef USB_LOWRES_IMG
3016:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3017:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3018:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3019:../uvc.c      **** #endif
3020:../uvc.c      **** #endif
3021:../uvc.c      ****                 }
3022:../uvc.c      **** 
3023:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3024:../uvc.c      ****                 prodCount++;
3025:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3026:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3027:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3028:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3029:../uvc.c      ****                 {
3030:../uvc.c      ****                     prodCount--;
3031:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3032:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3033:../uvc.c      ****                 }
3034:../uvc.c      ****             }
3035:../uvc.c      **** #endif
3036:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3037:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3038:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3039:../uvc.c      ****             {
3040:../uvc.c      ****             	if(0&&(prinflag == 0)){
3041:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3042:../uvc.c      ****             		prinflag = 1;
3043:../uvc.c      ****             	}
3044:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3045:../uvc.c      ****             	fb=0;
3046:../uvc.c      ****             	pb=0;
3047:../uvc.c      ****             	pbc=0;
3048:../uvc.c      ****                 prodCount = 0;
3049:../uvc.c      ****                 consCount = 0;
3050:../uvc.c      ****                 hitFV     = CyFalse;
3051:../uvc.c      **** 
3052:../uvc.c      **** #ifdef BACKFLOW_DETECT
3053:../uvc.c      ****                 back_flow_detected = 0;
3054:../uvc.c      **** #endif
3055:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3056:../uvc.c      ****                 frameCnt++;
3057:../uvc.c      **** #endif
3058:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3059:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3060:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3061:../uvc.c      ****                 //}
3062:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3063:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3064:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3065:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3066:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3067:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3068:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3069:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3070:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3071:../uvc.c      ****                 		stiflag = 0xFF;
3072:../uvc.c      ****                 		IMcount = 0;
3073:../uvc.c      ****                 	}
3074:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3075:../uvc.c      **** 
3076:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3077:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3078:../uvc.c      ****                 		stiflag = 0x0F;
3079:../uvc.c      ****                 		IMcount = 0;
3080:../uvc.c      ****                 		}
3081:../uvc.c      ****                  		/*if(IMcount > 0x4){
3082:../uvc.c      ****                 			stiflag = 0x0F;
3083:../uvc.c      ****                 			IMcount = 0;
3084:../uvc.c      ****                 		}*/
3085:../uvc.c      **** 
3086:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3087:../uvc.c      ****                     //CyU3PThreadSleep(400);
3088:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3089:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3090:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3091:../uvc.c      **** 
3092:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3093:../uvc.c      ****                 	{
3094:../uvc.c      ****                     switch (setRes)
3095:../uvc.c      ****                      {
3096:../uvc.c      ****                  	case 1: //1944
3097:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3098:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3099:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3100:../uvc.c      ****                  		break;
3101:../uvc.c      ****                  	case 2: //1080
3102:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3103:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3104:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3105:../uvc.c      ****                  		break;
3106:../uvc.c      ****                  	case 3: //720
3107:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3108:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3109:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3110:../uvc.c      ****                  		break;
3111:../uvc.c      ****                  	case 4: //VGA
3112:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3113:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3114:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3115:../uvc.c      ****                  		break;
3116:../uvc.c      ****                  	default:
3117:../uvc.c      ****                  		break;
3118:../uvc.c      ****                      }
3119:../uvc.c      ****                     IMcount = 0;
3120:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3121:../uvc.c      ****                 	stiflag = 0x0;
3122:../uvc.c      ****                 	}
3123:../uvc.c      ****                 }
3124:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3125:../uvc.c      ****                 /* Reset the DMA channel. */
3126:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3127:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3128:../uvc.c      ****                 {
3129:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3130:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3131:../uvc.c      ****                 }
3132:../uvc.c      **** 
3133:../uvc.c      ****                 /* Start Channel Immediately */
3134:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3135:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3136:../uvc.c      ****                 {
3137:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3138:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3139:../uvc.c      ****                 }
3140:../uvc.c      **** 
3141:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3142:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3143:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3144:../uvc.c      ****                 }
3145:../uvc.c      ****         }
3146:../uvc.c      ****         else
3147:../uvc.c      ****         {
3148:../uvc.c      ****             /* If we have a stream abort request pending. */
3149:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3150:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3151:../uvc.c      ****             {
3152:../uvc.c      ****                 hitFV     = CyFalse;
3153:../uvc.c      ****                 prodCount = 0;
3154:../uvc.c      ****                 consCount = 0;
3155:../uvc.c      ****                 if(0&&(prinflag == 0)){
3156:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3157:../uvc.c      ****                 	prinflag = 1;
3158:../uvc.c      ****                 }
3159:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3160:../uvc.c      ****                 fb=0;
3161:../uvc.c      ****                 pb=0;
3162:../uvc.c      ****                 pbc=0;
3163:../uvc.c      **** 
3164:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3165:../uvc.c      ****                 {
3166:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3167:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3168:../uvc.c      ****                     {
3169:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3170:../uvc.c      ****                     }
3171:../uvc.c      **** 
3172:../uvc.c      ****                     /* Flush the Endpoint memory */
3173:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3174:../uvc.c      ****                 }
3175:../uvc.c      **** 
3176:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3177:../uvc.c      ****             }
3178:../uvc.c      ****             else
3179:../uvc.c      ****             {
3180:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3181:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3182:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3183:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3184:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3185:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3186:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3187:../uvc.c      ****                 {
3188:../uvc.c      ****                     /* Error handling */
3189:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3190:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3191:../uvc.c      ****                 }
3192:../uvc.c      **** 
3193:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3194:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3195:../uvc.c      ****                 {
3196:../uvc.c      **** #if 0
3197:../uvc.c      ****                 	//for start up of the AF Lens
3198:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3199:../uvc.c      ****                     CyU3PThreadSleep(500);
3200:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3201:../uvc.c      ****                     CyU3PThreadSleep(500);
3202:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3203:../uvc.c      ****                    	CyU3PThreadSleep(300);
3204:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3205:../uvc.c      ****                     CyU3PThreadSleep(500);
3206:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3207:../uvc.c      ****                     CyU3PThreadSleep(500);
3208:../uvc.c      **** #endif
3209:../uvc.c      **** #if 0
3210:../uvc.c      ****                     switch (setRes)
3211:../uvc.c      ****                     {
3212:../uvc.c      ****                     	case 1: //1944
3213:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3214:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3215:../uvc.c      ****                     		break;
3216:../uvc.c      ****                     	case 2: //1080
3217:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3218:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3219:../uvc.c      ****                     		break;
3220:../uvc.c      ****                     	case 3: //720
3221:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3222:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3223:../uvc.c      ****                     		break;
3224:../uvc.c      ****                     	default:
3225:../uvc.c      ****                     		break;
3226:../uvc.c      ****                     }
3227:../uvc.c      **** #endif
3228:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3229:../uvc.c      **** 
3230:../uvc.c      ****                     gpif_initialized = CyTrue;
3231:../uvc.c      ****                     CyU3PThreadSleep(200);
3232:../uvc.c      ****                     
3233:../uvc.c      ****                 }
3234:../uvc.c      ****                 else
3235:../uvc.c      ****                 {
3236:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3237:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3238:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3239:../uvc.c      ****                 }
3240:../uvc.c      ****             }
3241:../uvc.c      ****         }
3242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3243:../uvc.c      **** 
3244:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3245:../uvc.c      ****         CyU3PThreadRelinquish ();
3246:../uvc.c      ****     }
3247:../uvc.c      **** }
3248:../uvc.c      **** 
3249:../uvc.c      **** /*
3250:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3251:../uvc.c      ****  */
3252:../uvc.c      **** 
3253:../uvc.c      **** static void
3254:../uvc.c      **** UVCHandleProcessingUnitRqts (
3255:../uvc.c      ****         void)
3256:../uvc.c      **** {
3257:../uvc.c      ****     uint8_t CtrlAdd;
3258:../uvc.c      **** #ifdef DbgInfo
3259:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3260:../uvc.c      **** #endif
3261:../uvc.c      ****     switch (wValue)
3262:../uvc.c      ****     {
3263:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3264:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3265:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3266:../uvc.c      ****     		break;
3267:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3268:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3269:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3270:../uvc.c      ****     		break;
3271:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3272:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3273:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3274:../uvc.c      **** 			break;
3275:../uvc.c      **** 
3276:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3277:../uvc.c      **** 
3278:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3279:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3280:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3281:../uvc.c      ****       		break;
3282:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3283:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3284:../uvc.c      ****      		ControlHandle(HueCtlID5);
3285:../uvc.c      ****      		break;
3286:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3287:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3288:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3289:../uvc.c      ****           		break;
3290:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3291:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3292:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3293:../uvc.c      ****           		break;
3294:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3295:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3296:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3297:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3298:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3299:../uvc.c      ****     		break;
3300:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3301:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3302:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3303:../uvc.c      ****     		break;
3304:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3305:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3306:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3307:../uvc.c      ****     		break;
3308:../uvc.c      **** 
3309:../uvc.c      ****         default:
3310:../uvc.c      ****             /*
3311:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3312:../uvc.c      ****              * other controls.
3313:../uvc.c      ****              */
3314:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3315:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3316:../uvc.c      ****             break;
3317:../uvc.c      ****     }
3318:../uvc.c      **** }
3319:../uvc.c      **** 
3320:../uvc.c      **** /*
3321:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3322:../uvc.c      ****  */
3323:../uvc.c      **** static void
3324:../uvc.c      **** UVCHandleCameraTerminalRqts (
3325:../uvc.c      ****         void)
3326:../uvc.c      **** {
3327:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3328:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3329:../uvc.c      ****     uint16_t readCount;
3330:../uvc.c      ****     uint16_t zoomVal;
3331:../uvc.c      ****     int32_t  panVal, tiltVal;
3332:../uvc.c      ****     CyBool_t sendData = CyFalse;
3333:../uvc.c      **** #endif
3334:../uvc.c      ****     uint8_t CtrlAdd;
3335:../uvc.c      **** 
3336:../uvc.c      ****     switch (wValue)
3337:../uvc.c      ****     {
3338:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3339:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3340:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3341:../uvc.c      ****     		break;
3342:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3343:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3344:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3345:../uvc.c      ****     		break;
3346:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3347:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3348:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3349:../uvc.c      **** 			break;
3350:../uvc.c      **** 
3351:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3352:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3353:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3354:../uvc.c      **** 			break;
3355:../uvc.c      **** 
3356:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3357:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3358:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3359:../uvc.c      ****       		break;
3360:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3361:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3362:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3363:../uvc.c      ****      		break;
3364:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3365:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3366:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3367:../uvc.c      ****           		break;
3368:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3369:../uvc.c      ****           		break;
3370:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3371:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3372:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3373:../uvc.c      ****      		break;
3374:../uvc.c      **** 
3375:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3376:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3377:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3378:../uvc.c      ****     		break;
3379:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3380:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3381:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3382:../uvc.c      ****     		break;
3383:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3384:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3385:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3386:../uvc.c      ****     		break;
3387:../uvc.c      **** 
3388:../uvc.c      ****         default:
3389:../uvc.c      ****             /*
3390:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3391:../uvc.c      ****              * other controls.
3392:../uvc.c      ****              */
3393:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3394:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3395:../uvc.c      ****             break;
3396:../uvc.c      ****     }
3397:../uvc.c      **** 
3398:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3399:../uvc.c      ****     switch (wValue)
3400:../uvc.c      ****     {
3401:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3402:../uvc.c      ****             switch (bRequest)
3403:../uvc.c      ****             {
3404:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3405:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3406:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3407:../uvc.c      ****                     break;
3408:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3409:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3410:../uvc.c      ****                     sendData = CyTrue;
3411:../uvc.c      ****                     break;
3412:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3413:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3414:../uvc.c      ****                     sendData = CyTrue;
3415:../uvc.c      ****                     break;
3416:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3417:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3418:../uvc.c      ****                     sendData = CyTrue;
3419:../uvc.c      ****                     break;
3420:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3421:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3422:../uvc.c      ****                     sendData = CyTrue;
3423:../uvc.c      ****                     break;
3424:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3425:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3426:../uvc.c      ****                     sendData = CyTrue;
3427:../uvc.c      ****                     break;
3428:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3429:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3430:../uvc.c      ****                             glEp0Buffer, &readCount);
3431:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3432:../uvc.c      ****                     {
3433:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3434:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3435:../uvc.c      ****                     }
3436:../uvc.c      ****                     break;
3437:../uvc.c      ****                 default:
3438:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3439:../uvc.c      ****                     break;
3440:../uvc.c      ****             }
3441:../uvc.c      **** 
3442:../uvc.c      ****             if (sendData)
3443:../uvc.c      ****             {
3444:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3445:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3446:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3447:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3448:../uvc.c      ****             }
3449:../uvc.c      ****             break;
3450:../uvc.c      **** 
3451:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3452:../uvc.c      ****             switch (bRequest)
3453:../uvc.c      ****             {
3454:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3455:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3456:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3457:../uvc.c      ****                     break;
3458:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3459:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3460:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3461:../uvc.c      ****                     sendData = CyTrue;
3462:../uvc.c      ****                     break;
3463:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3464:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3465:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3466:../uvc.c      ****                     sendData = CyTrue;
3467:../uvc.c      ****                     break;
3468:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3469:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3470:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3471:../uvc.c      ****                     sendData = CyTrue;
3472:../uvc.c      ****                     break;
3473:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3474:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3475:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3476:../uvc.c      ****                     sendData = CyTrue;
3477:../uvc.c      ****                     break;
3478:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3479:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3480:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3481:../uvc.c      ****                     sendData = CyTrue;
3482:../uvc.c      ****                     break;
3483:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3484:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3485:../uvc.c      ****                             glEp0Buffer, &readCount);
3486:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3487:../uvc.c      ****                     {
3488:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3489:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3490:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3491:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3492:../uvc.c      **** 
3493:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3494:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3495:../uvc.c      ****                     }
3496:../uvc.c      ****                     break;
3497:../uvc.c      ****                 default:
3498:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3499:../uvc.c      ****                     break;
3500:../uvc.c      ****             }
3501:../uvc.c      **** 
3502:../uvc.c      ****             if (sendData)
3503:../uvc.c      ****             {
3504:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3505:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3506:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3507:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3508:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3509:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3510:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3511:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3512:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3513:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3514:../uvc.c      ****             }
3515:../uvc.c      ****             break;
3516:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3517:../uvc.c      ****         default:
3518:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3519:../uvc.c      ****             break;
3520:../uvc.c      ****     }
3521:../uvc.c      **** #endif
3522:../uvc.c      **** }
3523:../uvc.c      **** 
3524:../uvc.c      **** /*
3525:../uvc.c      ****  * Handler for UVC Interface control requests.
3526:../uvc.c      ****  */
3527:../uvc.c      **** static void
3528:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3529:../uvc.c      ****         void)
3530:../uvc.c      **** {
3531:../uvc.c      **** 
3532:../uvc.c      ****     switch (wValue)
3533:../uvc.c      ****     {
3534:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3535:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3536:../uvc.c      ****     		break;
3537:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3538:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3539:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3540:../uvc.c      ****     		break;
3541:../uvc.c      ****     	default:
3542:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3543:../uvc.c      ****      		break;
3544:../uvc.c      ****     }
3545:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3546:../uvc.c      **** 
3547:../uvc.c      **** }
3548:../uvc.c      **** 
3549:../uvc.c      **** /*
3550:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3551:../uvc.c      ****  */
3552:../uvc.c      **** static void
3553:../uvc.c      **** UVCHandleExtensionUnitRqts (
3554:../uvc.c      ****         void)
3555:../uvc.c      **** {
3556:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3557:../uvc.c      **** 
3558:../uvc.c      **** #ifdef DbgInfo
3559:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3560:../uvc.c      **** #endif
3561:../uvc.c      ****     switch (wValue)
3562:../uvc.c      ****     {
3563:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3564:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3565:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3566:../uvc.c      ****     		break;
3567:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3568:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3569:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3570:../uvc.c      ****     		break;
3571:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3572:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3573:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3574:../uvc.c      ****      		break;
3575:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3576:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3577:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3578:../uvc.c      ****     		break;
3579:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3580:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3581:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3582:../uvc.c      ****     		break;
3583:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3584:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3585:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3586:../uvc.c      ****      		break;
3587:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3588:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3589:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3590:../uvc.c      ****     		break;
3591:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3592:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3593:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3594:../uvc.c      ****     		break;
3595:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3596:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3597:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3598:../uvc.c      ****      		break;
3599:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3600:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3601:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3602:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3603:../uvc.c      ****     		}else/* no support for 1080p camera */
3604:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3605:../uvc.c      ****     		break;
3606:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3607:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3608:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3609:../uvc.c      ****     		break;
3610:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3611:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3612:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3613:../uvc.c      ****     		break;
3614:../uvc.c      **** 
3615:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3616:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3617:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3618:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3619:../uvc.c      ****     		break;
3620:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3621:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3622:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3623:../uvc.c      ****     		//break;
3624:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3625:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3626:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3627:../uvc.c      ****     		break;
3628:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3629:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3630:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3631:../uvc.c      ****     		break;
3632:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3633:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3634:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3635:../uvc.c      ****     		break;
3636:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3637:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3638:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3639:../uvc.c      ****     		break;
3640:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3641:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3642:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3643:../uvc.c      ****     		break;
3644:../uvc.c      ****    	default:
3645:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3646:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3647:../uvc.c      ****     		break;
3648:../uvc.c      ****     }
3649:../uvc.c      **** 
3650:../uvc.c      **** }
3651:../uvc.c      **** 
3652:../uvc.c      **** /*
3653:../uvc.c      ****  * Handler for the video streaming control requests.
3654:../uvc.c      ****  */
3655:../uvc.c      **** static void
3656:../uvc.c      **** UVCHandleVideoStreamingRqts (
3657:../uvc.c      ****         void)
3658:../uvc.c      **** {
3659:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3660:../uvc.c      ****     uint16_t readCount;
3661:../uvc.c      **** 
3662:../uvc.c      ****     switch (wValue)
3663:../uvc.c      ****     {
3664:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3665:../uvc.c      ****             switch (bRequest)
3666:../uvc.c      ****             {
3667:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3668:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3669:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3670:../uvc.c      ****                     break;
3671:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3672:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3673:../uvc.c      ****                     glEp0Buffer[1] = 0;
3674:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3675:../uvc.c      ****                     break;
3676:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3677:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3678:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3679:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3680:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3681:../uvc.c      ****                     {
3682:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3683:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3684:../uvc.c      **** 
3685:../uvc.c      ****                     }
3686:../uvc.c      ****                     else
3687:../uvc.c      ****                     {
3688:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3689:../uvc.c      ****                     }
3690:../uvc.c      ****                     break;
3691:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3692:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3693:../uvc.c      ****                             glCommitCtrl, &readCount);
3694:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3695:../uvc.c      ****                     {
3696:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3697:../uvc.c      ****                         {
3698:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3699:../uvc.c      ****                                active data structure. */
3700:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3701:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3702:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3703:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3704:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3705:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3706:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3707:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3708:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3709:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3710:../uvc.c      **** #if 0
3711:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3712:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3713:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3714:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3715:../uvc.c      **** #endif
3716:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3717:../uvc.c      ****                        }
3718:../uvc.c      ****                     }
3719:../uvc.c      ****                     break;
3720:../uvc.c      ****                 default:
3721:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3722:../uvc.c      ****                     break;
3723:../uvc.c      ****             }
3724:../uvc.c      ****             break;
3725:../uvc.c      **** 
3726:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3727:../uvc.c      ****             switch (bRequest)
3728:../uvc.c      ****             {
3729:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3730:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3731:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3732:../uvc.c      ****                     break;
3733:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3734:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3735:../uvc.c      ****                     glEp0Buffer[1] = 0;
3736:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3737:../uvc.c      ****                     break;
3738:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3739:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3740:../uvc.c      ****                     {
3741:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3742:../uvc.c      ****                     }
3743:../uvc.c      ****                     else
3744:../uvc.c      ****                     {
3745:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3746:../uvc.c      ****                     }
3747:../uvc.c      ****                     break;
3748:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3749:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3750:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3751:../uvc.c      ****                        */
3752:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3753:../uvc.c      ****                             glCommitCtrl, &readCount);
3754:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3755:../uvc.c      ****                     {
3756:../uvc.c      ****                         switch (glCommitCtrl[3])
3757:../uvc.c      ****                          {
3758:../uvc.c      ****                          	case 1: //1944
3759:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3760:../uvc.c      ****                          		CyU3PThreadSleep(500);
3761:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3762:../uvc.c      ****                          		break;
3763:../uvc.c      ****                          	case 2: //1080
3764:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3765:../uvc.c      ****                          		CyU3PThreadSleep(500);
3766:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3767:../uvc.c      ****                          		break;
3768:../uvc.c      ****                          	case 3: //720
3769:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3770:../uvc.c      ****                          		CyU3PThreadSleep(500);
3771:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3772:../uvc.c      ****                          		break;
3773:../uvc.c      ****                          	case 4: //VGA
3774:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3775:../uvc.c      ****                          		CyU3PThreadSleep(500);
3776:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3777:../uvc.c      ****                          		break;
3778:../uvc.c      ****                          	default:
3779:../uvc.c      ****                          		break;
3780:../uvc.c      ****                          }
3781:../uvc.c      ****                         setRes = glCommitCtrl[3];
3782:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3783:../uvc.c      **** 
3784:../uvc.c      **** #if 0
3785:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3786:../uvc.c      ****                         {
3787:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3788:../uvc.c      ****                         }
3789:../uvc.c      ****                         else
3790:../uvc.c      ****                         {
3791:../uvc.c      ****                             SensorScaling_VGA ();
3792:../uvc.c      ****                         }
3793:../uvc.c      **** #endif
3794:../uvc.c      ****                         /* We can start streaming video now. */
3795:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3796:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3797:../uvc.c      ****                         {
3798:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3799:../uvc.c      ****                         }
3800:../uvc.c      ****                     }
3801:../uvc.c      ****                     break;
3802:../uvc.c      **** 
3803:../uvc.c      ****                 default:
3804:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3805:../uvc.c      ****                     break;
3806:../uvc.c      ****             }
3807:../uvc.c      ****             break;
3808:../uvc.c      **** 
3809:../uvc.c      **** /* still image streaming handler */
3810:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3811:../uvc.c      ****                 switch (bRequest)
3812:../uvc.c      ****                 {
3813:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3814:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3815:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3816:../uvc.c      ****                         break;
3817:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3818:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3819:../uvc.c      ****                         glEp0Buffer[1] = 0;
3820:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3821:../uvc.c      ****                         break;
3822:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3823:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3824:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3825:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3826:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3827:../uvc.c      ****                         {
3828:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3829:../uvc.c      ****                         }
3830:../uvc.c      ****                         else
3831:../uvc.c      ****                         {
3832:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3833:../uvc.c      ****                         }
3834:../uvc.c      ****                         break;
3835:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3836:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3837:../uvc.c      ****                                 glCommitCtrl, &readCount);
3838:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3839:../uvc.c      ****                         {
3840:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3841:../uvc.c      ****                             {
3842:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3843:../uvc.c      ****                                    active data structure. */
3844:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3845:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3846:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3847:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3848:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3849:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3850:../uvc.c      ****                             }
3851:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3852:../uvc.c      ****                         }
3853:../uvc.c      ****                         break;
3854:../uvc.c      ****                     default:
3855:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3856:../uvc.c      ****                         break;
3857:../uvc.c      ****                 }
3858:../uvc.c      ****                 break;
3859:../uvc.c      **** 
3860:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3861:../uvc.c      ****                 switch (bRequest)
3862:../uvc.c      ****                 {
3863:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3864:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3865:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3866:../uvc.c      ****                         break;
3867:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3868:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3869:../uvc.c      ****                         glEp0Buffer[1] = 0;
3870:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3871:../uvc.c      ****                         break;
3872:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3873:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3874:../uvc.c      ****                         {
3875:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3876:../uvc.c      ****                         }
3877:../uvc.c      ****                         else
3878:../uvc.c      ****                         {
3879:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3880:../uvc.c      ****                         }
3881:../uvc.c      ****                         break;
3882:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3883:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3884:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3885:../uvc.c      ****                            */
3886:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3887:../uvc.c      ****                                 glCommitCtrl, &readCount);
3888:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3889:../uvc.c      ****                         {
3890:../uvc.c      ****     #if 0
3891:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3892:../uvc.c      ****                             {
3893:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3894:../uvc.c      ****                             }
3895:../uvc.c      ****                             else
3896:../uvc.c      ****                             {
3897:../uvc.c      ****                                 SensorScaling_VGA ();
3898:../uvc.c      ****                             }
3899:../uvc.c      ****                             /* We can start streaming video now. */
3900:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3901:../uvc.c      **** 
3902:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3903:../uvc.c      ****                             {
3904:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3905:../uvc.c      ****                             }
3906:../uvc.c      **** 	#endif
3907:../uvc.c      ****                            switch (glCommitCtrl[1])
3908:../uvc.c      ****                              {
3909:../uvc.c      ****                              	case 4: //1944
3910:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3911:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3912:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3913:../uvc.c      ****                              		break;
3914:../uvc.c      ****                              	case 3: //1080
3915:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3916:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3917:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3918:../uvc.c      ****                              		break;
3919:../uvc.c      ****                              	case 2: //720
3920:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3921:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3922:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3923:../uvc.c      ****                              		break;
3924:../uvc.c      ****                             	case 1: //VGA
3925:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3926:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3927:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3928:../uvc.c      ****                              		break;
3929:../uvc.c      ****                               	default:
3930:../uvc.c      ****                              		break;
3931:../uvc.c      ****                              }
3932:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3933:../uvc.c      **** 
3934:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3935:../uvc.c      **** 
3936:../uvc.c      ****                         }
3937:../uvc.c      ****                         break;
3938:../uvc.c      **** 
3939:../uvc.c      ****                     default:
3940:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3941:../uvc.c      ****                         break;
3942:../uvc.c      ****                 }
3943:../uvc.c      ****                 break;
3944:../uvc.c      **** 
3945:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3946:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3947:../uvc.c      ****             	switch (bRequest)
3948:../uvc.c      ****                 {
3949:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3950:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3951:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3952:../uvc.c      ****                         break;
3953:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3954:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3955:../uvc.c      ****                         glEp0Buffer[1] = 0;
3956:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3957:../uvc.c      ****                         break;
3958:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3959:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3960:../uvc.c      ****                         {
3961:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3962:../uvc.c      ****                         }
3963:../uvc.c      ****                         else
3964:../uvc.c      ****                         {
3965:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3966:../uvc.c      ****                         }
3967:../uvc.c      ****                         break;
3968:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3969:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3970:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3971:../uvc.c      ****                            */
3972:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3973:../uvc.c      ****                                 glCommitCtrl, &readCount);
3974:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3975:../uvc.c      ****                         {
3976:../uvc.c      ****     #if 1
3977:../uvc.c      ****                             /* We can start still streaming video now. */
3978:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3979:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3980:../uvc.c      ****                             {
3981:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3982:../uvc.c      ****                             }
3983:../uvc.c      ****     #endif
3984:../uvc.c      ****                             else{
3985:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3986:../uvc.c      ****                             //stillcont = 0;
3987:../uvc.c      ****                             }
3988:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3989:../uvc.c      ****                         }else{
3990:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3991:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3992:../uvc.c      ****                         }
3993:../uvc.c      ****                         break;
3994:../uvc.c      **** 
3995:../uvc.c      ****                     default:
3996:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3997:../uvc.c      ****                         break;
3998:../uvc.c      ****                 }
3999:../uvc.c      ****                 break;
4000:../uvc.c      **** 
4001:../uvc.c      ****         default:
4002:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4003:../uvc.c      ****             break;
4004:../uvc.c      ****     }
4005:../uvc.c      **** }
4006:../uvc.c      **** 
4007:../uvc.c      **** /*
4008:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4009:../uvc.c      ****  */
4010:../uvc.c      **** void
4011:../uvc.c      **** UVCAppEP0Thread_Entry (
4012:../uvc.c      ****         uint32_t input)
4013:../uvc.c      **** {
4014:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4015:../uvc.c      ****     uint32_t eventFlag;
4016:../uvc.c      **** 	CyBool_t value;
4017:../uvc.c      **** 	CyBool_t *valueptr = &value;
4018:../uvc.c      **** 
4019:../uvc.c      **** 
4020:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4021:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4022:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4023:../uvc.c      **** 
4024:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4025:../uvc.c      **** #endif
4026:../uvc.c      **** 
4027:../uvc.c      ****     /* for interrupt status test */
4028:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4029:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4030:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4031:../uvc.c      **** 
4032:../uvc.c      ****     for (;;)
4033:../uvc.c      ****     {
4034:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4035:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4036:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4037:../uvc.c      ****         {
4038:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4039:../uvc.c      ****             if (!isUsbConnected)
4040:../uvc.c      ****             {
4041:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4042:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4043:../uvc.c      ****                 {
4044:../uvc.c      ****                     isUsbConnected = CyTrue;
4045:../uvc.c      ****                 }
4046:../uvc.c      ****             }
4047:../uvc.c      **** //#ifdef DbgInfo
4048:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4049:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4050:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4051:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4052:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4053:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4054:../uvc.c      **** //#endif
4055:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4056:../uvc.c      ****             {
4057:../uvc.c      ****             	switch ((wIndex >> 8))
4058:../uvc.c      ****                 {
4059:../uvc.c      **** 
4060:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4061:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4062:../uvc.c      ****                         break;
4063:../uvc.c      **** 
4064:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4065:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4066:../uvc.c      ****                         break;
4067:../uvc.c      **** 
4068:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4069:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4070:../uvc.c      ****                         break;
4071:../uvc.c      **** 
4072:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4073:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4074:../uvc.c      ****                         break;
4075:../uvc.c      **** 
4076:../uvc.c      ****                     default:
4077:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4078:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4079:../uvc.c      ****                         break;
4080:../uvc.c      ****                 }
4081:../uvc.c      ****             }
4082:../uvc.c      **** 
4083:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4084:../uvc.c      ****             {
4085:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4086:../uvc.c      **** 
4087:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4088:../uvc.c      ****                 {
4089:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4090:../uvc.c      ****                 }
4091:../uvc.c      ****                 else
4092:../uvc.c      ****                 {
4093:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4094:../uvc.c      ****                 }
4095:../uvc.c      ****             }
4096:../uvc.c      **** 
4097:../uvc.c      ****             /* handle interrupt status event */
4098:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4099:../uvc.c      ****             {
4100:../uvc.c      **** 
4101:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4102:../uvc.c      ****             	/** preparing interrupt status data **/
4103:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4104:../uvc.c      **** 
4105:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4106:../uvc.c      **** 
4107:../uvc.c      **** #if 0 //for real button
4108:../uvc.c      **** 				if(value&&(!snapButFlag)){
4109:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4110:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4111:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4112:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4113:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4114:../uvc.c      **** 
4115:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4116:../uvc.c      **** 					interStabuf.size   = 1024;
4117:../uvc.c      **** 					interStabuf.status = 0;
4118:../uvc.c      **** 
4119:../uvc.c      **** 					interStabuf.count = 4;
4120:../uvc.c      **** 
4121:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4122:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4123:../uvc.c      **** 
4124:../uvc.c      **** 					/** send a interrupt status data **/
4125:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4126:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4127:../uvc.c      **** 					{
4128:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4129:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4130:../uvc.c      **** 					}
4131:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4132:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4133:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4134:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4135:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4136:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4137:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4138:../uvc.c      **** 
4139:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4140:../uvc.c      **** 					interStabuf.size   = 1024;
4141:../uvc.c      **** 					interStabuf.status = 0;
4142:../uvc.c      **** 
4143:../uvc.c      **** 					interStabuf.count = 4;
4144:../uvc.c      **** 
4145:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4146:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4147:../uvc.c      **** 
4148:../uvc.c      **** 					/** send a interrupt status data **/
4149:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4150:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4151:../uvc.c      **** 					{
4152:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4153:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4154:../uvc.c      **** 					}
4155:../uvc.c      **** 
4156:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4157:../uvc.c      **** 					stiflag = 0xFF;
4158:../uvc.c      **** 				}
4159:../uvc.c      **** #else			//for botton simulation
4160:../uvc.c      **** 				if(snapButFlag == 0x0f){
4161:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4162:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4163:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4164:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4165:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4166:../uvc.c      **** 
4167:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4168:../uvc.c      **** 					interStabuf.size   = 1024;
4169:../uvc.c      **** 					interStabuf.status = 0;
4170:../uvc.c      **** 
4171:../uvc.c      **** 					interStabuf.count = 4;
4172:../uvc.c      **** 
4173:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4174:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4175:../uvc.c      **** 
4176:../uvc.c      **** 					/** send a interrupt status data **/
4177:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4178:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4179:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4180:../uvc.c      **** 					{
4181:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4182:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4183:../uvc.c      **** 					}
4184:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4185:../uvc.c      **** 
4186:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4187:../uvc.c      **** 				}else if(!snapButFlag){
4188:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4192:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4193:../uvc.c      **** 
4194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4195:../uvc.c      **** 					interStabuf.size   = 1024;
4196:../uvc.c      **** 					interStabuf.status = 0;
4197:../uvc.c      **** 
4198:../uvc.c      **** 					interStabuf.count = 4;
4199:../uvc.c      **** 
4200:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4202:../uvc.c      **** 
4203:../uvc.c      **** 					/** send a interrupt status data **/
4204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4205:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4206:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4207:../uvc.c      **** 					{
4208:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4209:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4210:../uvc.c      **** 					}
4211:../uvc.c      **** 
4212:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4213:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4214:../uvc.c      **** 				}
4215:../uvc.c      **** #endif
4216:../uvc.c      **** 
4217:../uvc.c      ****             }
4218:../uvc.c      **** 
4219:../uvc.c      **** 
4220:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4221:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4222:../uvc.c      ****             {
4223:../uvc.c      ****                 /* Get the command buffer */
4224:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4225:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4226:../uvc.c      ****                 {
4227:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4228:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4229:../uvc.c      ****                 }
4230:../uvc.c      **** 
4231:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4232:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4233:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4234:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4235:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4236:../uvc.c      ****                  * register value high byte and register value low byte.
4237:../uvc.c      ****                  */
4238:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4239:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4240:../uvc.c      ****                 {
4241:../uvc.c      ****                     if (dmaInfo.count == 3)
4242:../uvc.c      ****                     {
4243:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4244:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4245:../uvc.c      ****                         dmaInfo.count = 3;
4246:../uvc.c      ****                     }
4247:../uvc.c      ****                     else if (dmaInfo.count == 4)
4248:../uvc.c      ****                     {
4249:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4250:../uvc.c      ****                         {
4251:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4252:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4253:../uvc.c      ****                         }
4254:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4255:../uvc.c      ****                     }
4256:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4257:../uvc.c      ****                 }
4258:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4259:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4260:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4261:../uvc.c      ****                  */
4262:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4263:../uvc.c      ****                 {
4264:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4265:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4266:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4267:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4268:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4269:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4270:../uvc.c      ****                         	break;
4271:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4272:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4273:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4274:../uvc.c      ****                         	break;*/
4275:../uvc.c      ****                     dmaInfo.count -= 2;
4276:../uvc.c      ****                 }
4277:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4278:../uvc.c      ****                 else
4279:../uvc.c      ****                 {
4280:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4281:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4282:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4283:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4284:../uvc.c      ****                 }
4285:../uvc.c      **** 
4286:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4287:../uvc.c      ****                 dmaInfo.size   = 1024;
4288:../uvc.c      ****                 dmaInfo.status = 0;
4289:../uvc.c      **** 
4290:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4291:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4292:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4293:../uvc.c      ****                 {
4294:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4295:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4296:../uvc.c      ****                 }
4297:../uvc.c      **** 
4298:../uvc.c      ****                 /* Wait until the response has gone out. */
4299:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4300:../uvc.c      **** 
4301:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4302:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4303:../uvc.c      ****                 {
4304:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4305:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4306:../uvc.c      ****                 }
4307:../uvc.c      ****             }
4308:../uvc.c      **** #endif
4309:../uvc.c      ****         }
4310:../uvc.c      ****         /* Allow other ready threads to run. */
4311:../uvc.c      ****         CyU3PThreadRelinquish ();
4312:../uvc.c      ****     }
4313:../uvc.c      **** }
4314:../uvc.c      **** 
4315:../uvc.c      **** /*
4316:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4317:../uvc.c      ****  * added 10/2013
4318:../uvc.c      ****  */
4319:../uvc.c      **** /*
4320:../uvc.c      **** static uint8_t timeDelay[64] = {
4321:../uvc.c      **** 
4322:../uvc.c      **** };
4323:../uvc.c      **** */
4324:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4324 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4325:../uvc.c      **** 
4326:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4327:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4328:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4329:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4330:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4331:../uvc.c      **** 	uint32_t flag = 0;
4332:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4333:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4334:../uvc.c      **** 	uint8_t i;
4335:../uvc.c      **** 	uint16_t delaytime;
4336:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4337:../uvc.c      **** 
4338:../uvc.c      **** #if 0 //for test the command queue
4339:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4340:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4341:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4342:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4343:../uvc.c      **** 		lcCmdDes += 1;
4344:../uvc.c      **** 	}
4345:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4346:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4347:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4348:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4349:../uvc.c      **** 		lcCmdDes += 1;
4350:../uvc.c      **** 	}
4351:../uvc.c      **** 
4352:../uvc.c      **** #endif
4353:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4354:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4354 0
  36 0004 30229FE5 		ldr	r2, .L25
4331:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4331 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4324:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4324 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4354 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 18029FE5 		ldr	r0, .L25+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4331:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4331 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4354 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4355:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4355 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 FC119FE5 		ldr	r1, .L25+8
  71 0044 FC519FE5 		ldr	r5, .L25+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4356:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4356 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4357:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4357 0
  79 005c DC019FE5 		ldr	r0, .L25+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4358:../uvc.c      **** 
4359:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4359 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4360:../uvc.c      ****         /* Allow other ready threads to run. */
4361:../uvc.c      **** 
4362:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4362 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4359:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4359 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4363:../uvc.c      **** 	}
4364:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4364 0
  92 0078 C8019FE5 		ldr	r0, .L25+12
  93 007c C8119FE5 		ldr	r1, .L25+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 B8619FE5 		ldr	r6, .L25+20
  99 0094 B8B19FE5 		ldr	fp, .L25+24
4365:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4366:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4367:../uvc.c      **** 	//CyU3PThreadSleep(100);
4368:../uvc.c      **** 	//SetCurCmd();
4369:../uvc.c      **** 	/*********** the loop of the thread ***********/
4370:../uvc.c      **** 	for(;;){
4371:../uvc.c      **** 
4372:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4372 0
 101 0098 0070E0E3 		mvn	r7, #0
4373:../uvc.c      **** /*  // for test GPIO output
4374:../uvc.c      **** 		if(trigger)
4375:../uvc.c      **** 		{
4376:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4377:../uvc.c      **** 			{
4378:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4379:../uvc.c      **** 			}
4380:../uvc.c      **** 
4381:../uvc.c      **** 		}else{
4382:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4383:../uvc.c      **** 			{
4384:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4385:../uvc.c      **** 			}
4386:../uvc.c      **** 
4387:../uvc.c      **** 		}
4388:../uvc.c      **** */
4389:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4390:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4391:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4392:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4393:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4394:../uvc.c      **** 				i = 0;
4395:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4395 0
 103 009c 0090A0E3 		mov	r9, #0
4396:../uvc.c      **** 					i++;
4397:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4398:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4399:../uvc.c      **** 				}
4400:../uvc.c      **** #if 0
4401:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4402:../uvc.c      **** 				i = lcStaDes->curNum;
4403:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4404:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4405:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4406:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4407:../uvc.c      **** 
4408:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4409:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4410:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4411:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4412:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4413:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4414:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4415:../uvc.c      **** #endif
4416:../uvc.c      **** 				//}
4417:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4418:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4419:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4420:../uvc.c      **** 				/* setting delay */
4421:../uvc.c      **** 				delaytime = 300;
4422:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4423:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4424:../uvc.c      **** 			} //end of the if condition statment
4425:../uvc.c      **** #endif
4426:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4427:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4428:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4429:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4430:../uvc.c      **** 
4431:../uvc.c      **** 				/*
4432:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4433:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4434:../uvc.c      **** 				*/
4435:../uvc.c      **** 
4436:../uvc.c      **** 				/* find a available command */
4437:../uvc.c      **** 				i = 0;
4438:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4439:../uvc.c      **** 					i++;
4440:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4441:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4442:../uvc.c      **** 				}
4443:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4444:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4445:../uvc.c      **** 					i = lcCmdDes->curNum;
4446:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4447:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4448:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4449:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4450:../uvc.c      **** #if 1
4451:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4452:../uvc.c      **** 						case 0x20:
4453:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4454:../uvc.c      **** 							delaytime = 500;
4455:../uvc.c      **** 							break;
4456:../uvc.c      **** 						case 0x21:
4457:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4458:../uvc.c      **** 							delaytime = 500;
4459:../uvc.c      **** 							break;
4460:../uvc.c      **** 						case 0x22:
4461:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4462:../uvc.c      **** 							delaytime = 300;
4463:../uvc.c      **** 							break;
4464:../uvc.c      **** 						case 0x23:
4465:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4466:../uvc.c      **** 							delaytime = 300;
4467:../uvc.c      **** 							break;
4468:../uvc.c      **** 						default:
4469:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4470:../uvc.c      **** 							break;
4471:../uvc.c      **** 					}
4472:../uvc.c      **** #endif
4473:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4474:../uvc.c      **** 					/** timer's ticket modify **/
4475:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4476:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4477:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4478:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4479:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4480:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4481:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4482:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4483:../uvc.c      **** #endif
4484:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4485:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4486:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4487:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4488:../uvc.c      **** 						}else{
4489:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4490:../uvc.c      **** 						}
4491:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4492:../uvc.c      **** 					}else{
4493:../uvc.c      **** 						lcCmdDes->curNum ++;
4494:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4494 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L20:
4372:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4372 0
 108 00a4 14308DE2 		add	r3, sp, #20
 109 00a8 2010A0E3 		mov	r1, #32
 110 00ac 0320A0E3 		mov	r2, #3
 111 00b0 A0019FE5 		ldr	r0, .L25+28
 112 00b4 00708DE5 		str	r7, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4389:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4389 0
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 1C0096E5 		ldr	r0, [r6, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4395:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 119              		.loc 1 4395 0
 120 00c8 101096E5 		ldr	r1, [r6, #16]
 121 00cc 3C3091E5 		ldr	r3, [r1, #60]
 122 00d0 000053E3 		cmp	r3, #0
 123 00d4 0300001A 		bne	.L4
 124              	.LVL4:
 125              	.L5:
4396:../uvc.c      **** 					i++;
 126              		.loc 1 4396 0
 127 00d8 012083E2 		add	r2, r3, #1
 128 00dc FF3002E2 		and	r3, r2, #255
 129              	.LVL5:
4395:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4395 0
 131 00e0 3F0053E3 		cmp	r3, #63
 132 00e4 FBFFFF9A 		bls	.L5
 133              	.LVL6:
 134              	.L4:
4426:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 135              		.loc 1 4426 0
 136 00e8 1C0096E5 		ldr	r0, [r6, #28]
 137 00ec FEFFFFEB 		bl	_txe_mutex_put
 138              	.LVL7:
4428:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 139              		.loc 1 4428 0
 140 00f0 1C0095E5 		ldr	r0, [r5, #28]
 141 00f4 0010E0E3 		mvn	r1, #0
 142 00f8 FEFFFFEB 		bl	_txe_mutex_get
4429:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 143              		.loc 1 4429 0
 144 00fc 104095E5 		ldr	r4, [r5, #16]
 145              	.LVL8:
4438:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 146              		.loc 1 4438 0
 147 0100 3C2094E5 		ldr	r2, [r4, #60]
 148 0104 000052E3 		cmp	r2, #0
 149 0108 0800001A 		bne	.L6
 150 010c 0030A0E3 		mov	r3, #0
 151              	.LVL9:
 152              	.L7:
4440:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 153              		.loc 1 4440 0
 154 0110 344094E5 		ldr	r4, [r4, #52]
 155              	.LVL10:
4439:../uvc.c      **** 					i++;
 156              		.loc 1 4439 0
 157 0114 01A083E2 		add	sl, r3, #1
4438:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 158              		.loc 1 4438 0
 159 0118 3C2094E5 		ldr	r2, [r4, #60]
4439:../uvc.c      **** 					i++;
 160              		.loc 1 4439 0
 161 011c FF300AE2 		and	r3, sl, #255
 162              	.LVL11:
4438:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 163              		.loc 1 4438 0
 164 0120 3F0053E3 		cmp	r3, #63
 165 0124 00005293 		cmpls	r2, #0
 166 0128 F8FFFF0A 		beq	.L7
 167 012c 104085E5 		str	r4, [r5, #16]
 168              	.LVL12:
 169              	.L6:
4444:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 170              		.loc 1 4444 0
 171 0130 000052E3 		cmp	r2, #0
 172 0134 2D00000A 		beq	.L8
 173              	.LVL13:
4446:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 174              		.loc 1 4446 0
 175 0138 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
4451:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 176              		.loc 1 4451 0
 177 013c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4446:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 178              		.loc 1 4446 0
 179 0140 813081E0 		add	r3, r1, r1, asl #1
 180 0144 83E084E0 		add	lr, r4, r3, asl #1
4451:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 181              		.loc 1 4451 0
 182 0148 20C040E2 		sub	ip, r0, #32
4447:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 183              		.loc 1 4447 0
 184 014c 0510DEE5 		ldrb	r1, [lr, #5]	@ zero_extendqisi2
4446:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 185              		.loc 1 4446 0
 186 0150 0400DEE5 		ldrb	r0, [lr, #4]	@ zero_extendqisi2
 187              	.LVL14:
4448:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 188              		.loc 1 4448 0
 189 0154 0620DEE5 		ldrb	r2, [lr, #6]	@ zero_extendqisi2
 190              	.LVL15:
4449:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 191              		.loc 1 4449 0
 192 0158 B8A0DEE1 		ldrh	sl, [lr, #8]
 193              	.LVL16:
4451:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 194              		.loc 1 4451 0
 195 015c 03005CE3 		cmp	ip, #3
 196 0160 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 197 0164 1A0000EA 		b	.L9
 198              	.L14:
 199 0168 E0010000 		.word	.L10
 200 016c C4010000 		.word	.L11
 201 0170 78010000 		.word	.L13
 202 0174 78010000 		.word	.L13
 203              	.LVL17:
 204              	.L13:
4465:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 205              		.loc 1 4465 0
 206 0178 8230A0E3 		mov	r3, #130
 207 017c FEFFFFEB 		bl	SensorSetIrisControl
 208              	.LVL18:
4467:../uvc.c      **** 							break;
 209              		.loc 1 4467 0
 210 0180 4B1FA0E3 		mov	r1, #300
 211              	.LVL19:
 212              	.L15:
4476:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 213              		.loc 1 4476 0
 214 0184 0020A0E3 		mov	r2, #0
 215 0188 B0009FE5 		ldr	r0, .L25+4
 216 018c FEFFFFEB 		bl	_txe_timer_change
4477:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 217              		.loc 1 4477 0
 218 0190 A8009FE5 		ldr	r0, .L25+4
 219 0194 FEFFFFEB 		bl	_txe_timer_activate
 220              	.LVL20:
4484:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 221              		.loc 1 4484 0
 222 0198 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 223 019c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 224 01a0 0A0052E1 		cmp	r2, sl
4493:../uvc.c      **** 						lcCmdDes->curNum ++;
 225              		.loc 1 4493 0
 226 01a4 01A08A12 		addne	sl, sl, #1
 227 01a8 01A0C415 		strneb	sl, [r4, #1]
 228              		.loc 1 4494 0
 229 01ac 3C808415 		strne	r8, [r4, #60]
4484:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 230              		.loc 1 4484 0
 231 01b0 1400000A 		beq	.L24
 232              	.LVL21:
 233              	.L19:
4495:../uvc.c      **** 					}
4496:../uvc.c      **** 				}else{
4497:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4498:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4499:../uvc.c      **** 				}
4500:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 234              		.loc 1 4500 0
 235 01b4 1C0095E5 		ldr	r0, [r5, #28]
 236 01b8 FEFFFFEB 		bl	_txe_mutex_put
 237              	.LVL22:
4501:../uvc.c      **** 			}
4502:../uvc.c      **** /*
4503:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4504:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4505:../uvc.c      **** */
4506:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4507:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4508:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4509:../uvc.c      **** #endif
4510:../uvc.c      **** 
4511:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4512:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4513:../uvc.c      **** #if 0
4514:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4515:../uvc.c      **** 
4516:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4517:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4518:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4519:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4520:../uvc.c      **** 			    i = 0;
4521:../uvc.c      **** 				 switch(cmdCopyIdx)
4522:../uvc.c      **** 				 {
4523:../uvc.c      **** 					 case BrgtCtlID1:
4524:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4525:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4526:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4527:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4528:../uvc.c      **** 							 i++;
4529:../uvc.c      **** 						 }
4530:../uvc.c      **** 						 else{
4531:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4532:../uvc.c      **** 						 }
4533:../uvc.c      **** 
4534:../uvc.c      **** 						 CyU3PBusyWait(500);
4535:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4536:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4537:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4538:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4539:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4540:../uvc.c      **** 						 }
4541:../uvc.c      **** 						 else{
4542:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4543:../uvc.c      **** 						 }
4544:../uvc.c      **** 						 break;
4545:../uvc.c      **** 					 case HueCtlID5:
4546:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4547:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4548:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4549:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4550:../uvc.c      **** 						 }
4551:../uvc.c      **** 						 else{
4552:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4553:../uvc.c      **** 						 }
4554:../uvc.c      **** 						 break;
4555:../uvc.c      **** 					 case SaturCtlID6:
4556:../uvc.c      **** 					 case WBTLevCtlID10:
4557:../uvc.c      **** 					 default:
4558:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4559:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4560:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4561:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4562:../uvc.c      **** 						 }
4563:../uvc.c      **** 						 else{
4564:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4565:../uvc.c      **** 						 }
4566:../uvc.c      **** 						 break;
4567:../uvc.c      **** 				 }
4568:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4569:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4570:../uvc.c      **** 			}
4571:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4572:../uvc.c      **** #endif
4573:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4574:../uvc.c      **** 		/* Allow other ready threads to run. */
4575:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4576:../uvc.c      **** 			CyU3PThreadRelinquish ();
 238              		.loc 1 4576 0
 239 01bc FEFFFFEB 		bl	_txe_thread_relinquish
4577:../uvc.c      **** 		}
 240              		.loc 1 4577 0
 241 01c0 B7FFFFEA 		b	.L20
 242              	.LVL23:
 243              	.L11:
4457:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 244              		.loc 1 4457 0
 245 01c4 5230A0E3 		mov	r3, #82
 246 01c8 FEFFFFEB 		bl	SensorSetIrisControl
 247              	.LVL24:
4459:../uvc.c      **** 							break;
 248              		.loc 1 4459 0
 249 01cc 7D1FA0E3 		mov	r1, #500
 250 01d0 EBFFFFEA 		b	.L15
 251              	.LVL25:
 252              	.L9:
4469:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 253              		.loc 1 4469 0
 254 01d4 FEFFFFEB 		bl	SensorSetControl
 255              	.LVL26:
 256 01d8 0A10A0E1 		mov	r1, sl
4470:../uvc.c      **** 							break;
 257              		.loc 1 4470 0
 258 01dc E8FFFFEA 		b	.L15
 259              	.LVL27:
 260              	.L10:
4453:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 261              		.loc 1 4453 0
 262 01e0 8230A0E3 		mov	r3, #130
 263 01e4 FEFFFFEB 		bl	SensorSetIrisControl
 264              	.LVL28:
4455:../uvc.c      **** 							break;
 265              		.loc 1 4455 0
 266 01e8 7D1FA0E3 		mov	r1, #500
 267 01ec E4FFFFEA 		b	.L15
 268              	.LVL29:
 269              	.L8:
4497:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 270              		.loc 1 4497 0
 271 01f0 FA1FA0E3 		mov	r1, #1000
 272 01f4 44009FE5 		ldr	r0, .L25+4
 273 01f8 FEFFFFEB 		bl	_txe_timer_change
4498:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 274              		.loc 1 4498 0
 275 01fc 3C009FE5 		ldr	r0, .L25+4
 276 0200 FEFFFFEB 		bl	_txe_timer_activate
 277 0204 EAFFFFEA 		b	.L19
 278              	.LVL30:
 279              	.L24:
4486:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 280              		.loc 1 4486 0
 281 0208 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4485:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 282              		.loc 1 4485 0
 283 020c 3C9084E5 		str	r9, [r4, #60]
4486:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 284              		.loc 1 4486 0
 285 0210 23005CE3 		cmp	ip, #35
4487:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 286              		.loc 1 4487 0
 287 0214 24C04C82 		subhi	ip, ip, #36
 288 0218 8CC08C80 		addhi	ip, ip, ip, asl #1
4489:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 289              		.loc 1 4489 0
 290 021c 8CC08C90 		addls	ip, ip, ip, asl #1
4487:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 291              		.loc 1 4487 0
 292 0220 8CC18B80 		addhi	ip, fp, ip, asl #3
4489:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 293              		.loc 1 4489 0
 294 0224 8CC18B90 		addls	ip, fp, ip, asl #3
4487:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 295              		.loc 1 4487 0
 296 0228 1090CC85 		strhib	r9, [ip, #16]
4489:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 297              		.loc 1 4489 0
 298 022c 9091CC95 		strlsb	r9, [ip, #400]
4491:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 299              		.loc 1 4491 0
 300 0230 344094E5 		ldr	r4, [r4, #52]
 301              	.LVL31:
 302 0234 104085E5 		str	r4, [r5, #16]
 303 0238 DDFFFFEA 		b	.L19
 304              	.L26:
 305              		.align	2
 306              	.L25:
 307 023c 00000000 		.word	I2CCmdCb
 308 0240 00000000 		.word	I2CCmdTimer
 309 0244 00000000 		.word	.LC0
 310 0248 00000000 		.word	cmdQu
 311 024c 14000000 		.word	.LC1
 312 0250 00000000 		.word	statQu
 313 0254 00000000 		.word	.LANCHOR1
 314 0258 00000000 		.word	.LANCHOR0
 315              		.cfi_endproc
 316              	.LFE26:
 318              		.align	2
 319              		.global	I2CCmdCb
 321              	I2CCmdCb:
 322              	.LFB18:
2938:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 323              		.loc 1 2938 0
 324              		.cfi_startproc
 325              		@ args = 0, pretend = 0, frame = 0
 326              		@ frame_needed = 0, uses_anonymous_args = 0
 327              	.LVL32:
2939:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 328              		.loc 1 2939 0
 329 025c 28209FE5 		ldr	r2, .L28
2938:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 330              		.loc 1 2938 0
 331 0260 0030A0E1 		mov	r3, r0
 332 0264 10402DE9 		stmfd	sp!, {r4, lr}
 333              	.LCFI2:
 334              		.cfi_def_cfa_offset 8
2939:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 335              		.loc 1 2939 0
 336 0268 20109FE5 		ldr	r1, .L28+4
 337 026c 002092E5 		ldr	r2, [r2, #0]
 338 0270 0400A0E3 		mov	r0, #4
 339              	.LVL33:
 340              		.cfi_offset 14, -4
 341              		.cfi_offset 4, -8
 342 0274 FEFFFFEB 		bl	CyU3PDebugPrint
 343              	.LVL34:
2940:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 344              		.loc 1 2940 0
 345 0278 14009FE5 		ldr	r0, .L28+8
 346 027c 2010A0E3 		mov	r1, #32
 347 0280 0020A0E3 		mov	r2, #0
2941:../uvc.c      **** }
 348              		.loc 1 2941 0
 349 0284 1040BDE8 		ldmfd	sp!, {r4, lr}
2940:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 350              		.loc 1 2940 0
 351 0288 FEFFFFEA 		b	_txe_event_flags_set
 352              	.L29:
 353              		.align	2
 354              	.L28:
 355 028c 00000000 		.word	posTick
 356 0290 38000000 		.word	.LC2
 357 0294 00000000 		.word	.LANCHOR0
 358              		.cfi_endproc
 359              	.LFE18:
 361              		.align	2
 363              	CyFxUVCApplnUSBEventCB:
 364              	.LFB9:
1999:../uvc.c      **** {
 365              		.loc 1 1999 0
 366              		.cfi_startproc
 367              		@ args = 0, pretend = 0, frame = 8
 368              		@ frame_needed = 0, uses_anonymous_args = 0
 369              	.LVL35:
2000:../uvc.c      ****     switch (evtype)
 370              		.loc 1 2000 0
 371 0298 020050E3 		cmp	r0, #2
1999:../uvc.c      **** {
 372              		.loc 1 1999 0
 373 029c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 374              	.LCFI3:
 375              		.cfi_def_cfa_offset 16
 376 02a0 0130A0E1 		mov	r3, r1
 377 02a4 10D04DE2 		sub	sp, sp, #16
 378              	.LCFI4:
 379              		.cfi_def_cfa_offset 32
1999:../uvc.c      **** {
 380              		.loc 1 1999 0
 381 02a8 0040A0E1 		mov	r4, r0
 382              		.cfi_offset 14, -4
 383              		.cfi_offset 6, -8
 384              		.cfi_offset 5, -12
 385              		.cfi_offset 4, -16
2000:../uvc.c      ****     switch (evtype)
 386              		.loc 1 2000 0
 387 02ac 3600000A 		beq	.L33
 388 02b0 040050E3 		cmp	r0, #4
 389 02b4 1F00000A 		beq	.L34
 390 02b8 010050E3 		cmp	r0, #1
 391 02bc 0100000A 		beq	.L36
 392              	.LVL36:
 393              	.L30:
2036:../uvc.c      **** }
 394              		.loc 1 2036 0
 395 02c0 10D08DE2 		add	sp, sp, #16
 396 02c4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 397              	.LVL37:
 398              	.L36:
2021:../uvc.c      ****             gpif_initialized = 0;
 399              		.loc 1 2021 0
 400 02c8 28519FE5 		ldr	r5, .L37
2019:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 401              		.loc 1 2019 0
 402 02cc 0020A0E1 		mov	r2, r0
 403 02d0 24119FE5 		ldr	r1, .L37+4
 404              	.LVL38:
 405 02d4 0400A0E3 		mov	r0, #4
 406              	.LVL39:
 407 02d8 FEFFFFEB 		bl	CyU3PDebugPrint
2020:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 408              		.loc 1 2020 0
 409 02dc 0400A0E1 		mov	r0, r4
 410 02e0 FEFFFFEB 		bl	CyU3PGpifDisable
2021:../uvc.c      ****             gpif_initialized = 0;
 411              		.loc 1 2021 0
 412 02e4 00C0A0E3 		mov	ip, #0
 413              	.LBB16:
 414              	.LBB17:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 415              		.loc 1 1983 0
 416 02e8 0410A0E1 		mov	r1, r4
 417 02ec 0500A0E1 		mov	r0, r5
 418 02f0 0220A0E3 		mov	r2, #2
 419 02f4 0C308DE2 		add	r3, sp, #12
 420              	.LBE17:
 421              	.LBE16:
2021:../uvc.c      ****             gpif_initialized = 0;
 422              		.loc 1 2021 0
 423 02f8 28C085E5 		str	ip, [r5, #40]
2022:../uvc.c      ****             isUsbConnected = CyFalse;
 424              		.loc 1 2022 0
 425 02fc 30C085E5 		str	ip, [r5, #48]
2023:../uvc.c      ****             streamingStarted = CyFalse;
 426              		.loc 1 2023 0
 427 0300 2CC085E5 		str	ip, [r5, #44]
 428              	.LBB19:
 429              	.LBB18:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 430              		.loc 1 1983 0
 431 0304 00C08DE5 		str	ip, [sp, #0]
 432 0308 FEFFFFEB 		bl	_txe_event_flags_get
 433 030c 004050E2 		subs	r4, r0, #0
 434 0310 EAFFFF1A 		bne	.L30
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 435              		.loc 1 1986 0
 436 0314 0110E0E3 		mvn	r1, #1
 437 0318 0220A0E3 		mov	r2, #2
 438 031c 0500A0E1 		mov	r0, r5
 439              	.L35:
 440 0320 FEFFFFEB 		bl	_txe_event_flags_set
1989:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 441              		.loc 1 1989 0
 442 0324 0500A0E1 		mov	r0, r5
 443 0328 0210A0E3 		mov	r1, #2
 444 032c 0420A0E1 		mov	r2, r4
 445 0330 FEFFFFEB 		bl	_txe_event_flags_set
 446 0334 E1FFFFEA 		b	.L30
 447              	.LVL40:
 448              	.L34:
 449              	.LBE18:
 450              	.LBE19:
2005:../uvc.c      ****             gpif_initialized = 0;
 451              		.loc 1 2005 0
 452 0338 B8509FE5 		ldr	r5, .L37
2003:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 453              		.loc 1 2003 0
 454 033c BC109FE5 		ldr	r1, .L37+8
 455              	.LVL41:
 456 0340 0020A0E1 		mov	r2, r0
 457 0344 FEFFFFEB 		bl	CyU3PDebugPrint
 458              	.LVL42:
2004:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 459              		.loc 1 2004 0
 460 0348 0100A0E3 		mov	r0, #1
 461 034c FEFFFFEB 		bl	CyU3PGpifDisable
2005:../uvc.c      ****             gpif_initialized = 0;
 462              		.loc 1 2005 0
 463 0350 00C0A0E3 		mov	ip, #0
 464              	.LBB20:
 465              	.LBB21:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 466              		.loc 1 1983 0
 467 0354 0110A0E3 		mov	r1, #1
 468 0358 0220A0E3 		mov	r2, #2
 469 035c 0500A0E1 		mov	r0, r5
 470 0360 0C308DE2 		add	r3, sp, #12
 471              	.LBE21:
 472              	.LBE20:
2005:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 2005 0
 474 0364 28C085E5 		str	ip, [r5, #40]
2006:../uvc.c      ****             streamingStarted = CyFalse;
 475              		.loc 1 2006 0
 476 0368 2CC085E5 		str	ip, [r5, #44]
 477              	.LBB23:
 478              	.LBB22:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 479              		.loc 1 1983 0
 480 036c 00C08DE5 		str	ip, [sp, #0]
 481 0370 FEFFFFEB 		bl	_txe_event_flags_get
 482 0374 004050E2 		subs	r4, r0, #0
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 483              		.loc 1 1986 0
 484 0378 0500A001 		moveq	r0, r5
 485 037c 0110E003 		mvneq	r1, #1
 486 0380 0220A003 		moveq	r2, #2
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 487              		.loc 1 1983 0
 488 0384 CDFFFF1A 		bne	.L30
 489 0388 E4FFFFEA 		b	.L35
 490              	.LVL43:
 491              	.L33:
 492              	.LBE22:
 493              	.LBE23:
2013:../uvc.c      ****             gpif_initialized = 0;
 494              		.loc 1 2013 0
 495 038c 64509FE5 		ldr	r5, .L37
2011:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 496              		.loc 1 2011 0
 497 0390 0020A0E1 		mov	r2, r0
 498 0394 68109FE5 		ldr	r1, .L37+12
 499              	.LVL44:
 500 0398 0400A0E3 		mov	r0, #4
 501              	.LVL45:
 502 039c FEFFFFEB 		bl	CyU3PDebugPrint
2012:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 503              		.loc 1 2012 0
 504 03a0 0100A0E3 		mov	r0, #1
 505 03a4 FEFFFFEB 		bl	CyU3PGpifDisable
2013:../uvc.c      ****             gpif_initialized = 0;
 506              		.loc 1 2013 0
 507 03a8 0060A0E3 		mov	r6, #0
 508              	.LBB24:
 509              	.LBB25:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 510              		.loc 1 1983 0
 511 03ac 0500A0E1 		mov	r0, r5
 512 03b0 0110A0E3 		mov	r1, #1
 513 03b4 0420A0E1 		mov	r2, r4
 514 03b8 0C308DE2 		add	r3, sp, #12
 515              	.LBE25:
 516              	.LBE24:
2013:../uvc.c      ****             gpif_initialized = 0;
 517              		.loc 1 2013 0
 518 03bc 286085E5 		str	r6, [r5, #40]
2014:../uvc.c      ****             streamingStarted = CyFalse;
 519              		.loc 1 2014 0
 520 03c0 2C6085E5 		str	r6, [r5, #44]
 521              	.LBB27:
 522              	.LBB26:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 523              		.loc 1 1983 0
 524 03c4 00608DE5 		str	r6, [sp, #0]
 525 03c8 FEFFFFEB 		bl	_txe_event_flags_get
 526 03cc 006050E2 		subs	r6, r0, #0
 527 03d0 BAFFFF1A 		bne	.L30
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 528              		.loc 1 1986 0
 529 03d4 0420A0E1 		mov	r2, r4
 530 03d8 0500A0E1 		mov	r0, r5
 531 03dc 0110E0E3 		mvn	r1, #1
 532 03e0 FEFFFFEB 		bl	_txe_event_flags_set
1989:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 533              		.loc 1 1989 0
 534 03e4 0500A0E1 		mov	r0, r5
 535 03e8 0410A0E1 		mov	r1, r4
 536 03ec 0620A0E1 		mov	r2, r6
 537 03f0 FEFFFFEB 		bl	_txe_event_flags_set
 538 03f4 B1FFFFEA 		b	.L30
 539              	.L38:
 540              		.align	2
 541              	.L37:
 542 03f8 00000000 		.word	.LANCHOR0
 543 03fc 94000000 		.word	.LC5
 544 0400 50000000 		.word	.LC3
 545 0404 70000000 		.word	.LC4
 546              	.LBE26:
 547              	.LBE27:
 548              		.cfi_endproc
 549              	.LFE9:
 551              		.align	2
 552              		.global	CyFxUvcApplnDmaCallback
 554              	CyFxUvcApplnDmaCallback:
 555              	.LFB11:
2196:../uvc.c      **** {
 556              		.loc 1 2196 0
 557              		.cfi_startproc
 558              		@ args = 0, pretend = 0, frame = 0
 559              		@ frame_needed = 0, uses_anonymous_args = 0
 560              	.LVL46:
2203:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 561              		.loc 1 2203 0
 562 0408 080051E3 		cmp	r1, #8
2196:../uvc.c      **** {
 563              		.loc 1 2196 0
 564 040c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 565              	.LCFI5:
 566              		.cfi_def_cfa_offset 20
 567 0410 0250A0E1 		mov	r5, r2
 568              		.cfi_offset 14, -4
 569              		.cfi_offset 7, -8
 570              		.cfi_offset 6, -12
 571              		.cfi_offset 5, -16
 572              		.cfi_offset 4, -20
 573 0414 0CD04DE2 		sub	sp, sp, #12
 574              	.LCFI6:
 575              		.cfi_def_cfa_offset 32
2203:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 576              		.loc 1 2203 0
 577 0418 0B00000A 		beq	.L45
2255:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 578              		.loc 1 2255 0
 579 041c 100051E3 		cmp	r1, #16
 580 0420 0700001A 		bne	.L39
2257:../uvc.c      ****         consCount++;
 581              		.loc 1 2257 0
 582 0424 7C319FE5 		ldr	r3, .L48
2258:../uvc.c      ****         streamingStarted = CyTrue;
 583              		.loc 1 2258 0
 584 0428 0120A0E3 		mov	r2, #1
 585              	.LVL47:
2257:../uvc.c      ****         consCount++;
 586              		.loc 1 2257 0
 587 042c B204D3E1 		ldrh	r0, [r3, #66]
 588              	.LVL48:
2258:../uvc.c      ****         streamingStarted = CyTrue;
 589              		.loc 1 2258 0
 590 0430 2C2083E5 		str	r2, [r3, #44]
2257:../uvc.c      ****         consCount++;
 591              		.loc 1 2257 0
 592 0434 02C080E0 		add	ip, r0, r2
 593 0438 0C18A0E1 		mov	r1, ip, asl #16
 594              	.LVL49:
 595 043c 2128A0E1 		mov	r2, r1, lsr #16
 596 0440 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 597              	.L39:
2260:../uvc.c      **** }
 598              		.loc 1 2260 0
 599 0444 0CD08DE2 		add	sp, sp, #12
 600 0448 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 601              	.LVL50:
 602              	.L45:
2205:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 603              		.loc 1 2205 0
 604 044c B420D2E1 		ldrh	r2, [r2, #4]
 605 0450 54319FE5 		ldr	r3, .L48+4
 606 0454 030052E1 		cmp	r2, r3
 607 0458 3500000A 		beq	.L46
2225:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 608              		.loc 1 2225 0
 609 045c 006095E5 		ldr	r6, [r5, #0]
 610              	.LBB32:
 611              	.LBB34:
1944:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 612              		.loc 1 1944 0
 613 0460 48719FE5 		ldr	r7, .L48+8
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 614              		.loc 1 1943 0
 615 0464 0010E0E3 		mvn	r1, #0
 616              	.LVL51:
 617              	.LBE34:
 618              	.LBE32:
2225:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 619              		.loc 1 2225 0
 620 0468 0C4046E2 		sub	r4, r6, #12
 621              	.LVL52:
 622              	.LBB36:
 623              	.LBB33:
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 624              		.loc 1 1943 0
 625 046c 40019FE5 		ldr	r0, .L48+12
 626              	.LVL53:
 627 0470 FEFFFFEB 		bl	_txe_mutex_get
1944:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 628              		.loc 1 1944 0
 629 0474 0400A0E1 		mov	r0, r4
 630 0478 121D87E2 		add	r1, r7, #1152
 631 047c 0C20A0E3 		mov	r2, #12
 632 0480 FEFFFFEB 		bl	CyU3PMemCopy
1945:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 633              		.loc 1 1945 0
 634 0484 28019FE5 		ldr	r0, .L48+12
 635 0488 FEFFFFEB 		bl	_txe_mutex_put
1950:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 636              		.loc 1 1950 0
 637 048c 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 638              	.LBE33:
 639              	.LBE36:
2226:../uvc.c      ****                 pb++;
 640              		.loc 1 2226 0
 641 0490 10419FE5 		ldr	r4, .L48
 642              	.LVL54:
 643              	.LBB37:
 644              	.LBB35:
1950:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 645              		.loc 1 1950 0
 646 0494 02108CE3 		orr	r1, ip, #2
 647 0498 0B1046E5 		strb	r1, [r6, #-11]
 648              	.LBE35:
 649              	.LBE37:
2226:../uvc.c      ****                 pb++;
 650              		.loc 1 2226 0
 651 049c B603D4E1 		ldrh	r0, [r4, #54]
2232:../uvc.c      ****                 if(stiflag == 0x0F){
 652              		.loc 1 2232 0
 653 04a0 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
2227:../uvc.c      ****                 pbc = input->buffer_p.count;
 654              		.loc 1 2227 0
 655 04a4 B410D5E1 		ldrh	r1, [r5, #4]
2226:../uvc.c      ****                 pb++;
 656              		.loc 1 2226 0
 657 04a8 013080E2 		add	r3, r0, #1
2232:../uvc.c      ****                 if(stiflag == 0x0F){
 658              		.loc 1 2232 0
 659 04ac 0F0052E3 		cmp	r2, #15
2226:../uvc.c      ****                 pb++;
 660              		.loc 1 2226 0
 661 04b0 B633C4E1 		strh	r3, [r4, #54]	@ movhi
2227:../uvc.c      ****                 pbc = input->buffer_p.count;
 662              		.loc 1 2227 0
 663 04b4 B813C4E1 		strh	r1, [r4, #56]	@ movhi
2232:../uvc.c      ****                 if(stiflag == 0x0F){
 664              		.loc 1 2232 0
 665 04b8 2E00000A 		beq	.L47
 666              	.L43:
2239:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 667              		.loc 1 2239 0
 668 04bc 01E0A0E3 		mov	lr, #1
 669 04c0 3CE084E5 		str	lr, [r4, #60]
 670              	.LVL55:
 671              	.L42:
2243:../uvc.c      ****             prodCount++;
 672              		.loc 1 2243 0
 673 04c4 B0E4D4E1 		ldrh	lr, [r4, #64]
2244:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 674              		.loc 1 2244 0
 675 04c8 0C1081E2 		add	r1, r1, #12
2243:../uvc.c      ****             prodCount++;
 676              		.loc 1 2243 0
 677 04cc 01308EE2 		add	r3, lr, #1
 678 04d0 0308A0E1 		mov	r0, r3, asl #16
 679 04d4 20C8A0E1 		mov	ip, r0, lsr #16
2244:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 680              		.loc 1 2244 0
 681 04d8 0128A0E1 		mov	r2, r1, asl #16
 682 04dc 2218A0E1 		mov	r1, r2, lsr #16
 683 04e0 D0009FE5 		ldr	r0, .L48+16
 684 04e4 0020A0E3 		mov	r2, #0
2243:../uvc.c      ****             prodCount++;
 685              		.loc 1 2243 0
 686 04e8 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
2244:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 687              		.loc 1 2244 0
 688 04ec FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 689              	.LVL56:
2243:../uvc.c      ****             prodCount++;
 690              		.loc 1 2243 0
 691 04f0 B0109FE5 		ldr	r1, .L48
2247:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 692              		.loc 1 2247 0
 693 04f4 002050E2 		subs	r2, r0, #0
 694 04f8 D1FFFF0A 		beq	.L39
2249:../uvc.c      ****                 prodCount--;
 695              		.loc 1 2249 0
 696 04fc B004D1E1 		ldrh	r0, [r1, #64]
 697              	.LVL57:
2250:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 698              		.loc 1 2250 0
 699 0500 B430D5E1 		ldrh	r3, [r5, #4]
2249:../uvc.c      ****                 prodCount--;
 700              		.loc 1 2249 0
 701 0504 01E040E2 		sub	lr, r0, #1
 702 0508 0EC8A0E1 		mov	ip, lr, asl #16
 703 050c 2C08A0E1 		mov	r0, ip, lsr #16
 704 0510 B004C1E1 		strh	r0, [r1, #64]	@ movhi
2250:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 705              		.loc 1 2250 0
 706 0514 B0E4D1E1 		ldrh	lr, [r1, #64]
 707 0518 B2C4D1E1 		ldrh	ip, [r1, #66]
 708 051c 0400A0E3 		mov	r0, #4
 709 0520 94109FE5 		ldr	r1, .L48+20
 710 0524 00E08DE5 		str	lr, [sp, #0]
 711 0528 04C08DE5 		str	ip, [sp, #4]
 712 052c FEFFFFEB 		bl	CyU3PDebugPrint
 713              	.LVL58:
 714 0530 C3FFFFEA 		b	.L39
 715              	.LVL59:
 716              	.L46:
2219:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 717              		.loc 1 2219 0
 718 0534 006095E5 		ldr	r6, [r5, #0]
 719              	.LBB38:
 720              	.LBB39:
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 721              		.loc 1 1943 0
 722 0538 0010E0E3 		mvn	r1, #0
 723              	.LVL60:
 724              	.LBE39:
 725              	.LBE38:
2220:../uvc.c      ****                 fb++;
 726              		.loc 1 2220 0
 727 053c 64409FE5 		ldr	r4, .L48
2219:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 728              		.loc 1 2219 0
 729 0540 0C6046E2 		sub	r6, r6, #12
 730              	.LVL61:
 731              	.LBB41:
 732              	.LBB40:
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 733              		.loc 1 1943 0
 734 0544 68009FE5 		ldr	r0, .L48+12
 735              	.LVL62:
 736 0548 FEFFFFEB 		bl	_txe_mutex_get
1944:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 737              		.loc 1 1944 0
 738 054c 6C109FE5 		ldr	r1, .L48+24
 739 0550 0600A0E1 		mov	r0, r6
 740 0554 0C20A0E3 		mov	r2, #12
 741 0558 FEFFFFEB 		bl	CyU3PMemCopy
1945:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 742              		.loc 1 1945 0
 743 055c 50009FE5 		ldr	r0, .L48+12
 744 0560 FEFFFFEB 		bl	_txe_mutex_put
 745              	.LBE40:
 746              	.LBE41:
2220:../uvc.c      ****                 fb++;
 747              		.loc 1 2220 0
 748 0564 B4C3D4E1 		ldrh	ip, [r4, #52]
 749 0568 B410D5E1 		ldrh	r1, [r5, #4]
 750 056c 01008CE2 		add	r0, ip, #1
 751 0570 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 752 0574 D2FFFFEA 		b	.L42
 753              	.LVL63:
 754              	.L47:
2233:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 755              		.loc 1 2233 0
 756 0578 0010E0E3 		mvn	r1, #0
 757 057c 30009FE5 		ldr	r0, .L48+12
 758 0580 FEFFFFEB 		bl	_txe_mutex_get
2234:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 759              		.loc 1 2234 0
 760 0584 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2235:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 761              		.loc 1 2235 0
 762 0588 24009FE5 		ldr	r0, .L48+12
2234:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 763              		.loc 1 2234 0
 764 058c DF2001E2 		and	r2, r1, #223
 765 0590 8124C7E5 		strb	r2, [r7, #1153]
2235:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 766              		.loc 1 2235 0
 767 0594 FEFFFFEB 		bl	_txe_mutex_put
2236:../uvc.c      ****                 	stiflag = 0xAA;
 768              		.loc 1 2236 0
 769 0598 5530E0E3 		mvn	r3, #85
 770 059c 3A30C4E5 		strb	r3, [r4, #58]
 771 05a0 B410D5E1 		ldrh	r1, [r5, #4]
 772 05a4 C4FFFFEA 		b	.L43
 773              	.L49:
 774              		.align	2
 775              	.L48:
 776 05a8 00000000 		.word	.LANCHOR0
 777 05ac F03F0000 		.word	16368
 778 05b0 00000000 		.word	.LANCHOR1
 779 05b4 00000000 		.word	imgHdMux
 780 05b8 00000000 		.word	glChHandleUVCStream
 781 05bc B4000000 		.word	.LC6
 782 05c0 80040000 		.word	.LANCHOR1+1152
 783              		.cfi_endproc
 784              	.LFE11:
 786              		.align	2
 788              	CyFxUVCApplnUSBSetupCB:
 789              	.LFB10:
2044:../uvc.c      **** {
 790              		.loc 1 2044 0
 791              		.cfi_startproc
 792              		@ args = 0, pretend = 0, frame = 8
 793              		@ frame_needed = 0, uses_anonymous_args = 0
 794              	.LVL64:
2049:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 795              		.loc 1 2049 0
 796 05c4 C0329FE5 		ldr	r3, .L75
2044:../uvc.c      **** {
 797              		.loc 1 2044 0
 798 05c8 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 799              	.LCFI7:
 800              		.cfi_def_cfa_offset 24
2050:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 801              		.loc 1 2050 0
 802 05cc BCC29FE5 		ldr	ip, .L75+4
2049:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 803              		.loc 1 2049 0
 804 05d0 FF4000E2 		and	r4, r0, #255
 805              		.cfi_offset 14, -4
 806              		.cfi_offset 8, -8
 807              		.cfi_offset 7, -12
 808              		.cfi_offset 6, -16
 809              		.cfi_offset 5, -20
 810              		.cfi_offset 4, -24
2050:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 811              		.loc 1 2050 0
 812 05d4 FF8C00E2 		and	r8, r0, #65280
2051:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 813              		.loc 1 2051 0
 814 05d8 2078A0E1 		mov	r7, r0, lsr #16
2049:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 815              		.loc 1 2049 0
 816 05dc 0040C3E5 		strb	r4, [r3, #0]
2051:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 817              		.loc 1 2051 0
 818 05e0 AC229FE5 		ldr	r2, .L75+8
2052:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 819              		.loc 1 2052 0
 820 05e4 AC029FE5 		ldr	r0, .L75+12
 821              	.LVL65:
2053:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 822              		.loc 1 2053 0
 823 05e8 AC329FE5 		ldr	r3, .L75+16
2052:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 824              		.loc 1 2052 0
 825 05ec 0158A0E1 		mov	r5, r1, asl #16
2050:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 826              		.loc 1 2050 0
 827 05f0 2884A0E1 		mov	r8, r8, lsr #8
2052:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 828              		.loc 1 2052 0
 829 05f4 2558A0E1 		mov	r5, r5, lsr #16
2053:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 830              		.loc 1 2053 0
 831 05f8 2118A0E1 		mov	r1, r1, lsr #16
 832              	.LVL66:
2056:../uvc.c      ****     switch (bmReqType)
 833              		.loc 1 2056 0
 834 05fc 020054E3 		cmp	r4, #2
2044:../uvc.c      **** {
 835              		.loc 1 2044 0
 836 0600 10D04DE2 		sub	sp, sp, #16
 837              	.LCFI8:
 838              		.cfi_def_cfa_offset 40
2050:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 839              		.loc 1 2050 0
 840 0604 0080CCE5 		strb	r8, [ip, #0]
2051:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 841              		.loc 1 2051 0
 842 0608 B070C2E1 		strh	r7, [r2, #0]	@ movhi
2052:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 843              		.loc 1 2052 0
 844 060c B050C0E1 		strh	r5, [r0, #0]	@ movhi
2053:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 845              		.loc 1 2053 0
 846 0610 B010C3E1 		strh	r1, [r3, #0]	@ movhi
2056:../uvc.c      ****     switch (bmReqType)
 847              		.loc 1 2056 0
 848 0614 4F00000A 		beq	.L53
 849 0618 0600009A 		bls	.L71
 850 061c 210054E3 		cmp	r4, #33
 851 0620 3A00000A 		beq	.L54
 852 0624 A10054E3 		cmp	r4, #161
 853 0628 3800000A 		beq	.L54
 854              	.L68:
2045:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 855              		.loc 1 2045 0
 856 062c 0000A0E3 		mov	r0, #0
 857              	.LVL67:
 858              	.L51:
2183:../uvc.c      **** }
 859              		.loc 1 2183 0
 860 0630 10D08DE2 		add	sp, sp, #16
 861 0634 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 862              	.LVL68:
 863              	.L71:
2056:../uvc.c      ****     switch (bmReqType)
 864              		.loc 1 2056 0
 865 0638 010054E3 		cmp	r4, #1
 866 063c FAFFFF1A 		bne	.L68
2096:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 867              		.loc 1 2096 0
 868 0640 0B0058E3 		cmp	r8, #11
 869 0644 F8FFFF1A 		bne	.L68
2100:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 870              		.loc 1 2100 0
 871 0648 010055E3 		cmp	r5, #1
 872 064c F6FFFF1A 		bne	.L68
2100:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 873              		.loc 1 2100 0 is_stmt 0 discriminator 1
 874 0650 000057E3 		cmp	r7, #0
 875 0654 F4FFFF1A 		bne	.L68
2105:../uvc.c      ****                     gpif_initialized = 0;
 876              		.loc 1 2105 0 is_stmt 1
 877 0658 40429FE5 		ldr	r4, .L75+20
2103:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 878              		.loc 1 2103 0
 879 065c 40129FE5 		ldr	r1, .L75+24
 880 0660 0400A0E3 		mov	r0, #4
 881 0664 FEFFFFEB 		bl	CyU3PDebugPrint
2104:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 882              		.loc 1 2104 0
 883 0668 0500A0E1 		mov	r0, r5
 884 066c FEFFFFEB 		bl	CyU3PGpifDisable
2108:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 885              		.loc 1 2108 0
 886 0670 0510A0E1 		mov	r1, r5
 887 0674 8300A0E3 		mov	r0, #131
2105:../uvc.c      ****                     gpif_initialized = 0;
 888              		.loc 1 2105 0
 889 0678 287084E5 		str	r7, [r4, #40]
2106:../uvc.c      ****                     streamingStarted = CyFalse;
 890              		.loc 1 2106 0
 891 067c 2C7084E5 		str	r7, [r4, #44]
2108:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 892              		.loc 1 2108 0
 893 0680 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2109:../uvc.c      ****                     CyU3PBusyWait (100);
 894              		.loc 1 2109 0
 895 0684 6400A0E3 		mov	r0, #100
 896 0688 FEFFFFEB 		bl	CyU3PBusyWait
2112:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 897              		.loc 1 2112 0
 898 068c 14029FE5 		ldr	r0, .L75+28
 899 0690 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2113:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 900              		.loc 1 2113 0
 901 0694 8300A0E3 		mov	r0, #131
 902 0698 FEFFFFEB 		bl	CyU3PUsbFlushEp
2114:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 903              		.loc 1 2114 0
 904 069c 0710A0E1 		mov	r1, r7
 905 06a0 8300A0E3 		mov	r0, #131
 906 06a4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2115:../uvc.c      ****                     CyU3PBusyWait (100);
 907              		.loc 1 2115 0
 908 06a8 6400A0E3 		mov	r0, #100
 909 06ac FEFFFFEB 		bl	CyU3PBusyWait
2118:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 910              		.loc 1 2118 0
 911 06b0 0710A0E1 		mov	r1, r7
 912 06b4 0520A0E1 		mov	r2, r5
 913 06b8 8300A0E3 		mov	r0, #131
 914 06bc FEFFFFEB 		bl	CyU3PUsbStall
 915              	.LVL69:
2121:../uvc.c      ****                     CyU3PUsbAckSetup ();
 916              		.loc 1 2121 0
 917 06c0 FEFFFFEB 		bl	CyU3PUsbAckSetup
2123:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 918              		.loc 1 2123 0
 919 06c4 445084E5 		str	r5, [r4, #68]
 920              	.LBB46:
 921              	.LBB47:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 922              		.loc 1 1983 0
 923 06c8 0400A0E1 		mov	r0, r4
 924 06cc 0510A0E1 		mov	r1, r5
 925 06d0 0220A0E3 		mov	r2, #2
 926 06d4 0C308DE2 		add	r3, sp, #12
 927 06d8 00708DE5 		str	r7, [sp, #0]
 928 06dc FEFFFFEB 		bl	_txe_event_flags_get
 929 06e0 006050E2 		subs	r6, r0, #0
 930 06e4 2E00001A 		bne	.L66
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 931              		.loc 1 1986 0
 932 06e8 0110E0E3 		mvn	r1, #1
 933 06ec 0220A0E3 		mov	r2, #2
 934 06f0 0400A0E1 		mov	r0, r4
 935 06f4 FEFFFFEB 		bl	_txe_event_flags_set
1989:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 936              		.loc 1 1989 0
 937 06f8 0400A0E1 		mov	r0, r4
 938 06fc 0210A0E3 		mov	r1, #2
 939 0700 0620A0E1 		mov	r2, r6
 940 0704 FEFFFFEB 		bl	_txe_event_flags_set
2119:../uvc.c      ****                     uvcHandleReq = CyTrue;
 941              		.loc 1 2119 0
 942 0708 0500A0E1 		mov	r0, r5
 943 070c C7FFFFEA 		b	.L51
 944              	.LVL70:
 945              	.L54:
 946              	.LBE47:
 947              	.LBE46:
2061:../uvc.c      ****             switch (wIndex & 0xFF)
 948              		.loc 1 2061 0
 949 0710 FF5015E2 		ands	r5, r5, #255
 950 0714 1A00001A 		bne	.L72
 951              	.LVL71:
2066:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 952              		.loc 1 2066 0
 953 0718 0520A0E1 		mov	r2, r5
 954 071c 7C019FE5 		ldr	r0, .L75+20
 955 0720 0410A0E3 		mov	r1, #4
 956 0724 FEFFFFEB 		bl	_txe_event_flags_set
 957              	.LVL72:
2068:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 958              		.loc 1 2068 0
 959 0728 002050E2 		subs	r2, r0, #0
2065:../uvc.c      ****                         uvcHandleReq = CyTrue;
 960              		.loc 1 2065 0
 961 072c 0100A003 		moveq	r0, #1
 962              	.LVL73:
2068:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 963              		.loc 1 2068 0
 964 0730 BEFFFF0A 		beq	.L51
2070:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 965              		.loc 1 2070 0
 966 0734 70119FE5 		ldr	r1, .L75+32
 967 0738 0400A0E3 		mov	r0, #4
 968 073c FEFFFFEB 		bl	CyU3PDebugPrint
 969              	.LVL74:
2071:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 970              		.loc 1 2071 0
 971 0740 0500A0E1 		mov	r0, r5
 972 0744 0110A0E3 		mov	r1, #1
 973 0748 0520A0E1 		mov	r2, r5
 974 074c FEFFFFEB 		bl	CyU3PUsbStall
2065:../uvc.c      ****                         uvcHandleReq = CyTrue;
 975              		.loc 1 2065 0
 976 0750 0100A0E3 		mov	r0, #1
 977 0754 B5FFFFEA 		b	.L51
 978              	.LVL75:
 979              	.L53:
2131:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 980              		.loc 1 2131 0
 981 0758 010058E3 		cmp	r8, #1
 982 075c B2FFFF1A 		bne	.L68
2133:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 983              		.loc 1 2133 0
 984 0760 830055E3 		cmp	r5, #131
 985 0764 B0FFFF1A 		bne	.L68
2139:../uvc.c      ****                     if (streamingStarted == CyTrue)
 986              		.loc 1 2139 0
 987 0768 30719FE5 		ldr	r7, .L75+20
 988 076c 2C6097E5 		ldr	r6, [r7, #44]
 989 0770 010056E3 		cmp	r6, #1
 990 0774 1500000A 		beq	.L73
 991              	.LVL76:
2171:../uvc.c      ****                         CyU3PUsbAckSetup ();
 992              		.loc 1 2171 0
 993 0778 FEFFFFEB 		bl	CyU3PUsbAckSetup
2170:../uvc.c      ****                         uvcHandleReq = CyTrue;
 994              		.loc 1 2170 0
 995 077c 0800A0E1 		mov	r0, r8
 996 0780 AAFFFFEA 		b	.L51
 997              	.LVL77:
 998              	.L72:
2061:../uvc.c      ****             switch (wIndex & 0xFF)
 999              		.loc 1 2061 0
 1000 0784 010055E3 		cmp	r5, #1
 1001 0788 A7FFFF1A 		bne	.L68
 1002              	.LVL78:
2079:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1003              		.loc 1 2079 0
 1004 078c 0020A0E3 		mov	r2, #0
 1005 0790 08019FE5 		ldr	r0, .L75+20
 1006 0794 0810A0E3 		mov	r1, #8
 1007 0798 FEFFFFEB 		bl	_txe_event_flags_set
 1008              	.LVL79:
2081:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1009              		.loc 1 2081 0
 1010 079c 002050E2 		subs	r2, r0, #0
 1011 07a0 0100001A 		bne	.L74
 1012              	.LVL80:
 1013              	.L66:
 1014              	.LBB49:
 1015              	.LBB48:
2119:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1016              		.loc 1 2119 0
 1017 07a4 0500A0E1 		mov	r0, r5
 1018 07a8 A0FFFFEA 		b	.L51
 1019              	.LVL81:
 1020              	.L74:
 1021              	.LBE48:
 1022              	.LBE49:
2084:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1023              		.loc 1 2084 0
 1024 07ac FC109FE5 		ldr	r1, .L75+36
 1025 07b0 0400A0E3 		mov	r0, #4
 1026              	.LVL82:
 1027 07b4 FEFFFFEB 		bl	CyU3PDebugPrint
 1028              	.LVL83:
2085:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1029              		.loc 1 2085 0
 1030 07b8 0000A0E3 		mov	r0, #0
 1031 07bc 0510A0E1 		mov	r1, r5
 1032 07c0 0020A0E1 		mov	r2, r0
 1033 07c4 FEFFFFEB 		bl	CyU3PUsbStall
2078:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1034              		.loc 1 2078 0
 1035 07c8 0500A0E1 		mov	r0, r5
 1036 07cc 97FFFFEA 		b	.L51
 1037              	.LVL84:
 1038              	.L73:
2141:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1039              		.loc 1 2141 0
 1040 07d0 DC109FE5 		ldr	r1, .L75+40
 1041 07d4 0400A0E3 		mov	r0, #4
 1042 07d8 FEFFFFEB 		bl	CyU3PDebugPrint
2145:../uvc.c      ****                         gpif_initialized = 0;
 1043              		.loc 1 2145 0
 1044 07dc 0080A0E3 		mov	r8, #0
2144:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1045              		.loc 1 2144 0
 1046 07e0 0600A0E1 		mov	r0, r6
 1047 07e4 FEFFFFEB 		bl	CyU3PGpifDisable
2149:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1048              		.loc 1 2149 0
 1049 07e8 0610A0E1 		mov	r1, r6
 1050 07ec 0500A0E1 		mov	r0, r5
2145:../uvc.c      ****                         gpif_initialized = 0;
 1051              		.loc 1 2145 0
 1052 07f0 288087E5 		str	r8, [r7, #40]
2146:../uvc.c      ****                         streamingStarted = CyFalse;
 1053              		.loc 1 2146 0
 1054 07f4 2C8087E5 		str	r8, [r7, #44]
2149:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1055              		.loc 1 2149 0
 1056 07f8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2150:../uvc.c      ****                         CyU3PBusyWait (100);
 1057              		.loc 1 2150 0
 1058 07fc 6400A0E3 		mov	r0, #100
 1059 0800 FEFFFFEB 		bl	CyU3PBusyWait
2153:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1060              		.loc 1 2153 0
 1061 0804 9C009FE5 		ldr	r0, .L75+28
 1062 0808 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2154:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1063              		.loc 1 2154 0
 1064 080c 0500A0E1 		mov	r0, r5
 1065 0810 FEFFFFEB 		bl	CyU3PUsbFlushEp
2155:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1066              		.loc 1 2155 0
 1067 0814 0810A0E1 		mov	r1, r8
 1068 0818 0500A0E1 		mov	r0, r5
 1069 081c FEFFFFEB 		bl	CyU3PUsbSetEpNak
2156:../uvc.c      ****                         CyU3PBusyWait (100);
 1070              		.loc 1 2156 0
 1071 0820 6400A0E3 		mov	r0, #100
 1072 0824 FEFFFFEB 		bl	CyU3PBusyWait
2159:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1073              		.loc 1 2159 0
 1074 0828 0810A0E1 		mov	r1, r8
 1075 082c 0620A0E1 		mov	r2, r6
 1076 0830 0500A0E1 		mov	r0, r5
 1077 0834 FEFFFFEB 		bl	CyU3PUsbStall
 1078              	.LVL85:
2163:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1079              		.loc 1 2163 0
 1080 0838 FEFFFFEB 		bl	CyU3PUsbAckSetup
2165:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1081              		.loc 1 2165 0
 1082 083c 446087E5 		str	r6, [r7, #68]
 1083              	.LBB50:
 1084              	.LBB51:
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1085              		.loc 1 1983 0
 1086 0840 0700A0E1 		mov	r0, r7
 1087 0844 0610A0E1 		mov	r1, r6
 1088 0848 0420A0E1 		mov	r2, r4
 1089 084c 0C308DE2 		add	r3, sp, #12
 1090 0850 00808DE5 		str	r8, [sp, #0]
 1091 0854 FEFFFFEB 		bl	_txe_event_flags_get
 1092 0858 005050E2 		subs	r5, r0, #0
2161:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1093              		.loc 1 2161 0
 1094 085c 0600A011 		movne	r0, r6
1983:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1095              		.loc 1 1983 0
 1096 0860 72FFFF1A 		bne	.L51
1986:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1097              		.loc 1 1986 0
 1098 0864 0110E0E3 		mvn	r1, #1
 1099 0868 0420A0E1 		mov	r2, r4
 1100 086c 0700A0E1 		mov	r0, r7
 1101 0870 FEFFFFEB 		bl	_txe_event_flags_set
1989:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1102              		.loc 1 1989 0
 1103 0874 0700A0E1 		mov	r0, r7
 1104 0878 0410A0E1 		mov	r1, r4
 1105 087c 0520A0E1 		mov	r2, r5
 1106 0880 FEFFFFEB 		bl	_txe_event_flags_set
2161:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1107              		.loc 1 2161 0
 1108 0884 0600A0E1 		mov	r0, r6
 1109 0888 68FFFFEA 		b	.L51
 1110              	.L76:
 1111              		.align	2
 1112              	.L75:
 1113 088c 00000000 		.word	bmReqType
 1114 0890 00000000 		.word	bRequest
 1115 0894 00000000 		.word	wValue
 1116 0898 00000000 		.word	wIndex
 1117 089c 00000000 		.word	wLength
 1118 08a0 00000000 		.word	.LANCHOR0
 1119 08a4 6C010000 		.word	.LC9
 1120 08a8 00000000 		.word	glChHandleUVCStream
 1121 08ac 00010000 		.word	.LC7
 1122 08b0 38010000 		.word	.LC8
 1123 08b4 84010000 		.word	.LC10
 1124              	.LBE51:
 1125              	.LBE50:
 1126              		.cfi_endproc
 1127              	.LFE10:
 1129              		.align	2
 1130              		.global	CyFxGpifCB
 1132              	CyFxGpifCB:
 1133              	.LFB13:
2382:../uvc.c      **** {
 1134              		.loc 1 2382 0
 1135              		.cfi_startproc
 1136              		@ args = 0, pretend = 0, frame = 0
 1137              		@ frame_needed = 0, uses_anonymous_args = 0
 1138              	.LVL86:
2383:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1139              		.loc 1 2383 0
 1140 08b8 010050E3 		cmp	r0, #1
2382:../uvc.c      **** {
 1141              		.loc 1 2382 0
 1142 08bc 10402DE9 		stmfd	sp!, {r4, lr}
 1143              	.LCFI9:
 1144              		.cfi_def_cfa_offset 8
2382:../uvc.c      **** {
 1145              		.loc 1 2382 0
 1146 08c0 0120A0E1 		mov	r2, r1
2383:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1147              		.loc 1 2383 0
 1148 08c4 1080BD18 		ldmnefd	sp!, {r4, pc}
 1149              		.cfi_offset 14, -4
 1150              		.cfi_offset 4, -8
 1151              	.LVL87:
 1152              	.LBB56:
 1153              	.LBB57:
2280:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1154              		.loc 1 2280 0
 1155 08c8 CC309FE5 		ldr	r3, .L92
 1156 08cc 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1157 08d0 030053E3 		cmp	r3, #3
 1158 08d4 2100000A 		beq	.L91
2306:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1159              		.loc 1 2306 0
 1160 08d8 020053E3 		cmp	r3, #2
 1161 08dc 1080BD18 		ldmnefd	sp!, {r4, pc}
2308:../uvc.c      ****         switch (stateId)
 1162              		.loc 1 2308 0
 1163 08e0 080041E2 		sub	r0, r1, #8
 1164              	.LVL88:
 1165 08e4 0A0050E3 		cmp	r0, #10
 1166 08e8 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1167 08ec 230000EA 		b	.L84
 1168              	.L86:
 1169 08f0 20090000 		.word	.L81
 1170 08f4 80090000 		.word	.L84
 1171 08f8 80090000 		.word	.L84
 1172 08fc 1C090000 		.word	.L77
 1173 0900 80090000 		.word	.L84
 1174 0904 80090000 		.word	.L84
 1175 0908 80090000 		.word	.L84
 1176 090c 58090000 		.word	.L90
 1177 0910 80090000 		.word	.L84
 1178 0914 80090000 		.word	.L84
 1179 0918 1C090000 		.word	.L77
 1180              	.LVL89:
 1181              	.L77:
 1182 091c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1183              	.LVL90:
 1184              	.L81:
2291:../uvc.c      ****                 socket = 0;
 1185              		.loc 1 2291 0
 1186 0920 0010A0E3 		mov	r1, #0
 1187              	.LVL91:
 1188              	.L82:
2365:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1189              		.loc 1 2365 0
 1190 0924 74009FE5 		ldr	r0, .L92+4
 1191 0928 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1192              	.LVL92:
2366:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1193              		.loc 1 2366 0
 1194 092c 002050E2 		subs	r2, r0, #0
 1195 0930 F9FFFF0A 		beq	.L77
2368:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1196              		.loc 1 2368 0
 1197 0934 0400A0E3 		mov	r0, #4
 1198              	.LVL93:
 1199 0938 64109FE5 		ldr	r1, .L92+8
 1200 093c FEFFFFEB 		bl	CyU3PDebugPrint
 1201              	.LVL94:
 1202              	.L87:
 1203              	.LBB58:
 1204              	.LBB59:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1205              		.loc 1 1970 0
 1206 0940 60109FE5 		ldr	r1, .L92+12
 1207 0944 0400A0E3 		mov	r0, #4
 1208 0948 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 1209              		.loc 1 1971 0
 1210 094c FA0FA0E3 		mov	r0, #1000
 1211 0950 FEFFFFEB 		bl	_tx_thread_sleep
 1212 0954 F9FFFFEA 		b	.L87
 1213              	.LVL95:
 1214              	.L90:
 1215              	.LBE59:
 1216              	.LBE58:
2335:../uvc.c      ****                 socket = 1;
 1217              		.loc 1 2335 0
 1218 0958 0110A0E3 		mov	r1, #1
 1219              	.LVL96:
 1220 095c F0FFFFEA 		b	.L82
 1221              	.LVL97:
 1222              	.L91:
2282:../uvc.c      ****         switch (stateId)
 1223              		.loc 1 2282 0
 1224 0960 0B2041E2 		sub	r2, r1, #11
 1225 0964 030052E3 		cmp	r2, #3
 1226 0968 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1227 096c 060000EA 		b	.L80
 1228              	.L83:
 1229 0970 20090000 		.word	.L81
 1230 0974 58090000 		.word	.L90
 1231 0978 1C090000 		.word	.L77
 1232 097c 1C090000 		.word	.L77
 1233              	.LVL98:
 1234              	.L84:
2354:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1235              		.loc 1 2354 0
 1236 0980 24109FE5 		ldr	r1, .L92+16
 1237              	.LVL99:
 1238 0984 0100A0E3 		mov	r0, #1
 1239 0988 FEFFFFEB 		bl	CyU3PDebugPrint
 1240              	.LVL100:
 1241              	.L80:
 1242              	.LBE57:
 1243              	.LBE56:
2389:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1244              		.loc 1 2389 0
 1245 098c 1C109FE5 		ldr	r1, .L92+20
 1246 0990 0400A0E3 		mov	r0, #4
2392:../uvc.c      **** }
 1247              		.loc 1 2392 0
 1248 0994 1040BDE8 		ldmfd	sp!, {r4, lr}
2389:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1249              		.loc 1 2389 0
 1250 0998 FEFFFFEA 		b	CyU3PDebugPrint
 1251              	.L93:
 1252              		.align	2
 1253              	.L92:
 1254 099c 00000000 		.word	.LANCHOR0
 1255 09a0 00000000 		.word	glChHandleUVCStream
 1256 09a4 C0010000 		.word	.LC12
 1257 09a8 F0010000 		.word	.LC13
 1258 09ac A8010000 		.word	.LC11
 1259 09b0 04020000 		.word	.LC14
 1260              		.cfi_endproc
 1261              	.LFE13:
 1263              		.align	2
 1264              		.global	I2CCmdHandler
 1266              	I2CCmdHandler:
 1267              	.LFB0:
 607:../uvc.c      **** void I2CCmdHandler(){
 1268              		.loc 1 607 0
 1269              		.cfi_startproc
 1270              		@ args = 0, pretend = 0, frame = 16
 1271              		@ frame_needed = 0, uses_anonymous_args = 0
 1272 09b4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1273              	.LCFI10:
 1274              		.cfi_def_cfa_offset 36
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1275              		.loc 1 610 0
 1276 09b8 40429FE5 		ldr	r4, .L109
 1277              		.cfi_offset 14, -4
 1278              		.cfi_offset 11, -8
 1279              		.cfi_offset 10, -12
 1280              		.cfi_offset 9, -16
 1281              		.cfi_offset 8, -20
 1282              		.cfi_offset 7, -24
 1283              		.cfi_offset 6, -28
 1284              		.cfi_offset 5, -32
 1285              		.cfi_offset 4, -36
 607:../uvc.c      **** void I2CCmdHandler(){
 1286              		.loc 1 607 0
 1287 09bc 3CD04DE2 		sub	sp, sp, #60
 1288              	.LCFI11:
 1289              		.cfi_def_cfa_offset 96
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1290              		.loc 1 615 0
 1291 09c0 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1292              		.loc 1 610 0
 1293 09c4 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1294              	.LVL101:
 611:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1295              		.loc 1 611 0
 1296 09c8 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1297              	.LVL102:
 612:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1298              		.loc 1 612 0
 1299 09cc 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1300              	.LVL103:
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1301              		.loc 1 615 0
 1302 09d0 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1303 09d4 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1304 09d8 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1305 09dc 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1306 09e0 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1307 09e4 14208DE5 		str	r2, [sp, #20]
 1308 09e8 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1309 09ec 0730A0E1 		mov	r3, r7
 1310 09f0 1C108DE5 		str	r1, [sp, #28]
 1311 09f4 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1312 09f8 0400A0E3 		mov	r0, #4
 1313 09fc 00129FE5 		ldr	r1, .L109+4
 1314 0a00 0520A0E1 		mov	r2, r5
 1315 0a04 00E08DE5 		str	lr, [sp, #0]
 1316 0a08 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1317 0a0c 0C908DE5 		str	r9, [sp, #12]
 1318 0a10 10B08DE5 		str	fp, [sp, #16]
 1319 0a14 18608DE5 		str	r6, [sp, #24]
 1320 0a18 20C08DE5 		str	ip, [sp, #32]
 1321 0a1c FEFFFFEB 		bl	CyU3PDebugPrint
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1322              		.loc 1 618 0
 1323 0a20 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1324 0a24 520053E3 		cmp	r3, #82
 1325 0a28 2C00000A 		beq	.L105
 1326              	.L95:
 628:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1327              		.loc 1 628 0
 1328 0a2c 000055E3 		cmp	r5, #0
 1329 0a30 1600000A 		beq	.L106
 653:../uvc.c      **** 	}else if(CmdType == 1){
 1330              		.loc 1 653 0
 1331 0a34 010055E3 		cmp	r5, #1
 1332 0a38 0100000A 		beq	.L107
 1333              	.LVL104:
 1334              	.L94:
 672:../uvc.c      **** }
 1335              		.loc 1 672 0
 1336 0a3c 3CD08DE2 		add	sp, sp, #60
 1337 0a40 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1338              	.LVL105:
 1339              	.L107:
 655:../uvc.c      **** 			if(CmdRegLen == 2){
 1340              		.loc 1 655 0
 1341 0a44 020057E3 		cmp	r7, #2
 1342 0a48 3700000A 		beq	.L108
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1343              		.loc 1 660 0
 1344 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1345 0a50 A8319FE5 		ldr	r3, .L109
 1346 0a54 FE1001E2 		and	r1, r1, #254
 1347 0a58 820051E3 		cmp	r1, #130
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1348              		.loc 1 663 0
 1349 0a5c 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1350              	.LVL106:
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1351              		.loc 1 660 0
 1352 0a60 0200001A 		bne	.L104
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1353              		.loc 1 660 0 is_stmt 0 discriminator 1
 1354 0a64 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1355 0a68 300055E3 		cmp	r5, #48
 1356 0a6c 4F00000A 		beq	.L102
 1357              	.L104:
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1358              		.loc 1 663 0 is_stmt 1
 1359 0a70 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1360              	.L103:
 665:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1361              		.loc 1 665 0
 1362 0a74 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1363 0a78 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1364 0a7c FE0002E2 		and	r0, r2, #254
 1365 0a80 0520A0E1 		mov	r2, r5
 1366 0a84 00E08DE5 		str	lr, [sp, #0]
 1367 0a88 FEFFFFEB 		bl	SensorWrite2B
 1368 0a8c EAFFFFEA 		b	.L94
 1369              	.LVL107:
 1370              	.L106:
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1371              		.loc 1 644 0
 1372 0a90 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1373 0a94 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1374              		.loc 1 630 0
 1375 0a98 0FE0A0E3 		mov	lr, #15
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1376              		.loc 1 644 0
 1377 0a9c 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1378 0aa0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1379              		.loc 1 630 0
 1380 0aa4 57E0C4E5 		strb	lr, [r4, #87]
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1381              		.loc 1 644 0
 1382 0aa8 34C08DE2 		add	ip, sp, #52
 1383 0aac 010080E3 		orr	r0, r0, #1
 1384 0ab0 011081E3 		orr	r1, r1, #1
 1385 0ab4 00C08DE5 		str	ip, [sp, #0]
 1386 0ab8 FEFFFFEB 		bl	SensorRead2B
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1387              		.loc 1 645 0
 1388 0abc 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 646:../uvc.c      **** 				if(CmdDataLen == 2){
 1389              		.loc 1 646 0
 1390 0ac0 020056E3 		cmp	r6, #2
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1391              		.loc 1 645 0
 1392 0ac4 5530C4E5 		strb	r3, [r4, #85]
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1393              		.loc 1 647 0
 1394 0ac8 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1395 0acc 2C319F05 		ldreq	r3, .L109
 649:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1396              		.loc 1 649 0
 1397 0ad0 0020E0E3 		mvn	r2, #0
 1398 0ad4 5720C4E5 		strb	r2, [r4, #87]
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1399              		.loc 1 647 0
 1400 0ad8 5600C305 		streqb	r0, [r3, #86]
 1401 0adc D6FFFFEA 		b	.L94
 1402              	.L105:
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1403              		.loc 1 618 0 discriminator 1
 1404 0ae0 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1405 0ae4 300050E3 		cmp	r0, #48
 1406 0ae8 CFFFFF1A 		bne	.L95
 1407 0aec 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1408 0af0 010053E3 		cmp	r3, #1
 1409 0af4 CCFFFF1A 		bne	.L95
 620:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1410              		.loc 1 620 0
 1411 0af8 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1412 0afc 04C19FE5 		ldr	ip, .L109+8
 1413 0b00 031002E2 		and	r1, r2, #3
 1414 0b04 8C14CCE5 		strb	r1, [ip, #1164]
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 1415              		.loc 1 621 0
 1416 0b08 58E094E5 		ldr	lr, [r4, #88]
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1417              		.loc 1 625 0
 1418 0b0c F8109FE5 		ldr	r1, .L109+12
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 1419              		.loc 1 621 0
 1420 0b10 00005EE3 		cmp	lr, #0
 623:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1421              		.loc 1 623 0
 1422 0b14 80208203 		orreq	r2, r2, #128
 1423 0b18 5520C405 		streqb	r2, [r4, #85]
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1424              		.loc 1 625 0
 1425 0b1c 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1426 0b20 0400A0E3 		mov	r0, #4
 1427 0b24 FEFFFFEB 		bl	CyU3PDebugPrint
 1428 0b28 BFFFFFEA 		b	.L95
 1429              	.L108:
 657:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1430              		.loc 1 657 0
 1431 0b2c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1432 0b30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1433 0b34 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1434 0b38 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1435 0b3c 0020A0E3 		mov	r2, #0
 1436 0b40 FE0000E2 		and	r0, r0, #254
 1437 0b44 00E08DE5 		str	lr, [sp, #0]
 1438 0b48 FEFFFFEB 		bl	SensorWrite2B2
 1439 0b4c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1440 0b50 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1441 0b54 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1442 0b58 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1443 0b5c FE0002E2 		and	r0, r2, #254
 1444 0b60 0020A0E3 		mov	r2, #0
 1445 0b64 00C08DE5 		str	ip, [sp, #0]
 1446 0b68 FEFFFFEB 		bl	SensorWrite2B2
 1447              	.LVL108:
 1448 0b6c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1449 0b70 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1450 0b74 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1451 0b78 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1452 0b7c 0020A0E3 		mov	r2, #0
 1453 0b80 FE0000E2 		and	r0, r0, #254
 1454 0b84 00C08DE5 		str	ip, [sp, #0]
 1455 0b88 FEFFFFEB 		bl	SensorWrite2B2
 1456 0b8c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1457 0b90 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1458 0b94 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1459 0b98 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1460 0b9c FE0002E2 		and	r0, r2, #254
 1461 0ba0 0020A0E3 		mov	r2, #0
 1462 0ba4 00C08DE5 		str	ip, [sp, #0]
 1463 0ba8 FEFFFFEB 		bl	SensorWrite2B2
 1464 0bac A2FFFFEA 		b	.L94
 1465              	.LVL109:
 1466              	.L102:
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1467              		.loc 1 660 0 discriminator 1
 1468 0bb0 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1469 0bb4 100053E3 		cmp	r3, #16
 1470 0bb8 ADFFFF1A 		bne	.L103
 661:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1471              		.loc 1 661 0
 1472 0bbc 4C409FE5 		ldr	r4, .L109+16
 1473 0bc0 0010E0E3 		mvn	r1, #0
 1474 0bc4 1C0094E5 		ldr	r0, [r4, #28]
 1475 0bc8 2C308DE5 		str	r3, [sp, #44]
 1476 0bcc FEFFFFEB 		bl	_txe_mutex_get
 662:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1477              		.loc 1 662 0
 1478 0bd0 2C309DE5 		ldr	r3, [sp, #44]
 1479 0bd4 00C0A0E3 		mov	ip, #0
 1480 0bd8 0320A0E1 		mov	r2, r3
 1481 0bdc 0400A0E1 		mov	r0, r4
 1482 0be0 1710A0E3 		mov	r1, #23
 1483 0be4 0530A0E1 		mov	r3, r5
 1484 0be8 00C08DE5 		str	ip, [sp, #0]
 1485 0bec 04C08DE5 		str	ip, [sp, #4]
 1486 0bf0 FEFFFFEB 		bl	cmdSet
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1487              		.loc 1 663 0
 1488 0bf4 1C0094E5 		ldr	r0, [r4, #28]
 1489 0bf8 FEFFFFEB 		bl	_txe_mutex_put
 1490 0bfc 8EFFFFEA 		b	.L94
 1491              	.L110:
 1492              		.align	2
 1493              	.L109:
 1494 0c00 00000000 		.word	.LANCHOR0
 1495 0c04 1C020000 		.word	.LC15
 1496 0c08 00000000 		.word	.LANCHOR1
 1497 0c0c 68020000 		.word	.LC16
 1498 0c10 00000000 		.word	cmdQu
 1499              		.cfi_endproc
 1500              	.LFE0:
 1502              		.align	2
 1503              		.global	setIrisauto
 1505              	setIrisauto:
 1506              	.LFB1:
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1507              		.loc 1 678 0
 1508              		.cfi_startproc
 1509              		@ args = 0, pretend = 0, frame = 0
 1510              		@ frame_needed = 0, uses_anonymous_args = 0
 1511              	.LVL110:
 1512 0c14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1513              	.LCFI12:
 1514              		.cfi_def_cfa_offset 16
 1515 0c18 0160A0E1 		mov	r6, r1
 1516              		.cfi_offset 14, -4
 1517              		.cfi_offset 6, -8
 1518              		.cfi_offset 5, -12
 1519              		.cfi_offset 4, -16
 1520 0c1c 08D04DE2 		sub	sp, sp, #8
 1521              	.LCFI13:
 1522              		.cfi_def_cfa_offset 24
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1523              		.loc 1 678 0
 1524 0c20 0040A0E1 		mov	r4, r0
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1525              		.loc 1 681 0
 1526 0c24 0050A0E3 		mov	r5, #0
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1527              		.loc 1 680 0
 1528 0c28 0010E0E3 		mvn	r1, #0
 1529              	.LVL111:
 1530 0c2c 1C0090E5 		ldr	r0, [r0, #28]
 1531              	.LVL112:
 1532 0c30 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1533              		.loc 1 681 0
 1534 0c34 060065E0 		rsb	r0, r5, r6
 1535 0c38 00C070E2 		rsbs	ip, r0, #0
 1536 0c3c 00C0ACE0 		adc	ip, ip, r0
 1537 0c40 2010A0E3 		mov	r1, #32
 1538 0c44 2720A0E3 		mov	r2, #39
 1539 0c48 3030A0E3 		mov	r3, #48
 1540 0c4c 0400A0E1 		mov	r0, r4
 1541 0c50 00C08DE5 		str	ip, [sp, #0]
 1542 0c54 04508DE5 		str	r5, [sp, #4]
 1543 0c58 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1544              		.loc 1 682 0
 1545 0c5c 050056E1 		cmp	r6, r5
 1546 0c60 0260A003 		moveq	r6, #2
 1547 0c64 0160A013 		movne	r6, #1
 1548 0c68 0400A0E1 		mov	r0, r4
 1549 0c6c 2110A0E3 		mov	r1, #33
 1550 0c70 2520A0E3 		mov	r2, #37
 1551 0c74 3030A0E3 		mov	r3, #48
 1552 0c78 00608DE5 		str	r6, [sp, #0]
 1553 0c7c 04508DE5 		str	r5, [sp, #4]
 1554 0c80 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1555              		.loc 1 683 0
 1556 0c84 1C0094E5 		ldr	r0, [r4, #28]
 684:../uvc.c      **** }
 1557              		.loc 1 684 0
 1558 0c88 08D08DE2 		add	sp, sp, #8
 1559 0c8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1560              		.loc 1 683 0
 1561 0c90 FEFFFFEA 		b	_txe_mutex_put
 1562              		.cfi_endproc
 1563              	.LFE1:
 1565              		.align	2
 1566              		.global	getShutCtrl
 1568              	getShutCtrl:
 1569              	.LFB2:
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1570              		.loc 1 688 0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 0
 1573              		@ frame_needed = 0, uses_anonymous_args = 0
 1574              	.LVL113:
 693:../uvc.c      **** 	switch (Data){
 1575              		.loc 1 693 0
 1576 0c94 013040E2 		sub	r3, r0, #1
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1577              		.loc 1 688 0
 1578 0c98 10402DE9 		stmfd	sp!, {r4, lr}
 1579              	.LCFI14:
 1580              		.cfi_def_cfa_offset 8
 1581 0c9c 08D04DE2 		sub	sp, sp, #8
 1582              	.LCFI15:
 1583              		.cfi_def_cfa_offset 16
 693:../uvc.c      **** 	switch (Data){
 1584              		.loc 1 693 0
 1585 0ca0 090053E3 		cmp	r3, #9
 1586 0ca4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1587 0ca8 380000EA 		b	.L115
 1588              		.cfi_offset 14, -4
 1589              		.cfi_offset 4, -8
 1590              	.L118:
 1591 0cac 440D0000 		.word	.L116
 1592 0cb0 440D0000 		.word	.L116
 1593 0cb4 440D0000 		.word	.L116
 1594 0cb8 440D0000 		.word	.L116
 1595 0cbc 440D0000 		.word	.L116
 1596 0cc0 D40C0000 		.word	.L117
 1597 0cc4 D40C0000 		.word	.L117
 1598 0cc8 D40C0000 		.word	.L117
 1599 0ccc D40C0000 		.word	.L117
 1600 0cd0 D40C0000 		.word	.L117
 1601              	.L117:
 1602              	.LVL114:
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1603              		.loc 1 717 0
 1604 0cd4 ECC09FE5 		ldr	ip, .L127
 715:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1605              		.loc 1 715 0
 1606 0cd8 8330A0E1 		mov	r3, r3, asl #1
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1607              		.loc 1 717 0
 1608 0cdc B3309CE1 		ldrh	r3, [ip, r3]
 1609 0ce0 E4E09FE5 		ldr	lr, .L127+4
 1610 0ce4 032263E0 		rsb	r2, r3, r3, asl #4
 1611 0ce8 8240A0E1 		mov	r4, r2, asl #1
 1612 0cec 94CECEE0 		smull	ip, lr, r4, lr
 1613 0cf0 C4CFA0E1 		mov	ip, r4, asr #31
 1614 0cf4 4E246CE0 		rsb	r2, ip, lr, asr #8
 718:../uvc.c      **** 		if(NumLn > 1944)
 1615              		.loc 1 718 0
 1616 0cf8 D0E09FE5 		ldr	lr, .L127+8
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1617              		.loc 1 717 0
 1618 0cfc 0228A0E1 		mov	r2, r2, asl #16
 1619 0d00 22C8A0E1 		mov	ip, r2, lsr #16
 1620              	.LVL115:
 718:../uvc.c      **** 		if(NumLn > 1944)
 1621              		.loc 1 718 0
 1622 0d04 0E005CE1 		cmp	ip, lr
 1623 0d08 2600008A 		bhi	.L124
 720:../uvc.c      **** 		else if(NumLn < 8)
 1624              		.loc 1 720 0
 1625 0d0c 07005CE3 		cmp	ip, #7
 1626 0d10 2700008A 		bhi	.L126
 1627              	.LVL116:
 1628              	.L125:
 1629 0d14 01C0A0E3 		mov	ip, #1
 1630 0d18 08E0A0E3 		mov	lr, #8
 1631 0d1c 0C40A0E1 		mov	r4, ip
 1632              	.L121:
 1633              	.LVL117:
 723:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1634              		.loc 1 723 0
 1635 0d20 0120A0E3 		mov	r2, #1
 1636 0d24 0020C1E5 		strb	r2, [r1, #0]
 724:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1637              		.loc 1 724 0
 1638 0d28 0020A0E1 		mov	r2, r0
 1639 0d2c A0109FE5 		ldr	r1, .L127+12
 1640              	.LVL118:
 1641 0d30 0400A0E3 		mov	r0, #4
 1642              	.LVL119:
 1643 0d34 00E08DE5 		str	lr, [sp, #0]
 1644 0d38 04C08DE5 		str	ip, [sp, #4]
 1645 0d3c FEFFFFEB 		bl	CyU3PDebugPrint
 725:../uvc.c      **** 		break;
 1646              		.loc 1 725 0
 1647 0d40 150000EA 		b	.L120
 1648              	.LVL120:
 1649              	.L116:
 699:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1650              		.loc 1 699 0
 1651 0d44 7CE09FE5 		ldr	lr, .L127
 1652 0d48 8330A0E1 		mov	r3, r3, asl #1
 1653 0d4c B3309EE1 		ldrh	r3, [lr, r3]
 1654              	.LVL121:
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1655              		.loc 1 701 0
 1656 0d50 80C09FE5 		ldr	ip, .L127+16
 702:../uvc.c      **** 		if(NumLn > 1944)
 1657              		.loc 1 702 0
 1658 0d54 74E09FE5 		ldr	lr, .L127+8
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1659              		.loc 1 701 0
 1660 0d58 932C8CE0 		umull	r2, ip, r3, ip
 1661 0d5c AC24A0E1 		mov	r2, ip, lsr #9
 1662 0d60 024262E0 		rsb	r4, r2, r2, asl #4
 1663 0d64 8448A0E1 		mov	r4, r4, asl #17
 1664 0d68 2428A0E1 		mov	r2, r4, lsr #16
 1665              	.LVL122:
 702:../uvc.c      **** 		if(NumLn > 1944)
 1666              		.loc 1 702 0
 1667 0d6c 0E0052E1 		cmp	r2, lr
 1668 0d70 0C00008A 		bhi	.L124
 704:../uvc.c      **** 		else if(NumLn < 8)
 1669              		.loc 1 704 0
 1670 0d74 070052E3 		cmp	r2, #7
 1671 0d78 E5FFFF9A 		bls	.L125
 1672 0d7c A449A0E1 		mov	r4, r4, lsr #19
 1673 0d80 FF4004E2 		and	r4, r4, #255
 1674 0d84 02E0A0E1 		mov	lr, r2
 1675 0d88 04C0A0E1 		mov	ip, r4
 1676 0d8c E3FFFFEA 		b	.L121
 1677              	.LVL123:
 1678              	.L115:
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1679              		.loc 1 728 0
 1680 0d90 0000A0E3 		mov	r0, #0
 1681              	.LVL124:
 729:../uvc.c      **** 		LnVal = 1;
 1682              		.loc 1 729 0
 1683 0d94 0140A0E3 		mov	r4, #1
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1684              		.loc 1 728 0
 1685 0d98 0000C1E5 		strb	r0, [r1, #0]
 1686              	.LVL125:
 1687              	.L120:
 733:../uvc.c      **** }
 1688              		.loc 1 733 0
 1689 0d9c 0400A0E1 		mov	r0, r4
 1690 0da0 08D08DE2 		add	sp, sp, #8
 1691 0da4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1692              	.LVL126:
 1693              	.L124:
 718:../uvc.c      **** 		if(NumLn > 1944)
 1694              		.loc 1 718 0
 1695 0da8 F3C0A0E3 		mov	ip, #243
 1696 0dac 0C40A0E1 		mov	r4, ip
 1697 0db0 DAFFFFEA 		b	.L121
 1698              	.LVL127:
 1699              	.L126:
 720:../uvc.c      **** 		else if(NumLn < 8)
 1700              		.loc 1 720 0
 1701 0db4 A2E9A0E1 		mov	lr, r2, lsr #19
 1702 0db8 FF400EE2 		and	r4, lr, #255
 1703 0dbc 0CE0A0E1 		mov	lr, ip
 1704 0dc0 04C0A0E1 		mov	ip, r4
 1705              	.LVL128:
 1706 0dc4 D5FFFFEA 		b	.L121
 1707              	.L128:
 1708              		.align	2
 1709              	.L127:
 1710 0dc8 00000000 		.word	.LANCHOR2
 1711 0dcc 817F807F 		.word	2139127681
 1712 0dd0 98070000 		.word	1944
 1713 0dd4 90020000 		.word	.LC17
 1714 0dd8 01FF00FF 		.word	-16711935
 1715              		.cfi_endproc
 1716              	.LFE2:
 1718              		.align	2
 1719              		.global	ControlHandle
 1721              	ControlHandle:
 1722              	.LFB3:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1723              		.loc 1 735 0
 1724              		.cfi_startproc
 1725              		@ args = 0, pretend = 0, frame = 24
 1726              		@ frame_needed = 0, uses_anonymous_args = 0
 1727              	.LVL129:
 1728 0ddc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1729              	.LCFI16:
 1730              		.cfi_def_cfa_offset 36
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1731              		.loc 1 742 0
 1732 0de0 230050E3 		cmp	r0, #35
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1733              		.loc 1 741 0
 1734 0de4 207040E2 		sub	r7, r0, #32
 1735              		.cfi_offset 14, -4
 1736              		.cfi_offset 11, -8
 1737              		.cfi_offset 10, -12
 1738              		.cfi_offset 9, -16
 1739              		.cfi_offset 8, -20
 1740              		.cfi_offset 7, -24
 1741              		.cfi_offset 6, -28
 1742              		.cfi_offset 5, -32
 1743              		.cfi_offset 4, -36
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1744              		.loc 1 735 0
 1745 0de8 2CD04DE2 		sub	sp, sp, #44
 1746              	.LCFI17:
 1747              		.cfi_def_cfa_offset 80
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1748              		.loc 1 735 0
 1749 0dec 0040A0E1 		mov	r4, r0
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1750              		.loc 1 741 0
 1751 0df0 FF7007E2 		and	r7, r7, #255
 1752              	.LVL130:
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1753              		.loc 1 742 0
 1754 0df4 2300009A 		bls	.L130
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1755              		.loc 1 743 0
 1756 0df8 506F9FE5 		ldr	r6, .L303
 1757 0dfc 872087E0 		add	r2, r7, r7, asl #1
 1758 0e00 8221A0E1 		mov	r2, r2, asl #3
 1759 0e04 023086E0 		add	r3, r6, r2
 744:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1760              		.loc 1 744 0
 1761 0e08 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 745:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1762              		.loc 1 745 0
 1763 0e0c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 746:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1764              		.loc 1 746 0
 1765 0e10 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 757:../uvc.c      ****     reqData = bRequest;
 1766              		.loc 1 757 0
 1767 0e14 383F9FE5 		ldr	r3, .L303+4
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1768              		.loc 1 743 0
 1769 0e18 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1770              	.LVL131:
 757:../uvc.c      ****     reqData = bRequest;
 1771              		.loc 1 757 0
 1772 0e1c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1773              	.LVL132:
 765:../uvc.c      ****     switch (bRequest)
 1774              		.loc 1 765 0
 1775 0e20 830055E3 		cmp	r5, #131
 1776 0e24 2200000A 		beq	.L136
 1777              	.LVL133:
 1778              	.L294:
 1779 0e28 2B00009A 		bls	.L292
 1780 0e2c 850055E3 		cmp	r5, #133
 1781 0e30 8800000A 		beq	.L138
 1782 0e34 7600003A 		bcc	.L137
 1783 0e38 860055E3 		cmp	r5, #134
 1784 0e3c C500000A 		beq	.L139
 1785 0e40 870055E3 		cmp	r5, #135
 1786 0e44 B900000A 		beq	.L293
 1787              	.L132:
1616:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1788              		.loc 1 1616 0
 1789 0e48 0000A0E3 		mov	r0, #0
 1790              	.LVL134:
 1791 0e4c 0110A0E3 		mov	r1, #1
 1792 0e50 0020A0E1 		mov	r2, r0
 1793 0e54 FEFFFFEB 		bl	CyU3PUsbStall
1617:../uvc.c      **** 			  break;
 1794              		.loc 1 1617 0
 1795 0e58 FFA0A0E3 		mov	sl, #255
 1796 0e5c 0A70A0E1 		mov	r7, sl
 1797              	.LVL135:
 1798 0e60 0A40A0E1 		mov	r4, sl
 1799 0e64 0A80A0E1 		mov	r8, sl
 1800              	.LVL136:
 1801              	.L142:
1619:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1802              		.loc 1 1619 0
 1803 0e68 E81E9FE5 		ldr	r1, .L303+8
 1804 0e6c 0520A0E1 		mov	r2, r5
 1805 0e70 0830A0E1 		mov	r3, r8
 1806 0e74 0400A0E3 		mov	r0, #4
 1807 0e78 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 1808 0e7c FEFFFFEB 		bl	CyU3PDebugPrint
1620:../uvc.c      **** }
 1809              		.loc 1 1620 0
 1810 0e80 2CD08DE2 		add	sp, sp, #44
 1811 0e84 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1812              	.LVL137:
 1813              	.L130:
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1814              		.loc 1 748 0
 1815 0e88 C06E9FE5 		ldr	r6, .L303
 757:../uvc.c      ****     reqData = bRequest;
 1816              		.loc 1 757 0
 1817 0e8c C03E9FE5 		ldr	r3, .L303+4
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1818              		.loc 1 748 0
 1819 0e90 808080E0 		add	r8, r0, r0, asl #1
 1820 0e94 885186E0 		add	r5, r6, r8, asl #3
 1821 0e98 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 1822              	.LVL138:
 749:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1823              		.loc 1 749 0
 1824 0e9c 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 1825              	.LVL139:
 750:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1826              		.loc 1 750 0
 1827 0ea0 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 1828              	.LVL140:
 751:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1829              		.loc 1 751 0
 1830 0ea4 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 1831              	.LVL141:
 757:../uvc.c      ****     reqData = bRequest;
 1832              		.loc 1 757 0
 1833 0ea8 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1834              	.LVL142:
 765:../uvc.c      ****     switch (bRequest)
 1835              		.loc 1 765 0
 1836 0eac 830055E3 		cmp	r5, #131
 1837 0eb0 DCFFFF1A 		bne	.L294
 1838              	.LVL143:
 1839              	.L136:
1100:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1840              		.loc 1 1100 0
 1841 0eb4 230054E3 		cmp	r4, #35
 1842 0eb8 C400009A 		bls	.L202
1101:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1843              		.loc 1 1101 0
 1844 0ebc 87E087E0 		add	lr, r7, r7, asl #1
 1845 0ec0 8E6186E0 		add	r6, r6, lr, asl #3
 1846 0ec4 D49E9FE5 		ldr	r9, .L303+80
 1847 0ec8 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
1102:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1848              		.loc 1 1102 0
 1849 0ecc 0610D6E5 		ldrb	r1, [r6, #6]	@ zero_extendqisi2
1101:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1850              		.loc 1 1101 0
 1851 0ed0 5CC0C9E5 		strb	ip, [r9, #92]
1102:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1852              		.loc 1 1102 0
 1853 0ed4 5D10C9E5 		strb	r1, [r9, #93]
 1854 0ed8 0B0000EA 		b	.L210
 1855              	.L292:
 765:../uvc.c      ****     switch (bRequest)
 1856              		.loc 1 765 0
 1857 0edc 810055E3 		cmp	r5, #129
 1858 0ee0 6800000A 		beq	.L134
 1859 0ee4 1000009A 		bls	.L295
1081:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1860              		.loc 1 1081 0
 1861 0ee8 230054E3 		cmp	r4, #35
 1862 0eec AB00009A 		bls	.L199
1082:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1863              		.loc 1 1082 0
 1864 0ef0 879087E0 		add	r9, r7, r7, asl #1
 1865 0ef4 896186E0 		add	r6, r6, r9, asl #3
 1866 0ef8 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 1867 0efc 9C9E9FE5 		ldr	r9, .L303+80
1083:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1868              		.loc 1 1083 0
 1869 0f00 0470D6E5 		ldrb	r7, [r6, #4]	@ zero_extendqisi2
 1870              	.LVL144:
1082:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1871              		.loc 1 1082 0
 1872 0f04 5C20C9E5 		strb	r2, [r9, #92]
1083:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1873              		.loc 1 1083 0
 1874 0f08 5D70C9E5 		strb	r7, [r9, #93]
 1875              	.LVL145:
 1876              	.L210:
1158:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1877              		.loc 1 1158 0
 1878 0f0c 0800A0E1 		mov	r0, r8
1160:../uvc.c      **** 			  break;
 1879              		.loc 1 1160 0
 1880 0f10 FFA0A0E3 		mov	sl, #255
1158:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1881              		.loc 1 1158 0
 1882 0f14 401E9FE5 		ldr	r1, .L303+12
 1883 0f18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1884              	.LVL146:
1160:../uvc.c      **** 			  break;
 1885              		.loc 1 1160 0
 1886 0f1c 0A40A0E1 		mov	r4, sl
1158:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1887              		.loc 1 1158 0
 1888 0f20 5C70D9E5 		ldrb	r7, [r9, #92]	@ zero_extendqisi2
1160:../uvc.c      **** 			  break;
 1889              		.loc 1 1160 0
 1890 0f24 0A80A0E1 		mov	r8, sl
 1891 0f28 CEFFFFEA 		b	.L142
 1892              	.LVL147:
 1893              	.L295:
 765:../uvc.c      ****     switch (bRequest)
 1894              		.loc 1 765 0
 1895 0f2c 010055E3 		cmp	r5, #1
 1896 0f30 C4FFFF1A 		bne	.L132
1162:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1897              		.loc 1 1162 0
 1898 0f34 643E9FE5 		ldr	r3, .L303+80
 1899 0f38 26208DE2 		add	r2, sp, #38
 1900 0f3c 2000A0E3 		mov	r0, #32
 1901              	.LVL148:
 1902 0f40 5C1083E2 		add	r1, r3, #92
 1903 0f44 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1904              	.LVL149:
1164:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1905              		.loc 1 1164 0
 1906 0f48 002050E2 		subs	r2, r0, #0
 1907 0f4c 3A04001A 		bne	.L212
1167:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1908              		.loc 1 1167 0
 1909 0f50 480E9FE5 		ldr	r0, .L303+80
 1910              	.LVL150:
1166:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1911              		.loc 1 1166 0
 1912 0f54 441E9FE5 		ldr	r1, .L303+80
1167:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1913              		.loc 1 1167 0
 1914 0f58 5DC0D0E5 		ldrb	ip, [r0, #93]	@ zero_extendqisi2
1166:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1915              		.loc 1 1166 0
 1916 0f5c 5C30D1E5 		ldrb	r3, [r1, #92]	@ zero_extendqisi2
1169:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1917              		.loc 1 1169 0
 1918 0f60 5E00D0E5 		ldrb	r0, [r0, #94]	@ zero_extendqisi2
1166:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1919              		.loc 1 1166 0
 1920 0f64 18308DE5 		str	r3, [sp, #24]
 1921              	.LVL151:
1169:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1922              		.loc 1 1169 0
 1923 0f68 1C008DE5 		str	r0, [sp, #28]
 1924              	.LVL152:
1173:../uvc.c      **** 				  switch(CtrlID)
 1925              		.loc 1 1173 0
 1926 0f6c 260054E3 		cmp	r4, #38
 1927 0f70 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1928 0f74 170400EA 		b	.L213
 1929              	.L231:
 1930 0f78 6C1F0000 		.word	.L214
 1931 0f7c 001F0000 		.word	.L215
 1932 0f80 A01B0000 		.word	.L216
 1933 0f84 D81F0000 		.word	.L213
 1934 0f88 501B0000 		.word	.L217
 1935 0f8c 141A0000 		.word	.L218
 1936 0f90 9C190000 		.word	.L219
 1937 0f94 A41D0000 		.word	.L220
 1938 0f98 D81F0000 		.word	.L213
 1939 0f9c D81F0000 		.word	.L213
 1940 0fa0 D81F0000 		.word	.L213
 1941 0fa4 D01C0000 		.word	.L221
 1942 0fa8 D81F0000 		.word	.L213
 1943 0fac D81F0000 		.word	.L213
 1944 0fb0 D81F0000 		.word	.L213
 1945 0fb4 D81F0000 		.word	.L213
 1946 0fb8 241E0000 		.word	.L222
 1947 0fbc D81F0000 		.word	.L213
 1948 0fc0 D81F0000 		.word	.L213
 1949 0fc4 D81F0000 		.word	.L213
 1950 0fc8 D81F0000 		.word	.L213
 1951 0fcc D81F0000 		.word	.L213
 1952 0fd0 D81F0000 		.word	.L213
 1953 0fd4 D81F0000 		.word	.L213
 1954 0fd8 D81F0000 		.word	.L213
 1955 0fdc FC1B0000 		.word	.L223
 1956 0fe0 A01B0000 		.word	.L216
 1957 0fe4 08190000 		.word	.L224
 1958 0fe8 7C180000 		.word	.L225
 1959 0fec D81F0000 		.word	.L213
 1960 0ff0 20180000 		.word	.L226
 1961 0ff4 9C170000 		.word	.L227
 1962 0ff8 D81F0000 		.word	.L213
 1963 0ffc D81F0000 		.word	.L213
 1964 1000 D81F0000 		.word	.L213
 1965 1004 D81F0000 		.word	.L213
 1966 1008 80160000 		.word	.L228
 1967 100c 0C160000 		.word	.L229
 1968 1010 20170000 		.word	.L230
 1969              	.LVL153:
 1970              	.L137:
1118:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1971              		.loc 1 1118 0
 1972 1014 230054E3 		cmp	r4, #35
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1973              		.loc 1 1125 0
 1974 1018 84408490 		addls	r4, r4, r4, asl #1
1119:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1975              		.loc 1 1119 0
 1976 101c 87708780 		addhi	r7, r7, r7, asl #1
 1977              	.LVL154:
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1978              		.loc 1 1125 0
 1979 1020 84618690 		addls	r6, r6, r4, asl #3
1119:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1980              		.loc 1 1119 0
 1981 1024 87618680 		addhi	r6, r6, r7, asl #3
 1982 1028 709D9F85 		ldrhi	r9, .L303+80
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1983              		.loc 1 1125 0
 1984 102c 6C9D9F95 		ldrls	r9, .L303+80
1119:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1985              		.loc 1 1119 0
 1986 1030 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1120:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1987              		.loc 1 1120 0
 1988 1034 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1989              		.loc 1 1125 0
 1990 1038 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1126:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1991              		.loc 1 1126 0
 1992 103c 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1127:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1993              		.loc 1 1127 0
 1994 1040 0040A0E3 		mov	r4, #0
1125:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1995              		.loc 1 1125 0
 1996 1044 5C10C9E5 		strb	r1, [r9, #92]
1126:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1997              		.loc 1 1126 0
 1998 1048 5D20C9E5 		strb	r2, [r9, #93]
1127:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1999              		.loc 1 1127 0
 2000 104c 5E40C9E5 		strb	r4, [r9, #94]
1128:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2001              		.loc 1 1128 0
 2002 1050 5F40C9E5 		strb	r4, [r9, #95]
 2003 1054 ACFFFFEA 		b	.L210
 2004              	.LVL155:
 2005              	.L138:
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2006              		.loc 1 769 0
 2007 1058 404D9FE5 		ldr	r4, .L303+80
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2008              		.loc 1 770 0
 2009 105c 00A0A0E3 		mov	sl, #0
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2010              		.loc 1 769 0
 2011 1060 5C80C4E5 		strb	r8, [r4, #92]
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2012              		.loc 1 770 0
 2013 1064 5DA0C4E5 		strb	sl, [r4, #93]
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2014              		.loc 1 771 0
 2015 1068 5C1084E2 		add	r1, r4, #92
 773:../uvc.c      **** 			  break;
 2016              		.loc 1 773 0
 2017 106c FFA0A0E3 		mov	sl, #255
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2018              		.loc 1 771 0
 2019 1070 0200A0E3 		mov	r0, #2
 2020              	.LVL156:
 2021 1074 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2022              	.LVL157:
 773:../uvc.c      **** 			  break;
 2023              		.loc 1 773 0
 2024 1078 0A80A0E1 		mov	r8, sl
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2025              		.loc 1 771 0
 2026 107c 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 2027              	.LVL158:
 773:../uvc.c      **** 			  break;
 2028              		.loc 1 773 0
 2029 1080 0A40A0E1 		mov	r4, sl
 2030 1084 77FFFFEA 		b	.L142
 2031              	.LVL159:
 2032              	.L134:
 776:../uvc.c      **** 			 switch(CtrlID)
 2033              		.loc 1 776 0
 2034 1088 260054E3 		cmp	r4, #38
 2035 108c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2036 1090 FE0000EA 		b	.L143
 2037              	.L159:
 2038 1094 88150000 		.word	.L144
 2039 1098 C0140000 		.word	.L145
 2040 109c 34150000 		.word	.L146
 2041 10a0 90140000 		.word	.L143
 2042 10a4 44140000 		.word	.L147
 2043 10a8 DC150000 		.word	.L148
 2044 10ac 90140000 		.word	.L143
 2045 10b0 5C150000 		.word	.L149
 2046 10b4 90140000 		.word	.L143
 2047 10b8 B4150000 		.word	.L150
 2048 10bc 90140000 		.word	.L143
 2049 10c0 6C140000 		.word	.L151
 2050 10c4 90140000 		.word	.L143
 2051 10c8 90140000 		.word	.L143
 2052 10cc 90140000 		.word	.L143
 2053 10d0 90140000 		.word	.L143
 2054 10d4 F0130000 		.word	.L152
 2055 10d8 90140000 		.word	.L143
 2056 10dc 90140000 		.word	.L143
 2057 10e0 90140000 		.word	.L143
 2058 10e4 90140000 		.word	.L143
 2059 10e8 90140000 		.word	.L143
 2060 10ec 90140000 		.word	.L143
 2061 10f0 90140000 		.word	.L143
 2062 10f4 90140000 		.word	.L143
 2063 10f8 84130000 		.word	.L153
 2064 10fc 34150000 		.word	.L146
 2065 1100 F0140000 		.word	.L154
 2066 1104 5C130000 		.word	.L155
 2067 1108 90140000 		.word	.L143
 2068 110c 90140000 		.word	.L143
 2069 1110 C0120000 		.word	.L156
 2070 1114 90140000 		.word	.L143
 2071 1118 90140000 		.word	.L143
 2072 111c 90140000 		.word	.L143
 2073 1120 90140000 		.word	.L143
 2074 1124 84120000 		.word	.L157
 2075 1128 84120000 		.word	.L157
 2076 112c 4C120000 		.word	.L158
 2077              	.L293:
1145:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2078              		.loc 1 1145 0
 2079 1130 230054E3 		cmp	r4, #35
 2080 1134 3100009A 		bls	.L209
1146:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2081              		.loc 1 1146 0
 2082 1138 87A087E0 		add	sl, r7, r7, asl #1
 2083 113c 8A6186E0 		add	r6, r6, sl, asl #3
 2084 1140 589C9FE5 		ldr	r9, .L303+80
 2085 1144 0B30D6E5 		ldrb	r3, [r6, #11]	@ zero_extendqisi2
1147:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2086              		.loc 1 1147 0
 2087 1148 0C00D6E5 		ldrb	r0, [r6, #12]	@ zero_extendqisi2
 2088              	.LVL160:
1146:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2089              		.loc 1 1146 0
 2090 114c 5C30C9E5 		strb	r3, [r9, #92]
1147:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2091              		.loc 1 1147 0
 2092 1150 5D00C9E5 		strb	r0, [r9, #93]
 2093 1154 6CFFFFEA 		b	.L210
 2094              	.LVL161:
 2095              	.L139:
1134:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2096              		.loc 1 1134 0
 2097 1158 230054E3 		cmp	r4, #35
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2098              		.loc 1 1135 0
 2099 115c 87708780 		addhi	r7, r7, r7, asl #1
 2100              	.LVL162:
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2101              		.loc 1 1138 0
 2102 1160 84408490 		addls	r4, r4, r4, asl #1
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2103              		.loc 1 1135 0
 2104 1164 87618680 		addhi	r6, r6, r7, asl #3
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2105              		.loc 1 1138 0
 2106 1168 84618690 		addls	r6, r6, r4, asl #3
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2107              		.loc 1 1135 0
 2108 116c 2C8C9F85 		ldrhi	r8, .L303+80
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2109              		.loc 1 1138 0
 2110 1170 288C9F95 		ldrls	r8, .L303+80
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2111              		.loc 1 1135 0
 2112 1174 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2113              		.loc 1 1138 0
 2114 1178 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1143:../uvc.c      **** 			  break;
 2115              		.loc 1 1143 0
 2116 117c FFA0A0E3 		mov	sl, #255
1138:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2117              		.loc 1 1138 0
 2118 1180 5C30C8E5 		strb	r3, [r8, #92]
1140:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2119              		.loc 1 1140 0
 2120 1184 0100A0E3 		mov	r0, #1
 2121              	.LVL163:
 2122 1188 CC1B9FE5 		ldr	r1, .L303+12
 2123 118c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2124              	.LVL164:
1143:../uvc.c      **** 			  break;
 2125              		.loc 1 1143 0
 2126 1190 0A40A0E1 		mov	r4, sl
1140:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2127              		.loc 1 1140 0
 2128 1194 5C70D8E5 		ldrb	r7, [r8, #92]	@ zero_extendqisi2
1143:../uvc.c      **** 			  break;
 2129              		.loc 1 1143 0
 2130 1198 0A80A0E1 		mov	r8, sl
 2131 119c 31FFFFEA 		b	.L142
 2132              	.LVL165:
 2133              	.L199:
1086:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2134              		.loc 1 1086 0
 2135 11a0 0B0054E3 		cmp	r4, #11
1093:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2136              		.loc 1 1093 0
 2137 11a4 84408410 		addne	r4, r4, r4, asl #1
 2138 11a8 84618610 		addne	r6, r6, r4, asl #3
 2139 11ac EC9B9F15 		ldrne	r9, .L303+80
1087:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2140              		.loc 1 1087 0
 2141 11b0 E89B9F05 		ldreq	r9, .L303+80
 2142 11b4 A43B9F05 		ldreq	r3, .L303+16
1093:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2143              		.loc 1 1093 0
 2144 11b8 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1094:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2145              		.loc 1 1094 0
 2146 11bc 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1087:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2147              		.loc 1 1087 0
 2148 11c0 5C308905 		streq	r3, [r9, #92]
1093:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2149              		.loc 1 1093 0
 2150 11c4 5C20C915 		strneb	r2, [r9, #92]
1094:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2151              		.loc 1 1094 0
 2152 11c8 5D30C915 		strneb	r3, [r9, #93]
 2153 11cc 4EFFFFEA 		b	.L210
 2154              	.L202:
1104:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2155              		.loc 1 1104 0
 2156 11d0 0B0054E3 		cmp	r4, #11
1111:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2157              		.loc 1 1111 0
 2158 11d4 84408410 		addne	r4, r4, r4, asl #1
 2159 11d8 84618610 		addne	r6, r6, r4, asl #3
 2160 11dc BC9B9F15 		ldrne	r9, .L303+80
1105:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2161              		.loc 1 1105 0
 2162 11e0 B89B9F05 		ldreq	r9, .L303+80
 2163 11e4 783B9F05 		ldreq	r3, .L303+20
1111:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2164              		.loc 1 1111 0
 2165 11e8 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1112:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2166              		.loc 1 1112 0
 2167 11ec 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1105:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2168              		.loc 1 1105 0
 2169 11f0 5C308905 		streq	r3, [r9, #92]
1111:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2170              		.loc 1 1111 0
 2171 11f4 5C20C915 		strneb	r2, [r9, #92]
1112:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2172              		.loc 1 1112 0
 2173 11f8 5D30C915 		strneb	r3, [r9, #93]
 2174 11fc 42FFFFEA 		b	.L210
 2175              	.L209:
1149:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2176              		.loc 1 1149 0
 2177 1200 0B0054E3 		cmp	r4, #11
 2178 1204 0700000A 		beq	.L296
1155:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2179              		.loc 1 1155 0
 2180 1208 849084E0 		add	r9, r4, r4, asl #1
 2181 120c 896186E0 		add	r6, r6, r9, asl #3
 2182 1210 8BE1D6E5 		ldrb	lr, [r6, #395]	@ zero_extendqisi2
 2183 1214 849B9FE5 		ldr	r9, .L303+80
1156:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2184              		.loc 1 1156 0
 2185 1218 8CC1D6E5 		ldrb	ip, [r6, #396]	@ zero_extendqisi2
1155:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2186              		.loc 1 1155 0
 2187 121c 5CE0C9E5 		strb	lr, [r9, #92]
1156:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2188              		.loc 1 1156 0
 2189 1220 5DC0C9E5 		strb	ip, [r9, #93]
 2190 1224 38FFFFEA 		b	.L210
 2191              	.L296:
1150:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2192              		.loc 1 1150 0
 2193 1228 709B9FE5 		ldr	r9, .L303+80
 2194 122c 9312D6E5 		ldrb	r1, [r6, #659]	@ zero_extendqisi2
1152:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2195              		.loc 1 1152 0
 2196 1230 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
1151:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2197              		.loc 1 1151 0
 2198 1234 0070A0E3 		mov	r7, #0
 2199              	.LVL166:
1150:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2200              		.loc 1 1150 0
 2201 1238 5C10C9E5 		strb	r1, [r9, #92]
1151:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2202              		.loc 1 1151 0
 2203 123c 5D70C9E5 		strb	r7, [r9, #93]
1152:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2204              		.loc 1 1152 0
 2205 1240 5E20C9E5 		strb	r2, [r9, #94]
1153:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2206              		.loc 1 1153 0
 2207 1244 5F70C9E5 		strb	r7, [r9, #95]
 2208 1248 2FFFFFEA 		b	.L210
 2209              	.LVL167:
 2210              	.L158:
 800:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2211              		.loc 1 800 0
 2212 124c 4C4B9FE5 		ldr	r4, .L303+80
 2213 1250 A2B0D4E5 		ldrb	fp, [r4, #162]	@ zero_extendqisi2
 2214 1254 00005BE3 		cmp	fp, #0
 2215 1258 C603000A 		beq	.L165
 801:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2216              		.loc 1 801 0
 2217 125c 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2218              	.LVL168:
 802:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2219              		.loc 1 802 0
 2220 1260 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 801:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2221              		.loc 1 801 0
 2222 1264 5C70C4E5 		strb	r7, [r4, #92]
 802:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2223              		.loc 1 802 0
 2224 1268 5DA0C4E5 		strb	sl, [r4, #93]
 2225              	.LVL169:
 2226              	.L164:
1074:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2227              		.loc 1 1074 0
 2228 126c 0800A0E1 		mov	r0, r8
 2229 1270 E41A9FE5 		ldr	r1, .L303+12
 2230 1274 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1079:../uvc.c      **** 			  break;
 2231              		.loc 1 1079 0
 2232 1278 FF40A0E3 		mov	r4, #255
 2233 127c 0480A0E1 		mov	r8, r4
 2234 1280 F8FEFFEA 		b	.L142
 2235              	.LVL170:
 2236              	.L157:
 783:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2237              		.loc 1 783 0
 2238 1284 146B9FE5 		ldr	r6, .L303+80
 2239 1288 04B086E0 		add	fp, r6, r4
 2240 128c 7C00DBE5 		ldrb	r0, [fp, #124]	@ zero_extendqisi2
 2241              	.LVL171:
 2242 1290 000050E3 		cmp	r0, #0
 2243 1294 C503000A 		beq	.L162
 784:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2244              		.loc 1 784 0
 2245 1298 E83A9FE5 		ldr	r3, .L303+56
 2246 129c 047183E0 		add	r7, r3, r4, asl #2
 2247              	.LVL172:
 2248 12a0 20C017E5 		ldr	ip, [r7, #-32]
 2249 12a4 0DE0DCE5 		ldrb	lr, [ip, #13]	@ zero_extendqisi2
 2250 12a8 FF700EE2 		and	r7, lr, #255
 2251 12ac 5C70C6E5 		strb	r7, [r6, #92]
 785:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2252              		.loc 1 785 0
 2253 12b0 0E10DCE5 		ldrb	r1, [ip, #14]	@ zero_extendqisi2
 2254 12b4 FFA001E2 		and	sl, r1, #255
 2255 12b8 5DA0C6E5 		strb	sl, [r6, #93]
 2256 12bc EAFFFFEA 		b	.L164
 2257              	.LVL173:
 2258              	.L156:
 878:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2259              		.loc 1 878 0 discriminator 1
 2260 12c0 000058E3 		cmp	r8, #0
 2261 12c4 A104000A 		beq	.L288
 876:../uvc.c      **** 					 break;
 2262              		.loc 1 876 0
 2263 12c8 28E1A0E1 		mov	lr, r8, lsr #2
 2264 12cc 00005EE3 		cmp	lr, #0
 2265 12d0 03005813 		cmpne	r8, #3
 2266 12d4 0020A083 		movhi	r2, #0
 2267 12d8 0120A093 		movls	r2, #1
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2268              		.loc 1 735 0
 2269 12dc 0E31A0E1 		mov	r3, lr, asl #2
 876:../uvc.c      **** 					 break;
 2270              		.loc 1 876 0
 2271 12e0 9E04009A 		bls	.L268
 2272 12e4 701A9FE5 		ldr	r1, .L303+12
 2273 12e8 100041E2 		sub	r0, r1, #16
 2274              	.LVL174:
 2275              	.L176:
 879:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2276              		.loc 1 879 0 discriminator 2
 2277 12ec 044090E4 		ldr	r4, [r0], #4
 2278 12f0 01A082E2 		add	sl, r2, #1
 2279 12f4 FF200AE2 		and	r2, sl, #255
 2280 12f8 02005EE1 		cmp	lr, r2
 2281 12fc 044081E4 		str	r4, [r1], #4
 2282 1300 F9FFFF8A 		bhi	.L176
 879:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2283              		.loc 1 879 0 is_stmt 0
 2284 1304 030058E1 		cmp	r8, r3
 2285 1308 900A9F15 		ldrne	r0, .L303+80
 2286 130c 8F04000A 		beq	.L288
 2287              	.LVL175:
 2288              	.L281:
 2289 1310 03C080E0 		add	ip, r0, r3
 2290 1314 4C70DCE5 		ldrb	r7, [ip, #76]	@ zero_extendqisi2
 878:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2291              		.loc 1 878 0 is_stmt 1
 2292 1318 013083E2 		add	r3, r3, #1
 2293 131c FF3003E2 		and	r3, r3, #255
 2294              	.LVL176:
 2295 1320 030058E1 		cmp	r8, r3
 879:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2296              		.loc 1 879 0
 2297 1324 5C70CCE5 		strb	r7, [ip, #92]
 878:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2298              		.loc 1 878 0
 2299 1328 F8FFFF8A 		bhi	.L281
 2300              	.LVL177:
 2301              	.L161:
 888:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2302              		.loc 1 888 0
 2303 132c 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 881:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2304              		.loc 1 881 0
 2305 1330 683A9FE5 		ldr	r3, .L303+80
 888:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2306              		.loc 1 888 0
 2307 1334 FF0052E3 		cmp	r2, #255
 881:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2308              		.loc 1 881 0
 2309 1338 6570D0E5 		ldrb	r7, [r0, #101]	@ zero_extendqisi2
 2310              	.LVL178:
 882:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2311              		.loc 1 882 0
 2312 133c 66A0D0E5 		ldrb	sl, [r0, #102]	@ zero_extendqisi2
 2313              	.LVL179:
 888:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2314              		.loc 1 888 0
 2315 1340 C9FFFF0A 		beq	.L164
 890:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2316              		.loc 1 890 0
 2317 1344 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2318 1348 181A9FE5 		ldr	r1, .L303+24
 2319 134c 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2320 1350 0400A0E3 		mov	r0, #4
 2321 1354 FEFFFFEB 		bl	CyU3PDebugPrint
 2322 1358 C3FFFFEA 		b	.L164
 2323              	.LVL180:
 2324              	.L155:
 865:../uvc.c      **** 					 if(CamMode == 1){//720p
 2325              		.loc 1 865 0
 2326 135c 3C4A9FE5 		ldr	r4, .L303+80
 863:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2327              		.loc 1 863 0
 2328 1360 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2329              	.LVL181:
 865:../uvc.c      **** 					 if(CamMode == 1){//720p
 2330              		.loc 1 865 0
 2331 1364 BC20D4E5 		ldrb	r2, [r4, #188]	@ zero_extendqisi2
 2332 1368 010052E3 		cmp	r2, #1
 2333 136c 4404000A 		beq	.L297
 2334              	.LVL182:
 2335              	.L289:
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2336              		.loc 1 965 0
 2337 1370 0030A0E3 		mov	r3, #0
 964:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2338              		.loc 1 964 0
 2339 1374 5C70C4E5 		strb	r7, [r4, #92]
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2340              		.loc 1 965 0
 2341 1378 5D30C4E5 		strb	r3, [r4, #93]
 2342              	.LVL183:
 753:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2343              		.loc 1 753 0
 2344 137c FFA0A0E3 		mov	sl, #255
 967:../uvc.c      **** 					 break;
 2345              		.loc 1 967 0
 2346 1380 B9FFFFEA 		b	.L164
 2347              	.LVL184:
 2348              	.L153:
 900:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2349              		.loc 1 900 0
 2350 1384 144A9FE5 		ldr	r4, .L303+80
 894:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2351              		.loc 1 894 0
 2352 1388 B804D6E5 		ldrb	r0, [r6, #1208]	@ zero_extendqisi2
 2353              	.LVL185:
 900:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2354              		.loc 1 900 0
 2355 138c 95A0D4E5 		ldrb	sl, [r4, #149]	@ zero_extendqisi2
 895:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2356              		.loc 1 895 0
 2357 1390 B9E4D6E5 		ldrb	lr, [r6, #1209]	@ zero_extendqisi2
 896:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2358              		.loc 1 896 0
 2359 1394 C714D6E5 		ldrb	r1, [r6, #1223]	@ zero_extendqisi2
 900:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2360              		.loc 1 900 0
 2361 1398 00005AE3 		cmp	sl, #0
 894:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2362              		.loc 1 894 0
 2363 139c AC699FE5 		ldr	r6, .L303
 2364 13a0 FF0000E2 		and	r0, r0, #255
 2365              	.LVL186:
 895:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2366              		.loc 1 895 0
 2367 13a4 FFA00EE2 		and	sl, lr, #255
 2368              	.LVL187:
 896:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2369              		.loc 1 896 0
 2370 13a8 FF7001E2 		and	r7, r1, #255
 2371              	.LVL188:
 900:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2372              		.loc 1 900 0
 2373 13ac 8E03000A 		beq	.L179
 901:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2374              		.loc 1 901 0
 2375 13b0 C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
 902:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2376              		.loc 1 902 0
 2377 13b4 C674D6E5 		ldrb	r7, [r6, #1222]	@ zero_extendqisi2
 2378              	.LVL189:
 901:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2379              		.loc 1 901 0
 2380 13b8 5CC0C4E5 		strb	ip, [r4, #92]
 902:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2381              		.loc 1 902 0
 2382 13bc 5E70C4E5 		strb	r7, [r4, #94]
 2383              	.LVL190:
 2384              	.L180:
 919:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2385              		.loc 1 919 0
 2386 13c0 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 2387              	.LVL191:
 920:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2388              		.loc 1 920 0
 2389 13c4 5EA0D4E5 		ldrb	sl, [r4, #94]	@ zero_extendqisi2
 2390              	.LVL192:
 916:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2391              		.loc 1 916 0
 2392 13c8 00E0A0E3 		mov	lr, #0
 2393 13cc 5DE0C4E5 		strb	lr, [r4, #93]
 918:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2394              		.loc 1 918 0
 2395 13d0 5FE0C4E5 		strb	lr, [r4, #95]
 921:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2396              		.loc 1 921 0
 2397 13d4 90199FE5 		ldr	r1, .L303+28
 2398 13d8 0720A0E1 		mov	r2, r7
 2399 13dc 0E30A0E1 		mov	r3, lr
 2400 13e0 0400A0E3 		mov	r0, #4
 2401 13e4 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2402 13e8 FEFFFFEB 		bl	CyU3PDebugPrint
 922:../uvc.c      **** 					 break;
 2403              		.loc 1 922 0
 2404 13ec 9EFFFFEA 		b	.L164
 2405              	.LVL193:
 2406              	.L152:
 825:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2407              		.loc 1 825 0
 2408 13f0 A8499FE5 		ldr	r4, .L303+80
 818:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2409              		.loc 1 818 0
 2410 13f4 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
 825:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2411              		.loc 1 825 0
 2412 13f8 8CE0D4E5 		ldrb	lr, [r4, #140]	@ zero_extendqisi2
 819:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2413              		.loc 1 819 0
 2414 13fc 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 825:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2415              		.loc 1 825 0
 2416 1400 00005EE3 		cmp	lr, #0
 818:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2417              		.loc 1 818 0
 2418 1404 44399FE5 		ldr	r3, .L303
 820:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2419              		.loc 1 820 0
 2420 1408 9F24D6E5 		ldrb	r2, [r6, #1183]	@ zero_extendqisi2
 825:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2421              		.loc 1 825 0
 2422 140c 8303000A 		beq	.L169
 826:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2423              		.loc 1 826 0
 2424 1410 9D74D3E5 		ldrb	r7, [r3, #1181]	@ zero_extendqisi2
 2425              	.LVL194:
 827:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2426              		.loc 1 827 0
 2427 1414 9E34D3E5 		ldrb	r3, [r3, #1182]	@ zero_extendqisi2
 826:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2428              		.loc 1 826 0
 2429 1418 FF7007E2 		and	r7, r7, #255
 2430 141c 5C70C4E5 		strb	r7, [r4, #92]
 827:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2431              		.loc 1 827 0
 2432 1420 5D30C4E5 		strb	r3, [r4, #93]
 2433              	.LVL195:
 2434              	.L170:
 840:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2435              		.loc 1 840 0
 2436 1424 03A0A0E3 		mov	sl, #3
 2437 1428 40199FE5 		ldr	r1, .L303+32
 2438 142c 0720A0E1 		mov	r2, r7
 2439 1430 0730A0E1 		mov	r3, r7
 2440 1434 0400A0E3 		mov	r0, #4
 2441 1438 00A08DE5 		str	sl, [sp, #0]
 2442 143c FEFFFFEB 		bl	CyU3PDebugPrint
 841:../uvc.c      **** 			 		 break;
 2443              		.loc 1 841 0
 2444 1440 89FFFFEA 		b	.L164
 2445              	.LVL196:
 2446              	.L147:
1039:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2447              		.loc 1 1039 0
 2448 1444 54499FE5 		ldr	r4, .L303+80
 2449 1448 8020D4E5 		ldrb	r2, [r4, #128]	@ zero_extendqisi2
 2450 144c 000052E3 		cmp	r2, #0
 2451 1450 1403000A 		beq	.L195
1041:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
 2452              		.loc 1 1041 0
 2453 1454 ED11D6E5 		ldrb	r1, [r6, #493]	@ zero_extendqisi2
1042:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2454              		.loc 1 1042 0
 2455 1458 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1041:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
 2456              		.loc 1 1041 0
 2457 145c 807001E2 		and	r7, r1, #128
 2458              	.LVL197:
 2459 1460 5C70C4E5 		strb	r7, [r4, #92]
1042:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2460              		.loc 1 1042 0
 2461 1464 5DA0C4E5 		strb	sl, [r4, #93]
 2462 1468 7FFFFFEA 		b	.L164
 2463              	.LVL198:
 2464              	.L151:
 969:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2465              		.loc 1 969 0
 2466 146c 2C299FE5 		ldr	r2, .L303+80
 2467 1470 CC74D6E5 		ldrb	r7, [r6, #1228]	@ zero_extendqisi2
 2468              	.LVL199:
 971:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2469              		.loc 1 971 0
 2470 1474 CEA4D6E5 		ldrb	sl, [r6, #1230]	@ zero_extendqisi2
 970:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2471              		.loc 1 970 0
 2472 1478 0040A0E3 		mov	r4, #0
 969:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2473              		.loc 1 969 0
 2474 147c 5C70C2E5 		strb	r7, [r2, #92]
 970:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2475              		.loc 1 970 0
 2476 1480 5D40C2E5 		strb	r4, [r2, #93]
 971:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2477              		.loc 1 971 0
 2478 1484 5EA0C2E5 		strb	sl, [r2, #94]
 972:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2479              		.loc 1 972 0
 2480 1488 5F40C2E5 		strb	r4, [r2, #95]
 2481              	.LVL200:
 975:../uvc.c      **** 					 break;
 2482              		.loc 1 975 0
 2483 148c 76FFFFEA 		b	.L164
 2484              	.LVL201:
 2485              	.L143:
1058:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2486              		.loc 1 1058 0
 2487 1490 08B99FE5 		ldr	fp, .L303+80
 2488 1494 04308BE0 		add	r3, fp, r4
 2489 1498 7CE0D3E5 		ldrb	lr, [r3, #124]	@ zero_extendqisi2
 2490 149c 00005EE3 		cmp	lr, #0
 2491 14a0 7703000A 		beq	.L197
1059:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2492              		.loc 1 1059 0
 2493 14a4 844084E0 		add	r4, r4, r4, asl #1
 2494 14a8 846186E0 		add	r6, r6, r4, asl #3
 2495 14ac 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2496              	.LVL202:
1060:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2497              		.loc 1 1060 0
 2498 14b0 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1059:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2499              		.loc 1 1059 0
 2500 14b4 5C70CBE5 		strb	r7, [fp, #92]
1060:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2501              		.loc 1 1060 0
 2502 14b8 5DA0CBE5 		strb	sl, [fp, #93]
 2503 14bc 6AFFFFEA 		b	.L164
 2504              	.LVL203:
 2505              	.L145:
 938:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2506              		.loc 1 938 0
 2507 14c0 D8489FE5 		ldr	r4, .L303+80
 2508 14c4 7D10D4E5 		ldrb	r1, [r4, #125]	@ zero_extendqisi2
 2509 14c8 000051E3 		cmp	r1, #0
 939:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2510              		.loc 1 939 0
 2511 14cc A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2512              	.LVL204:
 938:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2513              		.loc 1 938 0
 2514 14d0 2103000A 		beq	.L298
 2515              	.L182:
 2516              	.LVL205:
 946:../uvc.c      **** 					  if(Data0&0x80){
 2517              		.loc 1 946 0
 2518 14d4 800010E3 		tst	r0, #128
 947:../uvc.c      **** 						  Data0 = ~Data0;
 2519              		.loc 1 947 0
 2520 14d8 0000E011 		mvnne	r0, r0
 2521              	.LVL206:
 2522 14dc FF700012 		andne	r7, r0, #255
 2523              	.LVL207:
 946:../uvc.c      **** 					  if(Data0&0x80){
 2524              		.loc 1 946 0
 2525 14e0 A2FFFF1A 		bne	.L289
 2526              	.L186:
 2527              	.LVL208:
 964:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2528              		.loc 1 964 0
 2529 14e4 800040E2 		sub	r0, r0, #128
 2530              	.LVL209:
 2531 14e8 FF7000E2 		and	r7, r0, #255
 2532 14ec 9FFFFFEA 		b	.L289
 2533              	.LVL210:
 2534              	.L154:
 850:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2535              		.loc 1 850 0
 2536 14f0 A8489FE5 		ldr	r4, .L303+80
 843:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2537              		.loc 1 843 0
 2538 14f4 A434D6E5 		ldrb	r3, [r6, #1188]	@ zero_extendqisi2
 850:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2539              		.loc 1 850 0
 2540 14f8 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 844:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2541              		.loc 1 844 0
 2542 14fc A504D6E5 		ldrb	r0, [r6, #1189]	@ zero_extendqisi2
 2543              	.LVL211:
 845:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2544              		.loc 1 845 0
 2545 1500 B314D6E5 		ldrb	r1, [r6, #1203]	@ zero_extendqisi2
 850:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2546              		.loc 1 850 0
 2547 1504 000053E3 		cmp	r3, #0
 843:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2548              		.loc 1 843 0
 2549 1508 40689FE5 		ldr	r6, .L303
 844:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2550              		.loc 1 844 0
 2551 150c FF0000E2 		and	r0, r0, #255
 2552              	.LVL212:
 845:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2553              		.loc 1 845 0
 2554 1510 FF1001E2 		and	r1, r1, #255
 2555              	.LVL213:
 850:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2556              		.loc 1 850 0
 2557 1514 5003000A 		beq	.L171
 851:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2558              		.loc 1 851 0
 2559 1518 B174D6E5 		ldrb	r7, [r6, #1201]	@ zero_extendqisi2
 2560              	.LVL214:
 852:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2561              		.loc 1 852 0
 2562 151c B2A4D6E5 		ldrb	sl, [r6, #1202]	@ zero_extendqisi2
 851:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2563              		.loc 1 851 0
 2564 1520 FF7007E2 		and	r7, r7, #255
 852:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2565              		.loc 1 852 0
 2566 1524 FFA00AE2 		and	sl, sl, #255
 851:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2567              		.loc 1 851 0
 2568 1528 5C70C4E5 		strb	r7, [r4, #92]
 852:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2569              		.loc 1 852 0
 2570 152c 5DA0C4E5 		strb	sl, [r4, #93]
 2571 1530 4DFFFFEA 		b	.L164
 2572              	.LVL215:
 2573              	.L146:
1010:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2574              		.loc 1 1010 0
 2575 1534 64B89FE5 		ldr	fp, .L303+80
 2576 1538 04408BE0 		add	r4, fp, r4
 2577 153c 7CE0D4E5 		ldrb	lr, [r4, #124]	@ zero_extendqisi2
 2578 1540 00005EE3 		cmp	lr, #0
 2579 1544 EE02000A 		beq	.L191
1011:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2580              		.loc 1 1011 0
 2581 1548 BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
 2582              	.LVL216:
1012:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2583              		.loc 1 1012 0
 2584 154c BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1011:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2585              		.loc 1 1011 0
 2586 1550 5C70CBE5 		strb	r7, [fp, #92]
1012:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2587              		.loc 1 1012 0
 2588 1554 5DA0CBE5 		strb	sl, [fp, #93]
 2589 1558 43FFFFEA 		b	.L164
 2590              	.LVL217:
 2591              	.L149:
 993:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2592              		.loc 1 993 0
 2593 155c 3C489FE5 		ldr	r4, .L303+80
 2594 1560 8370D4E5 		ldrb	r7, [r4, #131]	@ zero_extendqisi2
 2595              	.LVL218:
 2596 1564 000057E3 		cmp	r7, #0
 2597 1568 5403000A 		beq	.L189
 994:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2598              		.loc 1 994 0
 2599 156c F124D6E5 		ldrb	r2, [r6, #1265]	@ zero_extendqisi2
 995:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2600              		.loc 1 995 0
 2601 1570 F204D6E5 		ldrb	r0, [r6, #1266]	@ zero_extendqisi2
 2602              	.LVL219:
 994:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2603              		.loc 1 994 0
 2604 1574 FF7002E2 		and	r7, r2, #255
 995:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2605              		.loc 1 995 0
 2606 1578 FFA000E2 		and	sl, r0, #255
 994:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2607              		.loc 1 994 0
 2608 157c 5C70C4E5 		strb	r7, [r4, #92]
 995:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2609              		.loc 1 995 0
 2610 1580 5DA0C4E5 		strb	sl, [r4, #93]
 2611 1584 38FFFFEA 		b	.L164
 2612              	.LVL220:
 2613              	.L144:
 977:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2614              		.loc 1 977 0
 2615 1588 10489FE5 		ldr	r4, .L303+80
 2616 158c 7CE0D4E5 		ldrb	lr, [r4, #124]	@ zero_extendqisi2
 2617 1590 00005EE3 		cmp	lr, #0
 2618 1594 CE02000A 		beq	.L187
 978:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2619              		.loc 1 978 0
 2620 1598 DDA4D6E5 		ldrb	sl, [r6, #1245]	@ zero_extendqisi2
 979:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2621              		.loc 1 979 0
 2622 159c DE14D6E5 		ldrb	r1, [r6, #1246]	@ zero_extendqisi2
 978:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2623              		.loc 1 978 0
 2624 15a0 FF700AE2 		and	r7, sl, #255
 2625              	.LVL221:
 979:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2626              		.loc 1 979 0
 2627 15a4 FFA001E2 		and	sl, r1, #255
 978:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2628              		.loc 1 978 0
 2629 15a8 5C70C4E5 		strb	r7, [r4, #92]
 979:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2630              		.loc 1 979 0
 2631 15ac 5DA0C4E5 		strb	sl, [r4, #93]
 2632 15b0 2DFFFFEA 		b	.L164
 2633              	.LVL222:
 2634              	.L150:
1023:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2635              		.loc 1 1023 0
 2636 15b4 E4479FE5 		ldr	r4, .L303+80
 2637 15b8 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
 2638 15bc 000053E3 		cmp	r3, #0
 2639 15c0 DA02000A 		beq	.L193
1025:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2640              		.loc 1 1025 0
 2641 15c4 6572D6E5 		ldrb	r7, [r6, #613]	@ zero_extendqisi2
 2642              	.LVL223:
1026:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2643              		.loc 1 1026 0
 2644 15c8 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1025:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2645              		.loc 1 1025 0
 2646 15cc 037007E2 		and	r7, r7, #3
 2647 15d0 5C70C4E5 		strb	r7, [r4, #92]
1026:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2648              		.loc 1 1026 0
 2649 15d4 5DA0C4E5 		strb	sl, [r4, #93]
 2650 15d8 23FFFFEA 		b	.L164
 2651              	.LVL224:
 2652              	.L148:
 956:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2653              		.loc 1 956 0
 2654 15dc BC479FE5 		ldr	r4, .L303+80
 2655 15e0 8170D4E5 		ldrb	r7, [r4, #129]	@ zero_extendqisi2
 2656              	.LVL225:
 2657 15e4 000057E3 		cmp	r7, #0
 957:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2658              		.loc 1 957 0
 2659 15e8 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2660              	.LVL226:
 956:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2661              		.loc 1 956 0
 2662 15ec BCFFFF1A 		bne	.L186
 959:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 2663              		.loc 1 959 0
 2664 15f0 0A00A0E1 		mov	r0, sl
 2665 15f4 0910A0E1 		mov	r1, r9
 2666 15f8 FEFFFFEB 		bl	SensorGetControl
 2667              	.LVL227:
 961:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 2668              		.loc 1 961 0
 2669 15fc 01C0A0E3 		mov	ip, #1
 2670 1600 81C0C4E5 		strb	ip, [r4, #129]
 960:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 2671              		.loc 1 960 0
 2672 1604 0502C6E5 		strb	r0, [r6, #517]
 2673 1608 B5FFFFEA 		b	.L186
 2674              	.LVL228:
 2675              	.L229:
1371:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2676              		.loc 1 1371 0
 2677 160c 0C25D6E5 		ldrb	r2, [r6, #1292]	@ zero_extendqisi2
 2678              	.LVL229:
1376:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2679              		.loc 1 1376 0
 2680 1610 7C479FE5 		ldr	r4, .L303+68
1372:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2681              		.loc 1 1372 0
 2682 1614 0D35D6E5 		ldrb	r3, [r6, #1293]	@ zero_extendqisi2
1373:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2683              		.loc 1 1373 0
 2684 1618 1BE5D6E5 		ldrb	lr, [r6, #1307]	@ zero_extendqisi2
1371:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2685              		.loc 1 1371 0
 2686 161c FF8002E2 		and	r8, r2, #255
 2687              	.LVL230:
1376:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2688              		.loc 1 1376 0
 2689 1620 0010E0E3 		mvn	r1, #0
 2690 1624 1C0094E5 		ldr	r0, [r4, #28]
1373:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2691              		.loc 1 1373 0
 2692 1628 FFA00EE2 		and	sl, lr, #255
 2693              	.LVL231:
1376:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2694              		.loc 1 1376 0
 2695 162c FEFFFFEB 		bl	_txe_mutex_get
 2696              	.LVL232:
1377:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2697              		.loc 1 1377 0
 2698 1630 0820A0E1 		mov	r2, r8
 2699 1634 18809DE5 		ldr	r8, [sp, #24]
 2700              	.LVL233:
 2701 1638 0A30A0E1 		mov	r3, sl
 2702 163c 2510A0E3 		mov	r1, #37
 2703 1640 0400A0E1 		mov	r0, r4
 2704 1644 0070A0E3 		mov	r7, #0
 2705              	.LVL234:
 2706 1648 00808DE5 		str	r8, [sp, #0]
 2707 164c 04708DE5 		str	r7, [sp, #4]
 2708 1650 FEFFFFEB 		bl	cmdSet
 2709              	.LVL235:
1378:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2710              		.loc 1 1378 0
 2711 1654 1C0094E5 		ldr	r0, [r4, #28]
 2712 1658 FEFFFFEB 		bl	_txe_mutex_put
1379:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2713              		.loc 1 1379 0
 2714 165c 18C09DE5 		ldr	ip, [sp, #24]
1383:../uvc.c      **** 							 break;
 2715              		.loc 1 1383 0
 2716 1660 FFA0A0E3 		mov	sl, #255
 2717              	.LVL236:
1380:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2718              		.loc 1 1380 0
 2719 1664 0100A0E3 		mov	r0, #1
1379:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2720              		.loc 1 1379 0
 2721 1668 19C5C6E5 		strb	ip, [r6, #1305]
1380:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2722              		.loc 1 1380 0
 2723 166c 0C80A0E1 		mov	r8, ip
 2724 1670 1D05C6E5 		strb	r0, [r6, #1309]
 2725 1674 1C409DE5 		ldr	r4, [sp, #28]
1383:../uvc.c      **** 							 break;
 2726              		.loc 1 1383 0
 2727 1678 0A70A0E1 		mov	r7, sl
 2728 167c F9FDFFEA 		b	.L142
 2729              	.LVL237:
 2730              	.L228:
1331:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2731              		.loc 1 1331 0
 2732 1680 F834D6E5 		ldrb	r3, [r6, #1272]	@ zero_extendqisi2
1358:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2733              		.loc 1 1358 0
 2734 1684 08479FE5 		ldr	r4, .L303+68
1332:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2735              		.loc 1 1332 0
 2736 1688 F924D6E5 		ldrb	r2, [r6, #1273]	@ zero_extendqisi2
 2737              	.LVL238:
1333:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2738              		.loc 1 1333 0
 2739 168c 0715D6E5 		ldrb	r1, [r6, #1287]	@ zero_extendqisi2
1358:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2740              		.loc 1 1358 0
 2741 1690 1C0094E5 		ldr	r0, [r4, #28]
1333:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2742              		.loc 1 1333 0
 2743 1694 FF7001E2 		and	r7, r1, #255
 2744              	.LVL239:
1358:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2745              		.loc 1 1358 0
 2746 1698 0010E0E3 		mvn	r1, #0
 2747 169c 14C08DE5 		str	ip, [sp, #20]
1331:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2748              		.loc 1 1331 0
 2749 16a0 FF9003E2 		and	r9, r3, #255
 2750              	.LVL240:
1332:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2751              		.loc 1 1332 0
 2752 16a4 FF8002E2 		and	r8, r2, #255
 2753              	.LVL241:
1358:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2754              		.loc 1 1358 0
 2755 16a8 FEFFFFEB 		bl	_txe_mutex_get
 2756              	.LVL242:
1360:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2757              		.loc 1 1360 0
 2758 16ac 18E09DE5 		ldr	lr, [sp, #24]
 2759 16b0 0920A0E1 		mov	r2, r9
 2760 16b4 0730A0E1 		mov	r3, r7
 2761 16b8 2410A0E3 		mov	r1, #36
 2762 16bc 0400A0E1 		mov	r0, r4
 2763 16c0 00A0A0E3 		mov	sl, #0
 2764 16c4 00E08DE5 		str	lr, [sp, #0]
 2765 16c8 04A08DE5 		str	sl, [sp, #4]
 2766 16cc FEFFFFEB 		bl	cmdSet
 2767              	.LVL243:
1362:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2768              		.loc 1 1362 0
 2769 16d0 0820A0E1 		mov	r2, r8
 2770 16d4 14809DE5 		ldr	r8, [sp, #20]
 2771              	.LVL244:
 2772 16d8 0730A0E1 		mov	r3, r7
 2773 16dc 0190A0E3 		mov	r9, #1
 2774              	.LVL245:
 2775 16e0 2410A0E3 		mov	r1, #36
 2776 16e4 0400A0E1 		mov	r0, r4
 2777 16e8 00038DE8 		stmia	sp, {r8, r9}	@ phole stm
 2778 16ec FEFFFFEB 		bl	cmdSet
 2779              	.LVL246:
1363:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2780              		.loc 1 1363 0
 2781 16f0 1C0094E5 		ldr	r0, [r4, #28]
 2782 16f4 FEFFFFEB 		bl	_txe_mutex_put
 2783              	.LVL247:
1366:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2784              		.loc 1 1366 0
 2785 16f8 18C09DE5 		ldr	ip, [sp, #24]
1369:../uvc.c      **** 							 break;
 2786              		.loc 1 1369 0
 2787 16fc FFA0A0E3 		mov	sl, #255
1366:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2788              		.loc 1 1366 0
 2789 1700 05C5C6E5 		strb	ip, [r6, #1285]
1367:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2790              		.loc 1 1367 0
 2791 1704 14709DE5 		ldr	r7, [sp, #20]
 2792              	.LVL248:
1368:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2793              		.loc 1 1368 0
 2794 1708 0C80A0E1 		mov	r8, ip
1367:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2795              		.loc 1 1367 0
 2796 170c 0675C6E5 		strb	r7, [r6, #1286]
1368:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2797              		.loc 1 1368 0
 2798 1710 0740A0E1 		mov	r4, r7
 2799 1714 0995C6E5 		strb	r9, [r6, #1289]
1369:../uvc.c      **** 							 break;
 2800              		.loc 1 1369 0
 2801 1718 0A70A0E1 		mov	r7, sl
 2802 171c D1FDFFEA 		b	.L142
 2803              	.LVL249:
 2804              	.L230:
1386:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2805              		.loc 1 1386 0
 2806 1720 8780A0E1 		mov	r8, r7, asl #1
 2807 1724 24B69FE5 		ldr	fp, .L303
 2808 1728 072088E0 		add	r2, r8, r7
 2809              	.LVL250:
 2810 172c 82E186E0 		add	lr, r6, r2, asl #3
1392:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2811              		.loc 1 1392 0
 2812 1730 5C469FE5 		ldr	r4, .L303+68
1386:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2813              		.loc 1 1386 0
 2814 1734 0D30CEE5 		strb	r3, [lr, #13]
1388:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 2815              		.loc 1 1388 0
 2816 1738 DDB4DBE5 		ldrb	fp, [fp, #1245]	@ zero_extendqisi2
1387:../uvc.c      **** 							 if(Data0 == 1){
 2817              		.loc 1 1387 0
 2818 173c 010053E3 		cmp	r3, #1
1392:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2819              		.loc 1 1392 0
 2820 1740 0010E0E3 		mvn	r1, #0
 2821 1744 1C0094E5 		ldr	r0, [r4, #28]
1388:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 2822              		.loc 1 1388 0
 2823 1748 80B08B03 		orreq	fp, fp, #128
 2824              	.LVL251:
1390:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 2825              		.loc 1 1390 0
 2826 174c 7FB00B12 		andne	fp, fp, #127
 2827              	.LVL252:
1392:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2828              		.loc 1 1392 0
 2829 1750 FEFFFFEB 		bl	_txe_mutex_get
 2830              	.LVL253:
1393:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2831              		.loc 1 1393 0
 2832 1754 2610A0E3 		mov	r1, #38
 2833 1758 0A20A0E1 		mov	r2, sl
 2834 175c 0930A0E1 		mov	r3, r9
 2835 1760 00C0A0E3 		mov	ip, #0
 2836 1764 0400A0E1 		mov	r0, r4
 2837 1768 00188DE8 		stmia	sp, {fp, ip}	@ phole stm
 2838 176c FEFFFFEB 		bl	cmdSet
1394:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2839              		.loc 1 1394 0
 2840 1770 1C0094E5 		ldr	r0, [r4, #28]
 2841 1774 FEFFFFEB 		bl	_txe_mutex_put
1396:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2842              		.loc 1 1396 0
 2843 1778 073088E0 		add	r3, r8, r7
 2844 177c 836186E0 		add	r6, r6, r3, asl #3
1397:../uvc.c      **** 							 break;
 2845              		.loc 1 1397 0
 2846 1780 FFA0A0E3 		mov	sl, #255
1396:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2847              		.loc 1 1396 0
 2848 1784 0110A0E3 		mov	r1, #1
 2849 1788 1010C6E5 		strb	r1, [r6, #16]
 2850 178c 18809DE5 		ldr	r8, [sp, #24]
 2851 1790 1C409DE5 		ldr	r4, [sp, #28]
1397:../uvc.c      **** 							 break;
 2852              		.loc 1 1397 0
 2853 1794 0A70A0E1 		mov	r7, sl
 2854              	.LVL254:
 2855 1798 B2FDFFEA 		b	.L142
 2856              	.LVL255:
 2857              	.L227:
1325:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2858              		.loc 1 1325 0 discriminator 1
 2859 179c 000058E3 		cmp	r8, #0
 2860 17a0 1800000A 		beq	.L233
1323:../uvc.c      **** 							 break;
 2861              		.loc 1 1323 0
 2862 17a4 28E1A0E1 		mov	lr, r8, lsr #2
 2863 17a8 00005EE3 		cmp	lr, #0
 2864 17ac 03005813 		cmpne	r8, #3
 2865 17b0 0020A083 		movhi	r2, #0
 2866 17b4 0120A093 		movls	r2, #1
 2867              	.LVL256:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2868              		.loc 1 735 0
 2869 17b8 0E31A0E1 		mov	r3, lr, asl #2
1323:../uvc.c      **** 							 break;
 2870              		.loc 1 1323 0
 2871 17bc 6503009A 		bls	.L270
 2872 17c0 AC159FE5 		ldr	r1, .L303+36
 2873 17c4 100081E2 		add	r0, r1, #16
 2874              	.LVL257:
 2875              	.L243:
1326:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2876              		.loc 1 1326 0 discriminator 2
 2877 17c8 04A090E4 		ldr	sl, [r0], #4
 2878 17cc 012082E2 		add	r2, r2, #1
 2879 17d0 FF2002E2 		and	r2, r2, #255
 2880 17d4 02005EE1 		cmp	lr, r2
 2881 17d8 04A081E4 		str	sl, [r1], #4
 2882 17dc F9FFFF8A 		bhi	.L243
1326:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2883              		.loc 1 1326 0 is_stmt 0
 2884 17e0 030058E1 		cmp	r8, r3
 2885 17e4 0700000A 		beq	.L233
 2886              	.L282:
 2887 17e8 B0059FE5 		ldr	r0, .L303+80
 2888 17ec 03E080E0 		add	lr, r0, r3
 2889 17f0 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
1325:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2890              		.loc 1 1325 0 is_stmt 1
 2891 17f4 013083E2 		add	r3, r3, #1
 2892 17f8 FF3003E2 		and	r3, r3, #255
 2893              	.LVL258:
 2894 17fc 030058E1 		cmp	r8, r3
1326:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2895              		.loc 1 1326 0
 2896 1800 4C10CEE5 		strb	r1, [lr, #76]
1325:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2897              		.loc 1 1325 0
 2898 1804 F7FFFF8A 		bhi	.L282
 2899              	.LVL259:
 2900              	.L233:
1329:../uvc.c      **** 							 break;
 2901              		.loc 1 1329 0
 2902 1808 FFA0A0E3 		mov	sl, #255
1328:../uvc.c      **** 					 		I2CCmdHandler();
 2903              		.loc 1 1328 0
 2904 180c FEFFFFEB 		bl	I2CCmdHandler
 2905              	.LVL260:
1329:../uvc.c      **** 							 break;
 2906              		.loc 1 1329 0
 2907 1810 0A70A0E1 		mov	r7, sl
 2908              	.LVL261:
1328:../uvc.c      **** 					 		I2CCmdHandler();
 2909              		.loc 1 1328 0
 2910 1814 18809DE5 		ldr	r8, [sp, #24]
 2911 1818 1C409DE5 		ldr	r4, [sp, #28]
1329:../uvc.c      **** 							 break;
 2912              		.loc 1 1329 0
 2913 181c 91FDFFEA 		b	.L142
 2914              	.LVL262:
 2915              	.L226:
1319:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2916              		.loc 1 1319 0
 2917 1820 6C759FE5 		ldr	r7, .L303+68
 2918              	.LVL263:
 2919 1824 0010E0E3 		mvn	r1, #0
 2920 1828 1C0097E5 		ldr	r0, [r7, #28]
 2921 182c FEFFFFEB 		bl	_txe_mutex_get
 2922              	.LVL264:
1320:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2923              		.loc 1 1320 0
 2924 1830 18809DE5 		ldr	r8, [sp, #24]
 2925 1834 0A20A0E1 		mov	r2, sl
 2926 1838 014078E2 		rsbs	r4, r8, #1
 2927 183c 0040A033 		movcc	r4, #0
 2928 1840 00C0A0E3 		mov	ip, #0
 2929 1844 1E10A0E3 		mov	r1, #30
 2930 1848 0930A0E1 		mov	r3, r9
 2931 184c 0700A0E1 		mov	r0, r7
 2932 1850 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2933 1854 FEFFFFEB 		bl	cmdSet
1321:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2934              		.loc 1 1321 0
 2935 1858 1C0097E5 		ldr	r0, [r7, #28]
 2936 185c FEFFFFEB 		bl	_txe_mutex_put
1323:../uvc.c      **** 							 break;
 2937              		.loc 1 1323 0
 2938 1860 FFA0A0E3 		mov	sl, #255
1322:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2939              		.loc 1 1322 0
 2940 1864 0100A0E3 		mov	r0, #1
 2941 1868 6004C6E5 		strb	r0, [r6, #1120]
 2942 186c 18809DE5 		ldr	r8, [sp, #24]
 2943 1870 1C409DE5 		ldr	r4, [sp, #28]
1323:../uvc.c      **** 							 break;
 2944              		.loc 1 1323 0
 2945 1874 0A70A0E1 		mov	r7, sl
 2946 1878 7AFDFFEA 		b	.L142
 2947              	.LVL265:
 2948              	.L225:
1297:../uvc.c      **** 							 if(Data0 <= 3){
 2949              		.loc 1 1297 0
 2950 187c 030053E3 		cmp	r3, #3
1298:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2951              		.loc 1 1298 0
 2952 1880 18059F95 		ldrls	r0, .L303+80
 2953 1884 03E0A0E1 		mov	lr, r3
 2954              	.LVL266:
1301:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2955              		.loc 1 1301 0
 2956 1888 10C59F85 		ldrhi	ip, .L303+80
 2957              	.LVL267:
1298:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2958              		.loc 1 1298 0
 2959 188c 0030A093 		movls	r3, #0
 2960 1890 BC30C095 		strlsb	r3, [r0, #188]
 2961              	.LVL268:
1307:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2962              		.loc 1 1307 0
 2963 1894 F8449FE5 		ldr	r4, .L303+68
1298:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2964              		.loc 1 1298 0
 2965 1898 0E30A091 		movls	r3, lr
 2966 189c 18E09D95 		ldrls	lr, [sp, #24]
1301:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2967              		.loc 1 1301 0
 2968 18a0 0120A083 		movhi	r2, #1
 2969              	.LVL269:
1302:../uvc.c      **** 								 Data1 = Data0-4;
 2970              		.loc 1 1302 0
 2971 18a4 04304382 		subhi	r3, r3, #4
1301:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2972              		.loc 1 1301 0
 2973 18a8 BC20CC85 		strhib	r2, [ip, #188]
 2974              	.LVL270:
1306:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2975              		.loc 1 1306 0
 2976 18ac 0120A0E3 		mov	r2, #1
1307:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2977              		.loc 1 1307 0
 2978 18b0 0010E0E3 		mvn	r1, #0
1304:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2979              		.loc 1 1304 0
 2980 18b4 2DE4C6E5 		strb	lr, [r6, #1069]
1305:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2981              		.loc 1 1305 0
 2982 18b8 8D31C6E5 		strb	r3, [r6, #397]
1306:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2983              		.loc 1 1306 0
 2984 18bc 3024C6E5 		strb	r2, [r6, #1072]
1307:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2985              		.loc 1 1307 0
 2986 18c0 1C0094E5 		ldr	r0, [r4, #28]
 2987 18c4 FEFFFFEB 		bl	_txe_mutex_get
 2988              	.LVL271:
1308:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2989              		.loc 1 1308 0
 2990 18c8 0A20A0E1 		mov	r2, sl
 2991 18cc 18A09DE5 		ldr	sl, [sp, #24]
 2992 18d0 1C10A0E3 		mov	r1, #28
 2993 18d4 0930A0E1 		mov	r3, r9
 2994 18d8 0400A0E1 		mov	r0, r4
 2995 18dc 0080A0E3 		mov	r8, #0
 2996 18e0 00A08DE5 		str	sl, [sp, #0]
 2997 18e4 04808DE5 		str	r8, [sp, #4]
 2998 18e8 FEFFFFEB 		bl	cmdSet
1309:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2999              		.loc 1 1309 0
 3000 18ec 1C0094E5 		ldr	r0, [r4, #28]
 3001              	.LVL272:
 3002              	.L291:
1575:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3003              		.loc 1 1575 0
 3004 18f0 FFA0A0E3 		mov	sl, #255
 3005 18f4 FEFFFFEB 		bl	_txe_mutex_put
 3006 18f8 0A70A0E1 		mov	r7, sl
 3007 18fc 18809DE5 		ldr	r8, [sp, #24]
 3008 1900 1C409DE5 		ldr	r4, [sp, #28]
 3009 1904 57FDFFEA 		b	.L142
 3010              	.LVL273:
 3011              	.L224:
1274:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3012              		.loc 1 1274 0
 3013 1908 84449FE5 		ldr	r4, .L303+68
1270:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3014              		.loc 1 1270 0
 3015 190c A434D6E5 		ldrb	r3, [r6, #1188]	@ zero_extendqisi2
1271:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3016              		.loc 1 1271 0
 3017 1910 A574D6E5 		ldrb	r7, [r6, #1189]	@ zero_extendqisi2
 3018              	.LVL274:
1272:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3019              		.loc 1 1272 0
 3020 1914 B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1274:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3021              		.loc 1 1274 0
 3022 1918 0010E0E3 		mvn	r1, #0
 3023 191c 1C0094E5 		ldr	r0, [r4, #28]
1270:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3024              		.loc 1 1270 0
 3025 1920 FFA003E2 		and	sl, r3, #255
 3026              	.LVL275:
1271:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3027              		.loc 1 1271 0
 3028 1924 FF8007E2 		and	r8, r7, #255
 3029              	.LVL276:
1272:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3030              		.loc 1 1272 0
 3031 1928 FF700EE2 		and	r7, lr, #255
 3032              	.LVL277:
1274:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3033              		.loc 1 1274 0
 3034 192c FEFFFFEB 		bl	_txe_mutex_get
 3035              	.LVL278:
1282:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3036              		.loc 1 1282 0
 3037 1930 B104D6E5 		ldrb	r0, [r6, #1201]	@ zero_extendqisi2
 3038 1934 18109DE5 		ldr	r1, [sp, #24]
1270:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3039              		.loc 1 1270 0
 3040 1938 10349FE5 		ldr	r3, .L303
1282:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3041              		.loc 1 1282 0
 3042 193c 000051E1 		cmp	r1, r0
 3043 1940 0600000A 		beq	.L238
1283:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3044              		.loc 1 1283 0
 3045 1944 B114C3E5 		strb	r1, [r3, #1201]
1284:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3046              		.loc 1 1284 0
 3047 1948 C514D3E5 		ldrb	r1, [r3, #1221]	@ zero_extendqisi2
 3048 194c 010051E3 		cmp	r1, #1
 3049 1950 DA02000A 		beq	.L239
1284:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3050              		.loc 1 1284 0 is_stmt 0 discriminator 1
 3051 1954 C5C4D3E5 		ldrb	ip, [r3, #1221]	@ zero_extendqisi2
 3052 1958 03005CE3 		cmp	ip, #3
 3053 195c D702000A 		beq	.L239
 3054              	.LVL279:
 3055              	.L238:
1291:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3056              		.loc 1 1291 0 is_stmt 1
 3057 1960 1C0094E5 		ldr	r0, [r4, #28]
 3058 1964 FEFFFFEB 		bl	_txe_mutex_put
1293:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3059              		.loc 1 1293 0
 3060 1968 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3061              		.loc 1 1292 0
 3062 196c 18809DE5 		ldr	r8, [sp, #24]
1293:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3063              		.loc 1 1293 0
 3064 1970 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3065              		.loc 1 1292 0
 3066 1974 1C409DE5 		ldr	r4, [sp, #28]
1293:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3067              		.loc 1 1293 0
 3068 1978 B174D6E5 		ldrb	r7, [r6, #1201]	@ zero_extendqisi2
 3069              	.LVL280:
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3070              		.loc 1 1292 0
 3071 197c 0400A0E3 		mov	r0, #4
 3072 1980 F0139FE5 		ldr	r1, .L303+40
1294:../uvc.c      **** 							 break;
 3073              		.loc 1 1294 0
 3074 1984 FFA0A0E3 		mov	sl, #255
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3075              		.loc 1 1292 0
 3076 1988 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3077 198c 08408DE5 		str	r4, [sp, #8]
1294:../uvc.c      **** 							 break;
 3078              		.loc 1 1294 0
 3079 1990 0A70A0E1 		mov	r7, sl
1292:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3080              		.loc 1 1292 0
 3081 1994 FEFFFFEB 		bl	CyU3PDebugPrint
1294:../uvc.c      **** 							 break;
 3082              		.loc 1 1294 0
 3083 1998 32FDFFEA 		b	.L142
 3084              	.LVL281:
 3085              	.L219:
1460:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3086              		.loc 1 1460 0
 3087 199c F0439FE5 		ldr	r4, .L303+68
 3088 19a0 0010E0E3 		mvn	r1, #0
 3089 19a4 1C0094E5 		ldr	r0, [r4, #28]
 3090 19a8 FEFFFFEB 		bl	_txe_mutex_get
 3091              	.LVL282:
1461:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3092              		.loc 1 1461 0
 3093 19ac 0A20A0E1 		mov	r2, sl
 3094 19b0 18A09DE5 		ldr	sl, [sp, #24]
 3095 19b4 00E0A0E3 		mov	lr, #0
 3096 19b8 0610A0E3 		mov	r1, #6
 3097 19bc 0930A0E1 		mov	r3, r9
 3098 19c0 0400A0E1 		mov	r0, r4
 3099 19c4 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 3100 19c8 FEFFFFEB 		bl	cmdSet
 3101              	.LVL283:
1463:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3102              		.loc 1 1463 0
 3103 19cc 18C09DE5 		ldr	ip, [sp, #24]
 3104 19d0 0170A0E3 		mov	r7, #1
 3105              	.LVL284:
 3106 19d4 0610A0E3 		mov	r1, #6
 3107 19d8 0B20A0E1 		mov	r2, fp
 3108 19dc 0930A0E1 		mov	r3, r9
 3109 19e0 0400A0E1 		mov	r0, r4
 3110 19e4 00C08DE5 		str	ip, [sp, #0]
 3111 19e8 04708DE5 		str	r7, [sp, #4]
 3112 19ec FEFFFFEB 		bl	cmdSet
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3113              		.loc 1 1464 0
 3114 19f0 1C0094E5 		ldr	r0, [r4, #28]
 3115 19f4 FEFFFFEB 		bl	_txe_mutex_put
1465:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3116              		.loc 1 1465 0
 3117 19f8 18809DE5 		ldr	r8, [sp, #24]
1467:../uvc.c      **** 							 break;
 3118              		.loc 1 1467 0
 3119 19fc FFA0A0E3 		mov	sl, #255
1466:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3120              		.loc 1 1466 0
 3121 1a00 2072C6E5 		strb	r7, [r6, #544]
1465:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3122              		.loc 1 1465 0
 3123 1a04 1D82C6E5 		strb	r8, [r6, #541]
1466:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3124              		.loc 1 1466 0
 3125 1a08 1C409DE5 		ldr	r4, [sp, #28]
1467:../uvc.c      **** 							 break;
 3126              		.loc 1 1467 0
 3127 1a0c 0A70A0E1 		mov	r7, sl
 3128 1a10 14FDFFEA 		b	.L142
 3129              	.LVL285:
 3130              	.L218:
1440:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3131              		.loc 1 1440 0
 3132 1a14 78839FE5 		ldr	r8, .L303+68
 3133 1a18 0010E0E3 		mvn	r1, #0
 3134 1a1c 1C0098E5 		ldr	r0, [r8, #28]
 3135 1a20 FEFFFFEB 		bl	_txe_mutex_get
 3136              	.LVL286:
1441:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3137              		.loc 1 1441 0
 3138 1a24 18109DE5 		ldr	r1, [sp, #24]
 3139 1a28 0930A0E1 		mov	r3, r9
 3140 1a2c 802041E2 		sub	r2, r1, #128
 3141 1a30 FF4002E2 		and	r4, r2, #255
 3142 1a34 0510A0E3 		mov	r1, #5
 3143 1a38 0A20A0E1 		mov	r2, sl
 3144 1a3c 0800A0E1 		mov	r0, r8
 3145 1a40 00A0A0E3 		mov	sl, #0
 3146 1a44 10048DE8 		stmia	sp, {r4, sl}	@ phole stm
 3147 1a48 FEFFFFEB 		bl	cmdSet
 3148              	.LVL287:
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3149              		.loc 1 1443 0
 3150 1a4c 18C09DE5 		ldr	ip, [sp, #24]
 3151 1a50 0510A0E3 		mov	r1, #5
 3152 1a54 76704CE2 		sub	r7, ip, #118
 3153              	.LVL288:
 3154 1a58 FFE007E2 		and	lr, r7, #255
 3155 1a5c DC20A0E3 		mov	r2, #220
 3156 1a60 0170A0E3 		mov	r7, #1
 3157 1a64 0930A0E1 		mov	r3, r9
 3158 1a68 0800A0E1 		mov	r0, r8
 3159 1a6c 00E08DE5 		str	lr, [sp, #0]
 3160 1a70 04708DE5 		str	r7, [sp, #4]
 3161 1a74 FEFFFFEB 		bl	cmdSet
 3162              	.LVL289:
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3163              		.loc 1 1445 0
 3164 1a78 18009DE5 		ldr	r0, [sp, #24]
 3165 1a7c 0510A0E3 		mov	r1, #5
 3166 1a80 7E3080E2 		add	r3, r0, #126
 3167 1a84 FF4003E2 		and	r4, r3, #255
 3168 1a88 DE20A0E3 		mov	r2, #222
 3169 1a8c 0930A0E1 		mov	r3, r9
 3170 1a90 0800A0E1 		mov	r0, r8
 3171 1a94 02A0A0E3 		mov	sl, #2
 3172 1a98 10048DE8 		stmia	sp, {r4, sl}	@ phole stm
 3173 1a9c FEFFFFEB 		bl	cmdSet
 3174              	.LVL290:
1447:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3175              		.loc 1 1447 0
 3176 1aa0 18109DE5 		ldr	r1, [sp, #24]
 3177 1aa4 0930A0E1 		mov	r3, r9
 3178 1aa8 722081E2 		add	r2, r1, #114
 3179 1aac FFC002E2 		and	ip, r2, #255
 3180 1ab0 0510A0E3 		mov	r1, #5
 3181 1ab4 E020A0E3 		mov	r2, #224
 3182 1ab8 0800A0E1 		mov	r0, r8
 3183 1abc 0340A0E3 		mov	r4, #3
 3184 1ac0 00C08DE5 		str	ip, [sp, #0]
 3185 1ac4 04408DE5 		str	r4, [sp, #4]
 3186 1ac8 FEFFFFEB 		bl	cmdSet
 3187              	.LVL291:
1449:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3188              		.loc 1 1449 0
 3189 1acc 18009DE5 		ldr	r0, [sp, #24]
 3190 1ad0 04C0A0E3 		mov	ip, #4
 3191 1ad4 6F3040E2 		sub	r3, r0, #111
 3192 1ad8 FFA003E2 		and	sl, r3, #255
 3193 1adc 0510A0E3 		mov	r1, #5
 3194 1ae0 DD20A0E3 		mov	r2, #221
 3195 1ae4 0930A0E1 		mov	r3, r9
 3196 1ae8 0800A0E1 		mov	r0, r8
 3197 1aec 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3198 1af0 FEFFFFEB 		bl	cmdSet
 3199              	.LVL292:
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3200              		.loc 1 1451 0
 3201 1af4 A4129FE5 		ldr	r1, .L303+80
 3202 1af8 05E0A0E3 		mov	lr, #5
 3203 1afc 5C40D1E5 		ldrb	r4, [r1, #92]	@ zero_extendqisi2
 3204 1b00 0930A0E1 		mov	r3, r9
 3205 1b04 7F2084E2 		add	r2, r4, #127
 3206 1b08 FFA002E2 		and	sl, r2, #255
 3207 1b0c 0E10A0E1 		mov	r1, lr
 3208 1b10 0B20A0E1 		mov	r2, fp
 3209 1b14 0800A0E1 		mov	r0, r8
 3210 1b18 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 3211 1b1c FEFFFFEB 		bl	cmdSet
1452:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3212              		.loc 1 1452 0
 3213 1b20 1C0098E5 		ldr	r0, [r8, #28]
 3214 1b24 FEFFFFEB 		bl	_txe_mutex_put
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3215              		.loc 1 1454 0
 3216 1b28 70029FE5 		ldr	r0, .L303+80
1456:../uvc.c      **** 							 break;
 3217              		.loc 1 1456 0
 3218 1b2c FFA0A0E3 		mov	sl, #255
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3219              		.loc 1 1454 0
 3220 1b30 5CC0D0E5 		ldrb	ip, [r0, #92]	@ zero_extendqisi2
1455:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3221              		.loc 1 1455 0
 3222 1b34 0872C6E5 		strb	r7, [r6, #520]
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3223              		.loc 1 1454 0
 3224 1b38 80304CE2 		sub	r3, ip, #128
 3225 1b3c 0532C6E5 		strb	r3, [r6, #517]
1455:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3226              		.loc 1 1455 0
 3227 1b40 18809DE5 		ldr	r8, [sp, #24]
 3228 1b44 1C409DE5 		ldr	r4, [sp, #28]
1456:../uvc.c      **** 							 break;
 3229              		.loc 1 1456 0
 3230 1b48 0A70A0E1 		mov	r7, sl
 3231 1b4c C5FCFFEA 		b	.L142
 3232              	.LVL293:
 3233              	.L217:
1487:../uvc.c      **** 							 Data0 = Data0 - 1;
 3234              		.loc 1 1487 0
 3235 1b50 010043E2 		sub	r0, r3, #1
 3236 1b54 0310A0E1 		mov	r1, r3
 3237              	.LVL294:
1488:../uvc.c      **** 							 is60Hz = Data0;
 3238              		.loc 1 1488 0
 3239 1b58 40E29FE5 		ldr	lr, .L303+80
1487:../uvc.c      **** 							 Data0 = Data0 - 1;
 3240              		.loc 1 1487 0
 3241 1b5c FF3000E2 		and	r3, r0, #255
 3242              	.LVL295:
1494:../uvc.c      **** 							 else if(Data0 >2)
 3243              		.loc 1 1494 0
 3244 1b60 020053E3 		cmp	r3, #2
1486:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3245              		.loc 1 1486 0
 3246 1b64 ED11C6E5 		strb	r1, [r6, #493]
1497:../uvc.c      **** 								 is60Hz = CyTrue;
 3247              		.loc 1 1497 0
 3248 1b68 0110A083 		movhi	r1, #1
1488:../uvc.c      **** 							 is60Hz = Data0;
 3249              		.loc 1 1488 0
 3250 1b6c 58308EE5 		str	r3, [lr, #88]
 3251              	.LVL296:
1497:../uvc.c      **** 								 is60Hz = CyTrue;
 3252              		.loc 1 1497 0
 3253 1b70 58108E85 		strhi	r1, [lr, #88]
1500:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3254              		.loc 1 1500 0
 3255 1b74 24E29FE5 		ldr	lr, .L303+80
 3256 1b78 28209EE5 		ldr	r2, [lr, #40]
 3257              	.LVL297:
 3258 1b7c 010052E3 		cmp	r2, #1
 3259 1b80 DA01000A 		beq	.L299
 3260              	.LVL298:
 3261              	.L251:
1531:../uvc.c      **** 							 break;
 3262              		.loc 1 1531 0
 3263 1b84 FFA0A0E3 		mov	sl, #255
1530:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3264              		.loc 1 1530 0
 3265 1b88 0110A0E3 		mov	r1, #1
 3266 1b8c F011C6E5 		strb	r1, [r6, #496]
 3267 1b90 18809DE5 		ldr	r8, [sp, #24]
 3268 1b94 1C409DE5 		ldr	r4, [sp, #28]
1531:../uvc.c      **** 							 break;
 3269              		.loc 1 1531 0
 3270 1b98 0A70A0E1 		mov	r7, sl
 3271 1b9c B1FCFFEA 		b	.L142
 3272              	.LVL299:
 3273              	.L216:
1586:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3274              		.loc 1 1586 0
 3275 1ba0 EC819FE5 		ldr	r8, .L303+68
 3276 1ba4 0010E0E3 		mvn	r1, #0
 3277 1ba8 1C0098E5 		ldr	r0, [r8, #28]
 3278 1bac FEFFFFEB 		bl	_txe_mutex_get
 3279              	.LVL300:
1587:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3280              		.loc 1 1587 0
 3281 1bb0 18709DE5 		ldr	r7, [sp, #24]
 3282              	.LVL301:
 3283 1bb4 0410A0E1 		mov	r1, r4
 3284 1bb8 0A20A0E1 		mov	r2, sl
 3285 1bbc 0930A0E1 		mov	r3, r9
 3286 1bc0 0800A0E1 		mov	r0, r8
 3287 1bc4 00A0A0E3 		mov	sl, #0
 3288 1bc8 80048DE8 		stmia	sp, {r7, sl}	@ phole stm
 3289 1bcc FEFFFFEB 		bl	cmdSet
1588:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3290              		.loc 1 1588 0
 3291 1bd0 1C0098E5 		ldr	r0, [r8, #28]
 3292 1bd4 FEFFFFEB 		bl	_txe_mutex_put
1590:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3293              		.loc 1 1590 0
 3294 1bd8 18109DE5 		ldr	r1, [sp, #24]
1595:../uvc.c      **** 							 break;
 3295              		.loc 1 1595 0
 3296 1bdc FFA0A0E3 		mov	sl, #255
1591:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3297              		.loc 1 1591 0
 3298 1be0 0130A0E3 		mov	r3, #1
1590:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3299              		.loc 1 1590 0
 3300 1be4 BD11C6E5 		strb	r1, [r6, #445]
1591:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3301              		.loc 1 1591 0
 3302 1be8 C031C6E5 		strb	r3, [r6, #448]
 3303 1bec 0180A0E1 		mov	r8, r1
 3304 1bf0 1C409DE5 		ldr	r4, [sp, #28]
1595:../uvc.c      **** 							 break;
 3305              		.loc 1 1595 0
 3306 1bf4 0A70A0E1 		mov	r7, sl
 3307 1bf8 9AFCFFEA 		b	.L142
 3308              	.LVL302:
 3309              	.L223:
1240:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3310              		.loc 1 1240 0
 3311 1bfc 90419FE5 		ldr	r4, .L303+68
1236:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3312              		.loc 1 1236 0
 3313 1c00 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
1237:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3314              		.loc 1 1237 0
 3315 1c04 B924D6E5 		ldrb	r2, [r6, #1209]	@ zero_extendqisi2
 3316              	.LVL303:
1238:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3317              		.loc 1 1238 0
 3318 1c08 C7C4D6E5 		ldrb	ip, [r6, #1223]	@ zero_extendqisi2
 3319              	.LVL304:
1240:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3320              		.loc 1 1240 0
 3321 1c0c 1C0094E5 		ldr	r0, [r4, #28]
 3322 1c10 0010E0E3 		mvn	r1, #0
1238:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3323              		.loc 1 1238 0
 3324 1c14 FF800CE2 		and	r8, ip, #255
1237:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3325              		.loc 1 1237 0
 3326 1c18 FF9002E2 		and	r9, r2, #255
1240:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3327              		.loc 1 1240 0
 3328 1c1c FEFFFFEB 		bl	_txe_mutex_get
1241:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3329              		.loc 1 1241 0
 3330 1c20 18C09DE5 		ldr	ip, [sp, #24]
 3331 1c24 C504D6E5 		ldrb	r0, [r6, #1221]	@ zero_extendqisi2
1236:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3332              		.loc 1 1236 0
 3333 1c28 FFA00AE2 		and	sl, sl, #255
 3334              	.LVL305:
1241:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3335              		.loc 1 1241 0
 3336 1c2c 00005CE1 		cmp	ip, r0
1236:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3337              		.loc 1 1236 0
 3338 1c30 18319FE5 		ldr	r3, .L303
 3339 1c34 0C70A001 		moveq	r7, ip
 3340              	.LVL306:
1241:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3341              		.loc 1 1241 0
 3342 1c38 0A00000A 		beq	.L236
1243:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3343              		.loc 1 1243 0
 3344 1c3c C5C4C3E5 		strb	ip, [r3, #1221]
1244:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3345              		.loc 1 1244 0
 3346 1c40 9D74D3E5 		ldrb	r7, [r3, #1181]	@ zero_extendqisi2
1245:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3347              		.loc 1 1245 0
 3348 1c44 00E0A0E3 		mov	lr, #0
1244:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3349              		.loc 1 1244 0
 3350 1c48 07128CE1 		orr	r1, ip, r7, asl #4
 3351 1c4c FF7001E2 		and	r7, r1, #255
 3352              	.LVL307:
1245:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3353              		.loc 1 1245 0
 3354 1c50 0400A0E1 		mov	r0, r4
 3355 1c54 1910A0E3 		mov	r1, #25
 3356 1c58 0A20A0E1 		mov	r2, sl
 3357 1c5c 0830A0E1 		mov	r3, r8
 3358 1c60 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 3359 1c64 FEFFFFEB 		bl	cmdSet
 3360              	.LVL308:
 3361              	.L236:
1257:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3362              		.loc 1 1257 0
 3363 1c68 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 3364 1c6c 1CE09DE5 		ldr	lr, [sp, #28]
 3365 1c70 0E0053E1 		cmp	r3, lr
 3366 1c74 0500000A 		beq	.L237
1259:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3367              		.loc 1 1259 0
 3368 1c78 18209DE5 		ldr	r2, [sp, #24]
1258:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3369              		.loc 1 1258 0
 3370 1c7c CC009FE5 		ldr	r0, .L303
1259:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3371              		.loc 1 1259 0
 3372 1c80 02C042E2 		sub	ip, r2, #2
 3373 1c84 01005CE3 		cmp	ip, #1
1258:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3374              		.loc 1 1258 0
 3375 1c88 C6E4C0E5 		strb	lr, [r0, #1222]
1259:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3376              		.loc 1 1259 0
 3377 1c8c 1D02009A 		bls	.L300
 3378              	.LVL309:
 3379              	.L237:
1264:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3380              		.loc 1 1264 0
 3381 1c90 1C0094E5 		ldr	r0, [r4, #28]
 3382 1c94 FEFFFFEB 		bl	_txe_mutex_put
1266:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3383              		.loc 1 1266 0
 3384 1c98 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 3385 1c9c C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 3386 1ca0 9DA4D6E5 		ldrb	sl, [r6, #1181]	@ zero_extendqisi2
 3387              	.LVL310:
1265:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3388              		.loc 1 1265 0
 3389 1ca4 1C409DE5 		ldr	r4, [sp, #28]
 3390 1ca8 00A08DE5 		str	sl, [sp, #0]
 3391 1cac 0400A0E3 		mov	r0, #4
 3392 1cb0 C4109FE5 		ldr	r1, .L303+44
1267:../uvc.c      **** 							 break;
 3393              		.loc 1 1267 0
 3394 1cb4 FFA0A0E3 		mov	sl, #255
1265:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3395              		.loc 1 1265 0
 3396 1cb8 04708DE5 		str	r7, [sp, #4]
 3397 1cbc 08408DE5 		str	r4, [sp, #8]
1267:../uvc.c      **** 							 break;
 3398              		.loc 1 1267 0
 3399 1cc0 0A70A0E1 		mov	r7, sl
 3400              	.LVL311:
1265:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3401              		.loc 1 1265 0
 3402 1cc4 FEFFFFEB 		bl	CyU3PDebugPrint
 3403              	.LVL312:
 3404 1cc8 18809DE5 		ldr	r8, [sp, #24]
1267:../uvc.c      **** 							 break;
 3405              		.loc 1 1267 0
 3406 1ccc 65FCFFEA 		b	.L142
 3407              	.LVL313:
 3408              	.L221:
1474:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3409              		.loc 1 1474 0
 3410 1cd0 BC709FE5 		ldr	r7, .L303+68
 3411              	.LVL314:
 3412 1cd4 0010E0E3 		mvn	r1, #0
 3413 1cd8 1C0097E5 		ldr	r0, [r7, #28]
 3414 1cdc FEFFFFEB 		bl	_txe_mutex_get
 3415              	.LVL315:
1475:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3416              		.loc 1 1475 0
 3417 1ce0 0A20A0E1 		mov	r2, sl
 3418 1ce4 18A09DE5 		ldr	sl, [sp, #24]
 3419 1ce8 00C0A0E3 		mov	ip, #0
 3420 1cec 0B10A0E3 		mov	r1, #11
 3421 1cf0 0930A0E1 		mov	r3, r9
 3422 1cf4 0700A0E1 		mov	r0, r7
 3423 1cf8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3424 1cfc FEFFFFEB 		bl	cmdSet
 3425              	.LVL316:
1477:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3426              		.loc 1 1477 0
 3427 1d00 1C409DE5 		ldr	r4, [sp, #28]
 3428 1d04 0180A0E3 		mov	r8, #1
 3429 1d08 0930A0E1 		mov	r3, r9
 3430 1d0c 0B10A0E3 		mov	r1, #11
 3431 1d10 0B20A0E1 		mov	r2, fp
 3432 1d14 0700A0E1 		mov	r0, r7
 3433 1d18 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3434 1d1c FEFFFFEB 		bl	cmdSet
1478:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3435              		.loc 1 1478 0
 3436 1d20 1C0097E5 		ldr	r0, [r7, #28]
 3437 1d24 FEFFFFEB 		bl	_txe_mutex_put
1480:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3438              		.loc 1 1480 0
 3439 1d28 18009DE5 		ldr	r0, [sp, #24]
1481:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3440              		.loc 1 1481 0
 3441 1d2c 1C309DE5 		ldr	r3, [sp, #28]
1483:../uvc.c      **** 							 break;
 3442              		.loc 1 1483 0
 3443 1d30 FFA0A0E3 		mov	sl, #255
1482:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3444              		.loc 1 1482 0
 3445 1d34 9882C6E5 		strb	r8, [r6, #664]
1480:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3446              		.loc 1 1480 0
 3447 1d38 CC04C6E5 		strb	r0, [r6, #1228]
1481:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3448              		.loc 1 1481 0
 3449 1d3c CE34C6E5 		strb	r3, [r6, #1230]
1482:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3450              		.loc 1 1482 0
 3451 1d40 0080A0E1 		mov	r8, r0
 3452 1d44 0340A0E1 		mov	r4, r3
1483:../uvc.c      **** 							 break;
 3453              		.loc 1 1483 0
 3454 1d48 0A70A0E1 		mov	r7, sl
 3455 1d4c 45FCFFEA 		b	.L142
 3456              	.L304:
 3457              		.align	2
 3458              	.L303:
 3459 1d50 00000000 		.word	.LANCHOR1
 3460 1d54 00000000 		.word	bRequest
 3461 1d58 94040000 		.word	.LC28
 3462 1d5c 5C000000 		.word	.LANCHOR0+92
 3463 1d60 01000100 		.word	65537
 3464 1d64 FF00FF00 		.word	16711935
 3465 1d68 44030000 		.word	.LC21
 3466 1d6c 80030000 		.word	.LC22
 3467 1d70 E4020000 		.word	.LC19
 3468 1d74 4C000000 		.word	.LANCHOR0+76
 3469 1d78 08040000 		.word	.LC25
 3470 1d7c D4030000 		.word	.LC24
 3471 1d80 A8030000 		.word	.LC23
 3472 1d84 64040000 		.word	.LC27
 3473 1d88 00000000 		.word	.LANCHOR2
 3474 1d8c BC020000 		.word	.LC18
 3475 1d90 40040000 		.word	.LC26
 3476 1d94 00000000 		.word	cmdQu
 3477 1d98 0C030000 		.word	.LC20
 3478 1d9c 00000000 		.word	.LANCHOR1
 3479 1da0 00000000 		.word	.LANCHOR0
 3480              	.LVL317:
 3481              	.L220:
1560:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3482              		.loc 1 1560 0
 3483 1da4 E484D6E5 		ldrb	r8, [r6, #1252]	@ zero_extendqisi2
1561:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3484              		.loc 1 1561 0
 3485 1da8 E504D6E5 		ldrb	r0, [r6, #1253]	@ zero_extendqisi2
1562:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3486              		.loc 1 1562 0
 3487 1dac F324D6E5 		ldrb	r2, [r6, #1267]	@ zero_extendqisi2
 3488              	.LVL318:
1565:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3489              		.loc 1 1565 0
 3490 1db0 0140A0E3 		mov	r4, #1
1566:../uvc.c      **** 							 if(Data0 != 0){
 3491              		.loc 1 1566 0
 3492 1db4 000053E3 		cmp	r3, #0
1564:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3493              		.loc 1 1564 0
 3494 1db8 F134C6E5 		strb	r3, [r6, #1265]
1560:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3495              		.loc 1 1560 0
 3496 1dbc FF8008E2 		and	r8, r8, #255
 3497              	.LVL319:
1561:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3498              		.loc 1 1561 0
 3499 1dc0 FFA000E2 		and	sl, r0, #255
 3500              	.LVL320:
1562:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3501              		.loc 1 1562 0
 3502 1dc4 FF7002E2 		and	r7, r2, #255
 3503              	.LVL321:
1565:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3504              		.loc 1 1565 0
 3505 1dc8 F544C6E5 		strb	r4, [r6, #1269]
1566:../uvc.c      **** 							 if(Data0 != 0){
 3506              		.loc 1 1566 0
 3507 1dcc A200000A 		beq	.L267
1567:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3508              		.loc 1 1567 0
 3509 1dd0 44601FE5 		ldr	r6, .L303+68
 3510 1dd4 0010E0E3 		mvn	r1, #0
 3511 1dd8 1C0096E5 		ldr	r0, [r6, #28]
 3512 1ddc FEFFFFEB 		bl	_txe_mutex_get
 3513              	.LVL322:
1571:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3514              		.loc 1 1571 0
 3515 1de0 0730A0E1 		mov	r3, r7
 3516 1de4 00C0A0E3 		mov	ip, #0
 3517 1de8 0710A0E3 		mov	r1, #7
 3518 1dec 0820A0E1 		mov	r2, r8
 3519 1df0 0600A0E1 		mov	r0, r6
 3520 1df4 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3521 1df8 FEFFFFEB 		bl	cmdSet
 3522              	.LVL323:
1573:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3523              		.loc 1 1573 0
 3524 1dfc 0730A0E1 		mov	r3, r7
 3525 1e00 18709DE5 		ldr	r7, [sp, #24]
 3526              	.LVL324:
 3527 1e04 0710A0E3 		mov	r1, #7
 3528 1e08 0A20A0E1 		mov	r2, sl
 3529 1e0c 0600A0E1 		mov	r0, r6
 3530 1e10 00708DE5 		str	r7, [sp, #0]
 3531 1e14 04408DE5 		str	r4, [sp, #4]
 3532 1e18 FEFFFFEB 		bl	cmdSet
 3533              	.LVL325:
1575:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3534              		.loc 1 1575 0
 3535 1e1c 1C0096E5 		ldr	r0, [r6, #28]
 3536 1e20 B2FEFFEA 		b	.L291
 3537              	.LVL326:
 3538              	.L222:
1176:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3539              		.loc 1 1176 0
 3540 1e24 90A4D6E5 		ldrb	sl, [r6, #1168]	@ zero_extendqisi2
 3541 1e28 0310A0E1 		mov	r1, r3
1177:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3542              		.loc 1 1177 0
 3543 1e2c 9184D6E5 		ldrb	r8, [r6, #1169]	@ zero_extendqisi2
1178:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3544              		.loc 1 1178 0
 3545 1e30 9F44D6E5 		ldrb	r4, [r6, #1183]	@ zero_extendqisi2
1179:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3546              		.loc 1 1179 0
 3547 1e34 9D34C6E5 		strb	r3, [r6, #1181]
1181:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3548              		.loc 1 1181 0
 3549 1e38 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
1176:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3550              		.loc 1 1176 0
 3551 1e3c FF700AE2 		and	r7, sl, #255
 3552              	.LVL327:
1181:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3553              		.loc 1 1181 0
 3554 1e40 030013E3 		tst	r3, #3
1177:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3555              		.loc 1 1177 0
 3556 1e44 FF8008E2 		and	r8, r8, #255
 3557              	.LVL328:
1178:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3558              		.loc 1 1178 0
 3559 1e48 FF4004E2 		and	r4, r4, #255
 3560              	.LVL329:
1181:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3561              		.loc 1 1181 0
 3562 1e4c 0130A001 		moveq	r3, r1
 3563 1e50 1D00000A 		beq	.L235
1183:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3564              		.loc 1 1183 0
 3565 1e54 C0301FE5 		ldr	r3, .L303+76
1185:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3566              		.loc 1 1185 0
 3567 1e58 CCA01FE5 		ldr	sl, .L303+68
1183:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3568              		.loc 1 1183 0
 3569 1e5c C5E4D3E5 		ldrb	lr, [r3, #1221]	@ zero_extendqisi2
 3570 1e60 0190A0E1 		mov	r9, r1
 3571 1e64 09228EE1 		orr	r2, lr, r9, asl #4
 3572              	.LVL330:
1185:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3573              		.loc 1 1185 0
 3574 1e68 0010E0E3 		mvn	r1, #0
 3575 1e6c 1C009AE5 		ldr	r0, [sl, #28]
1183:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3576              		.loc 1 1183 0
 3577 1e70 FF9002E2 		and	r9, r2, #255
 3578              	.LVL331:
1185:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3579              		.loc 1 1185 0
 3580 1e74 14C08DE5 		str	ip, [sp, #20]
 3581 1e78 FEFFFFEB 		bl	_txe_mutex_get
 3582              	.LVL332:
1186:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3583              		.loc 1 1186 0
 3584 1e7c 00C0A0E3 		mov	ip, #0
 3585 1e80 1010A0E3 		mov	r1, #16
 3586 1e84 0820A0E1 		mov	r2, r8
 3587 1e88 0430A0E1 		mov	r3, r4
 3588 1e8c 0A00A0E1 		mov	r0, sl
 3589 1e90 00C08DE5 		str	ip, [sp, #0]
 3590 1e94 04C08DE5 		str	ip, [sp, #4]
 3591 1e98 FEFFFFEB 		bl	cmdSet
 3592              	.LVL333:
1188:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3593              		.loc 1 1188 0
 3594 1e9c 0720A0E1 		mov	r2, r7
 3595 1ea0 0430A0E1 		mov	r3, r4
 3596 1ea4 1010A0E3 		mov	r1, #16
 3597 1ea8 0A00A0E1 		mov	r0, sl
 3598 1eac 0170A0E3 		mov	r7, #1
 3599              	.LVL334:
 3600 1eb0 00908DE5 		str	r9, [sp, #0]
 3601 1eb4 04708DE5 		str	r7, [sp, #4]
 3602 1eb8 FEFFFFEB 		bl	cmdSet
 3603              	.LVL335:
1189:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3604              		.loc 1 1189 0
 3605 1ebc 1C009AE5 		ldr	r0, [sl, #28]
 3606 1ec0 FEFFFFEB 		bl	_txe_mutex_put
 3607 1ec4 14C09DE5 		ldr	ip, [sp, #20]
 3608 1ec8 0930A0E1 		mov	r3, r9
 3609              	.LVL336:
 3610              	.L235:
1192:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3611              		.loc 1 1192 0
 3612 1ecc C584D6E5 		ldrb	r8, [r6, #1221]	@ zero_extendqisi2
 3613              	.LVL337:
 3614 1ed0 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 3615              	.LVL338:
1191:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3616              		.loc 1 1191 0
 3617 1ed4 0400A0E3 		mov	r0, #4
 3618 1ed8 60111FE5 		ldr	r1, .L303+48
 3619 1edc 0C20A0E1 		mov	r2, ip
1193:../uvc.c      **** 						     break;
 3620              		.loc 1 1193 0
 3621 1ee0 FFA0A0E3 		mov	sl, #255
1191:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3622              		.loc 1 1191 0
 3623 1ee4 00808DE5 		str	r8, [sp, #0]
 3624 1ee8 04408DE5 		str	r4, [sp, #4]
1193:../uvc.c      **** 						     break;
 3625              		.loc 1 1193 0
 3626 1eec 0A70A0E1 		mov	r7, sl
1191:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3627              		.loc 1 1191 0
 3628 1ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 3629 1ef4 18809DE5 		ldr	r8, [sp, #24]
 3630 1ef8 1C409DE5 		ldr	r4, [sp, #28]
1193:../uvc.c      **** 						     break;
 3631              		.loc 1 1193 0
 3632 1efc D9FBFFEA 		b	.L142
 3633              	.LVL339:
 3634              	.L215:
1422:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3635              		.loc 1 1422 0
 3636 1f00 74A11FE5 		ldr	sl, .L303+68
 3637 1f04 0010E0E3 		mvn	r1, #0
 3638 1f08 1C009AE5 		ldr	r0, [sl, #28]
 3639 1f0c FEFFFFEB 		bl	_txe_mutex_get
 3640              	.LVL340:
1424:../uvc.c      **** 							  if(Data0&0x80){
 3641              		.loc 1 1424 0
 3642 1f10 18109DE5 		ldr	r1, [sp, #24]
1429:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3643              		.loc 1 1429 0
 3644 1f14 0B20A0E1 		mov	r2, fp
1424:../uvc.c      **** 							  if(Data0&0x80){
 3645              		.loc 1 1424 0
 3646 1f18 800011E3 		tst	r1, #128
1425:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3647              		.loc 1 1425 0
 3648 1f1c 80704112 		subne	r7, r1, #128
 3649              	.LVL341:
1427:../uvc.c      **** 								  Data0 = ~Data0;
 3650              		.loc 1 1427 0
 3651 1f20 0170E001 		mvneq	r7, r1
 3652 1f24 FF8007E2 		and	r8, r7, #255
 3653              	.LVL342:
1429:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3654              		.loc 1 1429 0
 3655 1f28 0110A0E3 		mov	r1, #1
 3656 1f2c 0930A0E1 		mov	r3, r9
 3657 1f30 0040A0E3 		mov	r4, #0
 3658 1f34 A8011FE5 		ldr	r0, .L303+68
 3659 1f38 00808DE5 		str	r8, [sp, #0]
 3660 1f3c 04408DE5 		str	r4, [sp, #4]
1433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3661              		.loc 1 1433 0
 3662 1f40 0170A0E3 		mov	r7, #1
1429:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3663              		.loc 1 1429 0
 3664 1f44 FEFFFFEB 		bl	cmdSet
1430:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3665              		.loc 1 1430 0
 3666 1f48 1C009AE5 		ldr	r0, [sl, #28]
 3667 1f4c FEFFFFEB 		bl	_txe_mutex_put
1436:../uvc.c      **** 							 break;
 3668              		.loc 1 1436 0
 3669 1f50 FFA0A0E3 		mov	sl, #255
1432:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3670              		.loc 1 1432 0
 3671 1f54 A581C6E5 		strb	r8, [r6, #421]
1433:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3672              		.loc 1 1433 0
 3673 1f58 A871C6E5 		strb	r7, [r6, #424]
 3674 1f5c 18809DE5 		ldr	r8, [sp, #24]
 3675              	.LVL343:
 3676 1f60 1C409DE5 		ldr	r4, [sp, #28]
1436:../uvc.c      **** 							 break;
 3677              		.loc 1 1436 0
 3678 1f64 0A70A0E1 		mov	r7, sl
 3679 1f68 BEFBFFEA 		b	.L142
 3680              	.LVL344:
 3681              	.L214:
1543:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3682              		.loc 1 1543 0
 3683 1f6c D4411FE5 		ldr	r4, .L303+80
1533:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3684              		.loc 1 1533 0
 3685 1f70 D074D6E5 		ldrb	r7, [r6, #1232]	@ zero_extendqisi2
 3686              	.LVL345:
1543:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3687              		.loc 1 1543 0
 3688 1f74 BC20D4E5 		ldrb	r2, [r4, #188]	@ zero_extendqisi2
 3689              	.LVL346:
 3690 1f78 0310A0E1 		mov	r1, r3
1534:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3691              		.loc 1 1534 0
 3692 1f7c D134D6E5 		ldrb	r3, [r6, #1233]	@ zero_extendqisi2
1535:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3693              		.loc 1 1535 0
 3694 1f80 DF34D6E5 		ldrb	r3, [r6, #1247]	@ zero_extendqisi2
1543:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3695              		.loc 1 1543 0
 3696 1f84 010052E3 		cmp	r2, #1
1541:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3697              		.loc 1 1541 0
 3698 1f88 01E0A0E3 		mov	lr, #1
1540:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3699              		.loc 1 1540 0
 3700 1f8c DD14C6E5 		strb	r1, [r6, #1245]
1533:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3701              		.loc 1 1533 0
 3702 1f90 FF7007E2 		and	r7, r7, #255
 3703              	.LVL347:
1541:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3704              		.loc 1 1541 0
 3705 1f94 E1E4C6E5 		strb	lr, [r6, #1249]
1535:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3706              		.loc 1 1535 0
 3707 1f98 FF8003E2 		and	r8, r3, #255
 3708              	.LVL348:
 3709 1f9c 0160A011 		movne	r6, r1
1543:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3710              		.loc 1 1543 0
 3711 1fa0 3C01000A 		beq	.L301
 3712              	.LVL349:
 3713              	.L265:
1554:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3714              		.loc 1 1554 0
 3715 1fa4 18A21FE5 		ldr	sl, .L303+68
 3716 1fa8 0010E0E3 		mvn	r1, #0
 3717 1fac 1C009AE5 		ldr	r0, [sl, #28]
 3718 1fb0 FEFFFFEB 		bl	_txe_mutex_get
1555:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3719              		.loc 1 1555 0
 3720 1fb4 00C0A0E3 		mov	ip, #0
 3721 1fb8 0C10A0E1 		mov	r1, ip
 3722 1fbc 0720A0E1 		mov	r2, r7
 3723 1fc0 0830A0E1 		mov	r3, r8
 3724 1fc4 0A00A0E1 		mov	r0, sl
 3725 1fc8 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3726 1fcc FEFFFFEB 		bl	cmdSet
1556:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3727              		.loc 1 1556 0
 3728 1fd0 1C009AE5 		ldr	r0, [sl, #28]
 3729 1fd4 45FEFFEA 		b	.L291
 3730              	.LVL350:
 3731              	.L213:
1599:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3732              		.loc 1 1599 0
 3733 1fd8 4C821FE5 		ldr	r8, .L303+68
 3734 1fdc 0010E0E3 		mvn	r1, #0
 3735 1fe0 1C0098E5 		ldr	r0, [r8, #28]
 3736 1fe4 FEFFFFEB 		bl	_txe_mutex_get
 3737              	.LVL351:
1600:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3738              		.loc 1 1600 0
 3739 1fe8 18709DE5 		ldr	r7, [sp, #24]
 3740              	.LVL352:
 3741 1fec 0A20A0E1 		mov	r2, sl
 3742 1ff0 0410A0E1 		mov	r1, r4
 3743 1ff4 0930A0E1 		mov	r3, r9
 3744 1ff8 0800A0E1 		mov	r0, r8
 3745 1ffc 00A0A0E3 		mov	sl, #0
 3746 2000 80048DE8 		stmia	sp, {r7, sl}	@ phole stm
 3747 2004 FEFFFFEB 		bl	cmdSet
1601:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3748              		.loc 1 1601 0
 3749 2008 1C0098E5 		ldr	r0, [r8, #28]
 3750 200c FEFFFFEB 		bl	_txe_mutex_put
1603:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3751              		.loc 1 1603 0
 3752 2010 18209DE5 		ldr	r2, [sp, #24]
 3753 2014 84C084E0 		add	ip, r4, r4, asl #1
 3754 2018 8C6186E0 		add	r6, r6, ip, asl #3
1605:../uvc.c      **** 							 break;
 3755              		.loc 1 1605 0
 3756 201c FFA0A0E3 		mov	sl, #255
1604:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3757              		.loc 1 1604 0
 3758 2020 0100A0E3 		mov	r0, #1
1603:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3759              		.loc 1 1603 0
 3760 2024 8D21C6E5 		strb	r2, [r6, #397]
1604:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3761              		.loc 1 1604 0
 3762 2028 9001C6E5 		strb	r0, [r6, #400]
 3763 202c 0280A0E1 		mov	r8, r2
 3764 2030 1C409DE5 		ldr	r4, [sp, #28]
1605:../uvc.c      **** 							 break;
 3765              		.loc 1 1605 0
 3766 2034 0A70A0E1 		mov	r7, sl
 3767 2038 8AFBFFEA 		b	.L142
 3768              	.LVL353:
 3769              	.L212:
1608:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3770              		.loc 1 1608 0
 3771 203c FFA0A0E3 		mov	sl, #255
 3772 2040 0400A0E3 		mov	r0, #4
 3773              	.LVL354:
 3774 2044 C8121FE5 		ldr	r1, .L303+52
 3775 2048 FEFFFFEB 		bl	CyU3PDebugPrint
 3776              	.LVL355:
 3777 204c 0A70A0E1 		mov	r7, sl
 3778              	.LVL356:
 3779 2050 0A40A0E1 		mov	r4, sl
 3780 2054 0A80A0E1 		mov	r8, sl
 3781 2058 82FBFFEA 		b	.L142
 3782              	.LVL357:
 3783              	.L267:
1577:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3784              		.loc 1 1577 0
 3785 205c D0421FE5 		ldr	r4, .L303+68
 3786 2060 0010E0E3 		mvn	r1, #0
 3787 2064 1C0094E5 		ldr	r0, [r4, #28]
 3788 2068 FEFFFFEB 		bl	_txe_mutex_get
 3789              	.LVL358:
1578:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3790              		.loc 1 1578 0
 3791 206c 18E09DE5 		ldr	lr, [sp, #24]
 3792 2070 0820A0E1 		mov	r2, r8
 3793 2074 0730A0E1 		mov	r3, r7
 3794 2078 0710A0E3 		mov	r1, #7
 3795 207c 0400A0E1 		mov	r0, r4
 3796 2080 00E08DE5 		str	lr, [sp, #0]
 3797 2084 04E08DE5 		str	lr, [sp, #4]
1579:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3798              		.loc 1 1579 0
 3799 2088 FFA0A0E3 		mov	sl, #255
 3800              	.LVL359:
1578:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3801              		.loc 1 1578 0
 3802 208c FEFFFFEB 		bl	cmdSet
1579:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3803              		.loc 1 1579 0
 3804 2090 1C0094E5 		ldr	r0, [r4, #28]
 3805 2094 FEFFFFEB 		bl	_txe_mutex_put
 3806 2098 0A70A0E1 		mov	r7, sl
 3807              	.LVL360:
 3808 209c 1C409DE5 		ldr	r4, [sp, #28]
 3809 20a0 18809DE5 		ldr	r8, [sp, #24]
 3810              	.LVL361:
 3811 20a4 6FFBFFEA 		b	.L142
 3812              	.LVL362:
 3813              	.L195:
1044:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3814              		.loc 1 1044 0
 3815 20a8 0A00A0E1 		mov	r0, sl
 3816              	.LVL363:
 3817 20ac 0910A0E1 		mov	r1, r9
 3818 20b0 FEFFFFEB 		bl	SensorGetControl
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3819              		.loc 1 1047 0
 3820 20b4 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1049:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3821              		.loc 1 1049 0
 3822 20b8 01C0A0E3 		mov	ip, #1
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3823              		.loc 1 1047 0
 3824 20bc 5DA0C4E5 		strb	sl, [r4, #93]
1049:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3825              		.loc 1 1049 0
 3826 20c0 80C0C4E5 		strb	ip, [r4, #128]
1046:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
 3827              		.loc 1 1046 0
 3828 20c4 807000E2 		and	r7, r0, #128
 3829              	.LVL364:
1045:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3830              		.loc 1 1045 0
 3831 20c8 ED01C6E5 		strb	r0, [r6, #493]
1046:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
 3832              		.loc 1 1046 0
 3833 20cc 5C70C4E5 		strb	r7, [r4, #92]
1053:../uvc.c      **** 					 break;
 3834              		.loc 1 1053 0
 3835 20d0 65FCFFEA 		b	.L164
 3836              	.LVL365:
 3837              	.L187:
 981:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 3838              		.loc 1 981 0
 3839 20d4 0B00A0E1 		mov	r0, fp
 3840              	.LVL366:
 3841 20d8 0910A0E1 		mov	r1, r9
 3842 20dc FEFFFFEB 		bl	SensorGetControl
 984:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3843              		.loc 1 984 0
 3844 20e0 01C0A0E3 		mov	ip, #1
 3845 20e4 7CC0C4E5 		strb	ip, [r4, #124]
 982:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 3846              		.loc 1 982 0
 3847 20e8 DD04C6E5 		strb	r0, [r6, #1245]
 983:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3848              		.loc 1 983 0
 3849 20ec DE34D6E5 		ldrb	r3, [r6, #1246]	@ zero_extendqisi2
 981:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 3850              		.loc 1 981 0
 3851 20f0 0070A0E1 		mov	r7, r0
 3852              	.LVL367:
 983:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3853              		.loc 1 983 0
 3854 20f4 FFA003E2 		and	sl, r3, #255
 3855              	.LVL368:
 981:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 3856              		.loc 1 981 0
 3857 20f8 5C00C4E5 		strb	r0, [r4, #92]
 983:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3858              		.loc 1 983 0
 3859 20fc 5DA0C4E5 		strb	sl, [r4, #93]
 988:../uvc.c      **** 					 break;
 3860              		.loc 1 988 0
 3861 2100 59FCFFEA 		b	.L164
 3862              	.LVL369:
 3863              	.L191:
1014:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3864              		.loc 1 1014 0
 3865 2104 0A00A0E1 		mov	r0, sl
 3866              	.LVL370:
 3867 2108 0910A0E1 		mov	r1, r9
 3868 210c FEFFFFEB 		bl	SensorGetControl
1016:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3869              		.loc 1 1016 0
 3870 2110 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1017:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3871              		.loc 1 1017 0
 3872 2114 01C0A0E3 		mov	ip, #1
1016:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3873              		.loc 1 1016 0
 3874 2118 5DA0CBE5 		strb	sl, [fp, #93]
1017:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3875              		.loc 1 1017 0
 3876 211c 7CC0C4E5 		strb	ip, [r4, #124]
1014:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3877              		.loc 1 1014 0
 3878 2120 0070A0E1 		mov	r7, r0
 3879              	.LVL371:
 3880 2124 5C00CBE5 		strb	r0, [fp, #92]
1015:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 3881              		.loc 1 1015 0
 3882 2128 BD01C6E5 		strb	r0, [r6, #445]
1021:../uvc.c      **** 					 break;
 3883              		.loc 1 1021 0
 3884 212c 4EFCFFEA 		b	.L164
 3885              	.LVL372:
 3886              	.L193:
1028:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3887              		.loc 1 1028 0
 3888 2130 0A00A0E1 		mov	r0, sl
 3889              	.LVL373:
 3890 2134 0910A0E1 		mov	r1, r9
 3891 2138 FEFFFFEB 		bl	SensorGetControl
1031:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3892              		.loc 1 1031 0
 3893 213c 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
 3894 2140 5DA0C4E5 		strb	sl, [r4, #93]
1030:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 3895              		.loc 1 1030 0
 3896 2144 037000E2 		and	r7, r0, #3
 3897              	.LVL374:
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3898              		.loc 1 1029 0
 3899 2148 6502C6E5 		strb	r0, [r6, #613]
1033:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3900              		.loc 1 1033 0
 3901 214c 0100A0E3 		mov	r0, #1
1030:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 3902              		.loc 1 1030 0
 3903 2150 5C70C4E5 		strb	r7, [r4, #92]
1033:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3904              		.loc 1 1033 0
 3905 2154 8500C4E5 		strb	r0, [r4, #133]
 3906              	.LVL375:
1037:../uvc.c      **** 					 break;
 3907              		.loc 1 1037 0
 3908 2158 43FCFFEA 		b	.L164
 3909              	.LVL376:
 3910              	.L298:
 941:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 3911              		.loc 1 941 0
 3912 215c 0A00A0E1 		mov	r0, sl
 3913 2160 0910A0E1 		mov	r1, r9
 3914 2164 FEFFFFEB 		bl	SensorGetControl
 3915              	.LVL377:
 943:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3916              		.loc 1 943 0
 3917 2168 01A0A0E3 		mov	sl, #1
 3918 216c 7DA0C4E5 		strb	sl, [r4, #125]
 942:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 3919              		.loc 1 942 0
 3920 2170 A501C6E5 		strb	r0, [r6, #421]
 3921 2174 D6FCFFEA 		b	.L182
 3922              	.LVL378:
 3923              	.L165:
 804:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 3924              		.loc 1 804 0
 3925 2178 0A00A0E1 		mov	r0, sl
 3926              	.LVL379:
 3927 217c 0910A0E1 		mov	r1, r9
 3928 2180 FEFFFFEB 		bl	SensorGetControl
 3929              	.LVL380:
 810:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 3930              		.loc 1 810 0
 3931 2184 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 3932 2188 5DA0C4E5 		strb	sl, [r4, #93]
 805:../uvc.c      **** 			 	 			if(Data0&0x80)
 3933              		.loc 1 805 0
 3934 218c 800010E3 		tst	r0, #128
 806:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 3935              		.loc 1 806 0
 3936 2190 0170A013 		movne	r7, #1
 3937              	.LVL381:
 808:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 3938              		.loc 1 808 0
 3939 2194 0B70A001 		moveq	r7, fp
 811:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 3940              		.loc 1 811 0
 3941 2198 0100A0E3 		mov	r0, #1
 3942              	.LVL382:
 806:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 3943              		.loc 1 806 0
 3944 219c 5C70C415 		strneb	r7, [r4, #92]
 808:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 3945              		.loc 1 808 0
 3946 21a0 5CB0C405 		streqb	fp, [r4, #92]
 809:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 3947              		.loc 1 809 0
 3948 21a4 9D70C6E5 		strb	r7, [r6, #157]
 811:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 3949              		.loc 1 811 0
 3950 21a8 A200C4E5 		strb	r0, [r4, #162]
 3951              	.LVL383:
 815:../uvc.c      **** 			 	 		 break;
 3952              		.loc 1 815 0
 3953 21ac 2EFCFFEA 		b	.L164
 3954              	.LVL384:
 3955              	.L162:
 787:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3956              		.loc 1 787 0
 3957 21b0 0A00A0E1 		mov	r0, sl
 3958 21b4 0910A0E1 		mov	r1, r9
 3959 21b8 FEFFFFEB 		bl	SensorGetControl
 788:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3960              		.loc 1 788 0
 3961 21bc 3CC41FE5 		ldr	ip, .L303+56
 3962 21c0 04118CE0 		add	r1, ip, r4, asl #2
 3963 21c4 20A011E5 		ldr	sl, [r1, #-32]
 790:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 3964              		.loc 1 790 0
 3965 21c8 0140A0E3 		mov	r4, #1
 787:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3966              		.loc 1 787 0
 3967 21cc 5C00C6E5 		strb	r0, [r6, #92]
 788:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3968              		.loc 1 788 0
 3969 21d0 0D00CAE5 		strb	r0, [sl, #13]
 789:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3970              		.loc 1 789 0
 3971 21d4 0E20DAE5 		ldrb	r2, [sl, #14]	@ zero_extendqisi2
 787:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3972              		.loc 1 787 0
 3973 21d8 0070A0E1 		mov	r7, r0
 3974              	.LVL385:
 789:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3975              		.loc 1 789 0
 3976 21dc FFA002E2 		and	sl, r2, #255
 790:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 3977              		.loc 1 790 0
 3978 21e0 7C40CBE5 		strb	r4, [fp, #124]
 3979              	.LVL386:
 789:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3980              		.loc 1 789 0
 3981 21e4 5DA0C6E5 		strb	sl, [r6, #93]
 794:../uvc.c      **** 			 	 		 break;
 3982              		.loc 1 794 0
 3983 21e8 1FFCFFEA 		b	.L164
 3984              	.LVL387:
 3985              	.L179:
 904:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 3986              		.loc 1 904 0
 3987 21ec 0710A0E1 		mov	r1, r7
 3988 21f0 FEFFFFEB 		bl	SensorGetControl
 3989              	.LVL388:
 908:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3990              		.loc 1 908 0
 3991 21f4 0710A0E1 		mov	r1, r7
 905:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 3992              		.loc 1 905 0
 3993 21f8 032000E2 		and	r2, r0, #3
 3994 21fc 5C20C4E5 		strb	r2, [r4, #92]
 908:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3995              		.loc 1 908 0
 3996 2200 0A00A0E1 		mov	r0, sl
 906:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 3997              		.loc 1 906 0
 3998 2204 C524C6E5 		strb	r2, [r6, #1221]
 908:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 3999              		.loc 1 908 0
 4000 2208 FEFFFFEB 		bl	SensorGetControl
 910:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4001              		.loc 1 910 0
 4002 220c 0130A0E3 		mov	r3, #1
 4003 2210 9530C4E5 		strb	r3, [r4, #149]
 908:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4004              		.loc 1 908 0
 4005 2214 5E00C4E5 		strb	r0, [r4, #94]
 909:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4006              		.loc 1 909 0
 4007 2218 C604C6E5 		strb	r0, [r6, #1222]
 4008 221c 67FCFFEA 		b	.L180
 4009              	.LVL389:
 4010              	.L169:
 830:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4011              		.loc 1 830 0
 4012 2220 4F20E0E3 		mvn	r2, #79
 4013 2224 9D24C3E5 		strb	r2, [r3, #1181]
 4014              	.LVL390:
 833:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4015              		.loc 1 833 0
 4016 2228 9EE4D3E5 		ldrb	lr, [r3, #1182]	@ zero_extendqisi2
 832:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4017              		.loc 1 832 0
 4018 222c 03C0A0E3 		mov	ip, #3
 4019 2230 5CC0C4E5 		strb	ip, [r4, #92]
 833:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4020              		.loc 1 833 0
 4021 2234 5DE0C4E5 		strb	lr, [r4, #93]
 835:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4022              		.loc 1 835 0
 4023 2238 0C20A0E1 		mov	r2, ip
 4024 223c 0400A0E3 		mov	r0, #4
 4025              	.LVL391:
 4026 2240 BC141FE5 		ldr	r1, .L303+60
 4027 2244 0C30A0E1 		mov	r3, ip
 4028 2248 B0A0A0E3 		mov	sl, #176
 4029 224c 00A08DE5 		str	sl, [sp, #0]
 4030 2250 FEFFFFEB 		bl	CyU3PDebugPrint
 4031 2254 5C70D4E5 		ldrb	r7, [r4, #92]	@ zero_extendqisi2
 4032              	.LVL392:
 4033 2258 71FCFFEA 		b	.L170
 4034              	.LVL393:
 4035              	.L171:
 854:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4036              		.loc 1 854 0
 4037 225c FEFFFFEB 		bl	SensorGetControl
 4038              	.LVL394:
 857:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4039              		.loc 1 857 0
 4040 2260 01C0A0E3 		mov	ip, #1
 4041 2264 97C0C4E5 		strb	ip, [r4, #151]
 855:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4042              		.loc 1 855 0
 4043 2268 B104C6E5 		strb	r0, [r6, #1201]
 856:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4044              		.loc 1 856 0
 4045 226c B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 854:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4046              		.loc 1 854 0
 4047 2270 0070A0E1 		mov	r7, r0
 4048              	.LVL395:
 856:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4049              		.loc 1 856 0
 4050 2274 FFA002E2 		and	sl, r2, #255
 4051              	.LVL396:
 854:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4052              		.loc 1 854 0
 4053 2278 5C00C4E5 		strb	r0, [r4, #92]
 856:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4054              		.loc 1 856 0
 4055 227c 5DA0C4E5 		strb	sl, [r4, #93]
 861:../uvc.c      **** 			 		 break;
 4056              		.loc 1 861 0
 4057 2280 F9FBFFEA 		b	.L164
 4058              	.LVL397:
 4059              	.L197:
1062:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4060              		.loc 1 1062 0
 4061 2284 0A00A0E1 		mov	r0, sl
 4062              	.LVL398:
 4063 2288 0910A0E1 		mov	r1, r9
 4064 228c 14308DE5 		str	r3, [sp, #20]
 4065 2290 FEFFFFEB 		bl	SensorGetControl
1063:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4066              		.loc 1 1063 0
 4067 2294 84A084E0 		add	sl, r4, r4, asl #1
 4068 2298 8A6186E0 		add	r6, r6, sl, asl #3
1064:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4069              		.loc 1 1064 0
 4070 229c 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
 4071 22a0 5DA0CBE5 		strb	sl, [fp, #93]
1062:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4072              		.loc 1 1062 0
 4073 22a4 5C00CBE5 		strb	r0, [fp, #92]
1063:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4074              		.loc 1 1063 0
 4075 22a8 8D01C6E5 		strb	r0, [r6, #397]
1065:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4076              		.loc 1 1065 0
 4077 22ac 14309DE5 		ldr	r3, [sp, #20]
1062:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4078              		.loc 1 1062 0
 4079 22b0 0070A0E1 		mov	r7, r0
 4080              	.LVL399:
1065:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4081              		.loc 1 1065 0
 4082 22b4 0100A0E3 		mov	r0, #1
 4083 22b8 7C00C3E5 		strb	r0, [r3, #124]
 4084              	.LVL400:
1071:../uvc.c      **** 					 break;
 4085              		.loc 1 1071 0
 4086 22bc EAFBFFEA 		b	.L164
 4087              	.LVL401:
 4088              	.L189:
 997:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4089              		.loc 1 997 0
 4090 22c0 0910A0E1 		mov	r1, r9
 4091 22c4 0B00A0E1 		mov	r0, fp
 4092              	.LVL402:
 4093 22c8 FEFFFFEB 		bl	SensorGetControl
1000:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4094              		.loc 1 1000 0
 4095 22cc 0110A0E3 		mov	r1, #1
 4096 22d0 8310C4E5 		strb	r1, [r4, #131]
 998:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4097              		.loc 1 998 0
 4098 22d4 F104C6E5 		strb	r0, [r6, #1265]
 999:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4099              		.loc 1 999 0
 4100 22d8 F2A4D6E5 		ldrb	sl, [r6, #1266]	@ zero_extendqisi2
 997:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4101              		.loc 1 997 0
 4102 22dc 0070A0E1 		mov	r7, r0
 4103              	.LVL403:
 999:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4104              		.loc 1 999 0
 4105 22e0 FFA00AE2 		and	sl, sl, #255
 4106              	.LVL404:
 997:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4107              		.loc 1 997 0
 4108 22e4 5C00C4E5 		strb	r0, [r4, #92]
 999:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4109              		.loc 1 999 0
 4110 22e8 5DA0C4E5 		strb	sl, [r4, #93]
1004:../uvc.c      **** 					 break;
 4111              		.loc 1 1004 0
 4112 22ec DEFBFFEA 		b	.L164
 4113              	.LVL405:
 4114              	.L299:
1503:../uvc.c      **** 			                       switch (setRes)
 4115              		.loc 1 1503 0
 4116 22f0 BD70DEE5 		ldrb	r7, [lr, #189]	@ zero_extendqisi2
 4117              	.LVL406:
 4118 22f4 018047E2 		sub	r8, r7, #1
 4119 22f8 030058E3 		cmp	r8, #3
 4120 22fc 08F19F97 		ldrls	pc, [pc, r8, asl #2]
 4121 2300 1FFEFFEA 		b	.L251
 4122              	.L256:
 4123 2304 30240000 		.word	.L252
 4124 2308 DC230000 		.word	.L253
 4125 230c 78230000 		.word	.L254
 4126 2310 14230000 		.word	.L255
 4127              	.L255:
1521:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4128              		.loc 1 1521 0
 4129 2314 7C051FE5 		ldr	r0, .L303+80
1523:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4130              		.loc 1 1523 0
 4131 2318 80A51FE5 		ldr	sl, .L303+80
1521:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4132              		.loc 1 1521 0
 4133 231c 582090E5 		ldr	r2, [r0, #88]
 4134 2320 8C84D6E5 		ldrb	r8, [r6, #1164]	@ zero_extendqisi2
 4135 2324 000052E3 		cmp	r2, #0
 4136 2328 F420A003 		moveq	r2, #244
 4137 232c 7420A013 		movne	r2, #116
 4138 2330 082082E1 		orr	r2, r2, r8
 4139 2334 3010A0E3 		mov	r1, #48
 4140 2338 5230A0E3 		mov	r3, #82
 4141 233c 0100A0E3 		mov	r0, #1
 4142 2340 FEFFFFEB 		bl	SensorSetIrisControl
 4143              	.LVL407:
1522:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4144              		.loc 1 1522 0
 4145 2344 7D0FA0E3 		mov	r0, #500
 4146 2348 FEFFFFEB 		bl	_tx_thread_sleep
1523:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4147              		.loc 1 1523 0
 4148 234c 58C09AE5 		ldr	ip, [sl, #88]
 4149 2350 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 4150 2354 00005CE3 		cmp	ip, #0
 4151 2358 F4C0A003 		moveq	ip, #244
 4152 235c 74C0A013 		movne	ip, #116
 4153 2360 58309AE5 		ldr	r3, [sl, #88]
 4154 2364 DC151FE5 		ldr	r1, .L303+64
 4155 2368 04208CE1 		orr	r2, ip, r4
 4156 236c 0400A0E3 		mov	r0, #4
 4157 2370 FEFFFFEB 		bl	CyU3PDebugPrint
 4158 2374 02FEFFEA 		b	.L251
 4159              	.LVL408:
 4160              	.L254:
1516:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 4161              		.loc 1 1516 0
 4162 2378 E0751FE5 		ldr	r7, .L303+80
 4163 237c 3010A0E3 		mov	r1, #48
 4164 2380 58E097E5 		ldr	lr, [r7, #88]
 4165 2384 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 4166 2388 00005EE3 		cmp	lr, #0
 4167 238c C4E0A003 		moveq	lr, #196
 4168 2390 44E0A013 		movne	lr, #68
 4169 2394 03208EE1 		orr	r2, lr, r3
 4170 2398 0100A0E3 		mov	r0, #1
 4171 239c 5230A0E3 		mov	r3, #82
 4172 23a0 FEFFFFEB 		bl	SensorSetIrisControl
 4173              	.LVL409:
1517:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4174              		.loc 1 1517 0
 4175 23a4 7D0FA0E3 		mov	r0, #500
 4176 23a8 FEFFFFEB 		bl	_tx_thread_sleep
1518:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4177              		.loc 1 1518 0
 4178 23ac 14161FE5 		ldr	r1, .L303+80
 4179 23b0 580091E5 		ldr	r0, [r1, #88]
 4180 23b4 8C84D6E5 		ldrb	r8, [r6, #1164]	@ zero_extendqisi2
 4181 23b8 000050E3 		cmp	r0, #0
 4182 23bc C400A003 		moveq	r0, #196
 4183 23c0 4400A013 		movne	r0, #68
 4184 23c4 583091E5 		ldr	r3, [r1, #88]
 4185 23c8 082080E1 		orr	r2, r0, r8
 4186 23cc 44161FE5 		ldr	r1, .L303+64
 4187 23d0 0400A0E3 		mov	r0, #4
 4188 23d4 FEFFFFEB 		bl	CyU3PDebugPrint
1519:../uvc.c      **** 			                         		break;
 4189              		.loc 1 1519 0
 4190 23d8 E9FDFFEA 		b	.L251
 4191              	.LVL410:
 4192              	.L253:
1511:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4193              		.loc 1 1511 0
 4194 23dc 44261FE5 		ldr	r2, .L303+80
1513:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4195              		.loc 1 1513 0
 4196 23e0 48A61FE5 		ldr	sl, .L303+80
1511:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4197              		.loc 1 1511 0
 4198 23e4 582092E5 		ldr	r2, [r2, #88]
 4199 23e8 3010A0E3 		mov	r1, #48
 4200 23ec 000052E3 		cmp	r2, #0
 4201 23f0 D420A003 		moveq	r2, #212
 4202 23f4 5420A013 		movne	r2, #84
 4203 23f8 5230A0E3 		mov	r3, #82
 4204 23fc 0100A0E3 		mov	r0, #1
 4205 2400 FEFFFFEB 		bl	SensorSetIrisControl
 4206              	.LVL411:
1512:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4207              		.loc 1 1512 0
 4208 2404 7D0FA0E3 		mov	r0, #500
 4209 2408 FEFFFFEB 		bl	_tx_thread_sleep
1513:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4210              		.loc 1 1513 0
 4211 240c 58209AE5 		ldr	r2, [sl, #88]
 4212 2410 88161FE5 		ldr	r1, .L303+64
 4213 2414 000052E3 		cmp	r2, #0
 4214 2418 58309AE5 		ldr	r3, [sl, #88]
 4215 241c D420A003 		moveq	r2, #212
 4216 2420 5420A013 		movne	r2, #84
 4217 2424 0400A0E3 		mov	r0, #4
 4218 2428 FEFFFFEB 		bl	CyU3PDebugPrint
1514:../uvc.c      **** 			                         		break;
 4219              		.loc 1 1514 0
 4220 242c D4FDFFEA 		b	.L251
 4221              	.LVL412:
 4222              	.L252:
1506:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4223              		.loc 1 1506 0
 4224 2430 98C61FE5 		ldr	ip, .L303+80
 4225              	.LVL413:
1508:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4226              		.loc 1 1508 0
 4227 2434 9C461FE5 		ldr	r4, .L303+80
1506:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4228              		.loc 1 1506 0
 4229 2438 58209CE5 		ldr	r2, [ip, #88]
 4230 243c 3010A0E3 		mov	r1, #48
 4231 2440 000052E3 		cmp	r2, #0
 4232 2444 E420A003 		moveq	r2, #228
 4233 2448 6420A013 		movne	r2, #100
 4234 244c 5230A0E3 		mov	r3, #82
 4235 2450 0100A0E3 		mov	r0, #1
 4236 2454 FEFFFFEB 		bl	SensorSetIrisControl
1507:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4237              		.loc 1 1507 0
 4238 2458 7D0FA0E3 		mov	r0, #500
 4239 245c FEFFFFEB 		bl	_tx_thread_sleep
1508:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4240              		.loc 1 1508 0
 4241 2460 582094E5 		ldr	r2, [r4, #88]
 4242 2464 DC161FE5 		ldr	r1, .L303+64
 4243 2468 000052E3 		cmp	r2, #0
 4244 246c 583094E5 		ldr	r3, [r4, #88]
 4245 2470 E420A003 		moveq	r2, #228
 4246 2474 6420A013 		movne	r2, #100
 4247 2478 0400A0E3 		mov	r0, #4
 4248 247c FEFFFFEB 		bl	CyU3PDebugPrint
1509:../uvc.c      **** 			                         		break;
 4249              		.loc 1 1509 0
 4250 2480 BFFDFFEA 		b	.L251
 4251              	.LVL414:
 4252              	.L297:
 866:../uvc.c      **** 						if(sendData >= 3){
 4253              		.loc 1 866 0
 4254 2484 020057E3 		cmp	r7, #2
 4255 2488 2700008A 		bhi	.L302
 4256              	.LVL415:
 4257              	.L174:
 871:../uvc.c      **** 						sendData += 4;
 4258              		.loc 1 871 0
 4259 248c 04E087E2 		add	lr, r7, #4
 4260 2490 FF700EE2 		and	r7, lr, #255
 4261              	.LVL416:
 4262 2494 B5FBFFEA 		b	.L289
 4263              	.LVL417:
 4264              	.L301:
1545:../uvc.c      **** 								 if(Data0 < 3){
 4265              		.loc 1 1545 0
 4266 2498 020051E3 		cmp	r1, #2
1546:../uvc.c      **** 					 				 Data0 += 4;
 4267              		.loc 1 1546 0
 4268 249c 04608192 		addls	r6, r1, #4
 4269 24a0 FF600692 		andls	r6, r6, #255
1545:../uvc.c      **** 								 if(Data0 < 3){
 4270              		.loc 1 1545 0
 4271 24a4 BEFEFF9A 		bls	.L265
1548:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4272              		.loc 1 1548 0
 4273 24a8 0400A0E3 		mov	r0, #4
 4274 24ac 1C171FE5 		ldr	r1, .L303+72
 4275 24b0 18309DE5 		ldr	r3, [sp, #24]
 4276 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4277              	.LVL418:
1549:../uvc.c      **** 									Data0 = 4; //set to default.
 4278              		.loc 1 1549 0
 4279 24b8 0460A0E3 		mov	r6, #4
 4280 24bc B8FEFFEA 		b	.L265
 4281              	.LVL419:
 4282              	.L239:
1285:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4283              		.loc 1 1285 0
 4284 24c0 0A20A0E1 		mov	r2, sl
 4285 24c4 0730A0E1 		mov	r3, r7
 4286 24c8 80C0A0E3 		mov	ip, #128
 4287 24cc 00E0A0E3 		mov	lr, #0
 4288 24d0 1B10A0E3 		mov	r1, #27
 4289 24d4 48071FE5 		ldr	r0, .L303+68
 4290 24d8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 4291 24dc FEFFFFEB 		bl	cmdSet
 4292              	.LVL420:
1287:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4293              		.loc 1 1287 0
 4294 24e0 18A09DE5 		ldr	sl, [sp, #24]
 4295              	.LVL421:
 4296 24e4 0820A0E1 		mov	r2, r8
 4297 24e8 1B10A0E3 		mov	r1, #27
 4298 24ec 0180A0E3 		mov	r8, #1
 4299              	.LVL422:
 4300 24f0 0730A0E1 		mov	r3, r7
 4301 24f4 68071FE5 		ldr	r0, .L303+68
 4302 24f8 00A08DE5 		str	sl, [sp, #0]
 4303 24fc 04808DE5 		str	r8, [sp, #4]
 4304 2500 FEFFFFEB 		bl	cmdSet
 4305              	.LVL423:
 4306 2504 15FDFFEA 		b	.L238
 4307              	.LVL424:
 4308              	.L300:
1260:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4309              		.loc 1 1260 0
 4310 2508 0830A0E1 		mov	r3, r8
 4311 250c 1910A0E3 		mov	r1, #25
 4312 2510 0080A0E3 		mov	r8, #0
 4313              	.LVL425:
 4314 2514 0920A0E1 		mov	r2, r9
 4315 2518 8C071FE5 		ldr	r0, .L303+68
 4316 251c 00E08DE5 		str	lr, [sp, #0]
 4317 2520 04808DE5 		str	r8, [sp, #4]
 4318 2524 FEFFFFEB 		bl	cmdSet
 4319              	.LVL426:
 4320 2528 D8FDFFEA 		b	.L237
 4321              	.LVL427:
 4322              	.L302:
 867:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4323              		.loc 1 867 0
 4324 252c 0730A0E1 		mov	r3, r7
 4325 2530 A0171FE5 		ldr	r1, .L303+72
 4326 2534 0400A0E3 		mov	r0, #4
 4327              	.LVL428:
 4328 2538 FEFFFFEB 		bl	CyU3PDebugPrint
 4329              	.LVL429:
 869:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4330              		.loc 1 869 0
 4331 253c A8171FE5 		ldr	r1, .L303+76
 4332 2540 0000A0E3 		mov	r0, #0
 868:../uvc.c      **** 							sendData = 0; //set back to default
 4333              		.loc 1 868 0
 4334 2544 0070A0E1 		mov	r7, r0
 869:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4335              		.loc 1 869 0
 4336 2548 2D04C1E5 		strb	r0, [r1, #1069]
 4337 254c CEFFFFEA 		b	.L174
 4338              	.LVL430:
 4339              	.L288:
 4340 2550 B8071FE5 		ldr	r0, .L303+80
 4341 2554 74FBFFEA 		b	.L161
 4342              	.LVL431:
 4343              	.L270:
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4344              		.loc 1 735 0
 4345 2558 0030A0E3 		mov	r3, #0
 4346 255c A1FCFFEA 		b	.L282
 4347              	.LVL432:
 4348              	.L268:
 4349 2560 C8071FE5 		ldr	r0, .L303+80
 4350              	.LVL433:
 4351 2564 0030A0E3 		mov	r3, #0
 4352 2568 68FBFFEA 		b	.L281
 4353              		.cfi_endproc
 4354              	.LFE3:
 4356              		.align	2
 4357              		.global	CTControlHandle
 4359              	CTControlHandle:
 4360              	.LFB4:
1624:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4361              		.loc 1 1624 0
 4362              		.cfi_startproc
 4363              		@ args = 0, pretend = 0, frame = 64
 4364              		@ frame_needed = 0, uses_anonymous_args = 0
 4365              	.LVL434:
 4366 256c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4367              	.LCFI18:
 4368              		.cfi_def_cfa_offset 36
1643:../uvc.c      ****     reqData = bRequest;
 4369              		.loc 1 1643 0
 4370 2570 64A99FE5 		ldr	sl, .L390
 4371              		.cfi_offset 14, -4
 4372              		.cfi_offset 11, -8
 4373              		.cfi_offset 10, -12
 4374              		.cfi_offset 9, -16
 4375              		.cfi_offset 8, -20
 4376              		.cfi_offset 7, -24
 4377              		.cfi_offset 6, -28
 4378              		.cfi_offset 5, -32
 4379              		.cfi_offset 4, -36
1635:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4380              		.loc 1 1635 0
 4381 2574 64899FE5 		ldr	r8, .L390+4
1643:../uvc.c      ****     reqData = bRequest;
 4382              		.loc 1 1643 0
 4383 2578 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1635:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4384              		.loc 1 1635 0
 4385 257c 8090A0E1 		mov	r9, r0, asl #1
 4386 2580 002089E0 		add	r2, r9, r0
 4387 2584 822188E0 		add	r2, r8, r2, asl #3
1645:../uvc.c      ****     switch (bRequest)
 4388              		.loc 1 1645 0
 4389 2588 830055E3 		cmp	r5, #131
1624:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4390              		.loc 1 1624 0
 4391 258c 5CD04DE2 		sub	sp, sp, #92
 4392              	.LCFI19:
 4393              		.cfi_def_cfa_offset 128
1624:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4394              		.loc 1 1624 0
 4395 2590 0060A0E1 		mov	r6, r0
1635:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4396              		.loc 1 1635 0
 4397 2594 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4398              	.LVL435:
1636:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4399              		.loc 1 1636 0
 4400 2598 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4401              	.LVL436:
1638:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4402              		.loc 1 1638 0
 4403 259c 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4404              	.LVL437:
1645:../uvc.c      ****     switch (bRequest)
 4405              		.loc 1 1645 0
 4406 25a0 7600000A 		beq	.L310
 4407 25a4 2100009A 		bls	.L385
 4408 25a8 850055E3 		cmp	r5, #133
 4409 25ac 5900000A 		beq	.L312
 4410 25b0 4E00003A 		bcc	.L311
 4411 25b4 860055E3 		cmp	r5, #134
 4412 25b8 8000000A 		beq	.L313
 4413 25bc 870055E3 		cmp	r5, #135
 4414 25c0 7600000A 		beq	.L386
 4415              	.L306:
1852:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4416              		.loc 1 1852 0
 4417 25c4 0000A0E3 		mov	r0, #0
 4418              	.LVL438:
 4419 25c8 0110A0E3 		mov	r1, #1
 4420 25cc 0020A0E1 		mov	r2, r0
 4421 25d0 FEFFFFEB 		bl	CyU3PUsbStall
 4422              	.LVL439:
 4423 25d4 08499FE5 		ldr	r4, .L390+8
1853:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4424              		.loc 1 1853 0
 4425 25d8 0620A0E1 		mov	r2, r6
 4426 25dc 0400A0E3 		mov	r0, #4
 4427 25e0 00199FE5 		ldr	r1, .L390+12
 4428 25e4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4429 25e8 FEFFFFEB 		bl	CyU3PDebugPrint
1854:../uvc.c      **** 			  break;
 4430              		.loc 1 1854 0
 4431 25ec FFC0A0E3 		mov	ip, #255
 4432 25f0 0C60A0E1 		mov	r6, ip
 4433 25f4 0C80A0E1 		mov	r8, ip
 4434              	.LVL440:
 4435              	.L316:
1858:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4436              		.loc 1 1858 0
 4437 25f8 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 4438 25fc 08C08DE5 		str	ip, [sp, #8]
 4439 2600 E4189FE5 		ldr	r1, .L390+16
 4440 2604 FFC0A0E3 		mov	ip, #255
 4441 2608 0520A0E1 		mov	r2, r5
 4442 260c 0830A0E1 		mov	r3, r8
 4443 2610 0400A0E3 		mov	r0, #4
 4444 2614 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4445 2618 0CC08DE5 		str	ip, [sp, #12]
 4446 261c 10E08DE5 		str	lr, [sp, #16]
 4447 2620 14708DE5 		str	r7, [sp, #20]
 4448 2624 FEFFFFEB 		bl	CyU3PDebugPrint
1859:../uvc.c      **** }
 4449              		.loc 1 1859 0
 4450 2628 5CD08DE2 		add	sp, sp, #92
 4451 262c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4452              	.LVL441:
 4453              	.L385:
1645:../uvc.c      ****     switch (bRequest)
 4454              		.loc 1 1645 0
 4455 2630 810055E3 		cmp	r5, #129
 4456 2634 4200000A 		beq	.L308
 4457 2638 1100009A 		bls	.L387
1674:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4458              		.loc 1 1674 0
 4459 263c A0489FE5 		ldr	r4, .L390+8
 4460 2640 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1675:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4461              		.loc 1 1675 0
 4462 2644 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1676:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4463              		.loc 1 1676 0
 4464 2648 0A0050E3 		cmp	r0, #10
1674:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4465              		.loc 1 1674 0
 4466 264c 5C10C4E5 		strb	r1, [r4, #92]
1675:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4467              		.loc 1 1675 0
 4468 2650 5D60C4E5 		strb	r6, [r4, #93]
1676:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4469              		.loc 1 1676 0
 4470 2654 2C00000A 		beq	.L384
 4471              	.LVL442:
 4472              	.L323:
1710:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4473              		.loc 1 1710 0
 4474 2658 00E0A0E3 		mov	lr, #0
 4475 265c 5EE0C4E5 		strb	lr, [r4, #94]
 4476              	.L324:
1711:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4477              		.loc 1 1711 0
 4478 2660 0030A0E3 		mov	r3, #0
1712:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4479              		.loc 1 1712 0
 4480 2664 0700A0E1 		mov	r0, r7
 4481              	.LVL443:
 4482 2668 80189FE5 		ldr	r1, .L390+20
1714:../uvc.c      **** 			  break;
 4483              		.loc 1 1714 0
 4484 266c FF60A0E3 		mov	r6, #255
1711:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4485              		.loc 1 1711 0
 4486 2670 5F30C4E5 		strb	r3, [r4, #95]
1714:../uvc.c      **** 			  break;
 4487              		.loc 1 1714 0
 4488 2674 0680A0E1 		mov	r8, r6
1712:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4489              		.loc 1 1712 0
 4490 2678 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4491              	.LVL444:
 4492 267c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1714:../uvc.c      **** 			  break;
 4493              		.loc 1 1714 0
 4494 2680 DCFFFFEA 		b	.L316
 4495              	.LVL445:
 4496              	.L387:
1645:../uvc.c      ****     switch (bRequest)
 4497              		.loc 1 1645 0
 4498 2684 010055E3 		cmp	r5, #1
 4499 2688 CDFFFF1A 		bne	.L306
1716:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4500              		.loc 1 1716 0
 4501 268c 50489FE5 		ldr	r4, .L390+8
 4502 2690 56208DE2 		add	r2, sp, #86
 4503 2694 2000A0E3 		mov	r0, #32
 4504              	.LVL446:
 4505 2698 5C1084E2 		add	r1, r4, #92
 4506 269c 2C308DE5 		str	r3, [sp, #44]
 4507 26a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4508              	.LVL447:
1718:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4509              		.loc 1 1718 0
 4510 26a4 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1719:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4511              		.loc 1 1719 0
 4512 26a8 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1722:../uvc.c      **** 			  switch(CtrlID)
 4513              		.loc 1 1722 0
 4514 26ac 012046E2 		sub	r2, r6, #1
1718:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4515              		.loc 1 1718 0
 4516 26b0 30008DE5 		str	r0, [sp, #48]
 4517              	.LVL448:
1719:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4518              		.loc 1 1719 0
 4519 26b4 34C08DE5 		str	ip, [sp, #52]
 4520              	.LVL449:
1722:../uvc.c      **** 			  switch(CtrlID)
 4521              		.loc 1 1722 0
 4522 26b8 2C309DE5 		ldr	r3, [sp, #44]
 4523 26bc 090052E3 		cmp	r2, #9
 4524 26c0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4525 26c4 550100EA 		b	.L325
 4526              	.L330:
 4527 26c8 DC2B0000 		.word	.L326
 4528 26cc 202C0000 		.word	.L325
 4529 26d0 EC280000 		.word	.L327
 4530 26d4 202C0000 		.word	.L325
 4531 26d8 202C0000 		.word	.L325
 4532 26dc 202C0000 		.word	.L325
 4533 26e0 68280000 		.word	.L328
 4534 26e4 202C0000 		.word	.L325
 4535 26e8 202C0000 		.word	.L325
 4536 26ec EC270000 		.word	.L329
 4537              	.LVL450:
 4538              	.L311:
1692:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4539              		.loc 1 1692 0
 4540 26f0 EC479FE5 		ldr	r4, .L390+8
 4541 26f4 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1693:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4542              		.loc 1 1693 0
 4543 26f8 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1694:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4544              		.loc 1 1694 0
 4545 26fc 0A0050E3 		cmp	r0, #10
1692:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4546              		.loc 1 1692 0
 4547 2700 5C80C4E5 		strb	r8, [r4, #92]
1693:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4548              		.loc 1 1693 0
 4549 2704 5D20C4E5 		strb	r2, [r4, #93]
1694:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4550              		.loc 1 1694 0
 4551 2708 D2FFFF1A 		bne	.L323
 4552              	.LVL451:
 4553              	.L384:
1709:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4554              		.loc 1 1709 0 discriminator 1
 4555 270c 0110A0E3 		mov	r1, #1
 4556 2710 5E10C4E5 		strb	r1, [r4, #94]
 4557 2714 D1FFFFEA 		b	.L324
 4558              	.LVL452:
 4559              	.L312:
1649:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4560              		.loc 1 1649 0
 4561 2718 C4479FE5 		ldr	r4, .L390+8
1650:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4562              		.loc 1 1650 0
 4563 271c 0030A0E3 		mov	r3, #0
 4564              	.LVL453:
1651:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4565              		.loc 1 1651 0
 4566 2720 0200A0E3 		mov	r0, #2
 4567              	.LVL454:
 4568 2724 5C1084E2 		add	r1, r4, #92
1653:../uvc.c      **** 			  break;
 4569              		.loc 1 1653 0
 4570 2728 FF60A0E3 		mov	r6, #255
1649:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4571              		.loc 1 1649 0
 4572 272c 5C70C4E5 		strb	r7, [r4, #92]
1650:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4573              		.loc 1 1650 0
 4574 2730 5D30C4E5 		strb	r3, [r4, #93]
1653:../uvc.c      **** 			  break;
 4575              		.loc 1 1653 0
 4576 2734 0680A0E1 		mov	r8, r6
1651:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4577              		.loc 1 1651 0
 4578 2738 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4579              	.LVL455:
 4580 273c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1653:../uvc.c      **** 			  break;
 4581              		.loc 1 1653 0
 4582 2740 ACFFFFEA 		b	.L316
 4583              	.LVL456:
 4584              	.L308:
1659:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4585              		.loc 1 1659 0
 4586 2744 98479FE5 		ldr	r4, .L390+8
 4587 2748 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1660:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4588              		.loc 1 1660 0
 4589 274c 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1661:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4590              		.loc 1 1661 0
 4591 2750 0080A0E3 		mov	r8, #0
1667:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4592              		.loc 1 1667 0
 4593 2754 0700A0E1 		mov	r0, r7
 4594              	.LVL457:
 4595 2758 5C1084E2 		add	r1, r4, #92
1672:../uvc.c      **** 			  break;
 4596              		.loc 1 1672 0
 4597 275c FF60A0E3 		mov	r6, #255
1660:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4598              		.loc 1 1660 0
 4599 2760 5DC0C4E5 		strb	ip, [r4, #93]
1661:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4600              		.loc 1 1661 0
 4601 2764 5E80C4E5 		strb	r8, [r4, #94]
1662:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4602              		.loc 1 1662 0
 4603 2768 5F80C4E5 		strb	r8, [r4, #95]
 4604              	.LVL458:
1659:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4605              		.loc 1 1659 0
 4606 276c 5CA0C4E5 		strb	sl, [r4, #92]
1672:../uvc.c      **** 			  break;
 4607              		.loc 1 1672 0
 4608 2770 0680A0E1 		mov	r8, r6
1667:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4609              		.loc 1 1667 0
 4610 2774 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4611              	.LVL459:
 4612 2778 0AC0A0E1 		mov	ip, sl
1672:../uvc.c      **** 			  break;
 4613              		.loc 1 1672 0
 4614 277c 9DFFFFEA 		b	.L316
 4615              	.LVL460:
 4616              	.L310:
1683:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4617              		.loc 1 1683 0
 4618 2780 5C479FE5 		ldr	r4, .L390+8
 4619 2784 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4620              	.LVL461:
1684:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4621              		.loc 1 1684 0
 4622 2788 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1685:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4623              		.loc 1 1685 0
 4624 278c 0A0050E3 		cmp	r0, #10
1683:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4625              		.loc 1 1683 0
 4626 2790 5C30C4E5 		strb	r3, [r4, #92]
1684:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4627              		.loc 1 1684 0
 4628 2794 5DE0C4E5 		strb	lr, [r4, #93]
1685:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4629              		.loc 1 1685 0
 4630 2798 AEFFFF1A 		bne	.L323
 4631 279c DAFFFFEA 		b	.L384
 4632              	.LVL462:
 4633              	.L386:
1707:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4634              		.loc 1 1707 0
 4635 27a0 3C479FE5 		ldr	r4, .L390+8
 4636 27a4 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1708:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4637              		.loc 1 1708 0
 4638 27a8 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1709:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4639              		.loc 1 1709 0
 4640 27ac 0A0050E3 		cmp	r0, #10
1707:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4641              		.loc 1 1707 0
 4642 27b0 5C60C4E5 		strb	r6, [r4, #92]
1708:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4643              		.loc 1 1708 0
 4644 27b4 5DC0C4E5 		strb	ip, [r4, #93]
1709:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4645              		.loc 1 1709 0
 4646 27b8 A6FFFF1A 		bne	.L323
 4647 27bc D2FFFFEA 		b	.L384
 4648              	.L313:
1701:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4649              		.loc 1 1701 0
 4650 27c0 1C479FE5 		ldr	r4, .L390+8
 4651 27c4 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4652              	.LVL463:
 4653 27c8 0410A0E1 		mov	r1, r4
 4654 27cc 5C00E1E5 		strb	r0, [r1, #92]!
1705:../uvc.c      **** 			  break;
 4655              		.loc 1 1705 0
 4656 27d0 FF60A0E3 		mov	r6, #255
1702:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4657              		.loc 1 1702 0
 4658 27d4 0100A0E3 		mov	r0, #1
 4659 27d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4660              	.LVL464:
1705:../uvc.c      **** 			  break;
 4661              		.loc 1 1705 0
 4662 27dc 0680A0E1 		mov	r8, r6
1702:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4663              		.loc 1 1702 0
 4664 27e0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1705:../uvc.c      **** 			  break;
 4665              		.loc 1 1705 0
 4666 27e4 0170A0E3 		mov	r7, #1
 4667 27e8 82FFFFEA 		b	.L316
 4668              	.LVL465:
 4669              	.L329:
1831:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4670              		.loc 1 1831 0
 4671 27ec 00679FE5 		ldr	r6, .L390+24
 4672 27f0 0010E0E3 		mvn	r1, #0
 4673 27f4 1C0096E5 		ldr	r0, [r6, #28]
 4674 27f8 2C308DE5 		str	r3, [sp, #44]
 4675 27fc FEFFFFEB 		bl	_txe_mutex_get
1832:../uvc.c      **** 					  if(getData == 1)
 4676              		.loc 1 1832 0
 4677 2800 30E09DE5 		ldr	lr, [sp, #48]
 4678 2804 2C309DE5 		ldr	r3, [sp, #44]
 4679 2808 01005EE3 		cmp	lr, #1
 4680 280c AA01000A 		beq	.L388
1834:../uvc.c      **** 					  else if(getData == 0xff)
 4681              		.loc 1 1834 0
 4682 2810 FF005EE3 		cmp	lr, #255
 4683 2814 9F01000A 		beq	.L389
1837:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4684              		.loc 1 1837 0
 4685 2818 0080A0E3 		mov	r8, #0
 4686 281c 0600A0E1 		mov	r0, r6
 4687 2820 2310A0E3 		mov	r1, #35
 4688 2824 0B20A0E1 		mov	r2, fp
 4689 2828 00808DE5 		str	r8, [sp, #0]
 4690 282c 04808DE5 		str	r8, [sp, #4]
 4691 2830 FEFFFFEB 		bl	cmdSet
 4692              	.L382:
1840:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4693              		.loc 1 1840 0
 4694 2834 1C0096E5 		ldr	r0, [r6, #28]
 4695 2838 FEFFFFEB 		bl	_txe_mutex_put
1842:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4696              		.loc 1 1842 0
 4697 283c 30809DE5 		ldr	r8, [sp, #48]
 4698 2840 34609DE5 		ldr	r6, [sp, #52]
 4699 2844 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4700 2848 0400A0E3 		mov	r0, #4
 4701 284c A4169FE5 		ldr	r1, .L390+28
 4702 2850 0820A0E1 		mov	r2, r8
 4703 2854 0630A0E1 		mov	r3, r6
 4704 2858 00C08DE5 		str	ip, [sp, #0]
 4705 285c FEFFFFEB 		bl	CyU3PDebugPrint
1843:../uvc.c      **** 					  break;
 4706              		.loc 1 1843 0
 4707 2860 FFC0A0E3 		mov	ip, #255
 4708 2864 63FFFFEA 		b	.L316
 4709              	.LVL466:
 4710              	.L328:
1808:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4711              		.loc 1 1808 0
 4712 2868 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4713 286c 010058E3 		cmp	r8, #1
 4714 2870 08005813 		cmpne	r8, #8
 4715 2874 0000A013 		movne	r0, #0
 4716 2878 0100A003 		moveq	r0, #1
 4717 287c 8101001A 		bne	.L379
 4718              	.LVL467:
1811:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4719              		.loc 1 1811 0
 4720 2880 6C869FE5 		ldr	r8, .L390+24
 4721 2884 0010E0E3 		mvn	r1, #0
 4722 2888 1C0098E5 		ldr	r0, [r8, #28]
 4723 288c 2C308DE5 		str	r3, [sp, #44]
 4724 2890 FEFFFFEB 		bl	_txe_mutex_get
1812:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4725              		.loc 1 1812 0
 4726 2894 30A09DE5 		ldr	sl, [sp, #48]
 4727 2898 2210A0E3 		mov	r1, #34
 4728 289c 0B20A0E1 		mov	r2, fp
 4729 28a0 2C309DE5 		ldr	r3, [sp, #44]
 4730 28a4 00C0A0E3 		mov	ip, #0
 4731 28a8 0800A0E1 		mov	r0, r8
 4732 28ac 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4733 28b0 FEFFFFEB 		bl	cmdSet
1813:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4734              		.loc 1 1813 0
 4735 28b4 1C0098E5 		ldr	r0, [r8, #28]
 4736 28b8 FEFFFFEB 		bl	_txe_mutex_put
1816:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4737              		.loc 1 1816 0
 4738 28bc 1C069FE5 		ldr	r0, .L390+4
1817:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4739              		.loc 1 1817 0
 4740 28c0 34209DE5 		ldr	r2, [sp, #52]
1816:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4741              		.loc 1 1816 0
 4742 28c4 061089E0 		add	r1, r9, r6
 4743 28c8 813180E0 		add	r3, r0, r1, asl #3
1818:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4744              		.loc 1 1818 0
 4745 28cc 0160A0E3 		mov	r6, #1
1816:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4746              		.loc 1 1816 0
 4747 28d0 2DA5C3E5 		strb	sl, [r3, #1325]
1817:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4748              		.loc 1 1817 0
 4749 28d4 2E25C3E5 		strb	r2, [r3, #1326]
1818:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4750              		.loc 1 1818 0
 4751 28d8 3065C3E5 		strb	r6, [r3, #1328]
 4752              	.LVL468:
 4753              	.L380:
1820:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4754              		.loc 1 1820 0
 4755 28dc 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4756 28e0 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1825:../uvc.c      **** 					  break;
 4757              		.loc 1 1825 0
 4758 28e4 FFC0A0E3 		mov	ip, #255
 4759 28e8 42FFFFEA 		b	.L316
 4760              	.LVL469:
 4761              	.L327:
1774:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4762              		.loc 1 1774 0
 4763 28ec 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 4764 28f0 010050E3 		cmp	r0, #1
 4765 28f4 04005013 		cmpne	r0, #4
 4766 28f8 5D01001A 		bne	.L337
1773:../uvc.c      **** 					  value = (value << 8)|Data0;
 4767              		.loc 1 1773 0
 4768 28fc 30109DE5 		ldr	r1, [sp, #48]
 4769 2900 34E09DE5 		ldr	lr, [sp, #52]
 4770 2904 0E2481E1 		orr	r2, r1, lr, asl #8
1775:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4771              		.loc 1 1775 0
 4772 2908 F90052E3 		cmp	r2, #249
 4773 290c 5801008A 		bhi	.L337
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4774              		.loc 1 1780 0
 4775 2910 C8A042E2 		sub	sl, r2, #200
 4776 2914 0AC8A0E1 		mov	ip, sl, asl #16
 4777 2918 3CC08DE5 		str	ip, [sp, #60]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4778              		.loc 1 1782 0
 4779 291c 27A062E2 		rsb	sl, r2, #39
 4780 2920 38A08DE5 		str	sl, [sp, #56]
 4781 2924 3CA09DE5 		ldr	sl, [sp, #60]
 4782 2928 C81062E2 		rsb	r1, r2, #200
 4783 292c C80052E3 		cmp	r2, #200
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4784              		.loc 1 1780 0
 4785 2930 640042E2 		sub	r0, r2, #100
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4786              		.loc 1 1782 0
 4787 2934 0118A0E1 		mov	r1, r1, asl #16
 4788 2938 64E062E2 		rsb	lr, r2, #100
 4789 293c 2A18A081 		movhi	r1, sl, lsr #16
 4790 2940 2118A091 		movls	r1, r1, lsr #16
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4791              		.loc 1 1780 0
 4792 2944 00C8A0E1 		mov	ip, r0, asl #16
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4793              		.loc 1 1782 0
 4794 2948 640052E3 		cmp	r2, #100
 4795 294c 0E08A0E1 		mov	r0, lr, asl #16
 4796 2950 2C08A081 		movhi	r0, ip, lsr #16
 4797 2954 38C09DE5 		ldr	ip, [sp, #56]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4798              		.loc 1 1780 0
 4799 2958 14A042E2 		sub	sl, r2, #20
 4800 295c 38A08DE5 		str	sl, [sp, #56]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4801              		.loc 1 1782 0
 4802 2960 2008A091 		movls	r0, r0, lsr #16
 4803 2964 14A062E2 		rsb	sl, r2, #20
 4804 2968 3CA08DE5 		str	sl, [sp, #60]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4805              		.loc 1 1780 0
 4806 296c 27E042E2 		sub	lr, r2, #39
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4807              		.loc 1 1782 0
 4808 2970 000051E1 		cmp	r1, r0
 4809 2974 01A0A031 		movcc	sl, r1
 4810 2978 00A0A021 		movcs	sl, r0
 4811 297c 0CC8A0E1 		mov	ip, ip, asl #16
 4812 2980 270052E3 		cmp	r2, #39
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4813              		.loc 1 1780 0
 4814 2984 0EE8A0E1 		mov	lr, lr, asl #16
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4815              		.loc 1 1782 0
 4816 2988 2CE8A091 		movls	lr, ip, lsr #16
 4817 298c 68C59FE5 		ldr	ip, .L390+32
 4818 2990 20A08DE5 		str	sl, [sp, #32]
 4819 2994 01A06CE0 		rsb	sl, ip, r1
 4820 2998 2EE8A081 		movhi	lr, lr, lsr #16
 4821 299c 00C07AE2 		rsbs	ip, sl, #0
 4822 29a0 0AC0ACE0 		adc	ip, ip, sl
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4823              		.loc 1 1780 0
 4824 29a4 38A09DE5 		ldr	sl, [sp, #56]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4825              		.loc 1 1782 0
 4826 29a8 44C08DE5 		str	ip, [sp, #68]
 4827              	.LVL470:
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4828              		.loc 1 1780 0
 4829 29ac 0AC8A0E1 		mov	ip, sl, asl #16
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4830              		.loc 1 1782 0
 4831 29b0 3CA09DE5 		ldr	sl, [sp, #60]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4832              		.loc 1 1780 0
 4833 29b4 4CC08DE5 		str	ip, [sp, #76]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4834              		.loc 1 1782 0
 4835 29b8 0AC8A0E1 		mov	ip, sl, asl #16
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4836              		.loc 1 1780 0
 4837 29bc 0AA042E2 		sub	sl, r2, #10
 4838 29c0 48A08DE5 		str	sl, [sp, #72]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4839              		.loc 1 1782 0
 4840 29c4 20A09DE5 		ldr	sl, [sp, #32]
 4841 29c8 3CC08DE5 		str	ip, [sp, #60]
 4842 29cc 0A005EE1 		cmp	lr, sl
 4843 29d0 0EA0A031 		movcc	sl, lr
 4844 29d4 0AC062E2 		rsb	ip, r2, #10
 4845 29d8 40C08DE5 		str	ip, [sp, #64]
 4846 29dc 38A08DE5 		str	sl, [sp, #56]
 4847 29e0 3CC09DE5 		ldr	ip, [sp, #60]
 4848 29e4 4CA09DE5 		ldr	sl, [sp, #76]
 4849 29e8 140052E3 		cmp	r2, #20
 4850 29ec 2CA8A091 		movls	sl, ip, lsr #16
 4851 29f0 2AA8A081 		movhi	sl, sl, lsr #16
 4852 29f4 44C09DE5 		ldr	ip, [sp, #68]
 4853 29f8 010050E1 		cmp	r0, r1
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4854              		.loc 1 1780 0
 4855 29fc 48109DE5 		ldr	r1, [sp, #72]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4856              		.loc 1 1782 0
 4857 2a00 01C0A033 		movcc	ip, #1
 4858 2a04 3CA08DE5 		str	sl, [sp, #60]
 4859 2a08 24C08DE5 		str	ip, [sp, #36]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4860              		.loc 1 1780 0
 4861 2a0c 01A8A0E1 		mov	sl, r1, asl #16
 4862 2a10 05C042E2 		sub	ip, r2, #5
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4863              		.loc 1 1782 0
 4864 2a14 051062E2 		rsb	r1, r2, #5
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4865              		.loc 1 1780 0
 4866 2a18 48A08DE5 		str	sl, [sp, #72]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4867              		.loc 1 1782 0
 4868 2a1c 40009DE5 		ldr	r0, [sp, #64]
 4869 2a20 38A09DE5 		ldr	sl, [sp, #56]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4870              		.loc 1 1780 0
 4871 2a24 40C08DE5 		str	ip, [sp, #64]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4872              		.loc 1 1782 0
 4873 2a28 3CC09DE5 		ldr	ip, [sp, #60]
 4874 2a2c 4C108DE5 		str	r1, [sp, #76]
 4875 2a30 48109DE5 		ldr	r1, [sp, #72]
 4876 2a34 0008A0E1 		mov	r0, r0, asl #16
 4877 2a38 0A005CE1 		cmp	ip, sl
 4878 2a3c 0AC0A021 		movcs	ip, sl
 4879 2a40 0A0052E3 		cmp	r2, #10
 4880 2a44 20A09DE5 		ldr	sl, [sp, #32]
 4881 2a48 2108A081 		movhi	r0, r1, lsr #16
 4882 2a4c 2008A091 		movls	r0, r0, lsr #16
 4883 2a50 48008DE5 		str	r0, [sp, #72]
 4884 2a54 24009DE5 		ldr	r0, [sp, #36]
 4885 2a58 0A005EE1 		cmp	lr, sl
 4886 2a5c 0200A033 		movcc	r0, #2
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4887              		.loc 1 1780 0
 4888 2a60 02E042E2 		sub	lr, r2, #2
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4889              		.loc 1 1782 0
 4890 2a64 44C08DE5 		str	ip, [sp, #68]
 4891 2a68 24008DE5 		str	r0, [sp, #36]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4892              		.loc 1 1780 0
 4893 2a6c 40C09DE5 		ldr	ip, [sp, #64]
 4894 2a70 1CE08DE5 		str	lr, [sp, #28]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4895              		.loc 1 1782 0
 4896 2a74 44009DE5 		ldr	r0, [sp, #68]
 4897 2a78 48E09DE5 		ldr	lr, [sp, #72]
 4898 2a7c 4C109DE5 		ldr	r1, [sp, #76]
 4899 2a80 02A062E2 		rsb	sl, r2, #2
 4900 2a84 00005EE1 		cmp	lr, r0
 4901 2a88 00E0A021 		movcs	lr, r0
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4902              		.loc 1 1780 0
 4903 2a8c 0CC8A0E1 		mov	ip, ip, asl #16
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4904              		.loc 1 1782 0
 4905 2a90 050052E3 		cmp	r2, #5
 4906 2a94 40A08DE5 		str	sl, [sp, #64]
 4907 2a98 0118A0E1 		mov	r1, r1, asl #16
 4908 2a9c 3CA09DE5 		ldr	sl, [sp, #60]
 4909 2aa0 2C18A081 		movhi	r1, ip, lsr #16
 4910 2aa4 38C09DE5 		ldr	ip, [sp, #56]
 4911 2aa8 4CE08DE5 		str	lr, [sp, #76]
 4912 2aac 24009DE5 		ldr	r0, [sp, #36]
 4913 2ab0 40E09DE5 		ldr	lr, [sp, #64]
 4914 2ab4 2118A091 		movls	r1, r1, lsr #16
 4915 2ab8 0C005AE1 		cmp	sl, ip
 4916 2abc 20108DE5 		str	r1, [sp, #32]
 4917 2ac0 0300A033 		movcc	r0, #3
 4918 2ac4 38008DE5 		str	r0, [sp, #56]
 4919 2ac8 4CA09DE5 		ldr	sl, [sp, #76]
 4920 2acc 0E08A0E1 		mov	r0, lr, asl #16
 4921 2ad0 20E09DE5 		ldr	lr, [sp, #32]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4922              		.loc 1 1780 0
 4923 2ad4 1C109DE5 		ldr	r1, [sp, #28]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4924              		.loc 1 1782 0
 4925 2ad8 0A005EE1 		cmp	lr, sl
 4926 2adc 0AE0A021 		movcs	lr, sl
 4927 2ae0 44C09DE5 		ldr	ip, [sp, #68]
 4928 2ae4 48A09DE5 		ldr	sl, [sp, #72]
 4929 2ae8 020052E3 		cmp	r2, #2
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4930              		.loc 1 1780 0
 4931 2aec 0118A0E1 		mov	r1, r1, asl #16
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4932              		.loc 1 1782 0
 4933 2af0 2018A091 		movls	r1, r0, lsr #16
 4934 2af4 38009DE5 		ldr	r0, [sp, #56]
 4935 2af8 2118A081 		movhi	r1, r1, lsr #16
 4936 2afc 0C005AE1 		cmp	sl, ip
 4937 2b00 0400A033 		movcc	r0, #4
 4938 2b04 40008DE5 		str	r0, [sp, #64]
1780:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4939              		.loc 1 1780 0
 4940 2b08 010042E2 		sub	r0, r2, #1
 4941 2b0c 38008DE5 		str	r0, [sp, #56]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4942              		.loc 1 1782 0
 4943 2b10 4CA09DE5 		ldr	sl, [sp, #76]
 4944 2b14 20009DE5 		ldr	r0, [sp, #32]
 4945 2b18 01C062E2 		rsb	ip, r2, #1
 4946 2b1c 3CC08DE5 		str	ip, [sp, #60]
 4947 2b20 0A0050E1 		cmp	r0, sl
1789:../uvc.c      **** 						  shutter = shutter+index;
 4948              		.loc 1 1789 0
 4949 2b24 38A09DE5 		ldr	sl, [sp, #56]
 4950 2b28 3C009DE5 		ldr	r0, [sp, #60]
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4951              		.loc 1 1782 0
 4952 2b2c 40C09DE5 		ldr	ip, [sp, #64]
 4953 2b30 05C0A033 		movcc	ip, #5
1789:../uvc.c      **** 						  shutter = shutter+index;
 4954              		.loc 1 1789 0
 4955 2b34 010052E3 		cmp	r2, #1
 4956 2b38 0028A091 		movls	r2, r0, asl #16
 4957 2b3c 0A28A081 		movhi	r2, sl, asl #16
 4958 2b40 0E0051E1 		cmp	r1, lr
 4959 2b44 01A0A031 		movcc	sl, r1
 4960 2b48 0EA0A021 		movcs	sl, lr
1782:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4961              		.loc 1 1782 0
 4962 2b4c 0E0051E1 		cmp	r1, lr
 4963 2b50 0C10A021 		movcs	r1, ip
 4964 2b54 0610A033 		movcc	r1, #6
1789:../uvc.c      **** 						  shutter = shutter+index;
 4965              		.loc 1 1789 0
 4966 2b58 22085AE1 		cmp	sl, r2, lsr #16
1792:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4967              		.loc 1 1792 0
 4968 2b5c 90A39FE5 		ldr	sl, .L390+24
1789:../uvc.c      **** 						  shutter = shutter+index;
 4969              		.loc 1 1789 0
 4970 2b60 0120A091 		movls	r2, r1
 4971 2b64 0720A083 		movhi	r2, #7
 4972 2b68 012082E2 		add	r2, r2, #1
 4973 2b6c FFE002E2 		and	lr, r2, #255
1792:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4974              		.loc 1 1792 0
 4975 2b70 0010E0E3 		mvn	r1, #0
 4976 2b74 1C009AE5 		ldr	r0, [sl, #28]
1789:../uvc.c      **** 						  shutter = shutter+index;
 4977              		.loc 1 1789 0
 4978 2b78 38E08DE5 		str	lr, [sp, #56]
 4979              	.LVL471:
1792:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4980              		.loc 1 1792 0
 4981 2b7c 2C308DE5 		str	r3, [sp, #44]
 4982 2b80 FEFFFFEB 		bl	_txe_mutex_get
1793:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 4983              		.loc 1 1793 0
 4984 2b84 38C09DE5 		ldr	ip, [sp, #56]
 4985 2b88 0310A0E3 		mov	r1, #3
 4986 2b8c 0B20A0E1 		mov	r2, fp
 4987 2b90 2C309DE5 		ldr	r3, [sp, #44]
 4988 2b94 00C08DE5 		str	ip, [sp, #0]
 4989 2b98 0A00A0E1 		mov	r0, sl
 4990 2b9c 00C0A0E3 		mov	ip, #0
 4991 2ba0 04C08DE5 		str	ip, [sp, #4]
 4992 2ba4 FEFFFFEB 		bl	cmdSet
1794:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4993              		.loc 1 1794 0
 4994 2ba8 1C009AE5 		ldr	r0, [sl, #28]
 4995 2bac FEFFFFEB 		bl	_txe_mutex_put
1797:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4996              		.loc 1 1797 0
 4997 2bb0 30009DE5 		ldr	r0, [sp, #48]
1798:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4998              		.loc 1 1798 0
 4999 2bb4 34C09DE5 		ldr	ip, [sp, #52]
1800:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5000              		.loc 1 1800 0
 5001 2bb8 38309DE5 		ldr	r3, [sp, #56]
1797:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5002              		.loc 1 1797 0
 5003 2bbc 061089E0 		add	r1, r9, r6
 5004 2bc0 816188E0 		add	r6, r8, r1, asl #3
1799:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5005              		.loc 1 1799 0
 5006 2bc4 0120A0E3 		mov	r2, #1
1797:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5007              		.loc 1 1797 0
 5008 2bc8 2D05C6E5 		strb	r0, [r6, #1325]
1798:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5009              		.loc 1 1798 0
 5010 2bcc 2EC5C6E5 		strb	ip, [r6, #1326]
1799:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5011              		.loc 1 1799 0
 5012 2bd0 3025C6E5 		strb	r2, [r6, #1328]
1800:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5013              		.loc 1 1800 0
 5014 2bd4 0D33C8E5 		strb	r3, [r8, #781]
 5015 2bd8 3FFFFFEA 		b	.L380
 5016              	.LVL472:
 5017              	.L326:
1727:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5018              		.loc 1 1727 0
 5019 2bdc 062089E0 		add	r2, r9, r6
 5020 2be0 826188E0 		add	r6, r8, r2, asl #3
1728:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5021              		.loc 1 1728 0
 5022 2be4 0110A0E3 		mov	r1, #1
1731:../uvc.c      **** 		  		    switch (getData){
 5023              		.loc 1 1731 0
 5024 2be8 01E040E2 		sub	lr, r0, #1
1727:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5025              		.loc 1 1727 0
 5026 2bec 2D05C6E5 		strb	r0, [r6, #1325]
1728:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5027              		.loc 1 1728 0
 5028 2bf0 3015C6E5 		strb	r1, [r6, #1328]
 5029              	.LVL473:
1731:../uvc.c      **** 		  		    switch (getData){
 5030              		.loc 1 1731 0
 5031 2bf4 07005EE3 		cmp	lr, #7
 5032 2bf8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5033 2bfc 980000EA 		b	.L331
 5034              	.L336:
 5035 2c00 F82D0000 		.word	.L332
 5036 2c04 5C2D0000 		.word	.L333
 5037 2c08 642E0000 		.word	.L331
 5038 2c0c F42C0000 		.word	.L334
 5039 2c10 642E0000 		.word	.L331
 5040 2c14 642E0000 		.word	.L331
 5041 2c18 642E0000 		.word	.L331
 5042 2c1c 542C0000 		.word	.L335
 5043              	.LVL474:
 5044              	.L325:
1847:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5045              		.loc 1 1847 0
 5046 2c20 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1846:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5047              		.loc 1 1846 0
 5048 2c24 30A09DE5 		ldr	sl, [sp, #48]
 5049 2c28 069089E0 		add	r9, r9, r6
 5050 2c2c 89E188E0 		add	lr, r8, r9, asl #3
1847:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5051              		.loc 1 1847 0
 5052 2c30 0620A0E1 		mov	r2, r6
 5053 2c34 0400A0E3 		mov	r0, #4
 5054 2c38 C0129FE5 		ldr	r1, .L390+36
1846:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5055              		.loc 1 1846 0
 5056 2c3c 2DA5CEE5 		strb	sl, [lr, #1325]
1847:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5057              		.loc 1 1847 0
 5058 2c40 FEFFFFEB 		bl	CyU3PDebugPrint
1848:../uvc.c      **** 			  		 break;
 5059              		.loc 1 1848 0
 5060 2c44 FFC0A0E3 		mov	ip, #255
 5061 2c48 0C60A0E1 		mov	r6, ip
 5062 2c4c 0C80A0E1 		mov	r8, ip
 5063 2c50 68FEFFEA 		b	.L316
 5064              	.LVL475:
 5065              	.L335:
1750:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5066              		.loc 1 1750 0
 5067 2c54 98629FE5 		ldr	r6, .L390+24
1748:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5068              		.loc 1 1748 0
 5069 2c58 00A0A0E3 		mov	sl, #0
1750:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5070              		.loc 1 1750 0
 5071 2c5c 1C0096E5 		ldr	r0, [r6, #28]
1748:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5072              		.loc 1 1748 0
 5073 2c60 0DA3C8E5 		strb	sl, [r8, #781]
 5074              	.LVL476:
1750:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5075              		.loc 1 1750 0
 5076 2c64 0010E0E3 		mvn	r1, #0
 5077 2c68 2C308DE5 		str	r3, [sp, #44]
 5078 2c6c FEFFFFEB 		bl	_txe_mutex_get
1751:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5079              		.loc 1 1751 0
 5080 2c70 0B20A0E1 		mov	r2, fp
 5081 2c74 2C309DE5 		ldr	r3, [sp, #44]
 5082 2c78 1010A0E3 		mov	r1, #16
 5083 2c7c 0600A0E1 		mov	r0, r6
 5084 2c80 00A08DE5 		str	sl, [sp, #0]
 5085 2c84 04A08DE5 		str	sl, [sp, #4]
 5086 2c88 FEFFFFEB 		bl	cmdSet
1752:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5087              		.loc 1 1752 0
 5088 2c8c 1C0096E5 		ldr	r0, [r6, #28]
 5089 2c90 FEFFFFEB 		bl	_txe_mutex_put
 5090              	.LVL477:
 5091              	.LBB68:
 5092              	.LBB69:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5093              		.loc 1 680 0
 5094 2c94 0010E0E3 		mvn	r1, #0
 5095 2c98 1C0096E5 		ldr	r0, [r6, #28]
 5096 2c9c FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5097              		.loc 1 681 0
 5098 2ca0 01C0A0E3 		mov	ip, #1
 5099 2ca4 2010A0E3 		mov	r1, #32
 5100 2ca8 2720A0E3 		mov	r2, #39
 5101 2cac 3030A0E3 		mov	r3, #48
 5102 2cb0 0600A0E1 		mov	r0, r6
 5103 2cb4 00C08DE5 		str	ip, [sp, #0]
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5104              		.loc 1 682 0
 5105 2cb8 0280A0E3 		mov	r8, #2
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5106              		.loc 1 681 0
 5107 2cbc 04A08DE5 		str	sl, [sp, #4]
 5108 2cc0 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5109              		.loc 1 682 0
 5110 2cc4 2110A0E3 		mov	r1, #33
 5111 2cc8 2520A0E3 		mov	r2, #37
 5112 2ccc 3030A0E3 		mov	r3, #48
 5113 2cd0 0600A0E1 		mov	r0, r6
 5114 2cd4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5115 2cd8 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5116              		.loc 1 683 0
 5117 2cdc 1C0096E5 		ldr	r0, [r6, #28]
 5118 2ce0 FEFFFFEB 		bl	_txe_mutex_put
 5119              	.LBE69:
 5120              	.LBE68:
1754:../uvc.c      **** 							break;
 5121              		.loc 1 1754 0
 5122 2ce4 FFC0A0E3 		mov	ip, #255
 5123 2ce8 0C60A0E1 		mov	r6, ip
 5124 2cec 0880A0E3 		mov	r8, #8
 5125 2cf0 40FEFFEA 		b	.L316
 5126              	.LVL478:
 5127              	.L334:
 5128              	.LBB70:
 5129              	.LBB71:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5130              		.loc 1 680 0
 5131 2cf4 F8619FE5 		ldr	r6, .L390+24
 5132 2cf8 0010E0E3 		mvn	r1, #0
 5133 2cfc 1C0096E5 		ldr	r0, [r6, #28]
 5134 2d00 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5135              		.loc 1 681 0
 5136 2d04 0080A0E3 		mov	r8, #0
 5137 2d08 2010A0E3 		mov	r1, #32
 5138 2d0c 2720A0E3 		mov	r2, #39
 5139 2d10 3030A0E3 		mov	r3, #48
 5140 2d14 0600A0E1 		mov	r0, r6
 5141 2d18 00808DE5 		str	r8, [sp, #0]
 5142 2d1c 04808DE5 		str	r8, [sp, #4]
 5143 2d20 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5144              		.loc 1 682 0
 5145 2d24 01C0A0E3 		mov	ip, #1
 5146 2d28 2110A0E3 		mov	r1, #33
 5147 2d2c 2520A0E3 		mov	r2, #37
 5148 2d30 3030A0E3 		mov	r3, #48
 5149 2d34 0600A0E1 		mov	r0, r6
 5150 2d38 00C08DE5 		str	ip, [sp, #0]
 5151 2d3c 04808DE5 		str	r8, [sp, #4]
 5152 2d40 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5153              		.loc 1 683 0
 5154 2d44 1C0096E5 		ldr	r0, [r6, #28]
 5155 2d48 FEFFFFEB 		bl	_txe_mutex_put
 5156 2d4c FFC0A0E3 		mov	ip, #255
 5157 2d50 0C60A0E1 		mov	r6, ip
 5158 2d54 0480A0E3 		mov	r8, #4
 5159 2d58 26FEFFEA 		b	.L316
 5160              	.LVL479:
 5161              	.L333:
 5162              	.LBE71:
 5163              	.LBE70:
1738:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5164              		.loc 1 1738 0
 5165 2d5c 90619FE5 		ldr	r6, .L390+24
1736:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5166              		.loc 1 1736 0
 5167 2d60 00A0A0E3 		mov	sl, #0
1738:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5168              		.loc 1 1738 0
 5169 2d64 1C0096E5 		ldr	r0, [r6, #28]
1736:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5170              		.loc 1 1736 0
 5171 2d68 0DA3C8E5 		strb	sl, [r8, #781]
 5172              	.LVL480:
1738:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5173              		.loc 1 1738 0
 5174 2d6c 0010E0E3 		mvn	r1, #0
 5175 2d70 2C308DE5 		str	r3, [sp, #44]
 5176 2d74 FEFFFFEB 		bl	_txe_mutex_get
1739:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5177              		.loc 1 1739 0
 5178 2d78 0B20A0E1 		mov	r2, fp
 5179 2d7c 2C309DE5 		ldr	r3, [sp, #44]
 5180 2d80 1010A0E3 		mov	r1, #16
 5181 2d84 0600A0E1 		mov	r0, r6
 5182 2d88 00A08DE5 		str	sl, [sp, #0]
 5183 2d8c 04A08DE5 		str	sl, [sp, #4]
 5184 2d90 FEFFFFEB 		bl	cmdSet
1740:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5185              		.loc 1 1740 0
 5186 2d94 1C0096E5 		ldr	r0, [r6, #28]
 5187 2d98 FEFFFFEB 		bl	_txe_mutex_put
 5188              	.LVL481:
 5189              	.LBB72:
 5190              	.LBB73:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5191              		.loc 1 680 0
 5192 2d9c 0010E0E3 		mvn	r1, #0
 5193 2da0 1C0096E5 		ldr	r0, [r6, #28]
 5194 2da4 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5195              		.loc 1 681 0
 5196 2da8 2010A0E3 		mov	r1, #32
 5197 2dac 2720A0E3 		mov	r2, #39
 5198 2db0 3030A0E3 		mov	r3, #48
 5199 2db4 0600A0E1 		mov	r0, r6
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5200              		.loc 1 682 0
 5201 2db8 0180A0E3 		mov	r8, #1
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5202              		.loc 1 681 0
 5203 2dbc 00A08DE5 		str	sl, [sp, #0]
 5204 2dc0 04A08DE5 		str	sl, [sp, #4]
 5205 2dc4 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5206              		.loc 1 682 0
 5207 2dc8 2110A0E3 		mov	r1, #33
 5208 2dcc 2520A0E3 		mov	r2, #37
 5209 2dd0 3030A0E3 		mov	r3, #48
 5210 2dd4 0600A0E1 		mov	r0, r6
 5211 2dd8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5212 2ddc FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5213              		.loc 1 683 0
 5214 2de0 1C0096E5 		ldr	r0, [r6, #28]
 5215 2de4 FEFFFFEB 		bl	_txe_mutex_put
 5216 2de8 FFC0A0E3 		mov	ip, #255
 5217 2dec 0C60A0E1 		mov	r6, ip
 5218 2df0 0280A0E3 		mov	r8, #2
 5219 2df4 FFFDFFEA 		b	.L316
 5220              	.LVL482:
 5221              	.L332:
 5222              	.LBE73:
 5223              	.LBE72:
 5224              	.LBB74:
 5225              	.LBB75:
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5226              		.loc 1 680 0
 5227 2df8 F4609FE5 		ldr	r6, .L390+24
 5228 2dfc 0010E0E3 		mvn	r1, #0
 5229 2e00 1C0096E5 		ldr	r0, [r6, #28]
 5230 2e04 FEFFFFEB 		bl	_txe_mutex_get
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5231              		.loc 1 681 0
 5232 2e08 0080A0E3 		mov	r8, #0
 5233 2e0c 01A0A0E3 		mov	sl, #1
 5234 2e10 2010A0E3 		mov	r1, #32
 5235 2e14 2720A0E3 		mov	r2, #39
 5236 2e18 3030A0E3 		mov	r3, #48
 5237 2e1c 0600A0E1 		mov	r0, r6
 5238 2e20 04808DE5 		str	r8, [sp, #4]
 5239 2e24 00A08DE5 		str	sl, [sp, #0]
 5240 2e28 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5241              		.loc 1 682 0
 5242 2e2c 02C0A0E3 		mov	ip, #2
 5243 2e30 2110A0E3 		mov	r1, #33
 5244 2e34 2520A0E3 		mov	r2, #37
 5245 2e38 3030A0E3 		mov	r3, #48
 5246 2e3c 0600A0E1 		mov	r0, r6
 5247 2e40 00C08DE5 		str	ip, [sp, #0]
 5248 2e44 04808DE5 		str	r8, [sp, #4]
 5249 2e48 FEFFFFEB 		bl	cmdSet
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5250              		.loc 1 683 0
 5251 2e4c 1C0096E5 		ldr	r0, [r6, #28]
 5252 2e50 FEFFFFEB 		bl	_txe_mutex_put
 5253              	.LBE75:
 5254              	.LBE74:
1734:../uvc.c      **** 							break;
 5255              		.loc 1 1734 0
 5256 2e54 FFC0A0E3 		mov	ip, #255
 5257 2e58 0C60A0E1 		mov	r6, ip
 5258 2e5c 0A80A0E1 		mov	r8, sl
 5259 2e60 E4FDFFEA 		b	.L316
 5260              	.LVL483:
 5261              	.L331:
1731:../uvc.c      **** 		  		    switch (getData){
 5262              		.loc 1 1731 0
 5263 2e64 FFC0A0E3 		mov	ip, #255
 5264 2e68 0080A0E1 		mov	r8, r0
 5265 2e6c 0C60A0E1 		mov	r6, ip
 5266 2e70 E0FDFFEA 		b	.L316
 5267              	.LVL484:
 5268              	.L337:
1802:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5269              		.loc 1 1802 0
 5270 2e74 0000A0E3 		mov	r0, #0
 5271 2e78 0110A0E3 		mov	r1, #1
 5272 2e7c 0020A0E1 		mov	r2, r0
 5273 2e80 FEFFFFEB 		bl	CyU3PUsbStall
 5274              	.LVL485:
 5275 2e84 94FEFFEA 		b	.L380
 5276              	.LVL486:
 5277              	.L379:
1820:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5278              		.loc 1 1820 0
 5279 2e88 0110A0E3 		mov	r1, #1
 5280 2e8c 0020A0E1 		mov	r2, r0
 5281 2e90 FEFFFFEB 		bl	CyU3PUsbStall
 5282 2e94 90FEFFEA 		b	.L380
 5283              	.LVL487:
 5284              	.L389:
1835:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5285              		.loc 1 1835 0
 5286 2e98 08E0A0E3 		mov	lr, #8
 5287 2e9c 00C0A0E3 		mov	ip, #0
 5288 2ea0 0600A0E1 		mov	r0, r6
 5289 2ea4 2310A0E3 		mov	r1, #35
 5290 2ea8 0B20A0E1 		mov	r2, fp
 5291 2eac 00E08DE5 		str	lr, [sp, #0]
 5292 2eb0 04C08DE5 		str	ip, [sp, #4]
 5293 2eb4 FEFFFFEB 		bl	cmdSet
 5294 2eb8 5DFEFFEA 		b	.L382
 5295              	.L388:
1833:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5296              		.loc 1 1833 0
 5297 2ebc 0480A0E3 		mov	r8, #4
 5298 2ec0 00E0A0E3 		mov	lr, #0
 5299 2ec4 0600A0E1 		mov	r0, r6
 5300 2ec8 2310A0E3 		mov	r1, #35
 5301 2ecc 0B20A0E1 		mov	r2, fp
 5302 2ed0 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5303 2ed4 FEFFFFEB 		bl	cmdSet
 5304 2ed8 55FEFFEA 		b	.L382
 5305              	.L391:
 5306              		.align	2
 5307              	.L390:
 5308 2edc 00000000 		.word	bRequest
 5309 2ee0 00000000 		.word	.LANCHOR1
 5310 2ee4 00000000 		.word	.LANCHOR0
 5311 2ee8 30050000 		.word	.LC31
 5312 2eec 54050000 		.word	.LC32
 5313 2ef0 5C000000 		.word	.LANCHOR0+92
 5314 2ef4 00000000 		.word	cmdQu
 5315 2ef8 E4040000 		.word	.LC29
 5316 2efc FFFF0000 		.word	65535
 5317 2f00 0C050000 		.word	.LC30
 5318              		.cfi_endproc
 5319              	.LFE4:
 5321              		.align	2
 5322              		.global	UVCAppEP0Thread_Entry
 5324              	UVCAppEP0Thread_Entry:
 5325              	.LFB25:
4013:../uvc.c      **** {
 5326              		.loc 1 4013 0
 5327              		.cfi_startproc
 5328              		@ args = 0, pretend = 0, frame = 24
 5329              		@ frame_needed = 0, uses_anonymous_args = 0
 5330              	.LVL488:
 5331 2f04 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5332              	.LCFI20:
 5333              		.cfi_def_cfa_offset 36
 5334 2f08 644D9FE5 		ldr	r4, .L587
 5335              		.cfi_offset 14, -4
 5336              		.cfi_offset 11, -8
 5337              		.cfi_offset 10, -12
 5338              		.cfi_offset 9, -16
 5339              		.cfi_offset 8, -20
 5340              		.cfi_offset 7, -24
 5341              		.cfi_offset 6, -28
 5342              		.cfi_offset 5, -32
 5343              		.cfi_offset 4, -36
 5344 2f0c 645D9FE5 		ldr	r5, .L587+4
 5345 2f10 648D9FE5 		ldr	r8, .L587+8
 5346 2f14 64AD9FE5 		ldr	sl, .L587+12
 5347 2f18 64BD9FE5 		ldr	fp, .L587+16
 5348 2f1c 647D9FE5 		ldr	r7, .L587+20
 5349 2f20 34D04DE2 		sub	sp, sp, #52
 5350              	.LCFI21:
 5351              		.cfi_def_cfa_offset 88
 5352              	.LVL489:
4035:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5353              		.loc 1 4035 0
 5354 2f24 0460A0E1 		mov	r6, r4
 5355              	.LVL490:
 5356              	.L547:
 5357 2f28 00C0E0E3 		mvn	ip, #0
 5358 2f2c 400D9FE5 		ldr	r0, .L587
 5359 2f30 4C10A0E3 		mov	r1, #76
 5360 2f34 0120A0E3 		mov	r2, #1
 5361 2f38 28308DE2 		add	r3, sp, #40
 5362 2f3c 00C08DE5 		str	ip, [sp, #0]
 5363 2f40 FEFFFFEB 		bl	_txe_event_flags_get
 5364 2f44 000050E3 		cmp	r0, #0
 5365 2f48 3000001A 		bne	.L393
4039:../uvc.c      ****             if (!isUsbConnected)
 5366              		.loc 1 4039 0
 5367 2f4c 303096E5 		ldr	r3, [r6, #48]
 5368 2f50 000053E3 		cmp	r3, #0
 5369 2f54 8C00000A 		beq	.L576
 5370              	.L394:
4048:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 5371              		.loc 1 4048 0
 5372 2f58 28309DE5 		ldr	r3, [sp, #40]
 5373 2f5c 0C0013E3 		tst	r3, #12
 5374 2f60 7500001A 		bne	.L577
 5375              	.L395:
4055:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5376              		.loc 1 4055 0
 5377 2f64 040013E3 		tst	r3, #4
 5378 2f68 1C00000A 		beq	.L396
4057:../uvc.c      ****             	switch ((wIndex >> 8))
 5379              		.loc 1 4057 0
 5380 2f6c B0E0DBE1 		ldrh	lr, [fp, #0]
 5381 2f70 2E24A0E1 		mov	r2, lr, lsr #8
 5382 2f74 030052E3 		cmp	r2, #3
 5383 2f78 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5384 2f7c 120000EA 		b	.L397
 5385              	.L402:
 5386 2f80 CC2F0000 		.word	.L397
 5387 2f84 BC300000 		.word	.L399
 5388 2f88 902F0000 		.word	.L400
 5389 2f8c F8300000 		.word	.L401
 5390              	.L400:
 5391              	.LBB90:
 5392              	.LBB94:
3261:../uvc.c      ****     switch (wValue)
 5393              		.loc 1 3261 0
 5394 2f90 B020DAE1 		ldrh	r2, [sl, #0]
 5395 2f94 060C52E3 		cmp	r2, #1536
 5396 2f98 9902000A 		beq	.L408
 5397 2f9c D900008A 		bhi	.L414
 5398 2fa0 030C52E3 		cmp	r2, #768
 5399 2fa4 9202000A 		beq	.L406
 5400 2fa8 A001008A 		bhi	.L415
 5401 2fac 010C52E3 		cmp	r2, #256
 5402 2fb0 B602000A 		beq	.L404
 5403 2fb4 020C52E3 		cmp	r2, #512
 5404 2fb8 B002000A 		beq	.L578
 5405              	.L417:
 5406              	.LBE94:
 5407              	.LBE90:
 5408              	.LBB98:
 5409              	.LBB103:
3393:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5410              		.loc 1 3393 0
 5411 2fbc C81C9FE5 		ldr	r1, .L587+24
 5412 2fc0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5413 2fc4 0400A0E3 		mov	r0, #4
 5414 2fc8 FEFFFFEB 		bl	CyU3PDebugPrint
 5415              	.L397:
 5416              	.LBE103:
 5417              	.LBE98:
4078:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5418              		.loc 1 4078 0
 5419 2fcc 0000A0E3 		mov	r0, #0
 5420 2fd0 0110A0E3 		mov	r1, #1
 5421 2fd4 0020A0E1 		mov	r2, r0
 5422 2fd8 FEFFFFEB 		bl	CyU3PUsbStall
 5423 2fdc 28309DE5 		ldr	r3, [sp, #40]
 5424              	.L396:
4083:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5425              		.loc 1 4083 0
 5426 2fe0 080013E3 		tst	r3, #8
 5427 2fe4 0700000A 		beq	.L460
4087:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5428              		.loc 1 4087 0
 5429 2fe8 B030DBE1 		ldrh	r3, [fp, #0]
 5430 2fec 010053E3 		cmp	r3, #1
 5431 2ff0 6B00000A 		beq	.L461
 5432              	.L462:
 5433              	.LBB109:
 5434              	.LBB113:
4002:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5435              		.loc 1 4002 0
 5436 2ff4 0000A0E3 		mov	r0, #0
 5437 2ff8 0110A0E3 		mov	r1, #1
 5438 2ffc 0020A0E1 		mov	r2, r0
 5439 3000 FEFFFFEB 		bl	CyU3PUsbStall
 5440              	.L566:
 5441 3004 28309DE5 		ldr	r3, [sp, #40]
 5442              	.L460:
 5443              	.LBE113:
 5444              	.LBE109:
4098:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5445              		.loc 1 4098 0
 5446 3008 400013E3 		tst	r3, #64
 5447 300c 0100001A 		bne	.L579
 5448              	.L393:
4311:../uvc.c      ****         CyU3PThreadRelinquish ();
 5449              		.loc 1 4311 0
 5450 3010 FEFFFFEB 		bl	_txe_thread_relinquish
4312:../uvc.c      ****     }
 5451              		.loc 1 4312 0
 5452 3014 C3FFFFEA 		b	.L547
 5453              	.L579:
4103:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5454              		.loc 1 4103 0
 5455 3018 1800A0E3 		mov	r0, #24
 5456 301c 24108DE2 		add	r1, sp, #36
 5457 3020 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4160:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5458              		.loc 1 4160 0
 5459 3024 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 5460 3028 0F0053E3 		cmp	r3, #15
 5461 302c 9400000A 		beq	.L580
4187:../uvc.c      **** 				}else if(!snapButFlag){
 5462              		.loc 1 4187 0
 5463 3030 000053E3 		cmp	r3, #0
 5464 3034 F5FFFF1A 		bne	.L393
4189:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5465              		.loc 1 4189 0
 5466 3038 002097E5 		ldr	r2, [r7, #0]
 5467 303c 0290A0E3 		mov	r9, #2
 5468 3040 0090C2E5 		strb	r9, [r2, #0]
4190:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5469              		.loc 1 4190 0
 5470 3044 001097E5 		ldr	r1, [r7, #0]
 5471 3048 0190A0E3 		mov	r9, #1
 5472 304c 0190C1E5 		strb	r9, [r1, #1]
4191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5473              		.loc 1 4191 0
 5474 3050 000097E5 		ldr	r0, [r7, #0]
4195:../uvc.c      **** 					interStabuf.size   = 1024;
 5475              		.loc 1 4195 0
 5476 3054 01CBA0E3 		mov	ip, #1024	@ movhi
4191:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5477              		.loc 1 4191 0
 5478 3058 0230C0E5 		strb	r3, [r0, #2]
4192:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5479              		.loc 1 4192 0
 5480 305c 00E097E5 		ldr	lr, [r7, #0]
4201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5481              		.loc 1 4201 0
 5482 3060 0010E0E3 		mvn	r1, #0
4192:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5483              		.loc 1 4192 0
 5484 3064 0390CEE5 		strb	r9, [lr, #3]
4194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5485              		.loc 1 4194 0
 5486 3068 002097E5 		ldr	r2, [r7, #0]
4198:../uvc.c      **** 					interStabuf.count = 4;
 5487              		.loc 1 4198 0
 5488 306c 04E0A0E3 		mov	lr, #4	@ movhi
4201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5489              		.loc 1 4201 0
 5490 3070 180C9FE5 		ldr	r0, .L587+28
4194:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5491              		.loc 1 4194 0
 5492 3074 18208DE5 		str	r2, [sp, #24]
4195:../uvc.c      **** 					interStabuf.size   = 1024;
 5493              		.loc 1 4195 0
 5494 3078 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4196:../uvc.c      **** 					interStabuf.status = 0;
 5495              		.loc 1 4196 0
 5496 307c B032CDE1 		strh	r3, [sp, #32]	@ movhi
4198:../uvc.c      **** 					interStabuf.count = 4;
 5497              		.loc 1 4198 0
 5498 3080 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
4201:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5499              		.loc 1 4201 0
 5500 3084 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4204:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5501              		.loc 1 4204 0
 5502 3088 000C9FE5 		ldr	r0, .L587+28
 5503 308c 18108DE2 		add	r1, sp, #24
 5504 3090 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5505              	.LVL491:
4206:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5506              		.loc 1 4206 0
 5507 3094 002050E2 		subs	r2, r0, #0
 5508 3098 5B01001A 		bne	.L581
4212:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 5509              		.loc 1 4212 0
 5510 309c 3010A0E3 		mov	r1, #48
 5511 30a0 0920A0E1 		mov	r2, r9
 5512 30a4 0500A0E3 		mov	r0, #5
 5513              	.LVL492:
 5514 30a8 FEFFFFEB 		bl	SensorSetControl
4213:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 5515              		.loc 1 4213 0
 5516 30ac C43B9FE5 		ldr	r3, .L587+4
 5517 30b0 0B97C3E5 		strb	r9, [r3, #1803]
4311:../uvc.c      ****         CyU3PThreadRelinquish ();
 5518              		.loc 1 4311 0
 5519 30b4 FEFFFFEB 		bl	_txe_thread_relinquish
 5520 30b8 9AFFFFEA 		b	.L547
 5521              	.L399:
 5522              	.LBB118:
 5523              	.LBB104:
3336:../uvc.c      ****     switch (wValue)
 5524              		.loc 1 3336 0
 5525 30bc B020DAE1 		ldrh	r2, [sl, #0]
 5526 30c0 060C52E3 		cmp	r2, #1536
 5527 30c4 7502000A 		beq	.L423
 5528 30c8 9900008A 		bhi	.L429
 5529 30cc 030C52E3 		cmp	r2, #768
 5530 30d0 5B02000A 		beq	.L420
 5531 30d4 8101008A 		bhi	.L430
 5532 30d8 010C52E3 		cmp	r2, #256
 5533 30dc 5402000A 		beq	.L418
 5534 30e0 020C52E3 		cmp	r2, #512
 5535 30e4 B4FFFF1A 		bne	.L417
 5536              	.LVL493:
3344:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 5537              		.loc 1 3344 0
 5538 30e8 0100A0E3 		mov	r0, #1
 5539 30ec FEFFFFEB 		bl	CTControlHandle
 5540              	.LVL494:
 5541 30f0 28309DE5 		ldr	r3, [sp, #40]
 5542 30f4 B9FFFFEA 		b	.L396
 5543              	.L401:
 5544              	.LBE104:
 5545              	.LBE118:
 5546              	.LBB119:
 5547              	.LBB125:
3561:../uvc.c      ****     switch (wValue)
 5548              		.loc 1 3561 0
 5549 30f8 B030DAE1 		ldrh	r3, [sl, #0]
 5550 30fc 090C53E3 		cmp	r3, #2304
 5551 3100 4702000A 		beq	.L444
 5552 3104 9200008A 		bhi	.L454
 5553 3108 010B53E3 		cmp	r3, #1024
 5554 310c 4002000A 		beq	.L439
 5555 3110 5701008A 		bhi	.L455
 5556 3114 020C53E3 		cmp	r3, #512
 5557 3118 C101000A 		beq	.L437
 5558 311c 030C53E3 		cmp	r3, #768
 5559 3120 BB01000A 		beq	.L438
 5560 3124 010C53E3 		cmp	r3, #256
 5561 3128 A7FFFF1A 		bne	.L397
 5562              	.LVL495:
3565:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5563              		.loc 1 3565 0
 5564 312c 1000A0E3 		mov	r0, #16
 5565 3130 FEFFFFEB 		bl	ControlHandle
 5566              	.LVL496:
 5567 3134 28309DE5 		ldr	r3, [sp, #40]
 5568 3138 A8FFFFEA 		b	.L396
 5569              	.L577:
 5570              	.LBE125:
 5571              	.LBE119:
4049:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 5572              		.loc 1 4049 0
 5573 313c B0C0DAE1 		ldrh	ip, [sl, #0]
 5574 3140 4C9B9FE5 		ldr	r9, .L587+32
 5575 3144 4C1B9FE5 		ldr	r1, .L587+36
 5576 3148 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 5577 314c 08C08DE5 		str	ip, [sp, #8]
 5578 3150 B000DBE1 		ldrh	r0, [fp, #0]
 5579 3154 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 5580 3158 0C008DE5 		str	r0, [sp, #12]
 5581 315c B0C0D1E1 		ldrh	ip, [r1, #0]
 5582 3160 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 5583 3164 04908DE5 		str	r9, [sp, #4]
 5584 3168 0400A0E3 		mov	r0, #4
 5585 316c 281B9FE5 		ldr	r1, .L587+40
 5586 3170 0090A0E3 		mov	r9, #0
 5587 3174 00E08DE5 		str	lr, [sp, #0]
 5588 3178 10C08DE5 		str	ip, [sp, #16]
 5589 317c 14908DE5 		str	r9, [sp, #20]
 5590 3180 FEFFFFEB 		bl	CyU3PDebugPrint
 5591 3184 28309DE5 		ldr	r3, [sp, #40]
 5592 3188 75FFFFEA 		b	.L395
 5593              	.L576:
4041:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5594              		.loc 1 4041 0
 5595 318c FEFFFFEB 		bl	CyU3PUsbGetSpeed
4042:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5596              		.loc 1 4042 0
 5597 3190 000050E3 		cmp	r0, #0
4041:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5598              		.loc 1 4041 0
 5599 3194 4800C6E5 		strb	r0, [r6, #72]
4044:../uvc.c      ****                     isUsbConnected = CyTrue;
 5600              		.loc 1 4044 0
 5601 3198 0100A013 		movne	r0, #1
 5602 319c 30008615 		strne	r0, [r6, #48]
 5603 31a0 6CFFFFEA 		b	.L394
 5604              	.L461:
 5605              	.LVL497:
 5606              	.LBB132:
 5607              	.LBB114:
3662:../uvc.c      ****     switch (wValue)
 5608              		.loc 1 3662 0
 5609 31a4 B020DAE1 		ldrh	r2, [sl, #0]
 5610 31a8 030C52E3 		cmp	r2, #768
 5611 31ac CD00000A 		beq	.L465
 5612 31b0 0F00008A 		bhi	.L468
 5613 31b4 010C52E3 		cmp	r2, #256
 5614 31b8 8600000A 		beq	.L463
 5615 31bc 020C52E3 		cmp	r2, #512
 5616 31c0 8BFFFF1A 		bne	.L462
3727:../uvc.c      ****             switch (bRequest)
 5617              		.loc 1 3727 0
 5618 31c4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5619 31c8 810053E3 		cmp	r3, #129
 5620 31cc 8301000A 		beq	.L534
 5621 31d0 D100008A 		bhi	.L483
 5622 31d4 010053E3 		cmp	r3, #1
 5623 31d8 7101000A 		beq	.L582
 5624              	.L510:
3940:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5625              		.loc 1 3940 0
 5626 31dc 0000A0E3 		mov	r0, #0
 5627 31e0 0110A0E3 		mov	r1, #1
 5628 31e4 0020A0E1 		mov	r2, r0
 5629 31e8 FEFFFFEB 		bl	CyU3PUsbStall
 5630 31ec 28309DE5 		ldr	r3, [sp, #40]
 5631 31f0 84FFFFEA 		b	.L460
 5632              	.L468:
3662:../uvc.c      ****     switch (wValue)
 5633              		.loc 1 3662 0
 5634 31f4 010B52E3 		cmp	r2, #1024
 5635 31f8 6100000A 		beq	.L466
 5636 31fc 050C52E3 		cmp	r2, #1280
 5637 3200 7BFFFF1A 		bne	.L462
3947:../uvc.c      ****             	switch (bRequest)
 5638              		.loc 1 3947 0
 5639 3204 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5640 3208 810052E3 		cmp	r2, #129
 5641 320c 7301000A 		beq	.L534
 5642 3210 4401008A 		bhi	.L537
 5643 3214 010052E3 		cmp	r2, #1
 5644 3218 75FFFF1A 		bne	.L462
3972:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5645              		.loc 1 3972 0
 5646 321c 2000A0E3 		mov	r0, #32
 5647 3220 781A9FE5 		ldr	r1, .L587+44
 5648 3224 2E208DE2 		add	r2, sp, #46
 5649 3228 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5650              	.LVL498:
3974:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5651              		.loc 1 3974 0
 5652 322c 000050E3 		cmp	r0, #0
 5653 3230 5501001A 		bne	.L539
3978:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5654              		.loc 1 3978 0
 5655 3234 0020A0E3 		mov	r2, #0
 5656 3238 340A9FE5 		ldr	r0, .L587
 5657              	.LVL499:
 5658 323c 8010A0E3 		mov	r1, #128
 5659 3240 FEFFFFEB 		bl	_txe_event_flags_set
 5660              	.LVL500:
3979:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5661              		.loc 1 3979 0
 5662 3244 002050E2 		subs	r2, r0, #0
3985:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5663              		.loc 1 3985 0
 5664 3248 0FC0E003 		mvneq	ip, #15
 5665 324c 3AC0C605 		streqb	ip, [r6, #58]
3979:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5666              		.loc 1 3979 0
 5667 3250 0200000A 		beq	.L541
3981:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5668              		.loc 1 3981 0
 5669 3254 481A9FE5 		ldr	r1, .L587+48
 5670 3258 0400A0E3 		mov	r0, #4
 5671              	.LVL501:
 5672 325c FEFFFFEB 		bl	CyU3PDebugPrint
 5673              	.LVL502:
 5674              	.L541:
3988:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5675              		.loc 1 3988 0
 5676 3260 C1E0D4E5 		ldrb	lr, [r4, #193]	@ zero_extendqisi2
 5677 3264 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 5678 3268 BE22DDE1 		ldrh	r2, [sp, #46]
 5679              	.LVL503:
 5680 326c 0400A0E3 		mov	r0, #4
 5681 3270 301A9FE5 		ldr	r1, .L587+52
 5682 3274 00E08DE5 		str	lr, [sp, #0]
 5683 3278 FEFFFFEB 		bl	CyU3PDebugPrint
 5684 327c 28309DE5 		ldr	r3, [sp, #40]
 5685 3280 60FFFFEA 		b	.L460
 5686              	.LVL504:
 5687              	.L580:
 5688              	.LBE114:
 5689              	.LBE132:
4162:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5690              		.loc 1 4162 0
 5691 3284 003097E5 		ldr	r3, [r7, #0]
 5692 3288 0290A0E3 		mov	r9, #2
 5693 328c 0090C3E5 		strb	r9, [r3, #0]
4163:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5694              		.loc 1 4163 0
 5695 3290 002097E5 		ldr	r2, [r7, #0]
 5696 3294 0190A0E3 		mov	r9, #1
 5697 3298 0190C2E5 		strb	r9, [r2, #1]
4164:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5698              		.loc 1 4164 0
 5699 329c 001097E5 		ldr	r1, [r7, #0]
 5700 32a0 0030A0E3 		mov	r3, #0
 5701 32a4 0230C1E5 		strb	r3, [r1, #2]
4165:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5702              		.loc 1 4165 0
 5703 32a8 000097E5 		ldr	r0, [r7, #0]
4171:../uvc.c      **** 					interStabuf.count = 4;
 5704              		.loc 1 4171 0
 5705 32ac 0420A0E3 		mov	r2, #4	@ movhi
4165:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5706              		.loc 1 4165 0
 5707 32b0 0330C0E5 		strb	r3, [r0, #3]
4167:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5708              		.loc 1 4167 0
 5709 32b4 00E097E5 		ldr	lr, [r7, #0]
4168:../uvc.c      **** 					interStabuf.size   = 1024;
 5710              		.loc 1 4168 0
 5711 32b8 01CBA0E3 		mov	ip, #1024	@ movhi
4174:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5712              		.loc 1 4174 0
 5713 32bc 0010E0E3 		mvn	r1, #0
 5714 32c0 C8099FE5 		ldr	r0, .L587+28
4171:../uvc.c      **** 					interStabuf.count = 4;
 5715              		.loc 1 4171 0
 5716 32c4 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
4167:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5717              		.loc 1 4167 0
 5718 32c8 18E08DE5 		str	lr, [sp, #24]
4168:../uvc.c      **** 					interStabuf.size   = 1024;
 5719              		.loc 1 4168 0
 5720 32cc BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4169:../uvc.c      **** 					interStabuf.status = 0;
 5721              		.loc 1 4169 0
 5722 32d0 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4174:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5723              		.loc 1 4174 0
 5724 32d4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4177:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5725              		.loc 1 4177 0
 5726 32d8 B0099FE5 		ldr	r0, .L587+28
 5727 32dc 18108DE2 		add	r1, sp, #24
 5728 32e0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5729              	.LVL505:
4179:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5730              		.loc 1 4179 0
 5731 32e4 002050E2 		subs	r2, r0, #0
 5732 32e8 D800001A 		bne	.L583
4184:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5733              		.loc 1 4184 0
 5734 32ec 3010A0E3 		mov	r1, #48
 5735 32f0 0500A0E3 		mov	r0, #5
 5736              	.LVL506:
 5737 32f4 FEFFFFEB 		bl	SensorSetControl
 5738              	.LVL507:
4186:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5739              		.loc 1 4186 0
 5740 32f8 78C99FE5 		ldr	ip, .L587+4
 5741 32fc 0B97CCE5 		strb	r9, [ip, #1803]
4311:../uvc.c      ****         CyU3PThreadRelinquish ();
 5742              		.loc 1 4311 0
 5743 3300 FEFFFFEB 		bl	_txe_thread_relinquish
 5744 3304 07FFFFEA 		b	.L547
 5745              	.L414:
 5746              	.LBB133:
 5747              	.LBB93:
3261:../uvc.c      ****     switch (wValue)
 5748              		.loc 1 3261 0
 5749 3308 0A0C52E3 		cmp	r2, #2560
 5750 330c 1A01000A 		beq	.L411
 5751 3310 FA00008A 		bhi	.L416
 5752 3314 070C52E3 		cmp	r2, #1792
 5753 3318 1301000A 		beq	.L409
 5754 331c 020B52E3 		cmp	r2, #2048
 5755 3320 25FFFF1A 		bne	.L417
 5756              	.LVL508:
3292:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5757              		.loc 1 3292 0
 5758 3324 0700A0E3 		mov	r0, #7
 5759 3328 FEFFFFEB 		bl	ControlHandle
 5760              	.LVL509:
 5761 332c 28309DE5 		ldr	r3, [sp, #40]
 5762 3330 2AFFFFEA 		b	.L396
 5763              	.L429:
 5764              	.LBE93:
 5765              	.LBE133:
 5766              	.LBB134:
 5767              	.LBB102:
3336:../uvc.c      ****     switch (wValue)
 5768              		.loc 1 3336 0
 5769 3334 090C52E3 		cmp	r2, #2304
 5770 3338 A901000A 		beq	.L425
 5771 333c D500008A 		bhi	.L431
 5772 3340 070C52E3 		cmp	r2, #1792
 5773 3344 A201000A 		beq	.L424
 5774 3348 020B52E3 		cmp	r2, #2048
 5775 334c 1AFFFF1A 		bne	.L417
 5776 3350 22FFFFEA 		b	.L396
 5777              	.L454:
 5778              	.LBE102:
 5779              	.LBE134:
 5780              	.LBB135:
 5781              	.LBB126:
3561:../uvc.c      ****     switch (wValue)
 5782              		.loc 1 3561 0
 5783 3354 0F0C53E3 		cmp	r3, #3840
 5784 3358 9901000A 		beq	.L449
 5785 335c A100008A 		bhi	.L457
 5786 3360 0B0C53E3 		cmp	r3, #2816
 5787 3364 FC00000A 		beq	.L446
 5788 3368 9600008A 		bhi	.L458
 5789 336c 0A0C53E3 		cmp	r3, #2560
 5790 3370 15FFFF1A 		bne	.L397
 5791              	.LVL510:
3602:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5792              		.loc 1 3602 0
 5793 3374 1900A0E3 		mov	r0, #25
 5794 3378 FEFFFFEB 		bl	ControlHandle
 5795              	.LVL511:
 5796 337c 28309DE5 		ldr	r3, [sp, #40]
 5797 3380 16FFFFEA 		b	.L396
 5798              	.LVL512:
 5799              	.L466:
 5800              	.LBE126:
 5801              	.LBE135:
 5802              	.LBB136:
 5803              	.LBB112:
3861:../uvc.c      ****                 switch (bRequest)
 5804              		.loc 1 3861 0
 5805 3384 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5806 3388 810052E3 		cmp	r2, #129
 5807 338c 5A00000A 		beq	.L512
 5808 3390 2100008A 		bhi	.L515
 5809 3394 010052E3 		cmp	r2, #1
 5810 3398 8FFFFF1A 		bne	.L510
3886:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5811              		.loc 1 3886 0
 5812 339c 2000A0E3 		mov	r0, #32
 5813 33a0 F8189FE5 		ldr	r1, .L587+44
 5814 33a4 2E208DE2 		add	r2, sp, #46
 5815 33a8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5816              	.LVL513:
3888:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5817              		.loc 1 3888 0
 5818 33ac 000050E3 		cmp	r0, #0
 5819 33b0 13FFFF1A 		bne	.L566
3907:../uvc.c      ****                            switch (glCommitCtrl[1])
 5820              		.loc 1 3907 0
 5821 33b4 C120D6E5 		ldrb	r2, [r6, #193]	@ zero_extendqisi2
 5822 33b8 011042E2 		sub	r1, r2, #1
 5823 33bc 030051E3 		cmp	r1, #3
 5824 33c0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5825 33c4 C90100EA 		b	.L518
 5826              	.L523:
 5827 33c8 5C3B0000 		.word	.L519
 5828 33cc B03B0000 		.word	.L520
 5829 33d0 183B0000 		.word	.L521
 5830 33d4 B03A0000 		.word	.L522
 5831              	.LVL514:
 5832              	.L463:
3665:../uvc.c      ****             switch (bRequest)
 5833              		.loc 1 3665 0
 5834 33d8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5835 33dc 830052E3 		cmp	r2, #131
 5836 33e0 3100008A 		bhi	.L474
 5837 33e4 810052E3 		cmp	r2, #129
 5838 33e8 1600003A 		bcc	.L584
 5839              	.L471:
3680:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5840              		.loc 1 3680 0
 5841 33ec 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5842 33f0 030053E3 		cmp	r3, #3
 5843 33f4 FC00001A 		bne	.L538
3682:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5844              		.loc 1 3682 0
 5845 33f8 AC189FE5 		ldr	r1, .L587+56
 5846 33fc 1A00A0E3 		mov	r0, #26
 5847 3400 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3683:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5848              		.loc 1 3683 0
 5849 3404 0400A0E3 		mov	r0, #4
 5850 3408 A0189FE5 		ldr	r1, .L587+60
 5851 340c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5852 3410 FEFFFFEB 		bl	CyU3PDebugPrint
 5853 3414 28309DE5 		ldr	r3, [sp, #40]
 5854 3418 FAFEFFEA 		b	.L460
 5855              	.L515:
3861:../uvc.c      ****                 switch (bRequest)
 5856              		.loc 1 3861 0
 5857 341c 850052E3 		cmp	r2, #133
 5858 3420 2700000A 		beq	.L513
 5859 3424 860052E3 		cmp	r2, #134
 5860 3428 6BFFFF1A 		bne	.L510
 5861              	.L570:
3865:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5862              		.loc 1 3865 0
 5863 342c 0300A0E1 		mov	r0, r3
 5864              	.L565:
3731:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5865              		.loc 1 3731 0
 5866 3430 7C189FE5 		ldr	r1, .L587+64
3730:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5867              		.loc 1 3730 0
 5868 3434 0390A0E3 		mov	r9, #3
 5869 3438 5C90C4E5 		strb	r9, [r4, #92]
3731:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5870              		.loc 1 3731 0
 5871 343c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5872 3440 28309DE5 		ldr	r3, [sp, #40]
 5873 3444 EFFEFFEA 		b	.L460
 5874              	.L584:
3665:../uvc.c      ****             switch (bRequest)
 5875              		.loc 1 3665 0
 5876 3448 010052E3 		cmp	r2, #1
 5877 344c 62FFFF1A 		bne	.L510
3692:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5878              		.loc 1 3692 0
 5879 3450 2000A0E3 		mov	r0, #32
 5880 3454 44189FE5 		ldr	r1, .L587+44
 5881 3458 2E208DE2 		add	r2, sp, #46
 5882 345c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5883              	.LVL515:
3694:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5884              		.loc 1 3694 0
 5885 3460 000050E3 		cmp	r0, #0
 5886 3464 E6FEFF1A 		bne	.L566
3696:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5887              		.loc 1 3696 0
 5888 3468 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5889 346c 030051E3 		cmp	r1, #3
 5890 3470 E3FEFF1A 		bne	.L566
3703:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5891              		.loc 1 3703 0
 5892 3474 C530D4E5 		ldrb	r3, [r4, #197]	@ zero_extendqisi2
3700:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5893              		.loc 1 3700 0
 5894 3478 C2E0D4E5 		ldrb	lr, [r4, #194]	@ zero_extendqisi2
3701:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5895              		.loc 1 3701 0
 5896 347c C3C0D4E5 		ldrb	ip, [r4, #195]	@ zero_extendqisi2
3702:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5897              		.loc 1 3702 0
 5898 3480 C400D4E5 		ldrb	r0, [r4, #196]	@ zero_extendqisi2
 5899              	.LVL516:
3704:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5900              		.loc 1 3704 0
 5901 3484 C620D4E5 		ldrb	r2, [r4, #198]	@ zero_extendqisi2
3705:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5902              		.loc 1 3705 0
 5903 3488 C790D4E5 		ldrb	r9, [r4, #199]	@ zero_extendqisi2
3703:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5904              		.loc 1 3703 0
 5905 348c A536C5E5 		strb	r3, [r5, #1701]
3700:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5906              		.loc 1 3700 0
 5907 3490 A2E6C5E5 		strb	lr, [r5, #1698]
3701:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5908              		.loc 1 3701 0
 5909 3494 A3C6C5E5 		strb	ip, [r5, #1699]
3702:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5910              		.loc 1 3702 0
 5911 3498 A406C5E5 		strb	r0, [r5, #1700]
3704:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5912              		.loc 1 3704 0
 5913 349c A626C5E5 		strb	r2, [r5, #1702]
3705:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5914              		.loc 1 3705 0
 5915 34a0 A796C5E5 		strb	r9, [r5, #1703]
 5916 34a4 28309DE5 		ldr	r3, [sp, #40]
 5917 34a8 D6FEFFEA 		b	.L460
 5918              	.LVL517:
 5919              	.L474:
3665:../uvc.c      ****             switch (bRequest)
 5920              		.loc 1 3665 0
 5921 34ac 860052E3 		cmp	r2, #134
 5922 34b0 DDFFFF0A 		beq	.L570
 5923 34b4 870052E3 		cmp	r2, #135
 5924 34b8 CBFFFF0A 		beq	.L471
 5925              	.L575:
3811:../uvc.c      ****                 switch (bRequest)
 5926              		.loc 1 3811 0
 5927 34bc 850052E3 		cmp	r2, #133
 5928 34c0 45FFFF1A 		bne	.L510
 5929              	.L513:
3870:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5930              		.loc 1 3870 0
 5931 34c4 E8179FE5 		ldr	r1, .L587+64
 5932 34c8 0200A0E3 		mov	r0, #2
3868:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 5933              		.loc 1 3868 0
 5934 34cc 1A30A0E3 		mov	r3, #26
 5935              	.L567:
3955:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5936              		.loc 1 3955 0
 5937 34d0 0090A0E3 		mov	r9, #0
3954:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5938              		.loc 1 3954 0
 5939 34d4 5C30C4E5 		strb	r3, [r4, #92]
3955:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5940              		.loc 1 3955 0
 5941 34d8 5D90C4E5 		strb	r9, [r4, #93]
3956:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5942              		.loc 1 3956 0
 5943 34dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5944 34e0 28309DE5 		ldr	r3, [sp, #40]
 5945 34e4 C7FEFFEA 		b	.L460
 5946              	.L465:
3811:../uvc.c      ****                 switch (bRequest)
 5947              		.loc 1 3811 0
 5948 34e8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5949 34ec 830052E3 		cmp	r2, #131
 5950 34f0 2F00008A 		bhi	.L506
 5951 34f4 810052E3 		cmp	r2, #129
 5952 34f8 0D00003A 		bcc	.L585
 5953              	.L512:
3873:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5954              		.loc 1 3873 0
 5955 34fc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3875:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5956              		.loc 1 3875 0
 5957 3500 0B00A0E3 		mov	r0, #11
3873:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5958              		.loc 1 3873 0
 5959 3504 030053E3 		cmp	r3, #3
3875:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5960              		.loc 1 3875 0
 5961 3508 A8179F05 		ldreq	r1, .L587+68
3879:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5962              		.loc 1 3879 0
 5963 350c A8179F15 		ldrne	r1, .L587+72
 5964 3510 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5965 3514 28309DE5 		ldr	r3, [sp, #40]
 5966 3518 BAFEFFEA 		b	.L460
 5967              	.L483:
3727:../uvc.c      ****             switch (bRequest)
 5968              		.loc 1 3727 0
 5969 351c 850053E3 		cmp	r3, #133
 5970 3520 E7FFFF0A 		beq	.L513
 5971 3524 860053E3 		cmp	r3, #134
 5972 3528 2BFFFF1A 		bne	.L510
 5973              	.L571:
3731:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5974              		.loc 1 3731 0
 5975 352c 0100A0E3 		mov	r0, #1
 5976 3530 BEFFFFEA 		b	.L565
 5977              	.L585:
3811:../uvc.c      ****                 switch (bRequest)
 5978              		.loc 1 3811 0
 5979 3534 010052E3 		cmp	r2, #1
 5980 3538 27FFFF1A 		bne	.L510
3836:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5981              		.loc 1 3836 0
 5982 353c 2000A0E3 		mov	r0, #32
 5983 3540 58179FE5 		ldr	r1, .L587+44
 5984 3544 2E208DE2 		add	r2, sp, #46
 5985 3548 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5986              	.LVL518:
3838:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5987              		.loc 1 3838 0
 5988 354c 000050E3 		cmp	r0, #0
 5989 3550 ABFEFF1A 		bne	.L566
3840:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5990              		.loc 1 3840 0
 5991 3554 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5992 3558 030051E3 		cmp	r1, #3
 5993 355c 0B00001A 		bne	.L509
3844:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5994              		.loc 1 3844 0
 5995 3560 C1E0D6E5 		ldrb	lr, [r6, #193]	@ zero_extendqisi2
3845:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5996              		.loc 1 3845 0
 5997 3564 C2C0D6E5 		ldrb	ip, [r6, #194]	@ zero_extendqisi2
3846:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5998              		.loc 1 3846 0
 5999 3568 C300D6E5 		ldrb	r0, [r6, #195]	@ zero_extendqisi2
 6000              	.LVL519:
3847:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6001              		.loc 1 3847 0
 6002 356c C420D6E5 		ldrb	r2, [r6, #196]	@ zero_extendqisi2
3848:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6003              		.loc 1 3848 0
 6004 3570 C590D6E5 		ldrb	r9, [r6, #197]	@ zero_extendqisi2
3849:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6005              		.loc 1 3849 0
 6006 3574 C630D6E5 		ldrb	r3, [r6, #198]	@ zero_extendqisi2
3844:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6007              		.loc 1 3844 0
 6008 3578 F5E6C5E5 		strb	lr, [r5, #1781]
3845:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6009              		.loc 1 3845 0
 6010 357c F6C6C5E5 		strb	ip, [r5, #1782]
3846:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6011              		.loc 1 3846 0
 6012 3580 F706C5E5 		strb	r0, [r5, #1783]
3847:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6013              		.loc 1 3847 0
 6014 3584 F826C5E5 		strb	r2, [r5, #1784]
3848:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6015              		.loc 1 3848 0
 6016 3588 F996C5E5 		strb	r9, [r5, #1785]
3849:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6017              		.loc 1 3849 0
 6018 358c FA36C5E5 		strb	r3, [r5, #1786]
 6019              	.L509:
3851:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 6020              		.loc 1 3851 0
 6021 3590 C190D4E5 		ldrb	r9, [r4, #193]	@ zero_extendqisi2
 6022 3594 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6023 3598 BE22DDE1 		ldrh	r2, [sp, #46]
 6024              	.LVL520:
 6025 359c 0400A0E3 		mov	r0, #4
 6026 35a0 18179FE5 		ldr	r1, .L587+76
 6027 35a4 00908DE5 		str	r9, [sp, #0]
 6028 35a8 FEFFFFEB 		bl	CyU3PDebugPrint
 6029 35ac 28309DE5 		ldr	r3, [sp, #40]
 6030 35b0 94FEFFEA 		b	.L460
 6031              	.LVL521:
 6032              	.L506:
3811:../uvc.c      ****                 switch (bRequest)
 6033              		.loc 1 3811 0
 6034 35b4 860052E3 		cmp	r2, #134
 6035 35b8 9BFFFF0A 		beq	.L570
 6036 35bc 870052E3 		cmp	r2, #135
 6037 35c0 BDFFFF1A 		bne	.L575
 6038 35c4 CCFFFFEA 		b	.L512
 6039              	.LVL522:
 6040              	.L458:
 6041              	.LBE112:
 6042              	.LBE136:
 6043              	.LBB137:
 6044              	.LBB124:
3561:../uvc.c      ****     switch (wValue)
 6045              		.loc 1 3561 0
 6046 35c8 030B53E3 		cmp	r3, #3072
 6047 35cc A401000A 		beq	.L447
 6048 35d0 0D0C53E3 		cmp	r3, #3328
 6049 35d4 7CFEFF1A 		bne	.L397
 6050              	.LVL523:
3618:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6051              		.loc 1 3618 0
 6052 35d8 1C00A0E3 		mov	r0, #28
 6053 35dc FEFFFFEB 		bl	ControlHandle
 6054              	.LVL524:
 6055 35e0 28309DE5 		ldr	r3, [sp, #40]
 6056 35e4 7DFEFFEA 		b	.L396
 6057              	.L457:
3561:../uvc.c      ****     switch (wValue)
 6058              		.loc 1 3561 0
 6059 35e8 110C53E3 		cmp	r3, #4352
 6060 35ec 9801000A 		beq	.L451
 6061 35f0 5100008A 		bhi	.L459
 6062 35f4 010A53E3 		cmp	r3, #4096
 6063 35f8 73FEFF1A 		bne	.L397
 6064              	.LVL525:
3630:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6065              		.loc 1 3630 0
 6066 35fc 1F00A0E3 		mov	r0, #31
 6067 3600 FEFFFFEB 		bl	ControlHandle
 6068              	.LVL526:
 6069 3604 28309DE5 		ldr	r3, [sp, #40]
 6070 3608 74FEFFEA 		b	.L396
 6071              	.LVL527:
 6072              	.L581:
 6073              	.LBE124:
 6074              	.LBE137:
4208:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6075              		.loc 1 4208 0
 6076 360c 0400A0E3 		mov	r0, #4
 6077              	.LVL528:
 6078 3610 AC169FE5 		ldr	r1, .L587+80
 6079 3614 FEFFFFEB 		bl	CyU3PDebugPrint
 6080              	.LVL529:
 6081              	.L546:
 6082              	.LBB138:
 6083              	.LBB139:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6084              		.loc 1 1970 0
 6085 3618 A8169FE5 		ldr	r1, .L587+84
 6086 361c 0400A0E3 		mov	r0, #4
 6087 3620 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 6088              		.loc 1 1971 0
 6089 3624 FA0FA0E3 		mov	r0, #1000
 6090 3628 FEFFFFEB 		bl	_tx_thread_sleep
 6091 362c F9FFFFEA 		b	.L546
 6092              	.L415:
 6093              	.LBE139:
 6094              	.LBE138:
 6095              	.LBB140:
 6096              	.LBB95:
3261:../uvc.c      ****     switch (wValue)
 6097              		.loc 1 3261 0
 6098 3630 010B52E3 		cmp	r2, #1024
 6099 3634 69FEFF0A 		beq	.L396
 6100 3638 050C52E3 		cmp	r2, #1280
 6101 363c 5EFEFF1A 		bne	.L417
 6102              	.LVL530:
3280:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6103              		.loc 1 3280 0
 6104 3640 0400A0E3 		mov	r0, #4
 6105 3644 FEFFFFEB 		bl	ControlHandle
 6106              	.LVL531:
 6107 3648 28309DE5 		ldr	r3, [sp, #40]
 6108 364c 63FEFFEA 		b	.L396
 6109              	.LVL532:
 6110              	.L583:
 6111              	.LBE95:
 6112              	.LBE140:
4181:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6113              		.loc 1 4181 0
 6114 3650 0400A0E3 		mov	r0, #4
 6115              	.LVL533:
 6116 3654 68169FE5 		ldr	r1, .L587+80
 6117 3658 FEFFFFEB 		bl	CyU3PDebugPrint
 6118              	.LVL534:
 6119              	.L544:
 6120              	.LBB141:
 6121              	.LBB142:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6122              		.loc 1 1970 0
 6123 365c 64169FE5 		ldr	r1, .L587+84
 6124 3660 0400A0E3 		mov	r0, #4
 6125 3664 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 6126              		.loc 1 1971 0
 6127 3668 FA0FA0E3 		mov	r0, #1000
 6128 366c FEFFFFEB 		bl	_tx_thread_sleep
 6129 3670 F9FFFFEA 		b	.L544
 6130              	.L455:
 6131              	.LBE142:
 6132              	.LBE141:
 6133              	.LBB143:
 6134              	.LBB127:
3561:../uvc.c      ****     switch (wValue)
 6135              		.loc 1 3561 0
 6136 3674 060C53E3 		cmp	r3, #1536
 6137 3678 7101000A 		beq	.L441
 6138 367c 0F00008A 		bhi	.L456
 6139 3680 050C53E3 		cmp	r3, #1280
 6140 3684 50FEFF1A 		bne	.L397
 6141              	.LVL535:
3581:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6142              		.loc 1 3581 0
 6143 3688 1400A0E3 		mov	r0, #20
 6144 368c FEFFFFEB 		bl	ControlHandle
 6145              	.LVL536:
 6146 3690 28309DE5 		ldr	r3, [sp, #40]
 6147 3694 51FEFFEA 		b	.L396
 6148              	.L431:
 6149              	.LBE127:
 6150              	.LBE143:
 6151              	.LBB144:
 6152              	.LBB105:
3336:../uvc.c      ****     switch (wValue)
 6153              		.loc 1 3336 0
 6154 3698 0B0C52E3 		cmp	r2, #2816
 6155 369c 6401000A 		beq	.L427
 6156 36a0 030B52E3 		cmp	r2, #3072
 6157 36a4 5E01000A 		beq	.L428
 6158 36a8 0A0C52E3 		cmp	r2, #2560
 6159 36ac 42FEFF1A 		bne	.L417
 6160              	.LVL537:
3377:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6161              		.loc 1 3377 0
 6162 36b0 0800A0E3 		mov	r0, #8
 6163 36b4 FEFFFFEB 		bl	CTControlHandle
 6164              	.LVL538:
 6165 36b8 28309DE5 		ldr	r3, [sp, #40]
 6166 36bc 47FEFFEA 		b	.L396
 6167              	.L456:
 6168              	.LBE105:
 6169              	.LBE144:
 6170              	.LBB145:
 6171              	.LBB123:
3561:../uvc.c      ****     switch (wValue)
 6172              		.loc 1 3561 0
 6173 36c0 070C53E3 		cmp	r3, #1792
 6174 36c4 5201000A 		beq	.L442
 6175 36c8 020B53E3 		cmp	r3, #2048
 6176 36cc 3EFEFF1A 		bne	.L397
 6177              	.LVL539:
3593:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6178              		.loc 1 3593 0
 6179 36d0 1700A0E3 		mov	r0, #23
 6180 36d4 FEFFFFEB 		bl	ControlHandle
 6181              	.LVL540:
 6182 36d8 28309DE5 		ldr	r3, [sp, #40]
 6183 36dc 3FFEFFEA 		b	.L396
 6184              	.L430:
 6185              	.LBE123:
 6186              	.LBE145:
 6187              	.LBB146:
 6188              	.LBB101:
3336:../uvc.c      ****     switch (wValue)
 6189              		.loc 1 3336 0
 6190 36e0 010B52E3 		cmp	r2, #1024
 6191 36e4 4601000A 		beq	.L421
 6192 36e8 050C52E3 		cmp	r2, #1280
 6193 36ec 32FEFF1A 		bne	.L417
 6194              	.LVL541:
3358:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6195              		.loc 1 3358 0
 6196 36f0 0400A0E3 		mov	r0, #4
 6197 36f4 FEFFFFEB 		bl	CTControlHandle
 6198              	.LVL542:
 6199 36f8 28309DE5 		ldr	r3, [sp, #40]
 6200 36fc 37FEFFEA 		b	.L396
 6201              	.L416:
 6202              	.LBE101:
 6203              	.LBE146:
 6204              	.LBB147:
 6205              	.LBB92:
3261:../uvc.c      ****     switch (wValue)
 6206              		.loc 1 3261 0
 6207 3700 0D0C52E3 		cmp	r2, #3328
 6208 3704 1C00000A 		beq	.L411
 6209 3708 0E0C52E3 		cmp	r2, #3584
 6210 370c D700000A 		beq	.L413
 6211 3710 030B52E3 		cmp	r2, #3072
 6212 3714 28FEFF1A 		bne	.L417
 6213              	.LVL543:
3302:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6214              		.loc 1 3302 0
 6215 3718 0B00A0E3 		mov	r0, #11
 6216 371c FEFFFFEB 		bl	ControlHandle
 6217              	.LVL544:
 6218 3720 28309DE5 		ldr	r3, [sp, #40]
 6219 3724 2DFEFFEA 		b	.L396
 6220              	.LVL545:
 6221              	.L537:
 6222              	.LBE92:
 6223              	.LBE147:
 6224              	.LBB148:
 6225              	.LBB115:
3947:../uvc.c      ****             	switch (bRequest)
 6226              		.loc 1 3947 0
 6227 3728 850052E3 		cmp	r2, #133
 6228 372c CC00000A 		beq	.L535
 6229 3730 860052E3 		cmp	r2, #134
 6230 3734 2EFEFF1A 		bne	.L462
 6231 3738 7BFFFFEA 		b	.L571
 6232              	.LVL546:
 6233              	.L459:
 6234              	.LBE115:
 6235              	.LBE148:
 6236              	.LBB149:
 6237              	.LBB128:
3561:../uvc.c      ****     switch (wValue)
 6238              		.loc 1 3561 0
 6239 373c 120C53E3 		cmp	r3, #4608
 6240 3740 C300000A 		beq	.L452
 6241 3744 130C53E3 		cmp	r3, #4864
 6242 3748 1FFEFF1A 		bne	.L397
 6243              	.LVL547:
3642:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6244              		.loc 1 3642 0
 6245 374c 2600A0E3 		mov	r0, #38
 6246 3750 FEFFFFEB 		bl	ControlHandle
 6247              	.LVL548:
 6248 3754 28309DE5 		ldr	r3, [sp, #40]
 6249 3758 20FEFFEA 		b	.L396
 6250              	.L446:
 6251              	.LVL549:
3608:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 6252              		.loc 1 3608 0
 6253 375c 1A00A0E3 		mov	r0, #26
 6254 3760 FEFFFFEB 		bl	ControlHandle
 6255              	.LVL550:
 6256 3764 28309DE5 		ldr	r3, [sp, #40]
 6257 3768 1CFEFFEA 		b	.L396
 6258              	.L409:
 6259              	.LVL551:
 6260              	.LBE128:
 6261              	.LBE149:
 6262              	.LBB150:
 6263              	.LBB96:
3288:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 6264              		.loc 1 3288 0
 6265 376c 0600A0E3 		mov	r0, #6
 6266 3770 FEFFFFEB 		bl	ControlHandle
 6267              	.LVL552:
 6268 3774 28309DE5 		ldr	r3, [sp, #40]
 6269 3778 18FEFFEA 		b	.L396
 6270              	.L411:
 6271              	.LVL553:
3298:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 6272              		.loc 1 3298 0
 6273 377c 0900A0E3 		mov	r0, #9
 6274 3780 FEFFFFEB 		bl	ControlHandle
 6275              	.LVL554:
 6276 3784 28309DE5 		ldr	r3, [sp, #40]
 6277 3788 14FEFFEA 		b	.L396
 6278              	.LVL555:
 6279              	.L539:
 6280              	.LBE96:
 6281              	.LBE150:
 6282              	.LBB151:
 6283              	.LBB111:
3990:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6284              		.loc 1 3990 0
 6285 378c 38159FE5 		ldr	r1, .L587+88
 6286 3790 BE22DDE1 		ldrh	r2, [sp, #46]
 6287 3794 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6288 3798 0400A0E3 		mov	r0, #4
 6289              	.LVL556:
 6290 379c FEFFFFEB 		bl	CyU3PDebugPrint
 6291 37a0 13FEFFEA 		b	.L462
 6292              	.LVL557:
 6293              	.L582:
3752:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6294              		.loc 1 3752 0
 6295 37a4 2000A0E3 		mov	r0, #32
 6296 37a8 F0149FE5 		ldr	r1, .L587+44
 6297 37ac 2E208DE2 		add	r2, sp, #46
 6298 37b0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6299              	.LVL558:
3754:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6300              		.loc 1 3754 0
 6301 37b4 000050E3 		cmp	r0, #0
 6302 37b8 11FEFF1A 		bne	.L566
3756:../uvc.c      ****                         switch (glCommitCtrl[3])
 6303              		.loc 1 3756 0
 6304 37bc C320D4E5 		ldrb	r2, [r4, #195]	@ zero_extendqisi2
 6305 37c0 011042E2 		sub	r1, r2, #1
 6306 37c4 030051E3 		cmp	r1, #3
 6307 37c8 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6308 37cc 2E0000EA 		b	.L486
 6309              	.L491:
 6310 37d0 2C390000 		.word	.L487
 6311 37d4 78390000 		.word	.L488
 6312 37d8 D0380000 		.word	.L489
 6313 37dc 34380000 		.word	.L490
 6314              	.LVL559:
 6315              	.L534:
3959:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6316              		.loc 1 3959 0
 6317 37e0 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 6318 37e4 030051E3 		cmp	r1, #3
 6319 37e8 0400000A 		beq	.L586
 6320              	.L538:
3965:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6321              		.loc 1 3965 0
 6322 37ec 1A00A0E3 		mov	r0, #26
 6323 37f0 D8149FE5 		ldr	r1, .L587+92
 6324 37f4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6325 37f8 28309DE5 		ldr	r3, [sp, #40]
 6326 37fc 01FEFFEA 		b	.L460
 6327              	.L586:
3961:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6328              		.loc 1 3961 0
 6329 3800 1A00A0E3 		mov	r0, #26
 6330 3804 C8149FE5 		ldr	r1, .L587+96
 6331 3808 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6332 380c 28309DE5 		ldr	r3, [sp, #40]
 6333 3810 FCFDFFEA 		b	.L460
 6334              	.LVL560:
 6335              	.L438:
 6336              	.LBE111:
 6337              	.LBE151:
 6338              	.LBB152:
 6339              	.LBB122:
3573:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 6340              		.loc 1 3573 0
 6341 3814 1200A0E3 		mov	r0, #18
 6342 3818 FEFFFFEB 		bl	ControlHandle
 6343              	.LVL561:
 6344 381c 28309DE5 		ldr	r3, [sp, #40]
 6345 3820 EEFDFFEA 		b	.L396
 6346              	.L437:
 6347              	.LVL562:
3569:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 6348              		.loc 1 3569 0
 6349 3824 1100A0E3 		mov	r0, #17
 6350 3828 FEFFFFEB 		bl	ControlHandle
 6351              	.LVL563:
 6352 382c 28309DE5 		ldr	r3, [sp, #40]
 6353 3830 EAFDFFEA 		b	.L396
 6354              	.LVL564:
 6355              	.L490:
 6356              	.LBE122:
 6357              	.LBE152:
 6358              	.LBB153:
 6359              	.LBB116:
3774:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6360              		.loc 1 3774 0
 6361 3834 58C094E5 		ldr	ip, [r4, #88]
 6362 3838 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 6363              	.LVL565:
 6364 383c 00005CE3 		cmp	ip, #0
 6365 3840 F4C0A003 		moveq	ip, #244
 6366 3844 74C0A013 		movne	ip, #116
 6367 3848 00208CE1 		orr	r2, ip, r0
 6368 384c 3010A0E3 		mov	r1, #48
 6369 3850 5230A0E3 		mov	r3, #82
 6370 3854 0100A0E3 		mov	r0, #1
 6371 3858 FEFFFFEB 		bl	SensorSetIrisControl
3775:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6372              		.loc 1 3775 0
 6373 385c 7D0FA0E3 		mov	r0, #500
 6374 3860 FEFFFFEB 		bl	_tx_thread_sleep
3776:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6375              		.loc 1 3776 0
 6376 3864 582094E5 		ldr	r2, [r4, #88]
 6377 3868 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6378 386c 000052E3 		cmp	r2, #0
 6379 3870 F420A003 		moveq	r2, #244
 6380 3874 7420A013 		movne	r2, #116
 6381 3878 583094E5 		ldr	r3, [r4, #88]
 6382 387c 0400A0E3 		mov	r0, #4
 6383 3880 50149FE5 		ldr	r1, .L587+100
 6384 3884 092082E1 		orr	r2, r2, r9
 6385 3888 FEFFFFEB 		bl	CyU3PDebugPrint
 6386              	.L486:
3781:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6387              		.loc 1 3781 0
 6388 388c C3E0D4E5 		ldrb	lr, [r4, #195]	@ zero_extendqisi2
3782:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6389              		.loc 1 3782 0
 6390 3890 44149FE5 		ldr	r1, .L587+104
 6391 3894 0E20A0E1 		mov	r2, lr
 6392 3898 0400A0E3 		mov	r0, #4
3781:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6393              		.loc 1 3781 0
 6394 389c BDE0C4E5 		strb	lr, [r4, #189]
3782:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6395              		.loc 1 3782 0
 6396 38a0 FEFFFFEB 		bl	CyU3PDebugPrint
3795:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6397              		.loc 1 3795 0
 6398 38a4 0020A0E3 		mov	r2, #0
 6399 38a8 C4039FE5 		ldr	r0, .L587
 6400 38ac 0110A0E3 		mov	r1, #1
 6401 38b0 FEFFFFEB 		bl	_txe_event_flags_set
 6402              	.LVL566:
3796:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6403              		.loc 1 3796 0
 6404 38b4 002050E2 		subs	r2, r0, #0
 6405 38b8 D1FDFF0A 		beq	.L566
3798:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6406              		.loc 1 3798 0
 6407 38bc 0400A0E3 		mov	r0, #4
 6408              	.LVL567:
 6409 38c0 18149FE5 		ldr	r1, .L587+108
 6410 38c4 FEFFFFEB 		bl	CyU3PDebugPrint
 6411              	.LVL568:
 6412 38c8 28309DE5 		ldr	r3, [sp, #40]
 6413 38cc CDFDFFEA 		b	.L460
 6414              	.LVL569:
 6415              	.L489:
3769:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6416              		.loc 1 3769 0
 6417 38d0 58E094E5 		ldr	lr, [r4, #88]
 6418 38d4 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6419 38d8 00005EE3 		cmp	lr, #0
 6420 38dc C4E0A003 		moveq	lr, #196
 6421 38e0 44E0A013 		movne	lr, #68
 6422 38e4 03208EE1 		orr	r2, lr, r3
 6423 38e8 3010A0E3 		mov	r1, #48
 6424 38ec 5230A0E3 		mov	r3, #82
 6425 38f0 0100A0E3 		mov	r0, #1
 6426              	.LVL570:
 6427 38f4 FEFFFFEB 		bl	SensorSetIrisControl
3770:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6428              		.loc 1 3770 0
 6429 38f8 7D0FA0E3 		mov	r0, #500
 6430 38fc FEFFFFEB 		bl	_tx_thread_sleep
3771:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6431              		.loc 1 3771 0
 6432 3900 580094E5 		ldr	r0, [r4, #88]
 6433 3904 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6434 3908 000050E3 		cmp	r0, #0
 6435 390c C400A003 		moveq	r0, #196
 6436 3910 4400A013 		movne	r0, #68
 6437 3914 0C2080E1 		orr	r2, r0, ip
 6438 3918 583094E5 		ldr	r3, [r4, #88]
 6439 391c B4139FE5 		ldr	r1, .L587+100
 6440 3920 0400A0E3 		mov	r0, #4
 6441 3924 FEFFFFEB 		bl	CyU3PDebugPrint
 6442 3928 D7FFFFEA 		b	.L486
 6443              	.LVL571:
 6444              	.L487:
3759:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6445              		.loc 1 3759 0
 6446 392c 582094E5 		ldr	r2, [r4, #88]
 6447 3930 3010A0E3 		mov	r1, #48
 6448 3934 000052E3 		cmp	r2, #0
 6449 3938 E420A003 		moveq	r2, #228
 6450 393c 6420A013 		movne	r2, #100
 6451 3940 5230A0E3 		mov	r3, #82
 6452 3944 0100A0E3 		mov	r0, #1
 6453              	.LVL572:
 6454 3948 FEFFFFEB 		bl	SensorSetIrisControl
3760:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6455              		.loc 1 3760 0
 6456 394c 7D0FA0E3 		mov	r0, #500
 6457 3950 FEFFFFEB 		bl	_tx_thread_sleep
3761:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6458              		.loc 1 3761 0
 6459 3954 582094E5 		ldr	r2, [r4, #88]
 6460 3958 78139FE5 		ldr	r1, .L587+100
 6461 395c 000052E3 		cmp	r2, #0
 6462 3960 583094E5 		ldr	r3, [r4, #88]
 6463 3964 E420A003 		moveq	r2, #228
 6464 3968 6420A013 		movne	r2, #100
 6465 396c 0400A0E3 		mov	r0, #4
 6466 3970 FEFFFFEB 		bl	CyU3PDebugPrint
 6467 3974 C4FFFFEA 		b	.L486
 6468              	.LVL573:
 6469              	.L488:
3764:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6470              		.loc 1 3764 0
 6471 3978 582094E5 		ldr	r2, [r4, #88]
 6472 397c 3010A0E3 		mov	r1, #48
 6473 3980 000052E3 		cmp	r2, #0
 6474 3984 D420A003 		moveq	r2, #212
 6475 3988 5420A013 		movne	r2, #84
 6476 398c 5230A0E3 		mov	r3, #82
 6477 3990 0100A0E3 		mov	r0, #1
 6478              	.LVL574:
 6479 3994 FEFFFFEB 		bl	SensorSetIrisControl
3765:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6480              		.loc 1 3765 0
 6481 3998 7D0FA0E3 		mov	r0, #500
 6482 399c FEFFFFEB 		bl	_tx_thread_sleep
3766:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6483              		.loc 1 3766 0
 6484 39a0 582094E5 		ldr	r2, [r4, #88]
 6485 39a4 2C139FE5 		ldr	r1, .L587+100
 6486 39a8 000052E3 		cmp	r2, #0
 6487 39ac 583094E5 		ldr	r3, [r4, #88]
 6488 39b0 D420A003 		moveq	r2, #212
 6489 39b4 5420A013 		movne	r2, #84
 6490 39b8 0400A0E3 		mov	r0, #4
 6491 39bc FEFFFFEB 		bl	CyU3PDebugPrint
 6492 39c0 B1FFFFEA 		b	.L486
 6493              	.L449:
 6494              	.LVL575:
 6495              	.LBE116:
 6496              	.LBE153:
 6497              	.LBB154:
 6498              	.LBB129:
3626:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 6499              		.loc 1 3626 0
 6500 39c4 1E00A0E3 		mov	r0, #30
 6501 39c8 FEFFFFEB 		bl	ControlHandle
 6502              	.LVL576:
 6503 39cc 28309DE5 		ldr	r3, [sp, #40]
 6504 39d0 82FDFFEA 		b	.L396
 6505              	.L424:
 6506              	.LVL577:
 6507              	.LBE129:
 6508              	.LBE154:
 6509              	.LBB155:
 6510              	.LBB106:
3366:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 6511              		.loc 1 3366 0
 6512 39d4 0600A0E3 		mov	r0, #6
 6513 39d8 FEFFFFEB 		bl	CTControlHandle
 6514              	.LVL578:
 6515 39dc 28309DE5 		ldr	r3, [sp, #40]
 6516 39e0 7EFDFFEA 		b	.L396
 6517              	.L425:
 6518              	.LVL579:
3372:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 6519              		.loc 1 3372 0
 6520 39e4 0700A0E3 		mov	r0, #7
 6521 39e8 FEFFFFEB 		bl	CTControlHandle
 6522              	.LVL580:
 6523 39ec 28309DE5 		ldr	r3, [sp, #40]
 6524 39f0 7AFDFFEA 		b	.L396
 6525              	.L406:
 6526              	.LVL581:
 6527              	.LBE106:
 6528              	.LBE155:
 6529              	.LBB156:
 6530              	.LBB91:
3273:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 6531              		.loc 1 3273 0
 6532 39f4 0200A0E3 		mov	r0, #2
 6533 39f8 FEFFFFEB 		bl	ControlHandle
 6534              	.LVL582:
 6535 39fc 28309DE5 		ldr	r3, [sp, #40]
 6536 3a00 76FDFFEA 		b	.L396
 6537              	.L408:
 6538              	.LVL583:
3284:../uvc.c      ****      		ControlHandle(HueCtlID5);
 6539              		.loc 1 3284 0
 6540 3a04 0500A0E3 		mov	r0, #5
 6541 3a08 FEFFFFEB 		bl	ControlHandle
 6542              	.LVL584:
 6543 3a0c 28309DE5 		ldr	r3, [sp, #40]
 6544 3a10 72FDFFEA 		b	.L396
 6545              	.L439:
 6546              	.LVL585:
 6547              	.LBE91:
 6548              	.LBE156:
 6549              	.LBB157:
 6550              	.LBB121:
3577:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6551              		.loc 1 3577 0
 6552 3a14 1300A0E3 		mov	r0, #19
 6553 3a18 FEFFFFEB 		bl	ControlHandle
 6554              	.LVL586:
 6555 3a1c 28309DE5 		ldr	r3, [sp, #40]
 6556 3a20 6EFDFFEA 		b	.L396
 6557              	.L444:
 6558              	.LVL587:
3597:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6559              		.loc 1 3597 0
 6560 3a24 1800A0E3 		mov	r0, #24
 6561 3a28 FEFFFFEB 		bl	ControlHandle
 6562              	.LVL588:
 6563 3a2c 28309DE5 		ldr	r3, [sp, #40]
 6564 3a30 6AFDFFEA 		b	.L396
 6565              	.L418:
 6566              	.LVL589:
 6567              	.LBE121:
 6568              	.LBE157:
 6569              	.LBB158:
 6570              	.LBB100:
3340:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6571              		.loc 1 3340 0
 6572 3a34 0000A0E3 		mov	r0, #0
 6573 3a38 FEFFFFEB 		bl	CTControlHandle
 6574              	.LVL590:
 6575 3a3c 28309DE5 		ldr	r3, [sp, #40]
 6576 3a40 66FDFFEA 		b	.L396
 6577              	.L420:
 6578              	.LVL591:
3348:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6579              		.loc 1 3348 0
 6580 3a44 0200A0E3 		mov	r0, #2
 6581 3a48 FEFFFFEB 		bl	CTControlHandle
 6582              	.LVL592:
 6583 3a4c 28309DE5 		ldr	r3, [sp, #40]
 6584 3a50 62FDFFEA 		b	.L396
 6585              	.L452:
 6586              	.LVL593:
 6587              	.LBE100:
 6588              	.LBE158:
 6589              	.LBB159:
 6590              	.LBB130:
3638:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6591              		.loc 1 3638 0
 6592 3a54 2500A0E3 		mov	r0, #37
 6593 3a58 FEFFFFEB 		bl	ControlHandle
 6594              	.LVL594:
 6595 3a5c 28309DE5 		ldr	r3, [sp, #40]
 6596 3a60 5EFDFFEA 		b	.L396
 6597              	.LVL595:
 6598              	.L535:
 6599              	.LBE130:
 6600              	.LBE159:
 6601              	.LBB160:
 6602              	.LBB110:
3956:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6603              		.loc 1 3956 0
 6604 3a64 0200A0E3 		mov	r0, #2
 6605 3a68 44129FE5 		ldr	r1, .L587+64
 6606 3a6c 97FEFFEA 		b	.L567
 6607              	.LVL596:
 6608              	.L413:
 6609              	.LBE110:
 6610              	.LBE160:
 6611              	.LBB161:
 6612              	.LBB97:
3306:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6613              		.loc 1 3306 0
 6614 3a70 0E00A0E3 		mov	r0, #14
 6615 3a74 FEFFFFEB 		bl	ControlHandle
 6616              	.LVL597:
 6617 3a78 28309DE5 		ldr	r3, [sp, #40]
 6618 3a7c 57FDFFEA 		b	.L396
 6619              	.L578:
 6620              	.LVL598:
3269:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6621              		.loc 1 3269 0
 6622 3a80 0100A0E3 		mov	r0, #1
 6623 3a84 FEFFFFEB 		bl	ControlHandle
 6624              	.LVL599:
 6625 3a88 28309DE5 		ldr	r3, [sp, #40]
 6626 3a8c 53FDFFEA 		b	.L396
 6627              	.L404:
 6628              	.LVL600:
3265:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6629              		.loc 1 3265 0
 6630 3a90 0000A0E3 		mov	r0, #0
 6631 3a94 FEFFFFEB 		bl	ControlHandle
 6632              	.LVL601:
 6633 3a98 28309DE5 		ldr	r3, [sp, #40]
 6634 3a9c 4FFDFFEA 		b	.L396
 6635              	.L423:
 6636              	.LVL602:
 6637              	.LBE97:
 6638              	.LBE161:
 6639              	.LBB162:
 6640              	.LBB107:
3362:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6641              		.loc 1 3362 0
 6642 3aa0 0500A0E3 		mov	r0, #5
 6643 3aa4 FEFFFFEB 		bl	CTControlHandle
 6644              	.LVL603:
 6645 3aa8 28309DE5 		ldr	r3, [sp, #40]
 6646 3aac 4BFDFFEA 		b	.L396
 6647              	.LVL604:
 6648              	.L522:
 6649              	.LBE107:
 6650              	.LBE162:
 6651              	.LBB163:
 6652              	.LBB117:
3910:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6653              		.loc 1 3910 0
 6654 3ab0 582094E5 		ldr	r2, [r4, #88]
 6655 3ab4 3010A0E3 		mov	r1, #48
 6656 3ab8 000052E3 		cmp	r2, #0
 6657 3abc E420A003 		moveq	r2, #228
 6658 3ac0 6420A013 		movne	r2, #100
 6659 3ac4 5230A0E3 		mov	r3, #82
 6660 3ac8 0100A0E3 		mov	r0, #1
 6661              	.LVL605:
 6662 3acc FEFFFFEB 		bl	SensorSetIrisControl
3912:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6663              		.loc 1 3912 0
 6664 3ad0 582094E5 		ldr	r2, [r4, #88]
 6665 3ad4 08129FE5 		ldr	r1, .L587+112
 6666 3ad8 000052E3 		cmp	r2, #0
 6667 3adc 583094E5 		ldr	r3, [r4, #88]
 6668 3ae0 E420A003 		moveq	r2, #228
 6669 3ae4 6420A013 		movne	r2, #100
 6670 3ae8 0400A0E3 		mov	r0, #4
 6671 3aec FEFFFFEB 		bl	CyU3PDebugPrint
 6672              	.L518:
3932:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6673              		.loc 1 3932 0
 6674 3af0 C1E0D4E5 		ldrb	lr, [r4, #193]	@ zero_extendqisi2
3934:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6675              		.loc 1 3934 0
 6676 3af4 C030D4E5 		ldrb	r3, [r4, #192]	@ zero_extendqisi2
 6677 3af8 BE22DDE1 		ldrh	r2, [sp, #46]
 6678              	.LVL606:
 6679 3afc 0400A0E3 		mov	r0, #4
 6680 3b00 E0119FE5 		ldr	r1, .L587+116
3932:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6681              		.loc 1 3932 0
 6682 3b04 E0E0C4E5 		strb	lr, [r4, #224]
3934:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6683              		.loc 1 3934 0
 6684 3b08 00E08DE5 		str	lr, [sp, #0]
 6685 3b0c FEFFFFEB 		bl	CyU3PDebugPrint
 6686 3b10 28309DE5 		ldr	r3, [sp, #40]
 6687 3b14 3BFDFFEA 		b	.L460
 6688              	.LVL607:
 6689              	.L521:
3915:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6690              		.loc 1 3915 0
 6691 3b18 582094E5 		ldr	r2, [r4, #88]
 6692 3b1c 3010A0E3 		mov	r1, #48
 6693 3b20 000052E3 		cmp	r2, #0
 6694 3b24 D420A003 		moveq	r2, #212
 6695 3b28 5420A013 		movne	r2, #84
 6696 3b2c 5230A0E3 		mov	r3, #82
 6697 3b30 0100A0E3 		mov	r0, #1
 6698              	.LVL608:
 6699 3b34 FEFFFFEB 		bl	SensorSetIrisControl
3917:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6700              		.loc 1 3917 0
 6701 3b38 582094E5 		ldr	r2, [r4, #88]
 6702 3b3c A0119FE5 		ldr	r1, .L587+112
 6703 3b40 000052E3 		cmp	r2, #0
 6704 3b44 583094E5 		ldr	r3, [r4, #88]
 6705 3b48 D420A003 		moveq	r2, #212
 6706 3b4c 5420A013 		movne	r2, #84
 6707 3b50 0400A0E3 		mov	r0, #4
 6708 3b54 FEFFFFEB 		bl	CyU3PDebugPrint
 6709 3b58 E4FFFFEA 		b	.L518
 6710              	.LVL609:
 6711              	.L519:
3925:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6712              		.loc 1 3925 0
 6713 3b5c 580094E5 		ldr	r0, [r4, #88]
 6714              	.LVL610:
 6715 3b60 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6716 3b64 000050E3 		cmp	r0, #0
 6717 3b68 F400A003 		moveq	r0, #244
 6718 3b6c 7400A013 		movne	r0, #116
 6719 3b70 032080E1 		orr	r2, r0, r3
 6720 3b74 3010A0E3 		mov	r1, #48
 6721 3b78 5230A0E3 		mov	r3, #82
 6722 3b7c 0100A0E3 		mov	r0, #1
 6723 3b80 FEFFFFEB 		bl	SensorSetIrisControl
3927:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6724              		.loc 1 3927 0
 6725 3b84 58C094E5 		ldr	ip, [r4, #88]
 6726 3b88 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6727 3b8c 00005CE3 		cmp	ip, #0
 6728 3b90 F4C0A003 		moveq	ip, #244
 6729 3b94 74C0A013 		movne	ip, #116
 6730 3b98 583094E5 		ldr	r3, [r4, #88]
 6731 3b9c 40119FE5 		ldr	r1, .L587+112
 6732 3ba0 02208CE1 		orr	r2, ip, r2
 6733 3ba4 0400A0E3 		mov	r0, #4
 6734 3ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 6735 3bac CFFFFFEA 		b	.L518
 6736              	.LVL611:
 6737              	.L520:
3920:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6738              		.loc 1 3920 0
 6739 3bb0 58E094E5 		ldr	lr, [r4, #88]
 6740 3bb4 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6741 3bb8 00005EE3 		cmp	lr, #0
 6742 3bbc C4E0A003 		moveq	lr, #196
 6743 3bc0 44E0A013 		movne	lr, #68
 6744 3bc4 09208EE1 		orr	r2, lr, r9
 6745 3bc8 3010A0E3 		mov	r1, #48
 6746 3bcc 5230A0E3 		mov	r3, #82
 6747 3bd0 0100A0E3 		mov	r0, #1
 6748              	.LVL612:
 6749 3bd4 FEFFFFEB 		bl	SensorSetIrisControl
3922:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6750              		.loc 1 3922 0
 6751 3bd8 580094E5 		ldr	r0, [r4, #88]
 6752 3bdc 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6753 3be0 000050E3 		cmp	r0, #0
 6754 3be4 C400A003 		moveq	r0, #196
 6755 3be8 4400A013 		movne	r0, #68
 6756 3bec 0C2080E1 		orr	r2, r0, ip
 6757 3bf0 583094E5 		ldr	r3, [r4, #88]
 6758 3bf4 E8109FE5 		ldr	r1, .L587+112
 6759 3bf8 0400A0E3 		mov	r0, #4
 6760 3bfc FEFFFFEB 		bl	CyU3PDebugPrint
 6761 3c00 BAFFFFEA 		b	.L518
 6762              	.L421:
 6763              	.LVL613:
 6764              	.LBE117:
 6765              	.LBE163:
 6766              	.LBB164:
 6767              	.LBB99:
3353:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 6768              		.loc 1 3353 0
 6769 3c04 0300A0E3 		mov	r0, #3
 6770 3c08 FEFFFFEB 		bl	CTControlHandle
 6771              	.LVL614:
 6772 3c0c 28309DE5 		ldr	r3, [sp, #40]
 6773 3c10 F2FCFFEA 		b	.L396
 6774              	.L442:
 6775              	.LVL615:
 6776              	.LBE99:
 6777              	.LBE164:
 6778              	.LBB165:
 6779              	.LBB120:
3589:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 6780              		.loc 1 3589 0
 6781 3c14 1600A0E3 		mov	r0, #22
 6782 3c18 FEFFFFEB 		bl	ControlHandle
 6783              	.LVL616:
 6784 3c1c 28309DE5 		ldr	r3, [sp, #40]
 6785 3c20 EEFCFFEA 		b	.L396
 6786              	.L428:
 6787              	.LVL617:
 6788              	.LBE120:
 6789              	.LBE165:
 6790              	.LBB166:
 6791              	.LBB108:
3385:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 6792              		.loc 1 3385 0
 6793 3c24 0A00A0E3 		mov	r0, #10
 6794 3c28 FEFFFFEB 		bl	CTControlHandle
 6795              	.LVL618:
 6796 3c2c 28309DE5 		ldr	r3, [sp, #40]
 6797 3c30 EAFCFFEA 		b	.L396
 6798              	.L427:
 6799              	.LVL619:
3381:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 6800              		.loc 1 3381 0
 6801 3c34 0900A0E3 		mov	r0, #9
 6802 3c38 FEFFFFEB 		bl	CTControlHandle
 6803              	.LVL620:
 6804 3c3c 28309DE5 		ldr	r3, [sp, #40]
 6805 3c40 E6FCFFEA 		b	.L396
 6806              	.L441:
 6807              	.LVL621:
 6808              	.LBE108:
 6809              	.LBE166:
 6810              	.LBB167:
 6811              	.LBB131:
3585:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 6812              		.loc 1 3585 0
 6813 3c44 1500A0E3 		mov	r0, #21
 6814 3c48 FEFFFFEB 		bl	ControlHandle
 6815              	.LVL622:
 6816 3c4c 28309DE5 		ldr	r3, [sp, #40]
 6817 3c50 E2FCFFEA 		b	.L396
 6818              	.L451:
 6819              	.LVL623:
3634:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 6820              		.loc 1 3634 0
 6821 3c54 2400A0E3 		mov	r0, #36
 6822 3c58 FEFFFFEB 		bl	ControlHandle
 6823              	.LVL624:
 6824 3c5c 28309DE5 		ldr	r3, [sp, #40]
 6825 3c60 DEFCFFEA 		b	.L396
 6826              	.L447:
 6827              	.LVL625:
3612:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6828              		.loc 1 3612 0
 6829 3c64 1B00A0E3 		mov	r0, #27
 6830 3c68 FEFFFFEB 		bl	ControlHandle
 6831              	.LVL626:
 6832 3c6c 28309DE5 		ldr	r3, [sp, #40]
 6833 3c70 DAFCFFEA 		b	.L396
 6834              	.L588:
 6835              		.align	2
 6836              	.L587:
 6837 3c74 00000000 		.word	.LANCHOR0
 6838 3c78 00000000 		.word	.LANCHOR1
 6839 3c7c 00000000 		.word	bRequest
 6840 3c80 00000000 		.word	wValue
 6841 3c84 00000000 		.word	wIndex
 6842 3c88 00000000 		.word	glInterStaBuffer
 6843 3c8c 34060000 		.word	.LC34
 6844 3c90 00000000 		.word	glChHandleInterStat
 6845 3c94 00000000 		.word	bmReqType
 6846 3c98 00000000 		.word	wLength
 6847 3c9c B8050000 		.word	.LC33
 6848 3ca0 C0000000 		.word	.LANCHOR0+192
 6849 3ca4 74070000 		.word	.LC42
 6850 3ca8 98070000 		.word	.LC43
 6851 3cac A0060000 		.word	.LANCHOR1+1696
 6852 3cb0 60060000 		.word	.LC35
 6853 3cb4 5C000000 		.word	.LANCHOR0+92
 6854 3cb8 F4060000 		.word	.LANCHOR1+1780
 6855 3cbc 00070000 		.word	.LANCHOR1+1792
 6856 3cc0 FC060000 		.word	.LC39
 6857 3cc4 EC070000 		.word	.LC45
 6858 3cc8 F0010000 		.word	.LC13
 6859 3ccc C4070000 		.word	.LC44
 6860 3cd0 BC060000 		.word	.LANCHOR1+1724
 6861 3cd4 D8060000 		.word	.LANCHOR1+1752
 6862 3cd8 88060000 		.word	.LC36
 6863 3cdc AC060000 		.word	.LC37
 6864 3ce0 D4060000 		.word	.LC38
 6865 3ce4 28070000 		.word	.LC40
 6866 3ce8 4C070000 		.word	.LC41
 6867              	.LBE131:
 6868              	.LBE167:
 6869              		.cfi_endproc
 6870              	.LFE25:
 6872              		.align	2
 6873              		.global	CamDefSet
 6875              	CamDefSet:
 6876              	.LFB5:
1863:../uvc.c      **** {
 6877              		.loc 1 1863 0
 6878              		.cfi_startproc
 6879              		@ args = 0, pretend = 0, frame = 24
 6880              		@ frame_needed = 0, uses_anonymous_args = 0
 6881              	.LVL627:
 6882 3cec F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6883              	.LCFI22:
 6884              		.cfi_def_cfa_offset 36
1870:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6885              		.loc 1 1870 0
 6886 3cf0 B0429FE5 		ldr	r4, .L592
 6887              		.cfi_offset 14, -4
 6888              		.cfi_offset 11, -8
 6889              		.cfi_offset 10, -12
 6890              		.cfi_offset 9, -16
 6891              		.cfi_offset 8, -20
 6892              		.cfi_offset 7, -24
 6893              		.cfi_offset 6, -28
 6894              		.cfi_offset 5, -32
 6895              		.cfi_offset 4, -36
1875:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6896              		.loc 1 1875 0
 6897 3cf4 B0229FE5 		ldr	r2, .L592+4
1872:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6898              		.loc 1 1872 0
 6899 3cf8 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1863:../uvc.c      **** {
 6900              		.loc 1 1863 0
 6901 3cfc 2CD04DE2 		sub	sp, sp, #44
 6902              	.LCFI23:
 6903              		.cfi_def_cfa_offset 80
1875:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6904              		.loc 1 1875 0
 6905 3d00 1C0092E5 		ldr	r0, [r2, #28]
 6906 3d04 0010E0E3 		mvn	r1, #0
1877:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6907              		.loc 1 1877 0
 6908 3d08 2963A0E1 		mov	r6, r9, lsr #6
1871:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6909              		.loc 1 1871 0
 6910 3d0c A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1870:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6911              		.loc 1 1870 0
 6912 3d10 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 6913              	.LVL628:
1875:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6914              		.loc 1 1875 0
 6915 3d14 FEFFFFEB 		bl	_txe_mutex_get
1876:../uvc.c      ****     if(Data1&0x80){
 6916              		.loc 1 1876 0
 6917 3d18 800019E3 		tst	r9, #128
1877:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6918              		.loc 1 1877 0
 6919 3d1c 01600612 		andne	r6, r6, #1
 6920 3d20 0660E011 		mvnne	r6, r6
 6921 3d24 3B600612 		andne	r6, r6, #59
 6922 3d28 0660E011 		mvnne	r6, r6
 6923 3d2c FF600612 		andne	r6, r6, #255
 6924              	.LVL629:
1879:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 6925              		.loc 1 1879 0
 6926 3d30 C6608603 		orreq	r6, r6, #198
 6927              	.LVL630:
1883:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6928              		.loc 1 1883 0
 6929 3d34 0080A0E3 		mov	r8, #0
 6930 3d38 0A20A0E1 		mov	r2, sl
 6931 3d3c 0730A0E1 		mov	r3, r7
 6932 3d40 0110A0E3 		mov	r1, #1
1881:../uvc.c      ****     Data0 = (Data0 << 2);
 6933              		.loc 1 1881 0
 6934 3d44 0951A0E1 		mov	r5, r9, asl #2
1883:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6935              		.loc 1 1883 0
 6936 3d48 5C029FE5 		ldr	r0, .L592+4
1886:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6937              		.loc 1 1886 0
 6938 3d4c 0190A0E3 		mov	r9, #1
 6939              	.LVL631:
1881:../uvc.c      ****     Data0 = (Data0 << 2);
 6940              		.loc 1 1881 0
 6941 3d50 FF5005E2 		and	r5, r5, #255
 6942              	.LVL632:
1883:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6943              		.loc 1 1883 0
 6944 3d54 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6945 3d58 FEFFFFEB 		bl	cmdSet
 6946              	.LVL633:
1886:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6947              		.loc 1 1886 0
 6948 3d5c 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6949 3d60 0910A0E1 		mov	r1, r9
 6950 3d64 0730A0E1 		mov	r3, r7
 6951 3d68 3C029FE5 		ldr	r0, .L592+4
 6952 3d6c 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 6953 3d70 FEFFFFEB 		bl	cmdSet
 6954              	.LVL634:
1889:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6955              		.loc 1 1889 0
 6956 3d74 0620A0E1 		mov	r2, r6
 6957 3d78 0530A0E1 		mov	r3, r5
 6958 3d7c 2C129FE5 		ldr	r1, .L592+8
 6959 3d80 0400A0E3 		mov	r0, #4
1888:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6960              		.loc 1 1888 0
 6961 3d84 A661C4E5 		strb	r6, [r4, #422]
1887:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6962              		.loc 1 1887 0
 6963 3d88 A551C4E5 		strb	r5, [r4, #421]
1889:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6964              		.loc 1 1889 0
 6965 3d8c FEFFFFEB 		bl	CyU3PDebugPrint
 6966              	.LVL635:
1894:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6967              		.loc 1 1894 0
 6968 3d90 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 6969              	.LVL636:
1895:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6970              		.loc 1 1895 0
 6971 3d94 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6972 3d98 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6973 3d9c 0210A0E3 		mov	r1, #2
 6974 3da0 04029FE5 		ldr	r0, .L592+4
 6975 3da4 00B08DE5 		str	fp, [sp, #0]
 6976 3da8 04808DE5 		str	r8, [sp, #4]
 6977 3dac FEFFFFEB 		bl	cmdSet
 6978              	.LVL637:
1898:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6979              		.loc 1 1898 0
 6980 3db0 0B20A0E1 		mov	r2, fp
 6981 3db4 0530A0E1 		mov	r3, r5
 6982 3db8 F0119FE5 		ldr	r1, .L592+8
 6983 3dbc 0400A0E3 		mov	r0, #4
1896:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6984              		.loc 1 1896 0
 6985 3dc0 BD51C4E5 		strb	r5, [r4, #445]
1897:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 6986              		.loc 1 1897 0
 6987 3dc4 FD53C4E5 		strb	r5, [r4, #1021]
1898:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6988              		.loc 1 1898 0
 6989 3dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 6990              	.LVL638:
1903:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6991              		.loc 1 1903 0
 6992 3dcc 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1902:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6993              		.loc 1 1902 0
 6994 3dd0 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6995              	.LVL639:
1904:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6996              		.loc 1 1904 0
 6997 3dd4 80B047E2 		sub	fp, r7, #128
 6998 3dd8 FF100BE2 		and	r1, fp, #255
 6999 3ddc 14108DE5 		str	r1, [sp, #20]
 7000 3de0 14C09DE5 		ldr	ip, [sp, #20]
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7001              		.loc 1 1905 0
 7002 3de4 760047E2 		sub	r0, r7, #118
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7003              		.loc 1 1906 0
 7004 3de8 7EE087E2 		add	lr, r7, #126
1904:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7005              		.loc 1 1904 0
 7006 3dec 0630A0E1 		mov	r3, r6
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7007              		.loc 1 1905 0
 7008 3df0 18008DE5 		str	r0, [sp, #24]
1904:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7009              		.loc 1 1904 0
 7010 3df4 0510A0E3 		mov	r1, #5
 7011 3df8 DF20A0E3 		mov	r2, #223
 7012 3dfc A8019FE5 		ldr	r0, .L592+4
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7013              		.loc 1 1906 0
 7014 3e00 1CE08DE5 		str	lr, [sp, #28]
1904:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7015              		.loc 1 1904 0
 7016 3e04 00C08DE5 		str	ip, [sp, #0]
 7017 3e08 04808DE5 		str	r8, [sp, #4]
 7018 3e0c FEFFFFEB 		bl	cmdSet
 7019              	.LVL640:
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7020              		.loc 1 1905 0
 7021 3e10 18A09DE5 		ldr	sl, [sp, #24]
1907:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7022              		.loc 1 1907 0
 7023 3e14 72E087E2 		add	lr, r7, #114
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7024              		.loc 1 1905 0
 7025 3e18 FFC00AE2 		and	ip, sl, #255
 7026 3e1c 0630A0E1 		mov	r3, r6
 7027 3e20 0510A0E3 		mov	r1, #5
 7028 3e24 DC20A0E3 		mov	r2, #220
 7029 3e28 7C019FE5 		ldr	r0, .L592+4
1907:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7030              		.loc 1 1907 0
 7031 3e2c 20E08DE5 		str	lr, [sp, #32]
1905:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7032              		.loc 1 1905 0
 7033 3e30 00C08DE5 		str	ip, [sp, #0]
 7034 3e34 04908DE5 		str	r9, [sp, #4]
 7035 3e38 FEFFFFEB 		bl	cmdSet
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7036              		.loc 1 1906 0
 7037 3e3c 1C009DE5 		ldr	r0, [sp, #28]
 7038 3e40 02E0A0E3 		mov	lr, #2
 7039 3e44 FFC000E2 		and	ip, r0, #255
 7040 3e48 0630A0E1 		mov	r3, r6
1908:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7041              		.loc 1 1908 0
 7042 3e4c 6FA047E2 		sub	sl, r7, #111
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7043              		.loc 1 1906 0
 7044 3e50 0510A0E3 		mov	r1, #5
 7045 3e54 DE20A0E3 		mov	r2, #222
 7046 3e58 4C019FE5 		ldr	r0, .L592+4
 7047 3e5c 04E08DE5 		str	lr, [sp, #4]
1908:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7048              		.loc 1 1908 0
 7049 3e60 24A08DE5 		str	sl, [sp, #36]
1906:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7050              		.loc 1 1906 0
 7051 3e64 00C08DE5 		str	ip, [sp, #0]
 7052 3e68 FEFFFFEB 		bl	cmdSet
1907:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7053              		.loc 1 1907 0
 7054 3e6c 20A09DE5 		ldr	sl, [sp, #32]
 7055 3e70 0630A0E1 		mov	r3, r6
 7056 3e74 FFC00AE2 		and	ip, sl, #255
 7057 3e78 00C08DE5 		str	ip, [sp, #0]
 7058 3e7c 0510A0E3 		mov	r1, #5
 7059 3e80 03C0A0E3 		mov	ip, #3
 7060 3e84 E020A0E3 		mov	r2, #224
 7061 3e88 1C019FE5 		ldr	r0, .L592+4
 7062 3e8c 04C08DE5 		str	ip, [sp, #4]
 7063 3e90 FEFFFFEB 		bl	cmdSet
1908:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7064              		.loc 1 1908 0
 7065 3e94 24009DE5 		ldr	r0, [sp, #36]
 7066 3e98 04A0A0E3 		mov	sl, #4
 7067 3e9c FFC000E2 		and	ip, r0, #255
 7068 3ea0 0630A0E1 		mov	r3, r6
 7069 3ea4 0510A0E3 		mov	r1, #5
 7070 3ea8 DD20A0E3 		mov	r2, #221
 7071 3eac F8009FE5 		ldr	r0, .L592+4
 7072 3eb0 00C08DE5 		str	ip, [sp, #0]
1909:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7073              		.loc 1 1909 0
 7074 3eb4 7F7087E2 		add	r7, r7, #127
 7075              	.LVL641:
1908:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7076              		.loc 1 1908 0
 7077 3eb8 04A08DE5 		str	sl, [sp, #4]
 7078 3ebc FEFFFFEB 		bl	cmdSet
1909:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7079              		.loc 1 1909 0
 7080 3ec0 05E0A0E3 		mov	lr, #5
 7081 3ec4 0E10A0E1 		mov	r1, lr
 7082 3ec8 0630A0E1 		mov	r3, r6
 7083 3ecc E120A0E3 		mov	r2, #225
 7084 3ed0 FF6007E2 		and	r6, r7, #255
 7085              	.LVL642:
 7086 3ed4 D0009FE5 		ldr	r0, .L592+4
 7087 3ed8 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7088 3edc FEFFFFEB 		bl	cmdSet
 7089              	.LVL643:
1910:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7090              		.loc 1 1910 0
 7091 3ee0 14C09DE5 		ldr	ip, [sp, #20]
1911:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7092              		.loc 1 1911 0
 7093 3ee4 24E09DE5 		ldr	lr, [sp, #36]
 7094 3ee8 1C609DE5 		ldr	r6, [sp, #28]
1910:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7095              		.loc 1 1910 0
 7096 3eec 05C2C4E5 		strb	ip, [r4, #517]
1911:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7097              		.loc 1 1911 0
 7098 3ef0 20C09DE5 		ldr	ip, [sp, #32]
 7099 3ef4 0B20A0E1 		mov	r2, fp
 7100 3ef8 18309DE5 		ldr	r3, [sp, #24]
 7101 3efc B0109FE5 		ldr	r1, .L592+12
 7102 3f00 0A00A0E1 		mov	r0, sl
 7103 3f04 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7104 3f08 0C708DE5 		str	r7, [sp, #12]
 7105 3f0c FEFFFFEB 		bl	CyU3PDebugPrint
 7106              	.LVL644:
1915:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7107              		.loc 1 1915 0
 7108 3f10 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7109              	.LVL645:
1916:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7110              		.loc 1 1916 0
 7111 3f14 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7112              	.LVL646:
1917:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7113              		.loc 1 1917 0
 7114 3f18 0730A0E1 		mov	r3, r7
 7115 3f1c 0610A0E3 		mov	r1, #6
 7116 3f20 8520A0E3 		mov	r2, #133
 7117 3f24 80009FE5 		ldr	r0, .L592+4
 7118 3f28 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7119 3f2c FEFFFFEB 		bl	cmdSet
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7120              		.loc 1 1918 0
 7121 3f30 0730A0E1 		mov	r3, r7
 7122 3f34 0610A0E3 		mov	r1, #6
 7123 3f38 8620A0E3 		mov	r2, #134
 7124 3f3c 68009FE5 		ldr	r0, .L592+4
 7125 3f40 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7126 3f44 FEFFFFEB 		bl	cmdSet
1920:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7127              		.loc 1 1920 0
 7128 3f48 0620A0E1 		mov	r2, r6
 7129 3f4c 0530A0E1 		mov	r3, r5
 7130 3f50 58109FE5 		ldr	r1, .L592+8
 7131 3f54 0A00A0E1 		mov	r0, sl
1919:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7132              		.loc 1 1919 0
 7133 3f58 1D62C4E5 		strb	r6, [r4, #541]
1920:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7134              		.loc 1 1920 0
 7135 3f5c FEFFFFEB 		bl	CyU3PDebugPrint
 7136              	.LVL647:
1925:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7137              		.loc 1 1925 0
 7138 3f60 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7139              	.LVL648:
1926:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7140              		.loc 1 1926 0
 7141 3f64 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7142 3f68 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7143 3f6c 0710A0E3 		mov	r1, #7
 7144 3f70 34009FE5 		ldr	r0, .L592+4
 7145 3f74 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7146 3f78 FEFFFFEB 		bl	cmdSet
 7147              	.LVL649:
1928:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7148              		.loc 1 1928 0
 7149 3f7c 0530A0E1 		mov	r3, r5
 7150 3f80 0A00A0E1 		mov	r0, sl
 7151 3f84 24109FE5 		ldr	r1, .L592+8
 7152 3f88 0620A0E1 		mov	r2, r6
1927:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7153              		.loc 1 1927 0
 7154 3f8c 3552C4E5 		strb	r5, [r4, #565]
1928:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7155              		.loc 1 1928 0
 7156 3f90 FEFFFFEB 		bl	CyU3PDebugPrint
1930:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7157              		.loc 1 1930 0
 7158 3f94 10309FE5 		ldr	r3, .L592+4
 7159 3f98 1C0093E5 		ldr	r0, [r3, #28]
1933:../uvc.c      **** }
 7160              		.loc 1 1933 0
 7161 3f9c 2CD08DE2 		add	sp, sp, #44
 7162 3fa0 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1930:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7163              		.loc 1 1930 0
 7164 3fa4 FEFFFFEA 		b	_txe_mutex_put
 7165              	.L593:
 7166              		.align	2
 7167              	.L592:
 7168 3fa8 00000000 		.word	.LANCHOR1
 7169 3fac 00000000 		.word	statQu
 7170 3fb0 20080000 		.word	.LC46
 7171 3fb4 40080000 		.word	.LC47
 7172              		.cfi_endproc
 7173              	.LFE5:
 7175              		.align	2
 7176              		.global	CyFxUVCAddHeader
 7178              	CyFxUVCAddHeader:
 7179              	.LFB6:
1941:../uvc.c      **** {
 7180              		.loc 1 1941 0
 7181              		.cfi_startproc
 7182              		@ args = 0, pretend = 0, frame = 0
 7183              		@ frame_needed = 0, uses_anonymous_args = 0
 7184              	.LVL650:
 7185 3fb8 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7186              	.LCFI24:
 7187              		.cfi_def_cfa_offset 16
1941:../uvc.c      **** {
 7188              		.loc 1 1941 0
 7189 3fbc 0040A0E1 		mov	r4, r0
 7190              		.cfi_offset 14, -4
 7191              		.cfi_offset 5, -8
 7192              		.cfi_offset 4, -12
 7193              		.cfi_offset 3, -16
 7194 3fc0 0150A0E1 		mov	r5, r1
1943:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7195              		.loc 1 1943 0
 7196 3fc4 30009FE5 		ldr	r0, .L596
 7197              	.LVL651:
 7198 3fc8 0010E0E3 		mvn	r1, #0
 7199              	.LVL652:
 7200 3fcc FEFFFFEB 		bl	_txe_mutex_get
1944:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7201              		.loc 1 1944 0
 7202 3fd0 0400A0E1 		mov	r0, r4
 7203 3fd4 24109FE5 		ldr	r1, .L596+4
 7204 3fd8 0C20A0E3 		mov	r2, #12
 7205 3fdc FEFFFFEB 		bl	CyU3PMemCopy
1945:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7206              		.loc 1 1945 0
 7207 3fe0 14009FE5 		ldr	r0, .L596
 7208 3fe4 FEFFFFEB 		bl	_txe_mutex_put
1948:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7209              		.loc 1 1948 0
 7210 3fe8 020015E3 		tst	r5, #2
1950:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7211              		.loc 1 1950 0
 7212 3fec 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7213 3ff0 02308313 		orrne	r3, r3, #2
 7214 3ff4 0130C415 		strneb	r3, [r4, #1]
 7215 3ff8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7216              	.L597:
 7217              		.align	2
 7218              	.L596:
 7219 3ffc 00000000 		.word	imgHdMux
 7220 4000 80040000 		.word	.LANCHOR1+1152
 7221              		.cfi_endproc
 7222              	.LFE6:
 7224              		.align	2
 7225              		.global	CyFxAppErrorHandler
 7227              	CyFxAppErrorHandler:
 7228              	.LFB7:
1960:../uvc.c      **** {
 7229              		.loc 1 1960 0
 7230              		.cfi_startproc
 7231              		@ args = 0, pretend = 0, frame = 0
 7232              		@ frame_needed = 0, uses_anonymous_args = 0
 7233              	.LVL653:
 7234 4004 08402DE9 		stmfd	sp!, {r3, lr}
 7235              	.LCFI25:
 7236              		.cfi_def_cfa_offset 8
 7237              	.LVL654:
 7238              	.L599:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7239              		.loc 1 1970 0 discriminator 1
 7240 4008 10109FE5 		ldr	r1, .L600
 7241 400c 0400A0E3 		mov	r0, #4
 7242              		.cfi_offset 14, -4
 7243              		.cfi_offset 3, -8
 7244 4010 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 7245              		.loc 1 1971 0 discriminator 1
 7246 4014 FA0FA0E3 		mov	r0, #1000
 7247 4018 FEFFFFEB 		bl	_tx_thread_sleep
 7248 401c F9FFFFEA 		b	.L599
 7249              	.L601:
 7250              		.align	2
 7251              	.L600:
 7252 4020 F0010000 		.word	.LC13
 7253              		.cfi_endproc
 7254              	.LFE7:
 7256              		.align	2
 7257              		.global	UVCAppThread_Entry
 7259              	UVCAppThread_Entry:
 7260              	.LFB19:
2947:../uvc.c      **** {
 7261              		.loc 1 2947 0
 7262              		.cfi_startproc
 7263              		@ args = 0, pretend = 0, frame = 176
 7264              		@ frame_needed = 0, uses_anonymous_args = 0
 7265              	.LVL655:
 7266 4024 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 7267              	.LCFI26:
 7268              		.cfi_def_cfa_offset 28
 7269 4028 BCD04DE2 		sub	sp, sp, #188
 7270              	.LCFI27:
 7271              		.cfi_def_cfa_offset 216
 7272              	.LBB220:
 7273              	.LBB221:
2403:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7274              		.loc 1 2403 0
 7275              		.cfi_offset 14, -4
 7276              		.cfi_offset 10, -8
 7277              		.cfi_offset 8, -12
 7278              		.cfi_offset 7, -16
 7279              		.cfi_offset 6, -20
 7280              		.cfi_offset 5, -24
 7281              		.cfi_offset 4, -28
 7282 402c FEFFFFEB 		bl	CyU3PUartInit
 7283              	.LVL656:
2404:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7284              		.loc 1 2404 0
 7285 4030 004050E2 		subs	r4, r0, #0
 7286 4034 0400000A 		beq	.L603
2406:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7287              		.loc 1 2406 0
 7288 4038 0400A0E3 		mov	r0, #4
 7289              	.LVL657:
 7290 403c F81B9FE5 		ldr	r1, .L719
 7291 4040 FEFFFFEB 		bl	CyU3PDebugPrint
2407:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7292              		.loc 1 2407 0
 7293 4044 0400A0E1 		mov	r0, r4
 7294 4048 FEFFFFEB 		bl	CyFxAppErrorHandler
 7295              	.L603:
2411:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7296              		.loc 1 2411 0
 7297 404c ECCB9FE5 		ldr	ip, .L719+4
2413:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7298              		.loc 1 2413 0
 7299 4050 0030A0E3 		mov	r3, #0
2412:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7300              		.loc 1 2412 0
 7301 4054 0120A0E3 		mov	r2, #1
2420:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7302              		.loc 1 2420 0
 7303 4058 50008DE2 		add	r0, sp, #80
 7304 405c 0310A0E1 		mov	r1, r3
2411:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7305              		.loc 1 2411 0
 7306 4060 60C08DE5 		str	ip, [sp, #96]
2412:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7307              		.loc 1 2412 0
 7308 4064 6420CDE5 		strb	r2, [sp, #100]
2413:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7309              		.loc 1 2413 0
 7310 4068 6530CDE5 		strb	r3, [sp, #101]
2414:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7311              		.loc 1 2414 0
 7312 406c 50208DE5 		str	r2, [sp, #80]
2415:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7313              		.loc 1 2415 0
 7314 4070 54308DE5 		str	r3, [sp, #84]
2416:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7315              		.loc 1 2416 0
 7316 4074 58308DE5 		str	r3, [sp, #88]
2417:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7317              		.loc 1 2417 0
 7318 4078 5C208DE5 		str	r2, [sp, #92]
2420:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7319              		.loc 1 2420 0
 7320 407c FEFFFFEB 		bl	CyU3PUartSetConfig
 7321              	.LVL658:
2421:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7322              		.loc 1 2421 0
 7323 4080 000050E3 		cmp	r0, #0
 7324 4084 0000000A 		beq	.L604
2423:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7325              		.loc 1 2423 0
 7326 4088 FEFFFFEB 		bl	CyFxAppErrorHandler
 7327              	.LVL659:
 7328              	.L604:
2427:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7329              		.loc 1 2427 0
 7330 408c 0000E0E3 		mvn	r0, #0
 7331 4090 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7332              	.LVL660:
2428:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7333              		.loc 1 2428 0
 7334 4094 000050E3 		cmp	r0, #0
 7335 4098 0000000A 		beq	.L605
2430:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7336              		.loc 1 2430 0
 7337 409c FEFFFFEB 		bl	CyFxAppErrorHandler
 7338              	.LVL661:
 7339              	.L605:
2434:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7340              		.loc 1 2434 0
 7341 40a0 0300A0E3 		mov	r0, #3
 7342 40a4 0410A0E3 		mov	r1, #4
 7343 40a8 FEFFFFEB 		bl	CyU3PDebugInit
 7344              	.LVL662:
2435:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7345              		.loc 1 2435 0
 7346 40ac 000050E3 		cmp	r0, #0
 7347 40b0 0000000A 		beq	.L606
2437:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7348              		.loc 1 2437 0
 7349 40b4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7350              	.LVL663:
 7351              	.L606:
2441:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7352              		.loc 1 2441 0
 7353 40b8 0000A0E3 		mov	r0, #0
 7354 40bc FEFFFFEB 		bl	CyU3PDebugPreamble
 7355              	.LVL664:
 7356              	.LBE221:
 7357              	.LBE220:
2963:../uvc.c      **** 		CyU3PThreadSleep(500);
 7358              		.loc 1 2963 0
 7359 40c0 7D0FA0E3 		mov	r0, #500
 7360 40c4 FEFFFFEB 		bl	_tx_thread_sleep
 7361              	.LVL665:
 7362 40c8 7D0FA0E3 		mov	r0, #500
 7363 40cc FEFFFFEB 		bl	_tx_thread_sleep
 7364 40d0 7D0FA0E3 		mov	r0, #500
 7365 40d4 FEFFFFEB 		bl	_tx_thread_sleep
 7366 40d8 7D0FA0E3 		mov	r0, #500
 7367 40dc FEFFFFEB 		bl	_tx_thread_sleep
 7368 40e0 7D0FA0E3 		mov	r0, #500
 7369 40e4 FEFFFFEB 		bl	_tx_thread_sleep
 7370 40e8 7D0FA0E3 		mov	r0, #500
 7371 40ec FEFFFFEB 		bl	_tx_thread_sleep
 7372              	.LBB222:
 7373              	.LBB223:
2451:../uvc.c      ****     status = CyU3PI2cInit ();
 7374              		.loc 1 2451 0
 7375 40f0 FEFFFFEB 		bl	CyU3PI2cInit
 7376              	.LVL666:
2452:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7377              		.loc 1 2452 0
 7378 40f4 004050E2 		subs	r4, r0, #0
 7379 40f8 0400000A 		beq	.L607
2454:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7380              		.loc 1 2454 0
 7381 40fc 0400A0E3 		mov	r0, #4
 7382              	.LVL667:
 7383 4100 3C1B9FE5 		ldr	r1, .L719+8
 7384 4104 FEFFFFEB 		bl	CyU3PDebugPrint
2455:../uvc.c      ****         CyFxAppErrorHandler (status);
 7385              		.loc 1 2455 0
 7386 4108 0400A0E1 		mov	r0, r4
 7387 410c FEFFFFEB 		bl	CyFxAppErrorHandler
 7388              	.L607:
2459:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7389              		.loc 1 2459 0
 7390 4110 306B9FE5 		ldr	r6, .L719+12
2460:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7391              		.loc 1 2460 0
 7392 4114 0050A0E3 		mov	r5, #0
2461:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7393              		.loc 1 2461 0
 7394 4118 0040E0E3 		mvn	r4, #0
 7395              	.LVL668:
2464:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7396              		.loc 1 2464 0
 7397 411c 8C008DE2 		add	r0, sp, #140
 7398 4120 0510A0E1 		mov	r1, r5
2461:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7399              		.loc 1 2461 0
 7400 4124 94408DE5 		str	r4, [sp, #148]
2462:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7401              		.loc 1 2462 0
 7402 4128 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2459:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7403              		.loc 1 2459 0
 7404 412c 8C608DE5 		str	r6, [sp, #140]
2460:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7405              		.loc 1 2460 0
 7406 4130 90508DE5 		str	r5, [sp, #144]
2464:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7407              		.loc 1 2464 0
 7408 4134 FEFFFFEB 		bl	CyU3PI2cSetConfig
 7409              	.LVL669:
2465:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7410              		.loc 1 2465 0
 7411 4138 004050E2 		subs	r4, r0, #0
 7412 413c 0400000A 		beq	.L608
2467:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7413              		.loc 1 2467 0
 7414 4140 0400A0E3 		mov	r0, #4
 7415              	.LVL670:
 7416 4144 001B9FE5 		ldr	r1, .L719+16
 7417 4148 FEFFFFEB 		bl	CyU3PDebugPrint
2468:../uvc.c      ****         CyFxAppErrorHandler (status);
 7418              		.loc 1 2468 0
 7419 414c 0400A0E1 		mov	r0, r4
 7420 4150 FEFFFFEB 		bl	CyFxAppErrorHandler
 7421              	.L608:
 7422              	.LBE223:
 7423              	.LBE222:
 7424              	.LBB224:
 7425              	.LBB227:
2538:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 7426              		.loc 1 2538 0
 7427 4154 F44A9FE5 		ldr	r4, .L719+20
 7428              	.LVL671:
 7429 4158 2820A0E3 		mov	r2, #40
 7430 415c 0010A0E3 		mov	r1, #0
 7431 4160 0400A0E1 		mov	r0, r4
 7432 4164 FEFFFFEB 		bl	_txe_event_flags_create
 7433              	.LVL672:
2539:../uvc.c      ****     if (apiRetStatus != 0)
 7434              		.loc 1 2539 0
 7435 4168 002050E2 		subs	r2, r0, #0
 7436 416c F800001A 		bne	.L693
2553:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7437              		.loc 1 2553 0
 7438 4170 0260A0E3 		mov	r6, #2
2560:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7439              		.loc 1 2560 0
 7440 4174 0210A0E1 		mov	r1, r2
2549:../uvc.c      ****     isUsbConnected = CyFalse;
 7441              		.loc 1 2549 0
 7442 4178 302084E5 		str	r2, [r4, #48]
2550:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7443              		.loc 1 2550 0
 7444 417c 442084E5 		str	r2, [r4, #68]
2556:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7445              		.loc 1 2556 0
 7446 4180 0370A0E3 		mov	r7, #3
2560:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7447              		.loc 1 2560 0
 7448 4184 9C008DE2 		add	r0, sp, #156
 7449              	.LVL673:
2555:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7450              		.loc 1 2555 0
 7451 4188 A420CDE5 		strb	r2, [sp, #164]
2557:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7452              		.loc 1 2557 0
 7453 418c A0208DE5 		str	r2, [sp, #160]
2553:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7454              		.loc 1 2553 0
 7455 4190 9C60CDE5 		strb	r6, [sp, #156]
2554:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7456              		.loc 1 2554 0
 7457 4194 9D60CDE5 		strb	r6, [sp, #157]
2556:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7458              		.loc 1 2556 0
 7459 4198 A570CDE5 		strb	r7, [sp, #165]
2560:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7460              		.loc 1 2560 0
 7461 419c FEFFFFEB 		bl	CyU3PGpioInit
 7462              	.LVL674:
2561:../uvc.c      ****     if (apiRetStatus != 0)
 7463              		.loc 1 2561 0
 7464 41a0 002050E2 		subs	r2, r0, #0
 7465 41a4 FC00001A 		bne	.L694
2569:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 7466              		.loc 1 2569 0
 7467 41a8 1600A0E3 		mov	r0, #22
 7468              	.LVL675:
 7469 41ac 0110A0E3 		mov	r1, #1
 7470 41b0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7471              	.LVL676:
2570:../uvc.c      ****     if (apiRetStatus != 0)
 7472              		.loc 1 2570 0
 7473 41b4 002050E2 		subs	r2, r0, #0
 7474 41b8 EE00001A 		bne	.L695
2575:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 7475              		.loc 1 2575 0
 7476 41bc 1400A0E3 		mov	r0, #20
 7477              	.LVL677:
 7478 41c0 0110A0E3 		mov	r1, #1
 7479 41c4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7480              	.LVL678:
2576:../uvc.c      ****     if (apiRetStatus != 0)
 7481              		.loc 1 2576 0
 7482 41c8 002050E2 		subs	r2, r0, #0
 7483 41cc FB00001A 		bne	.L696
2581:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 7484              		.loc 1 2581 0
 7485 41d0 1800A0E3 		mov	r0, #24
 7486              	.LVL679:
 7487 41d4 0110A0E3 		mov	r1, #1
 7488 41d8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7489              	.LVL680:
2582:../uvc.c      ****     if (apiRetStatus != 0)
 7490              		.loc 1 2582 0
 7491 41dc 002050E2 		subs	r2, r0, #0
 7492 41e0 D601001A 		bne	.L697
2589:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7493              		.loc 1 2589 0
 7494 41e4 0150A0E3 		mov	r5, #1
2594:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7495              		.loc 1 2594 0
 7496 41e8 1600A0E3 		mov	r0, #22
 7497              	.LVL681:
 7498 41ec 68108DE2 		add	r1, sp, #104
2592:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7499              		.loc 1 2592 0
 7500 41f0 74208DE5 		str	r2, [sp, #116]
2593:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7501              		.loc 1 2593 0
 7502 41f4 7820CDE5 		strb	r2, [sp, #120]
2589:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7503              		.loc 1 2589 0
 7504 41f8 68508DE5 		str	r5, [sp, #104]
2590:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7505              		.loc 1 2590 0
 7506 41fc 6C508DE5 		str	r5, [sp, #108]
2591:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7507              		.loc 1 2591 0
 7508 4200 70508DE5 		str	r5, [sp, #112]
2594:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7509              		.loc 1 2594 0
 7510 4204 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7511              	.LVL682:
2595:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7512              		.loc 1 2595 0
 7513 4208 002050E2 		subs	r2, r0, #0
 7514 420c C201001A 		bne	.L698
2608:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7515              		.loc 1 2608 0
 7516 4210 1400A0E3 		mov	r0, #20
 7517              	.LVL683:
 7518 4214 68108DE2 		add	r1, sp, #104
2606:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7519              		.loc 1 2606 0
 7520 4218 74208DE5 		str	r2, [sp, #116]
2607:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7521              		.loc 1 2607 0
 7522 421c 7820CDE5 		strb	r2, [sp, #120]
2603:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7523              		.loc 1 2603 0
 7524 4220 68508DE5 		str	r5, [sp, #104]
2604:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7525              		.loc 1 2604 0
 7526 4224 6C508DE5 		str	r5, [sp, #108]
2605:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7527              		.loc 1 2605 0
 7528 4228 70508DE5 		str	r5, [sp, #112]
2608:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7529              		.loc 1 2608 0
 7530 422c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7531              	.LVL684:
2609:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7532              		.loc 1 2609 0
 7533 4230 002050E2 		subs	r2, r0, #0
 7534 4234 CA01001A 		bne	.L699
2622:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7535              		.loc 1 2622 0
 7536 4238 1800A0E3 		mov	r0, #24
 7537              	.LVL685:
 7538 423c 68108DE2 		add	r1, sp, #104
2617:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 7539              		.loc 1 2617 0
 7540 4240 68208DE5 		str	r2, [sp, #104]
2618:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7541              		.loc 1 2618 0
 7542 4244 6C208DE5 		str	r2, [sp, #108]
2619:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7543              		.loc 1 2619 0
 7544 4248 70208DE5 		str	r2, [sp, #112]
2621:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7545              		.loc 1 2621 0
 7546 424c 7820CDE5 		strb	r2, [sp, #120]
2620:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7547              		.loc 1 2620 0
 7548 4250 74508DE5 		str	r5, [sp, #116]
2622:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7549              		.loc 1 2622 0
 7550 4254 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7551              	.LVL686:
2623:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7552              		.loc 1 2623 0
 7553 4258 002050E2 		subs	r2, r0, #0
 7554 425c A501001A 		bne	.L700
2635:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7555              		.loc 1 2635 0
 7556 4260 0500A0E1 		mov	r0, r5
 7557              	.LVL687:
 7558 4264 7C108DE2 		add	r1, sp, #124
2632:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7559              		.loc 1 2632 0
 7560 4268 84208DE5 		str	r2, [sp, #132]
2633:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7561              		.loc 1 2633 0
 7562 426c 80208DE5 		str	r2, [sp, #128]
2630:../uvc.c      ****     pibclock.clkDiv      = 2;
 7563              		.loc 1 2630 0
 7564 4270 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2631:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7565              		.loc 1 2631 0
 7566 4274 8870CDE5 		strb	r7, [sp, #136]
2635:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7567              		.loc 1 2635 0
 7568 4278 FEFFFFEB 		bl	CyU3PPibInit
 7569              	.LVL688:
2636:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7570              		.loc 1 2636 0
 7571 427c 002050E2 		subs	r2, r0, #0
 7572 4280 9301001A 		bne	.L701
2643:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7573              		.loc 1 2643 0
 7574 4284 C8099FE5 		ldr	r0, .L719+24
 7575              	.LVL689:
 7576 4288 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7577              	.LVL690:
2651:../uvc.c      ****     SensorReset ();
 7578              		.loc 1 2651 0
 7579 428c FEFFFFEB 		bl	SensorReset
2652:../uvc.c      ****     CyU3PThreadSleep(5000);
 7580              		.loc 1 2652 0
 7581 4290 C0099FE5 		ldr	r0, .L719+28
 7582 4294 FEFFFFEB 		bl	_tx_thread_sleep
2656:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7583              		.loc 1 2656 0
 7584 4298 FEFFFFEB 		bl	CyU3PUsbStart
 7585              	.LVL691:
2657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7586              		.loc 1 2657 0
 7587 429c 002050E2 		subs	r2, r0, #0
 7588 42a0 8201001A 		bne	.L702
2663:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7589              		.loc 1 2663 0
 7590 42a4 0010A0E3 		mov	r1, #0
 7591 42a8 AC099FE5 		ldr	r0, .L719+32
 7592              	.LVL692:
 7593 42ac FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7594              	.LVL693:
2666:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7595              		.loc 1 2666 0
 7596 42b0 A8099FE5 		ldr	r0, .L719+36
 7597 42b4 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2672:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7598              		.loc 1 2672 0
 7599 42b8 0010A0E3 		mov	r1, #0
 7600 42bc A0299FE5 		ldr	r2, .L719+40
 7601 42c0 0100A0E3 		mov	r0, #1
 7602 42c4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2673:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7603              		.loc 1 2673 0
 7604 42c8 0000A0E3 		mov	r0, #0
 7605 42cc 0010A0E1 		mov	r1, r0
 7606 42d0 90299FE5 		ldr	r2, .L719+44
 7607 42d4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2676:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7608              		.loc 1 2676 0
 7609 42d8 0010A0E3 		mov	r1, #0
 7610 42dc 88299FE5 		ldr	r2, .L719+48
 7611 42e0 0200A0E3 		mov	r0, #2
 7612 42e4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2677:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7613              		.loc 1 2677 0
 7614 42e8 0010A0E3 		mov	r1, #0
 7615 42ec 7C299FE5 		ldr	r2, .L719+52
 7616 42f0 0700A0E3 		mov	r0, #7
 7617 42f4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2680:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7618              		.loc 1 2680 0
 7619 42f8 0010A0E3 		mov	r1, #0
 7620 42fc 70299FE5 		ldr	r2, .L719+56
 7621 4300 0400A0E3 		mov	r0, #4
 7622 4304 FEFFFFEB 		bl	CyU3PUsbSetDesc
2681:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7623              		.loc 1 2681 0
 7624 4308 0010A0E3 		mov	r1, #0
 7625 430c 64299FE5 		ldr	r2, .L719+60
 7626 4310 0300A0E3 		mov	r0, #3
 7627 4314 FEFFFFEB 		bl	CyU3PUsbSetDesc
2682:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7628              		.loc 1 2682 0
 7629 4318 0010A0E3 		mov	r1, #0
 7630 431c 58299FE5 		ldr	r2, .L719+64
 7631 4320 0600A0E3 		mov	r0, #6
 7632 4324 FEFFFFEB 		bl	CyU3PUsbSetDesc
2685:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7633              		.loc 1 2685 0
 7634 4328 0010A0E3 		mov	r1, #0
 7635 432c 4C299FE5 		ldr	r2, .L719+68
 7636 4330 0500A0E3 		mov	r0, #5
 7637 4334 FEFFFFEB 		bl	CyU3PUsbSetDesc
2686:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7638              		.loc 1 2686 0
 7639 4338 0110A0E3 		mov	r1, #1
 7640 433c 40299FE5 		ldr	r2, .L719+72
 7641 4340 0500A0E3 		mov	r0, #5
 7642 4344 FEFFFFEB 		bl	CyU3PUsbSetDesc
2687:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7643              		.loc 1 2687 0
 7644 4348 0210A0E3 		mov	r1, #2
 7645 434c 34299FE5 		ldr	r2, .L719+76
 7646 4350 0500A0E3 		mov	r0, #5
 7647 4354 FEFFFFEB 		bl	CyU3PUsbSetDesc
2697:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7648              		.loc 1 2697 0
 7649 4358 0080A0E3 		mov	r8, #0
2694:../uvc.c      ****     endPointConfig.enable   = 1;
 7650              		.loc 1 2694 0
 7651 435c 0150A0E3 		mov	r5, #1
2696:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7652              		.loc 1 2696 0
 7653 4360 4070A0E3 		mov	r7, #64	@ movhi
2700:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7654              		.loc 1 2700 0
 7655 4364 8200A0E3 		mov	r0, #130
 7656 4368 A8108DE2 		add	r1, sp, #168
2695:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7657              		.loc 1 2695 0
 7658 436c 03A0A0E3 		mov	sl, #3
2696:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7659              		.loc 1 2696 0
 7660 4370 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2694:../uvc.c      ****     endPointConfig.enable   = 1;
 7661              		.loc 1 2694 0
 7662 4374 A8508DE5 		str	r5, [sp, #168]
2695:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7663              		.loc 1 2695 0
 7664 4378 ACA0CDE5 		strb	sl, [sp, #172]
2697:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7665              		.loc 1 2697 0
 7666 437c B380CDE5 		strb	r8, [sp, #179]
2698:../uvc.c      ****     endPointConfig.streams  = 0;
 7667              		.loc 1 2698 0
 7668 4380 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2699:../uvc.c      ****     endPointConfig.burstLen = 1;
 7669              		.loc 1 2699 0
 7670 4384 B250CDE5 		strb	r5, [sp, #178]
2700:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7671              		.loc 1 2700 0
 7672 4388 FEFFFFEB 		bl	CyU3PSetEpConfig
 7673              	.LVL694:
2698:../uvc.c      ****     endPointConfig.streams  = 0;
 7674              		.loc 1 2698 0
 7675 438c 0870A0E1 		mov	r7, r8	@ movhi
2701:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7676              		.loc 1 2701 0
 7677 4390 003050E2 		subs	r3, r0, #0
 7678 4394 3B01001A 		bne	.L703
2711:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7679              		.loc 1 2711 0
 7680 4398 ECC89FE5 		ldr	ip, .L719+80
2712:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7681              		.loc 1 2712 0
 7682 439c ECE89FE5 		ldr	lr, .L719+84
2709:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7683              		.loc 1 2709 0
 7684 43a0 016BA0E3 		mov	r6, #1024	@ movhi
2718:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7685              		.loc 1 2718 0
 7686 43a4 1080A0E3 		mov	r8, #16
2720:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7687              		.loc 1 2720 0
 7688 43a8 E4089FE5 		ldr	r0, .L719+88
 7689              	.LVL695:
 7690 43ac 0410A0E3 		mov	r1, #4
 7691 43b0 34208DE2 		add	r2, sp, #52
2709:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7692              		.loc 1 2709 0
 7693 43b4 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2710:../uvc.c      ****     dmaInterConfig.count          = 1;
 7694              		.loc 1 2710 0
 7695 43b8 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2711:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7696              		.loc 1 2711 0
 7697 43bc B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2712:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7698              		.loc 1 2712 0
 7699 43c0 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2713:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7700              		.loc 1 2713 0
 7701 43c4 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2714:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7702              		.loc 1 2714 0
 7703 43c8 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2715:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7704              		.loc 1 2715 0
 7705 43cc B034CDE1 		strh	r3, [sp, #64]	@ movhi
2716:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7706              		.loc 1 2716 0
 7707 43d0 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2717:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7708              		.loc 1 2717 0
 7709 43d4 4470CDE5 		strb	r7, [sp, #68]
2718:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7710              		.loc 1 2718 0
 7711 43d8 48808DE5 		str	r8, [sp, #72]
2719:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7712              		.loc 1 2719 0
 7713 43dc 4C308DE5 		str	r3, [sp, #76]
2720:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7714              		.loc 1 2720 0
 7715 43e0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7716              	.LVL696:
2722:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7717              		.loc 1 2722 0
 7718 43e4 006050E2 		subs	r6, r0, #0
 7719 43e8 DF00001A 		bne	.L704
2729:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7720              		.loc 1 2729 0
 7721 43ec 010BA0E3 		mov	r0, #1024
 7722              	.LVL697:
 7723 43f0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7724 43f4 9C189FE5 		ldr	r1, .L719+92
2730:../uvc.c      ****     if (glInterStaBuffer == 0)
 7725              		.loc 1 2730 0
 7726 43f8 000050E3 		cmp	r0, #0
2729:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7727              		.loc 1 2729 0
 7728 43fc 000081E5 		str	r0, [r1, #0]
2730:../uvc.c      ****     if (glInterStaBuffer == 0)
 7729              		.loc 1 2730 0
 7730 4400 D000000A 		beq	.L705
2737:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7731              		.loc 1 2737 0
 7732 4404 0610A0E1 		mov	r1, r6
 7733 4408 0620A0E1 		mov	r2, r6
 7734 440c 3830A0E3 		mov	r3, #56
 7735 4410 84089FE5 		ldr	r0, .L719+96
 7736 4414 FEFFFFEB 		bl	_txe_mutex_create
2739:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7737              		.loc 1 2739 0
 7738 4418 0430A0E3 		mov	r3, #4	@ movhi
 7739 441c BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2742:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7740              		.loc 1 2742 0
 7741 4420 78389FE5 		ldr	r3, .L719+100
2738:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7742              		.loc 1 2738 0
 7743 4424 01C9A0E3 		mov	ip, #16384	@ movhi
 7744 4428 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2741:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7745              		.loc 1 2741 0
 7746 442c 01CCA0E3 		mov	ip, #256	@ movhi
 7747 4430 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2742:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7748              		.loc 1 2742 0
 7749 4434 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2743:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7750              		.loc 1 2743 0
 7751 4438 64C89FE5 		ldr	ip, .L719+104
2745:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7752              		.loc 1 2745 0
 7753 443c 0C30A0E3 		mov	r3, #12	@ movhi
 7754 4440 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2750:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7755              		.loc 1 2750 0
 7756 4444 5C389FE5 		ldr	r3, .L719+108
2751:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7757              		.loc 1 2751 0
 7758 4448 0C208DE2 		add	r2, sp, #12
2743:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7759              		.loc 1 2743 0
 7760 444c BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2748:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7761              		.loc 1 2748 0
 7762 4450 2A70CDE5 		strb	r7, [sp, #42]
2746:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7763              		.loc 1 2746 0
 7764 4454 04C0A0E3 		mov	ip, #4	@ movhi
2740:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7765              		.loc 1 2740 0
 7766 4458 02A0A0E3 		mov	sl, #2	@ movhi
2751:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7767              		.loc 1 2751 0
 7768 445c 48089FE5 		ldr	r0, .L719+112
 7769 4460 0710A0E3 		mov	r1, #7
2749:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7770              		.loc 1 2749 0
 7771 4464 1870A0E3 		mov	r7, #24
2740:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7772              		.loc 1 2740 0
 7773 4468 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2744:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7774              		.loc 1 2744 0
 7775 446c B262CDE1 		strh	r6, [sp, #34]	@ movhi
2746:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7776              		.loc 1 2746 0
 7777 4470 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2747:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7778              		.loc 1 2747 0
 7779 4474 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2749:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7780              		.loc 1 2749 0
 7781 4478 2C708DE5 		str	r7, [sp, #44]
2750:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7782              		.loc 1 2750 0
 7783 447c 30308DE5 		str	r3, [sp, #48]
2751:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7784              		.loc 1 2751 0
 7785 4480 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7786              	.LVL698:
2753:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7787              		.loc 1 2753 0
 7788 4484 002050E2 		subs	r2, r0, #0
 7789 4488 A500001A 		bne	.L706
2844:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 7790              		.loc 1 2844 0
 7791 448c 0500A0E1 		mov	r0, r5
 7792              	.LVL699:
 7793 4490 0510A0E1 		mov	r1, r5
 7794 4494 FEFFFFEB 		bl	CyU3PConnectState
 7795              	.LVL700:
2845:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7796              		.loc 1 2845 0
 7797 4498 002050E2 		subs	r2, r0, #0
 7798 449c 9700001A 		bne	.L707
2851:../uvc.c      ****     CyU3PBusyWait(100);
 7799              		.loc 1 2851 0
 7800 44a0 6400A0E3 		mov	r0, #100
 7801              	.LVL701:
 7802 44a4 FEFFFFEB 		bl	CyU3PBusyWait
 7803              	.LVL702:
2853:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7804              		.loc 1 2853 0
 7805 44a8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2867:../uvc.c      ****     endPointConfig.streams  = 0;
 7806              		.loc 1 2867 0
 7807 44ac 0020A0E3 		mov	r2, #0	@ movhi
2856:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7808              		.loc 1 2856 0
 7809 44b0 ACA0CDE5 		strb	sl, [sp, #172]
2868:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7810              		.loc 1 2868 0
 7811 44b4 A8108DE2 		add	r1, sp, #168
2867:../uvc.c      ****     endPointConfig.streams  = 0;
 7812              		.loc 1 2867 0
 7813 44b8 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2855:../uvc.c      ****     endPointConfig.enable   = 1;
 7814              		.loc 1 2855 0
 7815 44bc A8508DE5 		str	r5, [sp, #168]
2857:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7816              		.loc 1 2857 0
 7817 44c0 030050E3 		cmp	r0, #3
2853:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7818              		.loc 1 2853 0
 7819 44c4 4800C4E5 		strb	r0, [r4, #72]
2864:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7820              		.loc 1 2864 0
 7821 44c8 020CA013 		movne	r0, #512	@ movhi
2859:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7822              		.loc 1 2859 0
 7823 44cc 01ABA003 		moveq	sl, #1024	@ movhi
2864:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7824              		.loc 1 2864 0
 7825 44d0 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2868:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7826              		.loc 1 2868 0
 7827 44d4 8300A0E3 		mov	r0, #131
2859:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7828              		.loc 1 2859 0
 7829 44d8 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2860:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7830              		.loc 1 2860 0
 7831 44dc B280CD05 		streqb	r8, [sp, #178]
2865:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7832              		.loc 1 2865 0
 7833 44e0 B250CD15 		strneb	r5, [sp, #178]
2868:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7834              		.loc 1 2868 0
 7835 44e4 FEFFFFEB 		bl	CyU3PSetEpConfig
 7836              	.LVL703:
2869:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7837              		.loc 1 2869 0
 7838 44e8 002050E2 		subs	r2, r0, #0
 7839 44ec 4F00001A 		bne	.L690
 7840 44f0 B8779FE5 		ldr	r7, .L719+116
 7841              	.LBE227:
 7842              	.LBE224:
2992:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7843              		.loc 1 2992 0
 7844 44f4 54579FE5 		ldr	r5, .L719+20
 7845 44f8 0260A0E1 		mov	r6, r2
3181:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7846              		.loc 1 3181 0
 7847 44fc 0080E0E3 		mvn	r8, #0
 7848              	.LVL704:
 7849              	.L641:
2992:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7850              		.loc 1 2992 0
 7851 4500 48079FE5 		ldr	r0, .L719+20
 7852 4504 0110A0E3 		mov	r1, #1
 7853 4508 0220A0E3 		mov	r2, #2
 7854 450c B4308DE2 		add	r3, sp, #180
 7855 4510 00608DE5 		str	r6, [sp, #0]
 7856 4514 FEFFFFEB 		bl	_txe_event_flags_get
 7857 4518 000050E3 		cmp	r0, #0
 7858 451c 3000001A 		bne	.L643
3038:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7859              		.loc 1 3038 0
 7860 4520 3CE095E5 		ldr	lr, [r5, #60]
 7861 4524 00005EE3 		cmp	lr, #0
 7862 4528 0300000A 		beq	.L644
3038:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7863              		.loc 1 3038 0 is_stmt 0 discriminator 1
 7864 452c B014D5E1 		ldrh	r1, [r5, #64]
 7865 4530 B234D5E1 		ldrh	r3, [r5, #66]
 7866 4534 030051E1 		cmp	r1, r3
 7867 4538 1201000A 		beq	.L708
 7868              	.L644:
3242:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7869              		.loc 1 3242 0 is_stmt 1
 7870 453c 4010A0E3 		mov	r1, #64
 7871 4540 0020A0E3 		mov	r2, #0
 7872 4544 04079FE5 		ldr	r0, .L719+20
 7873 4548 FEFFFFEB 		bl	_txe_event_flags_set
3245:../uvc.c      ****         CyU3PThreadRelinquish ();
 7874              		.loc 1 3245 0
 7875 454c FEFFFFEB 		bl	_txe_thread_relinquish
3246:../uvc.c      ****     }
 7876              		.loc 1 3246 0
 7877 4550 EAFFFFEA 		b	.L641
 7878              	.LVL705:
 7879              	.L693:
 7880              	.LBB262:
 7881              	.LBB226:
2541:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 7882              		.loc 1 2541 0
 7883 4554 0400A0E3 		mov	r0, #4
 7884              	.LVL706:
 7885 4558 54179FE5 		ldr	r1, .L719+120
 7886 455c FEFFFFEB 		bl	CyU3PDebugPrint
 7887              	.LVL707:
 7888              	.L610:
 7889              	.LBB242:
 7890              	.LBB243:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7891              		.loc 1 1970 0
 7892 4560 50179FE5 		ldr	r1, .L719+124
 7893 4564 0400A0E3 		mov	r0, #4
 7894 4568 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 7895              		.loc 1 1971 0
 7896 456c FA0FA0E3 		mov	r0, #1000
 7897 4570 FEFFFFEB 		bl	_tx_thread_sleep
 7898 4574 F9FFFFEA 		b	.L610
 7899              	.LVL708:
 7900              	.L695:
 7901              	.LBE243:
 7902              	.LBE242:
2572:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 7903              		.loc 1 2572 0
 7904 4578 0400A0E3 		mov	r0, #4
 7905              	.LVL709:
 7906 457c 38179FE5 		ldr	r1, .L719+128
 7907 4580 FEFFFFEB 		bl	CyU3PDebugPrint
 7908              	.LVL710:
 7909              	.L614:
 7910              	.LBB240:
 7911              	.LBB241:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7912              		.loc 1 1970 0
 7913 4584 2C179FE5 		ldr	r1, .L719+124
 7914 4588 0400A0E3 		mov	r0, #4
 7915 458c FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 7916              		.loc 1 1971 0
 7917 4590 FA0FA0E3 		mov	r0, #1000
 7918 4594 FEFFFFEB 		bl	_tx_thread_sleep
 7919 4598 F9FFFFEA 		b	.L614
 7920              	.LVL711:
 7921              	.L694:
 7922              	.LBE241:
 7923              	.LBE240:
2563:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 7924              		.loc 1 2563 0
 7925 459c 0400A0E3 		mov	r0, #4
 7926              	.LVL712:
 7927 45a0 18179FE5 		ldr	r1, .L719+132
 7928 45a4 FEFFFFEB 		bl	CyU3PDebugPrint
 7929              	.LVL713:
 7930              	.L612:
 7931              	.LBB238:
 7932              	.LBB239:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7933              		.loc 1 1970 0
 7934 45a8 08179FE5 		ldr	r1, .L719+124
 7935 45ac 0400A0E3 		mov	r0, #4
 7936 45b0 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 7937              		.loc 1 1971 0
 7938 45b4 FA0FA0E3 		mov	r0, #1000
 7939 45b8 FEFFFFEB 		bl	_tx_thread_sleep
 7940 45bc F9FFFFEA 		b	.L612
 7941              	.LVL714:
 7942              	.L696:
 7943              	.LBE239:
 7944              	.LBE238:
2578:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 7945              		.loc 1 2578 0
 7946 45c0 0400A0E3 		mov	r0, #4
 7947              	.LVL715:
 7948 45c4 F8169FE5 		ldr	r1, .L719+136
 7949 45c8 FEFFFFEB 		bl	CyU3PDebugPrint
 7950              	.LVL716:
 7951              	.L616:
 7952              	.LBB236:
 7953              	.LBB237:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7954              		.loc 1 1970 0
 7955 45cc E4169FE5 		ldr	r1, .L719+124
 7956 45d0 0400A0E3 		mov	r0, #4
 7957 45d4 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 7958              		.loc 1 1971 0
 7959 45d8 FA0FA0E3 		mov	r0, #1000
 7960 45dc FEFFFFEB 		bl	_tx_thread_sleep
 7961 45e0 F9FFFFEA 		b	.L616
 7962              	.LVL717:
 7963              	.L643:
 7964              	.LBE237:
 7965              	.LBE236:
 7966              	.LBE226:
 7967              	.LBE262:
3149:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 7968              		.loc 1 3149 0
 7969 45e4 64069FE5 		ldr	r0, .L719+20
 7970 45e8 0210A0E3 		mov	r1, #2
 7971 45ec 0320A0E3 		mov	r2, #3
 7972 45f0 B4308DE2 		add	r3, sp, #180
 7973 45f4 00608DE5 		str	r6, [sp, #0]
 7974 45f8 FEFFFFEB 		bl	_txe_event_flags_get
 7975 45fc 000050E3 		cmp	r0, #0
 7976 4600 2500001A 		bne	.L666
3164:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7977              		.loc 1 3164 0
 7978 4604 441095E5 		ldr	r1, [r5, #68]
3152:../uvc.c      ****                 hitFV     = CyFalse;
 7979              		.loc 1 3152 0
 7980 4608 3C6085E5 		str	r6, [r5, #60]
3164:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7981              		.loc 1 3164 0
 7982 460c 000051E3 		cmp	r1, #0
3153:../uvc.c      ****                 prodCount = 0;
 7983              		.loc 1 3153 0
 7984 4610 B064C5E1 		strh	r6, [r5, #64]	@ movhi
3160:../uvc.c      ****                 fb=0;
 7985              		.loc 1 3160 0
 7986 4614 B463C5E1 		strh	r6, [r5, #52]	@ movhi
3154:../uvc.c      ****                 consCount = 0;
 7987              		.loc 1 3154 0
 7988 4618 B264C5E1 		strh	r6, [r5, #66]	@ movhi
3161:../uvc.c      ****                 pb=0;
 7989              		.loc 1 3161 0
 7990 461c B663C5E1 		strh	r6, [r5, #54]	@ movhi
3162:../uvc.c      ****                 pbc=0;
 7991              		.loc 1 3162 0
 7992 4620 B863C5E1 		strh	r6, [r5, #56]	@ movhi
3164:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7993              		.loc 1 3164 0
 7994 4624 0A00000A 		beq	.L709
 7995              	.L667:
3176:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 7996              		.loc 1 3176 0
 7997 4628 446084E5 		str	r6, [r4, #68]
 7998 462c C2FFFFEA 		b	.L644
 7999              	.LVL718:
 8000              	.L690:
 8001              	.LBB263:
 8002              	.LBB260:
2872:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8003              		.loc 1 2872 0
 8004 4630 0400A0E3 		mov	r0, #4
 8005              	.LVL719:
 8006 4634 8C169FE5 		ldr	r1, .L719+140
 8007 4638 FEFFFFEB 		bl	CyU3PDebugPrint
 8008              	.LVL720:
 8009              	.L642:
 8010              	.LBB244:
 8011              	.LBB245:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8012              		.loc 1 1970 0
 8013 463c 74169FE5 		ldr	r1, .L719+124
 8014 4640 0400A0E3 		mov	r0, #4
 8015 4644 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8016              		.loc 1 1971 0
 8017 4648 FA0FA0E3 		mov	r0, #1000
 8018 464c FEFFFFEB 		bl	_tx_thread_sleep
 8019 4650 F9FFFFEA 		b	.L642
 8020              	.LVL721:
 8021              	.L709:
 8022              	.LBE245:
 8023              	.LBE244:
 8024              	.LBE260:
 8025              	.LBE263:
3166:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8026              		.loc 1 3166 0
 8027 4654 50069FE5 		ldr	r0, .L719+112
 8028 4658 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8029              	.LVL722:
3167:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8030              		.loc 1 3167 0
 8031 465c 000050E3 		cmp	r0, #0
 8032 4660 0200001A 		bne	.L691
3173:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8033              		.loc 1 3173 0
 8034 4664 8300A0E3 		mov	r0, #131
 8035              	.LVL723:
 8036 4668 FEFFFFEB 		bl	CyU3PUsbFlushEp
 8037 466c EDFFFFEA 		b	.L667
 8038              	.L691:
 8039              	.LBB264:
 8040              	.LBB265:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8041              		.loc 1 1970 0
 8042 4670 40169FE5 		ldr	r1, .L719+124
 8043 4674 0400A0E3 		mov	r0, #4
 8044 4678 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8045              		.loc 1 1971 0
 8046 467c FA0FA0E3 		mov	r0, #1000
 8047 4680 FEFFFFEB 		bl	_tx_thread_sleep
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8048              		.loc 1 1970 0
 8049 4684 2C169FE5 		ldr	r1, .L719+124
 8050 4688 0400A0E3 		mov	r0, #4
 8051 468c FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8052              		.loc 1 1971 0
 8053 4690 FA0FA0E3 		mov	r0, #1000
 8054 4694 FEFFFFEB 		bl	_tx_thread_sleep
 8055 4698 F4FFFFEA 		b	.L691
 8056              	.L666:
 8057              	.LBE265:
 8058              	.LBE264:
3181:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8059              		.loc 1 3181 0
 8060 469c 0110A0E3 		mov	r1, #1
 8061 46a0 0220A0E3 		mov	r2, #2
 8062 46a4 B4308DE2 		add	r3, sp, #180
 8063 46a8 A0059FE5 		ldr	r0, .L719+20
 8064 46ac 00808DE5 		str	r8, [sp, #0]
 8065 46b0 FEFFFFEB 		bl	_txe_event_flags_get
3185:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8066              		.loc 1 3185 0
 8067 46b4 0620A0E1 		mov	r2, r6
 8068 46b8 EC059FE5 		ldr	r0, .L719+112
 8069 46bc 0610A0E1 		mov	r1, r6
 8070 46c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8071              	.LVL724:
3186:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8072              		.loc 1 3186 0
 8073 46c4 002050E2 		subs	r2, r0, #0
 8074 46c8 6500001A 		bne	.L710
3194:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8075              		.loc 1 3194 0
 8076 46cc 280095E5 		ldr	r0, [r5, #40]
 8077              	.LVL725:
 8078 46d0 000050E3 		cmp	r0, #0
 8079 46d4 5A00001A 		bne	.L672
 8080              	.LVL726:
 8081              	.LBB266:
 8082              	.LBB267:
2897:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8083              		.loc 1 2897 0
 8084 46d8 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 8085 46dc 030053E3 		cmp	r3, #3
 8086 46e0 4700000A 		beq	.L711
2902:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8087              		.loc 1 2902 0
 8088 46e4 020053E3 		cmp	r3, #2
 8089 46e8 2900000A 		beq	.L712
 8090              	.LVL727:
 8091              	.L675:
 8092              	.LBE267:
 8093              	.LBE266:
3230:../uvc.c      ****                     gpif_initialized = CyTrue;
 8094              		.loc 1 3230 0
 8095 46ec 0120A0E3 		mov	r2, #1
 8096 46f0 282084E5 		str	r2, [r4, #40]
3231:../uvc.c      ****                     CyU3PThreadSleep(200);
 8097              		.loc 1 3231 0
 8098 46f4 C800A0E3 		mov	r0, #200
 8099 46f8 FEFFFFEB 		bl	_tx_thread_sleep
 8100 46fc 8EFFFFEA 		b	.L644
 8101              	.LVL728:
 8102              	.L707:
 8103              	.LBB273:
 8104              	.LBB225:
2847:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 8105              		.loc 1 2847 0
 8106 4700 0400A0E3 		mov	r0, #4
 8107              	.LVL729:
 8108 4704 C0159FE5 		ldr	r1, .L719+144
 8109 4708 FEFFFFEB 		bl	CyU3PDebugPrint
 8110              	.LVL730:
 8111              	.L638:
 8112              	.LBB234:
 8113              	.LBB235:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8114              		.loc 1 1970 0
 8115 470c A4159FE5 		ldr	r1, .L719+124
 8116 4710 0400A0E3 		mov	r0, #4
 8117 4714 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8118              		.loc 1 1971 0
 8119 4718 FA0FA0E3 		mov	r0, #1000
 8120 471c FEFFFFEB 		bl	_tx_thread_sleep
 8121 4720 F9FFFFEA 		b	.L638
 8122              	.LVL731:
 8123              	.L706:
 8124              	.LBE235:
 8125              	.LBE234:
2756:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 8126              		.loc 1 2756 0
 8127 4724 0400A0E3 		mov	r0, #4
 8128              	.LVL732:
 8129 4728 A0159FE5 		ldr	r1, .L719+148
 8130 472c FEFFFFEB 		bl	CyU3PDebugPrint
 8131              	.LVL733:
 8132              	.L636:
 8133              	.LBB232:
 8134              	.LBB233:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8135              		.loc 1 1970 0
 8136 4730 80159FE5 		ldr	r1, .L719+124
 8137 4734 0400A0E3 		mov	r0, #4
 8138 4738 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8139              		.loc 1 1971 0
 8140 473c FA0FA0E3 		mov	r0, #1000
 8141 4740 FEFFFFEB 		bl	_tx_thread_sleep
 8142 4744 F9FFFFEA 		b	.L636
 8143              	.LVL734:
 8144              	.L705:
 8145              	.LBE233:
 8146              	.LBE232:
2732:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 8147              		.loc 1 2732 0
 8148 4748 040080E2 		add	r0, r0, #4
 8149 474c 80159FE5 		ldr	r1, .L719+152
 8150 4750 FEFFFFEB 		bl	CyU3PDebugPrint
 8151              	.LVL735:
 8152              	.L634:
 8153              	.LBB230:
 8154              	.LBB231:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8155              		.loc 1 1970 0
 8156 4754 5C159FE5 		ldr	r1, .L719+124
 8157 4758 0400A0E3 		mov	r0, #4
 8158 475c FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8159              		.loc 1 1971 0
 8160 4760 FA0FA0E3 		mov	r0, #1000
 8161 4764 FEFFFFEB 		bl	_tx_thread_sleep
 8162 4768 F9FFFFEA 		b	.L634
 8163              	.LVL736:
 8164              	.L704:
 8165              	.LBE231:
 8166              	.LBE230:
2725:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 8167              		.loc 1 2725 0
 8168 476c 0400A0E3 		mov	r0, #4
 8169 4770 60159FE5 		ldr	r1, .L719+156
 8170 4774 0620A0E1 		mov	r2, r6
 8171 4778 FEFFFFEB 		bl	CyU3PDebugPrint
 8172              	.L632:
 8173              	.LBB228:
 8174              	.LBB229:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8175              		.loc 1 1970 0
 8176 477c 34159FE5 		ldr	r1, .L719+124
 8177 4780 0400A0E3 		mov	r0, #4
 8178 4784 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8179              		.loc 1 1971 0
 8180 4788 FA0FA0E3 		mov	r0, #1000
 8181 478c FEFFFFEB 		bl	_tx_thread_sleep
 8182 4790 F9FFFFEA 		b	.L632
 8183              	.LVL737:
 8184              	.L712:
 8185              	.LBE229:
 8186              	.LBE228:
 8187              	.LBE225:
 8188              	.LBE273:
 8189              	.LBB274:
 8190              	.LBB272:
2904:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8191              		.loc 1 2904 0
 8192 4794 40159FE5 		ldr	r1, .L719+160
 8193 4798 0100A0E3 		mov	r0, #1
 8194 479c FEFFFFEB 		bl	CyU3PDebugPrint
 8195              	.LVL738:
2905:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8196              		.loc 1 2905 0
 8197 47a0 38059FE5 		ldr	r0, .L719+164
 8198 47a4 FEFFFFEB 		bl	CyU3PGpifLoad
 8199 47a8 0020A0E1 		mov	r2, r0
 8200              	.LVL739:
 8201              	.L674:
2907:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8202              		.loc 1 2907 0
 8203 47ac 000052E3 		cmp	r2, #0
 8204 47b0 1A00001A 		bne	.L713
2915:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8205              		.loc 1 2915 0
 8206 47b4 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 8207 47b8 030053E3 		cmp	r3, #3
 8208 47bc 0100000A 		beq	.L692
2919:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8209              		.loc 1 2919 0
 8210 47c0 020053E3 		cmp	r3, #2
 8211 47c4 C8FFFF1A 		bne	.L675
 8212              	.L692:
2921:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8213              		.loc 1 2921 0
 8214 47c8 0200A0E1 		mov	r0, r2
 8215              	.LVL740:
 8216 47cc 0210A0E1 		mov	r1, r2
 8217 47d0 FEFFFFEB 		bl	CyU3PGpifSMStart
 8218              	.LVL741:
2923:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8219              		.loc 1 2923 0
 8220 47d4 000050E3 		cmp	r0, #0
2921:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8221              		.loc 1 2921 0
 8222 47d8 0020A0E1 		mov	r2, r0
 8223              	.LVL742:
2923:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8224              		.loc 1 2923 0
 8225 47dc C2FFFF0A 		beq	.L675
2926:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8226              		.loc 1 2926 0
 8227 47e0 0400A0E3 		mov	r0, #4
 8228              	.LVL743:
 8229 47e4 F8149FE5 		ldr	r1, .L719+168
 8230 47e8 FEFFFFEB 		bl	CyU3PDebugPrint
 8231              	.LVL744:
 8232              	.L680:
 8233              	.LBB268:
 8234              	.LBB269:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8235              		.loc 1 1970 0
 8236 47ec C4149FE5 		ldr	r1, .L719+124
 8237 47f0 0400A0E3 		mov	r0, #4
 8238 47f4 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8239              		.loc 1 1971 0
 8240 47f8 FA0FA0E3 		mov	r0, #1000
 8241 47fc FEFFFFEB 		bl	_tx_thread_sleep
 8242 4800 F9FFFFEA 		b	.L680
 8243              	.LVL745:
 8244              	.L711:
 8245              	.LBE269:
 8246              	.LBE268:
2899:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 8247              		.loc 1 2899 0
 8248 4804 DC149FE5 		ldr	r1, .L719+172
 8249 4808 0100A0E3 		mov	r0, #1
 8250 480c FEFFFFEB 		bl	CyU3PDebugPrint
 8251              	.LVL746:
2900:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 8252              		.loc 1 2900 0
 8253 4810 D4049FE5 		ldr	r0, .L719+176
 8254 4814 FEFFFFEB 		bl	CyU3PGpifLoad
 8255 4818 0020A0E1 		mov	r2, r0
 8256              	.LVL747:
 8257 481c E2FFFFEA 		b	.L674
 8258              	.L713:
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 8259              		.loc 1 2910 0
 8260 4820 0400A0E3 		mov	r0, #4
 8261              	.LVL748:
 8262 4824 C4149FE5 		ldr	r1, .L719+180
 8263 4828 FEFFFFEB 		bl	CyU3PDebugPrint
 8264              	.LVL749:
 8265              	.L677:
 8266              	.LBB270:
 8267              	.LBB271:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8268              		.loc 1 1970 0
 8269 482c 84149FE5 		ldr	r1, .L719+124
 8270 4830 0400A0E3 		mov	r0, #4
 8271 4834 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8272              		.loc 1 1971 0
 8273 4838 FA0FA0E3 		mov	r0, #1000
 8274 483c FEFFFFEB 		bl	_tx_thread_sleep
 8275 4840 F9FFFFEA 		b	.L677
 8276              	.LVL750:
 8277              	.L672:
 8278              	.LBE271:
 8279              	.LBE270:
 8280              	.LBE272:
 8281              	.LBE274:
3238:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8282              		.loc 1 3238 0
 8283 4844 54049FE5 		ldr	r0, .L719+100
 8284 4848 02C0A0E3 		mov	ip, #2
 8285 484c 0610A0E1 		mov	r1, r6
 8286 4850 0020A0E1 		mov	r2, r0
 8287              	.LVL751:
 8288 4854 0630A0E1 		mov	r3, r6
 8289 4858 00C08DE5 		str	ip, [sp, #0]
 8290 485c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8291 4860 35FFFFEA 		b	.L644
 8292              	.LVL752:
 8293              	.L710:
3189:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 8294              		.loc 1 3189 0
 8295 4864 0400A0E3 		mov	r0, #4
 8296              	.LVL753:
 8297 4868 84149FE5 		ldr	r1, .L719+184
 8298 486c FEFFFFEB 		bl	CyU3PDebugPrint
 8299              	.LVL754:
 8300              	.L671:
 8301              	.LBB275:
 8302              	.LBB276:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8303              		.loc 1 1970 0
 8304 4870 40149FE5 		ldr	r1, .L719+124
 8305 4874 0400A0E3 		mov	r0, #4
 8306 4878 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8307              		.loc 1 1971 0
 8308 487c FA0FA0E3 		mov	r0, #1000
 8309 4880 FEFFFFEB 		bl	_tx_thread_sleep
 8310 4884 F9FFFFEA 		b	.L671
 8311              	.LVL755:
 8312              	.L703:
 8313              	.LBE276:
 8314              	.LBE275:
 8315              	.LBB277:
 8316              	.LBB261:
2704:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8317              		.loc 1 2704 0
 8318 4888 0400A0E3 		mov	r0, #4
 8319              	.LVL756:
 8320 488c 34149FE5 		ldr	r1, .L719+140
 8321 4890 0320A0E1 		mov	r2, r3
 8322 4894 FEFFFFEB 		bl	CyU3PDebugPrint
 8323              	.LVL757:
 8324              	.L630:
 8325              	.LBB246:
 8326              	.LBB247:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8327              		.loc 1 1970 0
 8328 4898 18149FE5 		ldr	r1, .L719+124
 8329 489c 0400A0E3 		mov	r0, #4
 8330 48a0 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8331              		.loc 1 1971 0
 8332 48a4 FA0FA0E3 		mov	r0, #1000
 8333 48a8 FEFFFFEB 		bl	_tx_thread_sleep
 8334 48ac F9FFFFEA 		b	.L630
 8335              	.LVL758:
 8336              	.L702:
 8337              	.LBE247:
 8338              	.LBE246:
2659:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8339              		.loc 1 2659 0
 8340 48b0 0400A0E3 		mov	r0, #4
 8341              	.LVL759:
 8342 48b4 3C149FE5 		ldr	r1, .L719+188
 8343 48b8 FEFFFFEB 		bl	CyU3PDebugPrint
 8344              	.LVL760:
 8345              	.L628:
 8346              	.LBB248:
 8347              	.LBB249:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8348              		.loc 1 1970 0
 8349 48bc F4139FE5 		ldr	r1, .L719+124
 8350 48c0 0400A0E3 		mov	r0, #4
 8351 48c4 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8352              		.loc 1 1971 0
 8353 48c8 FA0FA0E3 		mov	r0, #1000
 8354 48cc FEFFFFEB 		bl	_tx_thread_sleep
 8355 48d0 F9FFFFEA 		b	.L628
 8356              	.LVL761:
 8357              	.L701:
 8358              	.LBE249:
 8359              	.LBE248:
2638:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8360              		.loc 1 2638 0
 8361 48d4 0400A0E3 		mov	r0, #4
 8362              	.LVL762:
 8363 48d8 1C149FE5 		ldr	r1, .L719+192
 8364 48dc FEFFFFEB 		bl	CyU3PDebugPrint
 8365              	.LVL763:
 8366              	.L626:
 8367              	.LBB250:
 8368              	.LBB251:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8369              		.loc 1 1970 0
 8370 48e0 D0139FE5 		ldr	r1, .L719+124
 8371 48e4 0400A0E3 		mov	r0, #4
 8372 48e8 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8373              		.loc 1 1971 0
 8374 48ec FA0FA0E3 		mov	r0, #1000
 8375 48f0 FEFFFFEB 		bl	_tx_thread_sleep
 8376 48f4 F9FFFFEA 		b	.L626
 8377              	.LVL764:
 8378              	.L700:
 8379              	.LBE251:
 8380              	.LBE250:
2625:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 8381              		.loc 1 2625 0
 8382 48f8 0400A0E3 		mov	r0, #4
 8383              	.LVL765:
 8384 48fc FC139FE5 		ldr	r1, .L719+196
 8385 4900 FEFFFFEB 		bl	CyU3PDebugPrint
 8386              	.LVL766:
 8387              	.L624:
 8388              	.LBB252:
 8389              	.LBB253:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8390              		.loc 1 1970 0
 8391 4904 AC139FE5 		ldr	r1, .L719+124
 8392 4908 0400A0E3 		mov	r0, #4
 8393 490c FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8394              		.loc 1 1971 0
 8395 4910 FA0FA0E3 		mov	r0, #1000
 8396 4914 FEFFFFEB 		bl	_tx_thread_sleep
 8397 4918 F9FFFFEA 		b	.L624
 8398              	.LVL767:
 8399              	.L698:
 8400              	.LBE253:
 8401              	.LBE252:
2597:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 8402              		.loc 1 2597 0
 8403 491c 0400A0E3 		mov	r0, #4
 8404              	.LVL768:
 8405 4920 DC139FE5 		ldr	r1, .L719+200
 8406 4924 FEFFFFEB 		bl	CyU3PDebugPrint
 8407              	.LVL769:
 8408              	.L620:
 8409              	.LBB254:
 8410              	.LBB255:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8411              		.loc 1 1970 0
 8412 4928 88139FE5 		ldr	r1, .L719+124
 8413 492c 0400A0E3 		mov	r0, #4
 8414 4930 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8415              		.loc 1 1971 0
 8416 4934 FA0FA0E3 		mov	r0, #1000
 8417 4938 FEFFFFEB 		bl	_tx_thread_sleep
 8418 493c F9FFFFEA 		b	.L620
 8419              	.LVL770:
 8420              	.L697:
 8421              	.LBE255:
 8422              	.LBE254:
2584:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 8423              		.loc 1 2584 0
 8424 4940 0400A0E3 		mov	r0, #4
 8425              	.LVL771:
 8426 4944 BC139FE5 		ldr	r1, .L719+204
 8427 4948 FEFFFFEB 		bl	CyU3PDebugPrint
 8428              	.LVL772:
 8429              	.L618:
 8430              	.LBB256:
 8431              	.LBB257:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8432              		.loc 1 1970 0
 8433 494c 64139FE5 		ldr	r1, .L719+124
 8434 4950 0400A0E3 		mov	r0, #4
 8435 4954 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8436              		.loc 1 1971 0
 8437 4958 FA0FA0E3 		mov	r0, #1000
 8438 495c FEFFFFEB 		bl	_tx_thread_sleep
 8439 4960 F9FFFFEA 		b	.L618
 8440              	.LVL773:
 8441              	.L699:
 8442              	.LBE257:
 8443              	.LBE256:
2611:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 8444              		.loc 1 2611 0
 8445 4964 0400A0E3 		mov	r0, #4
 8446              	.LVL774:
 8447 4968 9C139FE5 		ldr	r1, .L719+208
 8448 496c FEFFFFEB 		bl	CyU3PDebugPrint
 8449              	.LVL775:
 8450              	.L622:
 8451              	.LBB258:
 8452              	.LBB259:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8453              		.loc 1 1970 0
 8454 4970 40139FE5 		ldr	r1, .L719+124
 8455 4974 0400A0E3 		mov	r0, #4
 8456 4978 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8457              		.loc 1 1971 0
 8458 497c FA0FA0E3 		mov	r0, #1000
 8459 4980 FEFFFFEB 		bl	_tx_thread_sleep
 8460 4984 F9FFFFEA 		b	.L622
 8461              	.LVL776:
 8462              	.L708:
 8463              	.LBE259:
 8464              	.LBE258:
 8465              	.LBE261:
 8466              	.LBE277:
3048:../uvc.c      ****                 prodCount = 0;
 8467              		.loc 1 3048 0
 8468 4988 B064C5E1 		strh	r6, [r5, #64]	@ movhi
3063:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8469              		.loc 1 3063 0
 8470 498c 08039FE5 		ldr	r0, .L719+96
3049:../uvc.c      ****                 consCount = 0;
 8471              		.loc 1 3049 0
 8472 4990 B264C5E1 		strh	r6, [r5, #66]	@ movhi
3063:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8473              		.loc 1 3063 0
 8474 4994 0010E0E3 		mvn	r1, #0
3045:../uvc.c      ****             	fb=0;
 8475              		.loc 1 3045 0
 8476 4998 B463C5E1 		strh	r6, [r5, #52]	@ movhi
3046:../uvc.c      ****             	pb=0;
 8477              		.loc 1 3046 0
 8478 499c B663C5E1 		strh	r6, [r5, #54]	@ movhi
3047:../uvc.c      ****             	pbc=0;
 8479              		.loc 1 3047 0
 8480 49a0 B863C5E1 		strh	r6, [r5, #56]	@ movhi
3050:../uvc.c      ****                 hitFV     = CyFalse;
 8481              		.loc 1 3050 0
 8482 49a4 3C6085E5 		str	r6, [r5, #60]
3063:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8483              		.loc 1 3063 0
 8484 49a8 FEFFFFEB 		bl	_txe_mutex_get
3064:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 8485              		.loc 1 3064 0
 8486 49ac 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 8487 49b0 012020E2 		eor	r2, r0, #1
 8488 49b4 8124C7E5 		strb	r2, [r7, #1153]
3066:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8489              		.loc 1 3066 0
 8490 49b8 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 8491 49bc F0005CE3 		cmp	ip, #240
 8492 49c0 1800000A 		beq	.L714
 8493              	.L645:
3074:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 8494              		.loc 1 3074 0
 8495 49c4 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 8496 49c8 FF005AE3 		cmp	sl, #255
 8497 49cc 4000000A 		beq	.L715
3086:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 8498              		.loc 1 3086 0
 8499 49d0 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 8500 49d4 AA0050E3 		cmp	r0, #170
 8501 49d8 2F00000A 		beq	.L716
 8502              	.L646:
3124:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 8503              		.loc 1 3124 0
 8504 49dc B8029FE5 		ldr	r0, .L719+96
 8505 49e0 FEFFFFEB 		bl	_txe_mutex_put
3126:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8506              		.loc 1 3126 0
 8507 49e4 C0029FE5 		ldr	r0, .L719+112
 8508 49e8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8509              	.LVL777:
3127:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8510              		.loc 1 3127 0
 8511 49ec 002050E2 		subs	r2, r0, #0
 8512 49f0 2000001A 		bne	.L717
3134:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8513              		.loc 1 3134 0
 8514 49f4 0210A0E1 		mov	r1, r2
 8515 49f8 AC029FE5 		ldr	r0, .L719+112
 8516              	.LVL778:
 8517 49fc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8518              	.LVL779:
3135:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8519              		.loc 1 3135 0
 8520 4a00 002050E2 		subs	r2, r0, #0
 8521 4a04 1200001A 		bne	.L718
3143:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8522              		.loc 1 3143 0
 8523 4a08 90029FE5 		ldr	r0, .L719+100
 8524              	.LVL780:
 8525 4a0c 0210A0E1 		mov	r1, r2
 8526 4a10 02A0A0E3 		mov	sl, #2
 8527 4a14 0020A0E1 		mov	r2, r0
 8528              	.LVL781:
 8529 4a18 0130A0E1 		mov	r3, r1
 8530 4a1c 00A08DE5 		str	sl, [sp, #0]
 8531 4a20 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8532              	.LVL782:
 8533 4a24 C4FEFFEA 		b	.L644
 8534              	.L714:
3066:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8535              		.loc 1 3066 0 discriminator 1
 8536 4a28 20029FE5 		ldr	r0, .L719+20
 8537 4a2c 8010A0E3 		mov	r1, #128
 8538 4a30 0320A0E3 		mov	r2, #3
 8539 4a34 B4308DE2 		add	r3, sp, #180
 8540 4a38 00608DE5 		str	r6, [sp, #0]
 8541 4a3c FEFFFFEB 		bl	_txe_event_flags_get
 8542 4a40 000050E3 		cmp	r0, #0
3071:../uvc.c      ****                 		stiflag = 0xFF;
 8543              		.loc 1 3071 0 discriminator 1
 8544 4a44 3A80C505 		streqb	r8, [r5, #58]
3072:../uvc.c      ****                 		IMcount = 0;
 8545              		.loc 1 3072 0 discriminator 1
 8546 4a48 E160C505 		streqb	r6, [r5, #225]
3066:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8547              		.loc 1 3066 0 discriminator 1
 8548 4a4c E2FFFF0A 		beq	.L646
 8549 4a50 DBFFFFEA 		b	.L645
 8550              	.LVL783:
 8551              	.L718:
3137:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8552              		.loc 1 3137 0
 8553 4a54 0400A0E3 		mov	r0, #4
 8554              	.LVL784:
 8555 4a58 B0129FE5 		ldr	r1, .L719+212
 8556 4a5c FEFFFFEB 		bl	CyU3PDebugPrint
 8557              	.LVL785:
 8558              	.L665:
 8559              	.LBB278:
 8560              	.LBB279:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8561              		.loc 1 1970 0
 8562 4a60 50129FE5 		ldr	r1, .L719+124
 8563 4a64 0400A0E3 		mov	r0, #4
 8564 4a68 FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8565              		.loc 1 1971 0
 8566 4a6c FA0FA0E3 		mov	r0, #1000
 8567 4a70 FEFFFFEB 		bl	_tx_thread_sleep
 8568 4a74 F9FFFFEA 		b	.L665
 8569              	.LVL786:
 8570              	.L717:
 8571              	.LBE279:
 8572              	.LBE278:
3129:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 8573              		.loc 1 3129 0
 8574 4a78 0400A0E3 		mov	r0, #4
 8575              	.LVL787:
 8576 4a7c 90129FE5 		ldr	r1, .L719+216
 8577 4a80 FEFFFFEB 		bl	CyU3PDebugPrint
 8578              	.LVL788:
 8579              	.L663:
 8580              	.LBB280:
 8581              	.LBB281:
1970:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8582              		.loc 1 1970 0
 8583 4a84 2C129FE5 		ldr	r1, .L719+124
 8584 4a88 0400A0E3 		mov	r0, #4
 8585 4a8c FEFFFFEB 		bl	CyU3PDebugPrint
1971:../uvc.c      ****         CyU3PThreadSleep (1000);
 8586              		.loc 1 1971 0
 8587 4a90 FA0FA0E3 		mov	r0, #1000
 8588 4a94 FEFFFFEB 		bl	_tx_thread_sleep
 8589 4a98 F9FFFFEA 		b	.L663
 8590              	.L716:
 8591              	.LBE281:
 8592              	.LBE280:
3092:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 8593              		.loc 1 3092 0
 8594 4a9c E1E0D5E5 		ldrb	lr, [r5, #225]	@ zero_extendqisi2
 8595 4aa0 01A08EE2 		add	sl, lr, #1
 8596 4aa4 02005EE3 		cmp	lr, #2
 8597 4aa8 E1A0C5E5 		strb	sl, [r5, #225]
 8598 4aac CAFFFF9A 		bls	.L646
3094:../uvc.c      ****                     switch (setRes)
 8599              		.loc 1 3094 0
 8600 4ab0 BD30D5E5 		ldrb	r3, [r5, #189]	@ zero_extendqisi2
 8601 4ab4 011043E2 		sub	r1, r3, #1
 8602 4ab8 030051E3 		cmp	r1, #3
 8603 4abc 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 8604 4ac0 230000EA 		b	.L648
 8605              	.L653:
 8606 4ac4 B44B0000 		.word	.L649
 8607 4ac8 F84B0000 		.word	.L650
 8608 4acc 604B0000 		.word	.L651
 8609 4ad0 044B0000 		.word	.L652
 8610              	.L715:
3076:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8611              		.loc 1 3076 0
 8612 4ad4 E110D5E5 		ldrb	r1, [r5, #225]	@ zero_extendqisi2
 8613 4ad8 01E081E2 		add	lr, r1, #1
 8614 4adc 020051E3 		cmp	r1, #2
 8615 4ae0 E1E0C5E5 		strb	lr, [r5, #225]
 8616 4ae4 BCFFFF9A 		bls	.L646
3077:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8617              		.loc 1 3077 0
 8618 4ae8 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
3078:../uvc.c      ****                 		stiflag = 0x0F;
 8619              		.loc 1 3078 0
 8620 4aec 0F30A0E3 		mov	r3, #15
3077:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8621              		.loc 1 3077 0
 8622 4af0 20C082E3 		orr	ip, r2, #32
 8623 4af4 81C4C7E5 		strb	ip, [r7, #1153]
3079:../uvc.c      ****                 		IMcount = 0;
 8624              		.loc 1 3079 0
 8625 4af8 E160C5E5 		strb	r6, [r5, #225]
3078:../uvc.c      ****                 		stiflag = 0x0F;
 8626              		.loc 1 3078 0
 8627 4afc 3A30C5E5 		strb	r3, [r5, #58]
 8628 4b00 B5FFFFEA 		b	.L646
 8629              	.L652:
3112:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8630              		.loc 1 3112 0
 8631 4b04 58E094E5 		ldr	lr, [r4, #88]
 8632 4b08 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8633 4b0c 00005EE3 		cmp	lr, #0
 8634 4b10 F4E0A003 		moveq	lr, #244
 8635 4b14 74E0A013 		movne	lr, #116
 8636 4b18 03208EE1 		orr	r2, lr, r3
 8637 4b1c 3010A0E3 		mov	r1, #48
 8638 4b20 5230A0E3 		mov	r3, #82
 8639 4b24 0100A0E3 		mov	r0, #1
 8640 4b28 FEFFFFEB 		bl	SensorSetIrisControl
3114:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8641              		.loc 1 3114 0
 8642 4b2c 58C094E5 		ldr	ip, [r4, #88]
 8643 4b30 8C24D7E5 		ldrb	r2, [r7, #1164]	@ zero_extendqisi2
 8644 4b34 00005CE3 		cmp	ip, #0
 8645 4b38 F4C0A003 		moveq	ip, #244
 8646 4b3c 74C0A013 		movne	ip, #116
 8647 4b40 583094E5 		ldr	r3, [r4, #88]
 8648 4b44 0400A0E3 		mov	r0, #4
 8649 4b48 C8119FE5 		ldr	r1, .L719+220
 8650 4b4c 02208CE1 		orr	r2, ip, r2
 8651 4b50 FEFFFFEB 		bl	CyU3PDebugPrint
 8652              	.L648:
3119:../uvc.c      ****                     IMcount = 0;
 8653              		.loc 1 3119 0
 8654 4b54 E160C4E5 		strb	r6, [r4, #225]
3121:../uvc.c      ****                 	stiflag = 0x0;
 8655              		.loc 1 3121 0
 8656 4b58 3A60C4E5 		strb	r6, [r4, #58]
 8657 4b5c 9EFFFFEA 		b	.L646
 8658              	.L651:
3107:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 8659              		.loc 1 3107 0
 8660 4b60 580094E5 		ldr	r0, [r4, #88]
 8661 4b64 8CA4D7E5 		ldrb	sl, [r7, #1164]	@ zero_extendqisi2
 8662 4b68 000050E3 		cmp	r0, #0
 8663 4b6c C400A003 		moveq	r0, #196
 8664 4b70 4400A013 		movne	r0, #68
 8665 4b74 0A2080E1 		orr	r2, r0, sl
 8666 4b78 3010A0E3 		mov	r1, #48
 8667 4b7c 5230A0E3 		mov	r3, #82
 8668 4b80 0100A0E3 		mov	r0, #1
 8669 4b84 FEFFFFEB 		bl	SensorSetIrisControl
3109:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 8670              		.loc 1 3109 0
 8671 4b88 582094E5 		ldr	r2, [r4, #88]
 8672 4b8c 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 8673 4b90 000052E3 		cmp	r2, #0
 8674 4b94 C420A003 		moveq	r2, #196
 8675 4b98 4420A013 		movne	r2, #68
 8676 4b9c 583094E5 		ldr	r3, [r4, #88]
 8677 4ba0 70119FE5 		ldr	r1, .L719+220
 8678 4ba4 0C2082E1 		orr	r2, r2, ip
 8679 4ba8 0400A0E3 		mov	r0, #4
 8680 4bac FEFFFFEB 		bl	CyU3PDebugPrint
3110:../uvc.c      ****                  		break;
 8681              		.loc 1 3110 0
 8682 4bb0 E7FFFFEA 		b	.L648
 8683              	.L649:
3097:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 8684              		.loc 1 3097 0
 8685 4bb4 582094E5 		ldr	r2, [r4, #88]
 8686 4bb8 3010A0E3 		mov	r1, #48
 8687 4bbc 000052E3 		cmp	r2, #0
 8688 4bc0 E420A003 		moveq	r2, #228
 8689 4bc4 6420A013 		movne	r2, #100
 8690 4bc8 5230A0E3 		mov	r3, #82
 8691 4bcc 0100A0E3 		mov	r0, #1
 8692 4bd0 FEFFFFEB 		bl	SensorSetIrisControl
3099:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 8693              		.loc 1 3099 0
 8694 4bd4 582094E5 		ldr	r2, [r4, #88]
 8695 4bd8 38119FE5 		ldr	r1, .L719+220
 8696 4bdc 000052E3 		cmp	r2, #0
 8697 4be0 583094E5 		ldr	r3, [r4, #88]
 8698 4be4 E420A003 		moveq	r2, #228
 8699 4be8 6420A013 		movne	r2, #100
 8700 4bec 0400A0E3 		mov	r0, #4
 8701 4bf0 FEFFFFEB 		bl	CyU3PDebugPrint
3100:../uvc.c      ****                  		break;
 8702              		.loc 1 3100 0
 8703 4bf4 D6FFFFEA 		b	.L648
 8704              	.L650:
3102:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 8705              		.loc 1 3102 0
 8706 4bf8 582094E5 		ldr	r2, [r4, #88]
 8707 4bfc 3010A0E3 		mov	r1, #48
 8708 4c00 000052E3 		cmp	r2, #0
 8709 4c04 D420A003 		moveq	r2, #212
 8710 4c08 5420A013 		movne	r2, #84
 8711 4c0c 5230A0E3 		mov	r3, #82
 8712 4c10 0100A0E3 		mov	r0, #1
 8713 4c14 FEFFFFEB 		bl	SensorSetIrisControl
3104:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 8714              		.loc 1 3104 0
 8715 4c18 582094E5 		ldr	r2, [r4, #88]
 8716 4c1c F4109FE5 		ldr	r1, .L719+220
 8717 4c20 000052E3 		cmp	r2, #0
 8718 4c24 583094E5 		ldr	r3, [r4, #88]
 8719 4c28 D420A003 		moveq	r2, #212
 8720 4c2c 5420A013 		movne	r2, #84
 8721 4c30 0400A0E3 		mov	r0, #4
 8722 4c34 FEFFFFEB 		bl	CyU3PDebugPrint
3105:../uvc.c      ****                  		break;
 8723              		.loc 1 3105 0
 8724 4c38 C5FFFFEA 		b	.L648
 8725              	.L720:
 8726              		.align	2
 8727              	.L719:
 8728 4c3c 78080000 		.word	.LC48
 8729 4c40 00C20100 		.word	115200
 8730 4c44 98080000 		.word	.LC49
 8731 4c48 A0860100 		.word	100000
 8732 4c4c B4080000 		.word	.LC50
 8733 4c50 00000000 		.word	.LANCHOR0
 8734 4c54 00000000 		.word	CyFxGpifCB
 8735 4c58 88130000 		.word	5000
 8736 4c5c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8737 4c60 00000000 		.word	CyFxUVCApplnUSBEventCB
 8738 4c64 00000000 		.word	CyFxUSBDeviceDscr
 8739 4c68 00000000 		.word	CyFxUSBDeviceDscrSS
 8740 4c6c 00000000 		.word	CyFxUSBDeviceQualDscr
 8741 4c70 00000000 		.word	CyFxUSBBOSDscr
 8742 4c74 00000000 		.word	CyFxUSBHSConfigDscr
 8743 4c78 00000000 		.word	CyFxUSBFSConfigDscr
 8744 4c7c 00000000 		.word	CyFxUSBSSConfigDscr
 8745 4c80 00000000 		.word	CyFxUSBStringLangIDDscr
 8746 4c84 00000000 		.word	CyFxUSBManufactureDscr
 8747 4c88 00000000 		.word	CyFxUSBProductDscr
 8748 4c8c 013F0000 		.word	16129
 8749 4c90 02030000 		.word	770
 8750 4c94 00000000 		.word	glChHandleInterStat
 8751 4c98 00000000 		.word	glInterStaBuffer
 8752 4c9c 00000000 		.word	imgHdMux
 8753 4ca0 01010000 		.word	257
 8754 4ca4 03030000 		.word	771
 8755 4ca8 00000000 		.word	CyFxUvcApplnDmaCallback
 8756 4cac 00000000 		.word	glChHandleUVCStream
 8757 4cb0 00000000 		.word	.LANCHOR1
 8758 4cb4 D0080000 		.word	.LC51
 8759 4cb8 F0010000 		.word	.LC13
 8760 4cbc 20090000 		.word	.LC53
 8761 4cc0 FC080000 		.word	.LC52
 8762 4cc4 48090000 		.word	.LC54
 8763 4cc8 A00A0000 		.word	.LC61
 8764 4ccc 7C0B0000 		.word	.LC65
 8765 4cd0 4C0B0000 		.word	.LC64
 8766 4cd4 140B0000 		.word	.LC63
 8767 4cd8 D40A0000 		.word	.LC62
 8768 4cdc 6C0C0000 		.word	.LC71
 8769 4ce0 BC000000 		.word	.LANCHOR2+188
 8770 4ce4 B40C0000 		.word	.LC73
 8771 4ce8 5C0C0000 		.word	.LC70
 8772 4cec A0000000 		.word	.LANCHOR2+160
 8773 4cf0 7C0C0000 		.word	.LC72
 8774 4cf4 280C0000 		.word	.LC69
 8775 4cf8 700A0000 		.word	.LC60
 8776 4cfc 400A0000 		.word	.LC59
 8777 4d00 080A0000 		.word	.LC58
 8778 4d04 A0090000 		.word	.LC56
 8779 4d08 74090000 		.word	.LC55
 8780 4d0c D4090000 		.word	.LC57
 8781 4d10 F40B0000 		.word	.LC68
 8782 4d14 C80B0000 		.word	.LC67
 8783 4d18 A40B0000 		.word	.LC66
 8784              		.cfi_endproc
 8785              	.LFE19:
 8787              		.align	2
 8788              		.global	CyFxApplicationDefine
 8790              	CyFxApplicationDefine:
 8791              	.LFB27:
4578:../uvc.c      **** }
4579:../uvc.c      **** 
4580:../uvc.c      **** 
4581:../uvc.c      **** /*
4582:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4583:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4584:../uvc.c      ****  */
4585:../uvc.c      **** void
4586:../uvc.c      **** CyFxApplicationDefine (
4587:../uvc.c      ****         void)
4588:../uvc.c      **** {
 8792              		.loc 1 4588 0
 8793              		.cfi_startproc
 8794              		@ args = 0, pretend = 0, frame = 32
 8795              		@ frame_needed = 0, uses_anonymous_args = 0
 8796              	.LVL789:
 8797 4d1c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8798              	.LCFI28:
 8799              		.cfi_def_cfa_offset 36
4589:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4590:../uvc.c      ****     uint32_t retThrdCreate;
4591:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4592:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4593:../uvc.c      **** 
4594:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4595:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8800              		.loc 1 4595 0
 8801 4d20 010AA0E3 		mov	r0, #4096
4588:../uvc.c      **** {
 8802              		.loc 1 4588 0
 8803 4d24 44D04DE2 		sub	sp, sp, #68
 8804              	.LCFI29:
 8805              		.cfi_def_cfa_offset 104
 8806              		.loc 1 4595 0
 8807              		.cfi_offset 14, -4
 8808              		.cfi_offset 11, -8
 8809              		.cfi_offset 10, -12
 8810              		.cfi_offset 9, -16
 8811              		.cfi_offset 8, -20
 8812              		.cfi_offset 7, -24
 8813              		.cfi_offset 6, -28
 8814              		.cfi_offset 5, -32
 8815              		.cfi_offset 4, -36
 8816 4d28 FEFFFFEB 		bl	CyU3PMemAlloc
 8817 4d2c 00A0A0E1 		mov	sl, r0
 8818              	.LVL790:
4596:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8819              		.loc 1 4596 0
 8820 4d30 010AA0E3 		mov	r0, #4096
 8821              	.LVL791:
 8822 4d34 FEFFFFEB 		bl	CyU3PMemAlloc
 8823 4d38 0090A0E1 		mov	r9, r0
 8824              	.LVL792:
4597:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8825              		.loc 1 4597 0
 8826 4d3c 010AA0E3 		mov	r0, #4096
 8827              	.LVL793:
 8828 4d40 FEFFFFEB 		bl	CyU3PMemAlloc
4598:../uvc.c      **** 
4599:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 8829              		.loc 1 4599 0
 8830 4d44 00005AE3 		cmp	sl, #0
 8831 4d48 00005913 		cmpne	r9, #0
 8832 4d4c 0070A013 		movne	r7, #0
 8833 4d50 0170A003 		moveq	r7, #1
4597:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8834              		.loc 1 4597 0
 8835 4d54 00B0A0E1 		mov	fp, r0
 8836              	.LVL794:
 8837              		.loc 1 4599 0
 8838 4d58 0000001A 		bne	.L725
 8839              	.LVL795:
 8840              	.L722:
 8841              	.L724:
 8842 4d5c FEFFFFEA 		b	.L724
 8843              	.L725:
 8844              		.loc 1 4599 0 is_stmt 0 discriminator 1
 8845 4d60 000050E3 		cmp	r0, #0
 8846 4d64 FCFFFF0A 		beq	.L722
 8847              	.LVL796:
4600:../uvc.c      ****         goto fatalErrorHandler;
4601:../uvc.c      **** 
4602:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4603:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4604:../uvc.c      ****     char *staName = "I2CstaQue";
4605:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8848              		.loc 1 4605 0 is_stmt 1
 8849 4d68 38819FE5 		ldr	r8, .L726
 8850 4d6c 20408DE2 		add	r4, sp, #32
 8851 4d70 0400A0E1 		mov	r0, r4
 8852 4d74 4010A0E3 		mov	r1, #64
 8853 4d78 2C219FE5 		ldr	r2, .L726+4
 8854 4d7c 0730A0E1 		mov	r3, r7
 8855 4d80 0450A0E1 		mov	r5, r4
 8856 4d84 00808DE5 		str	r8, [sp, #0]
 8857 4d88 FEFFFFEB 		bl	cmdbufCreate
 8858 4d8c 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 8859 4d90 18619FE5 		ldr	r6, .L726+8
4606:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 8860              		.loc 1 4606 0
 8861 4d94 18C19FE5 		ldr	ip, .L726+12
4605:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8862              		.loc 1 4605 0
 8863 4d98 06E0A0E1 		mov	lr, r6
 8864 4d9c 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 8865              		.loc 1 4606 0
 8866 4da0 10819FE5 		ldr	r8, .L726+16
4605:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8867              		.loc 1 4605 0
 8868 4da4 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 8869              		.loc 1 4606 0
 8870 4da8 00C08DE5 		str	ip, [sp, #0]
4605:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8871              		.loc 1 4605 0
 8872 4dac 0F008EE8 		stmia	lr, {r0, r1, r2, r3}
 8873              		.loc 1 4606 0
 8874 4db0 04219FE5 		ldr	r2, .L726+20
 8875 4db4 0400A0E1 		mov	r0, r4
 8876 4db8 4010A0E3 		mov	r1, #64
 8877 4dbc 0130A0E3 		mov	r3, #1
 8878 4dc0 FEFFFFEB 		bl	cmdbufCreate
 8879 4dc4 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 8880 4dc8 08C0A0E1 		mov	ip, r8
 8881 4dcc 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8882 4dd0 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4607:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4608:../uvc.c      **** 
4609:../uvc.c      **** 	/****** initialize command descriptor ***********/
4610:../uvc.c      **** 	cmdquInit(cmdQuptr);
4611:../uvc.c      **** 	cmdquInit(statQuptr);
4612:../uvc.c      **** 
4613:../uvc.c      ****     /* Create the UVC application thread. */
4614:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 8883              		.loc 1 4614 0
 8884 4dd4 0840A0E3 		mov	r4, #8
4606:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 8885              		.loc 1 4606 0
 8886 4dd8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4610:../uvc.c      **** 	cmdquInit(cmdQuptr);
 8887              		.loc 1 4610 0
 8888 4ddc 0600A0E1 		mov	r0, r6
 8889 4de0 FEFFFFEB 		bl	cmdquInit
4611:../uvc.c      **** 	cmdquInit(statQuptr);
 8890              		.loc 1 4611 0
 8891 4de4 0800A0E1 		mov	r0, r8
 8892 4de8 FEFFFFEB 		bl	cmdquInit
 8893              		.loc 1 4614 0
 8894 4dec 0150A0E3 		mov	r5, #1
 8895 4df0 01CAA0E3 		mov	ip, #4096
 8896 4df4 A860A0E3 		mov	r6, #168
 8897 4df8 C0009FE5 		ldr	r0, .L726+24
 8898 4dfc C0109FE5 		ldr	r1, .L726+28
 8899 4e00 C0209FE5 		ldr	r2, .L726+32
 8900 4e04 0730A0E1 		mov	r3, r7
 8901 4e08 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 8902 4e0c 08408DE5 		str	r4, [sp, #8]
 8903 4e10 0C408DE5 		str	r4, [sp, #12]
 8904 4e14 10708DE5 		str	r7, [sp, #16]
 8905 4e18 14508DE5 		str	r5, [sp, #20]
 8906 4e1c 18608DE5 		str	r6, [sp, #24]
 8907 4e20 FEFFFFEB 		bl	_txe_thread_create
 8908              	.LVL797:
4615:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4616:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4617:../uvc.c      ****             0,                                          /* No input parameter to thread */
4618:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4619:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4620:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4621:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4622:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4623:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4624:../uvc.c      ****             );
4625:../uvc.c      ****     if (retThrdCreate != 0)
 8909              		.loc 1 4625 0
 8910 4e24 00C050E2 		subs	ip, r0, #0
 8911 4e28 CBFFFF1A 		bne	.L722
4626:../uvc.c      ****     {
4627:../uvc.c      ****         goto fatalErrorHandler;
4628:../uvc.c      ****     }
4629:../uvc.c      **** 
4630:../uvc.c      ****     /* Create the control request handling thread. */
4631:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 8912              		.loc 1 4631 0
 8913 4e2c 0C30A0E1 		mov	r3, ip
 8914 4e30 027BA0E3 		mov	r7, #2048
 8915 4e34 90009FE5 		ldr	r0, .L726+36
 8916              	.LVL798:
 8917 4e38 90109FE5 		ldr	r1, .L726+40
 8918 4e3c 90209FE5 		ldr	r2, .L726+44
 8919 4e40 10C08DE5 		str	ip, [sp, #16]
 8920 4e44 00908DE5 		str	r9, [sp, #0]
 8921 4e48 04708DE5 		str	r7, [sp, #4]
 8922 4e4c 08408DE5 		str	r4, [sp, #8]
 8923 4e50 0C408DE5 		str	r4, [sp, #12]
 8924 4e54 14508DE5 		str	r5, [sp, #20]
 8925 4e58 18608DE5 		str	r6, [sp, #24]
 8926 4e5c FEFFFFEB 		bl	_txe_thread_create
 8927              	.LVL799:
4632:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4633:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4634:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4635:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4636:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4637:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4638:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4639:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4640:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4641:../uvc.c      ****             );
4642:../uvc.c      ****     if (retThrdCreate != 0)
 8928              		.loc 1 4642 0
 8929 4e60 00C050E2 		subs	ip, r0, #0
 8930 4e64 BCFFFF1A 		bne	.L722
4643:../uvc.c      ****     {
4644:../uvc.c      ****         goto fatalErrorHandler;
4645:../uvc.c      ****     }
4646:../uvc.c      **** #if 1
4647:../uvc.c      ****     /* Create the I2C control command handling thread. */
4648:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 8931              		.loc 1 4648 0
 8932 4e68 68009FE5 		ldr	r0, .L726+48
 8933              	.LVL800:
 8934 4e6c 68109FE5 		ldr	r1, .L726+52
 8935 4e70 68209FE5 		ldr	r2, .L726+56
 8936 4e74 0C30A0E1 		mov	r3, ip
 8937 4e78 00B08DE5 		str	fp, [sp, #0]
 8938 4e7c 04708DE5 		str	r7, [sp, #4]
 8939 4e80 08408DE5 		str	r4, [sp, #8]
 8940 4e84 0C408DE5 		str	r4, [sp, #12]
 8941 4e88 10C08DE5 		str	ip, [sp, #16]
 8942 4e8c 14508DE5 		str	r5, [sp, #20]
 8943 4e90 18608DE5 		str	r6, [sp, #24]
 8944 4e94 FEFFFFEB 		bl	_txe_thread_create
 8945              	.LVL801:
4649:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4650:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4651:../uvc.c      ****             0,                                          /* No input parameter to thread */
4652:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4653:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4654:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4655:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4656:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4657:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4658:../uvc.c      ****             );
4659:../uvc.c      ****     if (retThrdCreate != 0)
 8946              		.loc 1 4659 0
 8947 4e98 000050E3 		cmp	r0, #0
 8948 4e9c AEFFFF1A 		bne	.L722
4660:../uvc.c      ****     {
4661:../uvc.c      ****         goto fatalErrorHandler;
4662:../uvc.c      ****     }
4663:../uvc.c      **** #endif
4664:../uvc.c      **** 
4665:../uvc.c      ****     return;
4666:../uvc.c      **** 
4667:../uvc.c      **** fatalErrorHandler:
4668:../uvc.c      ****     /* Add custom recovery or debug actions here */
4669:../uvc.c      ****     /* Loop indefinitely */
4670:../uvc.c      ****     while (1);
4671:../uvc.c      **** }
 8949              		.loc 1 4671 0
 8950 4ea0 44D08DE2 		add	sp, sp, #68
 8951 4ea4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8952              	.L727:
 8953              		.align	2
 8954              	.L726:
 8955 4ea8 00000000 		.word	cmdQuMux
 8956 4eac EC0C0000 		.word	.LC74
 8957 4eb0 00000000 		.word	cmdQu
 8958 4eb4 00000000 		.word	staQuMux
 8959 4eb8 00000000 		.word	statQu
 8960 4ebc F80C0000 		.word	.LC75
 8961 4ec0 E4000000 		.word	.LANCHOR0+228
 8962 4ec4 040D0000 		.word	.LC76
 8963 4ec8 00000000 		.word	UVCAppThread_Entry
 8964 4ecc 8C010000 		.word	.LANCHOR0+396
 8965 4ed0 180D0000 		.word	.LC77
 8966 4ed4 00000000 		.word	UVCAppEP0Thread_Entry
 8967 4ed8 34020000 		.word	.LANCHOR0+564
 8968 4edc 300D0000 		.word	.LC78
 8969 4ee0 00000000 		.word	I2cAppThread_Entry
 8970              		.cfi_endproc
 8971              	.LFE27:
 8973              		.align	2
 8974              		.global	main
 8976              	main:
 8977              	.LFB28:
4672:../uvc.c      **** 
4673:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4674:../uvc.c      ****  * the ThreadX RTOS here.
4675:../uvc.c      ****  */
4676:../uvc.c      **** int
4677:../uvc.c      **** main (
4678:../uvc.c      ****         void)
4679:../uvc.c      **** {
 8978              		.loc 1 4679 0
 8979              		.cfi_startproc
 8980              		@ args = 0, pretend = 0, frame = 56
 8981              		@ frame_needed = 0, uses_anonymous_args = 0
 8982 4ee4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 8983              	.LCFI30:
 8984              		.cfi_def_cfa_offset 12
4680:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4681:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4682:../uvc.c      **** 
4683:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4684:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4685:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4686:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4687:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4688:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8985              		.loc 1 4688 0
 8986 4ee8 0010A0E3 		mov	r1, #0
4679:../uvc.c      **** {
 8987              		.loc 1 4679 0
 8988 4eec 3CD04DE2 		sub	sp, sp, #60
 8989              	.LCFI31:
 8990              		.cfi_def_cfa_offset 72
4685:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8991              		.loc 1 4685 0
 8992 4ef0 0220A0E3 		mov	r2, #2
4689:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8993              		.loc 1 4689 0
 8994 4ef4 033081E2 		add	r3, r1, #3
4684:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8995              		.loc 1 4684 0
 8996 4ef8 0150A0E3 		mov	r5, #1
 8997              		.cfi_offset 14, -4
 8998              		.cfi_offset 5, -8
 8999              		.cfi_offset 4, -12
4690:../uvc.c      **** 
4691:../uvc.c      ****     /* Initialize the device */
4692:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9000              		.loc 1 4692 0
 9001 4efc 28008DE2 		add	r0, sp, #40
4684:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9002              		.loc 1 4684 0
 9003 4f00 28508DE5 		str	r5, [sp, #40]
4685:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9004              		.loc 1 4685 0
 9005 4f04 2C20CDE5 		strb	r2, [sp, #44]
4686:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9006              		.loc 1 4686 0
 9007 4f08 2D20CDE5 		strb	r2, [sp, #45]
4687:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9008              		.loc 1 4687 0
 9009 4f0c 2E20CDE5 		strb	r2, [sp, #46]
4688:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9010              		.loc 1 4688 0
 9011 4f10 30108DE5 		str	r1, [sp, #48]
4689:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9012              		.loc 1 4689 0
 9013 4f14 3430CDE5 		strb	r3, [sp, #52]
 9014              		.loc 1 4692 0
 9015 4f18 FEFFFFEB 		bl	CyU3PDeviceInit
 9016              	.LVL802:
4693:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9017              		.loc 1 4693 0
 9018 4f1c 004050E2 		subs	r4, r0, #0
 9019 4f20 0000000A 		beq	.L731
 9020              	.L729:
 9021              	.L730:
 9022 4f24 FEFFFFEA 		b	.L730
 9023              	.L731:
4694:../uvc.c      ****     {
4695:../uvc.c      ****         goto handle_fatal_error;
4696:../uvc.c      ****     }
4697:../uvc.c      **** 
4698:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4699:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 9024              		.loc 1 4699 0
 9025 4f28 0410A0E1 		mov	r1, r4
 9026 4f2c 0420A0E1 		mov	r2, r4
 9027 4f30 0500A0E1 		mov	r0, r5
 9028              	.LVL803:
 9029 4f34 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 9030              	.LVL804:
4700:../uvc.c      **** 
4701:../uvc.c      ****     /* Configure the IO matrix for the device. */
4702:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4703:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4704:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4705:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4706:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4707:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4708:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4709:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4710:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4711:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4712:../uvc.c      **** 
4713:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 9031              		.loc 1 4713 0
 9032 4f38 0D00A0E1 		mov	r0, sp
4703:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 9033              		.loc 1 4703 0
 9034 4f3c 1640CDE5 		strb	r4, [sp, #22]
4704:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 9035              		.loc 1 4704 0
 9036 4f40 18408DE5 		str	r4, [sp, #24]
4705:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 9037              		.loc 1 4705 0
 9038 4f44 1C408DE5 		str	r4, [sp, #28]
4706:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 9039              		.loc 1 4706 0
 9040 4f48 20408DE5 		str	r4, [sp, #32]
4707:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 9041              		.loc 1 4707 0
 9042 4f4c 24408DE5 		str	r4, [sp, #36]
4710:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 9043              		.loc 1 4710 0
 9044 4f50 0C408DE5 		str	r4, [sp, #12]
4711:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 9045              		.loc 1 4711 0
 9046 4f54 10408DE5 		str	r4, [sp, #16]
4702:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 9047              		.loc 1 4702 0
 9048 4f58 00508DE5 		str	r5, [sp, #0]
4708:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 9049              		.loc 1 4708 0
 9050 4f5c 04508DE5 		str	r5, [sp, #4]
4709:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 9051              		.loc 1 4709 0
 9052 4f60 08508DE5 		str	r5, [sp, #8]
 9053              		.loc 1 4713 0
 9054 4f64 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 9055              	.LVL805:
4714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9056              		.loc 1 4714 0
 9057 4f68 004050E2 		subs	r4, r0, #0
 9058 4f6c ECFFFF1A 		bne	.L729
4715:../uvc.c      ****     {
4716:../uvc.c      ****         goto handle_fatal_error;
4717:../uvc.c      ****     }
4718:../uvc.c      **** 
4719:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4720:../uvc.c      ****     CyU3PKernelEntry ();
 9059              		.loc 1 4720 0
 9060 4f70 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 9061              	.LVL806:
4721:../uvc.c      **** 
4722:../uvc.c      ****     /* Dummy return to make the compiler happy */
4723:../uvc.c      ****     return 0;
4724:../uvc.c      **** 
4725:../uvc.c      **** handle_fatal_error:
4726:../uvc.c      ****     /* Cannot recover from this error. */
4727:../uvc.c      ****     while (1);
4728:../uvc.c      **** }
 9062              		.loc 1 4728 0
 9063 4f74 0400A0E1 		mov	r0, r4
 9064 4f78 3CD08DE2 		add	sp, sp, #60
 9065 4f7c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 9066              		.cfi_endproc
 9067              	.LFE28:
 9069              		.global	CyFxGpifTransition
 9070              		.global	CyFxGpifWavedata
 9071              		.global	CyFxGpifWavedataPosition
 9072              		.global	CyFxGpifRegValue
 9073              		.global	CyFxGpifConfig
 9074              		.global	CyFxGpifTransition_usb2
 9075              		.global	CyFxGpifWavedata_usb2
 9076              		.global	CyFxGpifWavedataPosition_usb2
 9077              		.global	CyFxGpifRegValue_usb2
 9078              		.global	CyFxGpifConfig_usb2
 9079              		.global	snapButFlag
 9080              		.global	testSnap
 9081              		.global	fb
 9082              		.global	pb
 9083              		.global	pbc
 9084              		.global	fbbak
 9085              		.global	pbbak
 9086              		.global	pbcbak
 9087              		.global	pbcpbak
 9088              		.global	isUsbConnected
 9089              		.global	usbSpeed
 9090              		.global	clearFeatureRqtReceived
 9091              		.global	streamingStarted
 9092              		.global	glProbeCtrl
 9093              		.global	glProbeCtrlFull
 9094              		.global	glProbeStilCtrl
 9095              		.global	glProbeCtrl20
 9096              		.global	glProbeStilCtrl20
 9097              		.global	glUVCHeader
 9098              		.comm	glChHandleUVCStream,220,4
 9099              		.comm	glChHandleStillStream,220,4
 9100              		.comm	glChHandleInterStat,160,4
 9101              		.comm	glInterStaBuffer,4,4
 9102              		.comm	cmdQu,32,4
 9103              		.comm	statQu,32,4
 9104              		.comm	cmdQuMux,56,4
 9105              		.comm	staQuMux,56,4
 9106              		.comm	timMux,56,4
 9107              		.comm	imgHdMux,56,4
 9108              		.comm	bmReqType,1,1
 9109              		.comm	bRequest,1,1
 9110              		.comm	wValue,2,2
 9111              		.comm	wIndex,2,2
 9112              		.comm	wLength,2,2
 9113              		.comm	posTick,4,4
 9114              		.comm	I2CCmdTimer,44,4
 9115              		.section	.rodata
 9116              		.align	2
 9117              		.set	.LANCHOR2,. + 0
 9120              	ShutSp:
 9121 0000 3582     		.short	-32203
 9122 0002 1B41     		.short	16667
 9123 0004 8D20     		.short	8333
 9124 0006 A00F     		.short	4000
 9125 0008 D007     		.short	2000
 9126 000a E803     		.short	1000
 9127 000c F401     		.short	500
 9128 000e C800     		.short	200
 9129 0010 6400     		.short	100
 9130 0012 0A00     		.short	10
 9131 0014 0000     		.short	0
 9132 0016 00000000 		.space	10
 9132      00000000 
 9132      0000
 9135              	pEXTSenCtrl:
 9136 0020 90040000 		.word	EXTShutter
 9137 0024 00000000 		.word	0
 9138 0028 00000000 		.word	0
 9139 002c 00000000 		.word	0
 9140 0030 00000000 		.word	0
 9141 0034 00000000 		.word	0
 9142 0038 00000000 		.word	0
 9143 003c 00000000 		.word	0
 9144 0040 00000000 		.word	0
 9145 0044 B8040000 		.word	EXTAexModGainlev
 9146 0048 00000000 		.word	0
 9147 004c A4040000 		.word	EXTShutlev
 9148 0050 00000000 		.word	0
 9149 0054 00000000 		.word	0
 9150 0058 00000000 		.word	0
 9151 005c 00000000 		.word	0
 9152 0060 00000000 		.word	0
 9153 0064 00000000 		.word	0
 9154 0068 00000000 		.word	0
 9155 006c 00000000 		.word	0
 9156 0070 F8040000 		.word	EXTBLCWinPos
 9157 0074 0C050000 		.word	EXTBLCWeight
 9158 0078 00000000 		.word	0
 9159 007c 00000000 		.word	0
 9160 0080 00000000 		.space	32
 9160      00000000 
 9160      00000000 
 9160      00000000 
 9160      00000000 
 9163              	CyFxGpifConfig:
 9164 00a0 0F00     		.short	15
 9165 00a2 0000     		.space	2
 9166 00a4 00000000 		.word	CyFxGpifWavedata
 9167 00a8 00000000 		.word	CyFxGpifWavedataPosition
 9168 00ac 0500     		.short	5
 9169 00ae 0000     		.space	2
 9170 00b0 00000000 		.word	CyFxGpifTransition
 9171 00b4 4C00     		.short	76
 9172 00b6 0000     		.space	2
 9173 00b8 00000000 		.word	CyFxGpifRegValue
 9176              	CyFxGpifConfig_usb2:
 9177 00bc 9300     		.short	147
 9178 00be 0000     		.space	2
 9179 00c0 00000000 		.word	CyFxGpifWavedata_usb2
 9180 00c4 00000000 		.word	CyFxGpifWavedataPosition_usb2
 9181 00c8 0800     		.short	8
 9182 00ca 0000     		.space	2
 9183 00cc 00000000 		.word	CyFxGpifTransition_usb2
 9184 00d0 4C00     		.short	76
 9185 00d2 0000     		.space	2
 9186 00d4 00000000 		.word	CyFxGpifRegValue_usb2
 9187              		.data
 9188              		.align	2
 9189              		.set	.LANCHOR1,. + 0
 9192              	ExUCtrlParArry:
 9193 0000 00       		.byte	0
 9194 0001 00       		.byte	0
 9195 0002 04       		.byte	4
 9196 0003 01       		.byte	1
 9197 0004 00       		.byte	0
 9198 0005 38       		.byte	56
 9199 0006 01       		.byte	1
 9200 0007 01       		.byte	1
 9201 0008 00       		.byte	0
 9202 0009 03       		.byte	3
 9203 000a 00       		.byte	0
 9204 000b 4E       		.byte	78
 9205 000c 00       		.byte	0
 9206 000d 4E       		.byte	78
 9207 000e 00       		.byte	0
 9208 000f 30       		.byte	48
 9209 0010 01       		.byte	1
 9210 0011 00       		.byte	0
 9211 0012 00       		.byte	0
 9212 0013 00000000 		.space	5
 9212      00
 9213 0018 00       		.byte	0
 9214 0019 00       		.byte	0
 9215 001a 01       		.byte	1
 9216 001b 00       		.byte	0
 9217 001c 00       		.byte	0
 9218 001d 00       		.byte	0
 9219 001e 00       		.byte	0
 9220 001f 01       		.byte	1
 9221 0020 00       		.byte	0
 9222 0021 03       		.byte	3
 9223 0022 00       		.byte	0
 9224 0023 00       		.byte	0
 9225 0024 00       		.byte	0
 9226 0025 00       		.byte	0
 9227 0026 00       		.byte	0
 9228 0027 30       		.byte	48
 9229 0028 01       		.byte	1
 9230 0029 00       		.byte	0
 9231 002a 00       		.byte	0
 9232 002b 00000000 		.space	5
 9232      00
 9233 0030 00       		.byte	0
 9234 0031 00       		.byte	0
 9235 0032 02       		.byte	2
 9236 0033 00       		.byte	0
 9237 0034 00       		.byte	0
 9238 0035 FF       		.byte	-1
 9239 0036 00       		.byte	0
 9240 0037 01       		.byte	1
 9241 0038 00       		.byte	0
 9242 0039 03       		.byte	3
 9243 003a 00       		.byte	0
 9244 003b 01       		.byte	1
 9245 003c 00       		.byte	0
 9246 003d 00       		.byte	0
 9247 003e 00       		.byte	0
 9248 003f 30       		.byte	48
 9249 0040 01       		.byte	1
 9250 0041 01       		.byte	1
 9251 0042 00       		.byte	0
 9252 0043 00000000 		.space	5
 9252      00
 9253 0048 00       		.byte	0
 9254 0049 00       		.byte	0
 9255 004a 02       		.byte	2
 9256 004b 00       		.byte	0
 9257 004c 00       		.byte	0
 9258 004d 00       		.byte	0
 9259 004e 00       		.byte	0
 9260 004f 00       		.byte	0
 9261 0050 00       		.byte	0
 9262 0051 03       		.byte	3
 9263 0052 00       		.byte	0
 9264 0053 00       		.byte	0
 9265 0054 00       		.byte	0
 9266 0055 00       		.byte	0
 9267 0056 00       		.byte	0
 9268 0057 30       		.byte	48
 9269 0058 01       		.byte	1
 9270 0059 01       		.byte	1
 9271 005a 00       		.byte	0
 9272 005b 00000000 		.space	5
 9272      00
 9273 0060 13       		.byte	19
 9274 0061 14       		.byte	20
 9275 0062 02       		.byte	2
 9276 0063 00       		.byte	0
 9277 0064 00       		.byte	0
 9278 0065 FF       		.byte	-1
 9279 0066 FF       		.byte	-1
 9280 0067 01       		.byte	1
 9281 0068 00       		.byte	0
 9282 0069 03       		.byte	3
 9283 006a 00       		.byte	0
 9284 006b 66       		.byte	102
 9285 006c 66       		.byte	102
 9286 006d 66       		.byte	102
 9287 006e 66       		.byte	102
 9288 006f 30       		.byte	48
 9289 0070 01       		.byte	1
 9290 0071 00       		.byte	0
 9291 0072 00       		.byte	0
 9292 0073 00000000 		.space	5
 9292      00
 9293 0078 11       		.byte	17
 9294 0079 00       		.byte	0
 9295 007a 02       		.byte	2
 9296 007b 01       		.byte	1
 9297 007c 00       		.byte	0
 9298 007d 03       		.byte	3
 9299 007e 00       		.byte	0
 9300 007f 01       		.byte	1
 9301 0080 00       		.byte	0
 9302 0081 03       		.byte	3
 9303 0082 00       		.byte	0
 9304 0083 80       		.byte	-128
 9305 0084 00       		.byte	0
 9306 0085 80       		.byte	-128
 9307 0086 00       		.byte	0
 9308 0087 30       		.byte	48
 9309 0088 01       		.byte	1
 9310 0089 01       		.byte	1
 9311 008a 00       		.byte	0
 9312 008b 00000000 		.space	5
 9312      00
 9313 0090 10       		.byte	16
 9314 0091 00       		.byte	0
 9315 0092 01       		.byte	1
 9316 0093 01       		.byte	1
 9317 0094 00       		.byte	0
 9318 0095 02       		.byte	2
 9319 0096 00       		.byte	0
 9320 0097 01       		.byte	1
 9321 0098 00       		.byte	0
 9322 0099 03       		.byte	3
 9323 009a 00       		.byte	0
 9324 009b 00       		.byte	0
 9325 009c 00       		.byte	0
 9326 009d 00       		.byte	0
 9327 009e 00       		.byte	0
 9328 009f 30       		.byte	48
 9329 00a0 01       		.byte	1
 9330 00a1 01       		.byte	1
 9331 00a2 00       		.byte	0
 9332 00a3 00000000 		.space	5
 9332      00
 9333 00a8 00       		.byte	0
 9334 00a9 00       		.byte	0
 9335 00aa 04       		.byte	4
 9336 00ab 01       		.byte	1
 9337 00ac 00       		.byte	0
 9338 00ad 38       		.byte	56
 9339 00ae 01       		.byte	1
 9340 00af 01       		.byte	1
 9341 00b0 00       		.byte	0
 9342 00b1 03       		.byte	3
 9343 00b2 00       		.byte	0
 9344 00b3 4E       		.byte	78
 9345 00b4 00       		.byte	0
 9346 00b5 4E       		.byte	78
 9347 00b6 00       		.byte	0
 9348 00b7 30       		.byte	48
 9349 00b8 01       		.byte	1
 9350 00b9 00       		.byte	0
 9351 00ba 00       		.byte	0
 9352 00bb 00000000 		.space	5
 9352      00
 9353 00c0 00       		.byte	0
 9354 00c1 00       		.byte	0
 9355 00c2 01       		.byte	1
 9356 00c3 00       		.byte	0
 9357 00c4 00       		.byte	0
 9358 00c5 00       		.byte	0
 9359 00c6 00       		.byte	0
 9360 00c7 01       		.byte	1
 9361 00c8 00       		.byte	0
 9362 00c9 03       		.byte	3
 9363 00ca 00       		.byte	0
 9364 00cb 00       		.byte	0
 9365 00cc 00       		.byte	0
 9366 00cd 00       		.byte	0
 9367 00ce 00       		.byte	0
 9368 00cf 30       		.byte	48
 9369 00d0 01       		.byte	1
 9370 00d1 00       		.byte	0
 9371 00d2 00       		.byte	0
 9372 00d3 00000000 		.space	5
 9372      00
 9373 00d8 00       		.byte	0
 9374 00d9 00       		.byte	0
 9375 00da 02       		.byte	2
 9376 00db 00       		.byte	0
 9377 00dc 00       		.byte	0
 9378 00dd 05       		.byte	5
 9379 00de 00       		.byte	0
 9380 00df 01       		.byte	1
 9381 00e0 00       		.byte	0
 9382 00e1 03       		.byte	3
 9383 00e2 00       		.byte	0
 9384 00e3 00       		.byte	0
 9385 00e4 00       		.byte	0
 9386 00e5 00       		.byte	0
 9387 00e6 00       		.byte	0
 9388 00e7 30       		.byte	48
 9389 00e8 01       		.byte	1
 9390 00e9 00       		.byte	0
 9391 00ea 00       		.byte	0
 9392 00eb 00000000 		.space	5
 9392      00
 9393 00f0 00       		.byte	0
 9394 00f1 00       		.byte	0
 9395 00f2 03       		.byte	3
 9396 00f3 00       		.byte	0
 9397 00f4 00       		.byte	0
 9398 00f5 0A       		.byte	10
 9399 00f6 00       		.byte	0
 9400 00f7 01       		.byte	1
 9401 00f8 00       		.byte	0
 9402 00f9 03       		.byte	3
 9403 00fa 00       		.byte	0
 9404 00fb 00       		.byte	0
 9405 00fc 00       		.byte	0
 9406 00fd 00       		.byte	0
 9407 00fe 00       		.byte	0
 9408 00ff 30       		.byte	48
 9409 0100 01       		.byte	1
 9410 0101 00       		.byte	0
 9411 0102 00       		.byte	0
 9412 0103 00000000 		.space	5
 9412      00
 9413 0108 00       		.byte	0
 9414 0109 00       		.byte	0
 9415 010a 02       		.byte	2
 9416 010b 00       		.byte	0
 9417 010c 00       		.byte	0
 9418 010d 40       		.byte	64
 9419 010e 00       		.byte	0
 9420 010f 01       		.byte	1
 9421 0110 00       		.byte	0
 9422 0111 03       		.byte	3
 9423 0112 00       		.byte	0
 9424 0113 0F       		.byte	15
 9425 0114 11       		.byte	17
 9426 0115 00       		.byte	0
 9427 0116 00       		.byte	0
 9428 0117 30       		.byte	48
 9429 0118 01       		.byte	1
 9430 0119 00       		.byte	0
 9431 011a 00       		.byte	0
 9432 011b 00000000 		.space	5
 9432      00
 9433 0120 00       		.byte	0
 9434 0121 00       		.byte	0
 9435 0122 02       		.byte	2
 9436 0123 00       		.byte	0
 9437 0124 00       		.byte	0
 9438 0125 64       		.byte	100
 9439 0126 00       		.byte	0
 9440 0127 01       		.byte	1
 9441 0128 00       		.byte	0
 9442 0129 03       		.byte	3
 9443 012a 00       		.byte	0
 9444 012b 00       		.byte	0
 9445 012c 00       		.byte	0
 9446 012d 00       		.byte	0
 9447 012e 00       		.byte	0
 9448 012f 30       		.byte	48
 9449 0130 01       		.byte	1
 9450 0131 00       		.byte	0
 9451 0132 00       		.byte	0
 9452 0133 00000000 		.space	5
 9452      00
 9453 0138 00       		.byte	0
 9454 0139 00       		.byte	0
 9455 013a 02       		.byte	2
 9456 013b 00       		.byte	0
 9457 013c 00       		.byte	0
 9458 013d 64       		.byte	100
 9459 013e 00       		.byte	0
 9460 013f 01       		.byte	1
 9461 0140 00       		.byte	0
 9462 0141 03       		.byte	3
 9463 0142 00       		.byte	0
 9464 0143 00       		.byte	0
 9465 0144 00       		.byte	0
 9466 0145 00       		.byte	0
 9467 0146 00       		.byte	0
 9468 0147 30       		.byte	48
 9469 0148 01       		.byte	1
 9470 0149 00       		.byte	0
 9471 014a 00       		.byte	0
 9472 014b 00000000 		.space	5
 9472      00
 9473 0150 00       		.byte	0
 9474 0151 00       		.byte	0
 9475 0152 02       		.byte	2
 9476 0153 00       		.byte	0
 9477 0154 00       		.byte	0
 9478 0155 64       		.byte	100
 9479 0156 00       		.byte	0
 9480 0157 01       		.byte	1
 9481 0158 00       		.byte	0
 9482 0159 03       		.byte	3
 9483 015a 00       		.byte	0
 9484 015b 00       		.byte	0
 9485 015c 00       		.byte	0
 9486 015d 00       		.byte	0
 9487 015e 00       		.byte	0
 9488 015f 30       		.byte	48
 9489 0160 01       		.byte	1
 9490 0161 00       		.byte	0
 9491 0162 00       		.byte	0
 9492 0163 00000000 		.space	5
 9492      00
 9493 0168 00       		.byte	0
 9494 0169 00       		.byte	0
 9495 016a 02       		.byte	2
 9496 016b 00       		.byte	0
 9497 016c 00       		.byte	0
 9498 016d 64       		.byte	100
 9499 016e 00       		.byte	0
 9500 016f 01       		.byte	1
 9501 0170 00       		.byte	0
 9502 0171 03       		.byte	3
 9503 0172 00       		.byte	0
 9504 0173 00       		.byte	0
 9505 0174 00       		.byte	0
 9506 0175 00       		.byte	0
 9507 0176 00       		.byte	0
 9508 0177 30       		.byte	48
 9509 0178 01       		.byte	1
 9510 0179 00       		.byte	0
 9511 017a 00       		.byte	0
 9512 017b 00000000 		.space	5
 9512      00
 9515              	CtrlParArry:
 9516 0180 10       		.byte	16
 9517 0181 10       		.byte	16
 9518 0182 02       		.byte	2
 9519 0183 00       		.byte	0
 9520 0184 00       		.byte	0
 9521 0185 03       		.byte	3
 9522 0186 00       		.byte	0
 9523 0187 01       		.byte	1
 9524 0188 00       		.byte	0
 9525 0189 03       		.byte	3
 9526 018a 00       		.byte	0
 9527 018b 03       		.byte	3
 9528 018c 00       		.byte	0
 9529 018d 03       		.byte	3
 9530 018e 00       		.byte	0
 9531 018f 30       		.byte	48
 9532 0190 01       		.byte	1
 9533 0191 00       		.byte	0
 9534 0192 00       		.byte	0
 9535 0193 00000000 		.space	5
 9535      00
 9536 0198 15       		.byte	21
 9537 0199 15       		.byte	21
 9538 019a 02       		.byte	2
 9539 019b 00       		.byte	0
 9540 019c 00       		.byte	0
 9541 019d FF       		.byte	-1
 9542 019e 00       		.byte	0
 9543 019f 01       		.byte	1
 9544 01a0 00       		.byte	0
 9545 01a1 03       		.byte	3
 9546 01a2 00       		.byte	0
 9547 01a3 76       		.byte	118
 9548 01a4 00       		.byte	0
 9549 01a5 76       		.byte	118
 9550 01a6 C7       		.byte	-57
 9551 01a7 30       		.byte	48
 9552 01a8 01       		.byte	1
 9553 01a9 01       		.byte	1
 9554 01aa 00       		.byte	0
 9555 01ab 00000000 		.space	5
 9555      00
 9556 01b0 04       		.byte	4
 9557 01b1 04       		.byte	4
 9558 01b2 02       		.byte	2
 9559 01b3 00       		.byte	0
 9560 01b4 00       		.byte	0
 9561 01b5 FF       		.byte	-1
 9562 01b6 00       		.byte	0
 9563 01b7 01       		.byte	1
 9564 01b8 00       		.byte	0
 9565 01b9 03       		.byte	3
 9566 01ba 00       		.byte	0
 9567 01bb 70       		.byte	112
 9568 01bc 00       		.byte	0
 9569 01bd 70       		.byte	112
 9570 01be 00       		.byte	0
 9571 01bf 30       		.byte	48
 9572 01c0 01       		.byte	1
 9573 01c1 01       		.byte	1
 9574 01c2 00       		.byte	0
 9575 01c3 00000000 		.space	5
 9575      00
 9576 01c8 00       		.byte	0
 9577 01c9 00       		.byte	0
 9578 01ca 02       		.byte	2
 9579 01cb 00       		.byte	0
 9580 01cc 00       		.byte	0
 9581 01cd 64       		.byte	100
 9582 01ce 00       		.byte	0
 9583 01cf 01       		.byte	1
 9584 01d0 00       		.byte	0
 9585 01d1 03       		.byte	3
 9586 01d2 00       		.byte	0
 9587 01d3 00       		.byte	0
 9588 01d4 00       		.byte	0
 9589 01d5 00       		.byte	0
 9590 01d6 00       		.byte	0
 9591 01d7 30       		.byte	48
 9592 01d8 01       		.byte	1
 9593 01d9 00       		.byte	0
 9594 01da 00       		.byte	0
 9595 01db 00000000 		.space	5
 9595      00
 9596 01e0 07       		.byte	7
 9597 01e1 07       		.byte	7
 9598 01e2 02       		.byte	2
 9599 01e3 00       		.byte	0
 9600 01e4 00       		.byte	0
 9601 01e5 01       		.byte	1
 9602 01e6 00       		.byte	0
 9603 01e7 01       		.byte	1
 9604 01e8 00       		.byte	0
 9605 01e9 03       		.byte	3
 9606 01ea 00       		.byte	0
 9607 01eb 01       		.byte	1
 9608 01ec 00       		.byte	0
 9609 01ed 01       		.byte	1
 9610 01ee 00       		.byte	0
 9611 01ef 30       		.byte	48
 9612 01f0 01       		.byte	1
 9613 01f1 00       		.byte	0
 9614 01f2 00       		.byte	0
 9615 01f3 00000000 		.space	5
 9615      00
 9616 01f8 DF       		.byte	-33
 9617 01f9 E1       		.byte	-31
 9618 01fa 02       		.byte	2
 9619 01fb 00       		.byte	0
 9620 01fc 00       		.byte	0
 9621 01fd FF       		.byte	-1
 9622 01fe 00       		.byte	0
 9623 01ff 01       		.byte	1
 9624 0200 00       		.byte	0
 9625 0201 03       		.byte	3
 9626 0202 00       		.byte	0
 9627 0203 80       		.byte	-128
 9628 0204 00       		.byte	0
 9629 0205 00       		.byte	0
 9630 0206 00       		.byte	0
 9631 0207 C6       		.byte	-58
 9632 0208 01       		.byte	1
 9633 0209 01       		.byte	1
 9634 020a 00       		.byte	0
 9635 020b 00000000 		.space	5
 9635      00
 9636 0210 85       		.byte	-123
 9637 0211 86       		.byte	-122
 9638 0212 02       		.byte	2
 9639 0213 00       		.byte	0
 9640 0214 00       		.byte	0
 9641 0215 64       		.byte	100
 9642 0216 00       		.byte	0
 9643 0217 01       		.byte	1
 9644 0218 00       		.byte	0
 9645 0219 03       		.byte	3
 9646 021a 00       		.byte	0
 9647 021b 32       		.byte	50
 9648 021c 00       		.byte	0
 9649 021d 32       		.byte	50
 9650 021e 00       		.byte	0
 9651 021f F2       		.byte	-14
 9652 0220 01       		.byte	1
 9653 0221 01       		.byte	1
 9654 0222 00       		.byte	0
 9655 0223 00000000 		.space	5
 9655      00
 9656 0228 06       		.byte	6
 9657 0229 06       		.byte	6
 9658 022a 02       		.byte	2
 9659 022b 00       		.byte	0
 9660 022c 00       		.byte	0
 9661 022d FF       		.byte	-1
 9662 022e 00       		.byte	0
 9663 022f 01       		.byte	1
 9664 0230 00       		.byte	0
 9665 0231 03       		.byte	3
 9666 0232 00       		.byte	0
 9667 0233 20       		.byte	32
 9668 0234 00       		.byte	0
 9669 0235 20       		.byte	32
 9670 0236 00       		.byte	0
 9671 0237 30       		.byte	48
 9672 0238 01       		.byte	1
 9673 0239 01       		.byte	1
 9674 023a 00       		.byte	0
 9675 023b 00000000 		.space	5
 9675      00
 9676 0240 00       		.byte	0
 9677 0241 00       		.byte	0
 9678 0242 02       		.byte	2
 9679 0243 00       		.byte	0
 9680 0244 00       		.byte	0
 9681 0245 64       		.byte	100
 9682 0246 00       		.byte	0
 9683 0247 01       		.byte	1
 9684 0248 00       		.byte	0
 9685 0249 03       		.byte	3
 9686 024a 00       		.byte	0
 9687 024b 00       		.byte	0
 9688 024c 00       		.byte	0
 9689 024d 00       		.byte	0
 9690 024e 00       		.byte	0
 9691 024f 30       		.byte	48
 9692 0250 01       		.byte	1
 9693 0251 00       		.byte	0
 9694 0252 00       		.byte	0
 9695 0253 00000000 		.space	5
 9695      00
 9696 0258 08       		.byte	8
 9697 0259 08       		.byte	8
 9698 025a 02       		.byte	2
 9699 025b 00       		.byte	0
 9700 025c 00       		.byte	0
 9701 025d 05       		.byte	5
 9702 025e 00       		.byte	0
 9703 025f 01       		.byte	1
 9704 0260 00       		.byte	0
 9705 0261 03       		.byte	3
 9706 0262 00       		.byte	0
 9707 0263 00       		.byte	0
 9708 0264 00       		.byte	0
 9709 0265 00       		.byte	0
 9710 0266 00       		.byte	0
 9711 0267 30       		.byte	48
 9712 0268 01       		.byte	1
 9713 0269 00       		.byte	0
 9714 026a 00       		.byte	0
 9715 026b 00000000 		.space	5
 9715      00
 9716 0270 00       		.byte	0
 9717 0271 00       		.byte	0
 9718 0272 02       		.byte	2
 9719 0273 00       		.byte	0
 9720 0274 00       		.byte	0
 9721 0275 40       		.byte	64
 9722 0276 00       		.byte	0
 9723 0277 01       		.byte	1
 9724 0278 00       		.byte	0
 9725 0279 03       		.byte	3
 9726 027a 00       		.byte	0
 9727 027b 00       		.byte	0
 9728 027c 00       		.byte	0
 9729 027d 00       		.byte	0
 9730 027e 00       		.byte	0
 9731 027f 30       		.byte	48
 9732 0280 01       		.byte	1
 9733 0281 00       		.byte	0
 9734 0282 00       		.byte	0
 9735 0283 00000000 		.space	5
 9735      00
 9736 0288 09       		.byte	9
 9737 0289 0A       		.byte	10
 9738 028a 04       		.byte	4
 9739 028b 00       		.byte	0
 9740 028c 00       		.byte	0
 9741 028d 40       		.byte	64
 9742 028e 00       		.byte	0
 9743 028f 01       		.byte	1
 9744 0290 00       		.byte	0
 9745 0291 03       		.byte	3
 9746 0292 00       		.byte	0
 9747 0293 20       		.byte	32
 9748 0294 38       		.byte	56
 9749 0295 20       		.byte	32
 9750 0296 38       		.byte	56
 9751 0297 30       		.byte	48
 9752 0298 01       		.byte	1
 9753 0299 00       		.byte	0
 9754 029a 00       		.byte	0
 9755 029b 00000000 		.space	5
 9755      00
 9756 02a0 00       		.byte	0
 9757 02a1 00       		.byte	0
 9758 02a2 02       		.byte	2
 9759 02a3 00       		.byte	0
 9760 02a4 00       		.byte	0
 9761 02a5 64       		.byte	100
 9762 02a6 00       		.byte	0
 9763 02a7 01       		.byte	1
 9764 02a8 00       		.byte	0
 9765 02a9 03       		.byte	3
 9766 02aa 00       		.byte	0
 9767 02ab 00       		.byte	0
 9768 02ac 00       		.byte	0
 9769 02ad 00       		.byte	0
 9770 02ae 00       		.byte	0
 9771 02af 30       		.byte	48
 9772 02b0 01       		.byte	1
 9773 02b1 00       		.byte	0
 9774 02b2 00       		.byte	0
 9775 02b3 00000000 		.space	5
 9775      00
 9776 02b8 00       		.byte	0
 9777 02b9 00       		.byte	0
 9778 02ba 02       		.byte	2
 9779 02bb 00       		.byte	0
 9780 02bc 00       		.byte	0
 9781 02bd 64       		.byte	100
 9782 02be 00       		.byte	0
 9783 02bf 01       		.byte	1
 9784 02c0 00       		.byte	0
 9785 02c1 03       		.byte	3
 9786 02c2 00       		.byte	0
 9787 02c3 00       		.byte	0
 9788 02c4 00       		.byte	0
 9789 02c5 00       		.byte	0
 9790 02c6 00       		.byte	0
 9791 02c7 30       		.byte	48
 9792 02c8 01       		.byte	1
 9793 02c9 00       		.byte	0
 9794 02ca 00       		.byte	0
 9795 02cb 00000000 		.space	5
 9795      00
 9796 02d0 2A       		.byte	42
 9797 02d1 2A       		.byte	42
 9798 02d2 02       		.byte	2
 9799 02d3 00       		.byte	0
 9800 02d4 00       		.byte	0
 9801 02d5 1B       		.byte	27
 9802 02d6 00       		.byte	0
 9803 02d7 01       		.byte	1
 9804 02d8 00       		.byte	0
 9805 02d9 03       		.byte	3
 9806 02da 00       		.byte	0
 9807 02db 00       		.byte	0
 9808 02dc 00       		.byte	0
 9809 02dd 00       		.byte	0
 9810 02de 00       		.byte	0
 9811 02df 30       		.byte	48
 9812 02e0 01       		.byte	1
 9813 02e1 00       		.byte	0
 9814 02e2 00       		.byte	0
 9815 02e3 00000000 		.space	5
 9815      00
 9816 02e8 00       		.byte	0
 9817 02e9 00       		.byte	0
 9818 02ea 02       		.byte	2
 9819 02eb 00       		.byte	0
 9820 02ec 00       		.byte	0
 9821 02ed 64       		.byte	100
 9822 02ee 00       		.byte	0
 9823 02ef 01       		.byte	1
 9824 02f0 00       		.byte	0
 9825 02f1 03       		.byte	3
 9826 02f2 00       		.byte	0
 9827 02f3 00       		.byte	0
 9828 02f4 00       		.byte	0
 9829 02f5 00       		.byte	0
 9830 02f6 00       		.byte	0
 9831 02f7 30       		.byte	48
 9832 02f8 01       		.byte	1
 9833 02f9 00       		.byte	0
 9834 02fa 00       		.byte	0
 9835 02fb 00000000 		.space	5
 9835      00
 9836 0300 00       		.byte	0
 9837 0301 00       		.byte	0
 9838 0302 02       		.byte	2
 9839 0303 00       		.byte	0
 9840 0304 00       		.byte	0
 9841 0305 12       		.byte	18
 9842 0306 00       		.byte	0
 9843 0307 01       		.byte	1
 9844 0308 00       		.byte	0
 9845 0309 03       		.byte	3
 9846 030a 00       		.byte	0
 9847 030b 00       		.byte	0
 9848 030c 00       		.byte	0
 9849 030d 00       		.byte	0
 9850 030e 00       		.byte	0
 9851 030f 30       		.byte	48
 9852 0310 01       		.byte	1
 9853 0311 00       		.byte	0
 9854 0312 00       		.byte	0
 9855 0313 00000000 		.space	5
 9855      00
 9856 0318 01       		.byte	1
 9857 0319 01       		.byte	1
 9858 031a 02       		.byte	2
 9859 031b 00       		.byte	0
 9860 031c 00       		.byte	0
 9861 031d 09       		.byte	9
 9862 031e 00       		.byte	0
 9863 031f 01       		.byte	1
 9864 0320 00       		.byte	0
 9865 0321 03       		.byte	3
 9866 0322 00       		.byte	0
 9867 0323 00       		.byte	0
 9868 0324 00       		.byte	0
 9869 0325 01       		.byte	1
 9870 0326 00       		.byte	0
 9871 0327 30       		.byte	48
 9872 0328 01       		.byte	1
 9873 0329 00       		.byte	0
 9874 032a 00       		.byte	0
 9875 032b 00000000 		.space	5
 9875      00
 9876 0330 05       		.byte	5
 9877 0331 05       		.byte	5
 9878 0332 02       		.byte	2
 9879 0333 00       		.byte	0
 9880 0334 00       		.byte	0
 9881 0335 03       		.byte	3
 9882 0336 00       		.byte	0
 9883 0337 01       		.byte	1
 9884 0338 00       		.byte	0
 9885 0339 03       		.byte	3
 9886 033a 00       		.byte	0
 9887 033b 00       		.byte	0
 9888 033c 00       		.byte	0
 9889 033d 00       		.byte	0
 9890 033e 00       		.byte	0
 9891 033f 30       		.byte	48
 9892 0340 01       		.byte	1
 9893 0341 00       		.byte	0
 9894 0342 00       		.byte	0
 9895 0343 00000000 		.space	5
 9895      00
 9896 0348 18       		.byte	24
 9897 0349 18       		.byte	24
 9898 034a 02       		.byte	2
 9899 034b 00       		.byte	0
 9900 034c 00       		.byte	0
 9901 034d 01       		.byte	1
 9902 034e 00       		.byte	0
 9903 034f 01       		.byte	1
 9904 0350 00       		.byte	0
 9905 0351 03       		.byte	3
 9906 0352 00       		.byte	0
 9907 0353 00       		.byte	0
 9908 0354 00       		.byte	0
 9909 0355 00       		.byte	0
 9910 0356 00       		.byte	0
 9911 0357 30       		.byte	48
 9912 0358 01       		.byte	1
 9913 0359 00       		.byte	0
 9914 035a 00       		.byte	0
 9915 035b 00000000 		.space	5
 9915      00
 9916 0360 19       		.byte	25
 9917 0361 19       		.byte	25
 9918 0362 01       		.byte	1
 9919 0363 00       		.byte	0
 9920 0364 00       		.byte	0
 9921 0365 40       		.byte	64
 9922 0366 00       		.byte	0
 9923 0367 01       		.byte	1
 9924 0368 00       		.byte	0
 9925 0369 03       		.byte	3
 9926 036a 00       		.byte	0
 9927 036b 20       		.byte	32
 9928 036c 00       		.byte	0
 9929 036d 20       		.byte	32
 9930 036e 00       		.byte	0
 9931 036f 30       		.byte	48
 9932 0370 01       		.byte	1
 9933 0371 00       		.byte	0
 9934 0372 00       		.byte	0
 9935 0373 00000000 		.space	5
 9935      00
 9936 0378 20       		.byte	32
 9937 0379 20       		.byte	32
 9938 037a 02       		.byte	2
 9939 037b 00       		.byte	0
 9940 037c 00       		.byte	0
 9941 037d 02       		.byte	2
 9942 037e 00       		.byte	0
 9943 037f 01       		.byte	1
 9944 0380 00       		.byte	0
 9945 0381 03       		.byte	3
 9946 0382 00       		.byte	0
 9947 0383 00       		.byte	0
 9948 0384 00       		.byte	0
 9949 0385 00       		.byte	0
 9950 0386 00       		.byte	0
 9951 0387 30       		.byte	48
 9952 0388 01       		.byte	1
 9953 0389 00       		.byte	0
 9954 038a 00       		.byte	0
 9955 038b 00000000 		.space	5
 9955      00
 9956 0390 22       		.byte	34
 9957 0391 22       		.byte	34
 9958 0392 02       		.byte	2
 9959 0393 00       		.byte	0
 9960 0394 00       		.byte	0
 9961 0395 3F       		.byte	63
 9962 0396 00       		.byte	0
 9963 0397 01       		.byte	1
 9964 0398 00       		.byte	0
 9965 0399 03       		.byte	3
 9966 039a 00       		.byte	0
 9967 039b 00       		.byte	0
 9968 039c 00       		.byte	0
 9969 039d 00       		.byte	0
 9970 039e 00       		.byte	0
 9971 039f 30       		.byte	48
 9972 03a0 01       		.byte	1
 9973 03a1 00       		.byte	0
 9974 03a2 00       		.byte	0
 9975 03a3 00000000 		.space	5
 9975      00
 9976 03a8 23       		.byte	35
 9977 03a9 23       		.byte	35
 9978 03aa 02       		.byte	2
 9979 03ab 00       		.byte	0
 9980 03ac 00       		.byte	0
 9981 03ad 64       		.byte	100
 9982 03ae 00       		.byte	0
 9983 03af 01       		.byte	1
 9984 03b0 00       		.byte	0
 9985 03b1 03       		.byte	3
 9986 03b2 00       		.byte	0
 9987 03b3 10       		.byte	16
 9988 03b4 00       		.byte	0
 9989 03b5 10       		.byte	16
 9990 03b6 00       		.byte	0
 9991 03b7 30       		.byte	48
 9992 03b8 01       		.byte	1
 9993 03b9 00       		.byte	0
 9994 03ba 00       		.byte	0
 9995 03bb 00000000 		.space	5
 9995      00
 9996 03c0 24       		.byte	36
 9997 03c1 24       		.byte	36
 9998 03c2 02       		.byte	2
 9999 03c3 00       		.byte	0
 10000 03c4 00       		.byte	0
 10001 03c5 64       		.byte	100
 10002 03c6 00       		.byte	0
 10003 03c7 01       		.byte	1
 10004 03c8 00       		.byte	0
 10005 03c9 03       		.byte	3
 10006 03ca 00       		.byte	0
 10007 03cb 10       		.byte	16
 10008 03cc 00       		.byte	0
 10009 03cd 10       		.byte	16
 10010 03ce 00       		.byte	0
 10011 03cf 30       		.byte	48
 10012 03d0 01       		.byte	1
 10013 03d1 00       		.byte	0
 10014 03d2 00       		.byte	0
 10015 03d3 00000000 		.space	5
 10015      00
 10016 03d8 02       		.byte	2
 10017 03d9 03       		.byte	3
 10018 03da 04       		.byte	4
 10019 03db 00       		.byte	0
 10020 03dc 00       		.byte	0
 10021 03dd 7F       		.byte	127
 10022 03de 00       		.byte	0
 10023 03df 01       		.byte	1
 10024 03e0 00       		.byte	0
 10025 03e1 03       		.byte	3
 10026 03e2 00       		.byte	0
 10027 03e3 00       		.byte	0
 10028 03e4 20       		.byte	32
 10029 03e5 00       		.byte	0
 10030 03e6 20       		.byte	32
 10031 03e7 30       		.byte	48
 10032 03e8 01       		.byte	1
 10033 03e9 00       		.byte	0
 10034 03ea 00       		.byte	0
 10035 03eb 00000000 		.space	5
 10035      00
 10036 03f0 04       		.byte	4
 10037 03f1 04       		.byte	4
 10038 03f2 02       		.byte	2
 10039 03f3 00       		.byte	0
 10040 03f4 00       		.byte	0
 10041 03f5 FF       		.byte	-1
 10042 03f6 00       		.byte	0
 10043 03f7 01       		.byte	1
 10044 03f8 00       		.byte	0
 10045 03f9 03       		.byte	3
 10046 03fa 00       		.byte	0
 10047 03fb 60       		.byte	96
 10048 03fc 00       		.byte	0
 10049 03fd 60       		.byte	96
 10050 03fe 00       		.byte	0
 10051 03ff 30       		.byte	48
 10052 0400 01       		.byte	1
 10053 0401 00       		.byte	0
 10054 0402 00       		.byte	0
 10055 0403 00000000 		.space	5
 10055      00
 10056 0408 00       		.byte	0
 10057 0409 00       		.byte	0
 10058 040a 02       		.byte	2
 10059 040b 00       		.byte	0
 10060 040c 00       		.byte	0
 10061 040d 19       		.byte	25
 10062 040e 00       		.byte	0
 10063 040f 01       		.byte	1
 10064 0410 00       		.byte	0
 10065 0411 03       		.byte	3
 10066 0412 00       		.byte	0
 10067 0413 00       		.byte	0
 10068 0414 00       		.byte	0
 10069 0415 00       		.byte	0
 10070 0416 00       		.byte	0
 10071 0417 30       		.byte	48
 10072 0418 01       		.byte	1
 10073 0419 00       		.byte	0
 10074 041a 00       		.byte	0
 10075 041b 00000000 		.space	5
 10075      00
 10076 0420 10       		.byte	16
 10077 0421 10       		.byte	16
 10078 0422 02       		.byte	2
 10079 0423 00       		.byte	0
 10080 0424 00       		.byte	0
 10081 0425 06       		.byte	6
 10082 0426 00       		.byte	0
 10083 0427 01       		.byte	1
 10084 0428 00       		.byte	0
 10085 0429 03       		.byte	3
 10086 042a 00       		.byte	0
 10087 042b 03       		.byte	3
 10088 042c 00       		.byte	0
 10089 042d 03       		.byte	3
 10090 042e 00       		.byte	0
 10091 042f 30       		.byte	48
 10092 0430 01       		.byte	1
 10093 0431 00       		.byte	0
 10094 0432 00       		.byte	0
 10095 0433 00000000 		.space	5
 10095      00
 10096 0438 00       		.byte	0
 10097 0439 00       		.byte	0
 10098 043a 02       		.byte	2
 10099 043b 00       		.byte	0
 10100 043c 00       		.byte	0
 10101 043d 03       		.byte	3
 10102 043e 00       		.byte	0
 10103 043f 01       		.byte	1
 10104 0440 00       		.byte	0
 10105 0441 03       		.byte	3
 10106 0442 00       		.byte	0
 10107 0443 00       		.byte	0
 10108 0444 00       		.byte	0
 10109 0445 00       		.byte	0
 10110 0446 00       		.byte	0
 10111 0447 30       		.byte	48
 10112 0448 01       		.byte	1
 10113 0449 00       		.byte	0
 10114 044a 00       		.byte	0
 10115 044b 00000000 		.space	5
 10115      00
 10116 0450 50       		.byte	80
 10117 0451 50       		.byte	80
 10118 0452 01       		.byte	1
 10119 0453 00       		.byte	0
 10120 0454 00       		.byte	0
 10121 0455 03       		.byte	3
 10122 0456 00       		.byte	0
 10123 0457 01       		.byte	1
 10124 0458 00       		.byte	0
 10125 0459 03       		.byte	3
 10126 045a 00       		.byte	0
 10127 045b 00       		.byte	0
 10128 045c 00       		.byte	0
 10129 045d 00       		.byte	0
 10130 045e 00       		.byte	0
 10131 045f 30       		.byte	48
 10132 0460 01       		.byte	1
 10133 0461 00       		.byte	0
 10134 0462 00       		.byte	0
 10135 0463 00000000 		.space	5
 10135      00
 10136 0468 00       		.byte	0
 10137 0469 00       		.byte	0
 10138 046a 0B       		.byte	11
 10139 046b 00       		.byte	0
 10140 046c 00       		.byte	0
 10141 046d FF       		.byte	-1
 10142 046e FF       		.byte	-1
 10143 046f 01       		.byte	1
 10144 0470 00       		.byte	0
 10145 0471 03       		.byte	3
 10146 0472 00       		.byte	0
 10147 0473 00       		.byte	0
 10148 0474 00       		.byte	0
 10149 0475 00       		.byte	0
 10150 0476 00       		.byte	0
 10151 0477 00       		.byte	0
 10152 0478 01       		.byte	1
 10153 0479 00       		.byte	0
 10154 047a 00       		.byte	0
 10155 047b 00000000 		.space	5
 10155      00
 10158              	glUVCHeader:
 10159 0480 0C       		.byte	12
 10160 0481 8C       		.byte	-116
 10161 0482 00       		.byte	0
 10162 0483 00       		.byte	0
 10163 0484 00       		.byte	0
 10164 0485 00       		.byte	0
 10165 0486 00       		.byte	0
 10166 0487 00       		.byte	0
 10167 0488 00       		.byte	0
 10168 0489 00       		.byte	0
 10169 048a 00       		.byte	0
 10170 048b 00       		.byte	0
 10173              	ROIMode:
 10174 048c 01       		.byte	1
 10175 048d 000000   		.space	3
 10178              	EXTShutter:
 10179 0490 00       		.byte	0
 10180 0491 02       		.byte	2
 10181 0492 02       		.byte	2
 10182 0493 00       		.byte	0
 10183 0494 00       		.byte	0
 10184 0495 08       		.byte	8
 10185 0496 00       		.byte	0
 10186 0497 01       		.byte	1
 10187 0498 00       		.byte	0
 10188 0499 03       		.byte	3
 10189 049a 00       		.byte	0
 10190 049b 00       		.byte	0
 10191 049c 00       		.byte	0
 10192 049d 00       		.byte	0
 10193 049e 00       		.byte	0
 10194 049f 30       		.byte	48
 10195 04a0 01       		.byte	1
 10196 04a1 00       		.byte	0
 10197 04a2 0000     		.space	2
 10200              	EXTShutlev:
 10201 04a4 02       		.byte	2
 10202 04a5 12       		.byte	18
 10203 04a6 02       		.byte	2
 10204 04a7 00       		.byte	0
 10205 04a8 00       		.byte	0
 10206 04a9 FF       		.byte	-1
 10207 04aa 7F       		.byte	127
 10208 04ab 01       		.byte	1
 10209 04ac 00       		.byte	0
 10210 04ad 03       		.byte	3
 10211 04ae 00       		.byte	0
 10212 04af 3F       		.byte	63
 10213 04b0 00       		.byte	0
 10214 04b1 3F       		.byte	63
 10215 04b2 00       		.byte	0
 10216 04b3 30       		.byte	48
 10217 04b4 01       		.byte	1
 10218 04b5 00       		.byte	0
 10219 04b6 0000     		.space	2
 10222              	EXTAexModGainlev:
 10223 04b8 00       		.byte	0
 10224 04b9 03       		.byte	3
 10225 04ba 04       		.byte	4
 10226 04bb 00       		.byte	0
 10227 04bc 00       		.byte	0
 10228 04bd 03       		.byte	3
 10229 04be 7F       		.byte	127
 10230 04bf 01       		.byte	1
 10231 04c0 00       		.byte	0
 10232 04c1 03       		.byte	3
 10233 04c2 00       		.byte	0
 10234 04c3 00       		.byte	0
 10235 04c4 3F       		.byte	63
 10236 04c5 00       		.byte	0
 10237 04c6 3F       		.byte	63
 10238 04c7 30       		.byte	48
 10239 04c8 01       		.byte	1
 10240 04c9 00       		.byte	0
 10241 04ca 0000     		.space	2
 10244              	WBMenuCmpArry:
 10245 04cc 20       		.byte	32
 10246 04cd 0F       		.byte	15
 10247 04ce 38       		.byte	56
 10248 04cf F0       		.byte	-16
 10251              	PUCBLC:
 10252 04d0 10       		.byte	16
 10253 04d1 11       		.byte	17
 10254 04d2 02       		.byte	2
 10255 04d3 00       		.byte	0
 10256 04d4 00       		.byte	0
 10257 04d5 03       		.byte	3
 10258 04d6 00       		.byte	0
 10259 04d7 01       		.byte	1
 10260 04d8 00       		.byte	0
 10261 04d9 03       		.byte	3
 10262 04da 00       		.byte	0
 10263 04db 03       		.byte	3
 10264 04dc 00       		.byte	0
 10265 04dd 03       		.byte	3
 10266 04de 00       		.byte	0
 10267 04df 30       		.byte	48
 10268 04e0 01       		.byte	1
 10269 04e1 00       		.byte	0
 10270 04e2 0000     		.space	2
 10273              	PUCSharp:
 10274 04e4 06       		.byte	6
 10275 04e5 07       		.byte	7
 10276 04e6 02       		.byte	2
 10277 04e7 00       		.byte	0
 10278 04e8 00       		.byte	0
 10279 04e9 08       		.byte	8
 10280 04ea 00       		.byte	0
 10281 04eb 01       		.byte	1
 10282 04ec 00       		.byte	0
 10283 04ed 03       		.byte	3
 10284 04ee 00       		.byte	0
 10285 04ef 00       		.byte	0
 10286 04f0 00       		.byte	0
 10287 04f1 00       		.byte	0
 10288 04f2 00       		.byte	0
 10289 04f3 30       		.byte	48
 10290 04f4 01       		.byte	1
 10291 04f5 00       		.byte	0
 10292 04f6 0000     		.space	2
 10295              	EXTBLCWinPos:
 10296 04f8 14       		.byte	20
 10297 04f9 13       		.byte	19
 10298 04fa 02       		.byte	2
 10299 04fb 00       		.byte	0
 10300 04fc 00       		.byte	0
 10301 04fd FF       		.byte	-1
 10302 04fe FF       		.byte	-1
 10303 04ff 01       		.byte	1
 10304 0500 00       		.byte	0
 10305 0501 03       		.byte	3
 10306 0502 00       		.byte	0
 10307 0503 66       		.byte	102
 10308 0504 66       		.byte	102
 10309 0505 66       		.byte	102
 10310 0506 66       		.byte	102
 10311 0507 30       		.byte	48
 10312 0508 01       		.byte	1
 10313 0509 00       		.byte	0
 10314 050a 0000     		.space	2
 10317              	EXTBLCWeight:
 10318 050c 11       		.byte	17
 10319 050d 11       		.byte	17
 10320 050e 02       		.byte	2
 10321 050f 00       		.byte	0
 10322 0510 00       		.byte	0
 10323 0511 FF       		.byte	-1
 10324 0512 00       		.byte	0
 10325 0513 01       		.byte	1
 10326 0514 00       		.byte	0
 10327 0515 03       		.byte	3
 10328 0516 00       		.byte	0
 10329 0517 80       		.byte	-128
 10330 0518 00       		.byte	0
 10331 0519 80       		.byte	-128
 10332 051a 00       		.byte	0
 10333 051b 30       		.byte	48
 10334 051c 01       		.byte	1
 10335 051d 00       		.byte	0
 10336 051e 0000     		.space	2
 10339              	CTCtrlParArry:
 10340 0520 00       		.byte	0
 10341 0521 00       		.byte	0
 10342 0522 01       		.byte	1
 10343 0523 00       		.byte	0
 10344 0524 00       		.byte	0
 10345 0525 03       		.byte	3
 10346 0526 00       		.byte	0
 10347 0527 01       		.byte	1
 10348 0528 00       		.byte	0
 10349 0529 03       		.byte	3
 10350 052a 00       		.byte	0
 10351 052b 03       		.byte	3
 10352 052c 00       		.byte	0
 10353 052d 03       		.byte	3
 10354 052e 00       		.byte	0
 10355 052f 30       		.byte	48
 10356 0530 01       		.byte	1
 10357 0531 00       		.byte	0
 10358 0532 00       		.byte	0
 10359 0533 00000000 		.space	5
 10359      00
 10360 0538 00       		.byte	0
 10361 0539 00       		.byte	0
 10362 053a 01       		.byte	1
 10363 053b 01       		.byte	1
 10364 053c 00       		.byte	0
 10365 053d 0F       		.byte	15
 10366 053e 00       		.byte	0
 10367 053f 0F       		.byte	15
 10368 0540 00       		.byte	0
 10369 0541 03       		.byte	3
 10370 0542 00       		.byte	0
 10371 0543 02       		.byte	2
 10372 0544 00       		.byte	0
 10373 0545 02       		.byte	2
 10374 0546 00       		.byte	0
 10375 0547 30       		.byte	48
 10376 0548 01       		.byte	1
 10377 0549 01       		.byte	1
 10378 054a 00       		.byte	0
 10379 054b 00000000 		.space	5
 10379      00
 10380 0550 02       		.byte	2
 10381 0551 00       		.byte	0
 10382 0552 01       		.byte	1
 10383 0553 00       		.byte	0
 10384 0554 00       		.byte	0
 10385 0555 01       		.byte	1
 10386 0556 00       		.byte	0
 10387 0557 01       		.byte	1
 10388 0558 00       		.byte	0
 10389 0559 03       		.byte	3
 10390 055a 00       		.byte	0
 10391 055b 00       		.byte	0
 10392 055c 00       		.byte	0
 10393 055d 00       		.byte	0
 10394 055e 00       		.byte	0
 10395 055f 30       		.byte	48
 10396 0560 01       		.byte	1
 10397 0561 01       		.byte	1
 10398 0562 00       		.byte	0
 10399 0563 00000000 		.space	5
 10399      00
 10400 0568 00       		.byte	0
 10401 0569 00       		.byte	0
 10402 056a 04       		.byte	4
 10403 056b 01       		.byte	1
 10404 056c 00       		.byte	0
 10405 056d 38       		.byte	56
 10406 056e 01       		.byte	1
 10407 056f 01       		.byte	1
 10408 0570 00       		.byte	0
 10409 0571 03       		.byte	3
 10410 0572 00       		.byte	0
 10411 0573 4E       		.byte	78
 10412 0574 00       		.byte	0
 10413 0575 4E       		.byte	78
 10414 0576 00       		.byte	0
 10415 0577 30       		.byte	48
 10416 0578 01       		.byte	1
 10417 0579 00       		.byte	0
 10418 057a 00       		.byte	0
 10419 057b 00000000 		.space	5
 10419      00
 10420 0580 04       		.byte	4
 10421 0581 00       		.byte	0
 10422 0582 01       		.byte	1
 10423 0583 00       		.byte	0
 10424 0584 00       		.byte	0
 10425 0585 00       		.byte	0
 10426 0586 00       		.byte	0
 10427 0587 01       		.byte	1
 10428 0588 00       		.byte	0
 10429 0589 03       		.byte	3
 10430 058a 00       		.byte	0
 10431 058b 00       		.byte	0
 10432 058c 00       		.byte	0
 10433 058d 00       		.byte	0
 10434 058e 00       		.byte	0
 10435 058f 30       		.byte	48
 10436 0590 01       		.byte	1
 10437 0591 00       		.byte	0
 10438 0592 00       		.byte	0
 10439 0593 00000000 		.space	5
 10439      00
 10440 0598 05       		.byte	5
 10441 0599 00       		.byte	0
 10442 059a 02       		.byte	2
 10443 059b 00       		.byte	0
 10444 059c 00       		.byte	0
 10445 059d FF       		.byte	-1
 10446 059e 00       		.byte	0
 10447 059f 01       		.byte	1
 10448 05a0 00       		.byte	0
 10449 05a1 03       		.byte	3
 10450 05a2 00       		.byte	0
 10451 05a3 01       		.byte	1
 10452 05a4 00       		.byte	0
 10453 05a5 00       		.byte	0
 10454 05a6 00       		.byte	0
 10455 05a7 30       		.byte	48
 10456 05a8 01       		.byte	1
 10457 05a9 01       		.byte	1
 10458 05aa 00       		.byte	0
 10459 05ab 00000000 		.space	5
 10459      00
 10460 05b0 06       		.byte	6
 10461 05b1 00       		.byte	0
 10462 05b2 02       		.byte	2
 10463 05b3 00       		.byte	0
 10464 05b4 00       		.byte	0
 10465 05b5 00       		.byte	0
 10466 05b6 00       		.byte	0
 10467 05b7 00       		.byte	0
 10468 05b8 00       		.byte	0
 10469 05b9 03       		.byte	3
 10470 05ba 00       		.byte	0
 10471 05bb 00       		.byte	0
 10472 05bc 00       		.byte	0
 10473 05bd 00       		.byte	0
 10474 05be 00       		.byte	0
 10475 05bf 30       		.byte	48
 10476 05c0 01       		.byte	1
 10477 05c1 01       		.byte	1
 10478 05c2 00       		.byte	0
 10479 05c3 00000000 		.space	5
 10479      00
 10480 05c8 23       		.byte	35
 10481 05c9 00       		.byte	0
 10482 05ca 02       		.byte	2
 10483 05cb 00       		.byte	0
 10484 05cc 00       		.byte	0
 10485 05cd 30       		.byte	48
 10486 05ce 00       		.byte	0
 10487 05cf 01       		.byte	1
 10488 05d0 00       		.byte	0
 10489 05d1 03       		.byte	3
 10490 05d2 0A       		.byte	10
 10491 05d3 00       		.byte	0
 10492 05d4 00       		.byte	0
 10493 05d5 0A       		.byte	10
 10494 05d6 00       		.byte	0
 10495 05d7 30       		.byte	48
 10496 05d8 01       		.byte	1
 10497 05d9 01       		.byte	1
 10498 05da 00       		.byte	0
 10499 05db 00000000 		.space	5
 10499      00
 10500 05e0 08       		.byte	8
 10501 05e1 00       		.byte	0
 10502 05e2 01       		.byte	1
 10503 05e3 00       		.byte	0
 10504 05e4 00       		.byte	0
 10505 05e5 7F       		.byte	127
 10506 05e6 00       		.byte	0
 10507 05e7 01       		.byte	1
 10508 05e8 00       		.byte	0
 10509 05e9 03       		.byte	3
 10510 05ea 00       		.byte	0
 10511 05eb 00       		.byte	0
 10512 05ec 00       		.byte	0
 10513 05ed 00       		.byte	0
 10514 05ee 00       		.byte	0
 10515 05ef 30       		.byte	48
 10516 05f0 01       		.byte	1
 10517 05f1 00       		.byte	0
 10518 05f2 00       		.byte	0
 10519 05f3 00000000 		.space	5
 10519      00
 10520 05f8 09       		.byte	9
 10521 05f9 00       		.byte	0
 10522 05fa 02       		.byte	2
 10523 05fb 00       		.byte	0
 10524 05fc 00       		.byte	0
 10525 05fd 05       		.byte	5
 10526 05fe 00       		.byte	0
 10527 05ff 01       		.byte	1
 10528 0600 00       		.byte	0
 10529 0601 03       		.byte	3
 10530 0602 00       		.byte	0
 10531 0603 00       		.byte	0
 10532 0604 00       		.byte	0
 10533 0605 00       		.byte	0
 10534 0606 00       		.byte	0
 10535 0607 30       		.byte	48
 10536 0608 01       		.byte	1
 10537 0609 00       		.byte	0
 10538 060a 00       		.byte	0
 10539 060b 00000000 		.space	5
 10539      00
 10540 0610 10       		.byte	16
 10541 0611 00       		.byte	0
 10542 0612 03       		.byte	3
 10543 0613 00       		.byte	0
 10544 0614 00       		.byte	0
 10545 0615 00       		.byte	0
 10546 0616 00       		.byte	0
 10547 0617 00       		.byte	0
 10548 0618 00       		.byte	0
 10549 0619 03       		.byte	3
 10550 061a 00       		.byte	0
 10551 061b 00       		.byte	0
 10552 061c 00       		.byte	0
 10553 061d 00       		.byte	0
 10554 061e 00       		.byte	0
 10555 061f 30       		.byte	48
 10556 0620 01       		.byte	1
 10557 0621 00       		.byte	0
 10558 0622 00       		.byte	0
 10559 0623 00000000 		.space	5
 10559      00
 10560 0628 00       		.byte	0
 10561 0629 00       		.byte	0
 10562 062a 02       		.byte	2
 10563 062b 00       		.byte	0
 10564 062c 00       		.byte	0
 10565 062d 40       		.byte	64
 10566 062e 00       		.byte	0
 10567 062f 01       		.byte	1
 10568 0630 00       		.byte	0
 10569 0631 03       		.byte	3
 10570 0632 00       		.byte	0
 10571 0633 0F       		.byte	15
 10572 0634 11       		.byte	17
 10573 0635 00       		.byte	0
 10574 0636 00       		.byte	0
 10575 0637 30       		.byte	48
 10576 0638 01       		.byte	1
 10577 0639 00       		.byte	0
 10578 063a 00       		.byte	0
 10579 063b 00000000 		.space	5
 10579      00
 10580 0640 00       		.byte	0
 10581 0641 00       		.byte	0
 10582 0642 02       		.byte	2
 10583 0643 00       		.byte	0
 10584 0644 00       		.byte	0
 10585 0645 64       		.byte	100
 10586 0646 00       		.byte	0
 10587 0647 01       		.byte	1
 10588 0648 00       		.byte	0
 10589 0649 03       		.byte	3
 10590 064a 00       		.byte	0
 10591 064b 00       		.byte	0
 10592 064c 00       		.byte	0
 10593 064d 00       		.byte	0
 10594 064e 00       		.byte	0
 10595 064f 30       		.byte	48
 10596 0650 01       		.byte	1
 10597 0651 00       		.byte	0
 10598 0652 00       		.byte	0
 10599 0653 00000000 		.space	5
 10599      00
 10600 0658 00       		.byte	0
 10601 0659 00       		.byte	0
 10602 065a 02       		.byte	2
 10603 065b 00       		.byte	0
 10604 065c 00       		.byte	0
 10605 065d 64       		.byte	100
 10606 065e 00       		.byte	0
 10607 065f 01       		.byte	1
 10608 0660 00       		.byte	0
 10609 0661 03       		.byte	3
 10610 0662 00       		.byte	0
 10611 0663 00       		.byte	0
 10612 0664 00       		.byte	0
 10613 0665 00       		.byte	0
 10614 0666 00       		.byte	0
 10615 0667 30       		.byte	48
 10616 0668 01       		.byte	1
 10617 0669 00       		.byte	0
 10618 066a 00       		.byte	0
 10619 066b 00000000 		.space	5
 10619      00
 10620 0670 00       		.byte	0
 10621 0671 00       		.byte	0
 10622 0672 02       		.byte	2
 10623 0673 00       		.byte	0
 10624 0674 00       		.byte	0
 10625 0675 64       		.byte	100
 10626 0676 00       		.byte	0
 10627 0677 01       		.byte	1
 10628 0678 00       		.byte	0
 10629 0679 03       		.byte	3
 10630 067a 00       		.byte	0
 10631 067b 00       		.byte	0
 10632 067c 00       		.byte	0
 10633 067d 00       		.byte	0
 10634 067e 00       		.byte	0
 10635 067f 30       		.byte	48
 10636 0680 01       		.byte	1
 10637 0681 00       		.byte	0
 10638 0682 00       		.byte	0
 10639 0683 00000000 		.space	5
 10639      00
 10640 0688 00       		.byte	0
 10641 0689 00       		.byte	0
 10642 068a 02       		.byte	2
 10643 068b 00       		.byte	0
 10644 068c 00       		.byte	0
 10645 068d 64       		.byte	100
 10646 068e 00       		.byte	0
 10647 068f 01       		.byte	1
 10648 0690 00       		.byte	0
 10649 0691 03       		.byte	3
 10650 0692 00       		.byte	0
 10651 0693 00       		.byte	0
 10652 0694 00       		.byte	0
 10653 0695 00       		.byte	0
 10654 0696 00       		.byte	0
 10655 0697 30       		.byte	48
 10656 0698 01       		.byte	1
 10657 0699 00       		.byte	0
 10658 069a 00       		.byte	0
 10659 069b 00000000 		.space	5
 10659      00
 10662              	glProbeCtrlFull:
 10663 06a0 00       		.byte	0
 10664 06a1 00       		.byte	0
 10665 06a2 01       		.byte	1
 10666 06a3 01       		.byte	1
 10667 06a4 15       		.byte	21
 10668 06a5 16       		.byte	22
 10669 06a6 05       		.byte	5
 10670 06a7 00       		.byte	0
 10671 06a8 00       		.byte	0
 10672 06a9 00       		.byte	0
 10673 06aa 00       		.byte	0
 10674 06ab 00       		.byte	0
 10675 06ac 00       		.byte	0
 10676 06ad 00       		.byte	0
 10677 06ae 00       		.byte	0
 10678 06af 00       		.byte	0
 10679 06b0 00       		.byte	0
 10680 06b1 00       		.byte	0
 10681 06b2 00       		.byte	0
 10682 06b3 C6       		.byte	-58
 10683 06b4 99       		.byte	-103
 10684 06b5 00       		.byte	0
 10685 06b6 00       		.byte	0
 10686 06b7 40       		.byte	64
 10687 06b8 00       		.byte	0
 10688 06b9 00       		.byte	0
 10689 06ba 0000     		.space	2
 10692              	glProbeCtrl20:
 10693 06bc 00       		.byte	0
 10694 06bd 00       		.byte	0
 10695 06be 01       		.byte	1
 10696 06bf 01       		.byte	1
 10697 06c0 80       		.byte	-128
 10698 06c1 1A       		.byte	26
 10699 06c2 06       		.byte	6
 10700 06c3 00       		.byte	0
 10701 06c4 00       		.byte	0
 10702 06c5 00       		.byte	0
 10703 06c6 00       		.byte	0
 10704 06c7 00       		.byte	0
 10705 06c8 00       		.byte	0
 10706 06c9 00       		.byte	0
 10707 06ca 00       		.byte	0
 10708 06cb 00       		.byte	0
 10709 06cc 00       		.byte	0
 10710 06cd 00       		.byte	0
 10711 06ce 00       		.byte	0
 10712 06cf D2       		.byte	-46
 10713 06d0 0F       		.byte	15
 10714 06d1 00       		.byte	0
 10715 06d2 00       		.byte	0
 10716 06d3 40       		.byte	64
 10717 06d4 00       		.byte	0
 10718 06d5 00       		.byte	0
 10719 06d6 0000     		.space	2
 10722              	glProbeCtrl:
 10723 06d8 00       		.byte	0
 10724 06d9 00       		.byte	0
 10725 06da 01       		.byte	1
 10726 06db 01       		.byte	1
 10727 06dc 15       		.byte	21
 10728 06dd 16       		.byte	22
 10729 06de 05       		.byte	5
 10730 06df 00       		.byte	0
 10731 06e0 00       		.byte	0
 10732 06e1 00       		.byte	0
 10733 06e2 00       		.byte	0
 10734 06e3 00       		.byte	0
 10735 06e4 00       		.byte	0
 10736 06e5 00       		.byte	0
 10737 06e6 00       		.byte	0
 10738 06e7 00       		.byte	0
 10739 06e8 00       		.byte	0
 10740 06e9 00       		.byte	0
 10741 06ea 00       		.byte	0
 10742 06eb 48       		.byte	72
 10743 06ec 3F       		.byte	63
 10744 06ed 00       		.byte	0
 10745 06ee 00       		.byte	0
 10746 06ef 40       		.byte	64
 10747 06f0 00       		.byte	0
 10748 06f1 00       		.byte	0
 10749 06f2 0000     		.space	2
 10752              	glProbeStilCtrl:
 10753 06f4 01       		.byte	1
 10754 06f5 02       		.byte	2
 10755 06f6 00       		.byte	0
 10756 06f7 00       		.byte	0
 10757 06f8 C6       		.byte	-58
 10758 06f9 99       		.byte	-103
 10759 06fa 00       		.byte	0
 10760 06fb 00       		.byte	0
 10761 06fc 40       		.byte	64
 10762 06fd 00       		.byte	0
 10763 06fe 00       		.byte	0
 10764 06ff 00       		.space	1
 10767              	glProbeStilCtrl20:
 10768 0700 01       		.byte	1
 10769 0701 01       		.byte	1
 10770 0702 00       		.byte	0
 10771 0703 00       		.byte	0
 10772 0704 D2       		.byte	-46
 10773 0705 0F       		.byte	15
 10774 0706 00       		.byte	0
 10775 0707 00       		.byte	0
 10776 0708 40       		.byte	64
 10777 0709 00       		.byte	0
 10778 070a 00       		.byte	0
 10781              	snapButFlag:
 10782 070b 01       		.byte	1
 10785              	CyFxGpifTransition:
 10786 070c 0000     		.short	0
 10787 070e 5555     		.short	21845
 10788 0710 8888     		.short	-30584
 10789 0712 AAAA     		.short	-21846
 10790 0714 3333     		.short	13107
 10791 0716 0000     		.space	2
 10794              	CyFxGpifWavedata:
 10795 0718 0181731E 		.word	510886145
 10796 071c 00000000 		.word	0
 10797 0720 00000080 		.word	-2147483648
 10798 0724 00000000 		.word	0
 10799 0728 00000000 		.word	0
 10800 072c 00000000 		.word	0
 10801 0730 0201702E 		.word	779092226
 10802 0734 00010000 		.word	256
 10803 0738 A0000080 		.word	-2147483488
 10804 073c 00000000 		.word	0
 10805 0740 00000000 		.word	0
 10806 0744 00000000 		.word	0
 10807 0748 0380722E 		.word	779255811
 10808 074c 02010020 		.word	536871170
 10809 0750 60000080 		.word	-2147483552
 10810 0754 00000000 		.word	0
 10811 0758 00000000 		.word	0
 10812 075c 00000000 		.word	0
 10813 0760 0460722E 		.word	779247620
 10814 0764 02010024 		.word	603980034
 10815 0768 90000080 		.word	-2147483504
 10816 076c 0594731E 		.word	510891013
 10817 0770 06000000 		.word	6
 10818 0774 00000080 		.word	-2147483648
 10819 0778 0380722E 		.word	779255811
 10820 077c 02010020 		.word	536871170
 10821 0780 60000080 		.word	-2147483552
 10822 0784 0693731E 		.word	510890758
 10823 0788 06000000 		.word	6
 10824 078c 00000080 		.word	-2147483648
 10825 0790 0720703E 		.word	1047535623
 10826 0794 08010000 		.word	264
 10827 0798 00000080 		.word	-2147483648
 10828 079c 0820703E 		.word	1047535624
 10829 07a0 08010000 		.word	264
 10830 07a4 00000080 		.word	-2147483648
 10831 07a8 0920703E 		.word	1047535625
 10832 07ac 08010000 		.word	264
 10833 07b0 00000080 		.word	-2147483648
 10834 07b4 0A20703E 		.word	1047535626
 10835 07b8 08010000 		.word	264
 10836 07bc 00000080 		.word	-2147483648
 10837 07c0 0380722E 		.word	779255811
 10838 07c4 02010020 		.word	536871170
 10839 07c8 60000080 		.word	-2147483552
 10840 07cc 0B000000 		.word	11
 10841 07d0 00000000 		.word	0
 10842 07d4 00010080 		.word	-2147483392
 10843 07d8 0460722E 		.word	779247620
 10844 07dc 02010024 		.word	603980034
 10845 07e0 90000080 		.word	-2147483504
 10846 07e4 0D000000 		.word	13
 10847 07e8 00000000 		.word	0
 10848 07ec 00010080 		.word	-2147483392
 10849 07f0 0460722E 		.word	779247620
 10850 07f4 02010024 		.word	603980034
 10851 07f8 90000080 		.word	-2147483504
 10852 07fc 0C000000 		.word	12
 10853 0800 00000000 		.word	0
 10854 0804 00010080 		.word	-2147483392
 10855 0808 0380722E 		.word	779255811
 10856 080c 02010020 		.word	536871170
 10857 0810 60000080 		.word	-2147483552
 10858 0814 0E000000 		.word	14
 10859 0818 00000000 		.word	0
 10860 081c 00010080 		.word	-2147483392
 10861 0820 00000000 		.word	0
 10862 0824 00000000 		.word	0
 10863 0828 00000000 		.word	0
 10864 082c 00000000 		.word	0
 10865 0830 00000000 		.word	0
 10866 0834 00000000 		.word	0
 10869              	CyFxGpifWavedataPosition:
 10870 0838 00       		.byte	0
 10871 0839 01       		.byte	1
 10872 083a 02       		.byte	2
 10873 083b 03       		.byte	3
 10874 083c 04       		.byte	4
 10875 083d 05       		.byte	5
 10876 083e 06       		.byte	6
 10877 083f 07       		.byte	7
 10878 0840 08       		.byte	8
 10879 0841 09       		.byte	9
 10880 0842 0A       		.byte	10
 10881 0843 0B       		.byte	11
 10882 0844 0B       		.byte	11
 10883 0845 0B       		.byte	11
 10884 0846 0B       		.byte	11
 10885 0847 00       		.space	1
 10888              	CyFxGpifRegValue:
 10889 0848 08830080 		.word	-2147450104
 10890 084c 67000000 		.word	103
 10891 0850 00000000 		.word	0
 10892 0854 46000000 		.word	70
 10893 0858 00000000 		.word	0
 10894 085c 00000000 		.word	0
 10895 0860 02000000 		.word	2
 10896 0864 82000000 		.word	130
 10897 0868 82070000 		.word	1922
 10898 086c 40040000 		.word	1088
 10899 0870 FCFF0000 		.word	65532
 10900 0874 28000000 		.word	40
 10901 0878 00000000 		.word	0
 10902 087c 00000000 		.word	0
 10903 0880 00000000 		.word	0
 10904 0884 00000000 		.word	0
 10905 0888 01000000 		.word	1
 10906 088c 00000000 		.word	0
 10907 0890 00000000 		.word	0
 10908 0894 00000000 		.word	0
 10909 0898 00000000 		.word	0
 10910 089c 00000000 		.word	0
 10911 08a0 00000000 		.word	0
 10912 08a4 00000000 		.word	0
 10913 08a8 00000000 		.word	0
 10914 08ac 00000000 		.word	0
 10915 08b0 00000000 		.word	0
 10916 08b4 00000000 		.word	0
 10917 08b8 00000000 		.word	0
 10918 08bc 06000000 		.word	6
 10919 08c0 00000000 		.word	0
 10920 08c4 FFFF0000 		.word	65535
 10921 08c8 09010000 		.word	265
 10922 08cc 00000000 		.word	0
 10923 08d0 F71F0000 		.word	8183
 10924 08d4 00000000 		.word	0
 10925 08d8 FFFF0000 		.word	65535
 10926 08dc 09010000 		.word	265
 10927 08e0 00000000 		.word	0
 10928 08e4 F71F0000 		.word	8183
 10929 08e8 00000000 		.word	0
 10930 08ec 00000000 		.word	0
 10931 08f0 00000000 		.word	0
 10932 08f4 00000000 		.word	0
 10933 08f8 00000000 		.word	0
 10934 08fc 00000000 		.word	0
 10935 0900 00000000 		.word	0
 10936 0904 00000000 		.word	0
 10937 0908 00000000 		.word	0
 10938 090c 00000000 		.word	0
 10939 0910 00000000 		.word	0
 10940 0914 00000000 		.word	0
 10941 0918 00000000 		.word	0
 10942 091c 00000000 		.word	0
 10943 0920 00000000 		.word	0
 10944 0924 00000000 		.word	0
 10945 0928 00000000 		.word	0
 10946 092c 00000000 		.word	0
 10947 0930 00000000 		.word	0
 10948 0934 00000000 		.word	0
 10949 0938 00000000 		.word	0
 10950 093c 00000000 		.word	0
 10951 0940 00000000 		.word	0
 10952 0944 00040180 		.word	-2147417088
 10953 0948 01040180 		.word	-2147417087
 10954 094c 02040180 		.word	-2147417086
 10955 0950 03040180 		.word	-2147417085
 10956 0954 00000000 		.word	0
 10957 0958 00000000 		.word	0
 10958 095c 00000000 		.word	0
 10959 0960 00000000 		.word	0
 10960 0964 00000000 		.word	0
 10961 0968 00000000 		.word	0
 10962 096c 00000000 		.word	0
 10963 0970 00000000 		.word	0
 10964 0974 C1FFFFFF 		.word	-63
 10967              	CyFxGpifTransition_usb2:
 10968 0978 0000     		.short	0
 10969 097a 5555     		.short	21845
 10970 097c AAAA     		.short	-21846
 10971 097e 8888     		.short	-30584
 10972 0980 1111     		.short	4369
 10973 0982 4444     		.short	17476
 10974 0984 3333     		.short	13107
 10975 0986 CCCC     		.short	-13108
 10978              	CyFxGpifWavedata_usb2:
 10979 0988 0181731E 		.word	510886145
 10980 098c 00000000 		.word	0
 10981 0990 00000080 		.word	-2147483648
 10982 0994 00000000 		.word	0
 10983 0998 00000000 		.word	0
 10984 099c 00000000 		.word	0
 10985 09a0 0201703E 		.word	1047527682
 10986 09a4 00010000 		.word	256
 10987 09a8 A00000C0 		.word	-1073741664
 10988 09ac 00000000 		.word	0
 10989 09b0 00000000 		.word	0
 10990 09b4 00000000 		.word	0
 10991 09b8 0394731E 		.word	510891011
 10992 09bc 04000020 		.word	536870916
 10993 09c0 60004080 		.word	-2143289248
 10994 09c4 00000000 		.word	0
 10995 09c8 00000000 		.word	0
 10996 09cc 00000000 		.word	0
 10997 09d0 0620702E 		.word	779100166
 10998 09d4 0C000000 		.word	12
 10999 09d8 00000080 		.word	-2147483648
 11000 09dc 0620702E 		.word	779100166
 11001 09e0 0C000000 		.word	12
 11002 09e4 00000080 		.word	-2147483648
 11003 09e8 0394731E 		.word	510891011
 11004 09ec 04000020 		.word	536870916
 11005 09f0 60004080 		.word	-2143289248
 11006 09f4 0620702E 		.word	779100166
 11007 09f8 0C000000 		.word	12
 11008 09fc 00000080 		.word	-2147483648
 11009 0a00 0C93731E 		.word	510890764
 11010 0a04 04000024 		.word	603979780
 11011 0a08 90004080 		.word	-2143289200
 11012 0a0c 0D20702E 		.word	779100173
 11013 0a10 0C000000 		.word	12
 11014 0a14 00000080 		.word	-2147483648
 11015 0a18 0780724E 		.word	1316126727
 11016 0a1c 0A000000 		.word	10
 11017 0a20 00000080 		.word	-2147483648
 11018 0a24 08000000 		.word	8
 11019 0a28 00000000 		.word	0
 11020 0a2c 00010080 		.word	-2147483392
 11021 0a30 0920702E 		.word	779100169
 11022 0a34 0C010000 		.word	268
 11023 0a38 00000080 		.word	-2147483648
 11024 0a3c 0A01701E 		.word	510656778
 11025 0a40 0E000100 		.word	65550
 11026 0a44 00000080 		.word	-2147483648
 11027 0a48 00000000 		.word	0
 11028 0a4c 00000000 		.word	0
 11029 0a50 00000000 		.word	0
 11030 0a54 00000000 		.word	0
 11031 0a58 00000000 		.word	0
 11032 0a5c 00000000 		.word	0
 11033 0a60 0394731E 		.word	510891011
 11034 0a64 04000020 		.word	536870916
 11035 0a68 60004080 		.word	-2143289248
 11036 0a6c 08000000 		.word	8
 11037 0a70 00000000 		.word	0
 11038 0a74 00010080 		.word	-2147483392
 11039 0a78 0B000000 		.word	11
 11040 0a7c 00000000 		.word	0
 11041 0a80 00010080 		.word	-2147483392
 11042 0a84 0C93731E 		.word	510890764
 11043 0a88 04000024 		.word	603979780
 11044 0a8c 90004080 		.word	-2143289200
 11045 0a90 0D20702E 		.word	779100173
 11046 0a94 0C000000 		.word	12
 11047 0a98 00000080 		.word	-2147483648
 11048 0a9c 0D20702E 		.word	779100173
 11049 0aa0 0C000000 		.word	12
 11050 0aa4 00000080 		.word	-2147483648
 11051 0aa8 0E60724E 		.word	1316118542
 11052 0aac 0A000000 		.word	10
 11053 0ab0 00000080 		.word	-2147483648
 11054 0ab4 0F000000 		.word	15
 11055 0ab8 00000000 		.word	0
 11056 0abc 00010080 		.word	-2147483392
 11057 0ac0 1020702E 		.word	779100176
 11058 0ac4 0C010000 		.word	268
 11059 0ac8 00000080 		.word	-2147483648
 11060 0acc 1101701E 		.word	510656785
 11061 0ad0 0E000100 		.word	65550
 11062 0ad4 00000080 		.word	-2147483648
 11063 0ad8 0C93731E 		.word	510890764
 11064 0adc 04000024 		.word	603979780
 11065 0ae0 90004080 		.word	-2143289200
 11066 0ae4 0F000000 		.word	15
 11067 0ae8 00000000 		.word	0
 11068 0aec 00010080 		.word	-2147483392
 11069 0af0 12000000 		.word	18
 11070 0af4 00000000 		.word	0
 11071 0af8 00010080 		.word	-2147483392
 11072 0afc 0394731E 		.word	510891011
 11073 0b00 04000020 		.word	536870916
 11074 0b04 60004080 		.word	-2143289248
 11075 0b08 0480732E 		.word	779321348
 11076 0b0c 02010000 		.word	258
 11077 0b10 0000C0C0 		.word	-1061158912
 11078 0b14 0580732E 		.word	779321349
 11079 0b18 02010000 		.word	258
 11080 0b1c 0000C0C0 		.word	-1061158912
 11081 0b20 0580732E 		.word	779321349
 11082 0b24 02010000 		.word	258
 11083 0b28 0000C0C0 		.word	-1061158912
 11084 0b2c 0480732E 		.word	779321348
 11085 0b30 02010000 		.word	258
 11086 0b34 0000C0C0 		.word	-1061158912
 11089              	CyFxGpifWavedataPosition_usb2:
 11090 0b38 00       		.byte	0
 11091 0b39 01       		.byte	1
 11092 0b3a 02       		.byte	2
 11093 0b3b 03       		.byte	3
 11094 0b3c 04       		.byte	4
 11095 0b3d 05       		.byte	5
 11096 0b3e 06       		.byte	6
 11097 0b3f 07       		.byte	7
 11098 0b40 08       		.byte	8
 11099 0b41 09       		.byte	9
 11100 0b42 0A       		.byte	10
 11101 0b43 08       		.byte	8
 11102 0b44 0B       		.byte	11
 11103 0b45 0C       		.byte	12
 11104 0b46 0D       		.byte	13
 11105 0b47 08       		.byte	8
 11106 0b48 0E       		.byte	14
 11107 0b49 0F       		.byte	15
 11108 0b4a 08       		.byte	8
 11109 0b4b 08       		.byte	8
 11110 0b4c 08       		.byte	8
 11111 0b4d 08       		.byte	8
 11112 0b4e 08       		.byte	8
 11113 0b4f 08       		.byte	8
 11114 0b50 08       		.byte	8
 11115 0b51 08       		.byte	8
 11116 0b52 08       		.byte	8
 11117 0b53 08       		.byte	8
 11118 0b54 08       		.byte	8
 11119 0b55 08       		.byte	8
 11120 0b56 08       		.byte	8
 11121 0b57 08       		.byte	8
 11122 0b58 08       		.byte	8
 11123 0b59 08       		.byte	8
 11124 0b5a 08       		.byte	8
 11125 0b5b 08       		.byte	8
 11126 0b5c 08       		.byte	8
 11127 0b5d 08       		.byte	8
 11128 0b5e 08       		.byte	8
 11129 0b5f 08       		.byte	8
 11130 0b60 08       		.byte	8
 11131 0b61 08       		.byte	8
 11132 0b62 08       		.byte	8
 11133 0b63 08       		.byte	8
 11134 0b64 08       		.byte	8
 11135 0b65 08       		.byte	8
 11136 0b66 08       		.byte	8
 11137 0b67 08       		.byte	8
 11138 0b68 08       		.byte	8
 11139 0b69 08       		.byte	8
 11140 0b6a 08       		.byte	8
 11141 0b6b 08       		.byte	8
 11142 0b6c 08       		.byte	8
 11143 0b6d 08       		.byte	8
 11144 0b6e 08       		.byte	8
 11145 0b6f 08       		.byte	8
 11146 0b70 08       		.byte	8
 11147 0b71 08       		.byte	8
 11148 0b72 08       		.byte	8
 11149 0b73 08       		.byte	8
 11150 0b74 08       		.byte	8
 11151 0b75 08       		.byte	8
 11152 0b76 08       		.byte	8
 11153 0b77 08       		.byte	8
 11154 0b78 08       		.byte	8
 11155 0b79 08       		.byte	8
 11156 0b7a 08       		.byte	8
 11157 0b7b 08       		.byte	8
 11158 0b7c 08       		.byte	8
 11159 0b7d 08       		.byte	8
 11160 0b7e 08       		.byte	8
 11161 0b7f 08       		.byte	8
 11162 0b80 08       		.byte	8
 11163 0b81 08       		.byte	8
 11164 0b82 08       		.byte	8
 11165 0b83 08       		.byte	8
 11166 0b84 08       		.byte	8
 11167 0b85 08       		.byte	8
 11168 0b86 08       		.byte	8
 11169 0b87 08       		.byte	8
 11170 0b88 08       		.byte	8
 11171 0b89 08       		.byte	8
 11172 0b8a 08       		.byte	8
 11173 0b8b 08       		.byte	8
 11174 0b8c 08       		.byte	8
 11175 0b8d 08       		.byte	8
 11176 0b8e 08       		.byte	8
 11177 0b8f 08       		.byte	8
 11178 0b90 08       		.byte	8
 11179 0b91 08       		.byte	8
 11180 0b92 08       		.byte	8
 11181 0b93 08       		.byte	8
 11182 0b94 08       		.byte	8
 11183 0b95 08       		.byte	8
 11184 0b96 08       		.byte	8
 11185 0b97 08       		.byte	8
 11186 0b98 08       		.byte	8
 11187 0b99 08       		.byte	8
 11188 0b9a 08       		.byte	8
 11189 0b9b 08       		.byte	8
 11190 0b9c 08       		.byte	8
 11191 0b9d 08       		.byte	8
 11192 0b9e 08       		.byte	8
 11193 0b9f 08       		.byte	8
 11194 0ba0 08       		.byte	8
 11195 0ba1 08       		.byte	8
 11196 0ba2 08       		.byte	8
 11197 0ba3 08       		.byte	8
 11198 0ba4 08       		.byte	8
 11199 0ba5 08       		.byte	8
 11200 0ba6 08       		.byte	8
 11201 0ba7 08       		.byte	8
 11202 0ba8 08       		.byte	8
 11203 0ba9 08       		.byte	8
 11204 0baa 08       		.byte	8
 11205 0bab 08       		.byte	8
 11206 0bac 08       		.byte	8
 11207 0bad 08       		.byte	8
 11208 0bae 08       		.byte	8
 11209 0baf 08       		.byte	8
 11210 0bb0 08       		.byte	8
 11211 0bb1 08       		.byte	8
 11212 0bb2 08       		.byte	8
 11213 0bb3 08       		.byte	8
 11214 0bb4 08       		.byte	8
 11215 0bb5 08       		.byte	8
 11216 0bb6 08       		.byte	8
 11217 0bb7 08       		.byte	8
 11218 0bb8 00       		.byte	0
 11219 0bb9 01       		.byte	1
 11220 0bba 02       		.byte	2
 11221 0bbb 10       		.byte	16
 11222 0bbc 04       		.byte	4
 11223 0bbd 05       		.byte	5
 11224 0bbe 06       		.byte	6
 11225 0bbf 07       		.byte	7
 11226 0bc0 08       		.byte	8
 11227 0bc1 09       		.byte	9
 11228 0bc2 0A       		.byte	10
 11229 0bc3 08       		.byte	8
 11230 0bc4 11       		.byte	17
 11231 0bc5 0C       		.byte	12
 11232 0bc6 0D       		.byte	13
 11233 0bc7 08       		.byte	8
 11234 0bc8 0E       		.byte	14
 11235 0bc9 0F       		.byte	15
 11236 0bca 08       		.byte	8
 11237 0bcb 00       		.space	1
 11240              	CyFxGpifRegValue_usb2:
 11241 0bcc 08830080 		.word	-2147450104
 11242 0bd0 67000000 		.word	103
 11243 0bd4 01000000 		.word	1
 11244 0bd8 46000000 		.word	70
 11245 0bdc 00000000 		.word	0
 11246 0be0 00000000 		.word	0
 11247 0be4 02000000 		.word	2
 11248 0be8 82000000 		.word	130
 11249 0bec 82070000 		.word	1922
 11250 0bf0 40040000 		.word	1088
 11251 0bf4 FCFF0000 		.word	65532
 11252 0bf8 28000000 		.word	40
 11253 0bfc 00000000 		.word	0
 11254 0c00 00000000 		.word	0
 11255 0c04 00000000 		.word	0
 11256 0c08 00000000 		.word	0
 11257 0c0c 01000000 		.word	1
 11258 0c10 00000000 		.word	0
 11259 0c14 00000000 		.word	0
 11260 0c18 00000000 		.word	0
 11261 0c1c 00000000 		.word	0
 11262 0c20 00000000 		.word	0
 11263 0c24 00000000 		.word	0
 11264 0c28 00000000 		.word	0
 11265 0c2c 00000000 		.word	0
 11266 0c30 00000000 		.word	0
 11267 0c34 00000000 		.word	0
 11268 0c38 00000000 		.word	0
 11269 0c3c 00000000 		.word	0
 11270 0c40 06000000 		.word	6
 11271 0c44 00000000 		.word	0
 11272 0c48 FFFF0000 		.word	65535
 11273 0c4c 09010000 		.word	265
 11274 0c50 00000000 		.word	0
 11275 0c54 F71F0000 		.word	8183
 11276 0c58 00000000 		.word	0
 11277 0c5c FFFF0000 		.word	65535
 11278 0c60 09010000 		.word	265
 11279 0c64 00000000 		.word	0
 11280 0c68 F71F0000 		.word	8183
 11281 0c6c 00000000 		.word	0
 11282 0c70 00000000 		.word	0
 11283 0c74 00000000 		.word	0
 11284 0c78 00000000 		.word	0
 11285 0c7c 00000000 		.word	0
 11286 0c80 00000000 		.word	0
 11287 0c84 00000000 		.word	0
 11288 0c88 00000000 		.word	0
 11289 0c8c 00000000 		.word	0
 11290 0c90 00000000 		.word	0
 11291 0c94 00000000 		.word	0
 11292 0c98 00000000 		.word	0
 11293 0c9c 00000000 		.word	0
 11294 0ca0 00000000 		.word	0
 11295 0ca4 00000000 		.word	0
 11296 0ca8 00000000 		.word	0
 11297 0cac 00000000 		.word	0
 11298 0cb0 00000000 		.word	0
 11299 0cb4 00000000 		.word	0
 11300 0cb8 00000000 		.word	0
 11301 0cbc 00000000 		.word	0
 11302 0cc0 00000000 		.word	0
 11303 0cc4 00000000 		.word	0
 11304 0cc8 00040180 		.word	-2147417088
 11305 0ccc 01040180 		.word	-2147417087
 11306 0cd0 02040180 		.word	-2147417086
 11307 0cd4 03040180 		.word	-2147417085
 11308 0cd8 00000000 		.word	0
 11309 0cdc 00000000 		.word	0
 11310 0ce0 00000000 		.word	0
 11311 0ce4 00000000 		.word	0
 11312 0ce8 00000000 		.word	0
 11313 0cec 00000000 		.word	0
 11314 0cf0 00000000 		.word	0
 11315 0cf4 00000000 		.word	0
 11316 0cf8 C1FFFFFF 		.word	-63
 11317              		.section	.rodata.str1.4,"aMS",%progbits,1
 11318              		.align	2
 11319              	.LC0:
 11320 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 11320      7065722D 
 11320      74696D65 
 11320      72202564 
 11320      0D0A00
 11321 0013 00       		.space	1
 11322              	.LC1:
 11323 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 11323      636F6D6D 
 11323      616E6420 
 11323      71756575 
 11323      65206973 
 11324 0037 00       		.space	1
 11325              	.LC2:
 11326 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 11326      706F732D 
 11326      74696D65 
 11326      72202564 
 11326      2025640D 
 11327 004e 0000     		.space	2
 11328              	.LC3:
 11329 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 11329      5420656E 
 11329      636F756E 
 11329      74657265 
 11329      642E2E2E 
 11330              	.LC4:
 11331 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 11331      454E4420 
 11331      656E636F 
 11331      756E7465 
 11331      7265642E 
 11332 0092 0000     		.space	2
 11333              	.LC5:
 11334 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 11334      64697363 
 11334      6F6E6E65 
 11334      63746564 
 11334      2E2E2E30 
 11335 00b3 00       		.space	1
 11336              	.LC6:
 11337 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 11337      7220696E 
 11337      206D756C 
 11337      74696368 
 11337      616E6E65 
 11338 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 11338      2025782C 
 11338      20646D61 
 11338      446F6E65 
 11338      20256420 
 11339              	.LC7:
 11340 0100 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 11340      43595F46 
 11340      585F5556 
 11340      435F5649 
 11340      44454F5F 
 11341 0133 0A00     		.ascii	"\012\000"
 11342 0135 000000   		.space	3
 11343              	.LC8:
 11344 0138 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 11344      43595F46 
 11344      585F5556 
 11344      435F5649 
 11344      44454F5F 
 11345 016b 00       		.ascii	"\000"
 11346              	.LC9:
 11347 016c 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 11347      726E6174 
 11347      65207365 
 11347      7474696E 
 11347      6720302E 
 11348              	.LC10:
 11349 0184 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 11349      72206665 
 11349      61747572 
 11349      65207265 
 11349      71756573 
 11350 01a7 00       		.space	1
 11351              	.LC11:
 11352 01a8 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 11352      6F6D6D69 
 11352      74656F66 
 11352      20737461 
 11352      7465203D 
 11353              	.LC12:
 11354 01c0 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 11354      6E656C20 
 11354      53657420 
 11354      57726170 
 11354      55702066 
 11355 01ed 000000   		.space	3
 11356              	.LC13:
 11357 01f0 4572726F 		.ascii	"Error handler...\015\012\000"
 11357      72206861 
 11357      6E646C65 
 11357      722E2E2E 
 11357      0D0A00
 11358 0203 00       		.space	1
 11359              	.LC14:
 11360 0204 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 11360      69742045 
 11360      4F462066 
 11360      61696C65 
 11360      64210D0A 
 11361 0219 000000   		.space	3
 11362              	.LC15:
 11363 021c 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 11363      49324320 
 11363      636F6D6D 
 11363      616E6420 
 11363      69732030 
 11364 024f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11364      78257820 
 11364      30782578 
 11364      20307825 
 11364      78203078 
 11365              	.LC16:
 11366 0268 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 11366      49324320 
 11366      636F6D6D 
 11366      616E6420 
 11366      73657474 
 11367 028e 0000     		.space	2
 11368              	.LC17:
 11369 0290 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 11369      73687574 
 11369      74657220 
 11369      73657420 
 11369      76616C75 
 11370 02ba 0000     		.space	2
 11371              	.LC18:
 11372 02bc 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 11372      20736875 
 11372      74746572 
 11372      20737065 
 11372      65642E20 
 11373 02e1 000000   		.space	3
 11374              	.LC19:
 11375 02e4 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 11375      20736875 
 11375      74746572 
 11375      20737065 
 11375      6564322E 
 11376 030a 0000     		.space	2
 11377              	.LC20:
 11378 030c 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 11378      206C6967 
 11378      68742063 
 11378      6F6D7065 
 11378      6E736174 
 11379 033f 25640D0A 		.ascii	"%d\015\012\000"
 11379      00
 11380              	.LC21:
 11381 0344 54686520 		.ascii	"The I2C current data is not available. try again. %"
 11381      49324320 
 11381      63757272 
 11381      656E7420 
 11381      64617461 
 11382 0377 64202564 		.ascii	"d %d\015\012\000"
 11382      0D0A00
 11383 037e 0000     		.space	2
 11384              	.LC22:
 11385 0380 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 11385      26414743 
 11385      2073656E 
 11385      7420746F 
 11385      20686F73 
 11386 03a6 0000     		.space	2
 11387              	.LC23:
 11388 03a8 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11388      73687574 
 11388      74657226 
 11388      6578706F 
 11388      73757265 
 11389 03d3 00       		.space	1
 11390              	.LC24:
 11391 03d4 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 11391      26414743 
 11391      20676F74 
 11391      74656E20 
 11391      66726F6D 
 11392 0405 0A00     		.ascii	"\012\000"
 11393 0407 00       		.space	1
 11394              	.LC25:
 11395 0408 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 11395      74657220 
 11395      6C657665 
 11395      6C20676F 
 11395      7474656E 
 11396 043b 25640D0A 		.ascii	"%d\015\012\000"
 11396      00
 11397              	.LC26:
 11398 0440 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 11398      20746865 
 11398      20766964 
 11398      656F206D 
 11398      6F646520 
 11399 0462 0000     		.space	2
 11400              	.LC27:
 11401 0464 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 11401      67657420 
 11401      64617461 
 11401      2066726F 
 11401      6D20686F 
 11402 0491 000000   		.space	3
 11403              	.LC28:
 11404 0494 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 11404      52657175 
 11404      65737420 
 11404      30782578 
 11404      20706172 
 11405 04c7 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 11405      6E642074 
 11405      6F20686F 
 11405      73742030 
 11405      78257820 
 11406 04e2 0000     		.space	2
 11407              	.LC29:
 11408 04e4 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 11408      204F7020 
 11408      72656365 
 11408      69766573 
 11408      20284354 
 11409 050b 00       		.space	1
 11410              	.LC30:
 11411 050c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 11411      756C7420 
 11411      73656C65 
 11411      63746F72 
 11411      20284354 
 11412 052e 0000     		.space	2
 11413              	.LC31:
 11414 0530 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 11414      756C7420 
 11414      72657175 
 11414      65737420 
 11414      28435429 
 11415 0551 000000   		.space	3
 11416              	.LC32:
 11417 0554 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 11417      52657175 
 11417      65737420 
 11417      30782578 
 11417      20706172 
 11418 0587 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 11418      20307825 
 11418      78202F20 
 11418      73656E64 
 11418      20746F20 
 11419 05b4 00       		.ascii	"\000"
 11420 05b5 000000   		.space	3
 11421              	.LC33:
 11422 05b8 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 11422      73706565 
 11422      64203D20 
 11422      25642065 
 11422      76656E66 
 11423 05e8 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 11423      71756573 
 11423      74203D20 
 11423      30782578 
 11423      20775661 
 11424 0618 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 11424      203D2030 
 11424      78257820 
 11424      6973666C 
 11424      61672030 
 11425 0632 0000     		.space	2
 11426              	.LC34:
 11427 0634 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 11427      64656661 
 11427      756C7420 
 11427      73657475 
 11427      70207265 
 11428              	.LC35:
 11429 0660 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 11429      6F207374 
 11429      7265616D 
 11429      20474554 
 11429      20726571 
 11430 0685 000000   		.space	3
 11431              	.LC36:
 11432 0688 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 11432      74686520 
 11432      76696465 
 11432      6F206D6F 
 11432      64652066 
 11433 06a9 000000   		.space	3
 11434              	.LC37:
 11435 06ac 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 11435      74686520 
 11435      76696465 
 11435      6F206D6F 
 11435      64652066 
 11436 06d1 000000   		.space	3
 11437              	.LC38:
 11438 06d4 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 11438      43595F46 
 11438      585F5556 
 11438      435F5354 
 11438      5245414D 
 11439 06fa 0000     		.space	2
 11440              	.LC39:
 11441 06fc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 11441      55564320 
 11441      7374696C 
 11441      6C205072 
 11441      6F622873 
 11442 0727 00       		.space	1
 11443              	.LC40:
 11444 0728 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 11444      74686520 
 11444      7374696C 
 11444      6C206D6F 
 11444      64652066 
 11445 0749 000000   		.space	3
 11446              	.LC41:
 11447 074c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 11447      7374696C 
 11447      6C20636F 
 11447      6D6D6974 
 11447      20636F6E 
 11448              	.LC42:
 11449 0774 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 11449      43595F46 
 11449      585F5556 
 11449      435F5354 
 11449      494C5F45 
 11450              	.LC43:
 11451 0798 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 11451      55564320 
 11451      7374696C 
 11451      6C207472 
 11451      69676765 
 11452 07c1 000000   		.space	3
 11453              	.LC44:
 11454 07c4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 11454      7374696C 
 11454      6C207472 
 11454      69676765 
 11454      7220636F 
 11455 07eb 00       		.space	1
 11456              	.LC45:
 11457 07ec 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 11457      65642074 
 11457      6F207365 
 11457      6E642069 
 11457      6E746572 
 11458 081d 0A00     		.ascii	"\012\000"
 11459 081f 00       		.space	1
 11460              	.LC46:
 11461 0820 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 11461      73657420 
 11461      64656620 
 11461      64617461 
 11461      20307825 
 11462 083f 00       		.space	1
 11463              	.LC47:
 11464 0840 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 11464      73657420 
 11464      64656620 
 11464      64617461 
 11464      20307825 
 11465 0873 2E0D0A00 		.ascii	".\015\012\000"
 11466 0877 00       		.space	1
 11467              	.LC48:
 11468 0878 55415254 		.ascii	"UART initialization failed!\012\000"
 11468      20696E69 
 11468      7469616C 
 11468      697A6174 
 11468      696F6E20 
 11469 0895 000000   		.space	3
 11470              	.LC49:
 11471 0898 49324320 		.ascii	"I2C initialization failed!\012\000"
 11471      696E6974 
 11471      69616C69 
 11471      7A617469 
 11471      6F6E2066 
 11472              	.LC50:
 11473 08b4 49324320 		.ascii	"I2C configuration failed!\012\000"
 11473      636F6E66 
 11473      69677572 
 11473      6174696F 
 11473      6E206661 
 11474 08cf 00       		.space	1
 11475              	.LC51:
 11476 08d0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 11476      43726561 
 11476      74652045 
 11476      76656E74 
 11476      20666169 
 11477 08fa 0000     		.space	2
 11478              	.LC52:
 11479 08fc 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 11479      20496E69 
 11479      74206661 
 11479      696C6564 
 11479      2C204572 
 11480 091f 00       		.space	1
 11481              	.LC53:
 11482 0920 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 11482      204F7665 
 11482      72726964 
 11482      65206661 
 11482      696C6564 
 11483 0947 00       		.space	1
 11484              	.LC54:
 11485 0948 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 11485      28323029 
 11485      204F7665 
 11485      72726964 
 11485      65206661 
 11486 0973 00       		.space	1
 11487              	.LC55:
 11488 0974 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 11488      28323429 
 11488      204F7665 
 11488      72726964 
 11488      65206661 
 11489 099f 00       		.space	1
 11490              	.LC56:
 11491 09a0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 11491      20536574 
 11491      20287265 
 11491      73657420 
 11491      32322920 
 11492 09d2 00       		.ascii	"\000"
 11493 09d3 00       		.space	1
 11494              	.LC57:
 11495 09d4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 11495      20536574 
 11495      2028706F 
 11495      77657220 
 11495      32302920 
 11496 0a06 00       		.ascii	"\000"
 11497 0a07 00       		.space	1
 11498              	.LC58:
 11499 0a08 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 11499      20536574 
 11499      2028736E 
 11499      61702073 
 11499      686F7420 
 11500 0a3b 25640A00 		.ascii	"%d\012\000"
 11501 0a3f 00       		.space	1
 11502              	.LC59:
 11503 0a40 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 11503      46756E63 
 11503      74696F6E 
 11503      20466169 
 11503      6C656420 
 11504 0a6f 00       		.space	1
 11505              	.LC60:
 11506 0a70 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 11506      46756E63 
 11506      74696F6E 
 11506      20466169 
 11506      6C656420 
 11507 0a9f 00       		.space	1
 11508              	.LC61:
 11509 0aa0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 11509      53657420 
 11509      456E6470 
 11509      6F696E74 
 11509      20636F6E 
 11510 0ad0 00       		.ascii	"\000"
 11511 0ad1 000000   		.space	3
 11512              	.LC62:
 11513 0ad4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 11513      496E7465 
 11513      72727570 
 11513      74205374 
 11513      61747573 
 11514 0b07 20436F64 		.ascii	" Code = %d\012\000"
 11514      65203D20 
 11514      25640A00 
 11515 0b13 00       		.space	1
 11516              	.LC63:
 11517 0b14 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 11517      65642074 
 11517      6F20616C 
 11517      6C6F6361 
 11517      7465206D 
 11518 0b47 65720D0A 		.ascii	"er\015\012\000"
 11518      00
 11519              	.LC64:
 11520 0b4c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 11520      4368616E 
 11520      6E656C20 
 11520      43726561 
 11520      74696F6E 
 11521 0b7a 0000     		.space	2
 11522              	.LC65:
 11523 0b7c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 11523      436F6E6E 
 11523      65637420 
 11523      6661696C 
 11523      65642C20 
 11524 0ba1 000000   		.space	3
 11525              	.LC66:
 11526 0ba4 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 11526      74686520 
 11526      76696465 
 11526      6F206D6F 
 11526      64652066 
 11527 0bc6 0000     		.space	2
 11528              	.LC67:
 11529 0bc8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 11529      4368616E 
 11529      6E656C20 
 11529      52657365 
 11529      74204661 
 11530 0bf3 00       		.space	1
 11531              	.LC68:
 11532 0bf4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 11532      4368616E 
 11532      6E656C20 
 11532      53657420 
 11532      5472616E 
 11533 0c25 00       		.ascii	"\000"
 11534 0c26 0000     		.space	2
 11535              	.LC69:
 11536 0c28 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 11536      4368616E 
 11536      6E656C20 
 11536      53657420 
 11536      5472616E 
 11537 0c59 0A00     		.ascii	"\012\000"
 11538 0c5b 00       		.space	1
 11539              	.LC70:
 11540 0c5c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 11540      75706572 
 11540      20677069 
 11540      6600
 11541 0c6a 0000     		.space	2
 11542              	.LC71:
 11543 0c6c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 11543      69676820 
 11543      67706966 
 11543      00
 11544 0c79 000000   		.space	3
 11545              	.LC72:
 11546 0c7c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11546      696E6720 
 11546      47504946 
 11546      20436F6E 
 11546      66696775 
 11547 0caf 0A00     		.ascii	"\012\000"
 11548 0cb1 000000   		.space	3
 11549              	.LC73:
 11550 0cb4 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11550      74696E67 
 11550      20475049 
 11550      46207374 
 11550      61746520 
 11551 0ce7 0D0A00   		.ascii	"\015\012\000"
 11552 0cea 0000     		.space	2
 11553              	.LC74:
 11554 0cec 49324363 		.ascii	"I2CcmdQue\000"
 11554      6D645175 
 11554      6500
 11555 0cf6 0000     		.space	2
 11556              	.LC75:
 11557 0cf8 49324373 		.ascii	"I2CstaQue\000"
 11557      74615175 
 11557      6500
 11558 0d02 0000     		.space	2
 11559              	.LC76:
 11560 0d04 33303A55 		.ascii	"30:UVC App Thread\000"
 11560      56432041 
 11560      70702054 
 11560      68726561 
 11560      6400
 11561 0d16 0000     		.space	2
 11562              	.LC77:
 11563 0d18 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11563      56432041 
 11563      70702045 
 11563      50302054 
 11563      68726561 
 11564 0d2e 0000     		.space	2
 11565              	.LC78:
 11566 0d30 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11566      32432041 
 11566      70702043 
 11566      54524C20 
 11566      54687265 
 11567 0d47 00       		.bss
 11568              		.align	2
 11569              		.set	.LANCHOR0,. + 0
 11572              	glFxUVCEvent:
 11573 0000 00000000 		.space	40
 11573      00000000 
 11573      00000000 
 11573      00000000 
 11573      00000000 
 11576              	gpif_initialized:
 11577 0028 00000000 		.space	4
 11580              	streamingStarted:
 11581 002c 00000000 		.space	4
 11584              	isUsbConnected:
 11585 0030 00000000 		.space	4
 11588              	fb:
 11589 0034 0000     		.space	2
 11592              	pb:
 11593 0036 0000     		.space	2
 11596              	pbc:
 11597 0038 0000     		.space	2
 11600              	stiflag:
 11601 003a 00       		.space	1
 11602 003b 00       		.space	1
 11605              	hitFV:
 11606 003c 00000000 		.space	4
 11609              	prodCount:
 11610 0040 0000     		.space	2
 11613              	consCount:
 11614 0042 0000     		.space	2
 11617              	clearFeatureRqtReceived:
 11618 0044 00000000 		.space	4
 11621              	usbSpeed:
 11622 0048 00       		.space	1
 11623 0049 000000   		.space	3
 11626              	I2CCMDArry:
 11627 004c 00000000 		.space	12
 11627      00000000 
 11627      00000000 
 11630              	is60Hz:
 11631 0058 00000000 		.space	4
 11634              	glEp0Buffer:
 11635 005c 00000000 		.space	32
 11635      00000000 
 11635      00000000 
 11635      00000000 
 11635      00000000 
 11638              	curFlag:
 11639 007c 00000000 		.space	64
 11639      00000000 
 11639      00000000 
 11639      00000000 
 11639      00000000 
 11642              	CamMode:
 11643 00bc 00       		.space	1
 11646              	setRes:
 11647 00bd 00       		.space	1
 11648 00be 0000     		.space	2
 11651              	glCommitCtrl:
 11652 00c0 00000000 		.space	32
 11652      00000000 
 11652      00000000 
 11652      00000000 
 11652      00000000 
 11655              	setstilRes:
 11656 00e0 00       		.space	1
 11659              	IMcount.7858:
 11660 00e1 00       		.space	1
 11661 00e2 0000     		.space	2
 11664              	uvcAppThread:
 11665 00e4 00000000 		.space	168
 11665      00000000 
 11665      00000000 
 11665      00000000 
 11665      00000000 
 11668              	uvcAppEP0Thread:
 11669 018c 00000000 		.space	168
 11669      00000000 
 11669      00000000 
 11669      00000000 
 11669      00000000 
 11672              	i2cAppThread:
 11673 0234 00000000 		.space	168
 11673      00000000 
 11673      00000000 
 11673      00000000 
 11673      00000000 
 11676              	testSnap:
 11677 02dc 00       		.space	1
 11678 02dd 00       		.space	1
 11681              	fbbak:
 11682 02de 0000     		.space	2
 11685              	pbbak:
 11686 02e0 0000     		.space	2
 11689              	pbcbak:
 11690 02e2 0000     		.space	2
 11693              	pbcpbak:
 11694 02e4 0000     		.space	2
 11695 02e6 0000     		.text
 11696              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:199    .text:00000168 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:206    .text:00000178 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:307    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:321    .text:0000025c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:318    .text:0000025c $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:355    .text:0000028c $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:361    .text:00000298 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:363    .text:00000298 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:542    .text:000003f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:551    .text:00000408 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:554    .text:00000408 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:776    .text:000005a8 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:786    .text:000005c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:788    .text:000005c4 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1113   .text:0000088c $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1129   .text:000008b8 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1132   .text:000008b8 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1169   .text:000008f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1182   .text:0000091c $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1229   .text:00000970 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1236   .text:00000980 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1254   .text:0000099c $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1263   .text:000009b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1266   .text:000009b4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1494   .text:00000c00 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1502   .text:00000c14 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1505   .text:00000c14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1568   .text:00000c94 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1591   .text:00000cac $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1604   .text:00000cd4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1710   .text:00000dc8 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1718   .text:00000ddc $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1721   .text:00000ddc ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1930   .text:00000f78 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:1972   .text:00001014 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:2038   .text:00001094 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:2079   .text:00001130 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:3459   .text:00001d50 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:3483   .text:00001da4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:4123   .text:00002304 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:4129   .text:00002314 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:4359   .text:0000256c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:4527   .text:000026c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:4540   .text:000026f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5035   .text:00002c00 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5046   .text:00002c20 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5308   .text:00002edc $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5321   .text:00002f04 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5324   .text:00002f04 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5386   .text:00002f80 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5394   .text:00002f90 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5827   .text:000033c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:5834   .text:000033d8 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:6310   .text:000037d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:6317   .text:000037e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:6837   .text:00003c74 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:6872   .text:00003cec $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:6875   .text:00003cec CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7168   .text:00003fa8 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7175   .text:00003fb8 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7178   .text:00003fb8 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7219   .text:00003ffc $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7224   .text:00004004 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7227   .text:00004004 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7252   .text:00004020 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7256   .text:00004024 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:7259   .text:00004024 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8606   .text:00004ac4 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8612   .text:00004ad4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8728   .text:00004c3c $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8787   .text:00004d1c $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8790   .text:00004d1c CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8955   .text:00004ea8 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8973   .text:00004ee4 $a
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:8976   .text:00004ee4 main
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10785  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10794  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10869  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10888  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9163   .rodata:000000a0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10967  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10978  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11089  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11240  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9176   .rodata:000000bc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10781  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11676  .bss:000002dc testSnap
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11588  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11592  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11596  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11681  .bss:000002de fbbak
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11685  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11689  .bss:000002e2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11693  .bss:000002e4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11584  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11621  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11617  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11580  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10722  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10662  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10752  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10692  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10767  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10158  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9116   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9120   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9135   .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10178  .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10222  .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10200  .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10295  .data:000004f8 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10317  .data:0000050c EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9188   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9192   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:9515   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10173  .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10244  .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10251  .data:000004d0 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10273  .data:000004e4 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:10339  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11318  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11568  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11572  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11576  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11600  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11605  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11609  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11613  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11626  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11630  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11634  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11638  .bss:0000007c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11642  .bss:000000bc CamMode
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11646  .bss:000000bd setRes
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11651  .bss:000000c0 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11655  .bss:000000e0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11659  .bss:000000e1 IMcount.7858
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11664  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11668  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccoS32w8.s:11672  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
