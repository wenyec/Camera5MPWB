   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessEnReg       , SharpnessGaiReg        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** volatile static SensorCtrl PUCBright =
 301:../uvc.c      **** 		{0x15/*BrightnessReg1*/,		//Reg1: the command register address1
 302:../uvc.c      **** 		 0x15/*BrightnessReg0*/,		//Reg2: the command register address2
 303:../uvc.c      **** 		 2,					//UVCLn: the command length
 304:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 305:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 306:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 307:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 308:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 309:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 310:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 311:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 312:../uvc.c      **** 		 118,				//UVCDefVLo: the command default data value low byte
 313:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 314:../uvc.c      **** 		 118,				//UVCCurVLo: the command current data value low byte
 315:../uvc.c      **** 		 119,				//UVCCurVHi: the command current data value high byte
 316:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 317:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 318:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 319:../uvc.c      **** 		}; //brightness, Reg1: ; Reg2: .
 320:../uvc.c      **** //		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1
 321:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 322:../uvc.c      **** volatile static SensorCtrl PUCContrast =
 323:../uvc.c      **** 		{ContrastReg,		//Reg1: the command register address1
 324:../uvc.c      **** 		 ContrastReg,		//Reg2: the command register address2
 325:../uvc.c      **** 		 2,					//UVCLn: the command length
 326:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 327:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 328:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 329:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 330:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 331:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 332:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 333:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 334:../uvc.c      **** 		 112,				//UVCDefVLo: the command default data value low byte
 335:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 336:../uvc.c      **** 		 112,				//UVCCurVLo: the command current data value low byte
 337:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 338:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 339:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 340:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 341:../uvc.c      **** 		}; //contrast, Reg1: ; Reg2: .
 342:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 343:../uvc.c      **** //		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 
 344:../uvc.c      **** volatile static SensorCtrl PUCPLFreq =  //in 5MP b/w it is not used.
 345:../uvc.c      **** 		{MainsFreqReg,		//Reg1: the command register address1
 346:../uvc.c      **** 		 MainsFreqReg,		//Reg2: the command register address2
 347:../uvc.c      **** 		 2,					//UVCLn: the command length
 348:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 349:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 350:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 351:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 352:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 353:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 354:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 355:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 356:../uvc.c      **** 		 1,					//UVCDefVLo: the command default data value low byte
 357:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 358:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 359:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 360:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 361:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 362:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 363:../uvc.c      **** 		}; //main frequency, Reg1: ; Reg2: .
 364:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 365:../uvc.c      **** //{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 366:../uvc.c      **** volatile static SensorCtrl PUCHueC =
 367:../uvc.c      **** 		{HuectrlRegGr,		//Reg1: the command register address1
 368:../uvc.c      **** 		 HuectrlRegBlu,		//Reg2: the command register address2
 369:../uvc.c      **** 		 2,					//UVCLn: the command length
 370:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 371:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 372:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 373:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 374:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 375:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 376:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 377:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 378:../uvc.c      **** 		 128,				//UVCDefVLo: the command default data value low byte
 379:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 380:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 381:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 382:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 383:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 384:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 385:../uvc.c      **** 		}; //hue control, Reg1: ; Reg2: .
 386:../uvc.c      **** //		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 
 387:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 388:../uvc.c      **** volatile static SensorCtrl PUCSaturation =
 389:../uvc.c      **** 		{SaturationRegR,		//Reg1: the command register address1
 390:../uvc.c      **** 		 SaturationRegB,		//Reg2: the command register address2
 391:../uvc.c      **** 		 2,					//UVCLn: the command length
 392:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 393:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 394:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 395:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 396:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 397:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 398:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 399:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 400:../uvc.c      **** 		 50,				//UVCDefVLo: the command default data value low byte
 401:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 402:../uvc.c      **** 		 50,				//UVCCurVLo: the command current data value low byte
 403:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 404:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 405:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 406:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 407:../uvc.c      **** 		}; //saturation, Reg1: ; Reg2: .
 408:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 409:../uvc.c      **** 		{SharpnessEnReg,		//Reg1: the command register address1
 410:../uvc.c      **** 		 SharpnessGaiReg,		//Reg2: the command register address2
 411:../uvc.c      **** 		 2,					//UVCLn: the command length
 412:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 413:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 414:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 415:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 416:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 417:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 418:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 419:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 420:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 421:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 422:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 423:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 424:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 425:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 426:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 427:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 428:../uvc.c      **** //		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 
 429:../uvc.c      **** //volatile static SensorCtrl PUCWBMd;
 430:../uvc.c      **** volatile static SensorCtrl PUCWBMd = //not be used in 5MP B/W
 431:../uvc.c      **** 		{WBModeReg,		//Reg1: the command register address1
 432:../uvc.c      **** 		 WBModeReg,		//Reg2: the command register address2
 433:../uvc.c      **** 		 2,					//UVCLn: the command length
 434:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 435:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 436:../uvc.c      **** 		 5,					//UVCMaxLo: the command maximum value low byte
 437:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 438:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 439:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 440:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 441:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 442:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 443:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 444:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 445:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 446:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 447:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 448:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 449:../uvc.c      **** 		}; //write balance mode, Reg1: ; Reg2: .
 450:../uvc.c      **** //		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,5
 451:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 452:../uvc.c      **** volatile static SensorCtrl PUCWBLC =  //not be used in 5MP B/W
 453:../uvc.c      **** 		{ManuBWBReg,		//Reg1: the command register address1
 454:../uvc.c      **** 		 ManuRWBReg,		//Reg2: the command register address2
 455:../uvc.c      **** 		 4,					//UVCLn: the command length
 456:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 457:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 458:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 459:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 460:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 461:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 462:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 463:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 464:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 465:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 466:../uvc.c      **** 		 56,				//UVCCurVLo: the command current data value low byte
 467:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 468:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 469:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 470:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 471:../uvc.c      **** 		}; //write balance components, Reg1: ; Reg2: .
 472:../uvc.c      **** //		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 
 473:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 474:../uvc.c      **** volatile static SensorCtrl PUCDZoom =
 475:../uvc.c      **** 		{DigZoomReg,		//Reg1: the command register address1
 476:../uvc.c      **** 		 DigZoomReg,		//Reg2: the command register address2
 477:../uvc.c      **** 		 2,					//UVCLn: the command length
 478:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 479:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 480:../uvc.c      **** 		 27,				//UVCMaxLo: the command maximum value low byte
 481:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 482:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 483:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 484:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 485:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 486:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 487:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 488:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 489:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 490:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 491:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 492:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 493:../uvc.c      **** 		}; //digital zoom, Reg1: ; Reg2: .
 494:../uvc.c      **** 
 495:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 496:../uvc.c      **** 	&PUCBLC,
 497:../uvc.c      **** 	&PUCBright,
 498:../uvc.c      **** 	&PUCContrast,
 499:../uvc.c      **** 	0, //&PUCGain (AGC?)
 500:../uvc.c      **** 	&PUCPLFreq,
 501:../uvc.c      **** 	&PUCHueC,
 502:../uvc.c      **** 	&PUCSaturation,
 503:../uvc.c      **** 	&PUCSharp,
 504:../uvc.c      **** 	0, //&PUCGamGain,
 505:../uvc.c      **** 	&PUCWBMd,
 506:../uvc.c      **** 	0, //UVCCtlID10,
 507:../uvc.c      **** 	&PUCWBLC,
 508:../uvc.c      **** 	0, //UVCCtlID12,
 509:../uvc.c      **** 	0, //UVCCtlID13,
 510:../uvc.c      **** 	&PUCDZoom,
 511:../uvc.c      **** 	0 //UVCCtlID15
 512:../uvc.c      **** };
 513:../uvc.c      **** 
 514:../uvc.c      **** /* the Camera terminal control request */
 515:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 516:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 517:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 518:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 519:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 520:../uvc.c      **** 
 521:../uvc.c      **** /* the Extentsion control request */
 522:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 523:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 524:../uvc.c      **** 		 ExFinShutReg,		//Reg2: the command register address2
 525:../uvc.c      **** 		 2,					//UVCLn: the command length
 526:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 527:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 528:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 529:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 530:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 531:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 532:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 533:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 534:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 535:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 536:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 537:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 538:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 539:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 540:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 541:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 542:../uvc.c      **** volatile static SensorCtrl EXTSensUp =  //not be used in 5MP B/W
 543:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 544:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 545:../uvc.c      **** 		 2,					//UVCLn: the command length
 546:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 547:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 548:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 549:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 550:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 551:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 552:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 553:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 554:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 555:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 556:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 557:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 558:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 559:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 560:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 561:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 562:../uvc.c      **** 
 563:../uvc.c      **** // 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0
 564:../uvc.c      **** volatile static SensorCtrl EXTMirror =
 565:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 566:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 567:../uvc.c      **** 		 2,					//UVCLn: the command length
 568:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 569:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 570:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 571:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 572:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 573:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 574:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 575:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 576:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 577:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 578:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 579:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 580:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 581:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 582:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 583:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 584:../uvc.c      **** //		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0,
 585:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 586:../uvc.c      **** volatile static SensorCtrl EXT3DnoiseReduceMode = //2DNR mode
 587:../uvc.c      **** 		{NoiRedu3DModReg,		//Reg1: the command register address1
 588:../uvc.c      **** 		 NoiRedu3DModReg,		//Reg2: the command register address2
 589:../uvc.c      **** 		 2,					//UVCLn: the command length
 590:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 591:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 592:../uvc.c      **** 		 1,					//UVCMaxLo: the command maximum value low byte
 593:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 594:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 595:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 596:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 597:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 598:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 599:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 600:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 601:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 602:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 603:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 604:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 605:../uvc.c      **** 		};	// 3D noise reduce mode control
 606:../uvc.c      **** //		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32,
 607:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 608:../uvc.c      **** volatile static SensorCtrl EXT3DNoiseLev =  //2DNR gain
 609:../uvc.c      **** 		{NoiRedu3DLevReg,		//Reg1: the command register address1
 610:../uvc.c      **** 		 NoiRedu3DLevReg,		//Reg2: the command register address2
 611:../uvc.c      **** 		 2,					//UVCLn: the command length
 612:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 613:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 614:../uvc.c      **** 		 64,				//UVCMaxLo: the command maximum value low byte
 615:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 616:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 617:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 618:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 619:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 620:../uvc.c      **** 		 32,				//UVCDefVLo: the command default data value low byte
 621:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 622:../uvc.c      **** 		 32,				//UVCCurVLo: the command current data value low byte
 623:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 624:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 625:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 626:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 627:../uvc.c      **** 		};	// 3D noise reduce level control
 628:../uvc.c      **** 
 629:../uvc.c      **** //		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0,
 630:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 631:../uvc.c      **** volatile static SensorCtrl EXTDayNightMode =
 632:../uvc.c      **** 		{DayNightModReg,		//Reg1: the command register address1
 633:../uvc.c      **** 		 DayNightModReg,		//Reg2: the command register address2
 634:../uvc.c      **** 		 2,					//UVCLn: the command length
 635:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 636:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 637:../uvc.c      **** 		 2,					//UVCMaxLo: the command maximum value low byte
 638:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 639:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 640:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 641:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 642:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 643:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 644:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 645:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 646:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 647:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 648:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 649:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 650:../uvc.c      **** 		};	// day night mode control
 651:../uvc.c      **** //{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 652:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 653:../uvc.c      **** volatile static SensorCtrl EXTDayNightdely =
 654:../uvc.c      **** 		{DayNightDlyReg,		//Reg1: the command register address1
 655:../uvc.c      **** 		 DayNightDlyReg,		//Reg2: the command register address2
 656:../uvc.c      **** 		 2,					//UVCLn: the command length
 657:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 658:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 659:../uvc.c      **** 		 63,				//UVCMaxLo: the command maximum value low byte
 660:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 661:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 662:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 663:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 664:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 665:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 666:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 667:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 668:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 669:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 670:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 671:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 672:../uvc.c      **** 		};	// day night delay control
 673:../uvc.c      **** //{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 674:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 675:../uvc.c      **** volatile static SensorCtrl EXTDayNightlev =
 676:../uvc.c      **** 		{DayNightLevReg,		//Reg1: the command register address1
 677:../uvc.c      **** 		 DayNightLevReg,		//Reg2: the command register address2
 678:../uvc.c      **** 		 2,					//UVCLn: the command length
 679:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 680:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 681:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 682:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 683:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 684:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 685:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 686:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 687:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 688:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 689:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 690:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 691:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 692:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 693:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 694:../uvc.c      **** 		};	// day night level control
 695:../uvc.c      **** //{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 696:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 697:../uvc.c      **** volatile static SensorCtrl EXTNightDaylev =
 698:../uvc.c      **** 		{NightDayLevReg,		//Reg1: the command register address1
 699:../uvc.c      **** 		 NightDayLevReg,		//Reg2: the command register address2
 700:../uvc.c      **** 		 2,					//UVCLn: the command length
 701:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 702:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 703:../uvc.c      **** 		 100,				//UVCMaxLo: the command maximum value low byte
 704:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 705:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 706:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 707:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 708:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 709:../uvc.c      **** 		 16,				//UVCDefVLo: the command default data value low byte
 710:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 711:../uvc.c      **** 		 16,				//UVCCurVLo: the command current data value low byte
 712:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 713:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 714:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 715:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 716:../uvc.c      **** 		};	// night day level control
 717:../uvc.c      **** //{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 718:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 719:../uvc.c      **** 		{AExModeReg,		//Reg1: the command register address1
 720:../uvc.c      **** 		 AExAGCReg,			//Reg2: the command register address2
 721:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 722:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 723:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 724:../uvc.c      **** 		 127,				//UVCMaxLo: the command maximum value low byte
 725:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 726:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 727:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 728:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 729:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 730:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 731:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 732:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 733:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 734:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 735:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 736:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 737:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 738:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 739:../uvc.c      **** //{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 740:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 741:../uvc.c      **** volatile static SensorCtrl EXTExpReflev =
 742:../uvc.c      **** 		{AExReferleveReg,		//Reg1: the command register address1
 743:../uvc.c      **** 		 AExReferleveReg,		//Reg2: the command register address2
 744:../uvc.c      **** 		 2,					//UVCLn: the command length
 745:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 746:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 747:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 748:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 749:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 750:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 751:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 752:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 753:../uvc.c      **** 		 60,				//UVCDefVLo: the command default data value low byte
 754:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 755:../uvc.c      **** 		 60,				//UVCCurVLo: the command current data value low byte
 756:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 757:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 758:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 759:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 760:../uvc.c      **** 		};	// AEX reference level control
 761:../uvc.c      **** //{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 762:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 763:../uvc.c      **** volatile static SensorCtrl EXTCamMode =  //not be used
 764:../uvc.c      **** 		{SensorModeReg,		//Reg1: the command register address1
 765:../uvc.c      **** 		 SensorModeReg,		//Reg2: the command register address2
 766:../uvc.c      **** 		 2,					//UVCLn: the command length
 767:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 768:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 769:../uvc.c      **** 		 6,					//UVCMaxLo: the command maximum value low byte
 770:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 771:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 772:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 773:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 774:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 775:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 776:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 777:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 778:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 779:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 780:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 781:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 782:../uvc.c      **** 		};	// sensor mode control ???
 783:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot; ???
 784:../uvc.c      **** //{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 785:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 786:../uvc.c      **** volatile static SensorCtrl EXTSensorPare = //not be used
 787:../uvc.c      **** 		{SeveParsReg,		//Reg1: the command register address1
 788:../uvc.c      **** 		 SeveParsReg,		//Reg2: the command register address2
 789:../uvc.c      **** 		 2,					//UVCLn: the command length
 790:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 791:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 792:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 793:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 794:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 795:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 796:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 797:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 798:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 799:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 800:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 801:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 802:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 803:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 804:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 805:../uvc.c      **** 		};	// sensor mode control ???
 806:../uvc.c      **** //{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 807:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;???
 808:../uvc.c      **** volatile static SensorCtrl EXTI2Ccmd = //not be used
 809:../uvc.c      **** 		{0,/*no-fix register*/		//Reg1: the command register address1
 810:../uvc.c      **** 		 0,/*no-fix register*/		//Reg2: the command register address2
 811:../uvc.c      **** 		 11,				//UVCLn: the command length
 812:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 813:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 814:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 815:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 816:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 817:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 818:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 819:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 820:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 821:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 822:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 823:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 824:../uvc.c      **** 		 0,/*no-fix address*/ 		//DeviceAdd: the device address
 825:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 826:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 827:../uvc.c      **** 		};	// sensor mode control ???
 828:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 829:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 830:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 831:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 832:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 833:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 834:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 835:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 836:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 837:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 838:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 839:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 840:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 841:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 842:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 843:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 844:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 845:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 846:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 847:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 848:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 849:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 850:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 851:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 852:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 853:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 854:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 855:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 856:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 857:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 858:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 859:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 860:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 861:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 862:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 863:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 864:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 865:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 866:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 867:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 868:../uvc.c      **** 		}; //
 869:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 870:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 871:../uvc.c      **** volatile static SensorCtrl EXTBLCGrid =
 872:../uvc.c      **** 		{BLCModeRegAct,			//Reg1: the command register address1
 873:../uvc.c      **** 		 BLCModeRegAct,			//Reg2: the command register address2
 874:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 875:../uvc.c      **** 		 1,					//UVCMinLo: the command minimum value low byte
 876:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 877:../uvc.c      **** 		 2,		  			//UVCMaxLo: the command maximum value low byte
 878:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 879:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 880:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 881:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 882:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 883:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 884:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 885:../uvc.c      **** 		 0, 				//UVCCurVLo: the command current data value low byte
 886:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 887:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 888:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 889:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 890:../uvc.c      **** 		}; //
 891:../uvc.c      **** 
 892:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 893:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 894:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 895:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 896:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 897:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 898:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 899:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 900:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 901:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 902:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 903:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 904:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 905:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 906:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 907:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 908:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 909:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 910:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 911:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 912:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 913:../uvc.c      **** 
 914:../uvc.c      **** volatile static SensorCtrl EXTExHyster =
 915:../uvc.c      **** 		{ExHysterReg,			//Reg1: the command register address1
 916:../uvc.c      **** 		 ExHysterReg,			//Reg2: the command register address2
 917:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 918:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 919:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 920:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 921:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 922:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 923:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 924:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 925:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 926:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 927:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 928:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 929:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 930:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 931:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 932:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 933:../uvc.c      **** 		}; //
 934:../uvc.c      **** 
 935:../uvc.c      **** volatile static SensorCtrl EXTExCtrlSped =
 936:../uvc.c      **** 		{ExCtrlSpdReg,			//Reg1: the command register address1
 937:../uvc.c      **** 		 ExCtrlSpdReg,			//Reg2: the command register address2
 938:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 939:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 940:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 941:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 942:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 943:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 944:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 945:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 946:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 947:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 948:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 949:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 950:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 951:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 952:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 953:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 954:../uvc.c      **** 		}; //
 955:../uvc.c      **** 
 956:../uvc.c      **** volatile static SensorCtrl EXTEnhanceMode =
 957:../uvc.c      **** 		{ExEnhanceModeReg,			//Reg1: the command register address1
 958:../uvc.c      **** 		 ExEnhanceModeReg,			//Reg2: the command register address2
 959:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 960:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 961:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 962:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 963:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 964:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 965:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 966:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 967:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 968:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 969:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 970:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 971:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 972:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 973:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 974:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 975:../uvc.c      **** 		}; //
 976:../uvc.c      **** 
 977:../uvc.c      **** volatile static SensorCtrl EXTEnhanceGain =
 978:../uvc.c      **** 		{ExEnhanceGainReg,			//Reg1: the command register address1
 979:../uvc.c      **** 		 ExEnhanceGainReg,			//Reg2: the command register address2
 980:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 981:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 982:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 983:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 984:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 985:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 986:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 987:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 988:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 989:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 990:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 991:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 992:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 993:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 994:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 995:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 996:../uvc.c      **** 		}; //
 997:../uvc.c      **** 
 998:../uvc.c      **** volatile static SensorCtrl EXTEnhanceSTED =
 999:../uvc.c      **** 		{ExEnhanceStartReg,			//Reg1: the command register address1
1000:../uvc.c      **** 		 ExEnhanceEndReg,			//Reg2: the command register address2
1001:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1002:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1003:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1004:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1005:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1006:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1007:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1008:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1009:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1010:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1011:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1012:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1013:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1014:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1015:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1016:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1017:../uvc.c      **** 		}; //
1018:../uvc.c      **** 
1019:../uvc.c      **** volatile static SensorCtrl EXT2DNRGain =
1020:../uvc.c      **** 		{Ex2DNREnableReg,		//Reg1: the command register address1
1021:../uvc.c      **** 		 Ex2DNRGainReg,			//Reg2: the command register address2
1022:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1023:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1024:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1025:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1026:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1027:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1028:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1029:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1030:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1031:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1032:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1033:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1034:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1035:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1036:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1037:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1038:../uvc.c      **** 		}; //
1039:../uvc.c      **** 
1040:../uvc.c      **** volatile static SensorCtrl EXT2DNRSTED =
1041:../uvc.c      **** 		{Ex2DNRStartReg,			//Reg1: the command register address1
1042:../uvc.c      **** 		 Ex2DNREndReg,			//Reg2: the command register address2
1043:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1044:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1045:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1046:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
1047:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1048:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1049:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1050:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1051:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1052:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
1053:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1054:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
1055:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1056:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1057:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1058:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1059:../uvc.c      **** 		}; //
1060:../uvc.c      **** 
1061:../uvc.c      **** volatile static SensorCtrl EXTGammaCor =
1062:../uvc.c      **** 		{ExGammaReg,			//Reg1: the command register address1
1063:../uvc.c      **** 		 ExGammaReg,			//Reg2: the command register address2
1064:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1065:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1066:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1067:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1068:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1069:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1070:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1071:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1072:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1073:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1074:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1075:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1076:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1077:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1078:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1079:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1080:../uvc.c      **** 		}; //
1081:../uvc.c      **** 
1082:../uvc.c      **** volatile static SensorCtrl EXTAGCMaxLimit =
1083:../uvc.c      **** 		{AGCMaxLimtReg,			//Reg1: the command register address1
1084:../uvc.c      **** 		 AGCMaxLimtReg,			//Reg2: the command register address2
1085:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
1086:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
1087:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
1088:../uvc.c      **** 		 0x10,				//UVCMaxLo: the command maximum value low byte
1089:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
1090:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
1091:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
1092:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
1093:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
1094:../uvc.c      **** 		 0x00,				//UVCDefVLo: the command default data value low byte
1095:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
1096:../uvc.c      **** 		 0x00,				//UVCCurVLo: the command current data value low byte
1097:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
1098:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
1099:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
1100:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
1101:../uvc.c      **** 		}; //
1102:../uvc.c      **** 
1103:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x40] = {//Extension control
1104:../uvc.c      **** 		&EXTShutter,
1105:../uvc.c      **** 		&EXTSensUp,
1106:../uvc.c      **** 		&EXTMirror,
1107:../uvc.c      **** 		&EXT3DnoiseReduceMode,
1108:../uvc.c      **** 		&EXT3DNoiseLev,
1109:../uvc.c      **** 		&EXTDayNightMode,
1110:../uvc.c      **** 		&EXTDayNightdely,
1111:../uvc.c      **** 		&EXTDayNightlev,
1112:../uvc.c      **** 		&EXTNightDaylev,
1113:../uvc.c      **** 		&EXTAexModGainlev,
1114:../uvc.c      **** 		&EXTExpReflev,
1115:../uvc.c      **** 		&EXTShutlev,
1116:../uvc.c      **** 		&EXTCamMode,
1117:../uvc.c      **** 		0, //&EXTSnapshot,
1118:../uvc.c      **** 		&EXTSensorPare,
1119:../uvc.c      **** 		&EXTI2Ccmd,
1120:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
1121:../uvc.c      **** 		0, //&Ext1CtlID1,
1122:../uvc.c      **** 		0, //&Ext1CtlID2,
1123:../uvc.c      **** 		0, //&Ext1CtlID3,
1124:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
1125:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
1126:../uvc.c      **** 		&EXTBLCGrid,    	// back light compensation grid state
1127:../uvc.c      **** 		&EXTExHyster,       // exposure hystereses level
1128:../uvc.c      **** 		&EXTExCtrlSped,     // exposure control speed level
1129:../uvc.c      **** 		&EXTEnhanceMode,    // edge enhancement mode
1130:../uvc.c      **** 		&EXTEnhanceGain,    // edge enhancement gain level
1131:../uvc.c      **** 		&EXTEnhanceSTED,    // edge enhancement start/end level
1132:../uvc.c      **** 		&EXT2DNRGain,       // 2D noise reduction Gain level
1133:../uvc.c      **** 		&EXT2DNRSTED,       // 2D noise reduction start/end level
1134:../uvc.c      **** 		&EXTGammaCor,		// Gamma correction
1135:../uvc.c      **** 		&EXTAGCMaxLimit, 	// AGC Maximum Gain limitation &Ext1AGCMaxLimetCtlID15,
1136:../uvc.c      **** 		0
1137:../uvc.c      **** };
1138:../uvc.c      **** 
1139:../uvc.c      **** #endif //end of the new control structure
1140:../uvc.c      **** 
1141:../uvc.c      **** #ifndef CAM720
1142:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
1143:../uvc.c      **** #else
1144:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
1145:../uvc.c      **** #endif
1146:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
1147:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
1148:../uvc.c      **** 
1149:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
1150:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
1151:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
1152:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
1153:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
1154:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
1155:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
1156:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
1157:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
1158:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
1159:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
1160:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
1161:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
1162:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1163:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1164:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1165:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
1166:../uvc.c      **** };
1167:../uvc.c      **** 
1168:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
1169:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
1170:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
1171:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
1172:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
1173:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
1174:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
1175:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
1176:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
1177:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1178:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
1179:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
1180:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
1181:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
1182:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
1183:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1184:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1185:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1186:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
1187:../uvc.c      **** };
1188:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
1189:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
1190:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
1191:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
1192:../uvc.c      **** /*
1193:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
1194:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
1195:../uvc.c      ****  */
1196:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
1197:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
1198:../uvc.c      **** };
1199:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
1200:../uvc.c      **** 		0
1201:../uvc.c      **** };
1202:../uvc.c      **** 
1203:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
1204:../uvc.c      **** 
1205:../uvc.c      **** void I2CCmdHandler(){
1206:../uvc.c      **** 	uint8_t buf[2];
1207:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
1208:../uvc.c      **** 	CmdType = I2CCMDArry[0];
1209:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
1210:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
1211:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
1212:../uvc.c      **** 	uint8_t i;
1213:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
1214:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1215:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1216:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
1217:../uvc.c      **** 	{
1218:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
1219:../uvc.c      **** 		if(is60Hz==CyFalse)
1220:../uvc.c      **** 			{
1221:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
1222:../uvc.c      **** 			}
1223:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
1224:../uvc.c      **** 
1225:../uvc.c      **** 	}
1226:../uvc.c      **** 	if(CmdType == 0)//I2C read
1227:../uvc.c      **** 	{
1228:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
1229:../uvc.c      **** #if 0 //for debugging
1230:../uvc.c      **** 		/* test still image operation */
1231:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
1232:../uvc.c      **** 			snapButFlag = 0; //press
1233:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1234:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
1235:../uvc.c      **** 			snapButFlag = 0xf; //release
1236:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
1237:../uvc.c      **** 		}
1238:../uvc.c      **** 
1239:../uvc.c      **** 		/* end of the test */
1240:../uvc.c      **** #endif
1241:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
1242:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
1243:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
1244:../uvc.c      **** 				if(CmdDataLen == 2){
1245:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
1246:../uvc.c      **** 				}
1247:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
1248:../uvc.c      **** 		}else{//not support currently
1249:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1250:../uvc.c      **** 		}
1251:../uvc.c      **** 	}else if(CmdType == 1){
1252:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
1253:../uvc.c      **** 			if(CmdRegLen == 2){
1254:../uvc.c      **** 				for(i = 0; i<4; i++)
1255:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
1256:../uvc.c      **** 			}
1257:../uvc.c      **** 			else{
1258:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
1259:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
1260:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
1261:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
1262:../uvc.c      **** 				}
1263:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
1264:../uvc.c      **** 			}
1265:../uvc.c      **** 		}else{//not support currently
1266:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
1267:../uvc.c      **** 		}
1268:../uvc.c      **** 
1269:../uvc.c      **** 	}
1270:../uvc.c      **** }
1271:../uvc.c      **** 
1272:../uvc.c      **** /************************************
1273:../uvc.c      ****  * set Iris mode
1274:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
1275:../uvc.c      ****  */
1276:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
1277:../uvc.c      **** 	uint8_t dataIdx = 0;
1278:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
1280:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
1281:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1282:../uvc.c      **** }
1283:../uvc.c      **** 
1284:../uvc.c      **** 
1285:../uvc.c      **** 
1286:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
1287:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
1288:../uvc.c      **** 	uint16_t NumLn;
1289:../uvc.c      **** 	uint16_t fRate, shutTm;
1290:../uvc.c      **** 	uint8_t LnVal;
1291:../uvc.c      **** 	switch (Data){
1292:../uvc.c      **** 	case 1:
1293:../uvc.c      **** 	case 2:
1294:../uvc.c      **** 	case 3:
1295:../uvc.c      **** 	case 4:
1296:../uvc.c      **** 	case 5:
1297:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1298:../uvc.c      **** 		fRate = 30;
1299:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
1300:../uvc.c      **** 		if(NumLn > 1944)
1301:../uvc.c      **** 			NumLn =1944;
1302:../uvc.c      **** 		else if(NumLn < 8)
1303:../uvc.c      **** 			NumLn = 8;
1304:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1305:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1306:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1307:../uvc.c      **** 		break;
1308:../uvc.c      **** 	case 6:
1309:../uvc.c      **** 	case 7:
1310:../uvc.c      **** 	case 8:
1311:../uvc.c      **** 	case 9:
1312:../uvc.c      **** 	case 10:
1313:../uvc.c      **** 		shutTm = ShutSp[Data-1];
1314:../uvc.c      **** 		fRate = 30;
1315:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
1316:../uvc.c      **** 		if(NumLn > 1944)
1317:../uvc.c      **** 			NumLn =1944;
1318:../uvc.c      **** 		else if(NumLn < 8)
1319:../uvc.c      **** 			NumLn = 8;
1320:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
1321:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
1322:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
1323:../uvc.c      **** 		break;
1324:../uvc.c      **** 	case 0: //auto
1325:../uvc.c      **** 	default:
1326:../uvc.c      **** 		*pAxMode = 0x00;	// auto
1327:../uvc.c      **** 		LnVal = 1;
1328:../uvc.c      **** 		break;
1329:../uvc.c      **** 	}
1330:../uvc.c      **** 	return LnVal;
1331:../uvc.c      **** }
1332:../uvc.c      **** 
1333:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
1334:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1335:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1336:../uvc.c      ****     uint16_t readCount;
1337:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
1338:../uvc.c      ****     uint8_t devAdd;
1339:../uvc.c      ****     //locCtrlID = CtrlID-EXUAOFFSET+4;
1340:../uvc.c      ****     if(CtrlID >= 0x10){//the extension command over 32.
1341:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
1344:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
1345:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
1346:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1347:../uvc.c      ****     }else{
1348:../uvc.c      **** 		RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1;//CtrlParArry[CtrlID][0];
1349:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
1350:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
1351:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
1352:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
1353:../uvc.c      ****     	//		CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1354:../uvc.c      ****     }
1355:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1356:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1357:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
1358:../uvc.c      **** #endif
1359:../uvc.c      ****     reqData = bRequest;
1360:../uvc.c      ****     /*
1361:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
1362:../uvc.c      ****      */
1363:../uvc.c      ****     //if (0 && (CtrlID == ExtAexModCtlID9)){
1364:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
1365:../uvc.c      ****     	//goto EndofSet;
1366:../uvc.c      ****     //}
1367:../uvc.c      ****     switch (bRequest)
1368:../uvc.c      **** 		 {
1369:../uvc.c      **** 
1370:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1371:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1372:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1373:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1374:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1375:../uvc.c      **** 			  break;
1376:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1377:../uvc.c      **** 
1378:../uvc.c      **** 		 	 if(CtrlID >= 0x10/*EXUAOFFSET*/){
1379:../uvc.c      **** 				 switch(CtrlID)
1380:../uvc.c      **** 				 {
1381:../uvc.c      **** 					 case Ext1BLCGridCtlID6:
1382:../uvc.c      **** 						 if(curFlag[CtrlID]){
1383:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
1384:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
1385:../uvc.c      **** 						 }else{
1386:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1387:../uvc.c      **** 							if(Data0&0x80)
1388:../uvc.c      **** 								glEp0Buffer[0] = 1;
1389:../uvc.c      **** 							else
1390:../uvc.c      **** 								glEp0Buffer[0] = 0;
1391:../uvc.c      **** 							pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1392:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
1393:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1394:../uvc.c      **** 						 }
1395:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1396:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1397:../uvc.c      **** 						 break;
1398:../uvc.c      **** 			 	 	 case ExtAexModCtlID9:
1399:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1400:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1401:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1402:../uvc.c      **** 			 	 		 }else{
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1404:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
1405:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1406:../uvc.c      **** 
1407:../uvc.c      **** 			 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
1408:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1409:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
1410:../uvc.c      **** 			 	 		 }
1411:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1412:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1413:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1414:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1415:../uvc.c      **** 						 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1
1416:../uvc.c      **** 						 break;
1417:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
1418:../uvc.c      **** #if 0 //not be used
1419:../uvc.c      **** 						 sendData = CtrlParArry[CtrlID][13];
1420:../uvc.c      **** 
1421:../uvc.c      **** 						 if(CamMode == 1){//720p
1422:../uvc.c      **** 							if(sendData >= 3){
1423:../uvc.c      **** 								CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1424:../uvc.c      **** 								sendData = 0; //set back to default
1425:../uvc.c      **** 								CtrlParArry[CtrlID][13] = 0;
1426:../uvc.c      **** 							}
1427:../uvc.c      **** 							sendData += 4;
1428:../uvc.c      **** 						 }
1429:../uvc.c      **** 						//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, s
1430:../uvc.c      **** 						 glEp0Buffer[0] = sendData;
1431:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1432:../uvc.c      **** #endif
1433:../uvc.c      **** 						 break;
1434:../uvc.c      **** 				 	 case ExtI2CCtlID15:
1435:../uvc.c      **** 				 		 for(idx=0; idx<Len; idx++){
1436:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
1437:../uvc.c      **** 				 		 }
1438:../uvc.c      **** 				 		 sendData = glEp0Buffer[9];
1439:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
1440:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
1441:../uvc.c      **** 				 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x
1442:../uvc.c      **** 				 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
1443:../uvc.c      **** 				 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
1444:../uvc.c      **** 	#endif
1445:../uvc.c      **** 				 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
1446:../uvc.c      **** 				 		 {
1447:../uvc.c      **** 				 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDAr
1448:../uvc.c      **** 				 		 }
1449:../uvc.c      **** 				 		 break;
1450:../uvc.c      **** 				 	 case Ext1BLCRangeCtlID4:
1451:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
1452:../uvc.c      **** 				 	 case ExtShutCtlID0:
1453:../uvc.c      **** 				 	 case ExtCtlShutlevCtlID11:
1454:../uvc.c      **** 				 		 /* the exposure hysteresis to gamma correction */
1455:../uvc.c      **** 			 	 	 case Ext1ExHysterCtlID7:
1456:../uvc.c      **** 			 	 	 case Ext1ExCtrlSpeedCtlID8:
1457:../uvc.c      **** 			 	 	 case Ext1EnhanceModeCtlID9:
1458:../uvc.c      **** 			 	 	 case Ext1EnhanceGainCtlID10:
1459:../uvc.c      **** 			 	 	 case Ext1EnhanceStarEndCtlID11:
1460:../uvc.c      **** 			 	 	 case Ext12DNRGainEnblCtlID12:
1461:../uvc.c      **** 			 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1462:../uvc.c      **** 			 	 	 case Ext1GammaCorCtlID14:
1463:../uvc.c      **** 			 	 	 case Ext1AGCMaxLimetCtlID15:
1464:../uvc.c      **** 					 case ExtExRefCtlID10:
1465:../uvc.c      **** 			 	 	 default:
1466:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
1467:../uvc.c      **** 			 	 			 if(Len == 2)
1468:../uvc.c      **** 			 	 			 {
1469:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1470:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1471:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1472:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1473:../uvc.c      **** 			 	 			 }else if(Len == 4){
1474:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
1475:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1476:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
1477:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1478:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1479:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1480:../uvc.c      **** 			 	 			 }
1481:../uvc.c      **** 			 	 		 }else{
1482:../uvc.c      **** 			 	 			 if(Len == 2)
1483:../uvc.c      **** 			 	 			 {
1484:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1485:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1486:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1487:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
1488:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1489:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1490:../uvc.c      **** 			 	 			 }else if(Len == 4){
1491:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1492:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
1493:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1494:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
1495:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1496:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1497:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1498:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1499:../uvc.c      **** 			 	 			 }
1500:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1501:../uvc.c      **** 			 	 		 }
1502:../uvc.c      **** 			 	 		 break;
1503:../uvc.c      **** 			 	 }
1504:../uvc.c      **** 		 	 }
1505:../uvc.c      **** 		 	 else{
1506:../uvc.c      **** 				 switch(CtrlID)
1507:../uvc.c      **** 				 {
1508:../uvc.c      **** 					 case BrgtCtlID1:
1509:../uvc.c      **** 						 /* cancel for 5MP w/b camera
1510:../uvc.c      **** 						 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
1511:../uvc.c      **** 						 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
1512:../uvc.c      **** 						 if (Data1&0x2){ //check the sign bit (bit1)
1513:../uvc.c      **** 							 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
1514:../uvc.c      **** 						 }else{
1515:../uvc.c      **** 							 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1516:../uvc.c      **** 						 }
1517:../uvc.c      **** 						 glEp0Buffer[0] = Data1;
1518:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1519:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1520:../uvc.c      **** 						 */
1521:../uvc.c      **** 						 if(curFlag[CtrlID]){
1522:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
1523:../uvc.c      **** 						 }else{
1524:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1525:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1526:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1527:../uvc.c      **** 						 }
1528:../uvc.c      **** 						 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode(
1529:../uvc.c      **** 						 /*//new implementation 8/23/2016
1530:../uvc.c      **** 						 if(Data0&0x80){
1531:../uvc.c      **** 							  Data0 = ~Data0;
1532:../uvc.c      **** 						  }else{
1533:../uvc.c      **** 							  Data0 = Data0 + 0x80;
1534:../uvc.c      **** 						  }
1535:../uvc.c      **** 						  */
1536:../uvc.c      **** 						 glEp0Buffer[0] = Data0;
1537:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1538:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1539:../uvc.c      **** 						 break;
1540:../uvc.c      **** 					 case HueCtlID5:
1541:../uvc.c      **** 						 if(curFlag[CtrlID]){
1542:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
1543:../uvc.c      **** 						 }else{
1544:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1545:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1546:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1547:../uvc.c      **** 						 }
1548:../uvc.c      **** 
1549:../uvc.c      **** 						 glEp0Buffer[0] = Data0 + GREEN_BASE;
1550:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1551:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1552:../uvc.c      **** 						 break;
1553:../uvc.c      **** 					 case MFreqCtlID4:
1554:../uvc.c      **** 
1555:../uvc.c      **** 						 if(curFlag[CtrlID]){
1556:../uvc.c      **** 
1557:../uvc.c      **** 							 if(is60Hz)
1558:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1559:../uvc.c      **** 							 else
1560:../uvc.c      **** 								 glEp0Buffer[0] = 1;
1561:../uvc.c      **** 
1562:../uvc.c      **** 							 glEp0Buffer[1] = 0; //CtrlParArry[CtrlID][14];
1563:../uvc.c      **** 						 }else{
1564:../uvc.c      **** 							Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1565:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
1566:../uvc.c      **** 							glEp0Buffer[0]++;
1567:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1568:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
1569:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1570:../uvc.c      **** 						 }
1571:../uvc.c      **** 
1572:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1573:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
1574:../uvc.c      **** 						 break;
1575:../uvc.c      **** 					 case WBTLevCtlID11:
1576:../uvc.c      **** 						 if(curFlag[CtrlID]){
1577:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1578:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1579:../uvc.c      **** 						 }else{
1580:../uvc.c      **** 							Data0 = SensorGetControl(RegAdd0, devAdd);
1581:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
1582:../uvc.c      **** 							glEp0Buffer[0] = Data0;
1583:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1584:../uvc.c      **** 							glEp0Buffer[2] = Data1;
1585:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1586:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
1587:../uvc.c      **** 						 }
1588:../uvc.c      **** 						 glEp0Buffer[1] = 0;
1589:../uvc.c      **** 						 glEp0Buffer[3] = 0;
1590:../uvc.c      **** 						 sendData = glEp0Buffer[0];
1591:../uvc.c      **** 						 sendData1 = glEp0Buffer[2];
1592:../uvc.c      **** 						 break;
1593:../uvc.c      **** 					 case BLCCtlID0:
1594:../uvc.c      **** 					 case ShapCtlID7:
1595:../uvc.c      **** 					 case ConsCtlID2:
1596:../uvc.c      **** 					 case WBTMdCtlID9:
1597:../uvc.c      **** 					 case SaturCtlID6:
1598:../uvc.c      **** 					 default:
1599:../uvc.c      **** 						 if(curFlag[CtrlID]){
1600:../uvc.c      **** 			 	 			 if(Len == 2)
1601:../uvc.c      **** 			 	 			 {
1602:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1603:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1604:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1605:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1606:../uvc.c      **** 			 	 			 }else if(Len == 4){
1607:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1608:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1609:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1610:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1611:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1612:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1613:../uvc.c      **** 			 	 			 }
1614:../uvc.c      **** 			 	 		 }else{
1615:../uvc.c      **** 			 	 			 if(Len == 2)
1616:../uvc.c      **** 			 	 			 {
1617:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1618:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1619:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1620:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
1621:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1622:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
1623:../uvc.c      **** 			 	 			 }else if(Len == 4){
1624:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1625:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1626:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
1627:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
1628:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
1629:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
1630:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
1631:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
1632:../uvc.c      **** 			 	 			 }
1633:../uvc.c      **** 			 	 			 curFlag[CtrlID] = CyTrue;
1634:../uvc.c      **** 			 	 		 }
1635:../uvc.c      **** 						 break;
1636:../uvc.c      **** 				 }
1637:../uvc.c      **** 		 	 }
1638:../uvc.c      **** 
1639:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1640:../uvc.c      **** 
1641:../uvc.c      **** //#ifdef USB_DEBUG_PRINT
1642:../uvc.c      **** 			  CyU3PDebugPrint (4, "The current value 0x%x 0x%x 0x%x, 0x%x, %d\r\n", glEp0Buffer[0], glEp0Buf
1643:../uvc.c      **** //#endif
1644:../uvc.c      **** 			  break;
1645:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1646:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1647:../uvc.c      **** 		 		 if(Len == 2){
1648:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1649:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1650:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1651:../uvc.c      **** 		 		 }else //if(Len == 4)
1652:../uvc.c      **** 		 		 {
1653:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1654:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1655:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1656:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1657:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1658:../uvc.c      **** 				 }
1659:../uvc.c      **** 			 }else{
1660:../uvc.c      **** 			 	 if(Len ==2){
1661:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1662:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1663:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1664:../uvc.c      **** 				 }else{
1665:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
1666:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1667:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
1668:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1669:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1670:../uvc.c      **** 				 }
1671:../uvc.c      **** 			 }
1672:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1673:../uvc.c      **** 		 	 if(Len == 2){
1674:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1675:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1676:../uvc.c      **** 		 	 }else{
1677:../uvc.c      **** 				  sendData = glEp0Buffer[0];
1678:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
1679:../uvc.c      **** 			  }
1680:../uvc.c      **** 			  break;
1681:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1682:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1683:../uvc.c      **** 		 		 if(Len == 2){
1684:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1685:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1686:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1687:../uvc.c      **** 		 		 }else //if(Len == 4)
1688:../uvc.c      **** 		 		 {
1689:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1690:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1691:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1692:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1693:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
1694:../uvc.c      **** 				 }
1695:../uvc.c      **** 			 }else{
1696:../uvc.c      **** 			 	 if(Len ==2){
1697:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1698:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1699:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1700:../uvc.c      **** 				 }else{
1701:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
1702:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1703:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
1704:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1705:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
1706:../uvc.c      **** 				 }
1707:../uvc.c      **** 			 }
1708:../uvc.c      **** 				  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1709:../uvc.c      **** 				  if(Len == 2){
1710:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1711:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
1712:../uvc.c      **** 				  }else{
1713:../uvc.c      **** 					  sendData = glEp0Buffer[0];
1714:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
1715:../uvc.c      **** 				  }
1716:../uvc.c      **** 				  break;
1717:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1718:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1719:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
1720:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1721:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1722:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1723:../uvc.c      **** 		 	 }
1724:../uvc.c      **** 		 	 else{
1725:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_control a
1726:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
1727:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1728:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1729:../uvc.c      **** 		 	 }
1730:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1731:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1732:../uvc.c      **** 			  sendData1 = glEp0Buffer[1];
1733:../uvc.c      **** 			  //CyU3PDebugPrint (4, "The control ResLo: 0x%x, ResHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0], g
1734:../uvc.c      **** 			  break;
1735:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1736:../uvc.c      **** 		 	 if(CtrlID >= 0x10){
1737:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
1738:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1739:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1740:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1741:../uvc.c      **** 		 	 }
1742:../uvc.c      **** 		 	 else{
1743:../uvc.c      **** 		 		 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_control 
1744:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
1745:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
1746:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
1747:../uvc.c      **** 		 	 }
1748:../uvc.c      **** 		 	 Len = 1;
1749:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1750:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
1751:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
1752:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
1753:../uvc.c      **** 		 	 break;
1754:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1755:../uvc.c      **** 		 	 if(CtrlID >= 0x10){//the camera terminal/extension uint command over 0x10.
1756:../uvc.c      **** 		 		 if(Len == 2){
1757:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1758:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1759:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1760:../uvc.c      **** 		 		 }else //if(Len == 4)
1761:../uvc.c      **** 		 		 {
1762:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1763:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1764:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1765:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1766:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
1767:../uvc.c      **** 				 }
1768:../uvc.c      **** 			 }else{
1769:../uvc.c      **** 			 	 if(Len ==2){
1770:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1771:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1772:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1773:../uvc.c      **** 				 }else{
1774:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
1775:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1776:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
1777:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1778:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
1779:../uvc.c      **** 				 }
1780:../uvc.c      **** 			 }
1781:../uvc.c      **** 		 	 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1782:../uvc.c      **** 		 	 if(Len == 2){
1783:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1784:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
1785:../uvc.c      **** 		 	 }else{
1786:../uvc.c      **** 		 		 sendData = glEp0Buffer[0];
1787:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
1788:../uvc.c      **** 		 	 }
1789:../uvc.c      **** 		 	 break;
1790:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1791:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1792:../uvc.c      **** 				  glEp0Buffer, &readCount);
1793:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1794:../uvc.c      **** 			   {
1795:../uvc.c      **** 				 if(Len == 2){
1796:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1797:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
1798:../uvc.c      **** 				 }else{
1799:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
1800:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
1801:../uvc.c      **** 				 }
1802:../uvc.c      **** 				 dataIdx = 0;
1803:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
1804:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
1805:../uvc.c      **** 			 	 if(CtrlID >= 0x10){
1806:../uvc.c      **** 					 switch(CtrlID)
1807:../uvc.c      **** 					 {
1808:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1809:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
1810:../uvc.c      **** 							 if(Data0 == 1){
1811:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1812:../uvc.c      **** 							 }else{
1813:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1814:../uvc.c      **** 							 }
1815:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1816:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1817:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1818:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1819:../uvc.c      **** 							 break;
1820:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
1821:../uvc.c      **** 	#if 0 // not be used
1822:../uvc.c      **** 							 sendData = CtrlParArry[CtrlID][13];
1823:../uvc.c      **** 
1824:../uvc.c      **** 							 if(CamMode == 1){//720p
1825:../uvc.c      **** 								if(sendData >= 3){
1826:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1827:../uvc.c      **** 									sendData = 0; //set back to default
1828:../uvc.c      **** 									CtrlParArry[CtrlID][13] = 0;
1829:../uvc.c      **** 								}
1830:../uvc.c      **** 								sendData += 4;
1831:../uvc.c      **** 							 }
1832:../uvc.c      **** 							//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1833:../uvc.c      **** 							 glEp0Buffer[0] = sendData;
1834:../uvc.c      **** 							 glEp0Buffer[1] = 0;
1835:../uvc.c      **** 	#endif
1836:../uvc.c      **** 							 break;
1837:../uvc.c      **** 					 	 case ExtI2CCtlID15:
1838:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1839:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1840:../uvc.c      **** 					 		 }
1841:../uvc.c      **** 					 		 I2CCmdHandler();
1842:../uvc.c      **** 							 break;
1843:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
1844:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1845:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1846:../uvc.c      **** 							 {
1847:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wind
1848:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1849:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1850:../uvc.c      **** 							 }
1851:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
1852:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
1853:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
1854:../uvc.c      **** 									 dataIdx++;
1855:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //AGC
1856:../uvc.c      **** 								 }
1857:../uvc.c      **** 							 }
1858:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1859:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1860:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1861:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1862:../uvc.c      **** 							 break;
1863:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
1864:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0; //CtrlParArry[CtrlID][13] save new setting
1865:../uvc.c      **** 	#if 1	// register setting directly
1866:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)//based on the Aex Mode 2 has been masked in vi
1867:../uvc.c      **** 						     {
1868:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1869:../uvc.c      **** 						    	 dataIdx = 0;
1870:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1871:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1872:../uvc.c      **** 								 dataIdx++;
1873:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1874:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1875:../uvc.c      **** 						     }
1876:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1877:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1878:../uvc.c      **** 						     break;
1879:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
1880:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1881:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
1882:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1883:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1884:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1885:../uvc.c      **** 									 dataIdx++;
1886:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //shutter level
1887:../uvc.c      **** 								 }
1888:../uvc.c      **** 							 }
1889:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1890:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1891:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1892:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1893:../uvc.c      **** 							 break;
1894:../uvc.c      **** 
1895:../uvc.c      **** 	#else	// old fashion
1896:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1897:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1898:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1899:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1900:../uvc.c      **** 									 }else{
1901:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1902:../uvc.c      **** 									 }
1903:../uvc.c      **** 								 }
1904:../uvc.c      **** 							 }else{
1905:../uvc.c      **** 								 Data1 = Data0 - 1;
1906:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1907:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1908:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1909:../uvc.c      **** 									 }else{
1910:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1911:../uvc.c      **** 									 }
1912:../uvc.c      **** 								 }
1913:../uvc.c      **** 								 if(Data1 < 8){
1914:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1915:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1916:../uvc.c      **** 								 }else{
1917:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1918:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1919:../uvc.c      **** 								 }
1920:../uvc.c      **** 							 }
1921:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1922:../uvc.c      **** 							 dataIdx = 0;
1923:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1924:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1925:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1926:../uvc.c      **** 							 if(AxMode){
1927:../uvc.c      **** 								 dataIdx++;
1928:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1929:../uvc.c      **** 								 dataIdx++;
1930:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1931:../uvc.c      **** 							 }
1932:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1933:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1934:../uvc.c      **** 							 break;
1935:../uvc.c      **** 	#endif
1936:../uvc.c      **** 						 case Ext1BLCRangeCtlID4:
1937:../uvc.c      **** 	#if 0 //seperate version
1938:../uvc.c      **** 							 //registers value BLD window enable (0x17); position (0x13); size (0x14).getData = Data0&0x
1939:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1941:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1942:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1943:../uvc.c      **** 							 }else{ //disable BLD window
1944:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1945:../uvc.c      **** 							 }
1946:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1947:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1948:../uvc.c      **** 							 dataIdx++;
1949:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1950:../uvc.c      **** 							 dataIdx++;
1951:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1952:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1953:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1954:../uvc.c      **** 							 dataIdx++;
1955:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1956:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1957:../uvc.c      **** 	#else //combination version
1958:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1959:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1960:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1961:../uvc.c      **** 							 dataIdx++;
1962:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1963:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1964:../uvc.c      **** 							 getData1 = Data1;
1965:../uvc.c      **** 	#endif
1966:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1967:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1968:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1969:../uvc.c      **** 							 break;
1970:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
1971:../uvc.c      **** 				 	 	 case Ext1ExHysterCtlID7:
1972:../uvc.c      **** 				 	 	 case Ext1ExCtrlSpeedCtlID8:
1973:../uvc.c      **** 				 	 	 case Ext1EnhanceModeCtlID9:
1974:../uvc.c      **** 				 	 	 case Ext1EnhanceGainCtlID10:
1975:../uvc.c      **** 				 	 	 case Ext12DNRGainEnblCtlID12:
1976:../uvc.c      **** 				 	 	 case Ext1GammaCorCtlID14:
1977:../uvc.c      **** 				 	 	 case Ext1AGCMaxLimetCtlID15:
1978:../uvc.c      **** 				 	 	 case Ext1EnhanceStarEndCtlID11://4bytes
1979:../uvc.c      **** 				 	 	 case Ext12DNRGainStarEndCtlID13://4bytes
1980:../uvc.c      **** 						 case ExtExRefCtlID10:
1981:../uvc.c      **** 				 	 	 default:
1982:../uvc.c      **** 				 	 			 if(Len == 2)
1983:../uvc.c      **** 				 	 			 {
1984:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){  //2Bytes
1985:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1986:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
1987:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
1989:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
1990:../uvc.c      **** 									 }
1991:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
1992:../uvc.c      **** 				 	 			 }else if(Len == 4){
1993:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
1994:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
1995:../uvc.c      **** 									 {
1996:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC wi
1997:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
1998:../uvc.c      **** 										 dataIdx++;
1999:../uvc.c      **** 									 }
2000:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi != Data1){
2001:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2002:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2003:../uvc.c      **** 									 }
2004:../uvc.c      **** 									 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
2005:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2006:../uvc.c      **** 
2007:../uvc.c      **** 				 	 			 }
2008:../uvc.c      **** 				 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%
2009:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
2010:../uvc.c      **** 				 	 			 break;
2011:../uvc.c      **** 					 }
2012:../uvc.c      **** 			 	 }
2013:../uvc.c      **** 			 	 else{
2014:../uvc.c      **** 					 switch(CtrlID)
2015:../uvc.c      **** 					 {
2016:../uvc.c      **** 						 case BrgtCtlID1:
2017:../uvc.c      **** 	#if 0 //cancel for 5MP w/b camera
2018:../uvc.c      **** 								 dataIdx = 0;
2019:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2020:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2021:../uvc.c      **** 								  if(Data0&0x80){
2022:../uvc.c      **** 									  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
2023:../uvc.c      **** 								  }else{
2024:../uvc.c      **** 									  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
2025:../uvc.c      **** 								  }
2026:../uvc.c      **** 								 Data1 |= ~0x03;
2027:../uvc.c      **** 								 Data1 &= 0xC7;
2028:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
2029:../uvc.c      **** 							  	 dataIdx++;
2030:../uvc.c      **** 
2031:../uvc.c      **** 								 Data0 = (Data0 << 2);
2032:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
2033:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2034:../uvc.c      **** 
2035:../uvc.c      **** 								 CtrlParArry[CtrlID][13] = Data0;
2036:../uvc.c      **** 								 CtrlParArry[CtrlID][14] = Data1;
2037:../uvc.c      **** 								 CtrlParArry[CtrlID][16] = CyTrue;
2038:../uvc.c      **** 	#endif
2039:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2040:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
2041:../uvc.c      **** 								 /*// new I2C command. direct using Data0 coming from host. 8/23/2016
2042:../uvc.c      **** 								 if(Data0&0x80){
2043:../uvc.c      **** 									  Data0 = Data0 - 0x80;
2044:../uvc.c      **** 								  }else{
2045:../uvc.c      **** 									  Data0 = ~Data0;
2046:../uvc.c      **** 								  }
2047:../uvc.c      **** 								  */
2048:../uvc.c      **** 							  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
2049:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2050:../uvc.c      **** 
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2052:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2053:../uvc.c      **** 							 break;
2054:../uvc.c      **** 						 case HueCtlID5://not being used
2055:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2056:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
2057:../uvc.c      **** 							 dataIdx++;
2058:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
2059:../uvc.c      **** 							 dataIdx++;
2060:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
2061:../uvc.c      **** 							 dataIdx++;
2062:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
2063:../uvc.c      **** 							 dataIdx++;
2064:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
2065:../uvc.c      **** 							 dataIdx++;
2066:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
2067:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2068:../uvc.c      **** 
2069:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0] - GREEN_BASE;
2070:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2071:../uvc.c      **** 							 break;
2072:../uvc.c      **** 						 case MFreqCtlID4:
2073:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2074:../uvc.c      **** 							 Data0 = Data0 - 1;
2075:../uvc.c      **** 							 is60Hz = Data0;
2076:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
2077:../uvc.c      **** 							 {
2078:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
2079:../uvc.c      **** 								 is60Hz = CyFalse;
2080:../uvc.c      **** 							 }
2081:../uvc.c      **** 							 else if(Data0 >2)
2082:../uvc.c      **** 							 {
2083:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
2084:../uvc.c      **** 								 is60Hz = CyTrue;
2085:../uvc.c      **** 							 }
2086:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
2087:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
2088:../uvc.c      **** 							 {
2089:../uvc.c      **** 			                       switch (setRes)
2090:../uvc.c      **** 			                         {
2091:../uvc.c      **** 			                         	case 1: //1944
2092:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_
2093:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2094:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2095:../uvc.c      **** 			                         		break;
2096:../uvc.c      **** 			                         	case 2: //1080
2097:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_
2098:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2099:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
2100:../uvc.c      **** 			                         		break;
2101:../uvc.c      **** 			                         	case 3: //720
2102:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I
2103:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2104:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2105:../uvc.c      **** 			                         		break;
2106:../uvc.c      **** 			                         	case 4: //VGA
2107:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I
2108:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
2109:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
2110:../uvc.c      **** 			                         	default:
2111:../uvc.c      **** 			                         		break;
2112:../uvc.c      **** 			                         }
2113:../uvc.c      **** 							 }
2114:../uvc.c      **** 
2115:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2116:../uvc.c      **** 							 break;
2117:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
2118:../uvc.c      **** 							 //Data0 = glEp0Buffer[0]; //blue
2119:../uvc.c      **** 							 //Data1 = glEp0Buffer[2]; //red
2120:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2121:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2122:../uvc.c      **** 							 dataIdx++;
2123:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
2124:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2125:../uvc.c      **** 
2126:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
2127:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
2128:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2129:../uvc.c      **** 							 break;
2130:../uvc.c      **** 						 case BLCCtlID0:
2131:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2132:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
2133:../uvc.c      **** 							 {
2134:../uvc.c      **** 								 if(Data0 < 3){
2135:../uvc.c      **** 					 				 Data0 += 4;
2136:../uvc.c      **** 					 			 }else{
2137:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
2138:../uvc.c      **** 									Data0 = 4; //set to default.
2139:../uvc.c      **** 					 			 }
2140:../uvc.c      **** 					 		 }
2141:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2142:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
2143:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2144:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2145:../uvc.c      **** 					 		 break;
2146:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
2147:../uvc.c      **** 
2148:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
2149:../uvc.c      **** 							 if(Data0 != 0){
2150:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2151:../uvc.c      **** 	#ifdef COLOR
2152:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2153:../uvc.c      **** 	#else
2154:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
2155:../uvc.c      **** 								 dataIdx++;
2156:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
2157:../uvc.c      **** 	#endif
2158:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2159:../uvc.c      **** 							 }else{
2160:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2161:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
2162:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2163:../uvc.c      **** 							 }
2164:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2165:../uvc.c      **** 							 break;
2166:../uvc.c      **** 						 case ConsCtlID2:
2167:../uvc.c      **** 						 case WBTMdCtlID9:
2168:../uvc.c      **** 						 case SaturCtlID6:
2169:../uvc.c      **** 						 default:
2170:../uvc.c      **** 			 	 			 if(Len == 2)
2171:../uvc.c      **** 			 	 			 {
2172:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0){  //2Bytes
2173:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2174:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
2175:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2176:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
2177:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
2178:../uvc.c      **** 								 }
2179:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2180:../uvc.c      **** 			 	 			 }else if(Len == 4){
2181:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
2182:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
2183:../uvc.c      **** 								 {
2184:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//exposure mode (assume b3:2=00, no BLC window). C
2185:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
2186:../uvc.c      **** 									 dataIdx++;
2187:../uvc.c      **** 								 }
2188:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVHi != Data1){
2189:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
2190:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
2191:../uvc.c      **** 								 }
2192:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
2193:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2194:../uvc.c      **** 
2195:../uvc.c      **** 			 	 			 }
2196:../uvc.c      **** 			 	 			 CyU3PDebugPrint (4, "The data gets from host. [0]: 0x%x [1]: 0x%x curLo: 0x%x curHi: 0x%x
2197:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
2198:../uvc.c      **** 			 	 			 break;
2199:../uvc.c      **** 					 }
2200:../uvc.c      **** 			 	 }
2201:../uvc.c      **** 			   }else{
2202:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
2203:../uvc.c      **** 			   }
2204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2205:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
2206:../uvc.c      **** #endif
2207:../uvc.c      **** 
2208:../uvc.c      **** 			  break;
2209:../uvc.c      **** 		  default:
2210:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2211:../uvc.c      **** 			  break;
2212:../uvc.c      **** 		 }
2213:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
2214:../uvc.c      **** }
2215:../uvc.c      **** /************** CT control requests handler *************************/
2216:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
2217:../uvc.c      **** 
2218:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
2219:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
2220:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
2221:../uvc.c      ****     uint16_t readCount;
2222:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
2223:../uvc.c      ****     uint16_t diff, value, diffRd;
2224:../uvc.c      ****     uint8_t i, shutter, index;
2225:../uvc.c      ****     diff = 0xffff;
2226:../uvc.c      ****     shutter = 1;
2227:../uvc.c      ****     index = 1;
2228:../uvc.c      **** 
2229:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
2230:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
2231:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
2232:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
2233:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
2234:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2235:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
2236:../uvc.c      **** #endif
2237:../uvc.c      ****     reqData = bRequest;
2238:../uvc.c      **** 
2239:../uvc.c      ****     switch (bRequest)
2240:../uvc.c      **** 		 {
2241:../uvc.c      **** 
2242:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
2243:../uvc.c      **** 			  glEp0Buffer[0] = Len;
2244:../uvc.c      **** 			  glEp0Buffer[1] = 0;
2245:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2246:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2247:../uvc.c      **** 			  break;
2248:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
2249:../uvc.c      **** 
2250:../uvc.c      **** 			 switch(CtrlID)
2251:../uvc.c      **** 			 {
2252:../uvc.c      **** 				 default:
2253:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
2254:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
2255:../uvc.c      **** 					 glEp0Buffer[2] = 0;
2256:../uvc.c      **** 					 glEp0Buffer[3] = 0;
2257:../uvc.c      **** 					 sendData = glEp0Buffer[0];
2258:../uvc.c      **** 					 break;
2259:../uvc.c      **** 			 }
2260:../uvc.c      **** 
2261:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2262:../uvc.c      **** 
2263:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2264:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
2265:../uvc.c      **** #endif
2266:../uvc.c      **** 			  break;
2267:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
2268:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
2269:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
2270:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
2271:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2272:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2273:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2274:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2275:../uvc.c      **** 			  break;
2276:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
2277:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
2278:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
2279:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2280:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2281:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2282:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2283:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2284:../uvc.c      **** 			  break;
2285:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
2286:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
2287:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
2288:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2289:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2290:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2291:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2292:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2293:../uvc.c      **** 			  break;
2294:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
2295:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
2296:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2297:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2298:../uvc.c      **** 			  Len = 1;
2299:../uvc.c      **** 			  break;
2300:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
2301:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
2302:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
2303:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
2304:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
2305:../uvc.c      **** 			  glEp0Buffer[3] = 0;
2306:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
2307:../uvc.c      **** 			  sendData = glEp0Buffer[0];
2308:../uvc.c      **** 			  break;
2309:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
2310:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2311:../uvc.c      **** 			  glEp0Buffer, &readCount);
2312:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
2313:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
2314:../uvc.c      **** 			  value = Data1;
2315:../uvc.c      **** 
2316:../uvc.c      **** 			  switch(CtrlID)
2317:../uvc.c      **** 			  {
2318:../uvc.c      **** 		  	      case AutoExMCtlID1:
2319:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
2320:../uvc.c      **** 
2321:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
2322:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
2323:../uvc.c      **** 				    getData = glEp0Buffer[0];
2324:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
2325:../uvc.c      **** 		  		    switch (getData){
2326:../uvc.c      **** 						case 1:
2327:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
2328:../uvc.c      **** 							break;
2329:../uvc.c      **** 						case 2:
2330:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2331:../uvc.c      **** 							dataIdx = 0;
2332:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2333:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2334:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2335:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
2336:../uvc.c      **** 
2337:../uvc.c      **** 							break;
2338:../uvc.c      **** 						case 4:
2339:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2340:../uvc.c      **** 							break;
2341:../uvc.c      **** 						case 8:
2342:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2343:../uvc.c      **** 			  		    	dataIdx = 0;
2344:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2345:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2346:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2347:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
2348:../uvc.c      **** 							break;
2349:../uvc.c      **** 		  		    }
2350:../uvc.c      **** #if 0
2351:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
2352:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
2353:../uvc.c      **** 						  dataIdx = 0;
2354:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2355:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
2356:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2357:../uvc.c      **** 		  		    }
2358:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
2359:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
2360:../uvc.c      **** 		  		    }
2361:../uvc.c      **** #endif
2362:../uvc.c      **** 				    break;
2363:../uvc.c      **** 
2364:../uvc.c      **** 			  	  case ExTmACtlID3:
2365:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
2366:../uvc.c      **** 
2367:../uvc.c      **** 					  value = (value << 8)|Data0;
2368:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
2369:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
2370:../uvc.c      **** 					  {
2371:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
2372:../uvc.c      **** 						  {
2373:../uvc.c      **** 							if(value > ShutValueArry[i]){
2374:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
2375:../uvc.c      **** 							}else{
2376:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
2377:../uvc.c      **** 							}
2378:../uvc.c      **** 							  if(diff > diffRd){
2379:../uvc.c      **** 								  diff = diffRd;
2380:../uvc.c      **** 								  index = i;
2381:../uvc.c      **** 							  }
2382:../uvc.c      **** 						  }
2383:../uvc.c      **** 						  shutter = shutter+index;
2384:../uvc.c      **** 
2385:../uvc.c      **** 						  dataIdx = 0;
2386:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2387:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
2388:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2389:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
2390:../uvc.c      **** 
2391:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
2392:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
2393:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
2394:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
2395:../uvc.c      **** 					  }else{
2396:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2397:../uvc.c      **** 					  }
2398:../uvc.c      **** 					  getData = glEp0Buffer[0];
2399:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2400:../uvc.c      **** 					  break;
2401:../uvc.c      **** 			  	  case IriACtlID7:
2402:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
2403:../uvc.c      **** 					  {
2404:../uvc.c      **** 							 dataIdx = 0;
2405:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2406:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
2407:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2408:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
2409:../uvc.c      **** 
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
2411:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
2412:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
2413:../uvc.c      **** 					  }else{
2414:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
2415:../uvc.c      **** 					  }
2416:../uvc.c      **** 					  getData = glEp0Buffer[0];
2417:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2418:../uvc.c      **** 
2419:../uvc.c      **** 					  break;
2420:../uvc.c      **** 			  	  case ZmOpRCtlID10:
2421:../uvc.c      **** 					  getData = glEp0Buffer[0];
2422:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
2423:../uvc.c      **** #if 1
2424:../uvc.c      **** 					  dataIdx = 0;
2425:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2426:../uvc.c      **** 					  if(getData == 1)
2427:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
2428:../uvc.c      **** 					  else if(getData == 0xff)
2429:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
2430:../uvc.c      **** 					  else
2431:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
2432:../uvc.c      **** 					  //dataIdx++;
2433:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
2434:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
2435:../uvc.c      **** #endif
2436:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
2437:../uvc.c      **** 					  break;
2438:../uvc.c      **** 
2439:../uvc.c      **** 			  	  default:
2440:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
2441:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
2442:../uvc.c      **** 			  		 break;
2443:../uvc.c      **** 			  }
2444:../uvc.c      **** 			  break;
2445:../uvc.c      **** 		  default:
2446:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
2447:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
2448:../uvc.c      **** 			  break;
2449:../uvc.c      **** 		 }
2450:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
2451:../uvc.c      **** 
2452:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
2453:../uvc.c      **** }
2454:../uvc.c      **** 
2455:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
2456:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
2457:../uvc.c      **** {
2458:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
2459:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
2460:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
2461:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
2462:../uvc.c      **** 
2463:../uvc.c      ****     CtrlID = BrgtCtlID1;
2464:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
2465:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2466:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
2467:../uvc.c      ****     Data1 = Data0;
2468:../uvc.c      **** 
2469:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
2470:../uvc.c      ****     if(Data1&0x80){
2471:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
2472:../uvc.c      ****     }else{
2473:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
2474:../uvc.c      ****     }
2475:../uvc.c      ****     Data0 = (Data0 << 2);
2476:../uvc.c      **** 
2477:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
2478:../uvc.c      **** 
2479:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
2480:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
2481:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2482:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
2483:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
2484:../uvc.c      **** 
2485:../uvc.c      ****     CtrlID = ConsCtlID2;
2486:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2487:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2488:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2489:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
2490:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2491:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
2492:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2493:../uvc.c      **** 
2494:../uvc.c      ****     CtrlID = HueCtlID5;
2495:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2496:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2497:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2498:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
2501:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
2502:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2503:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2504:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2505:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2506:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2507:../uvc.c      **** 
2508:../uvc.c      ****     CtrlID = SaturCtlID6;
2509:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2510:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2511:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2512:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2513:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2514:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2515:../uvc.c      **** 
2516:../uvc.c      ****     CtrlID = ShapCtlID7;
2517:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2518:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2519:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2520:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2521:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2522:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2523:../uvc.c      **** 
2524:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2525:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2526:../uvc.c      **** 	return;
2527:../uvc.c      **** }
2528:../uvc.c      **** 
2529:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2530:../uvc.c      **** void
2531:../uvc.c      **** CyFxUVCAddHeader (
2532:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2533:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2534:../uvc.c      ****         )
2535:../uvc.c      **** {
2536:../uvc.c      ****     /* Copy header to buffer */
2537:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2538:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2539:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2540:../uvc.c      **** 
2541:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2542:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2543:../uvc.c      ****     {
2544:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2545:../uvc.c      ****     }
2546:../uvc.c      **** }
2547:../uvc.c      **** 
2548:../uvc.c      **** 
2549:../uvc.c      **** /* Application Error Handler */
2550:../uvc.c      **** void
2551:../uvc.c      **** CyFxAppErrorHandler (
2552:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2553:../uvc.c      ****         )
2554:../uvc.c      **** {
2555:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2556:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2557:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2558:../uvc.c      **** 
2559:../uvc.c      ****        This function can be modified to take additional error handling actions such
2560:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2561:../uvc.c      ****      */
2562:../uvc.c      ****     for (;;)
2563:../uvc.c      ****     {
2564:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2565:../uvc.c      ****         CyU3PThreadSleep (1000);
2566:../uvc.c      ****     }
2567:../uvc.c      **** }
2568:../uvc.c      **** 
2569:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2570:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2571:../uvc.c      ****  */
2572:../uvc.c      **** static void
2573:../uvc.c      **** CyFxUVCApplnAbortHandler (
2574:../uvc.c      ****         void)
2575:../uvc.c      **** {
2576:../uvc.c      **** 	uint32_t flag;
2577:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2578:../uvc.c      **** 	{
2579:../uvc.c      ****         /* Clear the Video Stream Request Event */
2580:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2581:../uvc.c      **** 
2582:../uvc.c      ****         /* Set Video Stream Abort Event */
2583:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2584:../uvc.c      **** 	}
2585:../uvc.c      **** }
2586:../uvc.c      **** 
2587:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2588:../uvc.c      **** static void
2589:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2590:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2591:../uvc.c      ****         uint16_t             evdata  /* Event data */
2592:../uvc.c      ****         )
2593:../uvc.c      **** {
2594:../uvc.c      ****     switch (evtype)
2595:../uvc.c      ****     {
2596:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2597:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2598:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2599:../uvc.c      ****             gpif_initialized = 0;
2600:../uvc.c      ****             streamingStarted = CyFalse;
2601:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2602:../uvc.c      ****             break;
2603:../uvc.c      **** 
2604:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2605:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2606:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2607:../uvc.c      ****             gpif_initialized = 0;
2608:../uvc.c      ****             streamingStarted = CyFalse;
2609:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2610:../uvc.c      ****             break;
2611:../uvc.c      **** 
2612:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2613:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2614:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2615:../uvc.c      ****             gpif_initialized = 0;
2616:../uvc.c      ****             isUsbConnected = CyFalse;
2617:../uvc.c      ****             streamingStarted = CyFalse;
2618:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2619:../uvc.c      ****             break;
2620:../uvc.c      **** 
2621:../uvc.c      **** #ifdef BACKFLOW_DETECT
2622:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2623:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2624:../uvc.c      ****             break;
2625:../uvc.c      **** #endif
2626:../uvc.c      **** 
2627:../uvc.c      ****         default:
2628:../uvc.c      ****             break;
2629:../uvc.c      ****     }
2630:../uvc.c      **** }
2631:../uvc.c      **** 
2632:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2633:../uvc.c      **** static CyBool_t
2634:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2635:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2636:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2637:../uvc.c      ****         )
2638:../uvc.c      **** {
2639:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2640:../uvc.c      ****     uint32_t status;
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Obtain Request Type and Request */
2643:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2644:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2645:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2646:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2647:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2648:../uvc.c      **** 
2649:../uvc.c      ****     /* Check for UVC Class Requests */
2650:../uvc.c      ****     switch (bmReqType)
2651:../uvc.c      ****     {
2652:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2653:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2654:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2655:../uvc.c      ****             switch (wIndex & 0xFF)
2656:../uvc.c      ****             {
2657:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2658:../uvc.c      ****                     {
2659:../uvc.c      ****                         uvcHandleReq = CyTrue;
2660:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2661:../uvc.c      ****                                 CYU3P_EVENT_OR);
2662:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2663:../uvc.c      ****                         {
2664:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2665:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2666:../uvc.c      ****                         }
2667:../uvc.c      ****                     }
2668:../uvc.c      ****                     break;
2669:../uvc.c      **** 
2670:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2671:../uvc.c      ****                     {
2672:../uvc.c      ****                         uvcHandleReq = CyTrue;
2673:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2674:../uvc.c      ****                                 CYU3P_EVENT_OR);
2675:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2676:../uvc.c      ****                         {
2677:../uvc.c      ****                             /* Error handling */
2678:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2679:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2680:../uvc.c      ****                         }
2681:../uvc.c      ****                     }
2682:../uvc.c      ****                     break;
2683:../uvc.c      **** 
2684:../uvc.c      ****                 default:
2685:../uvc.c      ****                     break;
2686:../uvc.c      ****             }
2687:../uvc.c      ****             break;
2688:../uvc.c      **** 
2689:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2690:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2691:../uvc.c      ****             {
2692:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2693:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2694:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2695:../uvc.c      ****                 {
2696:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2697:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2698:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2699:../uvc.c      ****                     gpif_initialized = 0;
2700:../uvc.c      ****                     streamingStarted = CyFalse;
2701:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2702:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2703:../uvc.c      ****                     CyU3PBusyWait (100);
2704:../uvc.c      **** 
2705:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2706:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2707:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2708:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2709:../uvc.c      ****                     CyU3PBusyWait (100);
2710:../uvc.c      **** 
2711:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2712:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2713:../uvc.c      ****                     uvcHandleReq = CyTrue;
2714:../uvc.c      ****                     /* Complete Control request handshake */
2715:../uvc.c      ****                     CyU3PUsbAckSetup ();
2716:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2717:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2718:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2719:../uvc.c      **** 
2720:../uvc.c      ****                 }
2721:../uvc.c      ****             }
2722:../uvc.c      ****             break;
2723:../uvc.c      **** 
2724:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2725:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2726:../uvc.c      ****             {
2727:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2728:../uvc.c      ****                 {
2729:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2730:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2731:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2732:../uvc.c      ****                 	 * has started. */
2733:../uvc.c      ****                     if (streamingStarted == CyTrue)
2734:../uvc.c      ****                     {
2735:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2736:../uvc.c      **** 
2737:../uvc.c      ****                         /* Disable the GPIF state machine. */
2738:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2739:../uvc.c      ****                         gpif_initialized = 0;
2740:../uvc.c      ****                         streamingStarted = CyFalse;
2741:../uvc.c      **** 
2742:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2743:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2744:../uvc.c      ****                         CyU3PBusyWait (100);
2745:../uvc.c      **** 
2746:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2747:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2748:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2749:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2750:../uvc.c      ****                         CyU3PBusyWait (100);
2751:../uvc.c      **** 
2752:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2753:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2754:../uvc.c      **** 
2755:../uvc.c      ****                         uvcHandleReq = CyTrue;
2756:../uvc.c      ****                         /* Complete Control request handshake */
2757:../uvc.c      ****                         CyU3PUsbAckSetup ();
2758:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2759:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2760:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2761:../uvc.c      ****                     }
2762:../uvc.c      ****                     else
2763:../uvc.c      ****                     {
2764:../uvc.c      ****                         uvcHandleReq = CyTrue;
2765:../uvc.c      ****                         CyU3PUsbAckSetup ();
2766:../uvc.c      ****                     }
2767:../uvc.c      ****                 }
2768:../uvc.c      ****             }
2769:../uvc.c      ****             break;
2770:../uvc.c      **** 
2771:../uvc.c      ****         default:
2772:../uvc.c      ****             break;
2773:../uvc.c      ****     }
2774:../uvc.c      **** 
2775:../uvc.c      ****     /* Return status of request handling to the USB driver */
2776:../uvc.c      ****     return uvcHandleReq;
2777:../uvc.c      **** }
2778:../uvc.c      **** 
2779:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2780:../uvc.c      **** 
2781:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2782:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2783:../uvc.c      ****  */
2784:../uvc.c      **** void
2785:../uvc.c      **** CyFxUvcApplnDmaCallback (
2786:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2787:../uvc.c      ****         CyU3PDmaCbType_t      type,
2788:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2789:../uvc.c      ****         )
2790:../uvc.c      **** {
2791:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2792:../uvc.c      **** #if 1
2793:../uvc.c      ****     CyU3PReturnStatus_t status;
2794:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2795:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2796:../uvc.c      **** 
2797:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2798:../uvc.c      ****     {
2799:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2800:../uvc.c      ****             {
2801:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2802:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2803:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2804:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2805:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2806:../uvc.c      ****                 	stiflag = 0x03;
2807:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2808:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2809:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2810:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2811:../uvc.c      ****                 }
2812:../uvc.c      **** #endif
2813:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2814:../uvc.c      ****                 fb++;
2815:../uvc.c      ****             }
2816:../uvc.c      ****             else
2817:../uvc.c      ****             {
2818:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2819:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2820:../uvc.c      ****                 pb++;
2821:../uvc.c      ****                 pbc = input->buffer_p.count;
2822:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2823:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2824:../uvc.c      ****                 //lineCount = 0; //res test
2825:../uvc.c      **** #if 1   //remove the still flag clearing here
2826:../uvc.c      ****                 if(stiflag == 0x0F){
2827:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2828:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2829:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2830:../uvc.c      ****                 	stiflag = 0xAA;
2831:../uvc.c      ****                 }
2832:../uvc.c      **** #endif
2833:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2834:../uvc.c      ****             }
2835:../uvc.c      **** 
2836:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2837:../uvc.c      ****             prodCount++;
2838:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2839:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2840:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2841:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2842:../uvc.c      ****             {
2843:../uvc.c      ****                 prodCount--;
2844:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2845:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2846:../uvc.c      ****             }
2847:../uvc.c      ****     }
2848:../uvc.c      **** #endif
2849:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2850:../uvc.c      ****     {
2851:../uvc.c      ****         consCount++;
2852:../uvc.c      ****         streamingStarted = CyTrue;
2853:../uvc.c      ****     }
2854:../uvc.c      **** }
2855:../uvc.c      **** 
2856:../uvc.c      **** /*
2857:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2858:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2859:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2860:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2861:../uvc.c      ****  * to commit the buffer.
2862:../uvc.c      ****  */
2863:../uvc.c      **** static uint8_t
2864:../uvc.c      **** CyFxUvcAppCommitEOF (
2865:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2866:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2867:../uvc.c      ****         )
2868:../uvc.c      **** {
2869:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2870:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2871:../uvc.c      **** 
2872:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2873:../uvc.c      **** 
2874:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2875:../uvc.c      ****     {
2876:../uvc.c      ****         switch (stateId)
2877:../uvc.c      ****         {
2878:../uvc.c      **** 
2879:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2880:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2881:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2882:../uvc.c      ****                 break;
2883:../uvc.c      **** 
2884:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2885:../uvc.c      ****                 socket = 0;
2886:../uvc.c      ****                 break;
2887:../uvc.c      **** 
2888:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2889:../uvc.c      ****                 socket = 1;
2890:../uvc.c      ****                 break;
2891:../uvc.c      **** 
2892:../uvc.c      ****             default:
2893:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2894:../uvc.c      ****                 /* Unexpected current state. Return error. */
2895:../uvc.c      ****             	//lineCount++;
2896:../uvc.c      ****             	return 1;
2897:../uvc.c      ****         }
2898:../uvc.c      ****     }
2899:../uvc.c      **** 
2900:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2901:../uvc.c      ****     {
2902:../uvc.c      ****         switch (stateId)
2903:../uvc.c      ****         {
2904:../uvc.c      **** #ifndef CAM720
2905:../uvc.c      **** #ifdef GPIFIIM
2906:../uvc.c      ****             case 13:
2907:../uvc.c      ****             case 24:
2908:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2909:../uvc.c      ****                 break;
2910:../uvc.c      **** 
2911:../uvc.c      ****             case 8:
2912:../uvc.c      ****                 socket = 0;
2913:../uvc.c      ****                 break;
2914:../uvc.c      **** 
2915:../uvc.c      ****             case 20:
2916:../uvc.c      ****                 socket = 1;
2917:../uvc.c      ****                 break;
2918:../uvc.c      **** #else
2919:../uvc.c      ****             case 11:
2920:../uvc.c      ****             case 18:
2921:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2922:../uvc.c      ****                 break;
2923:../uvc.c      **** 
2924:../uvc.c      ****             case 8:
2925:../uvc.c      ****                 socket = 0;
2926:../uvc.c      ****                 break;
2927:../uvc.c      **** 
2928:../uvc.c      ****             case 15:
2929:../uvc.c      ****                 socket = 1;
2930:../uvc.c      ****                 break;
2931:../uvc.c      **** #endif
2932:../uvc.c      **** #else
2933:../uvc.c      ****             case 11:
2934:../uvc.c      ****             case 18:
2935:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2936:../uvc.c      ****                 break;
2937:../uvc.c      **** 
2938:../uvc.c      ****             case 8:
2939:../uvc.c      ****                 socket = 0;
2940:../uvc.c      ****                 break;
2941:../uvc.c      **** 
2942:../uvc.c      ****             case 15:
2943:../uvc.c      ****                 socket = 1;
2944:../uvc.c      ****                 break;
2945:../uvc.c      **** 
2946:../uvc.c      **** #endif
2947:../uvc.c      ****              default:
2948:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2949:../uvc.c      ****                 /* Unexpected current state. Return error. */
2950:../uvc.c      ****                return 1;
2951:../uvc.c      ****         }
2952:../uvc.c      ****     }
2953:../uvc.c      **** 
2954:../uvc.c      ****     if (socket != 0xFF)
2955:../uvc.c      ****     {
2956:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2957:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2958:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2959:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2960:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2961:../uvc.c      ****         {
2962:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2963:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2964:../uvc.c      ****         }
2965:../uvc.c      ****     }
2966:../uvc.c      **** 
2967:../uvc.c      ****     return 0;
2968:../uvc.c      **** }
2969:../uvc.c      **** 
2970:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2971:../uvc.c      **** void
2972:../uvc.c      **** CyFxGpifCB (
2973:../uvc.c      ****         CyU3PGpifEventType event,
2974:../uvc.c      ****         uint8_t currentState
2975:../uvc.c      ****         )
2976:../uvc.c      **** {
2977:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2978:../uvc.c      ****     {
2979:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2980:../uvc.c      ****     	           in the UVC implementation. */
2981:../uvc.c      ****     	//hitFV = CyTrue;
2982:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2983:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2984:../uvc.c      ****     }
2985:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2986:../uvc.c      **** }
2987:../uvc.c      **** 
2988:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2989:../uvc.c      **** static void
2990:../uvc.c      **** CyFxUVCApplnDebugInit (
2991:../uvc.c      ****         void)
2992:../uvc.c      **** {
2993:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2994:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2995:../uvc.c      **** 
2996:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2997:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2998:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2999:../uvc.c      ****     {
3000:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
3001:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3002:../uvc.c      ****     }
3003:../uvc.c      **** 
3004:../uvc.c      ****     /* Set UART Configuration */
3005:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
3006:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
3007:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
3008:../uvc.c      ****     uartConfig.txEnable = CyTrue;
3009:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
3010:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
3011:../uvc.c      ****     uartConfig.isDma    = CyTrue;
3012:../uvc.c      **** 
3013:../uvc.c      ****     /* Set the UART configuration */
3014:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
3015:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3016:../uvc.c      ****     {
3017:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3018:../uvc.c      ****     }
3019:../uvc.c      **** 
3020:../uvc.c      ****     /* Set the UART transfer */
3021:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
3022:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3023:../uvc.c      ****     {
3024:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3025:../uvc.c      ****     }
3026:../uvc.c      **** 
3027:../uvc.c      ****     /* Initialize the Debug logger module. */
3028:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
3029:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3030:../uvc.c      ****     {
3031:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3032:../uvc.c      ****     }
3033:../uvc.c      **** 
3034:../uvc.c      ****     /* Disable log message headers. */
3035:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
3036:../uvc.c      **** }
3037:../uvc.c      **** 
3038:../uvc.c      **** /* I2C initialization. */
3039:../uvc.c      **** static void
3040:../uvc.c      **** CyFxUVCApplnI2CInit (void)
3041:../uvc.c      **** {
3042:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
3043:../uvc.c      ****     CyU3PReturnStatus_t status;
3044:../uvc.c      **** 
3045:../uvc.c      ****     status = CyU3PI2cInit ();
3046:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
3047:../uvc.c      ****     {
3048:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
3049:../uvc.c      ****         CyFxAppErrorHandler (status);
3050:../uvc.c      ****     }
3051:../uvc.c      **** 
3052:../uvc.c      ****     /*  Set I2C Configuration */
3053:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
3054:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
3055:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
3056:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
3057:../uvc.c      **** 
3058:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
3059:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
3060:../uvc.c      ****     {
3061:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
3062:../uvc.c      ****         CyFxAppErrorHandler (status);
3063:../uvc.c      ****     }
3064:../uvc.c      **** }
3065:../uvc.c      **** 
3066:../uvc.c      **** #ifdef BACKFLOW_DETECT
3067:../uvc.c      **** static void CyFxUvcAppPibCallback (
3068:../uvc.c      ****         CyU3PPibIntrType cbType,
3069:../uvc.c      ****         uint16_t cbArg)
3070:../uvc.c      **** {
3071:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
3072:../uvc.c      ****     {
3073:../uvc.c      ****         if (!back_flow_detected)
3074:../uvc.c      ****         {
3075:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
3076:../uvc.c      ****             back_flow_detected = 1;
3077:../uvc.c      ****         }
3078:../uvc.c      ****     }
3079:../uvc.c      **** }
3080:../uvc.c      **** #endif
3081:../uvc.c      **** 
3082:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3083:../uvc.c      **** static void
3084:../uvc.c      **** CyFxUvcAppDebugCallback (
3085:../uvc.c      ****         CyU3PDmaChannel   *handle,
3086:../uvc.c      ****         CyU3PDmaCbType_t   type,
3087:../uvc.c      ****         CyU3PDmaCBInput_t *input)
3088:../uvc.c      **** {
3089:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
3090:../uvc.c      ****     {
3091:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
3092:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
3093:../uvc.c      ****     }
3094:../uvc.c      **** }
3095:../uvc.c      **** #endif
3096:../uvc.c      **** 
3097:../uvc.c      **** #if 0
3098:../uvc.c      **** static void CyFxAppIntEpCb(
3099:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
3100:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
3101:../uvc.c      **** 		uint8_t  ebNum)
3102:../uvc.c      **** 		{
3103:../uvc.c      **** 			//CyBool_t value;
3104:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
3105:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
3106:../uvc.c      **** 
3107:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
3108:../uvc.c      **** 		}
3109:../uvc.c      **** #endif
3110:../uvc.c      **** 
3111:../uvc.c      **** /* This function initializes the USB Module, creates event group,
3112:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
3113:../uvc.c      ****    configures the DMA module for the UVC Application */
3114:../uvc.c      **** static void
3115:../uvc.c      **** CyFxUVCApplnInit (void)
3116:../uvc.c      **** {
3117:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
3118:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
3119:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
3120:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
3121:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
3122:../uvc.c      ****     CyU3PPibClock_t              pibclock;
3123:../uvc.c      **** 
3124:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
3125:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
3126:../uvc.c      **** 
3127:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3128:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
3129:../uvc.c      **** #endif
3130:../uvc.c      **** 
3131:../uvc.c      ****     /* Create UVC event group */
3132:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
3133:../uvc.c      ****     if (apiRetStatus != 0)
3134:../uvc.c      ****     {
3135:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
3136:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3137:../uvc.c      ****     }
3138:../uvc.c      **** 
3139:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3140:../uvc.c      ****     CyFxUvcAppPTZInit ();
3141:../uvc.c      **** #endif
3142:../uvc.c      **** 
3143:../uvc.c      ****     isUsbConnected = CyFalse;
3144:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
3145:../uvc.c      **** 
3146:../uvc.c      ****     /* Init the GPIO module */
3147:../uvc.c      ****     gpioClock.fastClkDiv = 2;
3148:../uvc.c      ****     gpioClock.slowClkDiv = 2;
3149:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
3150:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
3151:../uvc.c      ****     gpioClock.halfDiv    = 0;
3152:../uvc.c      **** 
3153:../uvc.c      ****     /* Initialize Gpio interface */
3154:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
3155:../uvc.c      ****     if (apiRetStatus != 0)
3156:../uvc.c      ****     {
3157:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
3158:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3159:../uvc.c      ****     }
3160:../uvc.c      **** 
3161:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
3162:../uvc.c      ****      * must use GpioOverride to configure it */
3163:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
3164:../uvc.c      ****     if (apiRetStatus != 0)
3165:../uvc.c      ****     {
3166:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
3167:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3168:../uvc.c      ****     }
3169:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
3170:../uvc.c      ****     if (apiRetStatus != 0)
3171:../uvc.c      ****     {
3172:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
3173:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3174:../uvc.c      ****     }
3175:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
3176:../uvc.c      ****     if (apiRetStatus != 0)
3177:../uvc.c      ****     {
3178:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
3179:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3180:../uvc.c      ****     }
3181:../uvc.c      **** 
3182:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
3183:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3184:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3185:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3186:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3187:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3188:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
3189:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3190:../uvc.c      ****     {
3191:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
3192:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3193:../uvc.c      ****     }
3194:../uvc.c      **** 
3195:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
3196:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3197:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
3198:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
3199:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
3200:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
3201:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3202:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
3203:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3204:../uvc.c      ****     {
3205:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
3206:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3207:../uvc.c      ****     }
3208:../uvc.c      **** 
3209:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
3210:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
3211:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
3212:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
3213:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
3214:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
3215:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
3216:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
3217:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3218:../uvc.c      ****     {
3219:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
3220:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3221:../uvc.c      ****     }
3222:../uvc.c      **** 
3223:../uvc.c      ****     /* Initialize the P-port. */
3224:../uvc.c      ****     pibclock.clkDiv      = 2;
3225:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
3226:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
3227:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
3228:../uvc.c      **** 
3229:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
3230:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3231:../uvc.c      ****     {
3232:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3233:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3234:../uvc.c      ****     }
3235:../uvc.c      **** 
3236:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
3237:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
3238:../uvc.c      **** 
3239:../uvc.c      **** #ifdef BACKFLOW_DETECT
3240:../uvc.c      ****     back_flow_detected = 0;
3241:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
3242:../uvc.c      **** #endif
3243:../uvc.c      **** 
3244:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
3245:../uvc.c      ****     SensorReset ();
3246:../uvc.c      ****     CyU3PThreadSleep(5000);
3247:../uvc.c      ****     //SensorInit ();
3248:../uvc.c      **** 
3249:../uvc.c      ****     /* USB initialization. */
3250:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
3251:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3252:../uvc.c      ****     {
3253:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
3254:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3255:../uvc.c      ****     }
3256:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
3257:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
3258:../uvc.c      **** 
3259:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
3260:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
3261:../uvc.c      **** 
3262:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
3263:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
3264:../uvc.c      **** 
3265:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
3266:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
3267:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
3268:../uvc.c      **** 
3269:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
3270:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
3271:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
3272:../uvc.c      **** 
3273:../uvc.c      ****     /* Configuration descriptors. */
3274:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
3275:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
3276:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
3277:../uvc.c      **** 
3278:../uvc.c      ****     /* String Descriptors */
3279:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
3280:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
3281:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
3282:../uvc.c      **** 
3283:../uvc.c      ****     /* Configure the status interrupt endpoint.
3284:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
3285:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
3286:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
3287:../uvc.c      ****      */
3288:../uvc.c      ****     endPointConfig.enable   = 1;
3289:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
3290:../uvc.c      ****     endPointConfig.pcktSize = 64;
3291:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3292:../uvc.c      ****     endPointConfig.streams  = 0;
3293:../uvc.c      ****     endPointConfig.burstLen = 1;
3294:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
3295:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3296:../uvc.c      ****     {
3297:../uvc.c      ****         /* Error Handling */
3298:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3299:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3300:../uvc.c      ****     }
3301:../uvc.c      **** 
3302:../uvc.c      ****     /* create a DMA for interrupt endpoint */
3303:../uvc.c      ****     dmaInterConfig.size           = 1024;
3304:../uvc.c      ****     dmaInterConfig.count          = 1;
3305:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3306:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
3307:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
3308:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
3309:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
3310:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
3311:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3312:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
3313:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
3314:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
3315:../uvc.c      ****             &dmaInterConfig);
3316:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3317:../uvc.c      ****     {
3318:../uvc.c      ****         /* Error handling */
3319:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
3320:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3321:../uvc.c      ****     }
3322:../uvc.c      **** 
3323:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3324:../uvc.c      ****     if (glInterStaBuffer == 0)
3325:../uvc.c      ****     {
3326:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
3327:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3328:../uvc.c      ****     }
3329:../uvc.c      **** 
3330:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
3331:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
3332:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
3333:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
3334:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
3335:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
3336:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
3337:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
3338:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
3339:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
3340:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
3341:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
3342:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3343:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
3344:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
3345:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
3346:../uvc.c      ****             &dmaMultiConfig);
3347:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3348:../uvc.c      ****     {
3349:../uvc.c      ****         /* Error handling */
3350:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
3351:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3352:../uvc.c      ****     }
3353:../uvc.c      **** 
3354:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3355:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
3356:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
3357:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
3358:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
3359:../uvc.c      ****      */
3360:../uvc.c      **** 
3361:../uvc.c      ****     endPointConfig.enable   = 1;
3362:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3363:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
3364:../uvc.c      ****     endPointConfig.isoPkts  = 0;
3365:../uvc.c      ****     endPointConfig.streams  = 0;
3366:../uvc.c      ****     endPointConfig.burstLen = 1;
3367:../uvc.c      **** 
3368:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
3369:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3370:../uvc.c      ****     {
3371:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
3372:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3373:../uvc.c      ****     }
3374:../uvc.c      **** 
3375:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
3376:../uvc.c      **** 
3377:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
3378:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3379:../uvc.c      ****     {
3380:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
3381:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3382:../uvc.c      ****     }
3383:../uvc.c      **** 
3384:../uvc.c      ****     channelConfig.size           = 1024;
3385:../uvc.c      ****     channelConfig.count          = 1;
3386:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
3387:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
3388:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3389:../uvc.c      ****     channelConfig.prodHeader     = 0;
3390:../uvc.c      ****     channelConfig.prodFooter     = 0;
3391:../uvc.c      ****     channelConfig.consHeader     = 0;
3392:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3393:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
3394:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
3395:../uvc.c      **** 
3396:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
3397:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3398:../uvc.c      ****     {
3399:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
3400:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3401:../uvc.c      ****     }
3402:../uvc.c      **** 
3403:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
3404:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3405:../uvc.c      ****     {
3406:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
3407:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3408:../uvc.c      ****     }
3409:../uvc.c      **** 
3410:../uvc.c      ****     channelConfig.size           = 1024;
3411:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
3412:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
3413:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
3414:../uvc.c      ****     channelConfig.prodAvailCount = 0;
3415:../uvc.c      ****     channelConfig.prodHeader     = 0;
3416:../uvc.c      ****     channelConfig.prodFooter     = 0;
3417:../uvc.c      ****     channelConfig.consHeader     = 0;
3418:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
3419:../uvc.c      ****     channelConfig.notification   = 0;
3420:../uvc.c      ****     channelConfig.cb             = 0;
3421:../uvc.c      **** 
3422:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
3423:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3424:../uvc.c      ****     {
3425:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
3426:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3427:../uvc.c      ****     }
3428:../uvc.c      **** 
3429:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
3430:../uvc.c      ****     if (glDebugRspBuffer == 0)
3431:../uvc.c      ****     {
3432:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
3433:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
3434:../uvc.c      ****     }
3435:../uvc.c      **** #endif
3436:../uvc.c      **** 
3437:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
3438:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
3439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3440:../uvc.c      ****     {
3441:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
3442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3443:../uvc.c      ****     }
3444:../uvc.c      **** 
3445:../uvc.c      ****     CyU3PBusyWait(100);
3446:../uvc.c      **** 
3447:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
3448:../uvc.c      **** 
3449:../uvc.c      ****     endPointConfig.enable   = 1;
3450:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
3451:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
3452:../uvc.c      ****     {
3453:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
3454:../uvc.c      ****     	endPointConfig.burstLen = 16;
3455:../uvc.c      ****     }
3456:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
3457:../uvc.c      ****     {
3458:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
3459:../uvc.c      ****     	endPointConfig.burstLen = 1;
3460:../uvc.c      ****     }
3461:../uvc.c      ****     endPointConfig.streams  = 0;
3462:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
3463:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3464:../uvc.c      ****     {
3465:../uvc.c      ****         /* Error Handling */
3466:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
3467:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3468:../uvc.c      ****     }
3469:../uvc.c      **** #if 0    //for still image method 3 using
3470:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
3471:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3472:../uvc.c      ****     {
3473:../uvc.c      ****         /* Error Handling */
3474:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
3475:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3476:../uvc.c      ****     }
3477:../uvc.c      **** #endif
3478:../uvc.c      **** 
3479:../uvc.c      **** }
3480:../uvc.c      **** 
3481:../uvc.c      **** /*
3482:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
3483:../uvc.c      ****  * streaming session is started.
3484:../uvc.c      ****  */
3485:../uvc.c      **** static void
3486:../uvc.c      **** CyFxUvcAppGpifInit (
3487:../uvc.c      ****         void)
3488:../uvc.c      **** {
3489:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3490:../uvc.c      **** 
3491:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3492:../uvc.c      ****     {
3493:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3494:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3495:../uvc.c      ****     }
3496:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3497:../uvc.c      ****     {
3498:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3499:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3500:../uvc.c      ****     }
3501:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3502:../uvc.c      ****     {
3503:../uvc.c      ****         /* Error Handling */
3504:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3505:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3506:../uvc.c      ****     }
3507:../uvc.c      **** 
3508:../uvc.c      ****     /* Start the state machine from the designated start state. */
3509:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3510:../uvc.c      ****     {
3511:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3512:../uvc.c      ****     }
3513:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3514:../uvc.c      ****     {
3515:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3516:../uvc.c      ****     }
3517:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3518:../uvc.c      ****     {
3519:../uvc.c      ****         /* Error Handling */
3520:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3521:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3522:../uvc.c      ****     }
3523:../uvc.c      **** }
3524:../uvc.c      **** 
3525:../uvc.c      **** /*
3526:../uvc.c      ****  * Entry function for the UVC Application Thread
3527:../uvc.c      ****  */
3528:../uvc.c      **** 
3529:../uvc.c      **** uint32_t posTick;
3530:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3531:../uvc.c      **** 
3532:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 3532 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
3533:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 3533 0
  28 0000 28209FE5 		ldr	r2, .L2
3532:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 3532 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 3533 0
  36 0008 002092E5 		ldr	r2, [r2]
3532:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 3532 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 3533 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
3534:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 3534 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
3535:../uvc.c      **** }
  49              		.loc 1 3535 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
3534:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 3534 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
3536:../uvc.c      **** 
3537:../uvc.c      **** 
3538:../uvc.c      **** void
3539:../uvc.c      **** UVCAppThread_Entry (
3540:../uvc.c      ****         uint32_t input)
3541:../uvc.c      **** {
3542:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3543:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3544:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3545:../uvc.c      ****     uint8_t i = 0;
3546:../uvc.c      ****     uint32_t flag;
3547:../uvc.c      ****     uint32_t prinflag = 0;
3548:../uvc.c      **** static uint8_t IMcount = 0;
3549:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3550:../uvc.c      ****     uint32_t frameCnt = 0;
3551:../uvc.c      **** #endif
3552:../uvc.c      ****     /* Initialize the Uart Debug Module */
3553:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3554:../uvc.c      **** 
3555:../uvc.c      ****     /* Initialize the I2C interface */
3556:../uvc.c      **** 	while (i++ < 6){
3557:../uvc.c      **** 		CyU3PThreadSleep(500);
3558:../uvc.c      **** 	}
3559:../uvc.c      **** 
3560:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3561:../uvc.c      **** 
3562:../uvc.c      ****     /* Initialize the UVC Application */
3563:../uvc.c      ****     CyFxUVCApplnInit ();
3564:../uvc.c      ****     /*
3565:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3566:../uvc.c      **** 
3567:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3568:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3569:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3570:../uvc.c      **** 
3571:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3572:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3573:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3574:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3575:../uvc.c      **** 
3576:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3577:../uvc.c      ****        of handling the abort request.
3578:../uvc.c      ****      */
3579:../uvc.c      **** 
3580:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3581:../uvc.c      ****     //CyU3PThreadSleep(1000);
3582:../uvc.c      **** 
3583:../uvc.c      ****     for (;;)
3584:../uvc.c      ****     {
3585:../uvc.c      ****         /* Waiting for the Video Stream Event */
3586:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3587:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3588:../uvc.c      ****         {
3589:../uvc.c      **** #if 0 //test for new firmware no video bring up
3590:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3591:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3592:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3593:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3594:../uvc.c      ****             {
3595:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3596:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3597:../uvc.c      ****                 {
3598:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3599:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3600:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3601:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3602:../uvc.c      **** #endif
3603:../uvc.c      **** #endif
3604:../uvc.c      ****                     }
3605:../uvc.c      ****                 else
3606:../uvc.c      ****                 {
3607:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3608:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3609:../uvc.c      **** #ifdef USB_LOWRES_IMG
3610:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3611:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3612:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3613:../uvc.c      **** #endif
3614:../uvc.c      **** #endif
3615:../uvc.c      ****                 }
3616:../uvc.c      **** 
3617:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3618:../uvc.c      ****                 prodCount++;
3619:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3620:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3621:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3622:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3623:../uvc.c      ****                 {
3624:../uvc.c      ****                     prodCount--;
3625:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3626:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3627:../uvc.c      ****                 }
3628:../uvc.c      ****             }
3629:../uvc.c      **** #endif
3630:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3631:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3632:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3633:../uvc.c      ****             {
3634:../uvc.c      ****             	if(0&&(prinflag == 0)){
3635:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3636:../uvc.c      ****             		prinflag = 1;
3637:../uvc.c      ****             	}
3638:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3639:../uvc.c      ****             	fb=0;
3640:../uvc.c      ****             	pb=0;
3641:../uvc.c      ****             	pbc=0;
3642:../uvc.c      ****                 prodCount = 0;
3643:../uvc.c      ****                 consCount = 0;
3644:../uvc.c      ****                 hitFV     = CyFalse;
3645:../uvc.c      **** 
3646:../uvc.c      **** #ifdef BACKFLOW_DETECT
3647:../uvc.c      ****                 back_flow_detected = 0;
3648:../uvc.c      **** #endif
3649:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3650:../uvc.c      ****                 frameCnt++;
3651:../uvc.c      **** #endif
3652:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3653:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3654:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3655:../uvc.c      ****                 //}
3656:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3657:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3658:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3659:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3660:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3661:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3662:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3663:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3664:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3665:../uvc.c      ****                 		stiflag = 0xFF;
3666:../uvc.c      ****                 		IMcount = 0;
3667:../uvc.c      ****                 	}
3668:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3669:../uvc.c      **** 
3670:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3671:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3672:../uvc.c      ****                 		stiflag = 0x0F;
3673:../uvc.c      ****                 		IMcount = 0;
3674:../uvc.c      ****                 		}
3675:../uvc.c      ****                  		/*if(IMcount > 0x4){
3676:../uvc.c      ****                 			stiflag = 0x0F;
3677:../uvc.c      ****                 			IMcount = 0;
3678:../uvc.c      ****                 		}*/
3679:../uvc.c      **** 
3680:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3681:../uvc.c      ****                     //CyU3PThreadSleep(400);
3682:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3683:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3684:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3685:../uvc.c      **** 
3686:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3687:../uvc.c      ****                 	{
3688:../uvc.c      ****                     switch (setRes)
3689:../uvc.c      ****                      {
3690:../uvc.c      ****                  	case 1: //1944
3691:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/*boardID
3692:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3693:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x22:0xA2
3694:../uvc.c      ****                  		break;
3695:../uvc.c      ****                  	case 2: //1080
3696:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/*boardID
3697:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3698:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x12:0x92
3699:../uvc.c      ****                  		break;
3700:../uvc.c      ****                  	case 3: //720
3701:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_DSPBOARD
3702:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3703:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x02:0x
3704:../uvc.c      ****                  		break;
3705:../uvc.c      ****                  	case 4: //VGA
3706:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_DSPBOARD
3707:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3708:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x32:0x
3709:../uvc.c      ****                  		break;
3710:../uvc.c      ****                  	default:
3711:../uvc.c      ****                  		break;
3712:../uvc.c      ****                      }
3713:../uvc.c      ****                     IMcount = 0;
3714:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3715:../uvc.c      ****                 	stiflag = 0x0;
3716:../uvc.c      ****                 	}
3717:../uvc.c      ****                 }
3718:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3719:../uvc.c      ****                 /* Reset the DMA channel. */
3720:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3721:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3722:../uvc.c      ****                 {
3723:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3724:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3725:../uvc.c      ****                 }
3726:../uvc.c      **** 
3727:../uvc.c      ****                 /* Start Channel Immediately */
3728:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3729:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3730:../uvc.c      ****                 {
3731:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3732:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3733:../uvc.c      ****                 }
3734:../uvc.c      **** 
3735:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3736:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3737:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3738:../uvc.c      ****                 }
3739:../uvc.c      ****         }
3740:../uvc.c      ****         else
3741:../uvc.c      ****         {
3742:../uvc.c      ****             /* If we have a stream abort request pending. */
3743:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3744:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3745:../uvc.c      ****             {
3746:../uvc.c      ****                 hitFV     = CyFalse;
3747:../uvc.c      ****                 prodCount = 0;
3748:../uvc.c      ****                 consCount = 0;
3749:../uvc.c      ****                 if(0&&(prinflag == 0)){
3750:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3751:../uvc.c      ****                 	prinflag = 1;
3752:../uvc.c      ****                 }
3753:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3754:../uvc.c      ****                 fb=0;
3755:../uvc.c      ****                 pb=0;
3756:../uvc.c      ****                 pbc=0;
3757:../uvc.c      **** 
3758:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3759:../uvc.c      ****                 {
3760:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3761:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3762:../uvc.c      ****                     {
3763:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3764:../uvc.c      ****                     }
3765:../uvc.c      **** 
3766:../uvc.c      ****                     /* Flush the Endpoint memory */
3767:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3768:../uvc.c      ****                 }
3769:../uvc.c      **** 
3770:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3771:../uvc.c      ****             }
3772:../uvc.c      ****             else
3773:../uvc.c      ****             {
3774:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3775:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3776:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3777:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3778:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3779:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3780:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3781:../uvc.c      ****                 {
3782:../uvc.c      ****                     /* Error handling */
3783:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3784:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3785:../uvc.c      ****                 }
3786:../uvc.c      **** 
3787:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3788:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3789:../uvc.c      ****                 {
3790:../uvc.c      **** #if 0
3791:../uvc.c      ****                 	//for start up of the AF Lens
3792:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3793:../uvc.c      ****                     CyU3PThreadSleep(500);
3794:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3795:../uvc.c      ****                     CyU3PThreadSleep(500);
3796:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3797:../uvc.c      ****                    	CyU3PThreadSleep(300);
3798:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3799:../uvc.c      ****                     CyU3PThreadSleep(500);
3800:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3801:../uvc.c      ****                     CyU3PThreadSleep(500);
3802:../uvc.c      **** #endif
3803:../uvc.c      **** #if 0
3804:../uvc.c      ****                     switch (setRes)
3805:../uvc.c      ****                     {
3806:../uvc.c      ****                     	case 1: //1944
3807:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3808:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3809:../uvc.c      ****                     		break;
3810:../uvc.c      ****                     	case 2: //1080
3811:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3812:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3813:../uvc.c      ****                     		break;
3814:../uvc.c      ****                     	case 3: //720
3815:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3816:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3817:../uvc.c      ****                     		break;
3818:../uvc.c      ****                     	default:
3819:../uvc.c      ****                     		break;
3820:../uvc.c      ****                     }
3821:../uvc.c      **** #endif
3822:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3823:../uvc.c      **** 
3824:../uvc.c      ****                     gpif_initialized = CyTrue;
3825:../uvc.c      ****                     CyU3PThreadSleep(200);
3826:../uvc.c      ****                     
3827:../uvc.c      ****                 }
3828:../uvc.c      ****                 else
3829:../uvc.c      ****                 {
3830:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3831:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3832:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3833:../uvc.c      ****                 }
3834:../uvc.c      ****             }
3835:../uvc.c      ****         }
3836:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3837:../uvc.c      **** 
3838:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3839:../uvc.c      ****         CyU3PThreadRelinquish ();
3840:../uvc.c      ****     }
3841:../uvc.c      **** }
3842:../uvc.c      **** 
3843:../uvc.c      **** /*
3844:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3845:../uvc.c      ****  */
3846:../uvc.c      **** 
3847:../uvc.c      **** static void
3848:../uvc.c      **** UVCHandleProcessingUnitRqts (
3849:../uvc.c      ****         void)
3850:../uvc.c      **** {
3851:../uvc.c      ****     uint8_t CtrlAdd;
3852:../uvc.c      **** #ifdef DbgInfo
3853:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3854:../uvc.c      **** #endif
3855:../uvc.c      ****     switch (wValue)
3856:../uvc.c      ****     {
3857:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3858:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3859:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3860:../uvc.c      ****     		break;
3861:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3862:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3863:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3864:../uvc.c      ****     		break;
3865:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3866:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3867:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3868:../uvc.c      **** 			break;
3869:../uvc.c      **** 
3870:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3871:../uvc.c      **** 
3872:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3873:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3874:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3875:../uvc.c      ****       		break;
3876:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3877:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3878:../uvc.c      ****      		ControlHandle(HueCtlID5);
3879:../uvc.c      ****      		break;
3880:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3881:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3882:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3883:../uvc.c      ****           		break;
3884:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3885:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3886:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3887:../uvc.c      ****           		break;
3888:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3889:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3890:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3891:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3892:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3893:../uvc.c      ****     		break;
3894:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3895:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3896:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3897:../uvc.c      ****     		break;
3898:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3899:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3900:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3901:../uvc.c      ****     		break;
3902:../uvc.c      **** 
3903:../uvc.c      ****         default:
3904:../uvc.c      ****             /*
3905:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3906:../uvc.c      ****              * other controls.
3907:../uvc.c      ****              */
3908:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3909:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3910:../uvc.c      ****             break;
3911:../uvc.c      ****     }
3912:../uvc.c      **** }
3913:../uvc.c      **** 
3914:../uvc.c      **** /*
3915:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3916:../uvc.c      ****  */
3917:../uvc.c      **** static void
3918:../uvc.c      **** UVCHandleCameraTerminalRqts (
3919:../uvc.c      ****         void)
3920:../uvc.c      **** {
3921:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3922:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3923:../uvc.c      ****     uint16_t readCount;
3924:../uvc.c      ****     uint16_t zoomVal;
3925:../uvc.c      ****     int32_t  panVal, tiltVal;
3926:../uvc.c      ****     CyBool_t sendData = CyFalse;
3927:../uvc.c      **** #endif
3928:../uvc.c      ****     uint8_t CtrlAdd;
3929:../uvc.c      **** 
3930:../uvc.c      ****     switch (wValue)
3931:../uvc.c      ****     {
3932:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3933:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3934:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3935:../uvc.c      ****     		break;
3936:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3937:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3938:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3939:../uvc.c      ****     		break;
3940:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3941:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3942:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3943:../uvc.c      **** 			break;
3944:../uvc.c      **** 
3945:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3946:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3947:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3948:../uvc.c      **** 			break;
3949:../uvc.c      **** 
3950:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3951:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3952:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3953:../uvc.c      ****       		break;
3954:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3955:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3956:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3957:../uvc.c      ****      		break;
3958:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3959:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3960:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3961:../uvc.c      ****           		break;
3962:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3963:../uvc.c      ****           		break;
3964:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3965:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3966:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3967:../uvc.c      ****      		break;
3968:../uvc.c      **** 
3969:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3970:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3971:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3972:../uvc.c      ****     		break;
3973:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3974:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3975:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3976:../uvc.c      ****     		break;
3977:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3978:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3979:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3980:../uvc.c      ****     		break;
3981:../uvc.c      **** 
3982:../uvc.c      ****         default:
3983:../uvc.c      ****             /*
3984:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3985:../uvc.c      ****              * other controls.
3986:../uvc.c      ****              */
3987:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3988:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3989:../uvc.c      ****             break;
3990:../uvc.c      ****     }
3991:../uvc.c      **** 
3992:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3993:../uvc.c      ****     switch (wValue)
3994:../uvc.c      ****     {
3995:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3996:../uvc.c      ****             switch (bRequest)
3997:../uvc.c      ****             {
3998:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3999:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
4000:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4001:../uvc.c      ****                     break;
4002:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
4003:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
4004:../uvc.c      ****                     sendData = CyTrue;
4005:../uvc.c      ****                     break;
4006:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
4007:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
4008:../uvc.c      ****                     sendData = CyTrue;
4009:../uvc.c      ****                     break;
4010:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
4011:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
4012:../uvc.c      ****                     sendData = CyTrue;
4013:../uvc.c      ****                     break;
4014:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
4015:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
4016:../uvc.c      ****                     sendData = CyTrue;
4017:../uvc.c      ****                     break;
4018:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
4019:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
4020:../uvc.c      ****                     sendData = CyTrue;
4021:../uvc.c      ****                     break;
4022:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4023:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4024:../uvc.c      ****                             glEp0Buffer, &readCount);
4025:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4026:../uvc.c      ****                     {
4027:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
4028:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
4029:../uvc.c      ****                     }
4030:../uvc.c      ****                     break;
4031:../uvc.c      ****                 default:
4032:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4033:../uvc.c      ****                     break;
4034:../uvc.c      ****             }
4035:../uvc.c      **** 
4036:../uvc.c      ****             if (sendData)
4037:../uvc.c      ****             {
4038:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
4039:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
4040:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
4041:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4042:../uvc.c      ****             }
4043:../uvc.c      ****             break;
4044:../uvc.c      **** 
4045:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
4046:../uvc.c      ****             switch (bRequest)
4047:../uvc.c      ****             {
4048:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4049:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
4050:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4051:../uvc.c      ****                     break;
4052:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4053:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
4054:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
4055:../uvc.c      ****                     sendData = CyTrue;
4056:../uvc.c      ****                     break;
4057:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4058:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
4059:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
4060:../uvc.c      ****                     sendData = CyTrue;
4061:../uvc.c      ****                     break;
4062:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4063:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
4064:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
4065:../uvc.c      ****                     sendData = CyTrue;
4066:../uvc.c      ****                     break;
4067:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
4068:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
4069:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
4070:../uvc.c      ****                     sendData = CyTrue;
4071:../uvc.c      ****                     break;
4072:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
4073:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
4074:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
4075:../uvc.c      ****                     sendData = CyTrue;
4076:../uvc.c      ****                     break;
4077:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4078:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4079:../uvc.c      ****                             glEp0Buffer, &readCount);
4080:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4081:../uvc.c      ****                     {
4082:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
4083:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
4084:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
4085:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
4086:../uvc.c      **** 
4087:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
4088:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
4089:../uvc.c      ****                     }
4090:../uvc.c      ****                     break;
4091:../uvc.c      ****                 default:
4092:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4093:../uvc.c      ****                     break;
4094:../uvc.c      ****             }
4095:../uvc.c      **** 
4096:../uvc.c      ****             if (sendData)
4097:../uvc.c      ****             {
4098:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
4099:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
4100:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
4101:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
4102:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
4103:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
4104:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
4105:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
4106:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
4107:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
4108:../uvc.c      ****             }
4109:../uvc.c      ****             break;
4110:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
4111:../uvc.c      ****         default:
4112:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
4113:../uvc.c      ****             break;
4114:../uvc.c      ****     }
4115:../uvc.c      **** #endif
4116:../uvc.c      **** }
4117:../uvc.c      **** 
4118:../uvc.c      **** /*
4119:../uvc.c      ****  * Handler for UVC Interface control requests.
4120:../uvc.c      ****  */
4121:../uvc.c      **** static void
4122:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
4123:../uvc.c      ****         void)
4124:../uvc.c      **** {
4125:../uvc.c      **** 
4126:../uvc.c      ****     switch (wValue)
4127:../uvc.c      ****     {
4128:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
4129:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4130:../uvc.c      ****     		break;
4131:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
4132:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
4133:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
4134:../uvc.c      ****     		break;
4135:../uvc.c      ****     	default:
4136:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
4137:../uvc.c      ****      		break;
4138:../uvc.c      ****     }
4139:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
4140:../uvc.c      **** 
4141:../uvc.c      **** }
4142:../uvc.c      **** 
4143:../uvc.c      **** /*
4144:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
4145:../uvc.c      ****  */
4146:../uvc.c      **** static void
4147:../uvc.c      **** UVCHandleExtensionUnitRqts (
4148:../uvc.c      ****         void)
4149:../uvc.c      **** {
4150:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
4151:../uvc.c      **** 
4152:../uvc.c      **** #ifdef DbgInfo
4153:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
4154:../uvc.c      **** #endif
4155:../uvc.c      ****     switch (wValue)
4156:../uvc.c      ****     {
4157:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
4158:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
4159:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
4160:../uvc.c      ****     		break;
4161:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
4162:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
4163:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
4164:../uvc.c      ****     		break;
4165:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
4166:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
4167:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
4168:../uvc.c      ****      		break;
4169:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
4170:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
4171:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
4172:../uvc.c      ****     		break;
4173:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
4174:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
4175:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
4176:../uvc.c      ****     		break;
4177:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
4178:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
4179:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
4180:../uvc.c      ****      		break;
4181:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
4182:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
4183:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
4184:../uvc.c      ****     		break;
4185:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
4186:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
4187:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
4188:../uvc.c      ****     		break;
4189:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
4190:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
4191:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
4192:../uvc.c      ****      		break;
4193:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
4194:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
4195:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
4196:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
4197:../uvc.c      ****     		}else/* no support for 1080p camera */
4198:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
4199:../uvc.c      ****     		break;
4200:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
4201:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
4202:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
4203:../uvc.c      ****     		break;
4204:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
4205:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
4206:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
4207:../uvc.c      ****     		break;
4208:../uvc.c      **** 
4209:../uvc.c      ****     		//ExtCtlShutlevCtlID11
4210:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
4211:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
4212:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
4213:../uvc.c      ****     		break;
4214:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
4215:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
4216:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
4217:../uvc.c      ****     		//break;
4218:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
4219:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
4220:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
4221:../uvc.c      ****     		break;
4222:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
4223:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
4224:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
4225:../uvc.c      ****     		break;
4226:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
4227:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
4228:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
4229:../uvc.c      ****     		break;
4230:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
4231:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
4232:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
4233:../uvc.c      ****     		break;
4234:../uvc.c      **** 		case CY_FX_EXT_CONTROL_19BLC_GRID:   //BLD gain CONTROL19
4235:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
4236:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
4237:../uvc.c      ****     		break;
4238:../uvc.c      **** 		case CY_FX_EXT_CONTROL_20EXP_HYSTER: //exposure hysteresis CONTROL20
4239:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExHysterCtlID7-EXUAOFFSET][0];
4240:../uvc.c      ****       		ControlHandle(Ext1ExHysterCtlID7);
4241:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
4242:../uvc.c      ****     		break;
4243:../uvc.c      **** 		case CY_FX_EXT_CONTROL_21EXP_CTRLSPD: //exposure control speed CONTROL21
4244:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1ExCtrlSpeedCtlID8-EXUAOFFSET][0];
4245:../uvc.c      ****       		ControlHandle(Ext1ExCtrlSpeedCtlID8);
4246:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
4247:../uvc.c      ****     		break;
4248:../uvc.c      **** 		case CY_FX_EXT_CONTROL_22ENHANCE_MODE: //edge enhancement mode CONTROL22
4249:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceModeCtlID9-EXUAOFFSET][0];
4250:../uvc.c      ****       		ControlHandle(Ext1EnhanceModeCtlID9);
4251:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
4252:../uvc.c      ****     		break;
4253:../uvc.c      **** 		case CY_FX_EXT_CONTROL_23ENHANCE_GAIN: //edge enhancement gain CONTROL23
4254:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceGainCtlID10-EXUAOFFSET][0];
4255:../uvc.c      ****       		ControlHandle(Ext1EnhanceGainCtlID10);
4256:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgegain command 0x%x 0x%x\r\n", wValue, bRequest);
4257:../uvc.c      ****    		break;
4258:../uvc.c      **** 		case CY_FX_EXT_CONTROL_24ENHANCE_STED: //edge enhancement start/end CONTROL24
4259:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1EnhanceStarEndCtlID11-EXUAOFFSET][0];
4260:../uvc.c      ****       		ControlHandle(Ext1EnhanceStarEndCtlID11);
4261:../uvc.c      **** 			CyU3PDebugPrint (4, "The edge start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4262:../uvc.c      ****     		break;
4263:../uvc.c      **** 		case CY_FX_EXT_CONTROL_262DNR_STED: //2D noise reduction start/end CONTROL26
4264:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext12DNRGainStarEndCtlID13-EXUAOFFSET][0];
4265:../uvc.c      ****       		ControlHandle(Ext12DNRGainStarEndCtlID13);
4266:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
4267:../uvc.c      ****     		break;
4268:../uvc.c      **** 		case CY_FX_EXT_CONTROL_27GAMMA_MODE: //gamma correction CONTROL27
4269:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4270:../uvc.c      ****       		ControlHandle(Ext1GammaCorCtlID14);
4271:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
4272:../uvc.c      ****     		break;
4273:../uvc.c      **** 		case CY_FX_EXT_CONTROL_28AGC_MAX: //AGC Maximum limitation CONTROL28
4274:../uvc.c      ****     		//CtrlAdd = ExUCtrlParArry[Ext1GammaCorCtlID14-EXUAOFFSET][0];
4275:../uvc.c      ****       		ControlHandle(Ext1AGCMaxLimetCtlID15);
4276:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
4277:../uvc.c      ****     		break;
4278:../uvc.c      **** 
4279:../uvc.c      ****    	default:
4280:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
4281:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
4282:../uvc.c      ****     		break;
4283:../uvc.c      ****     }
4284:../uvc.c      **** 
4285:../uvc.c      **** }
4286:../uvc.c      **** 
4287:../uvc.c      **** /*
4288:../uvc.c      ****  * Handler for the video streaming control requests.
4289:../uvc.c      ****  */
4290:../uvc.c      **** static void
4291:../uvc.c      **** UVCHandleVideoStreamingRqts (
4292:../uvc.c      ****         void)
4293:../uvc.c      **** {
  67              		.loc 1 4293 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
4294:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
4295:../uvc.c      ****     uint16_t readCount;
4296:../uvc.c      **** 
4297:../uvc.c      ****     switch (wValue)
  72              		.loc 1 4297 0
  73 003c A8369FE5 		ldr	r3, .L133
4293:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 4293 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 4297 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
4293:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 4293 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 4297 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
4298:../uvc.c      ****     {
4299:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
4300:../uvc.c      ****             switch (bRequest)
4301:../uvc.c      ****             {
4302:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4303:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4304:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4305:../uvc.c      ****                     break;
4306:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4307:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4308:../uvc.c      ****                     glEp0Buffer[1] = 0;
4309:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4310:../uvc.c      ****                     break;
4311:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4312:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
4313:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
4314:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4315:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4316:../uvc.c      ****                     {
4317:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
4318:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
4319:../uvc.c      **** 
4320:../uvc.c      ****                     }
4321:../uvc.c      ****                     else
4322:../uvc.c      ****                     {
4323:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4324:../uvc.c      ****                     }
4325:../uvc.c      ****                     break;
4326:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4327:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4328:../uvc.c      ****                             glCommitCtrl, &readCount);
4329:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4330:../uvc.c      ****                     {
4331:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4332:../uvc.c      ****                         {
4333:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
4334:../uvc.c      ****                                active data structure. */
4335:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
4336:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
4337:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
4338:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
4339:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
4340:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
4341:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
4342:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
4343:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
4344:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
4345:../uvc.c      **** #if 0
4346:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
4347:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
4348:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
4349:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
4350:../uvc.c      **** #endif
4351:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
4352:../uvc.c      ****                        }
4353:../uvc.c      ****                     }
4354:../uvc.c      ****                     break;
4355:../uvc.c      ****                 default:
4356:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4357:../uvc.c      ****                     break;
4358:../uvc.c      ****             }
4359:../uvc.c      ****             break;
4360:../uvc.c      **** 
4361:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
4362:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 4362 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
4363:../uvc.c      ****             {
4364:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
4365:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
4366:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4367:../uvc.c      ****                     break;
4368:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
4369:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4370:../uvc.c      ****                     glEp0Buffer[1] = 0;
4371:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4372:../uvc.c      ****                     break;
4373:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
4374:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
4375:../uvc.c      ****                     {
4376:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
4377:../uvc.c      ****                     }
4378:../uvc.c      ****                     else
4379:../uvc.c      ****                     {
4380:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
4381:../uvc.c      ****                     }
4382:../uvc.c      ****                     break;
4383:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
4384:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
4385:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
4386:../uvc.c      ****                        */
4387:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4388:../uvc.c      ****                             glCommitCtrl, &readCount);
4389:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
4390:../uvc.c      ****                     {
4391:../uvc.c      ****                         switch (glCommitCtrl[3])
4392:../uvc.c      ****                          {
4393:../uvc.c      ****                          	case 1: //1944
4394:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR_WR/
4395:../uvc.c      ****                          		CyU3PThreadSleep(500);
4396:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4397:../uvc.c      ****                          		break;
4398:../uvc.c      ****                          	case 2: //1080
4399:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR_WR/
4400:../uvc.c      ****                          		CyU3PThreadSleep(500);
4401:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
4402:../uvc.c      ****                          		break;
4403:../uvc.c      ****                          	case 3: //720
4404:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, I2C_
4405:../uvc.c      ****                          		CyU3PThreadSleep(500);
4406:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4407:../uvc.c      ****                          		break;
4408:../uvc.c      ****                          	case 4: //VGA
4409:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x32:0xB2)&0xFC)|ROIMode, I2C_
4410:../uvc.c      ****                          		CyU3PThreadSleep(500);
4411:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
4412:../uvc.c      ****                          		break;
4413:../uvc.c      ****                          	default:
4414:../uvc.c      ****                          		break;
4415:../uvc.c      ****                          }
4416:../uvc.c      ****                         setRes = glCommitCtrl[3];
4417:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
4418:../uvc.c      **** 
4419:../uvc.c      **** #if 0
4420:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
4421:../uvc.c      ****                         {
4422:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
4423:../uvc.c      ****                         }
4424:../uvc.c      ****                         else
4425:../uvc.c      ****                         {
4426:../uvc.c      ****                             SensorScaling_VGA ();
4427:../uvc.c      ****                         }
4428:../uvc.c      **** #endif
4429:../uvc.c      ****                         /* We can start streaming video now. */
4430:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
4431:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
4432:../uvc.c      ****                         {
4433:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
4434:../uvc.c      ****                         }
4435:../uvc.c      ****                     }
4436:../uvc.c      ****                     break;
4437:../uvc.c      **** 
4438:../uvc.c      ****                 default:
4439:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4440:../uvc.c      ****                     break;
4441:../uvc.c      ****             }
4442:../uvc.c      ****             break;
4443:../uvc.c      **** 
4444:../uvc.c      **** /* still image streaming handler */
4445:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
4446:../uvc.c      ****                 switch (bRequest)
4447:../uvc.c      ****                 {
4448:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4449:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
4450:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4451:../uvc.c      ****                         break;
4452:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4453:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4454:../uvc.c      ****                         glEp0Buffer[1] = 0;
4455:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4456:../uvc.c      ****                         break;
4457:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4458:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
4459:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
4460:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
4461:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4462:../uvc.c      ****                         {
4463:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4464:../uvc.c      ****                         }
4465:../uvc.c      ****                         else
4466:../uvc.c      ****                         {
4467:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4468:../uvc.c      ****                         }
4469:../uvc.c      ****                         break;
4470:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4471:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4472:../uvc.c      ****                                 glCommitCtrl, &readCount);
4473:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4474:../uvc.c      ****                         {
4475:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4476:../uvc.c      ****                             {
4477:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4478:../uvc.c      ****                                    active data structure. */
4479:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4480:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4481:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
4482:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
4483:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
4484:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
4485:../uvc.c      ****                             }
4486:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4487:../uvc.c      ****                         }
4488:../uvc.c      ****                         break;
4489:../uvc.c      ****                     default:
4490:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4491:../uvc.c      ****                         break;
4492:../uvc.c      ****                 }
4493:../uvc.c      ****                 break;
4494:../uvc.c      **** 
4495:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4496:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 4496 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
4497:../uvc.c      ****                 {
4498:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4499:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4500:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4501:../uvc.c      ****                         break;
4502:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4503:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4504:../uvc.c      ****                         glEp0Buffer[1] = 0;
4505:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4506:../uvc.c      ****                         break;
4507:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4508:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4509:../uvc.c      ****                         {
4510:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4511:../uvc.c      ****                         }
4512:../uvc.c      ****                         else
4513:../uvc.c      ****                         {
4514:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4515:../uvc.c      ****                         }
4516:../uvc.c      ****                         break;
4517:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4518:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4519:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4520:../uvc.c      ****                            */
4521:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4522:../uvc.c      ****                                 glCommitCtrl, &readCount);
4523:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4524:../uvc.c      ****                         {
4525:../uvc.c      ****     #if 0
4526:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4527:../uvc.c      ****                             {
4528:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4529:../uvc.c      ****                             }
4530:../uvc.c      ****                             else
4531:../uvc.c      ****                             {
4532:../uvc.c      ****                                 SensorScaling_VGA ();
4533:../uvc.c      ****                             }
4534:../uvc.c      ****                             /* We can start streaming video now. */
4535:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4536:../uvc.c      **** 
4537:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4538:../uvc.c      ****                             {
4539:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4540:../uvc.c      ****                             }
4541:../uvc.c      **** 	#endif
4542:../uvc.c      ****                            switch (glCommitCtrl[1])
4543:../uvc.c      ****                              {
4544:../uvc.c      ****                              	case 4: //1944
4545:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x22:0xA2, I2C_DSPBOARD_ADDR
4546:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4547:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4548:../uvc.c      ****                              		break;
4549:../uvc.c      ****                              	case 3: //1080
4550:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x12:0x92, I2C_DSPBOARD_ADDR
4551:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4552:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4553:../uvc.c      ****                              		break;
4554:../uvc.c      ****                              	case 2: //720
4555:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x02:0x82)&0xFC)|ROIMode, 
4556:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4557:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4558:../uvc.c      ****                              		break;
4559:../uvc.c      ****                             	case 1: //VGA
4560:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4561:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4562:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4563:../uvc.c      ****                              		break;
4564:../uvc.c      ****                               	default:
4565:../uvc.c      ****                              		break;
4566:../uvc.c      ****                              }
4567:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4568:../uvc.c      **** 
4569:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4570:../uvc.c      **** 
4571:../uvc.c      ****                         }
4572:../uvc.c      ****                         break;
4573:../uvc.c      **** 
4574:../uvc.c      ****                     default:
4575:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4576:../uvc.c      ****                         break;
4577:../uvc.c      ****                 }
4578:../uvc.c      ****                 break;
4579:../uvc.c      **** 
4580:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4581:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4582:../uvc.c      ****             	switch (bRequest)
4583:../uvc.c      ****                 {
4584:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4585:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 4585 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
4586:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 4586 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
4587:../uvc.c      ****                         break;
4588:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4589:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4590:../uvc.c      ****                         glEp0Buffer[1] = 0;
4591:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4592:../uvc.c      ****                         break;
4593:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4594:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4595:../uvc.c      ****                         {
4596:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4597:../uvc.c      ****                         }
4598:../uvc.c      ****                         else
4599:../uvc.c      ****                         {
4600:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4601:../uvc.c      ****                         }
4602:../uvc.c      ****                         break;
4603:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4604:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4605:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4606:../uvc.c      ****                            */
4607:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4608:../uvc.c      ****                                 glCommitCtrl, &readCount);
4609:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4610:../uvc.c      ****                         {
4611:../uvc.c      ****     #if 1
4612:../uvc.c      ****                             /* We can start still streaming video now. */
4613:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4614:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4615:../uvc.c      ****                             {
4616:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4617:../uvc.c      ****                             }
4618:../uvc.c      ****     #endif
4619:../uvc.c      ****                             else{
4620:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4621:../uvc.c      ****                             //stillcont = 0;
4622:../uvc.c      ****                             }
4623:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4624:../uvc.c      ****                         }else{
4625:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4626:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4627:../uvc.c      ****                         }
4628:../uvc.c      ****                         break;
4629:../uvc.c      **** 
4630:../uvc.c      ****                     default:
4631:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4632:../uvc.c      ****                         break;
4633:../uvc.c      ****                 }
4634:../uvc.c      ****                 break;
4635:../uvc.c      **** 
4636:../uvc.c      ****         default:
4637:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4638:../uvc.c      ****             break;
4639:../uvc.c      ****     }
4640:../uvc.c      **** }
 117              		.loc 1 4640 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
4297:../uvc.c      ****     {
 122              		.loc 1 4297 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
4582:../uvc.c      ****                 {
 127              		.loc 1 4582 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4637:../uvc.c      ****             break;
 138              		.loc 1 4637 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4640 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
4300:../uvc.c      ****             {
 151              		.loc 1 4300 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
4446:../uvc.c      ****                 {
 161              		.loc 1 4446 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
4503:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 4503 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
4590:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 4590 0
 170 0124 0020A0E3 		mov	r2, #0
4591:../uvc.c      ****                         break;
 171              		.loc 1 4591 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
4589:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 4589 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
4590:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 4590 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
4591:../uvc.c      ****                         break;
 178              		.loc 1 4591 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4640 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
4496:../uvc.c      ****                 {
 186              		.loc 1 4496 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
4521:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 4521 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
4523:../uvc.c      ****                         {
 201              		.loc 1 4523 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
4542:../uvc.c      ****                              {
 204              		.loc 1 4542 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
4446:../uvc.c      ****                 {
 217              		.loc 1 4446 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
4461:../uvc.c      ****                         {
 227              		.loc 1 4461 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
4463:../uvc.c      ****                         }
 229              		.loc 1 4463 0
 230 01c4 0B00A0E3 		mov	r0, #11
4461:../uvc.c      ****                         {
 231              		.loc 1 4461 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
4463:../uvc.c      ****                         }
 234              		.loc 1 4463 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
4467:../uvc.c      ****                         }
 236              		.loc 1 4467 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
4446:../uvc.c      ****                 {
 242              		.loc 1 4446 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
4471:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 4471 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
4473:../uvc.c      ****                         {
 254              		.loc 1 4473 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
4475:../uvc.c      ****                             {
 257              		.loc 1 4475 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
4479:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 4479 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
4480:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 4480 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
4479:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 4479 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
4480:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 4480 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
4486:../uvc.c      ****                         }
 272              		.loc 1 4486 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
4300:../uvc.c      ****             {
 283              		.loc 1 4300 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
4327:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 4327 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
4329:../uvc.c      ****                     {
 295              		.loc 1 4329 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
4331:../uvc.c      ****                         {
 298              		.loc 1 4331 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
4335:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 4335 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
4336:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 4336 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
4337:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 4337 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
4338:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 4338 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
4339:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 4339 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
4340:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 4340 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
4335:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 4335 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
4336:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 4336 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
4337:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 4337 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
4338:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 4338 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
4339:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 4339 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
4340:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 4340 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
4374:../uvc.c      ****                     {
 331              		.loc 1 4374 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
4323:../uvc.c      ****                     }
 337              		.loc 1 4323 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
4582:../uvc.c      ****                 {
 344              		.loc 1 4582 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4607:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4607 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4609:../uvc.c      ****                         {
 354              		.loc 1 4609 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4613:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4613 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4614:../uvc.c      ****                             {
 363              		.loc 1 4614 0
 364 030c 002050E2 		subs	r2, r0, #0
4620:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4620 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4614:../uvc.c      ****                             {
 368              		.loc 1 4614 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4623:../uvc.c      ****                         }else{
 372              		.loc 1 4623 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
4362:../uvc.c      ****             {
 384              		.loc 1 4362 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
4387:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 4387 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
4389:../uvc.c      ****                     {
 394              		.loc 1 4389 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
4391:../uvc.c      ****                          {
 397              		.loc 1 4391 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
4376:../uvc.c      ****                     }
 410              		.loc 1 4376 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
4409:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 4409 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 B020A003 		moveq	r2, #176
 424 03a8 3020A013 		movne	r2, #48
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
4410:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 4410 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
4411:../uvc.c      ****                          		break;
 436              		.loc 1 4411 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 B010A003 		moveq	r1, #176
 442 03dc 3010A013 		movne	r1, #48
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
4417:../uvc.c      **** 
 451              		.loc 1 4417 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
4416:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 4416 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
4417:../uvc.c      **** 
 457              		.loc 1 4417 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
4430:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 4430 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
4431:../uvc.c      ****                         {
 466              		.loc 1 4431 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
4433:../uvc.c      ****                         }
 469              		.loc 1 4433 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
4550:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 4550 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c 9220A003 		moveq	r2, #146
 483 0440 1220A013 		movne	r2, #18
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
4552:../uvc.c      ****                              		break;
 489              		.loc 1 4552 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 9220A003 		moveq	r2, #146
 495 0464 1220A013 		movne	r2, #18
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
4569:../uvc.c      **** 
 501              		.loc 1 4569 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
4567:../uvc.c      **** 
 506              		.loc 1 4567 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
4569:../uvc.c      **** 
 508              		.loc 1 4569 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
4555:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 4555 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 8020A003 		moveq	r2, #128
 521 04a8 0020A013 		movne	r2, #0
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
4557:../uvc.c      ****                              		break;
 529              		.loc 1 4557 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 8010A003 		moveq	r1, #128
 535 04d4 0010A013 		movne	r1, #0
 536              	.L118:
4562:../uvc.c      ****                              		break;
 537              		.loc 1 4562 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4563:../uvc.c      ****                               	default:
 544              		.loc 1 4563 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
4560:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 4560 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
4562:../uvc.c      ****                              		break;
 562              		.loc 1 4562 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
4404:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 4404 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 8020A003 		moveq	r2, #128
 578 054c 0020A013 		movne	r2, #0
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
4405:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 4405 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
4406:../uvc.c      ****                          		break;
 590              		.loc 1 4406 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c 8010A003 		moveq	r1, #128
 596 0580 0010A013 		movne	r1, #0
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
4399:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 4399 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 9220A003 		moveq	r2, #146
 605 0598 1220A013 		movne	r2, #18
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
4400:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 4400 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
4401:../uvc.c      ****                          		break;
 615              		.loc 1 4401 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 9220A003 		moveq	r2, #146
 621 05c4 1220A013 		movne	r2, #18
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4402:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 4402 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
4394:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 4394 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 A220A003 		moveq	r2, #162
 635 05e8 2220A013 		movne	r2, #34
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
4395:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 4395 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
4396:../uvc.c      ****                          		break;
 645              		.loc 1 4396 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 A220A003 		moveq	r2, #162
 651 0614 2220A013 		movne	r2, #34
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
4397:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 4397 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
4545:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 4545 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 A220A003 		moveq	r2, #162
 665 0638 2220A013 		movne	r2, #34
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
4547:../uvc.c      ****                              		break;
 671              		.loc 1 4547 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 A220A003 		moveq	r2, #162
 677 065c 2220A013 		movne	r2, #34
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
4548:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 4548 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
4589:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 4589 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
4315:../uvc.c      ****                     {
 691              		.loc 1 4315 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
4317:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 4317 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
4318:../uvc.c      **** 
 701              		.loc 1 4318 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4625:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4625 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4626:../uvc.c      ****                         }
 718              		.loc 1 4626 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4616:../uvc.c      ****                             }
 727              		.loc 1 4616 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
4391:../uvc.c      ****                          {
 736              		.loc 1 4391 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4641:../uvc.c      **** 
4642:../uvc.c      **** /*
4643:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4644:../uvc.c      ****  */
4645:../uvc.c      **** void
4646:../uvc.c      **** UVCAppEP0Thread_Entry (
4647:../uvc.c      ****         uint32_t input)
4648:../uvc.c      **** {
4649:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4650:../uvc.c      ****     uint32_t eventFlag;
4651:../uvc.c      **** 	CyBool_t value;
4652:../uvc.c      **** 	CyBool_t *valueptr = &value;
4653:../uvc.c      **** 
4654:../uvc.c      **** 
4655:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4656:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4657:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4658:../uvc.c      **** 
4659:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4660:../uvc.c      **** #endif
4661:../uvc.c      **** 
4662:../uvc.c      ****     /* for interrupt status test */
4663:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4664:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4665:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4666:../uvc.c      **** 
4667:../uvc.c      ****     for (;;)
4668:../uvc.c      ****     {
4669:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4670:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4671:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4672:../uvc.c      ****         {
4673:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4674:../uvc.c      ****             if (!isUsbConnected)
4675:../uvc.c      ****             {
4676:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4677:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4678:../uvc.c      ****                 {
4679:../uvc.c      ****                     isUsbConnected = CyTrue;
4680:../uvc.c      ****                 }
4681:../uvc.c      ****             }
4682:../uvc.c      **** //#ifdef DbgInfo
4683:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4684:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4685:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4686:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4687:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4688:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4689:../uvc.c      **** //#endif
4690:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4691:../uvc.c      ****             {
4692:../uvc.c      ****             	switch ((wIndex >> 8))
4693:../uvc.c      ****                 {
4694:../uvc.c      **** 
4695:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4696:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4697:../uvc.c      ****                         break;
4698:../uvc.c      **** 
4699:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4700:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4701:../uvc.c      ****                         break;
4702:../uvc.c      **** 
4703:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4704:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4705:../uvc.c      ****                         break;
4706:../uvc.c      **** 
4707:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4708:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4709:../uvc.c      ****                         break;
4710:../uvc.c      **** 
4711:../uvc.c      ****                     default:
4712:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4713:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4714:../uvc.c      ****                         break;
4715:../uvc.c      ****                 }
4716:../uvc.c      ****             }
4717:../uvc.c      **** 
4718:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4719:../uvc.c      ****             {
4720:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4721:../uvc.c      **** 
4722:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4723:../uvc.c      ****                 {
4724:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4725:../uvc.c      ****                 }
4726:../uvc.c      ****                 else
4727:../uvc.c      ****                 {
4728:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4729:../uvc.c      ****                 }
4730:../uvc.c      ****             }
4731:../uvc.c      **** 
4732:../uvc.c      ****             /* handle interrupt status event */
4733:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4734:../uvc.c      ****             {
4735:../uvc.c      **** 
4736:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4737:../uvc.c      ****             	/** preparing interrupt status data **/
4738:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4739:../uvc.c      **** 
4740:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4741:../uvc.c      **** 
4742:../uvc.c      **** #if 0 //for real button
4743:../uvc.c      **** 				if(value&&(!snapButFlag)){
4744:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4745:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4746:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4747:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4748:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4749:../uvc.c      **** 
4750:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4751:../uvc.c      **** 					interStabuf.size   = 1024;
4752:../uvc.c      **** 					interStabuf.status = 0;
4753:../uvc.c      **** 
4754:../uvc.c      **** 					interStabuf.count = 4;
4755:../uvc.c      **** 
4756:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4757:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4758:../uvc.c      **** 
4759:../uvc.c      **** 					/** send a interrupt status data **/
4760:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4761:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4762:../uvc.c      **** 					{
4763:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4764:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4765:../uvc.c      **** 					}
4766:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4767:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4768:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4769:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4770:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4771:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4772:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4773:../uvc.c      **** 
4774:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4775:../uvc.c      **** 					interStabuf.size   = 1024;
4776:../uvc.c      **** 					interStabuf.status = 0;
4777:../uvc.c      **** 
4778:../uvc.c      **** 					interStabuf.count = 4;
4779:../uvc.c      **** 
4780:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4781:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4782:../uvc.c      **** 
4783:../uvc.c      **** 					/** send a interrupt status data **/
4784:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4785:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4786:../uvc.c      **** 					{
4787:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4788:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4789:../uvc.c      **** 					}
4790:../uvc.c      **** 
4791:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4792:../uvc.c      **** 					stiflag = 0xFF;
4793:../uvc.c      **** 				}
4794:../uvc.c      **** #else			//for botton simulation
4795:../uvc.c      **** 				if(snapButFlag == 0x0f){
4796:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4797:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4798:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4799:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4800:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4801:../uvc.c      **** 
4802:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4803:../uvc.c      **** 					interStabuf.size   = 1024;
4804:../uvc.c      **** 					interStabuf.status = 0;
4805:../uvc.c      **** 
4806:../uvc.c      **** 					interStabuf.count = 4;
4807:../uvc.c      **** 
4808:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4809:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4810:../uvc.c      **** 
4811:../uvc.c      **** 					/** send a interrupt status data **/
4812:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4813:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4814:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4815:../uvc.c      **** 					{
4816:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4817:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4818:../uvc.c      **** 					}
4819:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4820:../uvc.c      **** 
4821:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4822:../uvc.c      **** 				}else if(!snapButFlag){
4823:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4824:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4825:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4826:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4827:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4828:../uvc.c      **** 
4829:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4830:../uvc.c      **** 					interStabuf.size   = 1024;
4831:../uvc.c      **** 					interStabuf.status = 0;
4832:../uvc.c      **** 
4833:../uvc.c      **** 					interStabuf.count = 4;
4834:../uvc.c      **** 
4835:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4836:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4837:../uvc.c      **** 
4838:../uvc.c      **** 					/** send a interrupt status data **/
4839:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4840:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4841:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4842:../uvc.c      **** 					{
4843:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4844:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4845:../uvc.c      **** 					}
4846:../uvc.c      **** 
4847:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4848:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4849:../uvc.c      **** 				}
4850:../uvc.c      **** #endif
4851:../uvc.c      **** 
4852:../uvc.c      ****             }
4853:../uvc.c      **** 
4854:../uvc.c      **** 
4855:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4856:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4857:../uvc.c      ****             {
4858:../uvc.c      ****                 /* Get the command buffer */
4859:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4860:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4861:../uvc.c      ****                 {
4862:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4863:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4864:../uvc.c      ****                 }
4865:../uvc.c      **** 
4866:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4867:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4868:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4869:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4870:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4871:../uvc.c      ****                  * register value high byte and register value low byte.
4872:../uvc.c      ****                  */
4873:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4874:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4875:../uvc.c      ****                 {
4876:../uvc.c      ****                     if (dmaInfo.count == 3)
4877:../uvc.c      ****                     {
4878:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4879:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4880:../uvc.c      ****                         dmaInfo.count = 3;
4881:../uvc.c      ****                     }
4882:../uvc.c      ****                     else if (dmaInfo.count == 4)
4883:../uvc.c      ****                     {
4884:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4885:../uvc.c      ****                         {
4886:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4887:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4888:../uvc.c      ****                         }
4889:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4890:../uvc.c      ****                     }
4891:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4892:../uvc.c      ****                 }
4893:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4894:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4895:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4896:../uvc.c      ****                  */
4897:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4898:../uvc.c      ****                 {
4899:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4900:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4901:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4902:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4903:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4904:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4905:../uvc.c      ****                         	break;
4906:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4907:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4908:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4909:../uvc.c      ****                         	break;*/
4910:../uvc.c      ****                     dmaInfo.count -= 2;
4911:../uvc.c      ****                 }
4912:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4913:../uvc.c      ****                 else
4914:../uvc.c      ****                 {
4915:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4916:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4917:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4918:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4919:../uvc.c      ****                 }
4920:../uvc.c      **** 
4921:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4922:../uvc.c      ****                 dmaInfo.size   = 1024;
4923:../uvc.c      ****                 dmaInfo.status = 0;
4924:../uvc.c      **** 
4925:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4926:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4927:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4928:../uvc.c      ****                 {
4929:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4930:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4931:../uvc.c      ****                 }
4932:../uvc.c      **** 
4933:../uvc.c      ****                 /* Wait until the response has gone out. */
4934:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4935:../uvc.c      **** 
4936:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4937:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4938:../uvc.c      ****                 {
4939:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4940:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4941:../uvc.c      ****                 }
4942:../uvc.c      ****             }
4943:../uvc.c      **** #endif
4944:../uvc.c      ****         }
4945:../uvc.c      ****         /* Allow other ready threads to run. */
4946:../uvc.c      ****         CyU3PThreadRelinquish ();
4947:../uvc.c      ****     }
4948:../uvc.c      **** }
4949:../uvc.c      **** 
4950:../uvc.c      **** /*
4951:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4952:../uvc.c      ****  * added 10/2013
4953:../uvc.c      ****  */
4954:../uvc.c      **** /*
4955:../uvc.c      **** static uint8_t timeDelay[64] = {
4956:../uvc.c      **** 
4957:../uvc.c      **** };
4958:../uvc.c      **** */
4959:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 4959 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
4960:../uvc.c      **** 
4961:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4962:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4963:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4964:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4965:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4966:../uvc.c      **** 	uint32_t flag = 0;
4967:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4968:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4969:../uvc.c      **** 	uint8_t i;
4970:../uvc.c      **** 	uint16_t delaytime;
4971:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4972:../uvc.c      **** 
4973:../uvc.c      **** #if 0 //for test the command queue
4974:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4975:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4976:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4977:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4978:../uvc.c      **** 		lcCmdDes += 1;
4979:../uvc.c      **** 	}
4980:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4981:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4982:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4983:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4984:../uvc.c      **** 		lcCmdDes += 1;
4985:../uvc.c      **** 	}
4986:../uvc.c      **** 
4987:../uvc.c      **** #endif
4988:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4989:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 4989 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
4959:../uvc.c      **** 
 786              		.loc 1 4959 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
4966:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 4966 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 4989 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
4966:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 4966 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 4989 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
4990:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 4990 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
4991:../uvc.c      **** 	CyU3PThreadSleep(50);
4992:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
4993:../uvc.c      **** 
4994:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 4994 0
 812 0774 00529FE5 		ldr	r5, .L161+8
4990:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 4990 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
4991:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 4991 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
4992:../uvc.c      **** 
 823              		.loc 1 4992 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 4994 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
4995:../uvc.c      ****         /* Allow other ready threads to run. */
4996:../uvc.c      **** 
4997:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 4997 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
4994:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 4994 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
4998:../uvc.c      **** 	}
4999:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 4999 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
5000:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
5001:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
5002:../uvc.c      **** 	//CyU3PThreadSleep(100);
5003:../uvc.c      **** 	//SetCurCmd();
5004:../uvc.c      **** 	/*********** the loop of the thread ***********/
5005:../uvc.c      **** 	for(;;){
5006:../uvc.c      **** 
5007:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 5007 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
5008:../uvc.c      **** /*  // for test GPIO output
5009:../uvc.c      **** 		if(trigger)
5010:../uvc.c      **** 		{
5011:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
5012:../uvc.c      **** 			{
5013:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
5014:../uvc.c      **** 			}
5015:../uvc.c      **** 
5016:../uvc.c      **** 		}else{
5017:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
5018:../uvc.c      **** 			{
5019:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
5020:../uvc.c      **** 			}
5021:../uvc.c      **** 
5022:../uvc.c      **** 		}
5023:../uvc.c      **** */
5024:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 5024 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
5025:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5026:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
5027:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
5028:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
5029:../uvc.c      **** 				i = 0;
5030:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 5030 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
5031:../uvc.c      **** 					i++;
5032:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
5033:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
5034:../uvc.c      **** 				}
5035:../uvc.c      **** #if 0
5036:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
5037:../uvc.c      **** 				i = lcStaDes->curNum;
5038:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5039:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5040:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
5041:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
5042:../uvc.c      **** 
5043:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
5044:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
5045:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
5046:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
5047:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5048:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
5049:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
5050:../uvc.c      **** #endif
5051:../uvc.c      **** 				//}
5052:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
5053:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
5054:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
5055:../uvc.c      **** 				/* setting delay */
5056:../uvc.c      **** 				delaytime = 300;
5057:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
5058:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
5059:../uvc.c      **** 			} //end of the if condition statment
5060:../uvc.c      **** #endif
5061:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 5061 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
5062:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
5063:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 5063 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
5064:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 5064 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
5065:../uvc.c      **** 
5066:../uvc.c      **** 				/*
5067:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5068:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5069:../uvc.c      **** 				*/
5070:../uvc.c      **** 
5071:../uvc.c      **** 				/* find a available command */
5072:../uvc.c      **** 				i = 0;
5073:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 5073 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 5073 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
5074:../uvc.c      **** 					i++;
5075:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 5075 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
5073:../uvc.c      **** 					i++;
 905              		.loc 1 5073 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
5076:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
5077:../uvc.c      **** 				}
5078:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
5079:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
5080:../uvc.c      **** 					i = lcCmdDes->curNum;
5081:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
5082:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
5083:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
5084:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
5085:../uvc.c      **** #if 1
5086:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 5086 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
5081:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 5081 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
5082:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 5082 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
5083:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 5083 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
5084:../uvc.c      **** #if 1
 927              		.loc 1 5084 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 5086 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
5087:../uvc.c      **** 						case 0x20:
5088:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
5089:../uvc.c      **** 							delaytime = 500;
5090:../uvc.c      **** 							break;
5091:../uvc.c      **** 						case 0x21:
5092:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
5093:../uvc.c      **** 							delaytime = 500;
5094:../uvc.c      **** 							break;
5095:../uvc.c      **** 						case 0x22:
5096:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
5097:../uvc.c      **** 							delaytime = 300;
5098:../uvc.c      **** 							break;
5099:../uvc.c      **** 						case 0x23:
5100:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 5100 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
5101:../uvc.c      **** 							delaytime = 300;
5102:../uvc.c      **** 							break;
 945              		.loc 1 5102 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
5103:../uvc.c      **** 						default:
5104:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
5105:../uvc.c      **** 							break;
5106:../uvc.c      **** 					}
5107:../uvc.c      **** #endif
5108:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
5109:../uvc.c      **** 					/** timer's ticket modify **/
5110:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
5111:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 5111 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
5112:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 5112 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
5113:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
5114:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
5115:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5116:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
5117:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
5118:../uvc.c      **** #endif
5119:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 5119 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
5120:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
5121:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
5122:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
5123:../uvc.c      **** 						}else{
5124:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
5125:../uvc.c      **** 						}
5126:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
5127:../uvc.c      **** 					}else{
5128:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 5128 0
 964 08d4 013083E2 		add	r3, r3, #1
5129:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 5129 0
 966 08d8 0F20A0E3 		mov	r2, #15
5128:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 5128 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 5129 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
5130:../uvc.c      **** 					}
5131:../uvc.c      **** 				}else{
5132:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
5133:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
5134:../uvc.c      **** 				}
5135:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 5135 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
5136:../uvc.c      **** 			}
5137:../uvc.c      **** /*
5138:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
5139:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
5140:../uvc.c      **** */
5141:../uvc.c      **** #ifdef USB_DEBUG_PRINT
5142:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
5143:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
5144:../uvc.c      **** #endif
5145:../uvc.c      **** 
5146:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
5147:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
5148:../uvc.c      **** #if 0
5149:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
5150:../uvc.c      **** 
5151:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
5152:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
5153:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
5154:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
5155:../uvc.c      **** 			    i = 0;
5156:../uvc.c      **** 				 switch(cmdCopyIdx)
5157:../uvc.c      **** 				 {
5158:../uvc.c      **** 					 case BrgtCtlID1:
5159:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
5160:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5161:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
5162:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5163:../uvc.c      **** 							 i++;
5164:../uvc.c      **** 						 }
5165:../uvc.c      **** 						 else{
5166:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5167:../uvc.c      **** 						 }
5168:../uvc.c      **** 
5169:../uvc.c      **** 						 CyU3PBusyWait(500);
5170:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
5171:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5172:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5173:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5174:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5175:../uvc.c      **** 						 }
5176:../uvc.c      **** 						 else{
5177:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5178:../uvc.c      **** 						 }
5179:../uvc.c      **** 						 break;
5180:../uvc.c      **** 					 case HueCtlID5:
5181:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
5182:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5183:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5184:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5185:../uvc.c      **** 						 }
5186:../uvc.c      **** 						 else{
5187:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5188:../uvc.c      **** 						 }
5189:../uvc.c      **** 						 break;
5190:../uvc.c      **** 					 case SaturCtlID6:
5191:../uvc.c      **** 					 case WBTLevCtlID10:
5192:../uvc.c      **** 					 default:
5193:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
5194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
5195:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
5196:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
5197:../uvc.c      **** 						 }
5198:../uvc.c      **** 						 else{
5199:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
5200:../uvc.c      **** 						 }
5201:../uvc.c      **** 						 break;
5202:../uvc.c      **** 				 }
5203:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
5204:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
5205:../uvc.c      **** 			}
5206:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
5207:../uvc.c      **** #endif
5208:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
5209:../uvc.c      **** 		/* Allow other ready threads to run. */
5210:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
5211:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 5211 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
5212:../uvc.c      **** 		}
 980              		.loc 1 5212 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
5092:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 5092 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
5094:../uvc.c      **** 						case 0x22:
 989              		.loc 1 5094 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
5088:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 5088 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
5090:../uvc.c      **** 						case 0x21:
 999              		.loc 1 5090 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
5132:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 5132 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
5133:../uvc.c      **** 				}
 1010              		.loc 1 5133 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
5121:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 5121 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
5120:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 5120 0
 1020 0934 0020A0E3 		mov	r2, #0
5121:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 5121 0
 1022 0938 230053E3 		cmp	r3, #35
5122:../uvc.c      **** 						}else{
 1023              		.loc 1 5122 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
5124:../uvc.c      **** 						}
 1026              		.loc 1 5124 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
5122:../uvc.c      **** 						}else{
 1028              		.loc 1 5122 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
5124:../uvc.c      **** 						}
 1030              		.loc 1 5124 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
5122:../uvc.c      **** 						}else{
 1032              		.loc 1 5122 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
5124:../uvc.c      **** 						}
 1034              		.loc 1 5124 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
5126:../uvc.c      **** 					}else{
 1036              		.loc 1 5126 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
5120:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 5120 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
5126:../uvc.c      **** 					}else{
 1040              		.loc 1 5126 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
5104:../uvc.c      **** 							break;
 1045              		.loc 1 5104 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
5105:../uvc.c      **** 					}
 1049              		.loc 1 5105 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2790:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2790 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2797:../uvc.c      ****     {
 1075              		.loc 1 2797 0
 1076 0994 080051E3 		cmp	r1, #8
2790:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2790 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2797:../uvc.c      ****     {
 1089              		.loc 1 2797 0
 1090 09a4 0B00000A 		beq	.L174
2849:../uvc.c      ****     {
 1091              		.loc 1 2849 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2851:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2851 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2852:../uvc.c      ****     }
 1096              		.loc 1 2852 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2851:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2851 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2852:../uvc.c      ****     }
 1102              		.loc 1 2852 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2851:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2851 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2854:../uvc.c      **** 
 1111              		.loc 1 2854 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2799:../uvc.c      ****             {
 1117              		.loc 1 2799 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2813:../uvc.c      ****                 fb++;
 1121              		.loc 1 2813 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2799:../uvc.c      ****             {
 1123              		.loc 1 2799 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
2537:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 2537 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2799:../uvc.c      ****             {
 1132              		.loc 1 2799 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
2537:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 2537 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
2538:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 2538 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
2539:../uvc.c      **** 
 1147              		.loc 1 2539 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
2544:../uvc.c      ****     }
 1151              		.loc 1 2544 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2820:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2820 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
2544:../uvc.c      ****     }
 1159              		.loc 1 2544 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2826:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2826 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2820:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2820 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2821:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2821 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2820:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2820 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2826:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2826 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2820:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2820 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2821:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2821 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
2538:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 2538 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2826:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2826 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2833:../uvc.c      ****             }
 1187              		.loc 1 2833 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2837 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2838 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2837 0
 1196 0a54 013082E2 		add	r3, r2, #1
2838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2838 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2837 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2838 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2837 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2838 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2837 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2838:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2838 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2837:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2837 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2841:../uvc.c      ****             {
 1215              		.loc 1 2841 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2843:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2843 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2844:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2844 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2843:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2843 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2844:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2844 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
2537:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 2537 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2814:../uvc.c      ****             }
 1246              		.loc 1 2814 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
2537:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 2537 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2813:../uvc.c      ****                 fb++;
 1255              		.loc 1 2813 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
2538:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 2538 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
2539:../uvc.c      **** 
 1266              		.loc 1 2539 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2814:../uvc.c      ****             }
 1272              		.loc 1 2814 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2827:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2827 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2828:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2828 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2829:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2829 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2828:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2828 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2829:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2829 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2830:../uvc.c      ****                 }
 1295              		.loc 1 2830 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2593:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2593 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2594:../uvc.c      ****     {
 1322              		.loc 1 2594 0
 1323 0b40 020050E3 		cmp	r0, #2
2593:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2593 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2594:../uvc.c      ****     {
 1336              		.loc 1 2594 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2630:../uvc.c      **** 
 1344              		.loc 1 2630 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2613:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2613 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2615:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2615 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2613:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2613 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2614:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2614 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2615:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2615 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2577:../uvc.c      **** 	{
 1372              		.loc 1 2577 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2615:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2615 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2616:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2616 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2617:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2617 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2577:../uvc.c      **** 	{
 1388              		.loc 1 2577 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2580:../uvc.c      **** 
 1395              		.loc 1 2580 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2583:../uvc.c      **** 	}
 1401              		.loc 1 2583 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2597:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2597 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2599:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2599 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2598:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2598 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2599:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2599 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2577:../uvc.c      **** 	{
 1433              		.loc 1 2577 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2599:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2599 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2600:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2600 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2577:../uvc.c      **** 	{
 1447              		.loc 1 2577 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2580:../uvc.c      **** 
 1454              		.loc 1 2580 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2583:../uvc.c      **** 	}
 1460              		.loc 1 2583 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2605:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2605 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2607:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2607 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2605:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2605 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2606:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2606 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2607:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2607 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2577:../uvc.c      **** 	{
 1493              		.loc 1 2577 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2607:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2607 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2608:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2608 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2577:../uvc.c      **** 	{
 1507              		.loc 1 2577 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2580:../uvc.c      **** 
 1514              		.loc 1 2580 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2583:../uvc.c      **** 	}
 1520              		.loc 1 2583 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2638:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2638 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2647:../uvc.c      **** 
 1560              		.loc 1 2647 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2644:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2644 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2646:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2646 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2643:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2643 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2645:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2645 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2646:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2646 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2643:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2643 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2644:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2644 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2646:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2646 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2647:../uvc.c      **** 
 1579              		.loc 1 2647 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2645:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2645 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2650:../uvc.c      ****     {
 1584              		.loc 1 2650 0
 1585 0d00 020054E3 		cmp	r4, #2
2638:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2638 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2644:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2644 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2646:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2646 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2647:../uvc.c      **** 
 1594              		.loc 1 2647 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2643:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2643 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2645:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2645 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2650:../uvc.c      ****     {
 1600              		.loc 1 2650 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2639:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2639 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2777:../uvc.c      **** 
 1612              		.loc 1 2777 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2650:../uvc.c      ****     {
 1618              		.loc 1 2650 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2690:../uvc.c      ****             {
 1621              		.loc 1 2690 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2694:../uvc.c      ****                 {
 1624              		.loc 1 2694 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2694:../uvc.c      ****                 {
 1627              		.loc 1 2694 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2699:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2699 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2697:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2697 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2698:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2698 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2702:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2702 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2699:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2699 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2700:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2700 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2702:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2702 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2703:../uvc.c      **** 
 1652              		.loc 1 2703 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2706:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2706 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2707:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2707 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2708:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2708 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2709:../uvc.c      **** 
 1669              		.loc 1 2709 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2712:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2712 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2715:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2715 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2577:../uvc.c      **** 	{
 1684              		.loc 1 2577 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2717:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2717 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2577:../uvc.c      **** 	{
 1696              		.loc 1 2577 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2580:../uvc.c      **** 
 1703              		.loc 1 2580 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2583:../uvc.c      **** 	}
 1709              		.loc 1 2583 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2655:../uvc.c      ****             {
 1722              		.loc 1 2655 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2673:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2673 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2675:../uvc.c      ****                         {
 1736              		.loc 1 2675 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2659:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2659 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2777:../uvc.c      **** 
 1744              		.loc 1 2777 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2725:../uvc.c      ****             {
 1750              		.loc 1 2725 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2727:../uvc.c      ****                 {
 1753              		.loc 1 2727 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2733:../uvc.c      ****                     {
 1756              		.loc 1 2733 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2765:../uvc.c      ****                     }
 1762              		.loc 1 2765 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2764:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2764 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2660:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2660 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2662:../uvc.c      ****                         {
 1777              		.loc 1 2662 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2664:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2664 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2665:../uvc.c      ****                         }
 1786              		.loc 1 2665 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2678:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2678 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2679:../uvc.c      ****                         }
 1801              		.loc 1 2679 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2672:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2672 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2735:../uvc.c      **** 
 1812              		.loc 1 2735 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2738:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2738 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2739:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2739 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2743:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2743 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2739:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2739 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2740:../uvc.c      **** 
 1829              		.loc 1 2740 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2743:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2743 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2744:../uvc.c      **** 
 1834              		.loc 1 2744 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2747:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2747 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2748:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2748 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2749:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2749 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2750:../uvc.c      **** 
 1851              		.loc 1 2750 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2753:../uvc.c      **** 
 1855              		.loc 1 2753 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2757:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2757 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2577:../uvc.c      **** 	{
 1866              		.loc 1 2577 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2759:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2759 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2577:../uvc.c      **** 	{
 1878              		.loc 1 2577 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2580:../uvc.c      **** 
 1885              		.loc 1 2580 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2583:../uvc.c      **** 	}
 1891              		.loc 1 2583 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
1205:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 1205 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 1208 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
1205:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 1205 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 1213 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
1208:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 1208 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
1209:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 1209 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
1210:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 1210 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
1213:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 1213 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
1216:../uvc.c      **** 	{
 1980              		.loc 1 1216 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
1226:../uvc.c      **** 	{
 1985              		.loc 1 1226 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
1251:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 1251 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
1270:../uvc.c      **** 
 1993              		.loc 1 1270 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 1253 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 1258 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 1258 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
1263:../uvc.c      **** 			}
 2018              		.loc 1 1263 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
1270:../uvc.c      **** 
 2025              		.loc 1 1270 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 1242 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
1228:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 1228 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 1242 0
 2041 10b0 011081E3 		orr	r1, r1, #1
1228:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 1228 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
1242:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 1242 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 1243 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
1244:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 1244 0
 2051 10c4 020056E3 		cmp	r6, #2
1243:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 1243 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
1245:../uvc.c      **** 				}
 2054              		.loc 1 1245 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
1228:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 1228 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
1245:../uvc.c      **** 				}
 2058              		.loc 1 1245 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
1247:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 1247 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
1270:../uvc.c      **** 
 2063              		.loc 1 1270 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
1216:../uvc.c      **** 	{
 2069              		.loc 1 1216 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
1218:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 1218 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
1219:../uvc.c      **** 			{
 2081              		.loc 1 1219 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
1223:../uvc.c      **** 
 2083              		.loc 1 1223 0
 2084 1114 0400A0E3 		mov	r0, #4
1219:../uvc.c      **** 			{
 2085              		.loc 1 1219 0
 2086 1118 000051E3 		cmp	r1, #0
1221:../uvc.c      **** 			}
 2087              		.loc 1 1221 0
 2088 111c 80208203 		orreq	r2, r2, #128
1223:../uvc.c      **** 
 2089              		.loc 1 1223 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
1221:../uvc.c      **** 			}
 2092              		.loc 1 1221 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
1223:../uvc.c      **** 
 2094              		.loc 1 1223 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
1253:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 1253 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
1255:../uvc.c      **** 			}
 2103              		.loc 1 1255 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
1254:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 1254 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
1258:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 1258 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
1259:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 1259 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
1260:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 1260 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
1261:../uvc.c      **** 				}
 2142              		.loc 1 1261 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 1276 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
1276:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 1276 0
 2180 11d8 0040A0E1 		mov	r4, r0
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 1279 0
 2182 11dc 0060A0E3 		mov	r6, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 1278 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 1279 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 1280 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
1281:../uvc.c      **** }
 2213              		.loc 1 1281 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
1282:../uvc.c      **** 
 2215              		.loc 1 1282 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
1281:../uvc.c      **** }
 2220              		.loc 1 1281 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 1286 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
1291:../uvc.c      **** 	case 1:
 2236              		.loc 1 1291 0
 2237 1248 013040E2 		sub	r3, r0, #1
1286:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 1286 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
1291:../uvc.c      **** 	case 1:
 2249              		.loc 1 1291 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
1313:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 1313 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
1315:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 1315 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
1316:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 1316 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
1315:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 1315 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
1316:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 1316 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
1318:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 1318 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 1321 0
 2298 12d8 0150A0E3 		mov	r5, #1
1322:../uvc.c      **** 		break;
 2299              		.loc 1 1322 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
1321:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 1321 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
1322:../uvc.c      **** 		break;
 2305              		.loc 1 1322 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
1331:../uvc.c      **** 
 2310              		.loc 1 1331 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
1297:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 1297 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
1299:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 1299 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
1300:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 1300 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
1299:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 1299 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
1300:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 1300 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
1327:../uvc.c      **** 		break;
 2345              		.loc 1 1327 0
 2346 133c 0140A0E3 		mov	r4, #1
1326:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 1326 0
 2348 1340 0030A0E3 		mov	r3, #0
1331:../uvc.c      **** 
 2349              		.loc 1 1331 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
1326:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 1326 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
1331:../uvc.c      **** 
 2355              		.loc 1 1331 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 1333 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 24
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 1341 0
 2399 137c B87F9FE5 		ldr	r7, .L463
1340:../uvc.c      ****     	RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1;//ExUCtrlParArry[locCtrlID][0];
 2400              		.loc 1 1340 0
 2401 1380 0F0050E3 		cmp	r0, #15
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 2402              		.loc 1 1341 0
 2403 1384 003187E0 		add	r3, r7, r0, asl #2
 2404 1388 20301385 		ldrhi	r3, [r3, #-32]
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2405              		.loc 1 1348 0
 2406 138c 20319395 		ldrls	r3, [r3, #288]
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2407              		.loc 1 1333 0
 2408 1390 2CD04DE2 		sub	sp, sp, #44
 2409              	.LCFI18:
 2410              		.cfi_def_cfa_offset 80
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2411              		.loc 1 1348 0
 2412 1394 00A0D3E5 		ldrb	r10, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2413              		.loc 1 1349 0
 2414 1398 01C0D3E5 		ldrb	ip, [r3, #1]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2415              		.loc 1 1350 0
 2416 139c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2417              		.loc 1 1351 0
 2418 13a0 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 2419              		.loc 1 1359 0
 2420 13a4 943F9FE5 		ldr	r3, .L463+4
1333:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2421              		.loc 1 1333 0
 2422 13a8 0050A0E1 		mov	r5, r0
1359:../uvc.c      ****     /*
 2423              		.loc 1 1359 0
 2424 13ac 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 2425              		.loc 1 1348 0
 2426 13b0 FFA00AE2 		and	r10, r10, #255
 2427              	.LVL269:
1367:../uvc.c      **** 		 {
 2428              		.loc 1 1367 0
 2429 13b4 830056E3 		cmp	r6, #131
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 2430              		.loc 1 1349 0
 2431 13b8 FFB00CE2 		and	fp, ip, #255
 2432              	.LVL270:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 2433              		.loc 1 1350 0
 2434 13bc FF9009E2 		and	r9, r9, #255
 2435              	.LVL271:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 2436              		.loc 1 1351 0
 2437 13c0 FF8008E2 		and	r8, r8, #255
 2438              	.LVL272:
1367:../uvc.c      **** 		 {
 2439              		.loc 1 1367 0
 2440 13c4 A300000A 		beq	.L275
 2441 13c8 1500009A 		bls	.L445
 2442 13cc 850056E3 		cmp	r6, #133
 2443 13d0 9400000A 		beq	.L280
 2444 13d4 AE00003A 		bcc	.L281
 2445 13d8 860056E3 		cmp	r6, #134
 2446 13dc 5900000A 		beq	.L282
 2447 13e0 870056E3 		cmp	r6, #135
 2448 13e4 8600001A 		bne	.L274
1755:../uvc.c      **** 		 		 if(Len == 2){
 2449              		.loc 1 1755 0
 2450 13e8 0F0050E3 		cmp	r0, #15
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2451              		.loc 1 1757 0
 2452 13ec 005187E0 		add	r5, r7, r0, asl #2
1755:../uvc.c      **** 		 		 if(Len == 2){
 2453              		.loc 1 1755 0
 2454 13f0 B500009A 		bls	.L340
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2455              		.loc 1 1756 0
 2456 13f4 020058E3 		cmp	r8, #2
 2457 13f8 0201000A 		beq	.L446
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2458              		.loc 1 1762 0
 2459 13fc 202015E5 		ldr	r2, [r5, #-32]
 2460 1400 3C4F9FE5 		ldr	r4, .L463+8
 2461 1404 0B10D2E5 		ldrb	r1, [r2, #11]	@ zero_extendqisi2
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2462              		.loc 1 1763 0
 2463 1408 0030A0E3 		mov	r3, #0
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2464              		.loc 1 1762 0
 2465 140c 2810C4E5 		strb	r1, [r4, #40]
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2466              		.loc 1 1763 0
 2467 1410 2930C4E5 		strb	r3, [r4, #41]
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2468              		.loc 1 1764 0
 2469 1414 0C20D2E5 		ldrb	r2, [r2, #12]	@ zero_extendqisi2
1765:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2470              		.loc 1 1765 0
 2471 1418 2B30C4E5 		strb	r3, [r4, #43]
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2472              		.loc 1 1764 0
 2473 141c 2A20C4E5 		strb	r2, [r4, #42]
 2474 1420 D90000EA 		b	.L343
 2475              	.L445:
1367:../uvc.c      **** 		 {
 2476              		.loc 1 1367 0
 2477 1424 810056E3 		cmp	r6, #129
 2478 1428 6100000A 		beq	.L277
 2479 142c 3600008A 		bhi	.L278
 2480 1430 010056E3 		cmp	r6, #1
 2481 1434 7200001A 		bne	.L274
1791:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2482              		.loc 1 1791 0
 2483 1438 044F9FE5 		ldr	r4, .L463+8
 2484 143c 26208DE2 		add	r2, sp, #38
 2485 1440 2000A0E3 		mov	r0, #32
 2486              	.LVL273:
 2487 1444 281084E2 		add	r1, r4, #40
 2488 1448 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2489              	.LVL274:
1793:../uvc.c      **** 			   {
 2490              		.loc 1 1793 0
 2491 144c 002050E2 		subs	r2, r0, #0
 2492 1450 7903001A 		bne	.L345
1795:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 2493              		.loc 1 1795 0
 2494 1454 020058E3 		cmp	r8, #2
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2495              		.loc 1 1796 0
 2496 1458 2800D405 		ldreqb	r0, [r4, #40]	@ zero_extendqisi2
 2497              	.LVL275:
1797:../uvc.c      **** 				 }else{
 2498              		.loc 1 1797 0
 2499 145c 2910D405 		ldreqb	r1, [r4, #41]	@ zero_extendqisi2
1799:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2500              		.loc 1 1799 0
 2501 1460 2820D415 		ldrneb	r2, [r4, #40]	@ zero_extendqisi2
 2502              	.LVL276:
1800:../uvc.c      **** 				 }
 2503              		.loc 1 1800 0
 2504 1464 2A30D415 		ldrneb	r3, [r4, #42]	@ zero_extendqisi2
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 2505              		.loc 1 1796 0
 2506 1468 18008D05 		streq	r0, [sp, #24]
 2507              	.LVL277:
1797:../uvc.c      **** 				 }else{
 2508              		.loc 1 1797 0
 2509 146c 1C108D05 		streq	r1, [sp, #28]
 2510              	.LVL278:
1799:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 2511              		.loc 1 1799 0
 2512 1470 18208D15 		strne	r2, [sp, #24]
 2513              	.LVL279:
1800:../uvc.c      **** 				 }
 2514              		.loc 1 1800 0
 2515 1474 1C308D15 		strne	r3, [sp, #28]
 2516              	.LVL280:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 2517              		.loc 1 1803 0
 2518 1478 00B08DE5 		str	fp, [sp]
 2519 147c 04908DE5 		str	r9, [sp, #4]
 2520 1480 08808DE5 		str	r8, [sp, #8]
 2521 1484 0400A0E3 		mov	r0, #4
 2522 1488 B81E9FE5 		ldr	r1, .L463+12
 2523 148c 0520A0E1 		mov	r2, r5
 2524 1490 0A30A0E1 		mov	r3, r10
 2525 1494 FEFFFFEB 		bl	CyU3PDebugPrint
 2526              	.LVL281:
1805:../uvc.c      **** 					 switch(CtrlID)
 2527              		.loc 1 1805 0
 2528 1498 0F0055E3 		cmp	r5, #15
 2529 149c C200009A 		bls	.L348
1806:../uvc.c      **** 					 {
 2530              		.loc 1 1806 0
 2531 14a0 103045E2 		sub	r3, r5, #16
 2532 14a4 160053E3 		cmp	r3, #22
 2533 14a8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2534 14ac 5B0300EA 		b	.L349
 2535              	.L351:
 2536 14b0 D0200000 		.word	.L350
 2537 14b4 20220000 		.word	.L349
 2538 14b8 20220000 		.word	.L349
 2539 14bc 20220000 		.word	.L349
 2540 14c0 20220000 		.word	.L349
 2541 14c4 20220000 		.word	.L349
 2542 14c8 20220000 		.word	.L349
 2543 14cc 20220000 		.word	.L349
 2544 14d0 20220000 		.word	.L349
 2545 14d4 30200000 		.word	.L352
 2546 14d8 20220000 		.word	.L349
 2547 14dc A01F0000 		.word	.L353
 2548 14e0 C0210000 		.word	.L354
 2549 14e4 20220000 		.word	.L349
 2550 14e8 20220000 		.word	.L349
 2551 14ec 90210000 		.word	.L355
 2552 14f0 20220000 		.word	.L349
 2553 14f4 20220000 		.word	.L349
 2554 14f8 20220000 		.word	.L349
 2555 14fc 20220000 		.word	.L349
 2556 1500 141F0000 		.word	.L356
 2557 1504 20220000 		.word	.L349
 2558 1508 9C1E0000 		.word	.L357
 2559              	.LVL282:
 2560              	.L278:
1646:../uvc.c      **** 		 		 if(Len == 2){
 2561              		.loc 1 1646 0
 2562 150c 0F0050E3 		cmp	r0, #15
1648:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2563              		.loc 1 1648 0
 2564 1510 005187E0 		add	r5, r7, r0, asl #2
1646:../uvc.c      **** 		 		 if(Len == 2){
 2565              		.loc 1 1646 0
 2566 1514 8700009A 		bls	.L326
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2567              		.loc 1 1647 0
 2568 1518 020058E3 		cmp	r8, #2
 2569 151c B100000A 		beq	.L447
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2570              		.loc 1 1653 0
 2571 1520 202015E5 		ldr	r2, [r5, #-32]
 2572 1524 184E9FE5 		ldr	r4, .L463+8
 2573 1528 0310D2E5 		ldrb	r1, [r2, #3]	@ zero_extendqisi2
1654:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2574              		.loc 1 1654 0
 2575 152c 0030A0E3 		mov	r3, #0
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2576              		.loc 1 1653 0
 2577 1530 2810C4E5 		strb	r1, [r4, #40]
1654:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2578              		.loc 1 1654 0
 2579 1534 2930C4E5 		strb	r3, [r4, #41]
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2580              		.loc 1 1655 0
 2581 1538 0420D2E5 		ldrb	r2, [r2, #4]	@ zero_extendqisi2
1656:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2582              		.loc 1 1656 0
 2583 153c 2B30C4E5 		strb	r3, [r4, #43]
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2584              		.loc 1 1655 0
 2585 1540 2A20C4E5 		strb	r2, [r4, #42]
 2586 1544 900000EA 		b	.L343
 2587              	.L282:
 2588              	.LVL283:
1736:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCInfoLo;//ExUCtrlParArry[locCtrlID][9];//ext_co
 2589              		.loc 1 1736 0
 2590 1548 0F0050E3 		cmp	r0, #15
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2591              		.loc 1 1737 0
 2592 154c 005187E0 		add	r5, r7, r0, asl #2
 2593 1550 20301585 		ldrhi	r3, [r5, #-32]
1743:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2594              		.loc 1 1743 0
 2595 1554 20319595 		ldrls	r3, [r5, #288]
 2596 1558 E44D9FE5 		ldr	r4, .L463+8
 2597 155c 0920D3E5 		ldrb	r2, [r3, #9]	@ zero_extendqisi2
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 2598              		.loc 1 1749 0
 2599 1560 0100A0E3 		mov	r0, #1
 2600              	.LVL284:
1744:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2601              		.loc 1 1744 0
 2602 1564 0030A0E3 		mov	r3, #0
1743:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 2603              		.loc 1 1743 0
 2604 1568 2820C4E5 		strb	r2, [r4, #40]
1744:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2605              		.loc 1 1744 0
 2606 156c 2930C4E5 		strb	r3, [r4, #41]
1745:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2607              		.loc 1 1745 0
 2608 1570 2A30C4E5 		strb	r3, [r4, #42]
1746:../uvc.c      **** 		 	 }
 2609              		.loc 1 1746 0
 2610 1574 2B30C4E5 		strb	r3, [r4, #43]
 2611              	.LVL285:
 2612              	.L439:
1672:../uvc.c      **** 		 	 if(Len == 2){
 2613              		.loc 1 1672 0
 2614 1578 CC1D9FE5 		ldr	r1, .L463+16
 2615 157c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2616              	.LVL286:
 2617 1580 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2618              	.LVL287:
 2619 1584 2970D4E5 		ldrb	r7, [r4, #41]	@ zero_extendqisi2
 2620 1588 0090A0E3 		mov	r9, #0
 2621              	.LVL288:
 2622 158c 0950A0E1 		mov	r5, r9
 2623              	.LVL289:
 2624              	.L284:
2213:../uvc.c      **** }
 2625              		.loc 1 2213 0
 2626 1590 20048DE8 		stmia	sp, {r5, r10}
 2627 1594 B41D9FE5 		ldr	r1, .L463+20
 2628 1598 08708DE5 		str	r7, [sp, #8]
 2629 159c 0620A0E1 		mov	r2, r6
 2630 15a0 0930A0E1 		mov	r3, r9
 2631 15a4 0400A0E3 		mov	r0, #4
 2632 15a8 FEFFFFEB 		bl	CyU3PDebugPrint
 2633              	.LVL290:
2214:../uvc.c      **** /************** CT control requests handler *************************/
 2634              		.loc 1 2214 0
 2635 15ac 2CD08DE2 		add	sp, sp, #44
 2636              		@ sp needed
 2637 15b0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2638              	.LVL291:
 2639              	.L277:
1378:../uvc.c      **** 				 switch(CtrlID)
 2640              		.loc 1 1378 0
 2641 15b4 0F0050E3 		cmp	r0, #15
 2642 15b8 4E00009A 		bls	.L285
1379:../uvc.c      **** 				 {
 2643              		.loc 1 1379 0
 2644 15bc 193040E2 		sub	r3, r0, #25
 2645 15c0 0D0053E3 		cmp	r3, #13
 2646 15c4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2647 15c8 1D0200EA 		b	.L286
 2648              	.L288:
 2649 15cc F8190000 		.word	.L287
 2650 15d0 441E0000 		.word	.L286
 2651 15d4 441E0000 		.word	.L286
 2652 15d8 541A0000 		.word	.L289
 2653 15dc 441E0000 		.word	.L286
 2654 15e0 441E0000 		.word	.L286
 2655 15e4 AC190000 		.word	.L290
 2656 15e8 441E0000 		.word	.L286
 2657 15ec 441E0000 		.word	.L286
 2658 15f0 441E0000 		.word	.L286
 2659 15f4 441E0000 		.word	.L286
 2660 15f8 441E0000 		.word	.L286
 2661 15fc 441E0000 		.word	.L286
 2662 1600 18190000 		.word	.L291
 2663              	.L274:
2210:../uvc.c      **** 			  break;
 2664              		.loc 1 2210 0
 2665 1604 0000A0E3 		mov	r0, #0
 2666              	.LVL292:
 2667 1608 0020A0E1 		mov	r2, r0
 2668 160c 0110A0E3 		mov	r1, #1
2211:../uvc.c      **** 		 }
 2669              		.loc 1 2211 0
 2670 1610 FF70A0E3 		mov	r7, #255
 2671 1614 0090A0E3 		mov	r9, #0
 2672              	.LVL293:
2210:../uvc.c      **** 			  break;
 2673              		.loc 1 2210 0
 2674 1618 FEFFFFEB 		bl	CyU3PUsbStall
 2675              	.LVL294:
2211:../uvc.c      **** 		 }
 2676              		.loc 1 2211 0
 2677 161c 07A0A0E1 		mov	r10, r7
 2678              	.LVL295:
 2679 1620 0950A0E1 		mov	r5, r9
 2680 1624 D9FFFFEA 		b	.L284
 2681              	.LVL296:
 2682              	.L280:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2683              		.loc 1 1371 0
 2684 1628 144D9FE5 		ldr	r4, .L463+8
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2685              		.loc 1 1372 0
 2686 162c 0030A0E3 		mov	r3, #0
 2687 1630 0390A0E1 		mov	r9, r3
 2688              	.LVL297:
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2689              		.loc 1 1373 0
 2690 1634 281084E2 		add	r1, r4, #40
 2691 1638 0200A0E3 		mov	r0, #2
 2692              	.LVL298:
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2693              		.loc 1 1371 0
 2694 163c 2880C4E5 		strb	r8, [r4, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2695              		.loc 1 1372 0
 2696 1640 2930C4E5 		strb	r3, [r4, #41]
 2697 1644 0950A0E1 		mov	r5, r9
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2698              		.loc 1 1373 0
 2699 1648 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2700              	.LVL299:
1375:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2701              		.loc 1 1375 0
 2702 164c FF70A0E3 		mov	r7, #255
 2703 1650 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2704              	.LVL300:
 2705 1654 CDFFFFEA 		b	.L284
 2706              	.LVL301:
 2707              	.L275:
1682:../uvc.c      **** 		 		 if(Len == 2){
 2708              		.loc 1 1682 0
 2709 1658 0F0050E3 		cmp	r0, #15
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2710              		.loc 1 1684 0
 2711 165c 005187E0 		add	r5, r7, r0, asl #2
1682:../uvc.c      **** 		 		 if(Len == 2){
 2712              		.loc 1 1682 0
 2713 1660 3F00009A 		bls	.L331
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2714              		.loc 1 1683 0
 2715 1664 020058E3 		cmp	r8, #2
 2716 1668 7200000A 		beq	.L448
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2717              		.loc 1 1689 0
 2718 166c 202015E5 		ldr	r2, [r5, #-32]
 2719 1670 CC4C9FE5 		ldr	r4, .L463+8
 2720 1674 0510D2E5 		ldrb	r1, [r2, #5]	@ zero_extendqisi2
1690:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2721              		.loc 1 1690 0
 2722 1678 0030A0E3 		mov	r3, #0
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2723              		.loc 1 1689 0
 2724 167c 2810C4E5 		strb	r1, [r4, #40]
1690:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2725              		.loc 1 1690 0
 2726 1680 2930C4E5 		strb	r3, [r4, #41]
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2727              		.loc 1 1691 0
 2728 1684 0620D2E5 		ldrb	r2, [r2, #6]	@ zero_extendqisi2
1692:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2729              		.loc 1 1692 0
 2730 1688 2B30C4E5 		strb	r3, [r4, #43]
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2731              		.loc 1 1691 0
 2732 168c 2A20C4E5 		strb	r2, [r4, #42]
 2733 1690 3D0000EA 		b	.L343
 2734              	.L281:
1718:../uvc.c      **** 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCResLo;//ExUCtrlParArry[locCtrlID][7];//ext_con
 2735              		.loc 1 1718 0
 2736 1694 0F0050E3 		cmp	r0, #15
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2737              		.loc 1 1719 0
 2738 1698 005187E0 		add	r5, r7, r0, asl #2
 2739 169c 20201585 		ldrhi	r2, [r5, #-32]
1725:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2740              		.loc 1 1725 0
 2741 16a0 20219595 		ldrls	r2, [r5, #288]
 2742 16a4 984C9FE5 		ldr	r4, .L463+8
 2743 16a8 0710D2E5 		ldrb	r1, [r2, #7]	@ zero_extendqisi2
1727:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2744              		.loc 1 1727 0
 2745 16ac 0030A0E3 		mov	r3, #0
1725:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 2746              		.loc 1 1725 0
 2747 16b0 2810C4E5 		strb	r1, [r4, #40]
1726:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2748              		.loc 1 1726 0
 2749 16b4 0820D2E5 		ldrb	r2, [r2, #8]	@ zero_extendqisi2
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2750              		.loc 1 1730 0
 2751 16b8 0800A0E1 		mov	r0, r8
 2752              	.LVL302:
1727:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 2753              		.loc 1 1727 0
 2754 16bc 2A30C4E5 		strb	r3, [r4, #42]
1726:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 2755              		.loc 1 1726 0
 2756 16c0 2920C4E5 		strb	r2, [r4, #41]
1728:../uvc.c      **** 		 	 }
 2757              		.loc 1 1728 0
 2758 16c4 2B30C4E5 		strb	r3, [r4, #43]
 2759 16c8 AAFFFFEA 		b	.L439
 2760              	.LVL303:
 2761              	.L340:
1769:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2762              		.loc 1 1769 0
 2763 16cc 020058E3 		cmp	r8, #2
1770:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2764              		.loc 1 1770 0
 2765 16d0 203195E5 		ldr	r3, [r5, #288]
 2766 16d4 684C9FE5 		ldr	r4, .L463+8
1769:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 2767              		.loc 1 1769 0
 2768 16d8 5100000A 		beq	.L449
1774:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2769              		.loc 1 1774 0
 2770 16dc 0B10D3E5 		ldrb	r1, [r3, #11]	@ zero_extendqisi2
1777:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2771              		.loc 1 1777 0
 2772 16e0 0020A0E3 		mov	r2, #0
1774:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2773              		.loc 1 1774 0
 2774 16e4 2810C4E5 		strb	r1, [r4, #40]
1776:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2775              		.loc 1 1776 0
 2776 16e8 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
1777:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2777              		.loc 1 1777 0
 2778 16ec 2B20C4E5 		strb	r2, [r4, #43]
1776:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2779              		.loc 1 1776 0
 2780 16f0 2930C4E5 		strb	r3, [r4, #41]
 2781 16f4 240000EA 		b	.L343
 2782              	.L285:
1506:../uvc.c      **** 				 {
 2783              		.loc 1 1506 0
 2784 16f8 013040E2 		sub	r3, r0, #1
1599:../uvc.c      **** 			 	 			 if(Len == 2)
 2785              		.loc 1 1599 0
 2786 16fc 404C9FE5 		ldr	r4, .L463+8
1506:../uvc.c      **** 				 {
 2787              		.loc 1 1506 0
 2788 1700 0A0053E3 		cmp	r3, #10
 2789 1704 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2790 1708 C10100EA 		b	.L306
 2791              	.L308:
 2792 170c 78190000 		.word	.L307
 2793 1710 141E0000 		.word	.L306
 2794 1714 141E0000 		.word	.L306
 2795 1718 4C190000 		.word	.L309
 2796 171c E0180000 		.word	.L310
 2797 1720 141E0000 		.word	.L306
 2798 1724 141E0000 		.word	.L306
 2799 1728 141E0000 		.word	.L306
 2800 172c 141E0000 		.word	.L306
 2801 1730 141E0000 		.word	.L306
 2802 1734 7C180000 		.word	.L311
 2803              	.L326:
1660:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2804              		.loc 1 1660 0
 2805 1738 020058E3 		cmp	r8, #2
1661:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2806              		.loc 1 1661 0
 2807 173c 203195E5 		ldr	r3, [r5, #288]
 2808 1740 FC4B9FE5 		ldr	r4, .L463+8
1660:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 2809              		.loc 1 1660 0
 2810 1744 4700000A 		beq	.L450
1665:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2811              		.loc 1 1665 0
 2812 1748 0310D3E5 		ldrb	r1, [r3, #3]	@ zero_extendqisi2
1668:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2813              		.loc 1 1668 0
 2814 174c 0020A0E3 		mov	r2, #0
1665:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2815              		.loc 1 1665 0
 2816 1750 2810C4E5 		strb	r1, [r4, #40]
1667:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2817              		.loc 1 1667 0
 2818 1754 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
1668:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2819              		.loc 1 1668 0
 2820 1758 2B20C4E5 		strb	r2, [r4, #43]
1667:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2821              		.loc 1 1667 0
 2822 175c 2930C4E5 		strb	r3, [r4, #41]
 2823 1760 090000EA 		b	.L343
 2824              	.L331:
1696:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2825              		.loc 1 1696 0
 2826 1764 020058E3 		cmp	r8, #2
1697:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2827              		.loc 1 1697 0
 2828 1768 203195E5 		ldr	r3, [r5, #288]
 2829 176c D04B9FE5 		ldr	r4, .L463+8
1696:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 2830              		.loc 1 1696 0
 2831 1770 3700000A 		beq	.L451
1701:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2832              		.loc 1 1701 0
 2833 1774 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
1704:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2834              		.loc 1 1704 0
 2835 1778 0020A0E3 		mov	r2, #0
1701:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2836              		.loc 1 1701 0
 2837 177c 2810C4E5 		strb	r1, [r4, #40]
1703:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2838              		.loc 1 1703 0
 2839 1780 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
1704:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2840              		.loc 1 1704 0
 2841 1784 2B20C4E5 		strb	r2, [r4, #43]
1703:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2842              		.loc 1 1703 0
 2843 1788 2930C4E5 		strb	r3, [r4, #41]
 2844              	.L343:
1781:../uvc.c      **** 		 	 if(Len == 2){
 2845              		.loc 1 1781 0
 2846 178c 0800A0E1 		mov	r0, r8
 2847              	.LVL304:
 2848 1790 B41B9FE5 		ldr	r1, .L463+16
 2849 1794 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2850              	.LVL305:
 2851 1798 0090A0E3 		mov	r9, #0
 2852              	.LVL306:
 2853 179c 0950A0E1 		mov	r5, r9
 2854 17a0 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 2855              	.LVL307:
 2856 17a4 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 2857 17a8 78FFFFEA 		b	.L284
 2858              	.LVL308:
 2859              	.L348:
2014:../uvc.c      **** 					 {
 2860              		.loc 1 2014 0
 2861 17ac 0B0055E3 		cmp	r5, #11
 2862 17b0 05F19F97 		ldrls	pc, [pc, r5, asl #2]
 2863 17b4 860200EA 		b	.L377
 2864              	.L379:
 2865 17b8 B01D0000 		.word	.L378
 2866 17bc 481D0000 		.word	.L380
 2867 17c0 D4210000 		.word	.L377
 2868 17c4 D4210000 		.word	.L377
 2869 17c8 E01C0000 		.word	.L381
 2870 17cc 8C1B0000 		.word	.L382
 2871 17d0 D4210000 		.word	.L377
 2872 17d4 FC1A0000 		.word	.L383
 2873 17d8 D4210000 		.word	.L377
 2874 17dc D4210000 		.word	.L377
 2875 17e0 D4210000 		.word	.L377
 2876 17e4 681A0000 		.word	.L384
 2877              	.LVL309:
 2878              	.L447:
1648:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2879              		.loc 1 1648 0
 2880 17e8 203015E5 		ldr	r3, [r5, #-32]
 2881 17ec 504B9FE5 		ldr	r4, .L463+8
 2882 17f0 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2883 17f4 2820C4E5 		strb	r2, [r4, #40]
1649:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2884              		.loc 1 1649 0
 2885 17f8 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2886 17fc 2930C4E5 		strb	r3, [r4, #41]
 2887              	.L328:
1672:../uvc.c      **** 		 	 if(Len == 2){
 2888              		.loc 1 1672 0
 2889 1800 0200A0E3 		mov	r0, #2
 2890              	.LVL310:
 2891 1804 5BFFFFEA 		b	.L439
 2892              	.LVL311:
 2893              	.L446:
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2894              		.loc 1 1757 0
 2895 1808 203015E5 		ldr	r3, [r5, #-32]
 2896 180c 304B9FE5 		ldr	r4, .L463+8
 2897 1810 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2898 1814 2820C4E5 		strb	r2, [r4, #40]
1758:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 2899              		.loc 1 1758 0
 2900 1818 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2901 181c 2930C4E5 		strb	r3, [r4, #41]
 2902 1820 F6FFFFEA 		b	.L328
 2903              	.L449:
1770:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 2904              		.loc 1 1770 0
 2905 1824 0B20D3E5 		ldrb	r2, [r3, #11]	@ zero_extendqisi2
 2906 1828 2820C4E5 		strb	r2, [r4, #40]
1771:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 2907              		.loc 1 1771 0
 2908 182c 0C30D3E5 		ldrb	r3, [r3, #12]	@ zero_extendqisi2
 2909 1830 2930C4E5 		strb	r3, [r4, #41]
 2910 1834 F1FFFFEA 		b	.L328
 2911              	.L448:
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2912              		.loc 1 1684 0
 2913 1838 203015E5 		ldr	r3, [r5, #-32]
 2914 183c 004B9FE5 		ldr	r4, .L463+8
 2915 1840 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2916 1844 2820C4E5 		strb	r2, [r4, #40]
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 2917              		.loc 1 1685 0
 2918 1848 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2919 184c 2930C4E5 		strb	r3, [r4, #41]
 2920 1850 EAFFFFEA 		b	.L328
 2921              	.L451:
1697:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 2922              		.loc 1 1697 0
 2923 1854 0520D3E5 		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 2924 1858 2820C4E5 		strb	r2, [r4, #40]
1698:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2925              		.loc 1 1698 0
 2926 185c 0630D3E5 		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 2927 1860 2930C4E5 		strb	r3, [r4, #41]
 2928 1864 E5FFFFEA 		b	.L328
 2929              	.L450:
1661:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 2930              		.loc 1 1661 0
 2931 1868 0320D3E5 		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 2932 186c 2820C4E5 		strb	r2, [r4, #40]
1662:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 2933              		.loc 1 1662 0
 2934 1870 0430D3E5 		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 2935 1874 2930C4E5 		strb	r3, [r4, #41]
 2936 1878 E0FFFFEA 		b	.L328
 2937              	.L311:
1576:../uvc.c      **** 							 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2938              		.loc 1 1576 0
 2939 187c AB30D4E5 		ldrb	r3, [r4, #171]	@ zero_extendqisi2
 2940 1880 000053E3 		cmp	r3, #0
 2941 1884 8A02000A 		beq	.L319
1577:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2942              		.loc 1 1577 0
 2943 1888 EC3A9FE5 		ldr	r3, .L463+64
 2944 188c 5CA5D3E5 		ldrb	r10, [r3, #1372]	@ zero_extendqisi2
 2945              	.LVL312:
1578:../uvc.c      **** 						 }else{
 2946              		.loc 1 1578 0
 2947 1890 5E75D3E5 		ldrb	r7, [r3, #1374]	@ zero_extendqisi2
1577:../uvc.c      **** 							 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2948              		.loc 1 1577 0
 2949 1894 28A0C4E5 		strb	r10, [r4, #40]
1578:../uvc.c      **** 						 }else{
 2950              		.loc 1 1578 0
 2951 1898 2A70C4E5 		strb	r7, [r4, #42]
 2952              	.LVL313:
 2953              	.L320:
1588:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 2954              		.loc 1 1588 0
 2955 189c 0030A0E3 		mov	r3, #0
 2956 18a0 0290A0E1 		mov	r9, r2
 2957              	.LVL314:
 2958 18a4 2930C4E5 		strb	r3, [r4, #41]
1589:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2959              		.loc 1 1589 0
 2960 18a8 2B30C4E5 		strb	r3, [r4, #43]
 2961              	.LVL315:
 2962              	.L292:
1639:../uvc.c      **** 
 2963              		.loc 1 1639 0
 2964 18ac 981A9FE5 		ldr	r1, .L463+16
 2965 18b0 0800A0E1 		mov	r0, r8
 2966 18b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2967              	.LVL316:
1642:../uvc.c      **** //#endif
 2968              		.loc 1 1642 0
 2969 18b8 2B00D4E5 		ldrb	r0, [r4, #43]	@ zero_extendqisi2
 2970 18bc 2C10D4E5 		ldrb	r1, [r4, #44]	@ zero_extendqisi2
 2971 18c0 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 2972 18c4 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 2973 18c8 03018DE8 		stmia	sp, {r0, r1, r8}
 2974 18cc 801A9FE5 		ldr	r1, .L463+24
 2975 18d0 0400A0E3 		mov	r0, #4
 2976 18d4 FEFFFFEB 		bl	CyU3PDebugPrint
 2977              	.LVL317:
 2978 18d8 18509DE5 		ldr	r5, [sp, #24]
1644:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 2979              		.loc 1 1644 0
 2980 18dc 2BFFFFEA 		b	.L284
 2981              	.LVL318:
 2982              	.L310:
1541:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; //CtrlParArry[CtrlID][13];
 2983              		.loc 1 1541 0
 2984 18e0 A530D4E5 		ldrb	r3, [r4, #165]	@ zero_extendqisi2
 2985 18e4 000053E3 		cmp	r3, #0
 2986 18e8 B802000A 		beq	.L314
1542:../uvc.c      **** 						 }else{
 2987              		.loc 1 1542 0
 2988 18ec 883A9FE5 		ldr	r3, .L463+64
 2989 18f0 4195D3E5 		ldrb	r9, [r3, #1345]	@ zero_extendqisi2
 2990              	.LVL319:
 2991 18f4 FF0009E2 		and	r0, r9, #255
 2992              	.LVL320:
 2993              	.L315:
1549:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 2994              		.loc 1 1549 0
 2995 18f8 80A040E2 		sub	r10, r0, #128
 2996              	.LVL321:
 2997 18fc FFA00AE2 		and	r10, r10, #255
1550:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 2998              		.loc 1 1550 0
 2999 1900 0030A0E3 		mov	r3, #0
1549:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3000              		.loc 1 1549 0
 3001 1904 28A0C4E5 		strb	r10, [r4, #40]
 3002 1908 0090A0E1 		mov	r9, r0
1550:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3003              		.loc 1 1550 0
 3004 190c 2930C4E5 		strb	r3, [r4, #41]
 3005              	.LVL322:
1552:../uvc.c      **** 					 case MFreqCtlID4:
 3006              		.loc 1 1552 0
 3007 1910 FF70A0E3 		mov	r7, #255
 3008 1914 E4FFFFEA 		b	.L292
 3009              	.LVL323:
 3010              	.L291:
1382:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo; //ExUCtrlParArry[CtrlID-0x20][13];/
 3011              		.loc 1 1382 0
 3012 1918 244A9FE5 		ldr	r4, .L463+8
 3013 191c C650D4E5 		ldrb	r5, [r4, #198]	@ zero_extendqisi2
 3014 1920 000055E3 		cmp	r5, #0
 3015 1924 7602000A 		beq	.L296
1383:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3016              		.loc 1 1383 0
 3017 1928 4C3A9FE5 		ldr	r3, .L463+64
 3018 192c 05A5D3E5 		ldrb	r10, [r3, #1285]	@ zero_extendqisi2
 3019              	.LVL324:
1384:../uvc.c      **** 						 }else{
 3020              		.loc 1 1384 0
 3021 1930 0675D3E5 		ldrb	r7, [r3, #1286]	@ zero_extendqisi2
1383:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3022              		.loc 1 1383 0
 3023 1934 FFA00AE2 		and	r10, r10, #255
1384:../uvc.c      **** 						 }else{
 3024              		.loc 1 1384 0
 3025 1938 FF7007E2 		and	r7, r7, #255
1383:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi; //ExUCtrlParArry[CtrlID-0x20][14];
 3026              		.loc 1 1383 0
 3027 193c 28A0C4E5 		strb	r10, [r4, #40]
1384:../uvc.c      **** 						 }else{
 3028              		.loc 1 1384 0
 3029 1940 2970C4E5 		strb	r7, [r4, #41]
 3030              	.LVL325:
 3031              	.L318:
 3032 1944 0290A0E1 		mov	r9, r2
 3033              	.LVL326:
1574:../uvc.c      **** 					 case WBTLevCtlID11:
 3034              		.loc 1 1574 0
 3035 1948 D7FFFFEA 		b	.L292
 3036              	.LVL327:
 3037              	.L309:
1555:../uvc.c      **** 
 3038              		.loc 1 1555 0
 3039 194c A430D4E5 		ldrb	r3, [r4, #164]	@ zero_extendqisi2
 3040 1950 000053E3 		cmp	r3, #0
 3041 1954 8B02000A 		beq	.L316
1557:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3042              		.loc 1 1557 0
 3043 1958 6C3094E5 		ldr	r3, [r4, #108]
1562:../uvc.c      **** 						 }else{
 3044              		.loc 1 1562 0
 3045 195c 0070A0E3 		mov	r7, #0
1557:../uvc.c      **** 								 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 3046              		.loc 1 1557 0
 3047 1960 000053E3 		cmp	r3, #0
 3048 1964 02A0A013 		movne	r10, #2
 3049              	.LVL328:
 3050 1968 01A0A003 		moveq	r10, #1
 3051 196c 28A0C4E5 		strb	r10, [r4, #40]
1562:../uvc.c      **** 						 }else{
 3052              		.loc 1 1562 0
 3053 1970 2970C4E5 		strb	r7, [r4, #41]
 3054 1974 F2FFFFEA 		b	.L318
 3055              	.LVL329:
 3056              	.L307:
1521:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
 3057              		.loc 1 1521 0
 3058 1978 A130D4E5 		ldrb	r3, [r4, #161]	@ zero_extendqisi2
 3059 197c 000053E3 		cmp	r3, #0
 3060 1980 9A02000A 		beq	.L312
1522:../uvc.c      **** 						 }else{
 3061              		.loc 1 1522 0
 3062 1984 F0399FE5 		ldr	r3, .L463+64
 3063 1988 2D05D3E5 		ldrb	r0, [r3, #1325]	@ zero_extendqisi2
 3064              	.LVL330:
 3065 198c FF0000E2 		and	r0, r0, #255
 3066              	.LVL331:
 3067              	.L313:
1537:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3068              		.loc 1 1537 0
 3069 1990 0030A0E3 		mov	r3, #0
 3070 1994 0090A0E1 		mov	r9, r0
 3071              	.LVL332:
1536:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 3072              		.loc 1 1536 0
 3073 1998 2800C4E5 		strb	r0, [r4, #40]
1539:../uvc.c      **** 					 case HueCtlID5:
 3074              		.loc 1 1539 0
 3075 199c 00A0A0E1 		mov	r10, r0
 3076              	.LVL333:
1537:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3077              		.loc 1 1537 0
 3078 19a0 2930C4E5 		strb	r3, [r4, #41]
 3079              	.LVL334:
1539:../uvc.c      **** 					 case HueCtlID5:
 3080              		.loc 1 1539 0
 3081 19a4 FF70A0E3 		mov	r7, #255
 3082 19a8 BFFFFFEA 		b	.L292
 3083              	.LVL335:
 3084              	.L290:
1435:../uvc.c      **** 				 			glEp0Buffer[idx] = I2CCMDArry[idx];
 3085              		.loc 1 1435 0 discriminator 1
 3086 19ac 000058E3 		cmp	r8, #0
 3087 19b0 0300000A 		beq	.L300
 3088 19b4 90099FE5 		ldr	r0, .L463+16
 3089              	.LVL336:
 3090 19b8 0820A0E1 		mov	r2, r8
 3091 19bc 6C1080E2 		add	r1, r0, #108
 3092 19c0 FEFFFFEB 		bl	memcpy
 3093              	.LVL337:
 3094              	.L300:
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3095              		.loc 1 1438 0
 3096 19c4 78499FE5 		ldr	r4, .L463+8
1445:../uvc.c      **** 				 		 {
 3097              		.loc 1 1445 0
 3098 19c8 9F30D4E5 		ldrb	r3, [r4, #159]	@ zero_extendqisi2
1438:../uvc.c      **** 				 		 sendData1 = glEp0Buffer[10];
 3099              		.loc 1 1438 0
 3100 19cc 31A0D4E5 		ldrb	r10, [r4, #49]	@ zero_extendqisi2
 3101              	.LVL338:
1445:../uvc.c      **** 				 		 {
 3102              		.loc 1 1445 0
 3103 19d0 FF0053E3 		cmp	r3, #255
1439:../uvc.c      **** 	#ifdef USB_DEBUG_PRINT
 3104              		.loc 1 1439 0
 3105 19d4 3270D4E5 		ldrb	r7, [r4, #50]	@ zero_extendqisi2
 3106              	.LVL339:
1445:../uvc.c      **** 				 		 {
 3107              		.loc 1 1445 0
 3108 19d8 2802000A 		beq	.L435
1447:../uvc.c      **** 				 		 }
 3109              		.loc 1 1447 0
 3110 19dc 0400A0E3 		mov	r0, #4
 3111 19e0 70199FE5 		ldr	r1, .L463+28
 3112 19e4 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 3113 19e8 9E30D4E5 		ldrb	r3, [r4, #158]	@ zero_extendqisi2
 3114 19ec FEFFFFEB 		bl	CyU3PDebugPrint
 3115              	.LVL340:
 3116 19f0 0090A0E3 		mov	r9, #0
 3117              	.LVL341:
 3118 19f4 ACFFFFEA 		b	.L292
 3119              	.LVL342:
 3120              	.L287:
1399:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3121              		.loc 1 1399 0
 3122 19f8 44499FE5 		ldr	r4, .L463+8
 3123 19fc B930D4E5 		ldrb	r3, [r4, #185]	@ zero_extendqisi2
 3124 1a00 000053E3 		cmp	r3, #0
 3125 1a04 8102000A 		beq	.L298
1400:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3126              		.loc 1 1400 0
 3127 1a08 6C399FE5 		ldr	r3, .L463+64
 3128 1a0c 19A5D3E5 		ldrb	r10, [r3, #1305]	@ zero_extendqisi2
 3129              	.LVL343:
1401:../uvc.c      **** 			 	 		 }else{
 3130              		.loc 1 1401 0
 3131 1a10 1A75D3E5 		ldrb	r7, [r3, #1306]	@ zero_extendqisi2
1400:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3132              		.loc 1 1400 0
 3133 1a14 FFA00AE2 		and	r10, r10, #255
1401:../uvc.c      **** 			 	 		 }else{
 3134              		.loc 1 1401 0
 3135 1a18 FF7007E2 		and	r7, r7, #255
1400:../uvc.c      **** 							 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3136              		.loc 1 1400 0
 3137 1a1c 28A0C4E5 		strb	r10, [r4, #40]
1401:../uvc.c      **** 			 	 		 }else{
 3138              		.loc 1 1401 0
 3139 1a20 2A70C4E5 		strb	r7, [r4, #42]
 3140              	.LVL344:
 3141              	.L299:
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3142              		.loc 1 1411 0
 3143 1a24 00C0A0E3 		mov	ip, #0
1415:../uvc.c      **** 						 break;
 3144              		.loc 1 1415 0
 3145 1a28 00708DE5 		str	r7, [sp]
 3146 1a2c 04C08DE5 		str	ip, [sp, #4]
 3147 1a30 0A20A0E1 		mov	r2, r10
 3148 1a34 0C30A0E1 		mov	r3, ip
 3149 1a38 1C199FE5 		ldr	r1, .L463+32
1411:../uvc.c      **** 						 glEp0Buffer[3] = 0;
 3150              		.loc 1 1411 0
 3151 1a3c 29C0C4E5 		strb	ip, [r4, #41]
1412:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 3152              		.loc 1 1412 0
 3153 1a40 2BC0C4E5 		strb	ip, [r4, #43]
 3154              	.LVL345:
1415:../uvc.c      **** 						 break;
 3155              		.loc 1 1415 0
 3156 1a44 0400A0E3 		mov	r0, #4
 3157 1a48 0C90A0E1 		mov	r9, ip
 3158              	.LVL346:
 3159 1a4c FEFFFFEB 		bl	CyU3PDebugPrint
 3160              	.LVL347:
1416:../uvc.c      **** 				 	 case ExtCamMCtlID12: //EXTCamMode
 3161              		.loc 1 1416 0
 3162 1a50 95FFFFEA 		b	.L292
 3163              	.LVL348:
 3164              	.L289:
1379:../uvc.c      **** 				 {
 3165              		.loc 1 1379 0
 3166 1a54 FF70A0E3 		mov	r7, #255
 3167 1a58 07A0A0E1 		mov	r10, r7
 3168              	.LVL349:
 3169 1a5c 0090A0E3 		mov	r9, #0
 3170              	.LVL350:
 3171 1a60 DC489FE5 		ldr	r4, .L463+8
 3172 1a64 90FFFFEA 		b	.L292
 3173              	.LVL351:
 3174              	.L384:
2120:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3175              		.loc 1 2120 0
 3176 1a68 14499FE5 		ldr	r4, .L463+72
 3177 1a6c 0010E0E3 		mvn	r1, #0
 3178 1a70 1C0094E5 		ldr	r0, [r4, #28]
 3179 1a74 FEFFFFEB 		bl	_txe_mutex_get
 3180              	.LVL352:
2121:../uvc.c      **** 							 dataIdx++;
 3181              		.loc 1 2121 0
 3182 1a78 18209DE5 		ldr	r2, [sp, #24]
 3183 1a7c 0030A0E3 		mov	r3, #0
 3184 1a80 00208DE5 		str	r2, [sp]
 3185 1a84 04308DE5 		str	r3, [sp, #4]
 3186 1a88 0A20A0E1 		mov	r2, r10
 3187 1a8c 0930A0E1 		mov	r3, r9
 3188 1a90 0B10A0E3 		mov	r1, #11
 3189 1a94 0400A0E1 		mov	r0, r4
 3190 1a98 FEFFFFEB 		bl	cmdSet
 3191              	.LVL353:
2123:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3192              		.loc 1 2123 0
 3193 1a9c 1C309DE5 		ldr	r3, [sp, #28]
 3194 1aa0 0180A0E3 		mov	r8, #1
 3195              	.LVL354:
 3196 1aa4 0B20A0E1 		mov	r2, fp
 3197 1aa8 0B10A0E3 		mov	r1, #11
 3198 1aac 00308DE5 		str	r3, [sp]
 3199 1ab0 0400A0E1 		mov	r0, r4
 3200 1ab4 0930A0E1 		mov	r3, r9
 3201 1ab8 04808DE5 		str	r8, [sp, #4]
 3202 1abc FEFFFFEB 		bl	cmdSet
 3203              	.LVL355:
2128:../uvc.c      **** 							 break;
 3204              		.loc 1 2128 0
 3205 1ac0 055187E0 		add	r5, r7, r5, asl #2
2124:../uvc.c      **** 
 3206              		.loc 1 2124 0
 3207 1ac4 1C0094E5 		ldr	r0, [r4, #28]
 3208 1ac8 FEFFFFEB 		bl	_txe_mutex_put
 3209              	.LVL356:
2128:../uvc.c      **** 							 break;
 3210              		.loc 1 2128 0
 3211 1acc 202195E5 		ldr	r2, [r5, #288]
2126:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3212              		.loc 1 2126 0
 3213 1ad0 A4389FE5 		ldr	r3, .L463+64
 3214 1ad4 18009DE5 		ldr	r0, [sp, #24]
2127:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3215              		.loc 1 2127 0
 3216 1ad8 1C109DE5 		ldr	r1, [sp, #28]
2129:../uvc.c      **** 						 case BLCCtlID0:
 3217              		.loc 1 2129 0
 3218 1adc FF70A0E3 		mov	r7, #255
2128:../uvc.c      **** 							 break;
 3219              		.loc 1 2128 0
 3220 1ae0 1180C2E5 		strb	r8, [r2, #17]
2126:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3221              		.loc 1 2126 0
 3222 1ae4 5C05C3E5 		strb	r0, [r3, #1372]
2127:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3223              		.loc 1 2127 0
 3224 1ae8 5E15C3E5 		strb	r1, [r3, #1374]
 3225 1aec 0090A0E1 		mov	r9, r0
 3226              	.LVL357:
 3227 1af0 0150A0E1 		mov	r5, r1
2129:../uvc.c      **** 						 case BLCCtlID0:
 3228              		.loc 1 2129 0
 3229 1af4 07A0A0E1 		mov	r10, r7
 3230              	.LVL358:
 3231 1af8 A4FEFFEA 		b	.L284
 3232              	.LVL359:
 3233              	.L383:
2149:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3234              		.loc 1 2149 0
 3235 1afc 18009DE5 		ldr	r0, [sp, #24]
2148:../uvc.c      **** 							 if(Data0 != 0){
 3236              		.loc 1 2148 0
 3237 1b00 055187E0 		add	r5, r7, r5, asl #2
 3238 1b04 204195E5 		ldr	r4, [r5, #288]
2150:../uvc.c      **** 	#ifdef COLOR
 3239              		.loc 1 2150 0
 3240 1b08 74589FE5 		ldr	r5, .L463+72
2149:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3241              		.loc 1 2149 0
 3242 1b0c 000050E3 		cmp	r0, #0
2148:../uvc.c      **** 							 if(Data0 != 0){
 3243              		.loc 1 2148 0
 3244 1b10 0D00C4E5 		strb	r0, [r4, #13]
2150:../uvc.c      **** 	#ifdef COLOR
 3245              		.loc 1 2150 0
 3246 1b14 0010E0E3 		mvn	r1, #0
 3247 1b18 1C0095E5 		ldr	r0, [r5, #28]
2149:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3248              		.loc 1 2149 0
 3249 1b1c 4C02000A 		beq	.L400
2150:../uvc.c      **** 	#ifdef COLOR
 3250              		.loc 1 2150 0
 3251 1b20 FEFFFFEB 		bl	_txe_mutex_get
 3252              	.LVL360:
2154:../uvc.c      **** 								 dataIdx++;
 3253              		.loc 1 2154 0
 3254 1b24 0170A0E3 		mov	r7, #1
 3255 1b28 0030A0E3 		mov	r3, #0
 3256 1b2c 0A20A0E1 		mov	r2, r10
 3257 1b30 04308DE5 		str	r3, [sp, #4]
 3258 1b34 0710A0E3 		mov	r1, #7
 3259 1b38 0500A0E1 		mov	r0, r5
 3260 1b3c 00708DE5 		str	r7, [sp]
 3261 1b40 0930A0E1 		mov	r3, r9
 3262 1b44 FEFFFFEB 		bl	cmdSet
 3263              	.LVL361:
2156:../uvc.c      **** 	#endif
 3264              		.loc 1 2156 0
 3265 1b48 18109DE5 		ldr	r1, [sp, #24]
 3266 1b4c 0B20A0E1 		mov	r2, fp
 3267 1b50 04708DE5 		str	r7, [sp, #4]
 3268 1b54 00108DE5 		str	r1, [sp]
 3269              	.LVL362:
 3270              	.L438:
2161:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3271              		.loc 1 2161 0
 3272 1b58 0930A0E1 		mov	r3, r9
 3273 1b5c 0500A0E1 		mov	r0, r5
 3274 1b60 0710A0E3 		mov	r1, #7
 3275 1b64 FEFFFFEB 		bl	cmdSet
 3276              	.LVL363:
2162:../uvc.c      **** 							 }
 3277              		.loc 1 2162 0
 3278 1b68 1C0095E5 		ldr	r0, [r5, #28]
 3279 1b6c FEFFFFEB 		bl	_txe_mutex_put
 3280              	.LVL364:
2165:../uvc.c      **** 						 case ConsCtlID2:
 3281              		.loc 1 2165 0
 3282 1b70 FF70A0E3 		mov	r7, #255
2164:../uvc.c      **** 							 break;
 3283              		.loc 1 2164 0
 3284 1b74 0130A0E3 		mov	r3, #1
 3285 1b78 18909DE5 		ldr	r9, [sp, #24]
 3286              	.LVL365:
 3287 1b7c 1C509DE5 		ldr	r5, [sp, #28]
2165:../uvc.c      **** 						 case ConsCtlID2:
 3288              		.loc 1 2165 0
 3289 1b80 07A0A0E1 		mov	r10, r7
 3290              	.LVL366:
2164:../uvc.c      **** 							 break;
 3291              		.loc 1 2164 0
 3292 1b84 1130C4E5 		strb	r3, [r4, #17]
 3293              	.LVL367:
2165:../uvc.c      **** 						 case ConsCtlID2:
 3294              		.loc 1 2165 0
 3295 1b88 80FEFFEA 		b	.L284
 3296              	.LVL368:
 3297              	.L382:
2055:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3298              		.loc 1 2055 0
 3299 1b8c F0879FE5 		ldr	r8, .L463+72
 3300              	.LVL369:
 3301 1b90 0010E0E3 		mvn	r1, #0
 3302 1b94 1C0098E5 		ldr	r0, [r8, #28]
 3303 1b98 FEFFFFEB 		bl	_txe_mutex_get
 3304              	.LVL370:
2056:../uvc.c      **** 							 dataIdx++;
 3305              		.loc 1 2056 0
 3306 1b9c 18209DE5 		ldr	r2, [sp, #24]
 3307 1ba0 0030A0E3 		mov	r3, #0
 3308 1ba4 801042E2 		sub	r1, r2, #128
 3309 1ba8 FF1001E2 		and	r1, r1, #255
 3310 1bac 0A20A0E1 		mov	r2, r10
 3311 1bb0 00108DE5 		str	r1, [sp]
 3312 1bb4 04308DE5 		str	r3, [sp, #4]
 3313 1bb8 0510A0E3 		mov	r1, #5
 3314 1bbc 0930A0E1 		mov	r3, r9
 3315 1bc0 0800A0E1 		mov	r0, r8
 3316 1bc4 FEFFFFEB 		bl	cmdSet
 3317              	.LVL371:
2058:../uvc.c      **** 							 dataIdx++;
 3318              		.loc 1 2058 0
 3319 1bc8 18009DE5 		ldr	r0, [sp, #24]
 3320 1bcc 01C0A0E3 		mov	ip, #1
 3321 1bd0 763040E2 		sub	r3, r0, #118
 3322 1bd4 FF3003E2 		and	r3, r3, #255
 3323 1bd8 04C08DE5 		str	ip, [sp, #4]
 3324 1bdc 00308DE5 		str	r3, [sp]
 3325 1be0 0510A0E3 		mov	r1, #5
 3326 1be4 0930A0E1 		mov	r3, r9
 3327 1be8 DC20A0E3 		mov	r2, #220
 3328 1bec 0800A0E1 		mov	r0, r8
 3329 1bf0 14C08DE5 		str	ip, [sp, #20]
 3330 1bf4 FEFFFFEB 		bl	cmdSet
 3331              	.LVL372:
2060:../uvc.c      **** 							 dataIdx++;
 3332              		.loc 1 2060 0
 3333 1bf8 18109DE5 		ldr	r1, [sp, #24]
 3334 1bfc 0230A0E3 		mov	r3, #2
 3335 1c00 7E2081E2 		add	r2, r1, #126
 3336 1c04 FF2002E2 		and	r2, r2, #255
 3337 1c08 00208DE5 		str	r2, [sp]
 3338 1c0c 04308DE5 		str	r3, [sp, #4]
 3339 1c10 0510A0E3 		mov	r1, #5
 3340 1c14 0930A0E1 		mov	r3, r9
 3341 1c18 DE20A0E3 		mov	r2, #222
 3342 1c1c 0800A0E1 		mov	r0, r8
 3343 1c20 FEFFFFEB 		bl	cmdSet
 3344              	.LVL373:
2062:../uvc.c      **** 							 dataIdx++;
 3345              		.loc 1 2062 0
 3346 1c24 18309DE5 		ldr	r3, [sp, #24]
 3347 1c28 0510A0E3 		mov	r1, #5
 3348 1c2c 722083E2 		add	r2, r3, #114
 3349 1c30 FF2002E2 		and	r2, r2, #255
 3350 1c34 0330A0E3 		mov	r3, #3
 3351 1c38 00208DE5 		str	r2, [sp]
 3352 1c3c 04308DE5 		str	r3, [sp, #4]
 3353 1c40 E020A0E3 		mov	r2, #224
 3354 1c44 0930A0E1 		mov	r3, r9
 3355 1c48 0800A0E1 		mov	r0, r8
 3356 1c4c FEFFFFEB 		bl	cmdSet
 3357              	.LVL374:
2064:../uvc.c      **** 							 dataIdx++;
 3358              		.loc 1 2064 0
 3359 1c50 18009DE5 		ldr	r0, [sp, #24]
 3360 1c54 0430A0E3 		mov	r3, #4
 3361 1c58 6F2040E2 		sub	r2, r0, #111
 3362 1c5c FF2002E2 		and	r2, r2, #255
 3363 1c60 00208DE5 		str	r2, [sp]
 3364 1c64 04308DE5 		str	r3, [sp, #4]
 3365 1c68 0510A0E3 		mov	r1, #5
 3366 1c6c 0930A0E1 		mov	r3, r9
 3367 1c70 DD20A0E3 		mov	r2, #221
 3368 1c74 0800A0E1 		mov	r0, r8
 3369 1c78 FEFFFFEB 		bl	cmdSet
 3370              	.LVL375:
2066:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3371              		.loc 1 2066 0
 3372 1c7c 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 3373 1c80 0510A0E3 		mov	r1, #5
 3374 1c84 7F0080E2 		add	r0, r0, #127
 3375 1c88 FF0000E2 		and	r0, r0, #255
 3376 1c8c 0930A0E1 		mov	r3, r9
 3377 1c90 0B20A0E1 		mov	r2, fp
 3378 1c94 00008DE5 		str	r0, [sp]
 3379 1c98 04108DE5 		str	r1, [sp, #4]
 3380 1c9c 0800A0E1 		mov	r0, r8
 3381 1ca0 FEFFFFEB 		bl	cmdSet
 3382              	.LVL376:
2067:../uvc.c      **** 
 3383              		.loc 1 2067 0
 3384 1ca4 1C0098E5 		ldr	r0, [r8, #28]
 3385 1ca8 FEFFFFEB 		bl	_txe_mutex_put
 3386              	.LVL377:
2069:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3387              		.loc 1 2069 0
 3388 1cac 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 3389 1cb0 055187E0 		add	r5, r7, r5, asl #2
 3390 1cb4 203195E5 		ldr	r3, [r5, #288]
 3391 1cb8 802042E2 		sub	r2, r2, #128
 3392 1cbc FF2002E2 		and	r2, r2, #255
 3393 1cc0 0D20C3E5 		strb	r2, [r3, #13]
2070:../uvc.c      **** 							 break;
 3394              		.loc 1 2070 0
 3395 1cc4 14C09DE5 		ldr	ip, [sp, #20]
2071:../uvc.c      **** 						 case MFreqCtlID4:
 3396              		.loc 1 2071 0
 3397 1cc8 FF70A0E3 		mov	r7, #255
 3398 1ccc 1C509DE5 		ldr	r5, [sp, #28]
 3399 1cd0 18909DE5 		ldr	r9, [sp, #24]
 3400              	.LVL378:
 3401 1cd4 07A0A0E1 		mov	r10, r7
 3402              	.LVL379:
2070:../uvc.c      **** 							 break;
 3403              		.loc 1 2070 0
 3404 1cd8 11C0C3E5 		strb	ip, [r3, #17]
2071:../uvc.c      **** 						 case MFreqCtlID4:
 3405              		.loc 1 2071 0
 3406 1cdc 2BFEFFEA 		b	.L284
 3407              	.LVL380:
 3408              	.L381:
2074:../uvc.c      **** 							 is60Hz = Data0;
 3409              		.loc 1 2074 0
 3410 1ce0 18109DE5 		ldr	r1, [sp, #24]
2073:../uvc.c      **** 							 Data0 = Data0 - 1;
 3411              		.loc 1 2073 0
 3412 1ce4 055187E0 		add	r5, r7, r5, asl #2
 3413 1ce8 208195E5 		ldr	r8, [r5, #288]
 3414              	.LVL381:
2074:../uvc.c      **** 							 is60Hz = Data0;
 3415              		.loc 1 2074 0
 3416 1cec 019041E2 		sub	r9, r1, #1
 3417              	.LVL382:
 3418 1cf0 FF9009E2 		and	r9, r9, #255
 3419              	.LVL383:
2075:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3420              		.loc 1 2075 0
 3421 1cf4 48369FE5 		ldr	r3, .L463+8
2081:../uvc.c      **** 							 {
 3422              		.loc 1 2081 0
 3423 1cf8 020059E3 		cmp	r9, #2
2073:../uvc.c      **** 							 Data0 = Data0 - 1;
 3424              		.loc 1 2073 0
 3425 1cfc 0D10C8E5 		strb	r1, [r8, #13]
2075:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3426              		.loc 1 2075 0
 3427 1d00 6C9084E5 		str	r9, [r4, #108]
 3428              	.LVL384:
2084:../uvc.c      **** 							 }
 3429              		.loc 1 2084 0
 3430 1d04 0190A083 		movhi	r9, #1
 3431 1d08 6C908385 		strhi	r9, [r3, #108]
 3432              	.LVL385:
2086:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3433              		.loc 1 2086 0
 3434 1d0c 0920A0E1 		mov	r2, r9
 3435 1d10 6C3094E5 		ldr	r3, [r4, #108]
 3436 1d14 0400A0E3 		mov	r0, #4
 3437 1d18 40169FE5 		ldr	r1, .L463+36
 3438 1d1c FEFFFFEB 		bl	CyU3PDebugPrint
 3439              	.LVL386:
2087:../uvc.c      **** 							 {
 3440              		.loc 1 2087 0
 3441 1d20 883094E5 		ldr	r3, [r4, #136]
2086:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3442              		.loc 1 2086 0
 3443 1d24 18269FE5 		ldr	r2, .L463+8
2087:../uvc.c      **** 							 {
 3444              		.loc 1 2087 0
 3445 1d28 010053E3 		cmp	r3, #1
 3446 1d2c DD01000A 		beq	.L452
 3447              	.L386:
2115:../uvc.c      **** 							 break;
 3448              		.loc 1 2115 0
 3449 1d30 0130A0E3 		mov	r3, #1
2116:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3450              		.loc 1 2116 0
 3451 1d34 FF70A0E3 		mov	r7, #255
 3452 1d38 1C509DE5 		ldr	r5, [sp, #28]
2115:../uvc.c      **** 							 break;
 3453              		.loc 1 2115 0
 3454 1d3c 1130C8E5 		strb	r3, [r8, #17]
2116:../uvc.c      **** 						 case WBTLevCtlID11: //4bytes
 3455              		.loc 1 2116 0
 3456 1d40 07A0A0E1 		mov	r10, r7
 3457              	.LVL387:
 3458 1d44 11FEFFEA 		b	.L284
 3459              	.LVL388:
 3460              	.L380:
2039:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 3461              		.loc 1 2039 0
 3462 1d48 34469FE5 		ldr	r4, .L463+72
 3463 1d4c 0010E0E3 		mvn	r1, #0
 3464 1d50 1C0094E5 		ldr	r0, [r4, #28]
 3465 1d54 FEFFFFEB 		bl	_txe_mutex_get
 3466              	.LVL389:
2048:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3467              		.loc 1 2048 0
 3468 1d58 18309DE5 		ldr	r3, [sp, #24]
 3469 1d5c 0010A0E3 		mov	r1, #0
 3470 1d60 0B20A0E1 		mov	r2, fp
 3471 1d64 00308DE5 		str	r3, [sp]
 3472 1d68 04108DE5 		str	r1, [sp, #4]
 3473 1d6c 0930A0E1 		mov	r3, r9
 3474 1d70 0110A0E3 		mov	r1, #1
 3475 1d74 0400A0E1 		mov	r0, r4
 3476 1d78 FEFFFFEB 		bl	cmdSet
 3477              	.LVL390:
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3478              		.loc 1 2051 0
 3479 1d7c 055187E0 		add	r5, r7, r5, asl #2
2049:../uvc.c      **** 
 3480              		.loc 1 2049 0
 3481 1d80 1C0094E5 		ldr	r0, [r4, #28]
 3482 1d84 FEFFFFEB 		bl	_txe_mutex_put
 3483              	.LVL391:
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3484              		.loc 1 2051 0
 3485 1d88 203195E5 		ldr	r3, [r5, #288]
 3486 1d8c 18009DE5 		ldr	r0, [sp, #24]
2052:../uvc.c      **** 							 break;
 3487              		.loc 1 2052 0
 3488 1d90 0120A0E3 		mov	r2, #1
2053:../uvc.c      **** 						 case HueCtlID5://not being used
 3489              		.loc 1 2053 0
 3490 1d94 FF70A0E3 		mov	r7, #255
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3491              		.loc 1 2051 0
 3492 1d98 0D00C3E5 		strb	r0, [r3, #13]
 3493 1d9c 1C509DE5 		ldr	r5, [sp, #28]
 3494 1da0 0090A0E1 		mov	r9, r0
 3495              	.LVL392:
2052:../uvc.c      **** 							 break;
 3496              		.loc 1 2052 0
 3497 1da4 1120C3E5 		strb	r2, [r3, #17]
2053:../uvc.c      **** 						 case HueCtlID5://not being used
 3498              		.loc 1 2053 0
 3499 1da8 07A0A0E1 		mov	r10, r7
 3500              	.LVL393:
 3501 1dac F7FDFFEA 		b	.L284
 3502              	.LVL394:
 3503              	.L378:
2131:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3504              		.loc 1 2131 0
 3505 1db0 055187E0 		add	r5, r7, r5, asl #2
 3506 1db4 204195E5 		ldr	r4, [r5, #288]
 3507 1db8 18209DE5 		ldr	r2, [sp, #24]
2141:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3508              		.loc 1 2141 0
 3509 1dbc C0559FE5 		ldr	r5, .L463+72
2131:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3510              		.loc 1 2131 0
 3511 1dc0 0D20C4E5 		strb	r2, [r4, #13]
2141:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3512              		.loc 1 2141 0
 3513 1dc4 0010E0E3 		mvn	r1, #0
 3514 1dc8 1C0095E5 		ldr	r0, [r5, #28]
 3515 1dcc FEFFFFEB 		bl	_txe_mutex_get
 3516              	.LVL395:
2142:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3517              		.loc 1 2142 0
 3518 1dd0 18309DE5 		ldr	r3, [sp, #24]
 3519 1dd4 0010A0E3 		mov	r1, #0
 3520 1dd8 0A20A0E1 		mov	r2, r10
 3521 1ddc 00308DE5 		str	r3, [sp]
 3522 1de0 0500A0E1 		mov	r0, r5
 3523 1de4 0930A0E1 		mov	r3, r9
 3524 1de8 04108DE5 		str	r1, [sp, #4]
 3525 1dec FEFFFFEB 		bl	cmdSet
 3526              	.LVL396:
2143:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3527              		.loc 1 2143 0
 3528 1df0 1C0095E5 		ldr	r0, [r5, #28]
 3529 1df4 FEFFFFEB 		bl	_txe_mutex_put
 3530              	.LVL397:
2145:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3531              		.loc 1 2145 0
 3532 1df8 FF70A0E3 		mov	r7, #255
2144:../uvc.c      **** 					 		 break;
 3533              		.loc 1 2144 0
 3534 1dfc 0130A0E3 		mov	r3, #1
 3535 1e00 1C509DE5 		ldr	r5, [sp, #28]
 3536 1e04 18909DE5 		ldr	r9, [sp, #24]
 3537              	.LVL398:
2145:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3538              		.loc 1 2145 0
 3539 1e08 07A0A0E1 		mov	r10, r7
 3540              	.LVL399:
2144:../uvc.c      **** 					 		 break;
 3541              		.loc 1 2144 0
 3542 1e0c 1130C4E5 		strb	r3, [r4, #17]
 3543              	.LVL400:
2145:../uvc.c      **** 						 case ShapCtlID7: //for stand sharpness with edge enhancement in 5MP B/W.
 3544              		.loc 1 2145 0
 3545 1e10 DEFDFFEA 		b	.L284
 3546              	.LVL401:
 3547              	.L306:
1599:../uvc.c      **** 			 	 			 if(Len == 2)
 3548              		.loc 1 1599 0
 3549 1e14 003084E0 		add	r3, r4, r0
 3550 1e18 A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3551 1e1c 000053E3 		cmp	r3, #0
 3552 1e20 1801000A 		beq	.L321
1600:../uvc.c      **** 			 	 			 {
 3553              		.loc 1 1600 0
 3554 1e24 020058E3 		cmp	r8, #2
 3555 1e28 2A02000A 		beq	.L453
1606:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3556              		.loc 1 1606 0
 3557 1e2c 040058E3 		cmp	r8, #4
 3558 1e30 4E02000A 		beq	.L454
 3559              	.L323:
1552:../uvc.c      **** 					 case MFreqCtlID4:
 3560              		.loc 1 1552 0
 3561 1e34 FF70A0E3 		mov	r7, #255
 3562 1e38 07A0A0E1 		mov	r10, r7
 3563              	.LVL402:
 3564 1e3c 0090A0E3 		mov	r9, #0
 3565              	.LVL403:
 3566 1e40 99FEFFEA 		b	.L292
 3567              	.LVL404:
 3568              	.L286:
1466:../uvc.c      **** 			 	 			 if(Len == 2)
 3569              		.loc 1 1466 0
 3570 1e44 F8449FE5 		ldr	r4, .L463+8
 3571 1e48 003084E0 		add	r3, r4, r0
 3572 1e4c A030D3E5 		ldrb	r3, [r3, #160]	@ zero_extendqisi2
 3573 1e50 000053E3 		cmp	r3, #0
 3574 1e54 0001000A 		beq	.L301
1467:../uvc.c      **** 			 	 			 {
 3575              		.loc 1 1467 0
 3576 1e58 020058E3 		cmp	r8, #2
 3577 1e5c 2702000A 		beq	.L455
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3578              		.loc 1 1473 0
 3579 1e60 040058E3 		cmp	r8, #4
 3580 1e64 F2FFFF1A 		bne	.L323
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3581              		.loc 1 1474 0
 3582 1e68 005187E0 		add	r5, r7, r0, asl #2
 3583 1e6c 202015E5 		ldr	r2, [r5, #-32]
 3584              	.L434:
1607:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3585              		.loc 1 1607 0
 3586 1e70 0DA0D2E5 		ldrb	r10, [r2, #13]	@ zero_extendqisi2
 3587              	.LVL405:
1608:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3588              		.loc 1 1608 0
 3589 1e74 0030A0E3 		mov	r3, #0
1607:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3590              		.loc 1 1607 0
 3591 1e78 FFA00AE2 		and	r10, r10, #255
1608:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3592              		.loc 1 1608 0
 3593 1e7c 2930C4E5 		strb	r3, [r4, #41]
1607:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 3594              		.loc 1 1607 0
 3595 1e80 28A0C4E5 		strb	r10, [r4, #40]
1609:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 3596              		.loc 1 1609 0
 3597 1e84 0E70D2E5 		ldrb	r7, [r2, #14]	@ zero_extendqisi2
 3598 1e88 0390A0E1 		mov	r9, r3
 3599              	.LVL406:
 3600 1e8c FF7007E2 		and	r7, r7, #255
 3601 1e90 2A70C4E5 		strb	r7, [r4, #42]
1610:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 3602              		.loc 1 1610 0
 3603 1e94 2B30C4E5 		strb	r3, [r4, #43]
 3604              	.LVL407:
 3605 1e98 83FEFFEA 		b	.L292
 3606              	.LVL408:
 3607              	.L357:
1809:../uvc.c      **** 							 if(Data0 == 1){
 3608              		.loc 1 1809 0
 3609 1e9c 033187E0 		add	r3, r7, r3, asl #2
 3610 1ea0 204093E5 		ldr	r4, [r3, #32]
1810:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3611              		.loc 1 1810 0
 3612 1ea4 18009DE5 		ldr	r0, [sp, #24]
1811:../uvc.c      **** 							 }else{
 3613              		.loc 1 1811 0
 3614 1ea8 CC349FE5 		ldr	r3, .L463+64
1815:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3615              		.loc 1 1815 0
 3616 1eac D0549FE5 		ldr	r5, .L463+72
1809:../uvc.c      **** 							 if(Data0 == 1){
 3617              		.loc 1 1809 0
 3618 1eb0 0D00C4E5 		strb	r0, [r4, #13]
1811:../uvc.c      **** 							 }else{
 3619              		.loc 1 1811 0
 3620 1eb4 6DB5D3E5 		ldrb	fp, [r3, #1389]	@ zero_extendqisi2
 3621              	.LVL409:
1810:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3622              		.loc 1 1810 0
 3623 1eb8 010050E3 		cmp	r0, #1
1815:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3624              		.loc 1 1815 0
 3625 1ebc 0010E0E3 		mvn	r1, #0
 3626 1ec0 1C0095E5 		ldr	r0, [r5, #28]
1811:../uvc.c      **** 							 }else{
 3627              		.loc 1 1811 0
 3628 1ec4 80B08B03 		orreq	fp, fp, #128
 3629              	.LVL410:
1813:../uvc.c      **** 							 }
 3630              		.loc 1 1813 0
 3631 1ec8 7FB00B12 		andne	fp, fp, #127
 3632              	.LVL411:
1815:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3633              		.loc 1 1815 0
 3634 1ecc FEFFFFEB 		bl	_txe_mutex_get
 3635              	.LVL412:
1816:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3636              		.loc 1 1816 0
 3637 1ed0 0010A0E3 		mov	r1, #0
 3638 1ed4 0930A0E1 		mov	r3, r9
 3639 1ed8 0A20A0E1 		mov	r2, r10
 3640 1edc 0500A0E1 		mov	r0, r5
 3641 1ee0 04108DE5 		str	r1, [sp, #4]
 3642 1ee4 00B08DE5 		str	fp, [sp]
 3643 1ee8 2610A0E3 		mov	r1, #38
 3644 1eec FEFFFFEB 		bl	cmdSet
 3645              	.LVL413:
1817:../uvc.c      **** 							 pEXTSenCtrl[CtrlID - 0x10]->AvailableF = CyTrue;
 3646              		.loc 1 1817 0
 3647 1ef0 1C0095E5 		ldr	r0, [r5, #28]
 3648 1ef4 FEFFFFEB 		bl	_txe_mutex_put
 3649              	.LVL414:
1819:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3650              		.loc 1 1819 0
 3651 1ef8 FF70A0E3 		mov	r7, #255
1818:../uvc.c      **** 							 break;
 3652              		.loc 1 1818 0
 3653 1efc 0130A0E3 		mov	r3, #1
 3654 1f00 1C509DE5 		ldr	r5, [sp, #28]
 3655 1f04 0B90A0E1 		mov	r9, fp
 3656              	.LVL415:
 3657 1f08 1130C4E5 		strb	r3, [r4, #17]
 3658              	.LVL416:
1819:../uvc.c      **** 					 	 case ExtCamMCtlID12://EXTCamMode
 3659              		.loc 1 1819 0
 3660 1f0c 07A0A0E1 		mov	r10, r7
 3661              	.LVL417:
 3662 1f10 9EFDFFEA 		b	.L284
 3663              	.LVL418:
 3664              	.L356:
1959:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3665              		.loc 1 1959 0
 3666 1f14 68549FE5 		ldr	r5, .L463+72
 3667 1f18 0010E0E3 		mvn	r1, #0
 3668 1f1c 1C0095E5 		ldr	r0, [r5, #28]
 3669 1f20 FEFFFFEB 		bl	_txe_mutex_get
 3670              	.LVL419:
1960:../uvc.c      **** 							 dataIdx++;
 3671              		.loc 1 1960 0
 3672 1f24 18009DE5 		ldr	r0, [sp, #24]
 3673 1f28 0030A0E3 		mov	r3, #0
 3674 1f2c 0A20A0E1 		mov	r2, r10
 3675 1f30 00008DE5 		str	r0, [sp]
 3676 1f34 04308DE5 		str	r3, [sp, #4]
 3677 1f38 0500A0E1 		mov	r0, r5
 3678 1f3c 0930A0E1 		mov	r3, r9
 3679 1f40 2410A0E3 		mov	r1, #36
 3680 1f44 FEFFFFEB 		bl	cmdSet
 3681              	.LVL420:
1962:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3682              		.loc 1 1962 0
 3683 1f48 1C109DE5 		ldr	r1, [sp, #28]
 3684 1f4c 0140A0E3 		mov	r4, #1
 3685 1f50 0930A0E1 		mov	r3, r9
 3686 1f54 0B20A0E1 		mov	r2, fp
 3687 1f58 00108DE5 		str	r1, [sp]
 3688 1f5c 0500A0E1 		mov	r0, r5
 3689 1f60 2410A0E3 		mov	r1, #36
 3690 1f64 04408DE5 		str	r4, [sp, #4]
 3691 1f68 FEFFFFEB 		bl	cmdSet
 3692              	.LVL421:
1963:../uvc.c      **** 							 getData1 = Data1;
 3693              		.loc 1 1963 0
 3694 1f6c 1C0095E5 		ldr	r0, [r5, #28]
 3695 1f70 FEFFFFEB 		bl	_txe_mutex_put
 3696              	.LVL422:
1966:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3697              		.loc 1 1966 0
 3698 1f74 00349FE5 		ldr	r3, .L463+64
 3699 1f78 18209DE5 		ldr	r2, [sp, #24]
1967:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3700              		.loc 1 1967 0
 3701 1f7c 1C009DE5 		ldr	r0, [sp, #28]
1969:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3702              		.loc 1 1969 0
 3703 1f80 FF70A0E3 		mov	r7, #255
1966:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3704              		.loc 1 1966 0
 3705 1f84 A925C3E5 		strb	r2, [r3, #1449]
 3706 1f88 0290A0E1 		mov	r9, r2
 3707              	.LVL423:
1967:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3708              		.loc 1 1967 0
 3709 1f8c AA05C3E5 		strb	r0, [r3, #1450]
 3710 1f90 0050A0E1 		mov	r5, r0
1968:../uvc.c      **** 							 break;
 3711              		.loc 1 1968 0
 3712 1f94 AD45C3E5 		strb	r4, [r3, #1453]
1969:../uvc.c      **** 				 	 	 case Ext1BLCWeightCtlID5:
 3713              		.loc 1 1969 0
 3714 1f98 07A0A0E1 		mov	r10, r7
 3715              	.LVL424:
 3716 1f9c 7BFDFFEA 		b	.L284
 3717              	.LVL425:
 3718              	.L353:
1880:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0){
 3719              		.loc 1 1880 0
 3720 1fa0 DC439FE5 		ldr	r4, .L463+72
 3721 1fa4 0010E0E3 		mvn	r1, #0
 3722 1fa8 1C0094E5 		ldr	r0, [r4, #28]
 3723 1fac 14308DE5 		str	r3, [sp, #20]
 3724 1fb0 FEFFFFEB 		bl	_txe_mutex_get
 3725              	.LVL426:
1881:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 3726              		.loc 1 1881 0
 3727 1fb4 14309DE5 		ldr	r3, [sp, #20]
 3728 1fb8 18009DE5 		ldr	r0, [sp, #24]
 3729 1fbc 033187E0 		add	r3, r7, r3, asl #2
 3730 1fc0 203093E5 		ldr	r3, [r3, #32]
 3731 1fc4 0D20D3E5 		ldrb	r2, [r3, #13]	@ zero_extendqisi2
 3732 1fc8 000052E1 		cmp	r2, r0
 3733 1fcc A8539F05 		ldreq	r5, .L463+64
 3734 1fd0 0700000A 		beq	.L368
1883:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3735              		.loc 1 1883 0
 3736 1fd4 A0539FE5 		ldr	r5, .L463+64
1882:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3737              		.loc 1 1882 0
 3738 1fd8 0D00C3E5 		strb	r0, [r3, #13]
1883:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3739              		.loc 1 1883 0
 3740 1fdc 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3741 1fe0 010053E3 		cmp	r3, #1
 3742 1fe4 8E01000A 		beq	.L369
1883:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3743              		.loc 1 1883 0 is_stmt 0 discriminator 1
 3744 1fe8 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3745 1fec 030053E3 		cmp	r3, #3
 3746 1ff0 8B01000A 		beq	.L369
 3747              	.LVL427:
 3748              	.L368:
1890:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3749              		.loc 1 1890 0 is_stmt 1
 3750 1ff4 1C0094E5 		ldr	r0, [r4, #28]
 3751 1ff8 FEFFFFEB 		bl	_txe_mutex_put
 3752              	.LVL428:
1892:../uvc.c      **** 							 break;
 3753              		.loc 1 1892 0
 3754 1ffc 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
 3755 2000 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3756 2004 9515D5E5 		ldrb	r1, [r5, #1429]	@ zero_extendqisi2
1891:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3757              		.loc 1 1891 0
 3758 2008 FF70A0E3 		mov	r7, #255
 3759 200c 82008DE8 		stmia	sp, {r1, r7}
 3760 2010 4C139FE5 		ldr	r1, .L463+40
 3761 2014 08708DE5 		str	r7, [sp, #8]
 3762 2018 0400A0E3 		mov	r0, #4
 3763 201c FEFFFFEB 		bl	CyU3PDebugPrint
 3764              	.LVL429:
1893:../uvc.c      **** 
 3765              		.loc 1 1893 0
 3766 2020 07A0A0E1 		mov	r10, r7
 3767              	.LVL430:
 3768 2024 18909DE5 		ldr	r9, [sp, #24]
 3769              	.LVL431:
 3770 2028 1C509DE5 		ldr	r5, [sp, #28]
 3771 202c 57FDFFEA 		b	.L284
 3772              	.LVL432:
 3773              	.L352:
1844:../uvc.c      **** 							 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 3774              		.loc 1 1844 0
 3775 2030 4C439FE5 		ldr	r4, .L463+72
 3776 2034 0010E0E3 		mvn	r1, #0
 3777 2038 1C0094E5 		ldr	r0, [r4, #28]
 3778 203c 14308DE5 		str	r3, [sp, #20]
 3779 2040 FEFFFFEB 		bl	_txe_mutex_get
 3780              	.LVL433:
1845:../uvc.c      **** 							 {
 3781              		.loc 1 1845 0
 3782 2044 14309DE5 		ldr	r3, [sp, #20]
 3783 2048 18109DE5 		ldr	r1, [sp, #24]
 3784 204c 033187E0 		add	r3, r7, r3, asl #2
 3785 2050 207093E5 		ldr	r7, [r3, #32]
 3786 2054 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 3787 2058 010053E1 		cmp	r3, r1
 3788 205c 0201001A 		bne	.L430
 3789 2060 14539FE5 		ldr	r5, .L463+64
 3790              	.L362:
1851:../uvc.c      **** 								 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 3791              		.loc 1 1851 0
 3792 2064 0E30D7E5 		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 3793 2068 1C209DE5 		ldr	r2, [sp, #28]
 3794 206c 020053E1 		cmp	r3, r2
 3795 2070 0500000A 		beq	.L364
1853:../uvc.c      **** 									 dataIdx++;
 3796              		.loc 1 1853 0
 3797 2074 18009DE5 		ldr	r0, [sp, #24]
1852:../uvc.c      **** 								 if(Data0 == 2 || Data0 == 3){
 3798              		.loc 1 1852 0
 3799 2078 0E20C7E5 		strb	r2, [r7, #14]
1853:../uvc.c      **** 									 dataIdx++;
 3800              		.loc 1 1853 0
 3801 207c 023040E2 		sub	r3, r0, #2
 3802 2080 FF3003E2 		and	r3, r3, #255
 3803 2084 010053E3 		cmp	r3, #1
 3804 2088 ED01009A 		bls	.L456
 3805              	.LVL434:
 3806              	.L364:
1858:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3807              		.loc 1 1858 0
 3808 208c 0130A0E3 		mov	r3, #1
 3809 2090 1130C7E5 		strb	r3, [r7, #17]
1859:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3810              		.loc 1 1859 0
 3811 2094 1C0094E5 		ldr	r0, [r4, #28]
 3812 2098 FEFFFFEB 		bl	_txe_mutex_put
 3813              	.LVL435:
1861:../uvc.c      **** 							 break;
 3814              		.loc 1 1861 0
 3815 209c 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
1860:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3816              		.loc 1 1860 0
 3817 20a0 18909DE5 		ldr	r9, [sp, #24]
 3818              	.LVL436:
1861:../uvc.c      **** 							 break;
 3819              		.loc 1 1861 0
 3820 20a4 1A35D5E5 		ldrb	r3, [r5, #1306]	@ zero_extendqisi2
 3821 20a8 8115D5E5 		ldrb	r1, [r5, #1409]	@ zero_extendqisi2
1860:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3822              		.loc 1 1860 0
 3823 20ac FF70A0E3 		mov	r7, #255
 3824 20b0 02028DE8 		stmia	sp, {r1, r9}
 3825 20b4 AC129FE5 		ldr	r1, .L463+44
 3826 20b8 08708DE5 		str	r7, [sp, #8]
 3827 20bc 0400A0E3 		mov	r0, #4
 3828 20c0 FEFFFFEB 		bl	CyU3PDebugPrint
 3829              	.LVL437:
1862:../uvc.c      **** 					 	 case ExtShutCtlID0: //special!!
 3830              		.loc 1 1862 0
 3831 20c4 07A0A0E1 		mov	r10, r7
 3832              	.LVL438:
 3833 20c8 1C509DE5 		ldr	r5, [sp, #28]
 3834 20cc 2FFDFFEA 		b	.L284
 3835              	.LVL439:
 3836              	.L350:
1864:../uvc.c      **** 	#if 1	// register setting directly
 3837              		.loc 1 1864 0
 3838 20d0 033187E0 		add	r3, r7, r3, asl #2
 3839 20d4 203093E5 		ldr	r3, [r3, #32]
1866:../uvc.c      **** 						     {
 3840              		.loc 1 1866 0
 3841 20d8 9C529FE5 		ldr	r5, .L463+64
1864:../uvc.c      **** 	#if 1	// register setting directly
 3842              		.loc 1 1864 0
 3843 20dc 18109DE5 		ldr	r1, [sp, #24]
 3844 20e0 0D10C3E5 		strb	r1, [r3, #13]
1866:../uvc.c      **** 						     {
 3845              		.loc 1 1866 0
 3846 20e4 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
 3847 20e8 030013E3 		tst	r3, #3
 3848 20ec 1A00000A 		beq	.L366
1868:../uvc.c      **** 						    	 dataIdx = 0;
 3849              		.loc 1 1868 0
 3850 20f0 1935D5E5 		ldrb	r3, [r5, #1305]	@ zero_extendqisi2
1870:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3851              		.loc 1 1870 0
 3852 20f4 88429FE5 		ldr	r4, .L463+72
1868:../uvc.c      **** 						    	 dataIdx = 0;
 3853              		.loc 1 1868 0
 3854 20f8 013283E1 		orr	r3, r3, r1, asl #4
 3855 20fc FF3003E2 		and	r3, r3, #255
1870:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3856              		.loc 1 1870 0
 3857 2100 0010E0E3 		mvn	r1, #0
 3858 2104 1C0094E5 		ldr	r0, [r4, #28]
1868:../uvc.c      **** 						    	 dataIdx = 0;
 3859              		.loc 1 1868 0
 3860 2108 18308DE5 		str	r3, [sp, #24]
 3861              	.LVL440:
1870:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3862              		.loc 1 1870 0
 3863 210c FEFFFFEB 		bl	_txe_mutex_get
 3864              	.LVL441:
1871:../uvc.c      **** 								 dataIdx++;
 3865              		.loc 1 1871 0
 3866 2110 0030A0E3 		mov	r3, #0
 3867 2114 0B20A0E1 		mov	r2, fp
 3868 2118 00308DE5 		str	r3, [sp]
 3869 211c 04308DE5 		str	r3, [sp, #4]
 3870 2120 1010A0E3 		mov	r1, #16
 3871 2124 0930A0E1 		mov	r3, r9
 3872 2128 0400A0E1 		mov	r0, r4
 3873 212c FEFFFFEB 		bl	cmdSet
 3874              	.LVL442:
1873:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3875              		.loc 1 1873 0
 3876 2130 18209DE5 		ldr	r2, [sp, #24]
 3877 2134 0110A0E3 		mov	r1, #1
 3878 2138 00208DE5 		str	r2, [sp]
 3879 213c 04108DE5 		str	r1, [sp, #4]
 3880 2140 0A20A0E1 		mov	r2, r10
 3881 2144 0930A0E1 		mov	r3, r9
 3882 2148 0400A0E1 		mov	r0, r4
 3883 214c 1010A0E3 		mov	r1, #16
 3884 2150 FEFFFFEB 		bl	cmdSet
 3885              	.LVL443:
1874:../uvc.c      **** 						     }
 3886              		.loc 1 1874 0
 3887 2154 1C0094E5 		ldr	r0, [r4, #28]
 3888 2158 FEFFFFEB 		bl	_txe_mutex_put
 3889              	.LVL444:
 3890              	.L366:
1877:../uvc.c      **** 						     break;
 3891              		.loc 1 1877 0
 3892 215c 1925D5E5 		ldrb	r2, [r5, #1305]	@ zero_extendqisi2
1876:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3893              		.loc 1 1876 0
 3894 2160 18909DE5 		ldr	r9, [sp, #24]
 3895              	.LVL445:
1877:../uvc.c      **** 						     break;
 3896              		.loc 1 1877 0
 3897 2164 8135D5E5 		ldrb	r3, [r5, #1409]	@ zero_extendqisi2
1876:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3898              		.loc 1 1876 0
 3899 2168 1C509DE5 		ldr	r5, [sp, #28]
 3900 216c 0C008DE8 		stmia	sp, {r2, r3}
 3901 2170 F4119FE5 		ldr	r1, .L463+48
 3902 2174 0520A0E1 		mov	r2, r5
 3903 2178 0930A0E1 		mov	r3, r9
 3904 217c 0400A0E3 		mov	r0, #4
1878:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 3905              		.loc 1 1878 0
 3906 2180 FF70A0E3 		mov	r7, #255
1876:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3907              		.loc 1 1876 0
 3908 2184 FEFFFFEB 		bl	CyU3PDebugPrint
 3909              	.LVL446:
1878:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level 2bytes standard operation!!!
 3910              		.loc 1 1878 0
 3911 2188 07A0A0E1 		mov	r10, r7
 3912              	.LVL447:
 3913 218c FFFCFFEA 		b	.L284
 3914              	.LVL448:
 3915              	.L355:
1838:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 3916              		.loc 1 1838 0 discriminator 1
 3917 2190 000058E3 		cmp	r8, #0
 3918 2194 0300000A 		beq	.L361
 3919 2198 D0019FE5 		ldr	r0, .L463+52
 3920 219c 0820A0E1 		mov	r2, r8
 3921 21a0 6C1040E2 		sub	r1, r0, #108
 3922 21a4 FEFFFFEB 		bl	memcpy
 3923              	.LVL449:
 3924              	.L361:
1842:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 3925              		.loc 1 1842 0
 3926 21a8 FF70A0E3 		mov	r7, #255
1841:../uvc.c      **** 							 break;
 3927              		.loc 1 1841 0
 3928 21ac FEFFFFEB 		bl	I2CCmdHandler
 3929              	.LVL450:
1842:../uvc.c      **** 				 	 	 case ExtAexModCtlID9://4byte
 3930              		.loc 1 1842 0
 3931 21b0 07A0A0E1 		mov	r10, r7
 3932              	.LVL451:
 3933 21b4 18909DE5 		ldr	r9, [sp, #24]
 3934              	.LVL452:
 3935 21b8 1C509DE5 		ldr	r5, [sp, #28]
 3936 21bc F3FCFFEA 		b	.L284
 3937              	.LVL453:
 3938              	.L354:
1806:../uvc.c      **** 					 {
 3939              		.loc 1 1806 0
 3940 21c0 FF70A0E3 		mov	r7, #255
 3941 21c4 18909DE5 		ldr	r9, [sp, #24]
 3942              	.LVL454:
 3943 21c8 1C509DE5 		ldr	r5, [sp, #28]
 3944 21cc 07A0A0E1 		mov	r10, r7
 3945              	.LVL455:
 3946 21d0 EEFCFFEA 		b	.L284
 3947              	.LVL456:
 3948              	.L377:
2170:../uvc.c      **** 			 	 			 {
 3949              		.loc 1 2170 0
 3950 21d4 020058E3 		cmp	r8, #2
 3951 21d8 2301000A 		beq	.L457
2180:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3952              		.loc 1 2180 0
 3953 21dc 040058E3 		cmp	r8, #4
 3954 21e0 6501000A 		beq	.L405
 3955 21e4 055187E0 		add	r5, r7, r5, asl #2
 3956 21e8 207195E5 		ldr	r7, [r5, #288]
 3957              	.LVL457:
 3958              	.L404:
2197:../uvc.c      **** 			 	 			 break;
 3959              		.loc 1 2197 0
 3960 21ec 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
2196:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3961              		.loc 1 2196 0
 3962 21f0 18909DE5 		ldr	r9, [sp, #24]
 3963              	.LVL458:
2197:../uvc.c      **** 			 	 			 break;
 3964              		.loc 1 2197 0
 3965 21f4 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
2196:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3966              		.loc 1 2196 0
 3967 21f8 1C509DE5 		ldr	r5, [sp, #28]
 3968 21fc 0C018DE8 		stmia	sp, {r2, r3, r8}
 3969 2200 6C119FE5 		ldr	r1, .L463+56
 3970 2204 0920A0E1 		mov	r2, r9
 3971 2208 0530A0E1 		mov	r3, r5
 3972 220c 0400A0E3 		mov	r0, #4
2198:../uvc.c      **** 					 }
 3973              		.loc 1 2198 0
 3974 2210 FF70A0E3 		mov	r7, #255
2196:../uvc.c      **** 										 Data0, Data1, pPUCSenCtrl[CtrlID]->UVCCurVHi, pPUCSenCtrl[CtrlID]->UVCCurVLo, Len);
 3975              		.loc 1 2196 0
 3976 2214 FEFFFFEB 		bl	CyU3PDebugPrint
 3977              	.LVL459:
2198:../uvc.c      **** 					 }
 3978              		.loc 1 2198 0
 3979 2218 07A0A0E1 		mov	r10, r7
 3980              	.LVL460:
 3981 221c DBFCFFEA 		b	.L284
 3982              	.LVL461:
 3983              	.L349:
1982:../uvc.c      **** 				 	 			 {
 3984              		.loc 1 1982 0
 3985 2220 020058E3 		cmp	r8, #2
 3986 2224 3801000A 		beq	.L458
1992:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 3987              		.loc 1 1992 0
 3988 2228 040058E3 		cmp	r8, #4
 3989 222c 8D01000A 		beq	.L374
 3990 2230 033187E0 		add	r3, r7, r3, asl #2
 3991 2234 207093E5 		ldr	r7, [r3, #32]
 3992 2238 EBFFFFEA 		b	.L404
 3993              	.LVL462:
 3994              	.L345:
2202:../uvc.c      **** 			   }
 3995              		.loc 1 2202 0
 3996 223c 0400A0E3 		mov	r0, #4
 3997              	.LVL463:
 3998 2240 30119FE5 		ldr	r1, .L463+60
 3999 2244 FEFFFFEB 		bl	CyU3PDebugPrint
 4000              	.LVL464:
 4001 2248 FF70A0E3 		mov	r7, #255
 4002 224c 0090A0E3 		mov	r9, #0
 4003              	.LVL465:
 4004 2250 07A0A0E1 		mov	r10, r7
 4005              	.LVL466:
 4006 2254 0950A0E1 		mov	r5, r9
 4007 2258 CCFCFFEA 		b	.L284
 4008              	.LVL467:
 4009              	.L301:
1482:../uvc.c      **** 			 	 			 {
 4010              		.loc 1 1482 0
 4011 225c 020058E3 		cmp	r8, #2
 4012 2260 8901000A 		beq	.L459
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4013              		.loc 1 1490 0
 4014 2264 040058E3 		cmp	r8, #4
 4015 2268 FF70A013 		movne	r7, #255
 4016 226c 07A0A011 		movne	r10, r7
 4017              	.LVL468:
 4018 2270 A701000A 		beq	.L460
 4019              	.LVL469:
 4020              	.L305:
1500:../uvc.c      **** 			 	 		 }
 4021              		.loc 1 1500 0
 4022 2274 055084E0 		add	r5, r4, r5
 4023 2278 0130A0E3 		mov	r3, #1
 4024 227c A030C5E5 		strb	r3, [r5, #160]
 4025              	.L435:
 4026 2280 0090A0E3 		mov	r9, #0
 4027              	.LVL470:
 4028 2284 88FDFFEA 		b	.L292
 4029              	.LVL471:
 4030              	.L321:
1615:../uvc.c      **** 			 	 			 {
 4031              		.loc 1 1615 0
 4032 2288 020058E3 		cmp	r8, #2
 4033 228c 5E01000A 		beq	.L461
1623:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4034              		.loc 1 1623 0
 4035 2290 040058E3 		cmp	r8, #4
 4036 2294 FF70A013 		movne	r7, #255
 4037 2298 07A0A011 		movne	r10, r7
 4038              	.LVL472:
 4039 229c 8801000A 		beq	.L462
 4040              	.LVL473:
 4041              	.L325:
1633:../uvc.c      **** 			 	 		 }
 4042              		.loc 1 1633 0
 4043 22a0 055084E0 		add	r5, r4, r5
 4044 22a4 0130A0E3 		mov	r3, #1
 4045 22a8 0090A0E3 		mov	r9, #0
 4046              	.LVL474:
 4047 22ac A030C5E5 		strb	r3, [r5, #160]
 4048 22b0 7DFDFFEA 		b	.L292
 4049              	.LVL475:
 4050              	.L319:
1580:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4051              		.loc 1 1580 0
 4052 22b4 0A00A0E1 		mov	r0, r10
 4053              	.LVL476:
 4054 22b8 0910A0E1 		mov	r1, r9
 4055 22bc FEFFFFEB 		bl	SensorGetControl
 4056              	.LVL477:
1581:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4057              		.loc 1 1581 0
 4058 22c0 0910A0E1 		mov	r1, r9
1580:../uvc.c      **** 							Data1 = SensorGetControl(RegAdd1, devAdd);
 4059              		.loc 1 1580 0
 4060 22c4 0020A0E1 		mov	r2, r0
 4061              	.LVL478:
1581:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4062              		.loc 1 1581 0
 4063 22c8 0B00A0E1 		mov	r0, fp
 4064              	.LVL479:
 4065 22cc 14208DE5 		str	r2, [sp, #20]
 4066 22d0 FEFFFFEB 		bl	SensorGetControl
 4067              	.LVL480:
1586:../uvc.c      **** 						 }
 4068              		.loc 1 1586 0
 4069 22d4 14209DE5 		ldr	r2, [sp, #20]
1583:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4070              		.loc 1 1583 0
 4071 22d8 9C309FE5 		ldr	r3, .L463+64
1586:../uvc.c      **** 						 }
 4072              		.loc 1 1586 0
 4073 22dc 0110A0E3 		mov	r1, #1
 4074 22e0 02A0A0E1 		mov	r10, r2
 4075              	.LVL481:
1582:../uvc.c      **** 							WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4076              		.loc 1 1582 0
 4077 22e4 2820C4E5 		strb	r2, [r4, #40]
1583:../uvc.c      **** 							glEp0Buffer[2] = Data1;
 4078              		.loc 1 1583 0
 4079 22e8 5C25C3E5 		strb	r2, [r3, #1372]
1586:../uvc.c      **** 						 }
 4080              		.loc 1 1586 0
 4081 22ec AB10C4E5 		strb	r1, [r4, #171]
1581:../uvc.c      **** 							glEp0Buffer[0] = Data0;
 4082              		.loc 1 1581 0
 4083 22f0 18008DE5 		str	r0, [sp, #24]
 4084              	.LVL482:
1586:../uvc.c      **** 						 }
 4085              		.loc 1 1586 0
 4086 22f4 0070A0E1 		mov	r7, r0
1584:../uvc.c      **** 							WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4087              		.loc 1 1584 0
 4088 22f8 2A00C4E5 		strb	r0, [r4, #42]
1585:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4089              		.loc 1 1585 0
 4090 22fc 5E05C3E5 		strb	r0, [r3, #1374]
 4091 2300 65FDFFEA 		b	.L320
 4092              	.LVL483:
 4093              	.L296:
1386:../uvc.c      **** 							if(Data0&0x80)
 4094              		.loc 1 1386 0
 4095 2304 0A00A0E1 		mov	r0, r10
 4096              	.LVL484:
 4097 2308 0910A0E1 		mov	r1, r9
 4098 230c FEFFFFEB 		bl	SensorGetControl
 4099              	.LVL485:
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4100              		.loc 1 1391 0
 4101 2310 64109FE5 		ldr	r1, .L463+64
1393:../uvc.c      **** 						 }
 4102              		.loc 1 1393 0
 4103 2314 0130A0E3 		mov	r3, #1
 4104 2318 0570A0E1 		mov	r7, r5
1392:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4105              		.loc 1 1392 0
 4106 231c 2950C4E5 		strb	r5, [r4, #41]
1393:../uvc.c      **** 						 }
 4107              		.loc 1 1393 0
 4108 2320 C630C4E5 		strb	r3, [r4, #198]
1387:../uvc.c      **** 								glEp0Buffer[0] = 1;
 4109              		.loc 1 1387 0
 4110 2324 FFA000E2 		and	r10, r0, #255
 4111              	.LVL486:
1388:../uvc.c      **** 							else
 4112              		.loc 1 1388 0
 4113 2328 AAA3A0E1 		mov	r10, r10, lsr #7
1386:../uvc.c      **** 							if(Data0&0x80)
 4114              		.loc 1 1386 0
 4115 232c 0020A0E1 		mov	r2, r0
 4116              	.LVL487:
 4117 2330 28A0C4E5 		strb	r10, [r4, #40]
1391:../uvc.c      **** 							glEp0Buffer[1] = 0; //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;ExUCtrlParArry[CtrlID-0x20][14];
 4118              		.loc 1 1391 0
 4119 2334 05A5C1E5 		strb	r10, [r1, #1285]
 4120 2338 81FDFFEA 		b	.L318
 4121              	.L464:
 4122              		.align	2
 4123              	.L463:
 4124 233c 00000000 		.word	.LANCHOR2
 4125 2340 00000000 		.word	bRequest
 4126 2344 00000000 		.word	.LANCHOR0
 4127 2348 68040000 		.word	.LC27
 4128 234c 28000000 		.word	.LANCHOR0+40
 4129 2350 14060000 		.word	.LC35
 4130 2354 38040000 		.word	.LC26
 4131 2358 FC030000 		.word	.LC25
 4132 235c D4030000 		.word	.LC24
 4133 2360 A0050000 		.word	.LC32
 4134 2364 14050000 		.word	.LC30
 4135 2368 B4040000 		.word	.LC28
 4136 236c E8040000 		.word	.LC29
 4137 2370 94000000 		.word	.LANCHOR0+148
 4138 2374 4C050000 		.word	.LC31
 4139 2378 E4050000 		.word	.LC34
 4140 237c 00000000 		.word	.LANCHOR1
 4141 2380 C0050000 		.word	.LC33
 4142 2384 00000000 		.word	cmdQu
 4143              	.LVL488:
 4144              	.L316:
1564:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4145              		.loc 1 1564 0
 4146 2388 0910A0E1 		mov	r1, r9
 4147 238c 0100A0E3 		mov	r0, #1
 4148              	.LVL489:
 4149 2390 FEFFFFEB 		bl	SensorGetControl
 4150              	.LVL490:
1567:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4151              		.loc 1 1567 0
 4152 2394 20101FE5 		ldr	r1, .L463+64
1565:../uvc.c      **** 							glEp0Buffer[0]++;
 4153              		.loc 1 1565 0
 4154 2398 A033A0E1 		mov	r3, r0, lsr #7
1566:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4155              		.loc 1 1566 0
 4156 239c 013083E2 		add	r3, r3, #1
 4157 23a0 FF3003E2 		and	r3, r3, #255
1567:../uvc.c      **** 							glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi; //CtrlParArry[CtrlID][14];
 4158              		.loc 1 1567 0
 4159 23a4 5535C1E5 		strb	r3, [r1, #1365]
1568:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4160              		.loc 1 1568 0
 4161 23a8 5615D1E5 		ldrb	r1, [r1, #1366]	@ zero_extendqisi2
1564:../uvc.c      **** 							glEp0Buffer[0] = (Data0&0x80)>>7;
 4162              		.loc 1 1564 0
 4163 23ac 0020A0E1 		mov	r2, r0
 4164              	.LVL491:
1568:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4165              		.loc 1 1568 0
 4166 23b0 FF1001E2 		and	r1, r1, #255
1569:../uvc.c      **** 						 }
 4167              		.loc 1 1569 0
 4168 23b4 0100A0E3 		mov	r0, #1
 4169              	.LVL492:
 4170 23b8 03A0A0E1 		mov	r10, r3
 4171              	.LVL493:
 4172 23bc 0170A0E1 		mov	r7, r1
1566:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4173              		.loc 1 1566 0
 4174 23c0 2830C4E5 		strb	r3, [r4, #40]
1568:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4175              		.loc 1 1568 0
 4176 23c4 2910C4E5 		strb	r1, [r4, #41]
1569:../uvc.c      **** 						 }
 4177              		.loc 1 1569 0
 4178 23c8 A400C4E5 		strb	r0, [r4, #164]
 4179 23cc 5CFDFFEA 		b	.L318
 4180              	.LVL494:
 4181              	.L314:
1544:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4182              		.loc 1 1544 0
 4183 23d0 0A00A0E1 		mov	r0, r10
 4184              	.LVL495:
 4185 23d4 0910A0E1 		mov	r1, r9
 4186 23d8 FEFFFFEB 		bl	SensorGetControl
 4187              	.LVL496:
1545:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4188              		.loc 1 1545 0
 4189 23dc 68201FE5 		ldr	r2, .L463+64
1546:../uvc.c      **** 						 }
 4190              		.loc 1 1546 0
 4191 23e0 0130A0E3 		mov	r3, #1
 4192 23e4 A530C4E5 		strb	r3, [r4, #165]
1545:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4193              		.loc 1 1545 0
 4194 23e8 4105C2E5 		strb	r0, [r2, #1345]
 4195 23ec 41FDFFEA 		b	.L315
 4196              	.LVL497:
 4197              	.L312:
1524:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 4198              		.loc 1 1524 0
 4199 23f0 0A00A0E1 		mov	r0, r10
 4200              	.LVL498:
 4201 23f4 0910A0E1 		mov	r1, r9
 4202 23f8 FEFFFFEB 		bl	SensorGetControl
 4203              	.LVL499:
1525:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4204              		.loc 1 1525 0
 4205 23fc 88201FE5 		ldr	r2, .L463+64
1526:../uvc.c      **** 						 }
 4206              		.loc 1 1526 0
 4207 2400 0130A0E3 		mov	r3, #1
 4208 2404 A130C4E5 		strb	r3, [r4, #161]
1525:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 4209              		.loc 1 1525 0
 4210 2408 2D05C2E5 		strb	r0, [r2, #1325]
 4211 240c 5FFDFFEA 		b	.L313
 4212              	.LVL500:
 4213              	.L298:
1403:../uvc.c      **** 			 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4214              		.loc 1 1403 0
 4215 2410 0A00A0E1 		mov	r0, r10
 4216              	.LVL501:
 4217 2414 0910A0E1 		mov	r1, r9
 4218 2418 FEFFFFEB 		bl	SensorGetControl
 4219              	.LVL502:
1405:../uvc.c      **** 
 4220              		.loc 1 1405 0
 4221 241c A8501FE5 		ldr	r5, .L463+64
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4222              		.loc 1 1407 0
 4223 2420 0910A0E1 		mov	r1, r9
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4224              		.loc 1 1404 0
 4225 2424 033000E2 		and	r3, r0, #3
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4226              		.loc 1 1407 0
 4227 2428 0B00A0E1 		mov	r0, fp
1404:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4228              		.loc 1 1404 0
 4229 242c 2830C4E5 		strb	r3, [r4, #40]
1405:../uvc.c      **** 
 4230              		.loc 1 1405 0
 4231 2430 1935C5E5 		strb	r3, [r5, #1305]
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4232              		.loc 1 1407 0
 4233 2434 FEFFFFEB 		bl	SensorGetControl
 4234              	.LVL503:
1409:../uvc.c      **** 			 	 		 }
 4235              		.loc 1 1409 0
 4236 2438 0130A0E3 		mov	r3, #1
 4237 243c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4238              	.LVL504:
 4239 2440 B930C4E5 		strb	r3, [r4, #185]
 4240 2444 0070A0E1 		mov	r7, r0
1407:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4241              		.loc 1 1407 0
 4242 2448 2A00C4E5 		strb	r0, [r4, #42]
1408:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4243              		.loc 1 1408 0
 4244 244c 1A05C5E5 		strb	r0, [r5, #1306]
 4245 2450 73FDFFEA 		b	.L299
 4246              	.LVL505:
 4247              	.L400:
2160:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4248              		.loc 1 2160 0
 4249 2454 FEFFFFEB 		bl	_txe_mutex_get
 4250              	.LVL506:
2161:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4251              		.loc 1 2161 0
 4252 2458 18209DE5 		ldr	r2, [sp, #24]
 4253 245c 00208DE5 		str	r2, [sp]
 4254 2460 04208DE5 		str	r2, [sp, #4]
 4255 2464 0A20A0E1 		mov	r2, r10
 4256 2468 BAFDFFEA 		b	.L438
 4257              	.L430:
1848:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4258              		.loc 1 1848 0
 4259 246c F8501FE5 		ldr	r5, .L463+64
1847:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 4260              		.loc 1 1847 0
 4261 2470 0D10C7E5 		strb	r1, [r7, #13]
1848:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4262              		.loc 1 1848 0
 4263 2474 8125D5E5 		ldrb	r2, [r5, #1409]	@ zero_extendqisi2
1849:../uvc.c      **** 							 }
 4264              		.loc 1 1849 0
 4265 2478 0030A0E3 		mov	r3, #0
1848:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4266              		.loc 1 1848 0
 4267 247c 022281E1 		orr	r2, r1, r2, asl #4
 4268 2480 FF2002E2 		and	r2, r2, #255
 4269 2484 18208DE5 		str	r2, [sp, #24]
 4270              	.LVL507:
1849:../uvc.c      **** 							 }
 4271              		.loc 1 1849 0
 4272 2488 18109DE5 		ldr	r1, [sp, #24]
 4273 248c 0A20A0E1 		mov	r2, r10
 4274 2490 0A008DE8 		stmia	sp, {r1, r3}
 4275 2494 0400A0E1 		mov	r0, r4
 4276 2498 1910A0E3 		mov	r1, #25
 4277 249c 0930A0E1 		mov	r3, r9
 4278 24a0 FEFFFFEB 		bl	cmdSet
 4279              	.LVL508:
 4280 24a4 EEFEFFEA 		b	.L362
 4281              	.LVL509:
 4282              	.L452:
2089:../uvc.c      **** 			                         {
 4283              		.loc 1 2089 0
 4284 24a8 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4285 24ac 013043E2 		sub	r3, r3, #1
 4286 24b0 030053E3 		cmp	r3, #3
 4287 24b4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4288 24b8 1CFEFFEA 		b	.L386
 4289              	.L388:
 4290 24bc D8250000 		.word	.L387
 4291 24c0 8C250000 		.word	.L389
 4292 24c4 2C250000 		.word	.L390
 4293 24c8 CC240000 		.word	.L391
 4294              	.L391:
2107:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4295              		.loc 1 2107 0
 4296 24cc 58511FE5 		ldr	r5, .L463+64
 4297 24d0 6C2094E5 		ldr	r2, [r4, #108]
 4298 24d4 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4299 24d8 000052E3 		cmp	r2, #0
 4300 24dc B020A003 		moveq	r2, #176
 4301 24e0 3020A013 		movne	r2, #48
 4302 24e4 032082E1 		orr	r2, r2, r3
 4303 24e8 3010A0E3 		mov	r1, #48
 4304 24ec 5230A0E3 		mov	r3, #82
 4305 24f0 0100A0E3 		mov	r0, #1
 4306 24f4 FEFFFFEB 		bl	SensorSetIrisControl
 4307              	.LVL510:
2108:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4308              		.loc 1 2108 0
 4309 24f8 7D0FA0E3 		mov	r0, #500
 4310 24fc FEFFFFEB 		bl	_tx_thread_sleep
 4311              	.LVL511:
2109:../uvc.c      **** 			                         	default:
 4312              		.loc 1 2109 0
 4313 2500 6C1094E5 		ldr	r1, [r4, #108]
 4314 2504 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4315 2508 000051E3 		cmp	r1, #0
 4316 250c B010A003 		moveq	r1, #176
 4317 2510 3010A013 		movne	r1, #48
 4318 2514 022081E1 		orr	r2, r1, r2
 4319 2518 6C3094E5 		ldr	r3, [r4, #108]
 4320 251c A4111FE5 		ldr	r1, .L463+68
 4321 2520 0400A0E3 		mov	r0, #4
 4322 2524 FEFFFFEB 		bl	CyU3PDebugPrint
 4323              	.LVL512:
 4324 2528 00FEFFEA 		b	.L386
 4325              	.L390:
2102:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4326              		.loc 1 2102 0
 4327 252c B8511FE5 		ldr	r5, .L463+64
 4328 2530 6C2094E5 		ldr	r2, [r4, #108]
 4329 2534 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 4330 2538 000052E3 		cmp	r2, #0
 4331 253c 8020A003 		moveq	r2, #128
 4332 2540 0020A013 		movne	r2, #0
 4333 2544 032082E1 		orr	r2, r2, r3
 4334 2548 3010A0E3 		mov	r1, #48
 4335 254c 5230A0E3 		mov	r3, #82
 4336 2550 0100A0E3 		mov	r0, #1
 4337 2554 FEFFFFEB 		bl	SensorSetIrisControl
 4338              	.LVL513:
2103:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4339              		.loc 1 2103 0
 4340 2558 7D0FA0E3 		mov	r0, #500
 4341 255c FEFFFFEB 		bl	_tx_thread_sleep
 4342              	.LVL514:
2104:../uvc.c      **** 			                         		break;
 4343              		.loc 1 2104 0
 4344 2560 6C1094E5 		ldr	r1, [r4, #108]
 4345 2564 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 4346 2568 000051E3 		cmp	r1, #0
 4347 256c 8010A003 		moveq	r1, #128
 4348 2570 0010A013 		movne	r1, #0
 4349 2574 022081E1 		orr	r2, r1, r2
 4350 2578 6C3094E5 		ldr	r3, [r4, #108]
 4351 257c 04121FE5 		ldr	r1, .L463+68
 4352 2580 0400A0E3 		mov	r0, #4
 4353 2584 FEFFFFEB 		bl	CyU3PDebugPrint
 4354              	.LVL515:
2105:../uvc.c      **** 			                         	case 4: //VGA
 4355              		.loc 1 2105 0
 4356 2588 E8FDFFEA 		b	.L386
 4357              	.L389:
2097:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4358              		.loc 1 2097 0
 4359 258c 6C2094E5 		ldr	r2, [r4, #108]
 4360 2590 3010A0E3 		mov	r1, #48
 4361 2594 000052E3 		cmp	r2, #0
 4362 2598 9220A003 		moveq	r2, #146
 4363 259c 1220A013 		movne	r2, #18
 4364 25a0 5230A0E3 		mov	r3, #82
 4365 25a4 0100A0E3 		mov	r0, #1
 4366 25a8 FEFFFFEB 		bl	SensorSetIrisControl
 4367              	.LVL516:
2098:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4368              		.loc 1 2098 0
 4369 25ac 7D0FA0E3 		mov	r0, #500
 4370 25b0 FEFFFFEB 		bl	_tx_thread_sleep
 4371              	.LVL517:
2099:../uvc.c      **** 			                         		break;
 4372              		.loc 1 2099 0
 4373 25b4 6C2094E5 		ldr	r2, [r4, #108]
 4374 25b8 40121FE5 		ldr	r1, .L463+68
 4375 25bc 000052E3 		cmp	r2, #0
 4376 25c0 6C3094E5 		ldr	r3, [r4, #108]
 4377 25c4 9220A003 		moveq	r2, #146
 4378 25c8 1220A013 		movne	r2, #18
 4379 25cc 0400A0E3 		mov	r0, #4
 4380 25d0 FEFFFFEB 		bl	CyU3PDebugPrint
 4381              	.LVL518:
2100:../uvc.c      **** 			                         	case 3: //720
 4382              		.loc 1 2100 0
 4383 25d4 D5FDFFEA 		b	.L386
 4384              	.L387:
2092:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4385              		.loc 1 2092 0
 4386 25d8 6C2094E5 		ldr	r2, [r4, #108]
 4387 25dc 3010A0E3 		mov	r1, #48
 4388 25e0 000052E3 		cmp	r2, #0
 4389 25e4 A220A003 		moveq	r2, #162
 4390 25e8 2220A013 		movne	r2, #34
 4391 25ec 5230A0E3 		mov	r3, #82
 4392 25f0 0100A0E3 		mov	r0, #1
 4393 25f4 FEFFFFEB 		bl	SensorSetIrisControl
 4394              	.LVL519:
2093:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4395              		.loc 1 2093 0
 4396 25f8 7D0FA0E3 		mov	r0, #500
 4397 25fc FEFFFFEB 		bl	_tx_thread_sleep
 4398              	.LVL520:
2094:../uvc.c      **** 			                         		break;
 4399              		.loc 1 2094 0
 4400 2600 6C2094E5 		ldr	r2, [r4, #108]
 4401 2604 8C121FE5 		ldr	r1, .L463+68
 4402 2608 000052E3 		cmp	r2, #0
 4403 260c 6C3094E5 		ldr	r3, [r4, #108]
 4404 2610 A220A003 		moveq	r2, #162
 4405 2614 2220A013 		movne	r2, #34
 4406 2618 0400A0E3 		mov	r0, #4
 4407 261c FEFFFFEB 		bl	CyU3PDebugPrint
 4408              	.LVL521:
2095:../uvc.c      **** 			                         	case 2: //1080
 4409              		.loc 1 2095 0
 4410 2620 C2FDFFEA 		b	.L386
 4411              	.LVL522:
 4412              	.L369:
1884:../uvc.c      **** 									 dataIdx++;
 4413              		.loc 1 1884 0
 4414 2624 8010A0E3 		mov	r1, #128
 4415 2628 0030A0E3 		mov	r3, #0
 4416 262c 0A008DE8 		stmia	sp, {r1, r3}
 4417 2630 B4021FE5 		ldr	r0, .L463+72
 4418 2634 0A20A0E1 		mov	r2, r10
 4419 2638 0930A0E1 		mov	r3, r9
 4420 263c 1B10A0E3 		mov	r1, #27
 4421 2640 FEFFFFEB 		bl	cmdSet
 4422              	.LVL523:
1886:../uvc.c      **** 								 }
 4423              		.loc 1 1886 0
 4424 2644 18209DE5 		ldr	r2, [sp, #24]
 4425 2648 0110A0E3 		mov	r1, #1
 4426 264c 00208DE5 		str	r2, [sp]
 4427 2650 04108DE5 		str	r1, [sp, #4]
 4428 2654 0B20A0E1 		mov	r2, fp
 4429 2658 0930A0E1 		mov	r3, r9
 4430 265c 1B10A0E3 		mov	r1, #27
 4431 2660 E4021FE5 		ldr	r0, .L463+72
 4432 2664 FEFFFFEB 		bl	cmdSet
 4433              	.LVL524:
 4434 2668 61FEFFEA 		b	.L368
 4435              	.LVL525:
 4436              	.L457:
2172:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4437              		.loc 1 2172 0
 4438 266c 057187E0 		add	r7, r7, r5, asl #2
 4439 2670 207197E5 		ldr	r7, [r7, #288]
 4440 2674 18009DE5 		ldr	r0, [sp, #24]
 4441 2678 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4442 267c 000053E1 		cmp	r3, r0
 4443 2680 1100000A 		beq	.L403
2173:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4444              		.loc 1 2173 0
 4445 2684 08431FE5 		ldr	r4, .L463+72
 4446 2688 0010E0E3 		mvn	r1, #0
 4447 268c 1C0094E5 		ldr	r0, [r4, #28]
 4448 2690 FEFFFFEB 		bl	_txe_mutex_get
 4449              	.LVL526:
2174:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4450              		.loc 1 2174 0
 4451 2694 18109DE5 		ldr	r1, [sp, #24]
 4452 2698 00B0A0E3 		mov	fp, #0
 4453              	.LVL527:
 4454 269c 0A20A0E1 		mov	r2, r10
 4455 26a0 00108DE5 		str	r1, [sp]
 4456 26a4 0930A0E1 		mov	r3, r9
 4457 26a8 0510A0E1 		mov	r1, r5
 4458 26ac 0400A0E1 		mov	r0, r4
 4459 26b0 04B08DE5 		str	fp, [sp, #4]
 4460 26b4 FEFFFFEB 		bl	cmdSet
 4461              	.LVL528:
2175:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4462              		.loc 1 2175 0
 4463 26b8 1C0094E5 		ldr	r0, [r4, #28]
 4464 26bc FEFFFFEB 		bl	_txe_mutex_put
 4465              	.LVL529:
2176:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = 0;
 4466              		.loc 1 2176 0
 4467 26c0 18209DE5 		ldr	r2, [sp, #24]
 4468 26c4 0D20C7E5 		strb	r2, [r7, #13]
2177:../uvc.c      **** 								 }
 4469              		.loc 1 2177 0
 4470 26c8 0EB0C7E5 		strb	fp, [r7, #14]
 4471              	.LVL530:
 4472              	.L403:
2179:../uvc.c      **** 			 	 			 }else if(Len == 4){
 4473              		.loc 1 2179 0
 4474 26cc 0130A0E3 		mov	r3, #1
 4475 26d0 1130C7E5 		strb	r3, [r7, #17]
 4476 26d4 C4FEFFEA 		b	.L404
 4477              	.LVL531:
 4478              	.L453:
1602:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4479              		.loc 1 1602 0
 4480 26d8 005187E0 		add	r5, r7, r0, asl #2
 4481 26dc 203195E5 		ldr	r3, [r5, #288]
 4482              	.L433:
 4483 26e0 0DA0D3E5 		ldrb	r10, [r3, #13]	@ zero_extendqisi2
 4484              	.LVL532:
 4485 26e4 0090A0E3 		mov	r9, #0
 4486              	.LVL533:
 4487 26e8 FFA00AE2 		and	r10, r10, #255
 4488 26ec 28A0C4E5 		strb	r10, [r4, #40]
1603:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4489              		.loc 1 1603 0
 4490 26f0 0E70D3E5 		ldrb	r7, [r3, #14]	@ zero_extendqisi2
 4491 26f4 FF7007E2 		and	r7, r7, #255
 4492 26f8 2970C4E5 		strb	r7, [r4, #41]
 4493              	.LVL534:
 4494 26fc 6AFCFFEA 		b	.L292
 4495              	.LVL535:
 4496              	.L455:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4497              		.loc 1 1469 0
 4498 2700 005187E0 		add	r5, r7, r0, asl #2
 4499 2704 203015E5 		ldr	r3, [r5, #-32]
 4500 2708 F4FFFFEA 		b	.L433
 4501              	.LVL536:
 4502              	.L458:
1984:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4503              		.loc 1 1984 0
 4504 270c 033187E0 		add	r3, r7, r3, asl #2
 4505 2710 207093E5 		ldr	r7, [r3, #32]
 4506 2714 18109DE5 		ldr	r1, [sp, #24]
 4507 2718 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4508 271c 010053E1 		cmp	r3, r1
 4509 2720 E9FFFF0A 		beq	.L403
1985:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 4510              		.loc 1 1985 0
 4511 2724 A8431FE5 		ldr	r4, .L463+72
 4512 2728 0010E0E3 		mvn	r1, #0
 4513 272c 1C0094E5 		ldr	r0, [r4, #28]
 4514 2730 FEFFFFEB 		bl	_txe_mutex_get
 4515              	.LVL537:
1986:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4516              		.loc 1 1986 0
 4517 2734 18209DE5 		ldr	r2, [sp, #24]
 4518 2738 00B0A0E3 		mov	fp, #0
 4519              	.LVL538:
 4520 273c 0930A0E1 		mov	r3, r9
 4521 2740 00208DE5 		str	r2, [sp]
 4522 2744 0510A0E1 		mov	r1, r5
 4523 2748 0A20A0E1 		mov	r2, r10
 4524 274c 0400A0E1 		mov	r0, r4
 4525 2750 04B08DE5 		str	fp, [sp, #4]
 4526 2754 FEFFFFEB 		bl	cmdSet
 4527              	.LVL539:
1987:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 4528              		.loc 1 1987 0
 4529 2758 1C0094E5 		ldr	r0, [r4, #28]
 4530 275c FEFFFFEB 		bl	_txe_mutex_put
 4531              	.LVL540:
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 4532              		.loc 1 1988 0
 4533 2760 18309DE5 		ldr	r3, [sp, #24]
 4534 2764 0D30C7E5 		strb	r3, [r7, #13]
1989:../uvc.c      **** 									 }
 4535              		.loc 1 1989 0
 4536 2768 0EB0C7E5 		strb	fp, [r7, #14]
 4537              	.LVL541:
 4538 276c D6FFFFEA 		b	.L403
 4539              	.LVL542:
 4540              	.L454:
1607:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4541              		.loc 1 1607 0
 4542 2770 005187E0 		add	r5, r7, r0, asl #2
 4543 2774 202195E5 		ldr	r2, [r5, #288]
 4544 2778 BCFDFFEA 		b	.L434
 4545              	.LVL543:
 4546              	.L405:
2181:../uvc.c      **** 								 if(pPUCSenCtrl[CtrlID]->UVCCurVLo != Data0)
 4547              		.loc 1 2181 0
 4548 277c 00441FE5 		ldr	r4, .L463+72
 4549 2780 0010E0E3 		mvn	r1, #0
 4550 2784 1C0094E5 		ldr	r0, [r4, #28]
 4551 2788 FEFFFFEB 		bl	_txe_mutex_get
 4552              	.LVL544:
2182:../uvc.c      **** 								 {
 4553              		.loc 1 2182 0
 4554 278c 057187E0 		add	r7, r7, r5, asl #2
 4555 2790 207197E5 		ldr	r7, [r7, #288]
 4556              	.L444:
 4557 2794 0D30D7E5 		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 4558 2798 18009DE5 		ldr	r0, [sp, #24]
 4559 279c 000053E1 		cmp	r3, r0
2185:../uvc.c      **** 									 dataIdx++;
 4560              		.loc 1 2185 0
 4561 27a0 0030A0E3 		mov	r3, #0
2182:../uvc.c      **** 								 {
 4562              		.loc 1 2182 0
 4563 27a4 0700000A 		beq	.L406
2184:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 4564              		.loc 1 2184 0
 4565 27a8 0D00C7E5 		strb	r0, [r7, #13]
 4566              	.LVL545:
2185:../uvc.c      **** 									 dataIdx++;
 4567              		.loc 1 2185 0
 4568 27ac 0A20A0E1 		mov	r2, r10
 4569 27b0 09008DE8 		stmia	sp, {r0, r3}
 4570 27b4 0510A0E1 		mov	r1, r5
 4571 27b8 0930A0E1 		mov	r3, r9
 4572 27bc 0400A0E1 		mov	r0, r4
 4573 27c0 FEFFFFEB 		bl	cmdSet
 4574              	.LVL546:
2186:../uvc.c      **** 								 }
 4575              		.loc 1 2186 0
 4576 27c4 0130A0E3 		mov	r3, #1
 4577              	.LVL547:
 4578              	.L406:
2188:../uvc.c      **** 									 pPUCSenCtrl[CtrlID]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 4579              		.loc 1 2188 0
 4580 27c8 0E20D7E5 		ldrb	r2, [r7, #14]	@ zero_extendqisi2
 4581 27cc 1C109DE5 		ldr	r1, [sp, #28]
 4582 27d0 010052E1 		cmp	r2, r1
 4583 27d4 0700000A 		beq	.L407
2189:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 4584              		.loc 1 2189 0
 4585 27d8 0E10C7E5 		strb	r1, [r7, #14]
2190:../uvc.c      **** 								 }
 4586              		.loc 1 2190 0
 4587 27dc 1C209DE5 		ldr	r2, [sp, #28]
 4588 27e0 0510A0E1 		mov	r1, r5
 4589 27e4 0C008DE8 		stmia	sp, {r2, r3}
 4590 27e8 6C041FE5 		ldr	r0, .L463+72
 4591 27ec 0B20A0E1 		mov	r2, fp
 4592 27f0 0930A0E1 		mov	r3, r9
 4593              	.LVL548:
 4594 27f4 FEFFFFEB 		bl	cmdSet
 4595              	.LVL549:
 4596              	.L407:
2192:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4597              		.loc 1 2192 0
 4598 27f8 0130A0E3 		mov	r3, #1
 4599 27fc 1130C7E5 		strb	r3, [r7, #17]
2193:../uvc.c      **** 
 4600              		.loc 1 2193 0
 4601 2800 1C0094E5 		ldr	r0, [r4, #28]
 4602 2804 FEFFFFEB 		bl	_txe_mutex_put
 4603              	.LVL550:
 4604 2808 77FEFFEA 		b	.L404
 4605              	.LVL551:
 4606              	.L461:
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4607              		.loc 1 1617 0
 4608 280c 0B00A0E1 		mov	r0, fp
 4609              	.LVL552:
 4610 2810 0910A0E1 		mov	r1, r9
 4611 2814 14308DE5 		str	r3, [sp, #20]
 4612 2818 FEFFFFEB 		bl	SensorGetControl
 4613              	.LVL553:
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4614              		.loc 1 1618 0
 4615 281c 057187E0 		add	r7, r7, r5, asl #2
 4616 2820 202197E5 		ldr	r2, [r7, #288]
1617:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4617              		.loc 1 1617 0
 4618 2824 2800C4E5 		strb	r0, [r4, #40]
1618:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4619              		.loc 1 1618 0
 4620 2828 0D00C2E5 		strb	r0, [r2, #13]
 4621 282c 14309DE5 		ldr	r3, [sp, #20]
 4622 2830 00A0A0E1 		mov	r10, r0
 4623              	.LVL554:
1619:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[1];
 4624              		.loc 1 1619 0
 4625 2834 2930C4E5 		strb	r3, [r4, #41]
 4626 2838 0370A0E1 		mov	r7, r3
1620:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4627              		.loc 1 1620 0
 4628 283c 0E30C2E5 		strb	r3, [r2, #14]
 4629              	.LVL555:
 4630 2840 96FEFFEA 		b	.L325
 4631              	.LVL556:
 4632              	.L456:
1855:../uvc.c      **** 								 }
 4633              		.loc 1 1855 0
 4634 2844 0110A0E3 		mov	r1, #1
 4635 2848 00208DE5 		str	r2, [sp]
 4636 284c 04108DE5 		str	r1, [sp, #4]
 4637 2850 0B20A0E1 		mov	r2, fp
 4638 2854 0930A0E1 		mov	r3, r9
 4639 2858 1910A0E3 		mov	r1, #25
 4640 285c E0041FE5 		ldr	r0, .L463+72
 4641 2860 FEFFFFEB 		bl	cmdSet
 4642              	.LVL557:
 4643 2864 08FEFFEA 		b	.L364
 4644              	.LVL558:
 4645              	.L374:
1993:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 4646              		.loc 1 1993 0
 4647 2868 EC441FE5 		ldr	r4, .L463+72
 4648 286c 0010E0E3 		mvn	r1, #0
 4649 2870 1C0094E5 		ldr	r0, [r4, #28]
 4650 2874 14308DE5 		str	r3, [sp, #20]
 4651 2878 FEFFFFEB 		bl	_txe_mutex_get
 4652              	.LVL559:
1994:../uvc.c      **** 									 {
 4653              		.loc 1 1994 0
 4654 287c 14309DE5 		ldr	r3, [sp, #20]
 4655 2880 033187E0 		add	r3, r7, r3, asl #2
 4656 2884 207093E5 		ldr	r7, [r3, #32]
 4657 2888 C1FFFFEA 		b	.L444
 4658              	.LVL560:
 4659              	.L459:
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4660              		.loc 1 1484 0
 4661 288c 0B00A0E1 		mov	r0, fp
 4662              	.LVL561:
 4663 2890 0910A0E1 		mov	r1, r9
 4664 2894 14308DE5 		str	r3, [sp, #20]
 4665 2898 FEFFFFEB 		bl	SensorGetControl
 4666              	.LVL562:
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4667              		.loc 1 1485 0
 4668 289c 057187E0 		add	r7, r7, r5, asl #2
 4669 28a0 202017E5 		ldr	r2, [r7, #-32]
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4670              		.loc 1 1484 0
 4671 28a4 2800C4E5 		strb	r0, [r4, #40]
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4672              		.loc 1 1485 0
 4673 28a8 0D00C2E5 		strb	r0, [r2, #13]
 4674 28ac 14309DE5 		ldr	r3, [sp, #20]
 4675 28b0 00A0A0E1 		mov	r10, r0
 4676              	.LVL563:
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 4677              		.loc 1 1486 0
 4678 28b4 2930C4E5 		strb	r3, [r4, #41]
 4679 28b8 0370A0E1 		mov	r7, r3
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4680              		.loc 1 1487 0
 4681 28bc 0E30C2E5 		strb	r3, [r2, #14]
 4682              	.LVL564:
 4683 28c0 6BFEFFEA 		b	.L305
 4684              	.LVL565:
 4685              	.L462:
1624:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4686              		.loc 1 1624 0
 4687 28c4 0B00A0E1 		mov	r0, fp
 4688              	.LVL566:
 4689 28c8 0910A0E1 		mov	r1, r9
 4690 28cc 14308DE5 		str	r3, [sp, #20]
 4691 28d0 FEFFFFEB 		bl	SensorGetControl
 4692              	.LVL567:
1625:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4693              		.loc 1 1625 0
 4694 28d4 057187E0 		add	r7, r7, r5, asl #2
 4695 28d8 20B197E5 		ldr	fp, [r7, #288]
 4696              	.LVL568:
1624:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4697              		.loc 1 1624 0
 4698 28dc 0010A0E1 		mov	r1, r0
 4699 28e0 2800C4E5 		strb	r0, [r4, #40]
1626:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4700              		.loc 1 1626 0
 4701 28e4 0A00A0E1 		mov	r0, r10
1625:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4702              		.loc 1 1625 0
 4703 28e8 0D10CBE5 		strb	r1, [fp, #13]
1626:../uvc.c      **** 			 	 				 pPUCSenCtrl[CtrlID]->UVCCurVHi = glEp0Buffer[2];
 4704              		.loc 1 1626 0
 4705 28ec 0910A0E1 		mov	r1, r9
 4706 28f0 FEFFFFEB 		bl	SensorGetControl
 4707              	.LVL569:
 4708 28f4 2A00C4E5 		strb	r0, [r4, #42]
1627:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4709              		.loc 1 1627 0
 4710 28f8 0E00CBE5 		strb	r0, [fp, #14]
1628:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4711              		.loc 1 1628 0
 4712 28fc 14309DE5 		ldr	r3, [sp, #20]
 4713 2900 0070A0E1 		mov	r7, r0
 4714 2904 2930C4E5 		strb	r3, [r4, #41]
1629:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4715              		.loc 1 1629 0
 4716 2908 2B30C4E5 		strb	r3, [r4, #43]
 4717              	.LVL570:
 4718 290c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4719 2910 62FEFFEA 		b	.L325
 4720              	.LVL571:
 4721              	.L460:
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4722              		.loc 1 1491 0
 4723 2914 0B00A0E1 		mov	r0, fp
 4724              	.LVL572:
 4725 2918 0910A0E1 		mov	r1, r9
 4726 291c 14308DE5 		str	r3, [sp, #20]
 4727 2920 FEFFFFEB 		bl	SensorGetControl
 4728              	.LVL573:
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4729              		.loc 1 1492 0
 4730 2924 057187E0 		add	r7, r7, r5, asl #2
 4731 2928 20B017E5 		ldr	fp, [r7, #-32]
 4732              	.LVL574:
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4733              		.loc 1 1491 0
 4734 292c 0010A0E1 		mov	r1, r0
 4735 2930 2800C4E5 		strb	r0, [r4, #40]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4736              		.loc 1 1493 0
 4737 2934 0A00A0E1 		mov	r0, r10
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 4738              		.loc 1 1492 0
 4739 2938 0D10CBE5 		strb	r1, [fp, #13]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4740              		.loc 1 1493 0
 4741 293c 0910A0E1 		mov	r1, r9
 4742 2940 FEFFFFEB 		bl	SensorGetControl
 4743              	.LVL575:
 4744 2944 2A00C4E5 		strb	r0, [r4, #42]
1494:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 4745              		.loc 1 1494 0
 4746 2948 0E00CBE5 		strb	r0, [fp, #14]
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 4747              		.loc 1 1495 0
 4748 294c 14309DE5 		ldr	r3, [sp, #20]
 4749 2950 0070A0E1 		mov	r7, r0
 4750 2954 2930C4E5 		strb	r3, [r4, #41]
1496:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 4751              		.loc 1 1496 0
 4752 2958 2B30C4E5 		strb	r3, [r4, #43]
 4753              	.LVL576:
 4754 295c 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4755 2960 43FEFFEA 		b	.L305
 4756              		.cfi_endproc
 4757              	.LFE3:
 4759              		.align	2
 4760              		.global	CTControlHandle
 4762              	CTControlHandle:
 4763              	.LFB4:
2218:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4764              		.loc 1 2218 0
 4765              		.cfi_startproc
 4766              		@ args = 0, pretend = 0, frame = 24
 4767              		@ frame_needed = 0, uses_anonymous_args = 0
 4768              	.LVL577:
 4769 2964 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4770              	.LCFI19:
 4771              		.cfi_def_cfa_offset 36
 4772              		.cfi_offset 4, -36
 4773              		.cfi_offset 5, -32
 4774              		.cfi_offset 6, -28
 4775              		.cfi_offset 7, -24
 4776              		.cfi_offset 8, -20
 4777              		.cfi_offset 9, -16
 4778              		.cfi_offset 10, -12
 4779              		.cfi_offset 11, -8
 4780              		.cfi_offset 14, -4
2237:../uvc.c      **** 
 4781              		.loc 1 2237 0
 4782 2968 28B89FE5 		ldr	fp, .L503
2229:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4783              		.loc 1 2229 0
 4784 296c 28389FE5 		ldr	r3, .L503+4
2237:../uvc.c      **** 
 4785              		.loc 1 2237 0
 4786 2970 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
2229:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4787              		.loc 1 2229 0
 4788 2974 8080A0E1 		mov	r8, r0, asl #1
 4789 2978 002088E0 		add	r2, r8, r0
 4790 297c 822183E0 		add	r2, r3, r2, asl #3
2239:../uvc.c      **** 		 {
 4791              		.loc 1 2239 0
 4792 2980 830055E3 		cmp	r5, #131
2218:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4793              		.loc 1 2218 0
 4794 2984 34D04DE2 		sub	sp, sp, #52
 4795              	.LCFI20:
 4796              		.cfi_def_cfa_offset 88
2218:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 4797              		.loc 1 2218 0
 4798 2988 0060A0E1 		mov	r6, r0
2229:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4799              		.loc 1 2229 0
 4800 298c BF95D2E5 		ldrb	r9, [r2, #1471]	@ zero_extendqisi2
 4801              	.LVL578:
2230:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 4802              		.loc 1 2230 0
 4803 2990 B0A5D2E5 		ldrb	r10, [r2, #1456]	@ zero_extendqisi2
 4804              	.LVL579:
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 4805              		.loc 1 2232 0
 4806 2994 B275D2E5 		ldrb	r7, [r2, #1458]	@ zero_extendqisi2
 4807              	.LVL580:
2239:../uvc.c      **** 		 {
 4808              		.loc 1 2239 0
 4809 2998 8000000A 		beq	.L467
 4810 299c 2600009A 		bls	.L501
 4811 29a0 850055E3 		cmp	r5, #133
 4812 29a4 7200000A 		beq	.L472
 4813 29a8 5000003A 		bcc	.L473
 4814 29ac 860055E3 		cmp	r5, #134
 4815 29b0 4300000A 		beq	.L474
 4816 29b4 870055E3 		cmp	r5, #135
 4817 29b8 5F00001A 		bne	.L466
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4818              		.loc 1 2301 0
 4819 29bc BBC5D2E5 		ldrb	ip, [r2, #1467]	@ zero_extendqisi2
 4820 29c0 D8479FE5 		ldr	r4, .L503+8
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4821              		.loc 1 2302 0
 4822 29c4 BC25D2E5 		ldrb	r2, [r2, #1468]	@ zero_extendqisi2
 4823              	.LVL581:
 4824              	.L500:
2279:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4825              		.loc 1 2279 0
 4826 29c8 0A1056E2 		subs	r1, r6, #10
 4827 29cc 006071E2 		rsbs	r6, r1, #0
 4828 29d0 0160B6E0 		adcs	r6, r6, r1
2281:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4829              		.loc 1 2281 0
 4830 29d4 0030A0E3 		mov	r3, #0
 4831              	.LVL582:
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4832              		.loc 1 2282 0
 4833 29d8 281084E2 		add	r1, r4, #40
 4834 29dc 0700A0E1 		mov	r0, r7
 4835              	.LVL583:
2279:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4836              		.loc 1 2279 0
 4837 29e0 2A60C4E5 		strb	r6, [r4, #42]
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4838              		.loc 1 2277 0
 4839 29e4 28C0C4E5 		strb	ip, [r4, #40]
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4840              		.loc 1 2278 0
 4841 29e8 2920C4E5 		strb	r2, [r4, #41]
2281:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4842              		.loc 1 2281 0
 4843 29ec 2B30C4E5 		strb	r3, [r4, #43]
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4844              		.loc 1 2282 0
 4845 29f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4846              	.LVL584:
 4847 29f4 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2284:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 4848              		.loc 1 2284 0
 4849 29f8 FF80A0E3 		mov	r8, #255
 4850 29fc 0860A0E1 		mov	r6, r8
 4851              	.LVL585:
 4852              	.L476:
2452:../uvc.c      **** }
 4853              		.loc 1 2452 0
 4854 2a00 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 4855 2a04 FFC0A0E3 		mov	ip, #255
 4856 2a08 04108DE5 		str	r1, [sp, #4]
 4857 2a0c 10108DE5 		str	r1, [sp, #16]
 4858 2a10 08008DE5 		str	r0, [sp, #8]
 4859 2a14 00808DE5 		str	r8, [sp]
 4860 2a18 14708DE5 		str	r7, [sp, #20]
 4861 2a1c 0520A0E1 		mov	r2, r5
 4862 2a20 0630A0E1 		mov	r3, r6
 4863 2a24 0CC08DE5 		str	ip, [sp, #12]
 4864 2a28 74179FE5 		ldr	r1, .L503+12
 4865 2a2c 0400A0E3 		mov	r0, #4
 4866 2a30 FEFFFFEB 		bl	CyU3PDebugPrint
 4867              	.LVL586:
2453:../uvc.c      **** 
 4868              		.loc 1 2453 0
 4869 2a34 34D08DE2 		add	sp, sp, #52
 4870              		@ sp needed
 4871 2a38 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4872              	.LVL587:
 4873              	.L501:
2239:../uvc.c      **** 		 {
 4874              		.loc 1 2239 0
 4875 2a3c 810055E3 		cmp	r5, #129
 4876 2a40 2E00000A 		beq	.L469
 4877 2a44 1A00008A 		bhi	.L470
 4878 2a48 010055E3 		cmp	r5, #1
 4879 2a4c 3A00001A 		bne	.L466
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 4880              		.loc 1 2310 0
 4881 2a50 48479FE5 		ldr	r4, .L503+8
 4882 2a54 2E208DE2 		add	r2, sp, #46
 4883              	.LVL588:
 4884 2a58 2000A0E3 		mov	r0, #32
 4885              	.LVL589:
 4886 2a5c 281084E2 		add	r1, r4, #40
 4887 2a60 18308DE5 		str	r3, [sp, #24]
 4888 2a64 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4889              	.LVL590:
2312:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4890              		.loc 1 2312 0
 4891 2a68 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
2316:../uvc.c      **** 			  {
 4892              		.loc 1 2316 0
 4893 2a6c 012046E2 		sub	r2, r6, #1
2312:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4894              		.loc 1 2312 0
 4895 2a70 1CC08DE5 		str	ip, [sp, #28]
 4896              	.LVL591:
2313:../uvc.c      **** 			  value = Data1;
 4897              		.loc 1 2313 0
 4898 2a74 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
2316:../uvc.c      **** 			  {
 4899              		.loc 1 2316 0
 4900 2a78 18309DE5 		ldr	r3, [sp, #24]
2313:../uvc.c      **** 			  value = Data1;
 4901              		.loc 1 2313 0
 4902 2a7c 20C08DE5 		str	ip, [sp, #32]
 4903              	.LVL592:
2316:../uvc.c      **** 			  {
 4904              		.loc 1 2316 0
 4905 2a80 090052E3 		cmp	r2, #9
 4906 2a84 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4907 2a88 1D0100EA 		b	.L477
 4908              	.L479:
 4909 2a8c BC2E0000 		.word	.L478
 4910 2a90 042F0000 		.word	.L477
 4911 2a94 BC2C0000 		.word	.L480
 4912 2a98 042F0000 		.word	.L477
 4913 2a9c 042F0000 		.word	.L477
 4914 2aa0 042F0000 		.word	.L477
 4915 2aa4 2C2C0000 		.word	.L481
 4916 2aa8 042F0000 		.word	.L477
 4917 2aac 042F0000 		.word	.L477
 4918 2ab0 B02B0000 		.word	.L482
 4919              	.LVL593:
 4920              	.L470:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4921              		.loc 1 2268 0
 4922 2ab4 B3C5D2E5 		ldrb	ip, [r2, #1459]	@ zero_extendqisi2
 4923 2ab8 E0469FE5 		ldr	r4, .L503+8
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4924              		.loc 1 2269 0
 4925 2abc B425D2E5 		ldrb	r2, [r2, #1460]	@ zero_extendqisi2
 4926              	.LVL594:
 4927 2ac0 C0FFFFEA 		b	.L500
 4928              	.LVL595:
 4929              	.L474:
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4930              		.loc 1 2295 0
 4931 2ac4 D4469FE5 		ldr	r4, .L503+8
 4932 2ac8 B935D2E5 		ldrb	r3, [r2, #1465]	@ zero_extendqisi2
 4933 2acc 0410A0E1 		mov	r1, r4
 4934 2ad0 2830E1E5 		strb	r3, [r1, #40]!
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4935              		.loc 1 2296 0
 4936 2ad4 0100A0E3 		mov	r0, #1
 4937              	.LVL596:
2299:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4938              		.loc 1 2299 0
 4939 2ad8 FF80A0E3 		mov	r8, #255
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 4940              		.loc 1 2296 0
 4941 2adc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4942              	.LVL597:
2299:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 4943              		.loc 1 2299 0
 4944 2ae0 0860A0E1 		mov	r6, r8
 4945 2ae4 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 4946 2ae8 0170A0E3 		mov	r7, #1
 4947 2aec C3FFFFEA 		b	.L476
 4948              	.LVL598:
 4949              	.L473:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4950              		.loc 1 2286 0
 4951 2af0 B7C5D2E5 		ldrb	ip, [r2, #1463]	@ zero_extendqisi2
 4952 2af4 A4469FE5 		ldr	r4, .L503+8
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4953              		.loc 1 2287 0
 4954 2af8 B825D2E5 		ldrb	r2, [r2, #1464]	@ zero_extendqisi2
 4955              	.LVL599:
 4956 2afc B1FFFFEA 		b	.L500
 4957              	.LVL600:
 4958              	.L469:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4959              		.loc 1 2253 0
 4960 2b00 98469FE5 		ldr	r4, .L503+8
 4961 2b04 BD95D2E5 		ldrb	r9, [r2, #1469]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4962              		.loc 1 2254 0
 4963 2b08 BEC5D2E5 		ldrb	ip, [r2, #1470]	@ zero_extendqisi2
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4964              		.loc 1 2255 0
 4965 2b0c 0030A0E3 		mov	r3, #0
2261:../uvc.c      **** 
 4966              		.loc 1 2261 0
 4967 2b10 281084E2 		add	r1, r4, #40
 4968 2b14 0700A0E1 		mov	r0, r7
 4969              	.LVL601:
2266:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4970              		.loc 1 2266 0
 4971 2b18 FF80A0E3 		mov	r8, #255
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4972              		.loc 1 2254 0
 4973 2b1c 29C0C4E5 		strb	ip, [r4, #41]
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4974              		.loc 1 2253 0
 4975 2b20 2890C4E5 		strb	r9, [r4, #40]
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4976              		.loc 1 2255 0
 4977 2b24 2A30C4E5 		strb	r3, [r4, #42]
2256:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 4978              		.loc 1 2256 0
 4979 2b28 2B30C4E5 		strb	r3, [r4, #43]
 4980              	.LVL602:
2266:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4981              		.loc 1 2266 0
 4982 2b2c 0860A0E1 		mov	r6, r8
 4983              	.LVL603:
2261:../uvc.c      **** 
 4984              		.loc 1 2261 0
 4985 2b30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4986              	.LVL604:
 4987 2b34 0900A0E1 		mov	r0, r9
2266:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 4988              		.loc 1 2266 0
 4989 2b38 B0FFFFEA 		b	.L476
 4990              	.LVL605:
 4991              	.L466:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4992              		.loc 1 2446 0
 4993 2b3c 0000A0E3 		mov	r0, #0
 4994              	.LVL606:
 4995 2b40 0020A0E1 		mov	r2, r0
 4996              	.LVL607:
 4997 2b44 0110A0E3 		mov	r1, #1
 4998 2b48 FEFFFFEB 		bl	CyU3PUsbStall
 4999              	.LVL608:
2447:../uvc.c      **** 			  break;
 5000              		.loc 1 2447 0
 5001 2b4c 0620A0E1 		mov	r2, r6
 5002 2b50 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5003 2b54 0400A0E3 		mov	r0, #4
 5004 2b58 48169FE5 		ldr	r1, .L503+16
 5005 2b5c FEFFFFEB 		bl	CyU3PDebugPrint
 5006              	.LVL609:
2448:../uvc.c      **** 		 }
 5007              		.loc 1 2448 0
 5008 2b60 FF00A0E3 		mov	r0, #255
 5009 2b64 34469FE5 		ldr	r4, .L503+8
 5010 2b68 0080A0E1 		mov	r8, r0
 5011 2b6c 0060A0E1 		mov	r6, r0
 5012 2b70 A2FFFFEA 		b	.L476
 5013              	.LVL610:
 5014              	.L472:
2243:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5015              		.loc 1 2243 0
 5016 2b74 24469FE5 		ldr	r4, .L503+8
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5017              		.loc 1 2244 0
 5018 2b78 0030A0E3 		mov	r3, #0
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5019              		.loc 1 2245 0
 5020 2b7c 281084E2 		add	r1, r4, #40
 5021 2b80 0200A0E3 		mov	r0, #2
 5022              	.LVL611:
2247:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5023              		.loc 1 2247 0
 5024 2b84 FF80A0E3 		mov	r8, #255
2243:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5025              		.loc 1 2243 0
 5026 2b88 2870C4E5 		strb	r7, [r4, #40]
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5027              		.loc 1 2244 0
 5028 2b8c 2930C4E5 		strb	r3, [r4, #41]
2247:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5029              		.loc 1 2247 0
 5030 2b90 0860A0E1 		mov	r6, r8
 5031              	.LVL612:
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5032              		.loc 1 2245 0
 5033 2b94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5034              	.LVL613:
 5035 2b98 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
2247:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5036              		.loc 1 2247 0
 5037 2b9c 97FFFFEA 		b	.L476
 5038              	.LVL614:
 5039              	.L467:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5040              		.loc 1 2277 0
 5041 2ba0 B5C5D2E5 		ldrb	ip, [r2, #1461]	@ zero_extendqisi2
 5042 2ba4 F4459FE5 		ldr	r4, .L503+8
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5043              		.loc 1 2278 0
 5044 2ba8 B625D2E5 		ldrb	r2, [r2, #1462]	@ zero_extendqisi2
 5045              	.LVL615:
 5046 2bac 85FFFFEA 		b	.L500
 5047              	.LVL616:
 5048              	.L482:
2425:../uvc.c      **** 					  if(getData == 1)
 5049              		.loc 1 2425 0
 5050 2bb0 F4659FE5 		ldr	r6, .L503+20
 5051 2bb4 0010E0E3 		mvn	r1, #0
 5052 2bb8 1C0096E5 		ldr	r0, [r6, #28]
 5053 2bbc FEFFFFEB 		bl	_txe_mutex_get
 5054              	.LVL617:
2426:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5055              		.loc 1 2426 0
 5056 2bc0 1CC09DE5 		ldr	ip, [sp, #28]
 5057 2bc4 01005CE3 		cmp	ip, #1
2427:../uvc.c      **** 					  else if(getData == 0xff)
 5058              		.loc 1 2427 0
 5059 2bc8 0400A003 		moveq	r0, #4
2426:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5060              		.loc 1 2426 0
 5061 2bcc 6901000A 		beq	.L499
2428:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5062              		.loc 1 2428 0
 5063 2bd0 FF005CE3 		cmp	ip, #255
 5064 2bd4 6601000A 		beq	.L502
2431:../uvc.c      **** 					  //dataIdx++;
 5065              		.loc 1 2431 0
 5066 2bd8 0010A0E3 		mov	r1, #0
 5067 2bdc 00108DE5 		str	r1, [sp]
 5068 2be0 04108DE5 		str	r1, [sp, #4]
 5069 2be4 0A20A0E1 		mov	r2, r10
 5070 2be8 0930A0E1 		mov	r3, r9
 5071 2bec 0600A0E1 		mov	r0, r6
 5072 2bf0 2310A0E3 		mov	r1, #35
 5073 2bf4 FEFFFFEB 		bl	cmdSet
 5074              	.LVL618:
 5075              	.L494:
2434:../uvc.c      **** #endif
 5076              		.loc 1 2434 0
 5077 2bf8 1C0096E5 		ldr	r0, [r6, #28]
 5078 2bfc FEFFFFEB 		bl	_txe_mutex_put
 5079              	.LVL619:
2436:../uvc.c      **** 					  break;
 5080              		.loc 1 2436 0
 5081 2c00 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5082 2c04 1C609DE5 		ldr	r6, [sp, #28]
 5083 2c08 20809DE5 		ldr	r8, [sp, #32]
 5084 2c0c 00108DE5 		str	r1, [sp]
 5085 2c10 0620A0E1 		mov	r2, r6
 5086 2c14 0830A0E1 		mov	r3, r8
 5087 2c18 0400A0E3 		mov	r0, #4
 5088 2c1c 8C159FE5 		ldr	r1, .L503+24
 5089 2c20 FEFFFFEB 		bl	CyU3PDebugPrint
 5090              	.LVL620:
2437:../uvc.c      **** 
 5091              		.loc 1 2437 0
 5092 2c24 FF00A0E3 		mov	r0, #255
 5093 2c28 74FFFFEA 		b	.L476
 5094              	.LVL621:
 5095              	.L481:
2402:../uvc.c      **** 					  {
 5096              		.loc 1 2402 0
 5097 2c2c D505D3E5 		ldrb	r0, [r3, #1493]	@ zero_extendqisi2
 5098 2c30 64C59FE5 		ldr	ip, .L503+4
 5099 2c34 010050E3 		cmp	r0, #1
 5100 2c38 08005013 		cmpne	r0, #8
 5101 2c3c 0000A013 		movne	r0, #0
 5102 2c40 0100A003 		moveq	r0, #1
 5103 2c44 4601001A 		bne	.L491
 5104              	.LVL622:
2405:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5105              		.loc 1 2405 0
 5106 2c48 5CB59FE5 		ldr	fp, .L503+20
 5107 2c4c 0010E0E3 		mvn	r1, #0
 5108 2c50 1C009BE5 		ldr	r0, [fp, #28]
 5109 2c54 18C08DE5 		str	ip, [sp, #24]
 5110 2c58 FEFFFFEB 		bl	_txe_mutex_get
 5111              	.LVL623:
2406:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5112              		.loc 1 2406 0
 5113 2c5c 1C009DE5 		ldr	r0, [sp, #28]
 5114 2c60 0010A0E3 		mov	r1, #0
 5115 2c64 0A20A0E1 		mov	r2, r10
 5116 2c68 0930A0E1 		mov	r3, r9
 5117 2c6c 00008DE5 		str	r0, [sp]
 5118 2c70 04108DE5 		str	r1, [sp, #4]
 5119 2c74 0B00A0E1 		mov	r0, fp
 5120 2c78 2210A0E3 		mov	r1, #34
 5121 2c7c FEFFFFEB 		bl	cmdSet
 5122              	.LVL624:
2407:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5123              		.loc 1 2407 0
 5124 2c80 1C009BE5 		ldr	r0, [fp, #28]
 5125 2c84 FEFFFFEB 		bl	_txe_mutex_put
 5126              	.LVL625:
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5127              		.loc 1 2410 0
 5128 2c88 18C09DE5 		ldr	ip, [sp, #24]
 5129 2c8c 1C109DE5 		ldr	r1, [sp, #28]
2411:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5130              		.loc 1 2411 0
 5131 2c90 20209DE5 		ldr	r2, [sp, #32]
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5132              		.loc 1 2410 0
 5133 2c94 066088E0 		add	r6, r8, r6
 5134 2c98 86C18CE0 		add	ip, ip, r6, asl #3
2412:../uvc.c      **** 					  }else{
 5135              		.loc 1 2412 0
 5136 2c9c 0130A0E3 		mov	r3, #1
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5137              		.loc 1 2410 0
 5138 2ca0 BD15CCE5 		strb	r1, [ip, #1469]
2411:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5139              		.loc 1 2411 0
 5140 2ca4 BE25CCE5 		strb	r2, [ip, #1470]
2412:../uvc.c      **** 					  }else{
 5141              		.loc 1 2412 0
 5142 2ca8 C035CCE5 		strb	r3, [ip, #1472]
 5143              	.LVL626:
 5144              	.L492:
 5145 2cac 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5146 2cb0 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
2419:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5147              		.loc 1 2419 0
 5148 2cb4 FF00A0E3 		mov	r0, #255
 5149 2cb8 50FFFFEA 		b	.L476
 5150              	.LVL627:
 5151              	.L480:
2368:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5152              		.loc 1 2368 0
 5153 2cbc D535D3E5 		ldrb	r3, [r3, #1493]	@ zero_extendqisi2
 5154 2cc0 010053E3 		cmp	r3, #1
 5155 2cc4 04005313 		cmpne	r3, #4
 5156 2cc8 2001001A 		bne	.L489
2367:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5157              		.loc 1 2367 0
 5158 2ccc 1CC09DE5 		ldr	ip, [sp, #28]
 5159 2cd0 20009DE5 		ldr	r0, [sp, #32]
 5160 2cd4 00348CE1 		orr	r3, ip, r0, asl #8
2369:../uvc.c      **** 					  {
 5161              		.loc 1 2369 0
 5162 2cd8 F90053E3 		cmp	r3, #249
 5163 2cdc 1B01008A 		bhi	.L489
 5164              	.LVL628:
2374:../uvc.c      **** 							}else{
 5165              		.loc 1 2374 0
 5166 2ce0 C80043E2 		sub	r0, r3, #200
 5167 2ce4 C80053E3 		cmp	r3, #200
2376:../uvc.c      **** 							}
 5168              		.loc 1 2376 0
 5169 2ce8 C82063E2 		rsb	r2, r3, #200
 5170 2cec C0149FE5 		ldr	r1, .L503+28
 5171 2cf0 0208A091 		movls	r0, r2, asl #16
 5172 2cf4 0008A081 		movhi	r0, r0, asl #16
 5173 2cf8 642063E2 		rsb	r2, r3, #100
 5174 2cfc 640053E3 		cmp	r3, #100
2374:../uvc.c      **** 							}else{
 5175              		.loc 1 2374 0
 5176 2d00 64C043E2 		sub	ip, r3, #100
 5177 2d04 2008A0E1 		mov	r0, r0, lsr #16
 5178 2d08 0C28A081 		movhi	r2, ip, asl #16
 5179 2d0c 0228A091 		movls	r2, r2, asl #16
 5180 2d10 010050E1 		cmp	r0, r1
 5181 2d14 00E0A031 		movcc	lr, r0
 5182 2d18 01E0A021 		movcs	lr, r1
 5183 2d1c 010050E1 		cmp	r0, r1
 5184 2d20 27C043E2 		sub	ip, r3, #39
2376:../uvc.c      **** 							}
 5185              		.loc 1 2376 0
 5186 2d24 271063E2 		rsb	r1, r3, #39
 5187 2d28 00B0A033 		movcc	fp, #0
 5188 2d2c 01B0A023 		movcs	fp, #1
 5189 2d30 270053E3 		cmp	r3, #39
2374:../uvc.c      **** 							}else{
 5190              		.loc 1 2374 0
 5191 2d34 140043E2 		sub	r0, r3, #20
 5192 2d38 01C8A091 		movls	ip, r1, asl #16
 5193 2d3c 2228A0E1 		mov	r2, r2, lsr #16
2376:../uvc.c      **** 							}
 5194              		.loc 1 2376 0
 5195 2d40 141063E2 		rsb	r1, r3, #20
 5196 2d44 0CC8A081 		movhi	ip, ip, asl #16
 5197 2d48 140053E3 		cmp	r3, #20
 5198 2d4c 0018A081 		movhi	r1, r0, asl #16
 5199 2d50 0118A091 		movls	r1, r1, asl #16
 5200 2d54 0E0052E1 		cmp	r2, lr
2374:../uvc.c      **** 							}else{
 5201              		.loc 1 2374 0
 5202 2d58 0A0043E2 		sub	r0, r3, #10
 5203 2d5c 01B0A033 		movcc	fp, #1
 5204 2d60 2CC8A0E1 		mov	ip, ip, lsr #16
 5205 2d64 02005EE1 		cmp	lr, r2
 5206 2d68 0E20A031 		movcc	r2, lr
 5207 2d6c 0A0053E3 		cmp	r3, #10
 5208 2d70 21E8A0E1 		mov	lr, r1, lsr #16
2376:../uvc.c      **** 							}
 5209              		.loc 1 2376 0
 5210 2d74 0A1063E2 		rsb	r1, r3, #10
 5211 2d78 0118A091 		movls	r1, r1, asl #16
 5212 2d7c 0018A081 		movhi	r1, r0, asl #16
 5213 2d80 0C0052E1 		cmp	r2, ip
 5214 2d84 02B0A083 		movhi	fp, #2
 5215 2d88 24B08DE5 		str	fp, [sp, #36]
2374:../uvc.c      **** 							}else{
 5216              		.loc 1 2374 0
 5217 2d8c 050043E2 		sub	r0, r3, #5
 5218 2d90 02005CE1 		cmp	ip, r2
 5219 2d94 0C20A031 		movcc	r2, ip
 5220 2d98 21B8A0E1 		mov	fp, r1, lsr #16
2376:../uvc.c      **** 							}
 5221              		.loc 1 2376 0
 5222 2d9c 05C063E2 		rsb	ip, r3, #5
 5223 2da0 050053E3 		cmp	r3, #5
 5224 2da4 24109DE5 		ldr	r1, [sp, #36]
 5225 2da8 00C8A081 		movhi	ip, r0, asl #16
 5226 2dac 0CC8A091 		movls	ip, ip, asl #16
 5227 2db0 0E0052E1 		cmp	r2, lr
 5228 2db4 0310A083 		movhi	r1, #3
 5229 2db8 24108DE5 		str	r1, [sp, #36]
 5230 2dbc 02005EE1 		cmp	lr, r2
 5231 2dc0 0E00A031 		movcc	r0, lr
 5232 2dc4 0200A021 		movcs	r0, r2
 5233 2dc8 021063E2 		rsb	r1, r3, #2
2374:../uvc.c      **** 							}else{
 5234              		.loc 1 2374 0
 5235 2dcc 022043E2 		sub	r2, r3, #2
 5236 2dd0 020053E3 		cmp	r3, #2
 5237 2dd4 0128A091 		movls	r2, r1, asl #16
 5238 2dd8 0228A081 		movhi	r2, r2, asl #16
 5239 2ddc 0B0050E1 		cmp	r0, fp
 5240 2de0 24E09DE5 		ldr	lr, [sp, #36]
 5241 2de4 2CC8A0E1 		mov	ip, ip, lsr #16
 5242 2de8 04E0A083 		movhi	lr, #4
 5243 2dec 00005BE1 		cmp	fp, r0
 5244 2df0 0B00A031 		movcc	r0, fp
 5245 2df4 00005CE1 		cmp	ip, r0
 5246 2df8 0C10A031 		movcc	r1, ip
 5247 2dfc 0010A021 		movcs	r1, r0
 5248 2e00 0C0050E1 		cmp	r0, ip
 5249 2e04 05E0A083 		movhi	lr, #5
 5250 2e08 01C043E2 		sub	ip, r3, #1
 5251 2e0c 010053E3 		cmp	r3, #1
2376:../uvc.c      **** 							}
 5252              		.loc 1 2376 0
 5253 2e10 010063E2 		rsb	r0, r3, #1
 5254 2e14 0C38A081 		movhi	r3, ip, asl #16
2386:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5255              		.loc 1 2386 0
 5256 2e18 8CC39FE5 		ldr	ip, .L503+20
 5257 2e1c 2228A0E1 		mov	r2, r2, lsr #16
 5258 2e20 0038A091 		movls	r3, r0, asl #16
 5259 2e24 010052E1 		cmp	r2, r1
 5260 2e28 0200A031 		movcc	r0, r2
 5261 2e2c 0100A021 		movcs	r0, r1
 5262 2e30 020051E1 		cmp	r1, r2
 5263 2e34 0E20A091 		movls	r2, lr
 5264 2e38 0620A083 		movhi	r2, #6
 5265              	.LVL629:
 5266 2e3c 0010E0E3 		mvn	r1, #0
 5267              	.LVL630:
 5268 2e40 230850E1 		cmp	r0, r3, lsr #16
 5269 2e44 1C009CE5 		ldr	r0, [ip, #28]
 5270 2e48 02B0A091 		movls	fp, r2
 5271 2e4c 07B0A083 		movhi	fp, #7
 5272              	.LVL631:
 5273 2e50 18C08DE5 		str	ip, [sp, #24]
 5274 2e54 FEFFFFEB 		bl	_txe_mutex_get
 5275              	.LVL632:
2387:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5276              		.loc 1 2387 0
 5277 2e58 18C09DE5 		ldr	ip, [sp, #24]
2383:../uvc.c      **** 
 5278              		.loc 1 2383 0
 5279 2e5c 01B08BE2 		add	fp, fp, #1
 5280              	.LVL633:
2387:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5281              		.loc 1 2387 0
 5282 2e60 0010A0E3 		mov	r1, #0
 5283 2e64 0A20A0E1 		mov	r2, r10
 5284 2e68 0930A0E1 		mov	r3, r9
 5285 2e6c 0C00A0E1 		mov	r0, ip
 5286 2e70 04108DE5 		str	r1, [sp, #4]
 5287 2e74 00B08DE5 		str	fp, [sp]
 5288 2e78 0310A0E3 		mov	r1, #3
 5289 2e7c FEFFFFEB 		bl	cmdSet
 5290              	.LVL634:
2388:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5291              		.loc 1 2388 0
 5292 2e80 18C09DE5 		ldr	ip, [sp, #24]
 5293 2e84 1C009CE5 		ldr	r0, [ip, #28]
 5294 2e88 FEFFFFEB 		bl	_txe_mutex_put
 5295              	.LVL635:
2394:../uvc.c      **** 					  }else{
 5296              		.loc 1 2394 0
 5297 2e8c 08C39FE5 		ldr	ip, .L503+4
2391:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5298              		.loc 1 2391 0
 5299 2e90 04239FE5 		ldr	r2, .L503+4
2394:../uvc.c      **** 					  }else{
 5300              		.loc 1 2394 0
 5301 2e94 79B3CCE5 		strb	fp, [ip, #889]
2391:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5302              		.loc 1 2391 0
 5303 2e98 1CC09DE5 		ldr	ip, [sp, #28]
 5304 2e9c 063088E0 		add	r3, r8, r6
 5305 2ea0 833182E0 		add	r3, r2, r3, asl #3
 5306 2ea4 BDC5C3E5 		strb	ip, [r3, #1469]
2392:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5307              		.loc 1 2392 0
 5308 2ea8 20C09DE5 		ldr	ip, [sp, #32]
2393:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5309              		.loc 1 2393 0
 5310 2eac 0120A0E3 		mov	r2, #1
2392:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5311              		.loc 1 2392 0
 5312 2eb0 BEC5C3E5 		strb	ip, [r3, #1470]
2393:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5313              		.loc 1 2393 0
 5314 2eb4 C025C3E5 		strb	r2, [r3, #1472]
2394:../uvc.c      **** 					  }else{
 5315              		.loc 1 2394 0
 5316 2eb8 7BFFFFEA 		b	.L492
 5317              	.LVL636:
 5318              	.L478:
2325:../uvc.c      **** 						case 1:
 5319              		.loc 1 2325 0
 5320 2ebc 1CC09DE5 		ldr	ip, [sp, #28]
2321:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5321              		.loc 1 2321 0
 5322 2ec0 066088E0 		add	r6, r8, r6
 5323 2ec4 866183E0 		add	r6, r3, r6, asl #3
2322:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5324              		.loc 1 2322 0
 5325 2ec8 0110A0E3 		mov	r1, #1
2325:../uvc.c      **** 						case 1:
 5326              		.loc 1 2325 0
 5327 2ecc 01204CE2 		sub	r2, ip, #1
2321:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5328              		.loc 1 2321 0
 5329 2ed0 BDC5C6E5 		strb	ip, [r6, #1469]
2322:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5330              		.loc 1 2322 0
 5331 2ed4 C015C6E5 		strb	r1, [r6, #1472]
 5332              	.LVL637:
2325:../uvc.c      **** 						case 1:
 5333              		.loc 1 2325 0
 5334 2ed8 070052E3 		cmp	r2, #7
 5335 2edc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5336 2ee0 960000EA 		b	.L483
 5337              	.L485:
 5338 2ee4 DC300000 		.word	.L484
 5339 2ee8 40300000 		.word	.L486
 5340 2eec 40310000 		.word	.L483
 5341 2ef0 D82F0000 		.word	.L487
 5342 2ef4 40310000 		.word	.L483
 5343 2ef8 40310000 		.word	.L483
 5344 2efc 40310000 		.word	.L483
 5345 2f00 382F0000 		.word	.L488
 5346              	.LVL638:
 5347              	.L477:
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5348              		.loc 1 2440 0
 5349 2f04 1CC09DE5 		ldr	ip, [sp, #28]
 5350 2f08 068088E0 		add	r8, r8, r6
 5351 2f0c 888183E0 		add	r8, r3, r8, asl #3
2441:../uvc.c      **** 			  		 break;
 5352              		.loc 1 2441 0
 5353 2f10 0620A0E1 		mov	r2, r6
 5354 2f14 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5355 2f18 0400A0E3 		mov	r0, #4
 5356 2f1c 94129FE5 		ldr	r1, .L503+32
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5357              		.loc 1 2440 0
 5358 2f20 BDC5C8E5 		strb	ip, [r8, #1469]
2441:../uvc.c      **** 			  		 break;
 5359              		.loc 1 2441 0
 5360 2f24 FEFFFFEB 		bl	CyU3PDebugPrint
 5361              	.LVL639:
2442:../uvc.c      **** 			  }
 5362              		.loc 1 2442 0
 5363 2f28 FF00A0E3 		mov	r0, #255
 5364 2f2c 0080A0E1 		mov	r8, r0
 5365 2f30 0060A0E1 		mov	r6, r0
 5366 2f34 B1FEFFEA 		b	.L476
 5367              	.LVL640:
 5368              	.L488:
2344:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5369              		.loc 1 2344 0
 5370 2f38 6C629FE5 		ldr	r6, .L503+20
2342:../uvc.c      **** 			  		    	dataIdx = 0;
 5371              		.loc 1 2342 0
 5372 2f3c 0080A0E3 		mov	r8, #0
2344:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5373              		.loc 1 2344 0
 5374 2f40 1C0096E5 		ldr	r0, [r6, #28]
 5375 2f44 0010E0E3 		mvn	r1, #0
2342:../uvc.c      **** 			  		    	dataIdx = 0;
 5376              		.loc 1 2342 0
 5377 2f48 7983C3E5 		strb	r8, [r3, #889]
 5378              	.LVL641:
2344:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5379              		.loc 1 2344 0
 5380 2f4c FEFFFFEB 		bl	_txe_mutex_get
 5381              	.LVL642:
2345:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5382              		.loc 1 2345 0
 5383 2f50 0A20A0E1 		mov	r2, r10
 5384 2f54 0930A0E1 		mov	r3, r9
 5385 2f58 1010A0E3 		mov	r1, #16
 5386 2f5c 00808DE5 		str	r8, [sp]
 5387 2f60 04808DE5 		str	r8, [sp, #4]
 5388 2f64 0600A0E1 		mov	r0, r6
 5389 2f68 FEFFFFEB 		bl	cmdSet
 5390              	.LVL643:
2346:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5391              		.loc 1 2346 0
 5392 2f6c 1C0096E5 		ldr	r0, [r6, #28]
 5393 2f70 FEFFFFEB 		bl	_txe_mutex_put
 5394              	.LVL644:
 5395              	.LBB82:
 5396              	.LBB83:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5397              		.loc 1 1278 0
 5398 2f74 1C0096E5 		ldr	r0, [r6, #28]
 5399 2f78 0010E0E3 		mvn	r1, #0
 5400 2f7c FEFFFFEB 		bl	_txe_mutex_get
 5401              	.LVL645:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5402              		.loc 1 1279 0
 5403 2f80 0130A0E3 		mov	r3, #1
 5404 2f84 04808DE5 		str	r8, [sp, #4]
 5405 2f88 0600A0E1 		mov	r0, r6
 5406 2f8c 00308DE5 		str	r3, [sp]
 5407 2f90 2010A0E3 		mov	r1, #32
 5408 2f94 2720A0E3 		mov	r2, #39
 5409 2f98 3030A0E3 		mov	r3, #48
 5410 2f9c FEFFFFEB 		bl	cmdSet
 5411              	.LVL646:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5412              		.loc 1 1280 0
 5413 2fa0 0230A0E3 		mov	r3, #2
 5414 2fa4 04808DE5 		str	r8, [sp, #4]
 5415 2fa8 0600A0E1 		mov	r0, r6
 5416 2fac 00308DE5 		str	r3, [sp]
 5417 2fb0 2110A0E3 		mov	r1, #33
 5418 2fb4 2520A0E3 		mov	r2, #37
 5419 2fb8 3030A0E3 		mov	r3, #48
 5420 2fbc FEFFFFEB 		bl	cmdSet
 5421              	.LVL647:
1281:../uvc.c      **** }
 5422              		.loc 1 1281 0
 5423 2fc0 1C0096E5 		ldr	r0, [r6, #28]
 5424 2fc4 FEFFFFEB 		bl	_txe_mutex_put
 5425              	.LVL648:
 5426 2fc8 FF00A0E3 		mov	r0, #255
 5427 2fcc 0080A0E1 		mov	r8, r0
 5428 2fd0 0860A0E3 		mov	r6, #8
 5429 2fd4 89FEFFEA 		b	.L476
 5430              	.LVL649:
 5431              	.L487:
 5432              	.LBE83:
 5433              	.LBE82:
 5434              	.LBB84:
 5435              	.LBB85:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5436              		.loc 1 1278 0
 5437 2fd8 CC619FE5 		ldr	r6, .L503+20
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5438              		.loc 1 1279 0
 5439 2fdc 0080A0E3 		mov	r8, #0
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5440              		.loc 1 1278 0
 5441 2fe0 0010E0E3 		mvn	r1, #0
 5442 2fe4 1C0096E5 		ldr	r0, [r6, #28]
 5443 2fe8 FEFFFFEB 		bl	_txe_mutex_get
 5444              	.LVL650:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5445              		.loc 1 1279 0
 5446 2fec 0600A0E1 		mov	r0, r6
 5447 2ff0 00808DE5 		str	r8, [sp]
 5448 2ff4 04808DE5 		str	r8, [sp, #4]
 5449 2ff8 2010A0E3 		mov	r1, #32
 5450 2ffc 2720A0E3 		mov	r2, #39
 5451 3000 3030A0E3 		mov	r3, #48
 5452 3004 FEFFFFEB 		bl	cmdSet
 5453              	.LVL651:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5454              		.loc 1 1280 0
 5455 3008 0130A0E3 		mov	r3, #1
 5456 300c 04808DE5 		str	r8, [sp, #4]
 5457 3010 0600A0E1 		mov	r0, r6
 5458 3014 00308DE5 		str	r3, [sp]
 5459 3018 2110A0E3 		mov	r1, #33
 5460 301c 2520A0E3 		mov	r2, #37
 5461 3020 3030A0E3 		mov	r3, #48
 5462 3024 FEFFFFEB 		bl	cmdSet
 5463              	.LVL652:
1281:../uvc.c      **** }
 5464              		.loc 1 1281 0
 5465 3028 1C0096E5 		ldr	r0, [r6, #28]
 5466 302c FEFFFFEB 		bl	_txe_mutex_put
 5467              	.LVL653:
 5468 3030 FF00A0E3 		mov	r0, #255
 5469 3034 0080A0E1 		mov	r8, r0
 5470 3038 0460A0E3 		mov	r6, #4
 5471 303c 6FFEFFEA 		b	.L476
 5472              	.LVL654:
 5473              	.L486:
 5474              	.LBE85:
 5475              	.LBE84:
2332:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5476              		.loc 1 2332 0
 5477 3040 64619FE5 		ldr	r6, .L503+20
2330:../uvc.c      **** 							dataIdx = 0;
 5478              		.loc 1 2330 0
 5479 3044 0080A0E3 		mov	r8, #0
2332:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5480              		.loc 1 2332 0
 5481 3048 1C0096E5 		ldr	r0, [r6, #28]
 5482 304c 0010E0E3 		mvn	r1, #0
2330:../uvc.c      **** 							dataIdx = 0;
 5483              		.loc 1 2330 0
 5484 3050 7983C3E5 		strb	r8, [r3, #889]
 5485              	.LVL655:
2332:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5486              		.loc 1 2332 0
 5487 3054 FEFFFFEB 		bl	_txe_mutex_get
 5488              	.LVL656:
2333:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5489              		.loc 1 2333 0
 5490 3058 0A20A0E1 		mov	r2, r10
 5491 305c 0930A0E1 		mov	r3, r9
 5492 3060 1010A0E3 		mov	r1, #16
 5493 3064 00808DE5 		str	r8, [sp]
 5494 3068 04808DE5 		str	r8, [sp, #4]
 5495 306c 0600A0E1 		mov	r0, r6
 5496 3070 FEFFFFEB 		bl	cmdSet
 5497              	.LVL657:
2334:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5498              		.loc 1 2334 0
 5499 3074 1C0096E5 		ldr	r0, [r6, #28]
 5500 3078 FEFFFFEB 		bl	_txe_mutex_put
 5501              	.LVL658:
 5502              	.LBB86:
 5503              	.LBB87:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5504              		.loc 1 1278 0
 5505 307c 1C0096E5 		ldr	r0, [r6, #28]
 5506 3080 0010E0E3 		mvn	r1, #0
 5507 3084 FEFFFFEB 		bl	_txe_mutex_get
 5508              	.LVL659:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5509              		.loc 1 1279 0
 5510 3088 00808DE5 		str	r8, [sp]
 5511 308c 04808DE5 		str	r8, [sp, #4]
 5512 3090 0600A0E1 		mov	r0, r6
 5513 3094 2010A0E3 		mov	r1, #32
 5514 3098 2720A0E3 		mov	r2, #39
 5515 309c 3030A0E3 		mov	r3, #48
 5516 30a0 FEFFFFEB 		bl	cmdSet
 5517              	.LVL660:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5518              		.loc 1 1280 0
 5519 30a4 0130A0E3 		mov	r3, #1
 5520 30a8 04808DE5 		str	r8, [sp, #4]
 5521 30ac 0600A0E1 		mov	r0, r6
 5522 30b0 00308DE5 		str	r3, [sp]
 5523 30b4 2110A0E3 		mov	r1, #33
 5524 30b8 2520A0E3 		mov	r2, #37
 5525 30bc 3030A0E3 		mov	r3, #48
 5526 30c0 FEFFFFEB 		bl	cmdSet
 5527              	.LVL661:
1281:../uvc.c      **** }
 5528              		.loc 1 1281 0
 5529 30c4 1C0096E5 		ldr	r0, [r6, #28]
 5530 30c8 FEFFFFEB 		bl	_txe_mutex_put
 5531              	.LVL662:
 5532 30cc FF00A0E3 		mov	r0, #255
 5533 30d0 0080A0E1 		mov	r8, r0
 5534 30d4 0260A0E3 		mov	r6, #2
 5535 30d8 48FEFFEA 		b	.L476
 5536              	.LVL663:
 5537              	.L484:
 5538              	.LBE87:
 5539              	.LBE86:
 5540              	.LBB88:
 5541              	.LBB89:
1278:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5542              		.loc 1 1278 0
 5543 30dc C8809FE5 		ldr	r8, .L503+20
 5544 30e0 0010E0E3 		mvn	r1, #0
 5545 30e4 1C0098E5 		ldr	r0, [r8, #28]
 5546 30e8 FEFFFFEB 		bl	_txe_mutex_get
 5547              	.LVL664:
1279:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5548              		.loc 1 1279 0
 5549 30ec 0090A0E3 		mov	r9, #0
 5550              	.LVL665:
 5551 30f0 0160A0E3 		mov	r6, #1
 5552 30f4 0800A0E1 		mov	r0, r8
 5553 30f8 2010A0E3 		mov	r1, #32
 5554 30fc 2720A0E3 		mov	r2, #39
 5555 3100 3030A0E3 		mov	r3, #48
 5556 3104 40028DE8 		stmia	sp, {r6, r9}
 5557 3108 FEFFFFEB 		bl	cmdSet
 5558              	.LVL666:
1280:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5559              		.loc 1 1280 0
 5560 310c 0230A0E3 		mov	r3, #2
 5561 3110 0800A0E1 		mov	r0, r8
 5562 3114 00308DE5 		str	r3, [sp]
 5563 3118 2110A0E3 		mov	r1, #33
 5564 311c 2520A0E3 		mov	r2, #37
 5565 3120 3030A0E3 		mov	r3, #48
 5566 3124 04908DE5 		str	r9, [sp, #4]
 5567 3128 FEFFFFEB 		bl	cmdSet
 5568              	.LVL667:
1281:../uvc.c      **** }
 5569              		.loc 1 1281 0
 5570 312c 1C0098E5 		ldr	r0, [r8, #28]
 5571 3130 FEFFFFEB 		bl	_txe_mutex_put
 5572              	.LVL668:
 5573 3134 FF00A0E3 		mov	r0, #255
 5574 3138 0080A0E1 		mov	r8, r0
 5575 313c 2FFEFFEA 		b	.L476
 5576              	.LVL669:
 5577              	.L483:
 5578              	.LBE89:
 5579              	.LBE88:
2325:../uvc.c      **** 						case 1:
 5580              		.loc 1 2325 0
 5581 3140 FF00A0E3 		mov	r0, #255
 5582 3144 0C60A0E1 		mov	r6, ip
 5583 3148 0080A0E1 		mov	r8, r0
 5584 314c 2BFEFFEA 		b	.L476
 5585              	.LVL670:
 5586              	.L489:
2396:../uvc.c      **** 					  }
 5587              		.loc 1 2396 0
 5588 3150 0000A0E3 		mov	r0, #0
 5589 3154 0020A0E1 		mov	r2, r0
 5590 3158 0110A0E3 		mov	r1, #1
 5591 315c FEFFFFEB 		bl	CyU3PUsbStall
 5592              	.LVL671:
 5593 3160 D1FEFFEA 		b	.L492
 5594              	.LVL672:
 5595              	.L491:
2414:../uvc.c      **** 					  }
 5596              		.loc 1 2414 0
 5597 3164 0020A0E1 		mov	r2, r0
 5598 3168 0110A0E3 		mov	r1, #1
 5599 316c FEFFFFEB 		bl	CyU3PUsbStall
 5600              	.LVL673:
 5601 3170 CDFEFFEA 		b	.L492
 5602              	.LVL674:
 5603              	.L502:
2429:../uvc.c      **** 					  else
 5604              		.loc 1 2429 0
 5605 3174 0800A0E3 		mov	r0, #8
 5606              	.L499:
 5607 3178 0010A0E3 		mov	r1, #0
 5608 317c 03008DE8 		stmia	sp, {r0, r1}
 5609 3180 0A20A0E1 		mov	r2, r10
 5610 3184 0930A0E1 		mov	r3, r9
 5611 3188 0600A0E1 		mov	r0, r6
 5612 318c 2310A0E3 		mov	r1, #35
 5613 3190 FEFFFFEB 		bl	cmdSet
 5614              	.LVL675:
 5615 3194 97FEFFEA 		b	.L494
 5616              	.L504:
 5617              		.align	2
 5618              	.L503:
 5619 3198 00000000 		.word	bRequest
 5620 319c 00000000 		.word	.LANCHOR1
 5621 31a0 00000000 		.word	.LANCHOR0
 5622 31a4 D4060000 		.word	.LC39
 5623 31a8 B0060000 		.word	.LC38
 5624 31ac 00000000 		.word	cmdQu
 5625 31b0 64060000 		.word	.LC36
 5626 31b4 FFFF0000 		.word	65535
 5627 31b8 8C060000 		.word	.LC37
 5628              		.cfi_endproc
 5629              	.LFE4:
 5631              		.align	2
 5632              		.global	CamDefSet
 5634              	CamDefSet:
 5635              	.LFB5:
2457:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5636              		.loc 1 2457 0
 5637              		.cfi_startproc
 5638              		@ args = 0, pretend = 0, frame = 24
 5639              		@ frame_needed = 0, uses_anonymous_args = 0
 5640              	.LVL676:
 5641 31bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5642              	.LCFI21:
 5643              		.cfi_def_cfa_offset 36
 5644              		.cfi_offset 4, -36
 5645              		.cfi_offset 5, -32
 5646              		.cfi_offset 6, -28
 5647              		.cfi_offset 7, -24
 5648              		.cfi_offset 8, -20
 5649              		.cfi_offset 9, -16
 5650              		.cfi_offset 10, -12
 5651              		.cfi_offset 11, -8
 5652              		.cfi_offset 14, -4
2464:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5653              		.loc 1 2464 0
 5654 31c0 B0429FE5 		ldr	r4, .L508
2469:../uvc.c      ****     if(Data1&0x80){
 5655              		.loc 1 2469 0
 5656 31c4 B0229FE5 		ldr	r2, .L508+4
2466:../uvc.c      ****     Data1 = Data0;
 5657              		.loc 1 2466 0
 5658 31c8 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
2457:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5659              		.loc 1 2457 0
 5660 31cc 2CD04DE2 		sub	sp, sp, #44
 5661              	.LCFI22:
 5662              		.cfi_def_cfa_offset 80
2469:../uvc.c      ****     if(Data1&0x80){
 5663              		.loc 1 2469 0
 5664 31d0 1C0092E5 		ldr	r0, [r2, #28]
 5665 31d4 0010E0E3 		mvn	r1, #0
2471:../uvc.c      ****     }else{
 5666              		.loc 1 2471 0
 5667 31d8 2563A0E1 		mov	r6, r5, lsr #6
2465:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5668              		.loc 1 2465 0
 5669 31dc 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
2464:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5670              		.loc 1 2464 0
 5671 31e0 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5672              	.LVL677:
2469:../uvc.c      ****     if(Data1&0x80){
 5673              		.loc 1 2469 0
 5674 31e4 FEFFFFEB 		bl	_txe_mutex_get
 5675              	.LVL678:
2470:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5676              		.loc 1 2470 0
 5677 31e8 800015E3 		tst	r5, #128
2471:../uvc.c      ****     }else{
 5678              		.loc 1 2471 0
 5679 31ec 01600612 		andne	r6, r6, #1
 5680 31f0 0660E011 		mvnne	r6, r6
 5681 31f4 3B600612 		andne	r6, r6, #59
 5682 31f8 0660E011 		mvnne	r6, r6
 5683 31fc FF600612 		andne	r6, r6, #255
 5684              	.LVL679:
2473:../uvc.c      ****     }
 5685              		.loc 1 2473 0
 5686 3200 C6608603 		orreq	r6, r6, #198
 5687              	.LVL680:
2477:../uvc.c      **** 
 5688              		.loc 1 2477 0
 5689 3204 0080A0E3 		mov	r8, #0
2475:../uvc.c      **** 
 5690              		.loc 1 2475 0
 5691 3208 0551A0E1 		mov	r5, r5, asl #2
 5692              	.LVL681:
 5693 320c FF5005E2 		and	r5, r5, #255
 5694              	.LVL682:
2480:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5695              		.loc 1 2480 0
 5696 3210 01A0A0E3 		mov	r10, #1
2477:../uvc.c      **** 
 5697              		.loc 1 2477 0
 5698 3214 00608DE5 		str	r6, [sp]
 5699 3218 0920A0E1 		mov	r2, r9
 5700 321c 0730A0E1 		mov	r3, r7
 5701 3220 04808DE5 		str	r8, [sp, #4]
 5702 3224 0110A0E3 		mov	r1, #1
 5703 3228 4C029FE5 		ldr	r0, .L508+4
 5704 322c FEFFFFEB 		bl	cmdSet
 5705              	.LVL683:
2480:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5706              		.loc 1 2480 0
 5707 3230 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 5708 3234 0730A0E1 		mov	r3, r7
 5709 3238 0A10A0E1 		mov	r1, r10
 5710 323c 00508DE5 		str	r5, [sp]
 5711 3240 04A08DE5 		str	r10, [sp, #4]
 5712 3244 30029FE5 		ldr	r0, .L508+4
 5713 3248 FEFFFFEB 		bl	cmdSet
 5714              	.LVL684:
2483:../uvc.c      **** 
 5715              		.loc 1 2483 0
 5716 324c 0620A0E1 		mov	r2, r6
 5717 3250 0530A0E1 		mov	r3, r5
 5718 3254 24129FE5 		ldr	r1, .L508+8
 5719 3258 0400A0E3 		mov	r0, #4
2482:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5720              		.loc 1 2482 0
 5721 325c 1262C4E5 		strb	r6, [r4, #530]
2481:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5722              		.loc 1 2481 0
 5723 3260 1152C4E5 		strb	r5, [r4, #529]
2483:../uvc.c      **** 
 5724              		.loc 1 2483 0
 5725 3264 FEFFFFEB 		bl	CyU3PDebugPrint
 5726              	.LVL685:
2488:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5727              		.loc 1 2488 0
 5728 3268 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 5729              	.LVL686:
2489:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5730              		.loc 1 2489 0
 5731 326c 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 5732 3270 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 5733 3274 40018DE8 		stmia	sp, {r6, r8}
 5734 3278 FC019FE5 		ldr	r0, .L508+4
 5735 327c 0210A0E3 		mov	r1, #2
 5736 3280 FEFFFFEB 		bl	cmdSet
 5737              	.LVL687:
2492:../uvc.c      **** 
 5738              		.loc 1 2492 0
 5739 3284 0620A0E1 		mov	r2, r6
 5740 3288 0530A0E1 		mov	r3, r5
 5741 328c EC119FE5 		ldr	r1, .L508+8
 5742 3290 0400A0E3 		mov	r0, #4
2490:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 5743              		.loc 1 2490 0
 5744 3294 2952C4E5 		strb	r5, [r4, #553]
2491:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5745              		.loc 1 2491 0
 5746 3298 6954C4E5 		strb	r5, [r4, #1129]
2492:../uvc.c      **** 
 5747              		.loc 1 2492 0
 5748 329c FEFFFFEB 		bl	CyU3PDebugPrint
 5749              	.LVL688:
2497:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5750              		.loc 1 2497 0
 5751 32a0 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
2496:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5752              		.loc 1 2496 0
 5753 32a4 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 5754              	.LVL689:
2498:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5755              		.loc 1 2498 0
 5756 32a8 80C047E2 		sub	ip, r7, #128
 5757 32ac FF300CE2 		and	r3, ip, #255
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5758              		.loc 1 2499 0
 5759 32b0 76E047E2 		sub	lr, r7, #118
2498:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5760              		.loc 1 2498 0
 5761 32b4 18308DE5 		str	r3, [sp, #24]
 5762 32b8 08018DE8 		stmia	sp, {r3, r8}
 5763 32bc B8019FE5 		ldr	r0, .L508+4
 5764 32c0 0630A0E1 		mov	r3, r6
 5765 32c4 0510A0E3 		mov	r1, #5
 5766 32c8 DF20A0E3 		mov	r2, #223
 5767 32cc 14C08DE5 		str	ip, [sp, #20]
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5768              		.loc 1 2499 0
 5769 32d0 1CE08DE5 		str	lr, [sp, #28]
2498:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5770              		.loc 1 2498 0
 5771 32d4 FEFFFFEB 		bl	cmdSet
 5772              	.LVL690:
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5773              		.loc 1 2499 0
 5774 32d8 1C209DE5 		ldr	r2, [sp, #28]
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5775              		.loc 1 2500 0
 5776 32dc 7EE087E2 		add	lr, r7, #126
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5777              		.loc 1 2499 0
 5778 32e0 FF3002E2 		and	r3, r2, #255
 5779 32e4 08048DE8 		stmia	sp, {r3, r10}
 5780 32e8 8C019FE5 		ldr	r0, .L508+4
 5781 32ec 0630A0E1 		mov	r3, r6
 5782 32f0 0510A0E3 		mov	r1, #5
 5783 32f4 DC20A0E3 		mov	r2, #220
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5784              		.loc 1 2500 0
 5785 32f8 20E08DE5 		str	lr, [sp, #32]
2499:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5786              		.loc 1 2499 0
 5787 32fc FEFFFFEB 		bl	cmdSet
 5788              	.LVL691:
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5789              		.loc 1 2500 0
 5790 3300 20209DE5 		ldr	r2, [sp, #32]
2501:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5791              		.loc 1 2501 0
 5792 3304 72E087E2 		add	lr, r7, #114
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5793              		.loc 1 2500 0
 5794 3308 FF3002E2 		and	r3, r2, #255
 5795 330c 0220A0E3 		mov	r2, #2
 5796 3310 00308DE5 		str	r3, [sp]
 5797 3314 04208DE5 		str	r2, [sp, #4]
 5798 3318 0630A0E1 		mov	r3, r6
 5799 331c 0510A0E3 		mov	r1, #5
 5800 3320 DE20A0E3 		mov	r2, #222
 5801 3324 50019FE5 		ldr	r0, .L508+4
2501:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5802              		.loc 1 2501 0
 5803 3328 24E08DE5 		str	lr, [sp, #36]
2500:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5804              		.loc 1 2500 0
 5805 332c FEFFFFEB 		bl	cmdSet
 5806              	.LVL692:
2501:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5807              		.loc 1 2501 0
 5808 3330 24209DE5 		ldr	r2, [sp, #36]
2502:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5809              		.loc 1 2502 0
 5810 3334 6FB047E2 		sub	fp, r7, #111
2501:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5811              		.loc 1 2501 0
 5812 3338 FF3002E2 		and	r3, r2, #255
 5813 333c 0320A0E3 		mov	r2, #3
 5814 3340 00308DE5 		str	r3, [sp]
 5815 3344 04208DE5 		str	r2, [sp, #4]
 5816 3348 0630A0E1 		mov	r3, r6
 5817 334c 0510A0E3 		mov	r1, #5
 5818 3350 E020A0E3 		mov	r2, #224
 5819 3354 20019FE5 		ldr	r0, .L508+4
 5820 3358 FEFFFFEB 		bl	cmdSet
 5821              	.LVL693:
2502:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5822              		.loc 1 2502 0
 5823 335c 0490A0E3 		mov	r9, #4
 5824 3360 FF300BE2 		and	r3, fp, #255
2503:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5825              		.loc 1 2503 0
 5826 3364 7F7087E2 		add	r7, r7, #127
 5827              	.LVL694:
2502:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5828              		.loc 1 2502 0
 5829 3368 00308DE5 		str	r3, [sp]
 5830 336c 04908DE5 		str	r9, [sp, #4]
 5831 3370 0630A0E1 		mov	r3, r6
 5832 3374 0510A0E3 		mov	r1, #5
 5833 3378 DD20A0E3 		mov	r2, #221
 5834 337c F8009FE5 		ldr	r0, .L508+4
 5835 3380 FEFFFFEB 		bl	cmdSet
 5836              	.LVL695:
2503:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5837              		.loc 1 2503 0
 5838 3384 FF2007E2 		and	r2, r7, #255
 5839 3388 0510A0E3 		mov	r1, #5
 5840 338c 0630A0E1 		mov	r3, r6
 5841 3390 00208DE5 		str	r2, [sp]
 5842 3394 04108DE5 		str	r1, [sp, #4]
 5843 3398 E120A0E3 		mov	r2, #225
 5844 339c D8009FE5 		ldr	r0, .L508+4
 5845 33a0 FEFFFFEB 		bl	cmdSet
 5846              	.LVL696:
2505:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5847              		.loc 1 2505 0
 5848 33a4 14C09DE5 		ldr	ip, [sp, #20]
 5849 33a8 24E09DE5 		ldr	lr, [sp, #36]
 5850 33ac 20309DE5 		ldr	r3, [sp, #32]
 5851 33b0 0C20A0E1 		mov	r2, ip
2504:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5852              		.loc 1 2504 0
 5853 33b4 18C09DE5 		ldr	ip, [sp, #24]
2505:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5854              		.loc 1 2505 0
 5855 33b8 04E08DE5 		str	lr, [sp, #4]
 5856 33bc 00308DE5 		str	r3, [sp]
 5857 33c0 0C708DE5 		str	r7, [sp, #12]
 5858 33c4 1C309DE5 		ldr	r3, [sp, #28]
 5859 33c8 08B08DE5 		str	fp, [sp, #8]
 5860 33cc 0900A0E1 		mov	r0, r9
 5861 33d0 AC109FE5 		ldr	r1, .L508+12
2504:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5862              		.loc 1 2504 0
 5863 33d4 71C2C4E5 		strb	ip, [r4, #625]
2505:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 5864              		.loc 1 2505 0
 5865 33d8 FEFFFFEB 		bl	CyU3PDebugPrint
 5866              	.LVL697:
2510:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5867              		.loc 1 2510 0
 5868 33dc 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 5869              	.LVL698:
2509:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5870              		.loc 1 2509 0
 5871 33e0 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 5872              	.LVL699:
2511:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5873              		.loc 1 2511 0
 5874 33e4 00608DE5 		str	r6, [sp]
 5875 33e8 0730A0E1 		mov	r3, r7
 5876 33ec 04808DE5 		str	r8, [sp, #4]
 5877 33f0 0610A0E3 		mov	r1, #6
 5878 33f4 8520A0E3 		mov	r2, #133
 5879 33f8 7C009FE5 		ldr	r0, .L508+4
 5880 33fc FEFFFFEB 		bl	cmdSet
 5881              	.LVL700:
2512:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5882              		.loc 1 2512 0
 5883 3400 40048DE8 		stmia	sp, {r6, r10}
 5884 3404 70009FE5 		ldr	r0, .L508+4
 5885 3408 0730A0E1 		mov	r3, r7
 5886 340c 0610A0E3 		mov	r1, #6
 5887 3410 8620A0E3 		mov	r2, #134
 5888 3414 FEFFFFEB 		bl	cmdSet
 5889              	.LVL701:
2514:../uvc.c      **** 
 5890              		.loc 1 2514 0
 5891 3418 0620A0E1 		mov	r2, r6
 5892 341c 0530A0E1 		mov	r3, r5
 5893 3420 0900A0E1 		mov	r0, r9
 5894 3424 54109FE5 		ldr	r1, .L508+8
2513:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5895              		.loc 1 2513 0
 5896 3428 8962C4E5 		strb	r6, [r4, #649]
2514:../uvc.c      **** 
 5897              		.loc 1 2514 0
 5898 342c FEFFFFEB 		bl	CyU3PDebugPrint
 5899              	.LVL702:
2519:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5900              		.loc 1 2519 0
 5901 3430 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 5902              	.LVL703:
2520:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5903              		.loc 1 2520 0
 5904 3434 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 5905 3438 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 5906 343c 40018DE8 		stmia	sp, {r6, r8}
 5907 3440 34009FE5 		ldr	r0, .L508+4
 5908 3444 0710A0E3 		mov	r1, #7
 5909 3448 FEFFFFEB 		bl	cmdSet
 5910              	.LVL704:
2522:../uvc.c      **** 
 5911              		.loc 1 2522 0
 5912 344c 0620A0E1 		mov	r2, r6
 5913 3450 0530A0E1 		mov	r3, r5
 5914 3454 0900A0E1 		mov	r0, r9
 5915 3458 20109FE5 		ldr	r1, .L508+8
2521:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5916              		.loc 1 2521 0
 5917 345c A152C4E5 		strb	r5, [r4, #673]
2522:../uvc.c      **** 
 5918              		.loc 1 2522 0
 5919 3460 FEFFFFEB 		bl	CyU3PDebugPrint
 5920              	.LVL705:
2524:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5921              		.loc 1 2524 0
 5922 3464 10209FE5 		ldr	r2, .L508+4
 5923 3468 1C0092E5 		ldr	r0, [r2, #28]
2527:../uvc.c      **** 
 5924              		.loc 1 2527 0
 5925 346c 2CD08DE2 		add	sp, sp, #44
 5926              		@ sp needed
 5927 3470 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5928              	.LVL706:
2524:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 5929              		.loc 1 2524 0
 5930 3474 FEFFFFEA 		b	_txe_mutex_put
 5931              	.LVL707:
 5932              	.L509:
 5933              		.align	2
 5934              	.L508:
 5935 3478 00000000 		.word	.LANCHOR1
 5936 347c 00000000 		.word	statQu
 5937 3480 38070000 		.word	.LC40
 5938 3484 58070000 		.word	.LC41
 5939              		.cfi_endproc
 5940              	.LFE5:
 5942              		.align	2
 5943              		.global	CyFxUVCAddHeader
 5945              	CyFxUVCAddHeader:
 5946              	.LFB6:
2535:../uvc.c      ****     /* Copy header to buffer */
 5947              		.loc 1 2535 0
 5948              		.cfi_startproc
 5949              		@ args = 0, pretend = 0, frame = 0
 5950              		@ frame_needed = 0, uses_anonymous_args = 0
 5951              	.LVL708:
 5952 3488 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5953              	.LCFI23:
 5954              		.cfi_def_cfa_offset 16
 5955              		.cfi_offset 3, -16
 5956              		.cfi_offset 4, -12
 5957              		.cfi_offset 5, -8
 5958              		.cfi_offset 14, -4
2535:../uvc.c      ****     /* Copy header to buffer */
 5959              		.loc 1 2535 0
 5960 348c 0040A0E1 		mov	r4, r0
 5961 3490 0150A0E1 		mov	r5, r1
2537:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5962              		.loc 1 2537 0
 5963 3494 30009FE5 		ldr	r0, .L515
 5964              	.LVL709:
 5965 3498 0010E0E3 		mvn	r1, #0
 5966              	.LVL710:
 5967 349c FEFFFFEB 		bl	_txe_mutex_get
 5968              	.LVL711:
2538:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5969              		.loc 1 2538 0
 5970 34a0 0400A0E1 		mov	r0, r4
 5971 34a4 24109FE5 		ldr	r1, .L515+4
 5972 34a8 0C20A0E3 		mov	r2, #12
 5973 34ac FEFFFFEB 		bl	CyU3PMemCopy
 5974              	.LVL712:
2539:../uvc.c      **** 
 5975              		.loc 1 2539 0
 5976 34b0 14009FE5 		ldr	r0, .L515
 5977 34b4 FEFFFFEB 		bl	_txe_mutex_put
 5978              	.LVL713:
2542:../uvc.c      ****     {
 5979              		.loc 1 2542 0
 5980 34b8 020015E3 		tst	r5, #2
2544:../uvc.c      ****     }
 5981              		.loc 1 2544 0
 5982 34bc 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5983 34c0 02308313 		orrne	r3, r3, #2
 5984 34c4 0130C415 		strneb	r3, [r4, #1]
 5985 34c8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5986              	.L516:
 5987              		.align	2
 5988              	.L515:
 5989 34cc 00000000 		.word	imgHdMux
 5990 34d0 EC040000 		.word	.LANCHOR1+1260
 5991              		.cfi_endproc
 5992              	.LFE6:
 5994              		.align	2
 5995              		.global	CyFxAppErrorHandler
 5997              	CyFxAppErrorHandler:
 5998              	.LFB7:
2554:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 5999              		.loc 1 2554 0
 6000              		.cfi_startproc
 6001              		@ Volatile: function does not return.
 6002              		@ args = 0, pretend = 0, frame = 0
 6003              		@ frame_needed = 0, uses_anonymous_args = 0
 6004              	.LVL714:
 6005 34d4 08402DE9 		stmfd	sp!, {r3, lr}
 6006              	.LCFI24:
 6007              		.cfi_def_cfa_offset 8
 6008              		.cfi_offset 3, -8
 6009              		.cfi_offset 14, -4
 6010              	.LVL715:
 6011              	.L518:
2564:../uvc.c      ****         CyU3PThreadSleep (1000);
 6012              		.loc 1 2564 0 discriminator 1
 6013 34d8 10109FE5 		ldr	r1, .L519
 6014 34dc 0400A0E3 		mov	r0, #4
 6015 34e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6016              	.LVL716:
2565:../uvc.c      ****     }
 6017              		.loc 1 2565 0 discriminator 1
 6018 34e4 FA0FA0E3 		mov	r0, #1000
 6019 34e8 FEFFFFEB 		bl	_tx_thread_sleep
 6020              	.LVL717:
 6021 34ec F9FFFFEA 		b	.L518
 6022              	.L520:
 6023              		.align	2
 6024              	.L519:
 6025 34f0 90070000 		.word	.LC42
 6026              		.cfi_endproc
 6027              	.LFE7:
 6029              		.align	2
 6030              		.global	UVCAppThread_Entry
 6032              	UVCAppThread_Entry:
 6033              	.LFB19:
3541:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6034              		.loc 1 3541 0
 6035              		.cfi_startproc
 6036              		@ args = 0, pretend = 0, frame = 128
 6037              		@ frame_needed = 0, uses_anonymous_args = 0
 6038              	.LVL718:
 6039 34f4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6040              	.LCFI25:
 6041              		.cfi_def_cfa_offset 32
 6042              		.cfi_offset 4, -32
 6043              		.cfi_offset 5, -28
 6044              		.cfi_offset 6, -24
 6045              		.cfi_offset 7, -20
 6046              		.cfi_offset 8, -16
 6047              		.cfi_offset 9, -12
 6048              		.cfi_offset 10, -8
 6049              		.cfi_offset 14, -4
 6050 34f8 88D04DE2 		sub	sp, sp, #136
 6051              	.LCFI26:
 6052              		.cfi_def_cfa_offset 168
 6053              	.LBB98:
 6054              	.LBB99:
2997:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6055              		.loc 1 2997 0
 6056 34fc FEFFFFEB 		bl	CyU3PUartInit
 6057              	.LVL719:
2998:../uvc.c      ****     {
 6058              		.loc 1 2998 0
 6059 3500 004050E2 		subs	r4, r0, #0
 6060 3504 2902001A 		bne	.L602
3005:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6061              		.loc 1 3005 0
 6062 3508 582A9FE5 		ldr	r2, .L633
3006:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6063              		.loc 1 3006 0
 6064 350c 0130A0E3 		mov	r3, #1
3014:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6065              		.loc 1 3014 0
 6066 3510 0410A0E1 		mov	r1, r4
 6067 3514 60008DE2 		add	r0, sp, #96
 6068              	.LVL720:
3007:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6069              		.loc 1 3007 0
 6070 3518 7540CDE5 		strb	r4, [sp, #117]
3009:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6071              		.loc 1 3009 0
 6072 351c 64408DE5 		str	r4, [sp, #100]
3010:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6073              		.loc 1 3010 0
 6074 3520 68408DE5 		str	r4, [sp, #104]
3005:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6075              		.loc 1 3005 0
 6076 3524 70208DE5 		str	r2, [sp, #112]
3006:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6077              		.loc 1 3006 0
 6078 3528 7430CDE5 		strb	r3, [sp, #116]
3008:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6079              		.loc 1 3008 0
 6080 352c 60308DE5 		str	r3, [sp, #96]
3011:../uvc.c      **** 
 6081              		.loc 1 3011 0
 6082 3530 6C308DE5 		str	r3, [sp, #108]
3014:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6083              		.loc 1 3014 0
 6084 3534 FEFFFFEB 		bl	CyU3PUartSetConfig
 6085              	.LVL721:
3015:../uvc.c      ****     {
 6086              		.loc 1 3015 0
 6087 3538 000050E3 		cmp	r0, #0
 6088 353c B201001A 		bne	.L601
3021:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6089              		.loc 1 3021 0
 6090 3540 0000E0E3 		mvn	r0, #0
 6091              	.LVL722:
 6092 3544 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6093              	.LVL723:
3022:../uvc.c      ****     {
 6094              		.loc 1 3022 0
 6095 3548 000050E3 		cmp	r0, #0
 6096 354c AE01001A 		bne	.L601
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6097              		.loc 1 3028 0
 6098 3550 0300A0E3 		mov	r0, #3
 6099              	.LVL724:
 6100 3554 0410A0E3 		mov	r1, #4
 6101 3558 FEFFFFEB 		bl	CyU3PDebugInit
 6102              	.LVL725:
3029:../uvc.c      ****     {
 6103              		.loc 1 3029 0
 6104 355c 000050E3 		cmp	r0, #0
 6105 3560 A901001A 		bne	.L601
3035:../uvc.c      **** }
 6106              		.loc 1 3035 0
 6107 3564 FEFFFFEB 		bl	CyU3PDebugPreamble
 6108              	.LVL726:
 6109 3568 0640A0E3 		mov	r4, #6
 6110              	.LVL727:
 6111              	.L527:
 6112              	.LBE99:
 6113              	.LBE98:
3557:../uvc.c      **** 	}
 6114              		.loc 1 3557 0
 6115 356c 7D0FA0E3 		mov	r0, #500
 6116 3570 014044E2 		sub	r4, r4, #1
 6117 3574 FEFFFFEB 		bl	_tx_thread_sleep
 6118              	.LVL728:
3556:../uvc.c      **** 		CyU3PThreadSleep(500);
 6119              		.loc 1 3556 0
 6120 3578 FF4014E2 		ands	r4, r4, #255
 6121 357c FAFFFF1A 		bne	.L527
 6122              	.LBB101:
 6123              	.LBB102:
3045:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6124              		.loc 1 3045 0
 6125 3580 FEFFFFEB 		bl	CyU3PI2cInit
 6126              	.LVL729:
3046:../uvc.c      ****     {
 6127              		.loc 1 3046 0
 6128 3584 005050E2 		subs	r5, r0, #0
 6129 3588 3002001A 		bne	.L603
3053:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6130              		.loc 1 3053 0
 6131 358c D8299FE5 		ldr	r2, .L633+4
3055:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6132              		.loc 1 3055 0
 6133 3590 0030E0E3 		mvn	r3, #0
3058:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6134              		.loc 1 3058 0
 6135 3594 60008DE2 		add	r0, sp, #96
 6136              	.LVL730:
 6137 3598 0410A0E1 		mov	r1, r4
3054:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6138              		.loc 1 3054 0
 6139 359c 64408DE5 		str	r4, [sp, #100]
3053:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6140              		.loc 1 3053 0
 6141 35a0 60208DE5 		str	r2, [sp, #96]
3055:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6142              		.loc 1 3055 0
 6143 35a4 68308DE5 		str	r3, [sp, #104]
3056:../uvc.c      **** 
 6144              		.loc 1 3056 0
 6145 35a8 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
3058:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6146              		.loc 1 3058 0
 6147 35ac FEFFFFEB 		bl	CyU3PI2cSetConfig
 6148              	.LVL731:
3059:../uvc.c      ****     {
 6149              		.loc 1 3059 0
 6150 35b0 005050E2 		subs	r5, r0, #0
 6151 35b4 2002001A 		bne	.L604
 6152              	.LBE102:
 6153              	.LBE101:
 6154              	.LBB104:
 6155              	.LBB105:
3132:../uvc.c      ****     if (apiRetStatus != 0)
 6156              		.loc 1 3132 0
 6157 35b8 B0799FE5 		ldr	r7, .L633+8
 6158 35bc 0410A0E1 		mov	r1, r4
 6159 35c0 0700A0E1 		mov	r0, r7
 6160              	.LVL732:
 6161 35c4 2820A0E3 		mov	r2, #40
 6162 35c8 FEFFFFEB 		bl	_txe_event_flags_create
 6163              	.LVL733:
3133:../uvc.c      ****     {
 6164              		.loc 1 3133 0
 6165 35cc 005050E2 		subs	r5, r0, #0
 6166              	.LVL734:
 6167 35d0 1302001A 		bne	.L605
3147:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6168              		.loc 1 3147 0
 6169 35d4 0230A0E3 		mov	r3, #2
3150:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6170              		.loc 1 3150 0
 6171 35d8 0320A0E3 		mov	r2, #3
3154:../uvc.c      ****     if (apiRetStatus != 0)
 6172              		.loc 1 3154 0
 6173 35dc 14008DE2 		add	r0, sp, #20
 6174              	.LVL735:
 6175 35e0 0410A0E1 		mov	r1, r4
3143:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6176              		.loc 1 3143 0
 6177 35e4 8C4087E5 		str	r4, [r7, #140]
3144:../uvc.c      **** 
 6178              		.loc 1 3144 0
 6179 35e8 904087E5 		str	r4, [r7, #144]
3149:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6180              		.loc 1 3149 0
 6181 35ec 1C40CDE5 		strb	r4, [sp, #28]
3151:../uvc.c      **** 
 6182              		.loc 1 3151 0
 6183 35f0 18408DE5 		str	r4, [sp, #24]
3147:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6184              		.loc 1 3147 0
 6185 35f4 1430CDE5 		strb	r3, [sp, #20]
3148:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6186              		.loc 1 3148 0
 6187 35f8 1530CDE5 		strb	r3, [sp, #21]
3150:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6188              		.loc 1 3150 0
 6189 35fc 1D20CDE5 		strb	r2, [sp, #29]
3154:../uvc.c      ****     if (apiRetStatus != 0)
 6190              		.loc 1 3154 0
 6191 3600 FEFFFFEB 		bl	CyU3PGpioInit
 6192              	.LVL736:
3155:../uvc.c      ****     {
 6193              		.loc 1 3155 0
 6194 3604 005050E2 		subs	r5, r0, #0
 6195 3608 FF01001A 		bne	.L606
3163:../uvc.c      ****     if (apiRetStatus != 0)
 6196              		.loc 1 3163 0
 6197 360c 1600A0E3 		mov	r0, #22
 6198              	.LVL737:
 6199 3610 0110A0E3 		mov	r1, #1
 6200 3614 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6201              	.LVL738:
3164:../uvc.c      ****     {
 6202              		.loc 1 3164 0
 6203 3618 005050E2 		subs	r5, r0, #0
 6204 361c 3A02001A 		bne	.L607
3169:../uvc.c      ****     if (apiRetStatus != 0)
 6205              		.loc 1 3169 0
 6206 3620 1400A0E3 		mov	r0, #20
 6207              	.LVL739:
 6208 3624 0110A0E3 		mov	r1, #1
 6209 3628 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6210              	.LVL740:
3170:../uvc.c      ****     {
 6211              		.loc 1 3170 0
 6212 362c 005050E2 		subs	r5, r0, #0
 6213 3630 2F02001A 		bne	.L608
3175:../uvc.c      ****     if (apiRetStatus != 0)
 6214              		.loc 1 3175 0
 6215 3634 1800A0E3 		mov	r0, #24
 6216              	.LVL741:
 6217 3638 0110A0E3 		mov	r1, #1
 6218 363c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6219              	.LVL742:
3176:../uvc.c      ****     {
 6220              		.loc 1 3176 0
 6221 3640 005050E2 		subs	r5, r0, #0
 6222 3644 2402001A 		bne	.L609
3183:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6223              		.loc 1 3183 0
 6224 3648 0150A0E3 		mov	r5, #1
3188:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6225              		.loc 1 3188 0
 6226 364c 30108DE2 		add	r1, sp, #48
 6227 3650 1600A0E3 		mov	r0, #22
 6228              	.LVL743:
3186:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6229              		.loc 1 3186 0
 6230 3654 3C408DE5 		str	r4, [sp, #60]
3187:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6231              		.loc 1 3187 0
 6232 3658 4040CDE5 		strb	r4, [sp, #64]
3183:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6233              		.loc 1 3183 0
 6234 365c 30508DE5 		str	r5, [sp, #48]
3184:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6235              		.loc 1 3184 0
 6236 3660 34508DE5 		str	r5, [sp, #52]
3185:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6237              		.loc 1 3185 0
 6238 3664 38508DE5 		str	r5, [sp, #56]
3188:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6239              		.loc 1 3188 0
 6240 3668 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6241              	.LVL744:
3189:../uvc.c      ****     {
 6242              		.loc 1 3189 0
 6243 366c 006050E2 		subs	r6, r0, #0
 6244 3670 1302001A 		bne	.L610
3202:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6245              		.loc 1 3202 0
 6246 3674 1400A0E3 		mov	r0, #20
 6247              	.LVL745:
 6248 3678 30108DE2 		add	r1, sp, #48
3200:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6249              		.loc 1 3200 0
 6250 367c 3C408DE5 		str	r4, [sp, #60]
3201:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6251              		.loc 1 3201 0
 6252 3680 4040CDE5 		strb	r4, [sp, #64]
3197:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6253              		.loc 1 3197 0
 6254 3684 30508DE5 		str	r5, [sp, #48]
3198:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6255              		.loc 1 3198 0
 6256 3688 34508DE5 		str	r5, [sp, #52]
3199:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6257              		.loc 1 3199 0
 6258 368c 38508DE5 		str	r5, [sp, #56]
3202:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6259              		.loc 1 3202 0
 6260 3690 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6261              	.LVL746:
3203:../uvc.c      ****     {
 6262              		.loc 1 3203 0
 6263 3694 004050E2 		subs	r4, r0, #0
 6264 3698 0302001A 		bne	.L611
3211:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6265              		.loc 1 3211 0
 6266 369c 0030A0E3 		mov	r3, #0
3216:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6267              		.loc 1 3216 0
 6268 36a0 30108DE2 		add	r1, sp, #48
3214:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6269              		.loc 1 3214 0
 6270 36a4 0150A0E3 		mov	r5, #1
3216:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6271              		.loc 1 3216 0
 6272 36a8 1800A0E3 		mov	r0, #24
 6273              	.LVL747:
3211:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6274              		.loc 1 3211 0
 6275 36ac 30308DE5 		str	r3, [sp, #48]
3212:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6276              		.loc 1 3212 0
 6277 36b0 34308DE5 		str	r3, [sp, #52]
3213:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6278              		.loc 1 3213 0
 6279 36b4 38308DE5 		str	r3, [sp, #56]
3215:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6280              		.loc 1 3215 0
 6281 36b8 4030CDE5 		strb	r3, [sp, #64]
3214:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6282              		.loc 1 3214 0
 6283 36bc 3C508DE5 		str	r5, [sp, #60]
3216:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6284              		.loc 1 3216 0
 6285 36c0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6286              	.LVL748:
3217:../uvc.c      ****     {
 6287              		.loc 1 3217 0
 6288 36c4 004050E2 		subs	r4, r0, #0
 6289 36c8 F101001A 		bne	.L612
3224:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6290              		.loc 1 3224 0
 6291 36cc 0260A0E3 		mov	r6, #2
3225:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6292              		.loc 1 3225 0
 6293 36d0 0380A0E3 		mov	r8, #3
3229:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6294              		.loc 1 3229 0
 6295 36d4 0500A0E1 		mov	r0, r5
 6296              	.LVL749:
 6297 36d8 20108DE2 		add	r1, sp, #32
3226:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6298              		.loc 1 3226 0
 6299 36dc 28408DE5 		str	r4, [sp, #40]
3227:../uvc.c      **** 
 6300              		.loc 1 3227 0
 6301 36e0 24408DE5 		str	r4, [sp, #36]
3224:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6302              		.loc 1 3224 0
 6303 36e4 B062CDE1 		strh	r6, [sp, #32]	@ movhi
3225:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6304              		.loc 1 3225 0
 6305 36e8 2C80CDE5 		strb	r8, [sp, #44]
3229:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6306              		.loc 1 3229 0
 6307 36ec FEFFFFEB 		bl	CyU3PPibInit
 6308              	.LVL750:
3230:../uvc.c      ****     {
 6309              		.loc 1 3230 0
 6310 36f0 004050E2 		subs	r4, r0, #0
 6311 36f4 E001001A 		bne	.L613
3237:../uvc.c      **** 
 6312              		.loc 1 3237 0
 6313 36f8 74089FE5 		ldr	r0, .L633+12
 6314              	.LVL751:
 6315 36fc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6316              	.LVL752:
3245:../uvc.c      ****     CyU3PThreadSleep(5000);
 6317              		.loc 1 3245 0
 6318 3700 FEFFFFEB 		bl	SensorReset
 6319              	.LVL753:
3246:../uvc.c      ****     //SensorInit ();
 6320              		.loc 1 3246 0
 6321 3704 6C089FE5 		ldr	r0, .L633+16
 6322 3708 FEFFFFEB 		bl	_tx_thread_sleep
 6323              	.LVL754:
3250:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6324              		.loc 1 3250 0
 6325 370c FEFFFFEB 		bl	CyU3PUsbStart
 6326              	.LVL755:
3251:../uvc.c      ****     {
 6327              		.loc 1 3251 0
 6328 3710 004050E2 		subs	r4, r0, #0
 6329 3714 D201001A 		bne	.L614
3257:../uvc.c      **** 
 6330              		.loc 1 3257 0
 6331 3718 0410A0E1 		mov	r1, r4
 6332 371c 58089FE5 		ldr	r0, .L633+20
 6333              	.LVL756:
 6334 3720 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6335              	.LVL757:
3260:../uvc.c      **** 
 6336              		.loc 1 3260 0
 6337 3724 54089FE5 		ldr	r0, .L633+24
 6338 3728 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6339              	.LVL758:
3266:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6340              		.loc 1 3266 0
 6341 372c 0410A0E1 		mov	r1, r4
 6342 3730 4C289FE5 		ldr	r2, .L633+28
 6343 3734 0500A0E1 		mov	r0, r5
 6344 3738 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6345              	.LVL759:
3267:../uvc.c      **** 
 6346              		.loc 1 3267 0
 6347 373c 0410A0E1 		mov	r1, r4
 6348 3740 0400A0E1 		mov	r0, r4
 6349 3744 3C289FE5 		ldr	r2, .L633+32
 6350 3748 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6351              	.LVL760:
3270:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6352              		.loc 1 3270 0
 6353 374c 0410A0E1 		mov	r1, r4
 6354 3750 34289FE5 		ldr	r2, .L633+36
 6355 3754 0600A0E1 		mov	r0, r6
 6356 3758 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6357              	.LVL761:
3271:../uvc.c      **** 
 6358              		.loc 1 3271 0
 6359 375c 0410A0E1 		mov	r1, r4
 6360 3760 28289FE5 		ldr	r2, .L633+40
 6361 3764 0700A0E3 		mov	r0, #7
 6362 3768 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6363              	.LVL762:
3274:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6364              		.loc 1 3274 0
 6365 376c 0410A0E1 		mov	r1, r4
 6366 3770 1C289FE5 		ldr	r2, .L633+44
 6367 3774 0400A0E3 		mov	r0, #4
 6368 3778 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6369              	.LVL763:
3275:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6370              		.loc 1 3275 0
 6371 377c 0410A0E1 		mov	r1, r4
 6372 3780 10289FE5 		ldr	r2, .L633+48
 6373 3784 0800A0E1 		mov	r0, r8
 6374 3788 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6375              	.LVL764:
3276:../uvc.c      **** 
 6376              		.loc 1 3276 0
 6377 378c 0410A0E1 		mov	r1, r4
 6378 3790 04289FE5 		ldr	r2, .L633+52
 6379 3794 0600A0E3 		mov	r0, #6
 6380 3798 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6381              	.LVL765:
3279:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6382              		.loc 1 3279 0
 6383 379c 0410A0E1 		mov	r1, r4
 6384 37a0 F8279FE5 		ldr	r2, .L633+56
 6385 37a4 0500A0E3 		mov	r0, #5
 6386 37a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6387              	.LVL766:
3280:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6388              		.loc 1 3280 0
 6389 37ac 0510A0E1 		mov	r1, r5
 6390 37b0 EC279FE5 		ldr	r2, .L633+60
 6391 37b4 0500A0E3 		mov	r0, #5
 6392 37b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6393              	.LVL767:
3281:../uvc.c      **** 
 6394              		.loc 1 3281 0
 6395 37bc 0610A0E1 		mov	r1, r6
 6396 37c0 E0279FE5 		ldr	r2, .L633+64
 6397 37c4 0500A0E3 		mov	r0, #5
 6398 37c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6399              	.LVL768:
3290:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6400              		.loc 1 3290 0
 6401 37cc 4030A0E3 		mov	r3, #64
3294:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6402              		.loc 1 3294 0
 6403 37d0 08108DE2 		add	r1, sp, #8
 6404 37d4 8200A0E3 		mov	r0, #130
3291:../uvc.c      ****     endPointConfig.streams  = 0;
 6405              		.loc 1 3291 0
 6406 37d8 1340CDE5 		strb	r4, [sp, #19]
3292:../uvc.c      ****     endPointConfig.burstLen = 1;
 6407              		.loc 1 3292 0
 6408 37dc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3288:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6409              		.loc 1 3288 0
 6410 37e0 08508DE5 		str	r5, [sp, #8]
3289:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6411              		.loc 1 3289 0
 6412 37e4 0C80CDE5 		strb	r8, [sp, #12]
3293:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6413              		.loc 1 3293 0
 6414 37e8 1250CDE5 		strb	r5, [sp, #18]
3290:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6415              		.loc 1 3290 0
 6416 37ec B031CDE1 		strh	r3, [sp, #16]	@ movhi
3294:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6417              		.loc 1 3294 0
 6418 37f0 FEFFFFEB 		bl	CyU3PSetEpConfig
 6419              	.LVL769:
3295:../uvc.c      ****     {
 6420              		.loc 1 3295 0
 6421 37f4 004050E2 		subs	r4, r0, #0
3298:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6422              		.loc 1 3298 0
 6423 37f8 0400A013 		movne	r0, #4
 6424              	.LVL770:
3295:../uvc.c      ****     {
 6425              		.loc 1 3295 0
 6426 37fc 7101001A 		bne	.L599
3303:../uvc.c      ****     dmaInterConfig.count          = 1;
 6427              		.loc 1 3303 0
 6428 3800 A4C79FE5 		ldr	ip, .L633+68
 6429 3804 413BA0E3 		mov	r3, #66560
3312:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6430              		.loc 1 3312 0
 6431 3808 1080A0E3 		mov	r8, #16
3314:../uvc.c      ****             &dmaInterConfig);
 6432              		.loc 1 3314 0
 6433 380c 9C079FE5 		ldr	r0, .L633+72
 6434 3810 0410A0E3 		mov	r1, #4
 6435 3814 44208DE2 		add	r2, sp, #68
3303:../uvc.c      ****     dmaInterConfig.count          = 1;
 6436              		.loc 1 3303 0
 6437 3818 4C408DE5 		str	r4, [sp, #76]
 6438 381c 50408DE5 		str	r4, [sp, #80]
3311:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6439              		.loc 1 3311 0
 6440 3820 5440CDE5 		strb	r4, [sp, #84]
3313:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6441              		.loc 1 3313 0
 6442 3824 5C408DE5 		str	r4, [sp, #92]
3303:../uvc.c      ****     dmaInterConfig.count          = 1;
 6443              		.loc 1 3303 0
 6444 3828 48C08DE5 		str	ip, [sp, #72]
 6445 382c 44308DE5 		str	r3, [sp, #68]
3312:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6446              		.loc 1 3312 0
 6447 3830 58808DE5 		str	r8, [sp, #88]
3314:../uvc.c      ****             &dmaInterConfig);
 6448              		.loc 1 3314 0
 6449 3834 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6450              	.LVL771:
3316:../uvc.c      ****     {
 6451              		.loc 1 3316 0
 6452 3838 004050E2 		subs	r4, r0, #0
 6453 383c BE01001A 		bne	.L615
3323:../uvc.c      ****     if (glInterStaBuffer == 0)
 6454              		.loc 1 3323 0
 6455 3840 010BA0E3 		mov	r0, #1024
 6456              	.LVL772:
 6457 3844 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6458              	.LVL773:
 6459 3848 64379FE5 		ldr	r3, .L633+76
3324:../uvc.c      ****     {
 6460              		.loc 1 3324 0
 6461 384c 000050E3 		cmp	r0, #0
3323:../uvc.c      ****     if (glInterStaBuffer == 0)
 6462              		.loc 1 3323 0
 6463 3850 000083E5 		str	r0, [r3]
3324:../uvc.c      ****     {
 6464              		.loc 1 3324 0
 6465 3854 BE01000A 		beq	.L616
3331:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6466              		.loc 1 3331 0
 6467 3858 0410A0E1 		mov	r1, r4
 6468 385c 0420A0E1 		mov	r2, r4
 6469 3860 3830A0E3 		mov	r3, #56
 6470 3864 4C079FE5 		ldr	r0, .L633+80
 6471 3868 FEFFFFEB 		bl	_txe_mutex_create
 6472              	.LVL774:
3336:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6473              		.loc 1 3336 0
 6474 386c 48179FE5 		ldr	r1, .L633+84
3337:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6475              		.loc 1 3337 0
 6476 3870 48279FE5 		ldr	r2, .L633+88
3344:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6477              		.loc 1 3344 0
 6478 3874 48A79FE5 		ldr	r10, .L633+92
3333:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6479              		.loc 1 3333 0
 6480 3878 0480A0E3 		mov	r8, #4
3335:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6481              		.loc 1 3335 0
 6482 387c 01ECA0E3 		mov	lr, #256
3339:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6483              		.loc 1 3339 0
 6484 3880 0CC0A0E3 		mov	ip, #12
3343:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6485              		.loc 1 3343 0
 6486 3884 1830A0E3 		mov	r3, #24
3336:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6487              		.loc 1 3336 0
 6488 3888 B816CDE1 		strh	r1, [sp, #104]	@ movhi
3337:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6489              		.loc 1 3337 0
 6490 388c BE26CDE1 		strh	r2, [sp, #110]	@ movhi
3332:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6491              		.loc 1 3332 0
 6492 3890 0199A0E3 		mov	r9, #16384
3345:../uvc.c      ****             &dmaMultiConfig);
 6493              		.loc 1 3345 0
 6494 3894 2C079FE5 		ldr	r0, .L633+96
 6495 3898 0710A0E3 		mov	r1, #7
 6496 389c 60208DE2 		add	r2, sp, #96
3338:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6497              		.loc 1 3338 0
 6498 38a0 B647CDE1 		strh	r4, [sp, #118]	@ movhi
3341:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6499              		.loc 1 3341 0
 6500 38a4 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
3342:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6501              		.loc 1 3342 0
 6502 38a8 7E40CDE5 		strb	r4, [sp, #126]
3334:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6503              		.loc 1 3334 0
 6504 38ac B466CDE1 		strh	r6, [sp, #100]	@ movhi
3344:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6505              		.loc 1 3344 0
 6506 38b0 84A08DE5 		str	r10, [sp, #132]
3332:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6507              		.loc 1 3332 0
 6508 38b4 B096CDE1 		strh	r9, [sp, #96]	@ movhi
3333:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6509              		.loc 1 3333 0
 6510 38b8 B286CDE1 		strh	r8, [sp, #98]	@ movhi
3340:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6511              		.loc 1 3340 0
 6512 38bc BA87CDE1 		strh	r8, [sp, #122]	@ movhi
3335:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6513              		.loc 1 3335 0
 6514 38c0 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
3339:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6515              		.loc 1 3339 0
 6516 38c4 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
3343:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6517              		.loc 1 3343 0
 6518 38c8 80308DE5 		str	r3, [sp, #128]
3345:../uvc.c      ****             &dmaMultiConfig);
 6519              		.loc 1 3345 0
 6520 38cc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6521              	.LVL775:
3347:../uvc.c      ****     {
 6522              		.loc 1 3347 0
 6523 38d0 004050E2 		subs	r4, r0, #0
 6524 38d4 9201001A 		bne	.L617
3438:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6525              		.loc 1 3438 0
 6526 38d8 0500A0E1 		mov	r0, r5
 6527              	.LVL776:
 6528 38dc 0510A0E1 		mov	r1, r5
 6529 38e0 FEFFFFEB 		bl	CyU3PConnectState
 6530              	.LVL777:
3439:../uvc.c      ****     {
 6531              		.loc 1 3439 0
 6532 38e4 004050E2 		subs	r4, r0, #0
 6533 38e8 3B01001A 		bne	.L618
3445:../uvc.c      **** 
 6534              		.loc 1 3445 0
 6535 38ec 6400A0E3 		mov	r0, #100
 6536              	.LVL778:
 6537 38f0 FEFFFFEB 		bl	CyFx3BusyWait
 6538              	.LVL779:
3447:../uvc.c      **** 
 6539              		.loc 1 3447 0
 6540 38f4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6541              	.LVL780:
3462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6542              		.loc 1 3462 0
 6543 38f8 08108DE2 		add	r1, sp, #8
3461:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6544              		.loc 1 3461 0
 6545 38fc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
3449:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6546              		.loc 1 3449 0
 6547 3900 08508DE5 		str	r5, [sp, #8]
3450:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6548              		.loc 1 3450 0
 6549 3904 0C60CDE5 		strb	r6, [sp, #12]
3454:../uvc.c      ****     }
 6550              		.loc 1 3454 0
 6551 3908 030050E3 		cmp	r0, #3
3447:../uvc.c      **** 
 6552              		.loc 1 3447 0
 6553 390c 0030A0E1 		mov	r3, r0
3454:../uvc.c      ****     }
 6554              		.loc 1 3454 0
 6555 3910 01C0A013 		movne	ip, #1
 6556 3914 10C0A003 		moveq	ip, #16
 6557 3918 022CA013 		movne	r2, #512
 6558 391c 012BA003 		moveq	r2, #1024
3462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6559              		.loc 1 3462 0
 6560 3920 8300A0E3 		mov	r0, #131
3447:../uvc.c      **** 
 6561              		.loc 1 3447 0
 6562 3924 4830C7E5 		strb	r3, [r7, #72]
 6563 3928 12C0CDE5 		strb	ip, [sp, #18]
 6564 392c B021CDE1 		strh	r2, [sp, #16]	@ movhi
3462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6565              		.loc 1 3462 0
 6566 3930 FEFFFFEB 		bl	CyU3PSetEpConfig
 6567              	.LVL781:
3463:../uvc.c      ****     {
 6568              		.loc 1 3463 0
 6569 3934 004050E2 		subs	r4, r0, #0
 6570              	.LBE105:
 6571              	.LBE104:
3586:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6572              		.loc 1 3586 0
 6573 3938 30469F05 		ldreq	r4, .L633+8
 6574              	.LBB110:
 6575              	.LBB106:
3463:../uvc.c      ****     {
 6576              		.loc 1 3463 0
 6577 393c 0C00000A 		beq	.L578
 6578 3940 1F0100EA 		b	.L632
 6579              	.LVL782:
 6580              	.L621:
 6581              	.LBE106:
 6582              	.LBE110:
3632:../uvc.c      ****             {
 6583              		.loc 1 3632 0
 6584 3944 7C3094E5 		ldr	r3, [r4, #124]
 6585 3948 050053E1 		cmp	r3, r5
 6586 394c 0300000A 		beq	.L548
3632:../uvc.c      ****             {
 6587              		.loc 1 3632 0 is_stmt 0 discriminator 1
 6588 3950 B028D4E1 		ldrh	r2, [r4, #128]
 6589 3954 B238D4E1 		ldrh	r3, [r4, #130]
 6590 3958 030052E1 		cmp	r2, r3
 6591 395c 3B00000A 		beq	.L620
 6592              	.L548:
3836:../uvc.c      **** 
 6593              		.loc 1 3836 0 is_stmt 1
 6594 3960 4010A0E3 		mov	r1, #64
 6595 3964 0020A0E3 		mov	r2, #0
 6596 3968 00069FE5 		ldr	r0, .L633+8
 6597 396c FEFFFFEB 		bl	_txe_event_flags_set
 6598              	.LVL783:
3839:../uvc.c      ****     }
 6599              		.loc 1 3839 0
 6600 3970 FEFFFFEB 		bl	_txe_thread_relinquish
 6601              	.LVL784:
 6602              	.L578:
3586:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6603              		.loc 1 3586 0
 6604 3974 0050A0E3 		mov	r5, #0
 6605 3978 00508DE5 		str	r5, [sp]
 6606 397c EC059FE5 		ldr	r0, .L633+8
 6607 3980 0110A0E3 		mov	r1, #1
 6608 3984 0220A0E3 		mov	r2, #2
 6609 3988 60308DE2 		add	r3, sp, #96
 6610 398c FEFFFFEB 		bl	_txe_event_flags_get
 6611              	.LVL785:
 6612 3990 006050E2 		subs	r6, r0, #0
 6613 3994 EAFFFF0A 		beq	.L621
3743:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6614              		.loc 1 3743 0
 6615 3998 00508DE5 		str	r5, [sp]
 6616 399c CC059FE5 		ldr	r0, .L633+8
 6617 39a0 0210A0E3 		mov	r1, #2
 6618 39a4 0320A0E3 		mov	r2, #3
 6619 39a8 60308DE2 		add	r3, sp, #96
 6620 39ac FEFFFFEB 		bl	_txe_event_flags_get
 6621              	.LVL786:
 6622 39b0 000050E3 		cmp	r0, #0
 6623 39b4 0B00001A 		bne	.L570
3758:../uvc.c      ****                 {
 6624              		.loc 1 3758 0
 6625 39b8 903094E5 		ldr	r3, [r4, #144]
3746:../uvc.c      ****                 prodCount = 0;
 6626              		.loc 1 3746 0
 6627 39bc 7C0084E5 		str	r0, [r4, #124]
3758:../uvc.c      ****                 {
 6628              		.loc 1 3758 0
 6629 39c0 000053E3 		cmp	r3, #0
3747:../uvc.c      ****                 consCount = 0;
 6630              		.loc 1 3747 0
 6631 39c4 B008C4E1 		strh	r0, [r4, #128]	@ movhi
3754:../uvc.c      ****                 pb=0;
 6632              		.loc 1 3754 0
 6633 39c8 B407C4E1 		strh	r0, [r4, #116]	@ movhi
3748:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6634              		.loc 1 3748 0
 6635 39cc B208C4E1 		strh	r0, [r4, #130]	@ movhi
3755:../uvc.c      ****                 pbc=0;
 6636              		.loc 1 3755 0
 6637 39d0 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3756:../uvc.c      **** 
 6638              		.loc 1 3756 0
 6639 39d4 B807C4E1 		strh	r0, [r4, #120]	@ movhi
3758:../uvc.c      ****                 {
 6640              		.loc 1 3758 0
 6641 39d8 4600000A 		beq	.L622
 6642              	.L571:
3770:../uvc.c      ****             }
 6643              		.loc 1 3770 0
 6644 39dc 0030A0E3 		mov	r3, #0
 6645 39e0 903087E5 		str	r3, [r7, #144]
 6646 39e4 DDFFFFEA 		b	.L548
 6647              	.L570:
3775:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6648              		.loc 1 3775 0
 6649 39e8 0030E0E3 		mvn	r3, #0
 6650 39ec 00308DE5 		str	r3, [sp]
 6651 39f0 0110A0E3 		mov	r1, #1
 6652 39f4 0220A0E3 		mov	r2, #2
 6653 39f8 60308DE2 		add	r3, sp, #96
 6654 39fc 6C059FE5 		ldr	r0, .L633+8
 6655 3a00 FEFFFFEB 		bl	_txe_event_flags_get
 6656              	.LVL787:
3779:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6657              		.loc 1 3779 0
 6658 3a04 0510A0E1 		mov	r1, r5
 6659 3a08 0520A0E1 		mov	r2, r5
 6660 3a0c B4059FE5 		ldr	r0, .L633+96
 6661 3a10 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6662              	.LVL788:
3780:../uvc.c      ****                 {
 6663              		.loc 1 3780 0
 6664 3a14 005050E2 		subs	r5, r0, #0
 6665 3a18 9D00001A 		bne	.L623
3788:../uvc.c      ****                 {
 6666              		.loc 1 3788 0
 6667 3a1c 883094E5 		ldr	r3, [r4, #136]
 6668 3a20 000053E3 		cmp	r3, #0
 6669 3a24 2B00001A 		bne	.L569
 6670              	.LVL789:
 6671              	.LBB111:
 6672              	.LBB112:
3491:../uvc.c      ****     {
 6673              		.loc 1 3491 0
 6674 3a28 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6675 3a2c 030053E3 		cmp	r3, #3
 6676 3a30 5E00000A 		beq	.L624
3496:../uvc.c      ****     {
 6677              		.loc 1 3496 0
 6678 3a34 020053E3 		cmp	r3, #2
 6679 3a38 7400000A 		beq	.L625
 6680              	.LVL790:
 6681              	.L576:
 6682              	.LBE112:
 6683              	.LBE111:
3824:../uvc.c      ****                     CyU3PThreadSleep(200);
 6684              		.loc 1 3824 0
 6685 3a3c 0130A0E3 		mov	r3, #1
3825:../uvc.c      ****                     
 6686              		.loc 1 3825 0
 6687 3a40 C800A0E3 		mov	r0, #200
3824:../uvc.c      ****                     CyU3PThreadSleep(200);
 6688              		.loc 1 3824 0
 6689 3a44 883087E5 		str	r3, [r7, #136]
3825:../uvc.c      ****                     
 6690              		.loc 1 3825 0
 6691 3a48 FEFFFFEB 		bl	_tx_thread_sleep
 6692              	.LVL791:
 6693 3a4c C3FFFFEA 		b	.L548
 6694              	.L620:
3658:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6695              		.loc 1 3658 0
 6696 3a50 74559FE5 		ldr	r5, .L633+100
3657:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6697              		.loc 1 3657 0
 6698 3a54 5C059FE5 		ldr	r0, .L633+80
 6699 3a58 0010E0E3 		mvn	r1, #0
3642:../uvc.c      ****                 consCount = 0;
 6700              		.loc 1 3642 0
 6701 3a5c B068C4E1 		strh	r6, [r4, #128]	@ movhi
3639:../uvc.c      ****             	pb=0;
 6702              		.loc 1 3639 0
 6703 3a60 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3643:../uvc.c      ****                 hitFV     = CyFalse;
 6704              		.loc 1 3643 0
 6705 3a64 B268C4E1 		strh	r6, [r4, #130]	@ movhi
3640:../uvc.c      ****             	pbc=0;
 6706              		.loc 1 3640 0
 6707 3a68 B667C4E1 		strh	r6, [r4, #118]	@ movhi
3641:../uvc.c      ****                 prodCount = 0;
 6708              		.loc 1 3641 0
 6709 3a6c B867C4E1 		strh	r6, [r4, #120]	@ movhi
3644:../uvc.c      **** 
 6710              		.loc 1 3644 0
 6711 3a70 7C6084E5 		str	r6, [r4, #124]
3657:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6712              		.loc 1 3657 0
 6713 3a74 FEFFFFEB 		bl	_txe_mutex_get
 6714              	.LVL792:
3658:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 6715              		.loc 1 3658 0
 6716 3a78 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 6717 3a7c 013023E2 		eor	r3, r3, #1
 6718 3a80 ED34C5E5 		strb	r3, [r5, #1261]
3660:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6719              		.loc 1 3660 0
 6720 3a84 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6721 3a88 F00053E3 		cmp	r3, #240
 6722 3a8c 3B00000A 		beq	.L626
 6723              	.L549:
3668:../uvc.c      **** 
 6724              		.loc 1 3668 0
 6725 3a90 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 6726 3a94 FF0053E3 		cmp	r3, #255
 6727 3a98 1D00000A 		beq	.L627
3680:../uvc.c      ****                     //CyU3PThreadSleep(400);
 6728              		.loc 1 3680 0
 6729 3a9c 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 6730 3aa0 AA0053E3 		cmp	r3, #170
 6731 3aa4 2700000A 		beq	.L628
 6732              	.L550:
3718:../uvc.c      ****                 /* Reset the DMA channel. */
 6733              		.loc 1 3718 0
 6734 3aa8 08059FE5 		ldr	r0, .L633+80
 6735 3aac FEFFFFEB 		bl	_txe_mutex_put
 6736              	.LVL793:
3720:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6737              		.loc 1 3720 0
 6738 3ab0 10059FE5 		ldr	r0, .L633+96
 6739 3ab4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6740              	.LVL794:
3721:../uvc.c      ****                 {
 6741              		.loc 1 3721 0
 6742 3ab8 005050E2 		subs	r5, r0, #0
 6743 3abc 7A00001A 		bne	.L629
3728:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6744              		.loc 1 3728 0
 6745 3ac0 0510A0E1 		mov	r1, r5
 6746 3ac4 0520A0E1 		mov	r2, r5
 6747 3ac8 F8049FE5 		ldr	r0, .L633+96
 6748              	.LVL795:
 6749 3acc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6750              	.LVL796:
3729:../uvc.c      ****                 {
 6751              		.loc 1 3729 0
 6752 3ad0 005050E2 		subs	r5, r0, #0
 6753 3ad4 6800001A 		bne	.L630
 6754              	.L569:
3737:../uvc.c      ****                 }
 6755              		.loc 1 3737 0
 6756 3ad8 DC049FE5 		ldr	r0, .L633+84
 6757              	.LVL797:
 6758 3adc 0230A0E3 		mov	r3, #2
 6759 3ae0 0010A0E3 		mov	r1, #0
 6760 3ae4 00308DE5 		str	r3, [sp]
 6761 3ae8 0020A0E1 		mov	r2, r0
 6762 3aec 0130A0E1 		mov	r3, r1
 6763 3af0 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6764              	.LVL798:
 6765 3af4 99FFFFEA 		b	.L548
 6766              	.LVL799:
 6767              	.L622:
3760:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6768              		.loc 1 3760 0
 6769 3af8 C8049FE5 		ldr	r0, .L633+96
 6770 3afc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6771              	.LVL800:
3761:../uvc.c      ****                     {
 6772              		.loc 1 3761 0
 6773 3b00 000050E3 		cmp	r0, #0
 6774 3b04 4000001A 		bne	.L601
3767:../uvc.c      ****                 }
 6775              		.loc 1 3767 0
 6776 3b08 8300A0E3 		mov	r0, #131
 6777              	.LVL801:
 6778 3b0c FEFFFFEB 		bl	CyU3PUsbFlushEp
 6779              	.LVL802:
 6780 3b10 B1FFFFEA 		b	.L571
 6781              	.L627:
3670:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 6782              		.loc 1 3670 0
 6783 3b14 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6784 3b18 020053E3 		cmp	r3, #2
 6785 3b1c 013083E2 		add	r3, r3, #1
 6786 3b20 E030C4E5 		strb	r3, [r4, #224]
 6787 3b24 DFFFFF9A 		bls	.L550
3671:../uvc.c      ****                 		stiflag = 0x0F;
 6788              		.loc 1 3671 0
 6789 3b28 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3672:../uvc.c      ****                 		IMcount = 0;
 6790              		.loc 1 3672 0
 6791 3b2c 0F30A0E3 		mov	r3, #15
3671:../uvc.c      ****                 		stiflag = 0x0F;
 6792              		.loc 1 3671 0
 6793 3b30 201081E3 		orr	r1, r1, #32
3673:../uvc.c      ****                 		}
 6794              		.loc 1 3673 0
 6795 3b34 0020A0E3 		mov	r2, #0
3671:../uvc.c      ****                 		stiflag = 0x0F;
 6796              		.loc 1 3671 0
 6797 3b38 ED14C5E5 		strb	r1, [r5, #1261]
3673:../uvc.c      ****                 		}
 6798              		.loc 1 3673 0
 6799 3b3c E020C4E5 		strb	r2, [r4, #224]
3672:../uvc.c      ****                 		IMcount = 0;
 6800              		.loc 1 3672 0
 6801 3b40 7230C4E5 		strb	r3, [r4, #114]
 6802 3b44 D7FFFFEA 		b	.L550
 6803              	.L628:
3686:../uvc.c      ****                 	{
 6804              		.loc 1 3686 0
 6805 3b48 E030D4E5 		ldrb	r3, [r4, #224]	@ zero_extendqisi2
 6806 3b4c 020053E3 		cmp	r3, #2
 6807 3b50 013083E2 		add	r3, r3, #1
 6808 3b54 E030C4E5 		strb	r3, [r4, #224]
 6809 3b58 D2FFFF9A 		bls	.L550
3688:../uvc.c      ****                      {
 6810              		.loc 1 3688 0
 6811 3b5c 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 6812 3b60 013043E2 		sub	r3, r3, #1
 6813 3b64 030053E3 		cmp	r3, #3
 6814 3b68 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 6815 3b6c 3E0000EA 		b	.L554
 6816              	.L556:
 6817 3b70 2C3C0000 		.word	.L555
 6818 3b74 183D0000 		.word	.L557
 6819 3b78 5C3D0000 		.word	.L558
 6820 3b7c C43C0000 		.word	.L559
 6821              	.L626:
3660:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 6822              		.loc 1 3660 0 discriminator 1
 6823 3b80 00608DE5 		str	r6, [sp]
 6824 3b84 E4039FE5 		ldr	r0, .L633+8
 6825 3b88 8010A0E3 		mov	r1, #128
 6826 3b8c 0320A0E3 		mov	r2, #3
 6827 3b90 60308DE2 		add	r3, sp, #96
 6828 3b94 FEFFFFEB 		bl	_txe_event_flags_get
 6829              	.LVL803:
 6830 3b98 000050E3 		cmp	r0, #0
 6831 3b9c BBFFFF1A 		bne	.L549
3665:../uvc.c      ****                 		IMcount = 0;
 6832              		.loc 1 3665 0
 6833 3ba0 0030E0E3 		mvn	r3, #0
3666:../uvc.c      ****                 	}
 6834              		.loc 1 3666 0
 6835 3ba4 E000C4E5 		strb	r0, [r4, #224]
3665:../uvc.c      ****                 		IMcount = 0;
 6836              		.loc 1 3665 0
 6837 3ba8 7230C4E5 		strb	r3, [r4, #114]
3666:../uvc.c      ****                 	}
 6838              		.loc 1 3666 0
 6839 3bac BDFFFFEA 		b	.L550
 6840              	.LVL804:
 6841              	.L624:
 6842              	.LBB115:
 6843              	.LBB113:
3493:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6844              		.loc 1 3493 0
 6845 3bb0 18149FE5 		ldr	r1, .L633+104
 6846 3bb4 0100A0E3 		mov	r0, #1
 6847              	.LVL805:
 6848 3bb8 FEFFFFEB 		bl	CyU3PDebugPrint
 6849              	.LVL806:
3494:../uvc.c      ****     }
 6850              		.loc 1 3494 0
 6851 3bbc 10049FE5 		ldr	r0, .L633+108
 6852 3bc0 FEFFFFEB 		bl	CyU3PGpifLoad
 6853              	.LVL807:
 6854 3bc4 0050A0E1 		mov	r5, r0
 6855              	.LVL808:
 6856              	.L575:
3501:../uvc.c      ****     {
 6857              		.loc 1 3501 0
 6858 3bc8 000055E3 		cmp	r5, #0
 6859 3bcc 8800001A 		bne	.L631
 6860              	.LVL809:
3513:../uvc.c      ****     {
 6861              		.loc 1 3513 0
 6862 3bd0 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 6863 3bd4 023043E2 		sub	r3, r3, #2
 6864 3bd8 FF3003E2 		and	r3, r3, #255
 6865 3bdc 010053E3 		cmp	r3, #1
 6866 3be0 95FFFF8A 		bhi	.L576
3511:../uvc.c      ****     }
 6867              		.loc 1 3511 0
 6868 3be4 0500A0E1 		mov	r0, r5
 6869 3be8 0510A0E1 		mov	r1, r5
 6870 3bec FEFFFFEB 		bl	CyU3PGpifSMStart
 6871              	.LVL810:
3517:../uvc.c      ****     {
 6872              		.loc 1 3517 0
 6873 3bf0 005050E2 		subs	r5, r0, #0
 6874 3bf4 90FFFF0A 		beq	.L576
3520:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6875              		.loc 1 3520 0
 6876 3bf8 0400A0E3 		mov	r0, #4
 6877              	.LVL811:
 6878 3bfc D4139FE5 		ldr	r1, .L633+112
 6879 3c00 0520A0E1 		mov	r2, r5
 6880 3c04 FEFFFFEB 		bl	CyU3PDebugPrint
 6881              	.LVL812:
3521:../uvc.c      ****     }
 6882              		.loc 1 3521 0
 6883 3c08 0500A0E1 		mov	r0, r5
 6884              	.LVL813:
 6885              	.L601:
3505:../uvc.c      ****     }
 6886              		.loc 1 3505 0
 6887 3c0c FEFFFFEB 		bl	CyFxAppErrorHandler
 6888              	.LVL814:
 6889              	.L625:
3498:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6890              		.loc 1 3498 0
 6891 3c10 C4139FE5 		ldr	r1, .L633+116
 6892 3c14 0100A0E3 		mov	r0, #1
 6893              	.LVL815:
 6894 3c18 FEFFFFEB 		bl	CyU3PDebugPrint
 6895              	.LVL816:
3499:../uvc.c      ****     }
 6896              		.loc 1 3499 0
 6897 3c1c BC039FE5 		ldr	r0, .L633+120
 6898 3c20 FEFFFFEB 		bl	CyU3PGpifLoad
 6899              	.LVL817:
 6900 3c24 0050A0E1 		mov	r5, r0
 6901              	.LVL818:
 6902 3c28 E6FFFFEA 		b	.L575
 6903              	.LVL819:
 6904              	.L555:
 6905              	.LBE113:
 6906              	.LBE115:
3691:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6907              		.loc 1 3691 0
 6908 3c2c 6C2097E5 		ldr	r2, [r7, #108]
 6909 3c30 3010A0E3 		mov	r1, #48
 6910 3c34 000052E3 		cmp	r2, #0
 6911 3c38 A220A003 		moveq	r2, #162
 6912 3c3c 2220A013 		movne	r2, #34
 6913 3c40 5230A0E3 		mov	r3, #82
 6914 3c44 0100A0E3 		mov	r0, #1
 6915 3c48 FEFFFFEB 		bl	SensorSetIrisControl
 6916              	.LVL820:
3693:../uvc.c      ****                  		break;
 6917              		.loc 1 3693 0
 6918 3c4c 6C2097E5 		ldr	r2, [r7, #108]
 6919 3c50 0400A0E3 		mov	r0, #4
 6920 3c54 000052E3 		cmp	r2, #0
 6921 3c58 6C3097E5 		ldr	r3, [r7, #108]
 6922 3c5c A220A003 		moveq	r2, #162
 6923 3c60 2220A013 		movne	r2, #34
 6924 3c64 78139FE5 		ldr	r1, .L633+124
 6925 3c68 FEFFFFEB 		bl	CyU3PDebugPrint
 6926              	.LVL821:
 6927              	.L554:
3713:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6928              		.loc 1 3713 0
 6929 3c6c 0030A0E3 		mov	r3, #0
 6930 3c70 E030C7E5 		strb	r3, [r7, #224]
3715:../uvc.c      ****                 	}
 6931              		.loc 1 3715 0
 6932 3c74 7230C7E5 		strb	r3, [r7, #114]
 6933 3c78 8AFFFFEA 		b	.L550
 6934              	.LVL822:
 6935              	.L630:
3731:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6936              		.loc 1 3731 0
 6937 3c7c 0400A0E3 		mov	r0, #4
 6938              	.LVL823:
 6939 3c80 60139FE5 		ldr	r1, .L633+128
 6940 3c84 0520A0E1 		mov	r2, r5
 6941 3c88 FEFFFFEB 		bl	CyU3PDebugPrint
 6942              	.LVL824:
3732:../uvc.c      ****                 }
 6943              		.loc 1 3732 0
 6944 3c8c 0500A0E1 		mov	r0, r5
 6945 3c90 FEFFFFEB 		bl	CyFxAppErrorHandler
 6946              	.LVL825:
 6947              	.L623:
3783:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6948              		.loc 1 3783 0
 6949 3c94 0400A0E3 		mov	r0, #4
 6950              	.LVL826:
 6951 3c98 4C139FE5 		ldr	r1, .L633+132
 6952 3c9c 0520A0E1 		mov	r2, r5
 6953 3ca0 FEFFFFEB 		bl	CyU3PDebugPrint
 6954              	.LVL827:
3784:../uvc.c      ****                 }
 6955              		.loc 1 3784 0
 6956 3ca4 0500A0E1 		mov	r0, r5
 6957 3ca8 FEFFFFEB 		bl	CyFxAppErrorHandler
 6958              	.LVL828:
 6959              	.L629:
3723:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 6960              		.loc 1 3723 0
 6961 3cac 0400A0E3 		mov	r0, #4
 6962              	.LVL829:
 6963 3cb0 38139FE5 		ldr	r1, .L633+136
 6964 3cb4 0520A0E1 		mov	r2, r5
 6965 3cb8 FEFFFFEB 		bl	CyU3PDebugPrint
 6966              	.LVL830:
3724:../uvc.c      ****                 }
 6967              		.loc 1 3724 0
 6968 3cbc 0500A0E1 		mov	r0, r5
 6969 3cc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 6970              	.LVL831:
 6971              	.L559:
3706:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6972              		.loc 1 3706 0
 6973 3cc4 6C2097E5 		ldr	r2, [r7, #108]
 6974 3cc8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 6975 3ccc 000052E3 		cmp	r2, #0
 6976 3cd0 B020A003 		moveq	r2, #176
 6977 3cd4 3020A013 		movne	r2, #48
 6978 3cd8 032082E1 		orr	r2, r2, r3
 6979 3cdc 3010A0E3 		mov	r1, #48
 6980 3ce0 5230A0E3 		mov	r3, #82
 6981 3ce4 0100A0E3 		mov	r0, #1
 6982 3ce8 FEFFFFEB 		bl	SensorSetIrisControl
 6983              	.LVL832:
3708:../uvc.c      ****                  		break;
 6984              		.loc 1 3708 0
 6985 3cec 6C1097E5 		ldr	r1, [r7, #108]
 6986 3cf0 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 6987 3cf4 000051E3 		cmp	r1, #0
 6988 3cf8 B010A003 		moveq	r1, #176
 6989 3cfc 3010A013 		movne	r1, #48
 6990 3d00 022081E1 		orr	r2, r1, r2
 6991 3d04 6C3097E5 		ldr	r3, [r7, #108]
 6992 3d08 D4129FE5 		ldr	r1, .L633+124
 6993 3d0c 0400A0E3 		mov	r0, #4
 6994 3d10 FEFFFFEB 		bl	CyU3PDebugPrint
 6995              	.LVL833:
3709:../uvc.c      ****                  	default:
 6996              		.loc 1 3709 0
 6997 3d14 D4FFFFEA 		b	.L554
 6998              	.L557:
3696:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 6999              		.loc 1 3696 0
 7000 3d18 6C2097E5 		ldr	r2, [r7, #108]
 7001 3d1c 3010A0E3 		mov	r1, #48
 7002 3d20 000052E3 		cmp	r2, #0
 7003 3d24 9220A003 		moveq	r2, #146
 7004 3d28 1220A013 		movne	r2, #18
 7005 3d2c 5230A0E3 		mov	r3, #82
 7006 3d30 0100A0E3 		mov	r0, #1
 7007 3d34 FEFFFFEB 		bl	SensorSetIrisControl
 7008              	.LVL834:
3698:../uvc.c      ****                  		break;
 7009              		.loc 1 3698 0
 7010 3d38 6C2097E5 		ldr	r2, [r7, #108]
 7011 3d3c A0129FE5 		ldr	r1, .L633+124
 7012 3d40 000052E3 		cmp	r2, #0
 7013 3d44 6C3097E5 		ldr	r3, [r7, #108]
 7014 3d48 9220A003 		moveq	r2, #146
 7015 3d4c 1220A013 		movne	r2, #18
 7016 3d50 0400A0E3 		mov	r0, #4
 7017 3d54 FEFFFFEB 		bl	CyU3PDebugPrint
 7018              	.LVL835:
3699:../uvc.c      ****                  	case 3: //720
 7019              		.loc 1 3699 0
 7020 3d58 C3FFFFEA 		b	.L554
 7021              	.L558:
3701:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7022              		.loc 1 3701 0
 7023 3d5c 6C2097E5 		ldr	r2, [r7, #108]
 7024 3d60 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7025 3d64 000052E3 		cmp	r2, #0
 7026 3d68 8020A003 		moveq	r2, #128
 7027 3d6c 0020A013 		movne	r2, #0
 7028 3d70 032082E1 		orr	r2, r2, r3
 7029 3d74 3010A0E3 		mov	r1, #48
 7030 3d78 5230A0E3 		mov	r3, #82
 7031 3d7c 0100A0E3 		mov	r0, #1
 7032 3d80 FEFFFFEB 		bl	SensorSetIrisControl
 7033              	.LVL836:
3703:../uvc.c      ****                  		break;
 7034              		.loc 1 3703 0
 7035 3d84 6C1097E5 		ldr	r1, [r7, #108]
 7036 3d88 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7037 3d8c 000051E3 		cmp	r1, #0
 7038 3d90 8010A003 		moveq	r1, #128
 7039 3d94 0010A013 		movne	r1, #0
 7040 3d98 022081E1 		orr	r2, r1, r2
 7041 3d9c 6C3097E5 		ldr	r3, [r7, #108]
 7042 3da0 3C129FE5 		ldr	r1, .L633+124
 7043 3da4 0400A0E3 		mov	r0, #4
 7044 3da8 FEFFFFEB 		bl	CyU3PDebugPrint
 7045              	.LVL837:
3704:../uvc.c      ****                  	case 4: //VGA
 7046              		.loc 1 3704 0
 7047 3dac AEFFFFEA 		b	.L554
 7048              	.LVL838:
 7049              	.L602:
 7050              	.LBB116:
 7051              	.LBB100:
3000:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7052              		.loc 1 3000 0
 7053 3db0 0400A0E3 		mov	r0, #4
 7054              	.LVL839:
 7055 3db4 38129FE5 		ldr	r1, .L633+140
 7056 3db8 FEFFFFEB 		bl	CyU3PDebugPrint
 7057              	.LVL840:
3001:../uvc.c      ****     }
 7058              		.loc 1 3001 0
 7059 3dbc 0400A0E1 		mov	r0, r4
 7060 3dc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7061              	.LVL841:
 7062              	.L632:
 7063              	.LBE100:
 7064              	.LBE116:
 7065              	.LBB117:
 7066              	.LBB107:
3466:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7067              		.loc 1 3466 0
 7068 3dc4 0800A0E1 		mov	r0, r8
 7069              	.LVL842:
 7070              	.L599:
 7071 3dc8 28129FE5 		ldr	r1, .L633+144
 7072 3dcc 0420A0E1 		mov	r2, r4
 7073 3dd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7074              	.LVL843:
3467:../uvc.c      ****     }
 7075              		.loc 1 3467 0
 7076 3dd4 0400A0E1 		mov	r0, r4
 7077 3dd8 8BFFFFEA 		b	.L601
 7078              	.LVL844:
 7079              	.L618:
3441:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7080              		.loc 1 3441 0
 7081 3ddc 0800A0E1 		mov	r0, r8
 7082              	.LVL845:
 7083 3de0 14129FE5 		ldr	r1, .L633+148
 7084 3de4 0420A0E1 		mov	r2, r4
 7085 3de8 FEFFFFEB 		bl	CyU3PDebugPrint
 7086              	.LVL846:
3442:../uvc.c      ****     }
 7087              		.loc 1 3442 0
 7088 3dec 0400A0E1 		mov	r0, r4
 7089 3df0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7090              	.LVL847:
 7091              	.L631:
 7092              	.LBE107:
 7093              	.LBE117:
 7094              	.LBB118:
 7095              	.LBB114:
3504:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7096              		.loc 1 3504 0
 7097 3df4 0400A0E3 		mov	r0, #4
 7098              	.LVL848:
 7099 3df8 00129FE5 		ldr	r1, .L633+152
 7100 3dfc 0520A0E1 		mov	r2, r5
 7101 3e00 FEFFFFEB 		bl	CyU3PDebugPrint
 7102              	.LVL849:
3505:../uvc.c      ****     }
 7103              		.loc 1 3505 0
 7104 3e04 0500A0E1 		mov	r0, r5
 7105 3e08 7FFFFFEA 		b	.L601
 7106              	.LVL850:
 7107              	.L606:
 7108              	.LBE114:
 7109              	.LBE118:
 7110              	.LBB119:
 7111              	.LBB108:
3157:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7112              		.loc 1 3157 0
 7113 3e0c 0400A0E3 		mov	r0, #4
 7114              	.LVL851:
 7115 3e10 EC119FE5 		ldr	r1, .L633+156
 7116 3e14 0520A0E1 		mov	r2, r5
 7117 3e18 FEFFFFEB 		bl	CyU3PDebugPrint
 7118              	.LVL852:
3158:../uvc.c      ****     }
 7119              		.loc 1 3158 0
 7120 3e1c 0500A0E1 		mov	r0, r5
 7121 3e20 FEFFFFEB 		bl	CyFxAppErrorHandler
 7122              	.LVL853:
 7123              	.L605:
3135:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7124              		.loc 1 3135 0
 7125 3e24 0400A0E3 		mov	r0, #4
 7126              	.LVL854:
 7127 3e28 D8119FE5 		ldr	r1, .L633+160
 7128 3e2c 0520A0E1 		mov	r2, r5
 7129 3e30 FEFFFFEB 		bl	CyU3PDebugPrint
 7130              	.LVL855:
3136:../uvc.c      ****     }
 7131              		.loc 1 3136 0
 7132 3e34 0500A0E1 		mov	r0, r5
 7133 3e38 FEFFFFEB 		bl	CyFxAppErrorHandler
 7134              	.LVL856:
 7135              	.L604:
 7136              	.LBE108:
 7137              	.LBE119:
 7138              	.LBB120:
 7139              	.LBB103:
3061:../uvc.c      ****         CyFxAppErrorHandler (status);
 7140              		.loc 1 3061 0
 7141 3e3c 0400A0E3 		mov	r0, #4
 7142              	.LVL857:
 7143 3e40 C4119FE5 		ldr	r1, .L633+164
 7144 3e44 FEFFFFEB 		bl	CyU3PDebugPrint
 7145              	.LVL858:
3062:../uvc.c      ****     }
 7146              		.loc 1 3062 0
 7147 3e48 0500A0E1 		mov	r0, r5
 7148 3e4c FEFFFFEB 		bl	CyFxAppErrorHandler
 7149              	.LVL859:
 7150              	.L603:
3048:../uvc.c      ****         CyFxAppErrorHandler (status);
 7151              		.loc 1 3048 0
 7152 3e50 0400A0E3 		mov	r0, #4
 7153              	.LVL860:
 7154 3e54 B4119FE5 		ldr	r1, .L633+168
 7155 3e58 FEFFFFEB 		bl	CyU3PDebugPrint
 7156              	.LVL861:
3049:../uvc.c      ****     }
 7157              		.loc 1 3049 0
 7158 3e5c 0500A0E1 		mov	r0, r5
 7159 3e60 FEFFFFEB 		bl	CyFxAppErrorHandler
 7160              	.LVL862:
 7161              	.L614:
 7162              	.LBE103:
 7163              	.LBE120:
 7164              	.LBB121:
 7165              	.LBB109:
3253:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7166              		.loc 1 3253 0
 7167 3e64 0400A0E3 		mov	r0, #4
 7168              	.LVL863:
 7169 3e68 A4119FE5 		ldr	r1, .L633+172
 7170 3e6c 0420A0E1 		mov	r2, r4
 7171 3e70 FEFFFFEB 		bl	CyU3PDebugPrint
 7172              	.LVL864:
3254:../uvc.c      ****     }
 7173              		.loc 1 3254 0
 7174 3e74 0400A0E1 		mov	r0, r4
 7175 3e78 FEFFFFEB 		bl	CyFxAppErrorHandler
 7176              	.LVL865:
 7177              	.L613:
3232:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7178              		.loc 1 3232 0
 7179 3e7c 0400A0E3 		mov	r0, #4
 7180              	.LVL866:
 7181 3e80 90119FE5 		ldr	r1, .L633+176
 7182 3e84 0420A0E1 		mov	r2, r4
 7183 3e88 FEFFFFEB 		bl	CyU3PDebugPrint
 7184              	.LVL867:
3233:../uvc.c      ****     }
 7185              		.loc 1 3233 0
 7186 3e8c 0400A0E1 		mov	r0, r4
 7187 3e90 FEFFFFEB 		bl	CyFxAppErrorHandler
 7188              	.LVL868:
 7189              	.L612:
3219:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7190              		.loc 1 3219 0
 7191 3e94 0400A0E3 		mov	r0, #4
 7192              	.LVL869:
 7193 3e98 7C119FE5 		ldr	r1, .L633+180
 7194 3e9c 0420A0E1 		mov	r2, r4
 7195 3ea0 FEFFFFEB 		bl	CyU3PDebugPrint
 7196              	.LVL870:
3220:../uvc.c      ****     }
 7197              		.loc 1 3220 0
 7198 3ea4 0400A0E1 		mov	r0, r4
 7199 3ea8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7200              	.LVL871:
 7201              	.L611:
3205:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7202              		.loc 1 3205 0
 7203 3eac 0400A0E3 		mov	r0, #4
 7204              	.LVL872:
 7205 3eb0 68119FE5 		ldr	r1, .L633+184
 7206 3eb4 0420A0E1 		mov	r2, r4
 7207 3eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 7208              	.LVL873:
3206:../uvc.c      ****     }
 7209              		.loc 1 3206 0
 7210 3ebc 0400A0E1 		mov	r0, r4
 7211 3ec0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7212              	.LVL874:
 7213              	.L610:
3191:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7214              		.loc 1 3191 0
 7215 3ec4 0400A0E3 		mov	r0, #4
 7216              	.LVL875:
 7217 3ec8 54119FE5 		ldr	r1, .L633+188
 7218 3ecc 0620A0E1 		mov	r2, r6
 7219 3ed0 FEFFFFEB 		bl	CyU3PDebugPrint
 7220              	.LVL876:
3192:../uvc.c      ****     }
 7221              		.loc 1 3192 0
 7222 3ed4 0600A0E1 		mov	r0, r6
 7223 3ed8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7224              	.LVL877:
 7225              	.L609:
3178:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7226              		.loc 1 3178 0
 7227 3edc 0400A0E3 		mov	r0, #4
 7228              	.LVL878:
 7229 3ee0 40119FE5 		ldr	r1, .L633+192
 7230 3ee4 0520A0E1 		mov	r2, r5
 7231 3ee8 FEFFFFEB 		bl	CyU3PDebugPrint
 7232              	.LVL879:
3179:../uvc.c      ****     }
 7233              		.loc 1 3179 0
 7234 3eec 0500A0E1 		mov	r0, r5
 7235 3ef0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7236              	.LVL880:
 7237              	.L608:
3172:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7238              		.loc 1 3172 0
 7239 3ef4 0400A0E3 		mov	r0, #4
 7240              	.LVL881:
 7241 3ef8 2C119FE5 		ldr	r1, .L633+196
 7242 3efc 0520A0E1 		mov	r2, r5
 7243 3f00 FEFFFFEB 		bl	CyU3PDebugPrint
 7244              	.LVL882:
3173:../uvc.c      ****     }
 7245              		.loc 1 3173 0
 7246 3f04 0500A0E1 		mov	r0, r5
 7247 3f08 FEFFFFEB 		bl	CyFxAppErrorHandler
 7248              	.LVL883:
 7249              	.L607:
3166:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7250              		.loc 1 3166 0
 7251 3f0c 0400A0E3 		mov	r0, #4
 7252              	.LVL884:
 7253 3f10 18119FE5 		ldr	r1, .L633+200
 7254 3f14 0520A0E1 		mov	r2, r5
 7255 3f18 FEFFFFEB 		bl	CyU3PDebugPrint
 7256              	.LVL885:
3167:../uvc.c      ****     }
 7257              		.loc 1 3167 0
 7258 3f1c 0500A0E1 		mov	r0, r5
 7259 3f20 FEFFFFEB 		bl	CyFxAppErrorHandler
 7260              	.LVL886:
 7261              	.L617:
3350:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7262              		.loc 1 3350 0
 7263 3f24 0800A0E1 		mov	r0, r8
 7264              	.LVL887:
 7265 3f28 04119FE5 		ldr	r1, .L633+204
 7266 3f2c 0420A0E1 		mov	r2, r4
 7267 3f30 FEFFFFEB 		bl	CyU3PDebugPrint
 7268              	.LVL888:
3351:../uvc.c      ****     }
 7269              		.loc 1 3351 0
 7270 3f34 0400A0E1 		mov	r0, r4
 7271 3f38 FEFFFFEB 		bl	CyFxAppErrorHandler
 7272              	.LVL889:
 7273              	.L615:
3319:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7274              		.loc 1 3319 0
 7275 3f3c 0400A0E3 		mov	r0, #4
 7276              	.LVL890:
 7277 3f40 F0109FE5 		ldr	r1, .L633+208
 7278 3f44 0420A0E1 		mov	r2, r4
 7279 3f48 FEFFFFEB 		bl	CyU3PDebugPrint
 7280              	.LVL891:
3320:../uvc.c      ****     }
 7281              		.loc 1 3320 0
 7282 3f4c 0400A0E1 		mov	r0, r4
 7283 3f50 FEFFFFEB 		bl	CyFxAppErrorHandler
 7284              	.LVL892:
 7285              	.L616:
3326:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7286              		.loc 1 3326 0
 7287 3f54 0400A0E3 		mov	r0, #4
 7288 3f58 DC109FE5 		ldr	r1, .L633+212
 7289 3f5c FEFFFFEB 		bl	CyU3PDebugPrint
 7290              	.LVL893:
3327:../uvc.c      ****     }
 7291              		.loc 1 3327 0
 7292 3f60 0800A0E1 		mov	r0, r8
 7293 3f64 FEFFFFEB 		bl	CyFxAppErrorHandler
 7294              	.LVL894:
 7295              	.L634:
 7296              		.align	2
 7297              	.L633:
 7298 3f68 00C20100 		.word	115200
 7299 3f6c A0860100 		.word	100000
 7300 3f70 00000000 		.word	.LANCHOR0
 7301 3f74 00000000 		.word	CyFxGpifCB
 7302 3f78 88130000 		.word	5000
 7303 3f7c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7304 3f80 00000000 		.word	CyFxUVCApplnUSBEventCB
 7305 3f84 00000000 		.word	CyFxUSBDeviceDscr
 7306 3f88 00000000 		.word	CyFxUSBDeviceDscrSS
 7307 3f8c 00000000 		.word	CyFxUSBDeviceQualDscr
 7308 3f90 00000000 		.word	CyFxUSBBOSDscr
 7309 3f94 00000000 		.word	CyFxUSBHSConfigDscr
 7310 3f98 00000000 		.word	CyFxUSBFSConfigDscr
 7311 3f9c 00000000 		.word	CyFxUSBSSConfigDscr
 7312 3fa0 00000000 		.word	CyFxUSBStringLangIDDscr
 7313 3fa4 00000000 		.word	CyFxUSBManufactureDscr
 7314 3fa8 00000000 		.word	CyFxUSBProductDscr
 7315 3fac 013F0203 		.word	50478849
 7316 3fb0 00000000 		.word	glChHandleInterStat
 7317 3fb4 00000000 		.word	glInterStaBuffer
 7318 3fb8 00000000 		.word	imgHdMux
 7319 3fbc 01010000 		.word	257
 7320 3fc0 03030000 		.word	771
 7321 3fc4 00000000 		.word	CyFxUvcApplnDmaCallback
 7322 3fc8 00000000 		.word	glChHandleUVCStream
 7323 3fcc 00000000 		.word	.LANCHOR1
 7324 3fd0 880B0000 		.word	.LC65
 7325 3fd4 60010000 		.word	.LANCHOR2+352
 7326 3fd8 E00B0000 		.word	.LC68
 7327 3fdc 980B0000 		.word	.LC66
 7328 3fe0 7C010000 		.word	.LANCHOR2+380
 7329 3fe4 D00A0000 		.word	.LC61
 7330 3fe8 200B0000 		.word	.LC63
 7331 3fec 540B0000 		.word	.LC64
 7332 3ff0 F40A0000 		.word	.LC62
 7333 3ff4 A4070000 		.word	.LC43
 7334 3ff8 CC090000 		.word	.LC56
 7335 3ffc A80A0000 		.word	.LC60
 7336 4000 A80B0000 		.word	.LC67
 7337 4004 28080000 		.word	.LC47
 7338 4008 FC070000 		.word	.LC46
 7339 400c E0070000 		.word	.LC45
 7340 4010 C4070000 		.word	.LC44
 7341 4014 9C090000 		.word	.LC55
 7342 4018 6C090000 		.word	.LC54
 7343 401c 34090000 		.word	.LC53
 7344 4020 00090000 		.word	.LC52
 7345 4024 CC080000 		.word	.LC51
 7346 4028 A0080000 		.word	.LC50
 7347 402c 74080000 		.word	.LC49
 7348 4030 4C080000 		.word	.LC48
 7349 4034 780A0000 		.word	.LC59
 7350 4038 000A0000 		.word	.LC57
 7351 403c 400A0000 		.word	.LC58
 7352              	.LBE109:
 7353              	.LBE121:
 7354              		.cfi_endproc
 7355              	.LFE19:
 7357              		.align	2
 7358              		.global	UVCAppEP0Thread_Entry
 7360              	UVCAppEP0Thread_Entry:
 7361              	.LFB25:
4648:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7362              		.loc 1 4648 0
 7363              		.cfi_startproc
 7364              		@ args = 0, pretend = 0, frame = 64
 7365              		@ frame_needed = 0, uses_anonymous_args = 0
 7366              	.LVL895:
 7367 4040 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7368              	.LCFI27:
 7369              		.cfi_def_cfa_offset 36
 7370              		.cfi_offset 4, -36
 7371              		.cfi_offset 5, -32
 7372              		.cfi_offset 6, -28
 7373              		.cfi_offset 7, -24
 7374              		.cfi_offset 8, -20
 7375              		.cfi_offset 9, -16
 7376              		.cfi_offset 10, -12
 7377              		.cfi_offset 11, -8
 7378              		.cfi_offset 14, -4
 7379 4044 D47F9FE5 		ldr	r7, .L1018
 7380 4048 D4AF9FE5 		ldr	r10, .L1018+4
 7381 404c D46F9FE5 		ldr	r6, .L1018+8
4722:../uvc.c      ****                 {
 7382              		.loc 1 4722 0
 7383 4050 D49F9FE5 		ldr	r9, .L1018+12
 7384              	.LBB154:
 7385              	.LBB155:
4155:../uvc.c      ****     {
 7386              		.loc 1 4155 0
 7387 4054 D48F9FE5 		ldr	r8, .L1018+16
 7388              	.LBE155:
 7389              	.LBE154:
4648:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7390              		.loc 1 4648 0
 7391 4058 5CD04DE2 		sub	sp, sp, #92
 7392              	.LCFI28:
 7393              		.cfi_def_cfa_offset 128
 7394              	.LVL896:
4670:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7395              		.loc 1 4670 0
 7396 405c 07B0A0E1 		mov	fp, r7
 7397              	.LVL897:
 7398              	.L911:
 7399 4060 0030E0E3 		mvn	r3, #0
 7400 4064 00308DE5 		str	r3, [sp]
 7401 4068 B00F9FE5 		ldr	r0, .L1018
 7402 406c 4C10A0E3 		mov	r1, #76
 7403 4070 0120A0E3 		mov	r2, #1
 7404 4074 44308DE2 		add	r3, sp, #68
 7405 4078 FEFFFFEB 		bl	_txe_event_flags_get
 7406              	.LVL898:
 7407 407c 000050E3 		cmp	r0, #0
 7408 4080 3B00001A 		bne	.L637
4674:../uvc.c      ****             {
 7409              		.loc 1 4674 0
 7410 4084 8C309BE5 		ldr	r3, [fp, #140]
 7411 4088 000053E3 		cmp	r3, #0
 7412 408c 9600000A 		beq	.L971
 7413              	.L639:
4683:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7414              		.loc 1 4683 0
 7415 4090 44309DE5 		ldr	r3, [sp, #68]
 7416 4094 0C0013E3 		tst	r3, #12
 7417 4098 7E00001A 		bne	.L972
 7418              	.L641:
4690:../uvc.c      ****             {
 7419              		.loc 1 4690 0
 7420 409c 040013E3 		tst	r3, #4
 7421 40a0 1F00000A 		beq	.L642
4692:../uvc.c      ****                 {
 7422              		.loc 1 4692 0
 7423 40a4 B020D9E1 		ldrh	r2, [r9]
 7424 40a8 2224A0E1 		mov	r2, r2, lsr #8
 7425 40ac 030052E3 		cmp	r2, #3
 7426 40b0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7427 40b4 150000EA 		b	.L643
 7428              	.L645:
 7429 40b8 10410000 		.word	.L643
 7430 40bc C8400000 		.word	.L646
 7431 40c0 7C410000 		.word	.L647
 7432 40c4 44420000 		.word	.L648
 7433              	.L646:
 7434              	.LBB236:
 7435              	.LBB237:
3930:../uvc.c      ****     {
 7436              		.loc 1 3930 0
 7437 40c8 B020D8E1 		ldrh	r2, [r8]
 7438 40cc 060C52E3 		cmp	r2, #1536
 7439 40d0 AC01000A 		beq	.L683
 7440 40d4 EC00009A 		bls	.L973
 7441 40d8 090C52E3 		cmp	r2, #2304
 7442 40dc 4E02000A 		beq	.L691
 7443 40e0 2201009A 		bls	.L974
 7444 40e4 0B0C52E3 		cmp	r2, #2816
 7445 40e8 B801000A 		beq	.L694
 7446 40ec 030B52E3 		cmp	r2, #3072
 7447 40f0 4102000A 		beq	.L695
 7448 40f4 0A0C52E3 		cmp	r2, #2560
 7449 40f8 2302000A 		beq	.L975
 7450              	.L682:
3987:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7451              		.loc 1 3987 0
 7452 40fc 683F9FE5 		ldr	r3, .L1018+76
 7453 4100 0400A0E3 		mov	r0, #4
 7454 4104 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7455 4108 241F9FE5 		ldr	r1, .L1018+20
 7456 410c FEFFFFEB 		bl	CyU3PDebugPrint
 7457              	.LVL899:
 7458              	.L643:
 7459              	.LBE237:
 7460              	.LBE236:
4713:../uvc.c      ****                         break;
 7461              		.loc 1 4713 0
 7462 4110 0000A0E3 		mov	r0, #0
 7463 4114 0020A0E1 		mov	r2, r0
 7464 4118 0110A0E3 		mov	r1, #1
 7465 411c FEFFFFEB 		bl	CyU3PUsbStall
 7466              	.LVL900:
 7467 4120 44309DE5 		ldr	r3, [sp, #68]
 7468              	.L642:
4718:../uvc.c      ****             {
 7469              		.loc 1 4718 0
 7470 4124 080013E3 		tst	r3, #8
 7471 4128 0700000A 		beq	.L905
4722:../uvc.c      ****                 {
 7472              		.loc 1 4722 0
 7473 412c B030D9E1 		ldrh	r3, [r9]
 7474 4130 010053E3 		cmp	r3, #1
 7475 4134 7200000A 		beq	.L906
4724:../uvc.c      ****                 }
 7476              		.loc 1 4724 0
 7477 4138 0000A0E3 		mov	r0, #0
 7478 413c 0020A0E1 		mov	r2, r0
 7479 4140 0110A0E3 		mov	r1, #1
 7480 4144 FEFFFFEB 		bl	CyU3PUsbStall
 7481              	.LVL901:
 7482 4148 44309DE5 		ldr	r3, [sp, #68]
 7483              	.L905:
4733:../uvc.c      ****             {
 7484              		.loc 1 4733 0
 7485 414c 400013E3 		tst	r3, #64
 7486 4150 0700000A 		beq	.L637
4738:../uvc.c      **** 
 7487              		.loc 1 4738 0
 7488 4154 1800A0E3 		mov	r0, #24
 7489 4158 48108DE2 		add	r1, sp, #72
 7490              	.LVL902:
 7491 415c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7492              	.LVL903:
4795:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7493              		.loc 1 4795 0
 7494 4160 6A37DAE5 		ldrb	r3, [r10, #1898]	@ zero_extendqisi2
 7495 4164 0F0053E3 		cmp	r3, #15
 7496 4168 8800000A 		beq	.L976
4822:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7497              		.loc 1 4822 0
 7498 416c 000053E3 		cmp	r3, #0
 7499 4170 6600000A 		beq	.L977
 7500              	.L637:
4946:../uvc.c      ****     }
 7501              		.loc 1 4946 0
 7502 4174 FEFFFFEB 		bl	_txe_thread_relinquish
 7503              	.LVL904:
4947:../uvc.c      **** }
 7504              		.loc 1 4947 0
 7505 4178 B8FFFFEA 		b	.L911
 7506              	.L647:
 7507              	.LBB373:
 7508              	.LBB374:
3855:../uvc.c      ****     {
 7509              		.loc 1 3855 0
 7510 417c B020D8E1 		ldrh	r2, [r8]
 7511 4180 060C52E3 		cmp	r2, #1536
 7512 4184 3201000A 		beq	.L650
 7513 4188 B200008A 		bhi	.L651
 7514 418c 030C52E3 		cmp	r2, #768
 7515 4190 2701000A 		beq	.L652
 7516 4194 E500008A 		bhi	.L653
 7517 4198 010C52E3 		cmp	r2, #256
 7518 419c 2001000A 		beq	.L654
 7519 41a0 020C52E3 		cmp	r2, #512
 7520 41a4 D4FFFF1A 		bne	.L682
 7521              	.LVL905:
 7522              	.LBB375:
 7523              	.LBB376:
1359:../uvc.c      ****     /*
 7524              		.loc 1 1359 0
 7525 41a8 BC3E9FE5 		ldr	r3, .L1018+76
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7526              		.loc 1 1348 0
 7527 41ac 2005DAE5 		ldrb	r0, [r10, #1312]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 7528              		.loc 1 1359 0
 7529 41b0 0040D3E5 		ldrb	r4, [r3]	@ zero_extendqisi2
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7530              		.loc 1 1349 0
 7531 41b4 2115DAE5 		ldrb	r1, [r10, #1313]	@ zero_extendqisi2
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7532              		.loc 1 1350 0
 7533 41b8 2F25DAE5 		ldrb	r2, [r10, #1327]	@ zero_extendqisi2
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7534              		.loc 1 1351 0
 7535 41bc 2235DAE5 		ldrb	r3, [r10, #1314]	@ zero_extendqisi2
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7536              		.loc 1 1348 0
 7537 41c0 FF0000E2 		and	r0, r0, #255
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7538              		.loc 1 1349 0
 7539 41c4 FF1001E2 		and	r1, r1, #255
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7540              		.loc 1 1350 0
 7541 41c8 FF2002E2 		and	r2, r2, #255
1367:../uvc.c      **** 		 {
 7542              		.loc 1 1367 0
 7543 41cc 830054E3 		cmp	r4, #131
1348:../uvc.c      **** 		RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2;//CtrlParArry[CtrlID][1];
 7544              		.loc 1 1348 0
 7545 41d0 28008DE5 		str	r0, [sp, #40]
 7546              	.LVL906:
1349:../uvc.c      **** 		devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;//CtrlParArry[CtrlID][15];
 7547              		.loc 1 1349 0
 7548 41d4 2C108DE5 		str	r1, [sp, #44]
 7549              	.LVL907:
1350:../uvc.c      **** 		Len = pPUCSenCtrl[CtrlID]->UVCLn;//CtrlParArry[CtrlID][2];
 7550              		.loc 1 1350 0
 7551 41d8 24208DE5 		str	r2, [sp, #36]
 7552              	.LVL908:
1351:../uvc.c      ****     	//CyU3PDebugPrint (4, "The PU control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x
 7553              		.loc 1 1351 0
 7554 41dc FF3003E2 		and	r3, r3, #255
 7555              	.LVL909:
1367:../uvc.c      **** 		 {
 7556              		.loc 1 1367 0
 7557 41e0 8805000A 		beq	.L664
 7558 41e4 9A02009A 		bls	.L978
 7559 41e8 850054E3 		cmp	r4, #133
 7560 41ec 7A05000A 		beq	.L669
 7561 41f0 6F05003A 		bcc	.L670
 7562 41f4 860054E3 		cmp	r4, #134
 7563 41f8 1204000A 		beq	.L671
 7564 41fc 870054E3 		cmp	r4, #135
 7565 4200 4505001A 		bne	.L663
1769:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7566              		.loc 1 1769 0
 7567 4204 020053E3 		cmp	r3, #2
1770:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 7568              		.loc 1 1770 0
 7569 4208 2BC5DAE5 		ldrb	ip, [r10, #1323]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 if(Len == 2){
 7570              		.loc 1 1781 0
 7571 420c 0300A0E1 		mov	r0, r3
1771:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer
 7572              		.loc 1 1771 0
 7573 4210 2C25DAE5 		ldrb	r2, [r10, #1324]	@ zero_extendqisi2
1769:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 7574              		.loc 1 1769 0
 7575 4214 1E04000A 		beq	.L947
 7576              	.L948:
1704:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 7577              		.loc 1 1704 0
 7578 4218 0030A0E3 		mov	r3, #0
 7579              	.LVL910:
1714:../uvc.c      **** 				  }
 7580              		.loc 1 1714 0
 7581 421c 0350A0E1 		mov	r5, r3
1708:../uvc.c      **** 				  if(Len == 2){
 7582              		.loc 1 1708 0
 7583 4220 681E9FE5 		ldr	r1, .L1018+112
1701:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 7584              		.loc 1 1701 0
 7585 4224 28C0C7E5 		strb	ip, [r7, #40]
1703:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 7586              		.loc 1 1703 0
 7587 4228 2920C7E5 		strb	r2, [r7, #41]
1704:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 7588              		.loc 1 1704 0
 7589 422c 2B30C7E5 		strb	r3, [r7, #43]
1708:../uvc.c      **** 				  if(Len == 2){
 7590              		.loc 1 1708 0
 7591 4230 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7592              	.LVL911:
1714:../uvc.c      **** 				  }
 7593              		.loc 1 1714 0
 7594 4234 05C0A0E1 		mov	ip, r5
1713:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 7595              		.loc 1 1713 0
 7596 4238 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 7597              	.LVL912:
1714:../uvc.c      **** 				  }
 7598              		.loc 1 1714 0
 7599 423c 2A30D7E5 		ldrb	r3, [r7, #42]	@ zero_extendqisi2
 7600              	.LVL913:
 7601 4240 B40200EA 		b	.L673
 7602              	.LVL914:
 7603              	.L648:
 7604              	.LBE376:
 7605              	.LBE375:
 7606              	.LBE374:
 7607              	.LBE373:
 7608              	.LBB392:
 7609              	.LBB226:
4155:../uvc.c      ****     {
 7610              		.loc 1 4155 0
 7611 4244 B030D8E1 		ldrh	r3, [r8]
 7612 4248 E04D9FE5 		ldr	r4, .L1018+16
 7613 424c 0D0C53E3 		cmp	r3, #3328
 7614 4250 B203000A 		beq	.L791
 7615 4254 6F00008A 		bhi	.L792
 7616 4258 060C53E3 		cmp	r3, #1536
 7617 425c AB03000A 		beq	.L793
 7618 4260 A700009A 		bls	.L979
 7619 4264 090C53E3 		cmp	r3, #2304
 7620 4268 A403000A 		beq	.L801
 7621 426c 3501009A 		bls	.L980
 7622 4270 0B0C53E3 		cmp	r3, #2816
 7623 4274 9D03000A 		beq	.L805
 7624 4278 030B53E3 		cmp	r3, #3072
 7625 427c 2502000A 		beq	.L806
 7626 4280 0A0C53E3 		cmp	r3, #2560
 7627 4284 A1FFFF1A 		bne	.L643
 7628              	.LVL915:
4196:../uvc.c      ****     		}else/* no support for 1080p camera */
 7629              		.loc 1 4196 0
 7630 4288 1900A0E3 		mov	r0, #25
 7631 428c FEFFFFEB 		bl	ControlHandle
 7632              	.LVL916:
 7633 4290 44309DE5 		ldr	r3, [sp, #68]
 7634 4294 A2FFFFEA 		b	.L642
 7635              	.L972:
 7636              	.LBE226:
 7637              	.LBE392:
4684:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7638              		.loc 1 4684 0
 7639 4298 980D9FE5 		ldr	r0, .L1018+24
 7640 429c C81D9FE5 		ldr	r1, .L1018+76
 7641 42a0 942D9FE5 		ldr	r2, .L1018+28
 7642 42a4 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7643 42a8 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7644 42ac B010D2E1 		ldrh	r1, [r2]
 7645 42b0 B0C0D8E1 		ldrh	ip, [r8]
 7646 42b4 00008DE5 		str	r0, [sp]
 7647 42b8 B000D9E1 		ldrh	r0, [r9]
 7648 42bc 10108DE5 		str	r1, [sp, #16]
 7649 42c0 0010A0E3 		mov	r1, #0
 7650 42c4 0C008DE5 		str	r0, [sp, #12]
 7651 42c8 14108DE5 		str	r1, [sp, #20]
 7652 42cc 4820D7E5 		ldrb	r2, [r7, #72]	@ zero_extendqisi2
 7653 42d0 04E08DE5 		str	lr, [sp, #4]
 7654 42d4 08C08DE5 		str	ip, [sp, #8]
 7655 42d8 0400A0E3 		mov	r0, #4
 7656 42dc 5C1D9FE5 		ldr	r1, .L1018+32
 7657 42e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7658              	.LVL917:
 7659 42e4 44309DE5 		ldr	r3, [sp, #68]
 7660 42e8 6BFFFFEA 		b	.L641
 7661              	.L971:
4676:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7662              		.loc 1 4676 0
 7663 42ec FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7664              	.LVL918:
4677:../uvc.c      ****                 {
 7665              		.loc 1 4677 0
 7666 42f0 000050E3 		cmp	r0, #0
4679:../uvc.c      ****                 }
 7667              		.loc 1 4679 0
 7668 42f4 0130A013 		movne	r3, #1
4676:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7669              		.loc 1 4676 0
 7670 42f8 4800CBE5 		strb	r0, [fp, #72]
4679:../uvc.c      ****                 }
 7671              		.loc 1 4679 0
 7672 42fc 8C308B15 		strne	r3, [fp, #140]
 7673 4300 62FFFFEA 		b	.L639
 7674              	.L906:
4728:../uvc.c      ****                 }
 7675              		.loc 1 4728 0
 7676 4304 4CEFFFEB 		bl	UVCHandleVideoStreamingRqts
 7677              	.LVL919:
 7678 4308 44309DE5 		ldr	r3, [sp, #68]
 7679 430c 8EFFFFEA 		b	.L905
 7680              	.L977:
4824:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7681              		.loc 1 4824 0
 7682 4310 002096E5 		ldr	r2, [r6]
 7683 4314 0210A0E3 		mov	r1, #2
 7684 4318 0010C2E5 		strb	r1, [r2]
4825:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7685              		.loc 1 4825 0
 7686 431c 002096E5 		ldr	r2, [r6]
 7687 4320 0140A0E3 		mov	r4, #1
 7688 4324 0140C2E5 		strb	r4, [r2, #1]
4826:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7689              		.loc 1 4826 0
 7690 4328 001096E5 		ldr	r1, [r6]
4830:../uvc.c      **** 					interStabuf.status = 0;
 7691              		.loc 1 4830 0
 7692 432c 012BA0E3 		mov	r2, #1024
4826:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7693              		.loc 1 4826 0
 7694 4330 0230C1E5 		strb	r3, [r1, #2]
4827:../uvc.c      **** 
 7695              		.loc 1 4827 0
 7696 4334 001096E5 		ldr	r1, [r6]
4833:../uvc.c      **** 
 7697              		.loc 1 4833 0
 7698 4338 0450A0E3 		mov	r5, #4
4827:../uvc.c      **** 
 7699              		.loc 1 4827 0
 7700 433c 0340C1E5 		strb	r4, [r1, #3]
4829:../uvc.c      **** 					interStabuf.size   = 1024;
 7701              		.loc 1 4829 0
 7702 4340 001096E5 		ldr	r1, [r6]
4836:../uvc.c      **** 
 7703              		.loc 1 4836 0
 7704 4344 F80C9FE5 		ldr	r0, .L1018+36
4829:../uvc.c      **** 					interStabuf.size   = 1024;
 7705              		.loc 1 4829 0
 7706 4348 4C108DE5 		str	r1, [sp, #76]
4836:../uvc.c      **** 
 7707              		.loc 1 4836 0
 7708 434c 0010E0E3 		mvn	r1, #0
4831:../uvc.c      **** 
 7709              		.loc 1 4831 0
 7710 4350 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4830:../uvc.c      **** 					interStabuf.status = 0;
 7711              		.loc 1 4830 0
 7712 4354 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4833:../uvc.c      **** 
 7713              		.loc 1 4833 0
 7714 4358 B055CDE1 		strh	r5, [sp, #80]	@ movhi
4836:../uvc.c      **** 
 7715              		.loc 1 4836 0
 7716 435c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7717              	.LVL920:
4839:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7718              		.loc 1 4839 0
 7719 4360 DC0C9FE5 		ldr	r0, .L1018+36
 7720 4364 4C108DE2 		add	r1, sp, #76
 7721 4368 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7722              	.LVL921:
4841:../uvc.c      **** 					{
 7723              		.loc 1 4841 0
 7724 436c 000050E3 		cmp	r0, #0
 7725 4370 D501001A 		bne	.L981
4847:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 7726              		.loc 1 4847 0
 7727 4374 0500A0E3 		mov	r0, #5
 7728              	.LVL922:
 7729 4378 3010A0E3 		mov	r1, #48
 7730 437c 0420A0E1 		mov	r2, r4
 7731 4380 FEFFFFEB 		bl	SensorSetControl
 7732              	.LVL923:
4848:../uvc.c      **** 				}
 7733              		.loc 1 4848 0
 7734 4384 98EC9FE5 		ldr	lr, .L1018+4
 7735 4388 6A47CEE5 		strb	r4, [lr, #1898]
 7736 438c 78FFFFEA 		b	.L637
 7737              	.L976:
4797:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7738              		.loc 1 4797 0
 7739 4390 003096E5 		ldr	r3, [r6]
 7740 4394 0220A0E3 		mov	r2, #2
 7741 4398 0020C3E5 		strb	r2, [r3]
4798:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7742              		.loc 1 4798 0
 7743 439c 003096E5 		ldr	r3, [r6]
 7744 43a0 0140A0E3 		mov	r4, #1
 7745 43a4 0140C3E5 		strb	r4, [r3, #1]
4799:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7746              		.loc 1 4799 0
 7747 43a8 002096E5 		ldr	r2, [r6]
 7748 43ac 0030A0E3 		mov	r3, #0
 7749 43b0 0230C2E5 		strb	r3, [r2, #2]
4800:../uvc.c      **** 
 7750              		.loc 1 4800 0
 7751 43b4 001096E5 		ldr	r1, [r6]
4806:../uvc.c      **** 
 7752              		.loc 1 4806 0
 7753 43b8 04C0A0E3 		mov	ip, #4
4800:../uvc.c      **** 
 7754              		.loc 1 4800 0
 7755 43bc 0330C1E5 		strb	r3, [r1, #3]
4802:../uvc.c      **** 					interStabuf.size   = 1024;
 7756              		.loc 1 4802 0
 7757 43c0 001096E5 		ldr	r1, [r6]
4803:../uvc.c      **** 					interStabuf.status = 0;
 7758              		.loc 1 4803 0
 7759 43c4 012BA0E3 		mov	r2, #1024
4802:../uvc.c      **** 					interStabuf.size   = 1024;
 7760              		.loc 1 4802 0
 7761 43c8 4C108DE5 		str	r1, [sp, #76]
4809:../uvc.c      **** 
 7762              		.loc 1 4809 0
 7763 43cc 700C9FE5 		ldr	r0, .L1018+36
 7764 43d0 0010E0E3 		mvn	r1, #0
4803:../uvc.c      **** 					interStabuf.status = 0;
 7765              		.loc 1 4803 0
 7766 43d4 B225CDE1 		strh	r2, [sp, #82]	@ movhi
4806:../uvc.c      **** 
 7767              		.loc 1 4806 0
 7768 43d8 B0C5CDE1 		strh	ip, [sp, #80]	@ movhi
4809:../uvc.c      **** 
 7769              		.loc 1 4809 0
 7770 43dc 1CC08DE5 		str	ip, [sp, #28]
4804:../uvc.c      **** 
 7771              		.loc 1 4804 0
 7772 43e0 B435CDE1 		strh	r3, [sp, #84]	@ movhi
4809:../uvc.c      **** 
 7773              		.loc 1 4809 0
 7774 43e4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7775              	.LVL924:
4812:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7776              		.loc 1 4812 0
 7777 43e8 540C9FE5 		ldr	r0, .L1018+36
 7778 43ec 4C108DE2 		add	r1, sp, #76
 7779 43f0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7780              	.LVL925:
4814:../uvc.c      **** 					{
 7781              		.loc 1 4814 0
 7782 43f4 1CC09DE5 		ldr	ip, [sp, #28]
 7783 43f8 002050E2 		subs	r2, r0, #0
 7784 43fc 8B03001A 		bne	.L982
4819:../uvc.c      **** 
 7785              		.loc 1 4819 0
 7786 4400 0500A0E3 		mov	r0, #5
 7787              	.LVL926:
 7788 4404 3010A0E3 		mov	r1, #48
 7789 4408 FEFFFFEB 		bl	SensorSetControl
 7790              	.LVL927:
4821:../uvc.c      **** 				}else if(!snapButFlag){
 7791              		.loc 1 4821 0
 7792 440c 10CC9FE5 		ldr	ip, .L1018+4
 7793 4410 6A47CCE5 		strb	r4, [ip, #1898]
 7794 4414 56FFFFEA 		b	.L637
 7795              	.L792:
 7796              	.LBB393:
 7797              	.LBB227:
4155:../uvc.c      ****     {
 7798              		.loc 1 4155 0
 7799 4418 150C53E3 		cmp	r3, #5376
 7800 441c 4303000A 		beq	.L808
 7801 4420 2400008A 		bhi	.L809
 7802 4424 110C53E3 		cmp	r3, #4352
 7803 4428 4E03000A 		beq	.L810
 7804 442c CD00009A 		bls	.L983
 7805 4430 130C53E3 		cmp	r3, #4864
 7806 4434 4703000A 		beq	.L814
 7807 4438 050B53E3 		cmp	r3, #5120
 7808 443c AB01000A 		beq	.L815
 7809 4440 120C53E3 		cmp	r3, #4608
 7810 4444 31FFFF1A 		bne	.L643
 7811              	.LVL928:
4232:../uvc.c      ****     		break;
 7812              		.loc 1 4232 0
 7813 4448 2500A0E3 		mov	r0, #37
 7814 444c FEFFFFEB 		bl	ControlHandle
 7815              	.LVL929:
 7816 4450 44309DE5 		ldr	r3, [sp, #68]
 7817 4454 32FFFFEA 		b	.L642
 7818              	.L651:
 7819              	.LBE227:
 7820              	.LBE393:
 7821              	.LBB394:
 7822              	.LBB385:
3855:../uvc.c      ****     {
 7823              		.loc 1 3855 0
 7824 4458 0A0C52E3 		cmp	r2, #2560
 7825 445c 6800000A 		beq	.L657
 7826 4460 3A00009A 		bls	.L984
 7827 4464 0D0C52E3 		cmp	r2, #3328
 7828 4468 6500000A 		beq	.L657
 7829 446c 0E0C52E3 		cmp	r2, #3584
 7830 4470 6700000A 		beq	.L661
 7831 4474 030B52E3 		cmp	r2, #3072
 7832 4478 1FFFFF1A 		bne	.L682
 7833              	.LVL930:
3896:../uvc.c      ****     		break;
 7834              		.loc 1 3896 0
 7835 447c 0B00A0E3 		mov	r0, #11
 7836 4480 FEFFFFEB 		bl	ControlHandle
 7837              	.LVL931:
 7838 4484 44309DE5 		ldr	r3, [sp, #68]
 7839 4488 25FFFFEA 		b	.L642
 7840              	.L973:
 7841              	.LBE385:
 7842              	.LBE394:
 7843              	.LBB395:
 7844              	.LBB366:
3930:../uvc.c      ****     {
 7845              		.loc 1 3930 0
 7846 448c 030C52E3 		cmp	r2, #768
 7847 4490 0601000A 		beq	.L685
 7848 4494 3A00008A 		bhi	.L686
 7849 4498 010C52E3 		cmp	r2, #256
 7850 449c E700000A 		beq	.L687
 7851 44a0 020C52E3 		cmp	r2, #512
 7852 44a4 14FFFF1A 		bne	.L682
 7853              	.LVL932:
3938:../uvc.c      ****     		break;
 7854              		.loc 1 3938 0
 7855 44a8 0100A0E3 		mov	r0, #1
 7856 44ac FEFFFFEB 		bl	CTControlHandle
 7857              	.LVL933:
 7858 44b0 44309DE5 		ldr	r3, [sp, #68]
 7859 44b4 1AFFFFEA 		b	.L642
 7860              	.L809:
 7861              	.LBE366:
 7862              	.LBE395:
 7863              	.LBB396:
 7864              	.LBB228:
4155:../uvc.c      ****     {
 7865              		.loc 1 4155 0
 7866 44b8 060B53E3 		cmp	r3, #6144
 7867 44bc 3B03000A 		beq	.L817
 7868 44c0 6F00009A 		bls	.L985
 7869 44c4 1B0C53E3 		cmp	r3, #6912
 7870 44c8 2E03000A 		beq	.L821
 7871 44cc 070B53E3 		cmp	r3, #7168
 7872 44d0 D501000A 		beq	.L822
 7873 44d4 1A0C53E3 		cmp	r3, #6656
 7874 44d8 0CFFFF1A 		bne	.L643
4265:../uvc.c      **** 			CyU3PDebugPrint (4, "The 2DNR start/end command 0x%x 0x%x\r\n", wValue, bRequest);
 7875              		.loc 1 4265 0
 7876 44dc 2D00A0E3 		mov	r0, #45
 7877 44e0 FEFFFFEB 		bl	ControlHandle
 7878              	.LVL934:
4266:../uvc.c      ****     		break;
 7879              		.loc 1 4266 0
 7880 44e4 803B9FE5 		ldr	r3, .L1018+76
 7881 44e8 B020D4E1 		ldrh	r2, [r4]
 7882 44ec 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7883 44f0 0400A0E3 		mov	r0, #4
 7884 44f4 4C1B9FE5 		ldr	r1, .L1018+40
 7885 44f8 FEFFFFEB 		bl	CyU3PDebugPrint
 7886              	.LVL935:
 7887 44fc 44309DE5 		ldr	r3, [sp, #68]
 7888 4500 07FFFFEA 		b	.L642
 7889              	.L979:
4155:../uvc.c      ****     {
 7890              		.loc 1 4155 0
 7891 4504 030C53E3 		cmp	r3, #768
 7892 4508 1A03000A 		beq	.L795
 7893 450c 5400008A 		bhi	.L796
 7894 4510 010C53E3 		cmp	r3, #256
 7895 4514 C001000A 		beq	.L797
 7896 4518 020C53E3 		cmp	r3, #512
 7897 451c FBFEFF1A 		bne	.L643
 7898              	.LVL936:
4163:../uvc.c      ****     		break;
 7899              		.loc 1 4163 0
 7900 4520 1100A0E3 		mov	r0, #17
 7901 4524 FEFFFFEB 		bl	ControlHandle
 7902              	.LVL937:
 7903 4528 44309DE5 		ldr	r3, [sp, #68]
 7904 452c FCFEFFEA 		b	.L642
 7905              	.L653:
 7906              	.LBE228:
 7907              	.LBE396:
 7908              	.LBB397:
 7909              	.LBB386:
3855:../uvc.c      ****     {
 7910              		.loc 1 3855 0
 7911 4530 010B52E3 		cmp	r2, #1024
 7912 4534 FAFEFF0A 		beq	.L642
 7913 4538 050C52E3 		cmp	r2, #1280
 7914 453c EEFEFF1A 		bne	.L682
 7915              	.LVL938:
3874:../uvc.c      ****       		break;
 7916              		.loc 1 3874 0
 7917 4540 0400A0E3 		mov	r0, #4
 7918 4544 FEFFFFEB 		bl	ControlHandle
 7919              	.LVL939:
 7920 4548 44309DE5 		ldr	r3, [sp, #68]
 7921 454c F4FEFFEA 		b	.L642
 7922              	.L984:
3855:../uvc.c      ****     {
 7923              		.loc 1 3855 0
 7924 4550 070C52E3 		cmp	r2, #1792
 7925 4554 3A00000A 		beq	.L659
 7926 4558 020B52E3 		cmp	r2, #2048
 7927 455c E6FEFF1A 		bne	.L682
 7928              	.LVL940:
3886:../uvc.c      ****           		break;
 7929              		.loc 1 3886 0
 7930 4560 0700A0E3 		mov	r0, #7
 7931 4564 FEFFFFEB 		bl	ControlHandle
 7932              	.LVL941:
 7933 4568 44309DE5 		ldr	r3, [sp, #68]
 7934 456c ECFEFFEA 		b	.L642
 7935              	.L974:
 7936              	.LBE386:
 7937              	.LBE397:
 7938              	.LBB398:
 7939              	.LBB367:
3930:../uvc.c      ****     {
 7940              		.loc 1 3930 0
 7941 4570 070C52E3 		cmp	r2, #1792
 7942 4574 E800000A 		beq	.L693
 7943 4578 020B52E3 		cmp	r2, #2048
 7944 457c E8FEFF0A 		beq	.L642
 7945 4580 DDFEFFEA 		b	.L682
 7946              	.L686:
 7947 4584 010B52E3 		cmp	r2, #1024
 7948 4588 1F01000A 		beq	.L689
 7949 458c 050C52E3 		cmp	r2, #1280
 7950 4590 D9FEFF1A 		bne	.L682
 7951              	.LVL942:
 7952              	.LBB238:
 7953              	.LBB239:
2237:../uvc.c      **** 
 7954              		.loc 1 2237 0
 7955 4594 D04A9FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 7956              		.loc 1 2232 0
 7957 4598 1256DAE5 		ldrb	r5, [r10, #1554]	@ zero_extendqisi2
 7958              	.LVL943:
2237:../uvc.c      **** 
 7959              		.loc 1 2237 0
 7960 459c 24408DE5 		str	r4, [sp, #36]
 7961 45a0 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 7962              	.LVL944:
2239:../uvc.c      **** 		 {
 7963              		.loc 1 2239 0
 7964 45a4 830054E3 		cmp	r4, #131
 7965 45a8 9D04000A 		beq	.L720
 7966 45ac E201009A 		bls	.L986
 7967 45b0 850054E3 		cmp	r4, #133
 7968 45b4 B802000A 		beq	.L782
 7969 45b8 ED04003A 		bcc	.L726
 7970 45bc 860054E3 		cmp	r4, #134
 7971 45c0 6103000A 		beq	.L727
 7972 45c4 870054E3 		cmp	r4, #135
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 7973              		.loc 1 2301 0
 7974 45c8 1B16DA05 		ldreqb	r1, [r10, #1563]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 7975              		.loc 1 2302 0
 7976 45cc 1C26DA05 		ldreqb	r2, [r10, #1564]	@ zero_extendqisi2
2239:../uvc.c      **** 		 {
 7977              		.loc 1 2239 0
 7978 45d0 C700000A 		beq	.L957
 7979              	.L719:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 7980              		.loc 1 2446 0
 7981 45d4 0000A0E3 		mov	r0, #0
 7982 45d8 0020A0E1 		mov	r2, r0
 7983 45dc 0110A0E3 		mov	r1, #1
 7984 45e0 FEFFFFEB 		bl	CyU3PUsbStall
 7985              	.LVL945:
2447:../uvc.c      **** 			  break;
 7986              		.loc 1 2447 0
 7987 45e4 24C09DE5 		ldr	ip, [sp, #36]
 7988 45e8 0400A0E3 		mov	r0, #4
 7989 45ec 0020A0E1 		mov	r2, r0
 7990 45f0 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 7991 45f4 8C1A9FE5 		ldr	r1, .L1018+104
 7992 45f8 FEFFFFEB 		bl	CyU3PDebugPrint
 7993              	.LVL946:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7994              		.loc 1 2233 0
 7995 45fc FF20A0E3 		mov	r2, #255
 7996              	.LVL947:
 7997 4600 AC0200EA 		b	.L786
 7998              	.LVL948:
 7999              	.L657:
 8000              	.LBE239:
 8001              	.LBE238:
 8002              	.LBE367:
 8003              	.LBE398:
 8004              	.LBB399:
 8005              	.LBB387:
3892:../uvc.c      ****     		break;
 8006              		.loc 1 3892 0
 8007 4604 0900A0E3 		mov	r0, #9
 8008 4608 FEFFFFEB 		bl	ControlHandle
 8009              	.LVL949:
 8010 460c 44309DE5 		ldr	r3, [sp, #68]
 8011 4610 C3FEFFEA 		b	.L642
 8012              	.L661:
 8013              	.LVL950:
3900:../uvc.c      ****     		break;
 8014              		.loc 1 3900 0
 8015 4614 0E00A0E3 		mov	r0, #14
 8016 4618 FEFFFFEB 		bl	ControlHandle
 8017              	.LVL951:
 8018 461c 44309DE5 		ldr	r3, [sp, #68]
 8019 4620 BFFEFFEA 		b	.L642
 8020              	.L654:
 8021              	.LVL952:
3859:../uvc.c      ****     		break;
 8022              		.loc 1 3859 0
 8023 4624 0000A0E3 		mov	r0, #0
 8024 4628 FEFFFFEB 		bl	ControlHandle
 8025              	.LVL953:
 8026 462c 44309DE5 		ldr	r3, [sp, #68]
 8027 4630 BBFEFFEA 		b	.L642
 8028              	.L652:
 8029              	.LVL954:
3867:../uvc.c      **** 			break;
 8030              		.loc 1 3867 0
 8031 4634 0200A0E3 		mov	r0, #2
 8032 4638 FEFFFFEB 		bl	ControlHandle
 8033              	.LVL955:
 8034 463c 44309DE5 		ldr	r3, [sp, #68]
 8035 4640 B7FEFFEA 		b	.L642
 8036              	.L659:
 8037              	.LVL956:
3882:../uvc.c      ****           		break;
 8038              		.loc 1 3882 0
 8039 4644 0600A0E3 		mov	r0, #6
 8040 4648 FEFFFFEB 		bl	ControlHandle
 8041              	.LVL957:
 8042 464c 44309DE5 		ldr	r3, [sp, #68]
 8043 4650 B3FEFFEA 		b	.L642
 8044              	.L650:
 8045              	.LVL958:
3878:../uvc.c      ****      		break;
 8046              		.loc 1 3878 0
 8047 4654 0500A0E3 		mov	r0, #5
 8048 4658 FEFFFFEB 		bl	ControlHandle
 8049              	.LVL959:
 8050 465c 44309DE5 		ldr	r3, [sp, #68]
 8051 4660 AFFEFFEA 		b	.L642
 8052              	.L796:
 8053              	.LBE387:
 8054              	.LBE399:
 8055              	.LBB400:
 8056              	.LBB229:
4155:../uvc.c      ****     {
 8057              		.loc 1 4155 0
 8058 4664 010B53E3 		cmp	r3, #1024
 8059 4668 3801000A 		beq	.L799
 8060 466c 050C53E3 		cmp	r3, #1280
 8061 4670 A6FEFF1A 		bne	.L643
 8062              	.LVL960:
4175:../uvc.c      ****     		break;
 8063              		.loc 1 4175 0
 8064 4674 1400A0E3 		mov	r0, #20
 8065 4678 FEFFFFEB 		bl	ControlHandle
 8066              	.LVL961:
 8067 467c 44309DE5 		ldr	r3, [sp, #68]
 8068 4680 A7FEFFEA 		b	.L642
 8069              	.L985:
4155:../uvc.c      ****     {
 8070              		.loc 1 4155 0
 8071 4684 160C53E3 		cmp	r3, #5632
 8072 4688 2601000A 		beq	.L819
 8073 468c 170C53E3 		cmp	r3, #5888
 8074 4690 9EFEFF1A 		bne	.L643
 8075              	.LVL962:
 8076              	.LBB156:
 8077              	.LBB157:
1359:../uvc.c      ****     /*
 8078              		.loc 1 1359 0
 8079 4694 D0499FE5 		ldr	r4, .L1018+76
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8080              		.loc 1 1341 0
 8081 4698 4437DAE5 		ldrb	r3, [r10, #1860]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8082              		.loc 1 1359 0
 8083 469c 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 8084 46a0 24408DE5 		str	r4, [sp, #36]
 8085 46a4 2CC08DE5 		str	ip, [sp, #44]
1367:../uvc.c      **** 		 {
 8086              		.loc 1 1367 0
 8087 46a8 2CE09DE5 		ldr	lr, [sp, #44]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8088              		.loc 1 1342 0
 8089 46ac 4547DAE5 		ldrb	r4, [r10, #1861]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8090              		.loc 1 1343 0
 8091 46b0 5357DAE5 		ldrb	r5, [r10, #1875]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8092              		.loc 1 1344 0
 8093 46b4 46C7DAE5 		ldrb	ip, [r10, #1862]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8094              		.loc 1 1341 0
 8095 46b8 FF3003E2 		and	r3, r3, #255
1367:../uvc.c      **** 		 {
 8096              		.loc 1 1367 0
 8097 46bc 83005EE3 		cmp	lr, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8098              		.loc 1 1341 0
 8099 46c0 30308DE5 		str	r3, [sp, #48]
 8100              	.LVL963:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8101              		.loc 1 1342 0
 8102 46c4 FF4004E2 		and	r4, r4, #255
 8103              	.LVL964:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8104              		.loc 1 1343 0
 8105 46c8 FF5005E2 		and	r5, r5, #255
 8106              	.LVL965:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8107              		.loc 1 1344 0
 8108 46cc FFC00CE2 		and	ip, ip, #255
 8109              	.LVL966:
1367:../uvc.c      **** 		 {
 8110              		.loc 1 1367 0
 8111 46d0 7C03000A 		beq	.L852
 8112 46d4 E303009A 		bls	.L987
 8113 46d8 2C409DE5 		ldr	r4, [sp, #44]
 8114              	.LVL967:
 8115 46dc 850054E3 		cmp	r4, #133
 8116 46e0 5D03000A 		beq	.L857
 8117 46e4 3E05003A 		bcc	.L858
 8118 46e8 860054E3 		cmp	r4, #134
 8119 46ec 2E05000A 		beq	.L859
 8120 46f0 870054E3 		cmp	r4, #135
 8121 46f4 1705001A 		bne	.L851
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8122              		.loc 1 1756 0
 8123 46f8 02005CE3 		cmp	ip, #2
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8124              		.loc 1 1757 0
 8125 46fc 4F27DA05 		ldreqb	r2, [r10, #1871]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 if(Len == 2){
 8126              		.loc 1 1781 0
 8127 4700 0C00A001 		moveq	r0, ip
1758:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8128              		.loc 1 1758 0
 8129 4704 5037DA05 		ldreqb	r3, [r10, #1872]	@ zero_extendqisi2
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8130              		.loc 1 1756 0
 8131 4708 7503000A 		beq	.L962
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8132              		.loc 1 1762 0
 8133 470c 4FE7DAE5 		ldrb	lr, [r10, #1871]	@ zero_extendqisi2
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8134              		.loc 1 1764 0
 8135 4710 5027DAE5 		ldrb	r2, [r10, #1872]	@ zero_extendqisi2
 8136              	.L963:
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8137              		.loc 1 1763 0
 8138 4714 0030A0E3 		mov	r3, #0
1781:../uvc.c      **** 		 	 if(Len == 2){
 8139              		.loc 1 1781 0
 8140 4718 0C00A0E1 		mov	r0, ip
 8141 471c 6C199FE5 		ldr	r1, .L1018+112
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8142              		.loc 1 1762 0
 8143 4720 28E0C7E5 		strb	lr, [r7, #40]
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8144              		.loc 1 1764 0
 8145 4724 2A20C7E5 		strb	r2, [r7, #42]
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8146              		.loc 1 1763 0
 8147 4728 2930C7E5 		strb	r3, [r7, #41]
1765:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8148              		.loc 1 1765 0
 8149 472c 2B30C7E5 		strb	r3, [r7, #43]
1787:../uvc.c      **** 		 	 }
 8150              		.loc 1 1787 0
 8151 4730 28308DE5 		str	r3, [sp, #40]
1781:../uvc.c      **** 		 	 if(Len == 2){
 8152              		.loc 1 1781 0
 8153 4734 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8154              	.LVL968:
1787:../uvc.c      **** 		 	 }
 8155              		.loc 1 1787 0
 8156 4738 00C0A0E3 		mov	ip, #0
1786:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8157              		.loc 1 1786 0
 8158 473c 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 8159              	.LVL969:
1787:../uvc.c      **** 		 	 }
 8160              		.loc 1 1787 0
 8161 4740 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 8162              	.LVL970:
 8163 4744 4E0300EA 		b	.L861
 8164              	.LVL971:
 8165              	.L980:
 8166              	.LBE157:
 8167              	.LBE156:
4155:../uvc.c      ****     {
 8168              		.loc 1 4155 0
 8169 4748 070C53E3 		cmp	r3, #1792
 8170 474c 0701000A 		beq	.L803
 8171 4750 020B53E3 		cmp	r3, #2048
 8172 4754 6DFEFF1A 		bne	.L643
 8173              	.LVL972:
4187:../uvc.c      ****     		break;
 8174              		.loc 1 4187 0
 8175 4758 1700A0E3 		mov	r0, #23
 8176 475c FEFFFFEB 		bl	ControlHandle
 8177              	.LVL973:
 8178 4760 44309DE5 		ldr	r3, [sp, #68]
 8179 4764 6EFEFFEA 		b	.L642
 8180              	.L983:
4155:../uvc.c      ****     {
 8181              		.loc 1 4155 0
 8182 4768 0F0C53E3 		cmp	r3, #3840
 8183 476c FB00000A 		beq	.L812
 8184 4770 010A53E3 		cmp	r3, #4096
 8185 4774 65FEFF1A 		bne	.L643
 8186              	.LVL974:
4224:../uvc.c      ****     		break;
 8187              		.loc 1 4224 0
 8188 4778 1F00A0E3 		mov	r0, #31
 8189 477c FEFFFFEB 		bl	ControlHandle
 8190              	.LVL975:
 8191 4780 44309DE5 		ldr	r3, [sp, #68]
 8192 4784 66FEFFEA 		b	.L642
 8193              	.L683:
 8194              	.LVL976:
 8195              	.LBE229:
 8196              	.LBE400:
 8197              	.LBB401:
 8198              	.LBB368:
 8199              	.LBB246:
 8200              	.LBB247:
2237:../uvc.c      **** 
 8201              		.loc 1 2237 0
 8202 4788 DC489FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8203              		.loc 1 2232 0
 8204 478c 2A56DAE5 		ldrb	r5, [r10, #1578]	@ zero_extendqisi2
 8205              	.LVL977:
2237:../uvc.c      **** 
 8206              		.loc 1 2237 0
 8207 4790 24408DE5 		str	r4, [sp, #36]
 8208 4794 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8209              	.LVL978:
2239:../uvc.c      **** 		 {
 8210              		.loc 1 2239 0
 8211 4798 830054E3 		cmp	r4, #131
 8212 479c 3804000A 		beq	.L731
 8213 47a0 C501009A 		bls	.L988
 8214 47a4 850054E3 		cmp	r4, #133
 8215 47a8 3B02000A 		beq	.L782
 8216 47ac 3C04003A 		bcc	.L737
 8217 47b0 860054E3 		cmp	r4, #134
 8218 47b4 F102000A 		beq	.L738
 8219 47b8 870054E3 		cmp	r4, #135
 8220 47bc 9404001A 		bne	.L730
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8221              		.loc 1 2301 0
 8222 47c0 5CE89FE5 		ldr	lr, .L1018+4
 8223 47c4 3316DEE5 		ldrb	r1, [lr, #1587]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8224              		.loc 1 2302 0
 8225 47c8 3426DEE5 		ldrb	r2, [lr, #1588]	@ zero_extendqisi2
 8226 47cc 480000EA 		b	.L957
 8227              	.LVL979:
 8228              	.L694:
 8229              	.LBE247:
 8230              	.LBE246:
 8231              	.LBB255:
 8232              	.LBB256:
2237:../uvc.c      **** 
 8233              		.loc 1 2237 0
 8234 47d0 94489FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8235              		.loc 1 2232 0
 8236 47d4 8A56DAE5 		ldrb	r5, [r10, #1674]	@ zero_extendqisi2
 8237              	.LVL980:
2237:../uvc.c      **** 
 8238              		.loc 1 2237 0
 8239 47d8 24408DE5 		str	r4, [sp, #36]
 8240 47dc 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8241              	.LVL981:
2239:../uvc.c      **** 		 {
 8242              		.loc 1 2239 0
 8243 47e0 830054E3 		cmp	r4, #131
 8244 47e4 1204000A 		beq	.L777
 8245 47e8 6601009A 		bls	.L989
 8246 47ec 850054E3 		cmp	r4, #133
 8247 47f0 2902000A 		beq	.L782
 8248 47f4 6104003A 		bcc	.L783
 8249 47f8 860054E3 		cmp	r4, #134
 8250 47fc B702000A 		beq	.L784
 8251 4800 870054E3 		cmp	r4, #135
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8252              		.loc 1 2301 0
 8253 4804 9316DA05 		ldreqb	r1, [r10, #1683]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8254              		.loc 1 2302 0
 8255 4808 9426DA05 		ldreqb	r2, [r10, #1684]	@ zero_extendqisi2
2239:../uvc.c      **** 		 {
 8256              		.loc 1 2239 0
 8257 480c 3800000A 		beq	.L957
 8258              	.L776:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8259              		.loc 1 2446 0
 8260 4810 0000A0E3 		mov	r0, #0
 8261 4814 0020A0E1 		mov	r2, r0
 8262 4818 0110A0E3 		mov	r1, #1
 8263 481c FEFFFFEB 		bl	CyU3PUsbStall
 8264              	.LVL982:
2447:../uvc.c      **** 			  break;
 8265              		.loc 1 2447 0
 8266 4820 24C09DE5 		ldr	ip, [sp, #36]
 8267 4824 0920A0E3 		mov	r2, #9
 8268 4828 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8269 482c 0400A0E3 		mov	r0, #4
 8270 4830 50189FE5 		ldr	r1, .L1018+104
 8271 4834 FEFFFFEB 		bl	CyU3PDebugPrint
 8272              	.LVL983:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8273              		.loc 1 2233 0
 8274 4838 FF20A0E3 		mov	r2, #255
 8275 483c 1D0200EA 		b	.L786
 8276              	.LVL984:
 8277              	.L687:
 8278              	.LBE256:
 8279              	.LBE255:
 8280              	.LBB267:
 8281              	.LBB268:
2237:../uvc.c      **** 
 8282              		.loc 1 2237 0
 8283 4840 24489FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8284              		.loc 1 2232 0
 8285 4844 B255DAE5 		ldrb	r5, [r10, #1458]	@ zero_extendqisi2
 8286              	.LVL985:
2237:../uvc.c      **** 
 8287              		.loc 1 2237 0
 8288 4848 24408DE5 		str	r4, [sp, #36]
 8289 484c 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8290              	.LVL986:
2239:../uvc.c      **** 		 {
 8291              		.loc 1 2239 0
 8292 4850 830054E3 		cmp	r4, #131
 8293 4854 FE03000A 		beq	.L698
 8294 4858 8401009A 		bls	.L990
 8295 485c 850054E3 		cmp	r4, #133
 8296 4860 0D02000A 		beq	.L782
 8297 4864 1204003A 		bcc	.L704
 8298 4868 860054E3 		cmp	r4, #134
 8299 486c C602000A 		beq	.L705
 8300 4870 870054E3 		cmp	r4, #135
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8301              		.loc 1 2301 0
 8302 4874 BB15DA05 		ldreqb	r1, [r10, #1467]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8303              		.loc 1 2302 0
 8304 4878 BC25DA05 		ldreqb	r2, [r10, #1468]	@ zero_extendqisi2
2239:../uvc.c      **** 		 {
 8305              		.loc 1 2239 0
 8306 487c 1C00000A 		beq	.L957
 8307              	.L697:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8308              		.loc 1 2446 0
 8309 4880 0000A0E3 		mov	r0, #0
 8310 4884 0020A0E1 		mov	r2, r0
 8311 4888 0110A0E3 		mov	r1, #1
 8312 488c FEFFFFEB 		bl	CyU3PUsbStall
 8313              	.LVL987:
2447:../uvc.c      **** 			  break;
 8314              		.loc 1 2447 0
 8315 4890 24C09DE5 		ldr	ip, [sp, #36]
 8316 4894 0020A0E3 		mov	r2, #0
 8317 4898 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8318 489c 0400A0E3 		mov	r0, #4
 8319 48a0 E0179FE5 		ldr	r1, .L1018+104
 8320 48a4 FEFFFFEB 		bl	CyU3PDebugPrint
 8321              	.LVL988:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8322              		.loc 1 2233 0
 8323 48a8 FF20A0E3 		mov	r2, #255
 8324              	.LVL989:
 8325 48ac 010200EA 		b	.L786
 8326              	.LVL990:
 8327              	.L685:
 8328              	.LBE268:
 8329              	.LBE267:
 8330              	.LBB275:
 8331              	.LBB276:
2237:../uvc.c      **** 
 8332              		.loc 1 2237 0
 8333 48b0 B4479FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8334              		.loc 1 2232 0
 8335 48b4 E255DAE5 		ldrb	r5, [r10, #1506]	@ zero_extendqisi2
 8336              	.LVL991:
2237:../uvc.c      **** 
 8337              		.loc 1 2237 0
 8338 48b8 24408DE5 		str	r4, [sp, #36]
 8339 48bc 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8340              	.LVL992:
2239:../uvc.c      **** 		 {
 8341              		.loc 1 2239 0
 8342 48c0 830054E3 		cmp	r4, #131
 8343 48c4 E603000A 		beq	.L709
 8344 48c8 5401009A 		bls	.L991
 8345 48cc 850054E3 		cmp	r4, #133
 8346 48d0 F101000A 		beq	.L782
 8347 48d4 4A04003A 		bcc	.L715
 8348 48d8 860054E3 		cmp	r4, #134
 8349 48dc AC02000A 		beq	.L716
 8350 48e0 870054E3 		cmp	r4, #135
 8351 48e4 0604001A 		bne	.L708
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8352              		.loc 1 2301 0
 8353 48e8 34E79FE5 		ldr	lr, .L1018+4
 8354 48ec EB15DEE5 		ldrb	r1, [lr, #1515]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8355              		.loc 1 2302 0
 8356 48f0 EC25DEE5 		ldrb	r2, [lr, #1516]	@ zero_extendqisi2
 8357              	.LVL993:
 8358              	.L957:
 8359              	.LBE276:
 8360              	.LBE275:
 8361              	.LBB284:
 8362              	.LBB257:
2280:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8363              		.loc 1 2280 0
 8364 48f4 0030A0E3 		mov	r3, #0
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8365              		.loc 1 2277 0
 8366 48f8 2810C7E5 		strb	r1, [r7, #40]
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8367              		.loc 1 2282 0
 8368 48fc 0500A0E1 		mov	r0, r5
 8369 4900 88179FE5 		ldr	r1, .L1018+112
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8370              		.loc 1 2278 0
 8371 4904 2920C7E5 		strb	r2, [r7, #41]
2280:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8372              		.loc 1 2280 0
 8373 4908 2A30C7E5 		strb	r3, [r7, #42]
2281:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8374              		.loc 1 2281 0
 8375 490c 2B30C7E5 		strb	r3, [r7, #43]
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8376              		.loc 1 2282 0
 8377 4910 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8378              	.LVL994:
2283:../uvc.c      **** 			  break;
 8379              		.loc 1 2283 0
 8380 4914 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 8381              	.LVL995:
 8382 4918 E60100EA 		b	.L786
 8383              	.LVL996:
 8384              	.L693:
 8385              	.LBE257:
 8386              	.LBE284:
 8387              	.LBB285:
 8388              	.LBB286:
2237:../uvc.c      **** 
 8389              		.loc 1 2237 0
 8390 491c 48479FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8391              		.loc 1 2232 0
 8392 4920 4256DAE5 		ldrb	r5, [r10, #1602]	@ zero_extendqisi2
 8393              	.LVL997:
2237:../uvc.c      **** 
 8394              		.loc 1 2237 0
 8395 4924 24408DE5 		str	r4, [sp, #36]
 8396 4928 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8397              	.LVL998:
2239:../uvc.c      **** 		 {
 8398              		.loc 1 2239 0
 8399 492c 830054E3 		cmp	r4, #131
 8400 4930 CF03000A 		beq	.L742
 8401 4934 2601009A 		bls	.L992
 8402 4938 850054E3 		cmp	r4, #133
 8403 493c D601000A 		beq	.L782
 8404 4940 2704003A 		bcc	.L748
 8405 4944 860054E3 		cmp	r4, #134
 8406 4948 7D02000A 		beq	.L749
 8407 494c 870054E3 		cmp	r4, #135
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8408              		.loc 1 2301 0
 8409 4950 4B16DA05 		ldreqb	r1, [r10, #1611]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8410              		.loc 1 2302 0
 8411 4954 4C26DA05 		ldreqb	r2, [r10, #1612]	@ zero_extendqisi2
2239:../uvc.c      **** 		 {
 8412              		.loc 1 2239 0
 8413 4958 E5FFFF0A 		beq	.L957
 8414              	.L741:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8415              		.loc 1 2446 0
 8416 495c 0000A0E3 		mov	r0, #0
 8417 4960 0020A0E1 		mov	r2, r0
 8418 4964 0110A0E3 		mov	r1, #1
 8419 4968 FEFFFFEB 		bl	CyU3PUsbStall
 8420              	.LVL999:
2447:../uvc.c      **** 			  break;
 8421              		.loc 1 2447 0
 8422 496c 24C09DE5 		ldr	ip, [sp, #36]
 8423 4970 0620A0E3 		mov	r2, #6
 8424 4974 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8425 4978 0400A0E3 		mov	r0, #4
 8426 497c 04179FE5 		ldr	r1, .L1018+104
 8427 4980 FEFFFFEB 		bl	CyU3PDebugPrint
 8428              	.LVL1000:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8429              		.loc 1 2233 0
 8430 4984 FF20A0E3 		mov	r2, #255
 8431              	.LVL1001:
 8432 4988 CA0100EA 		b	.L786
 8433              	.LVL1002:
 8434              	.L975:
 8435              	.LBE286:
 8436              	.LBE285:
 8437              	.LBB293:
 8438              	.LBB294:
2237:../uvc.c      **** 
 8439              		.loc 1 2237 0
 8440 498c D8469FE5 		ldr	r4, .L1018+76
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8441              		.loc 1 2232 0
 8442 4990 7256DAE5 		ldrb	r5, [r10, #1650]	@ zero_extendqisi2
 8443              	.LVL1003:
2237:../uvc.c      **** 
 8444              		.loc 1 2237 0
 8445 4994 24408DE5 		str	r4, [sp, #36]
 8446 4998 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
 8447              	.LVL1004:
2239:../uvc.c      **** 		 {
 8448              		.loc 1 2239 0
 8449 499c 830054E3 		cmp	r4, #131
 8450 49a0 BB03000A 		beq	.L766
 8451 49a4 5801009A 		bls	.L993
 8452 49a8 850054E3 		cmp	r4, #133
 8453 49ac BA01000A 		beq	.L782
 8454 49b0 0404003A 		bcc	.L772
 8455 49b4 860054E3 		cmp	r4, #134
 8456 49b8 3902000A 		beq	.L773
 8457 49bc 870054E3 		cmp	r4, #135
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8458              		.loc 1 2301 0
 8459 49c0 7B16DA05 		ldreqb	r1, [r10, #1659]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8460              		.loc 1 2302 0
 8461 49c4 7C26DA05 		ldreqb	r2, [r10, #1660]	@ zero_extendqisi2
2239:../uvc.c      **** 		 {
 8462              		.loc 1 2239 0
 8463 49c8 C9FFFF0A 		beq	.L957
 8464              	.L765:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8465              		.loc 1 2446 0
 8466 49cc 0000A0E3 		mov	r0, #0
 8467 49d0 0020A0E1 		mov	r2, r0
 8468 49d4 0110A0E3 		mov	r1, #1
 8469 49d8 FEFFFFEB 		bl	CyU3PUsbStall
 8470              	.LVL1005:
2447:../uvc.c      **** 			  break;
 8471              		.loc 1 2447 0
 8472 49dc 24C09DE5 		ldr	ip, [sp, #36]
 8473 49e0 0820A0E3 		mov	r2, #8
 8474 49e4 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 8475 49e8 0400A0E3 		mov	r0, #4
 8476 49ec 94169FE5 		ldr	r1, .L1018+104
 8477 49f0 FEFFFFEB 		bl	CyU3PDebugPrint
 8478              	.LVL1006:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8479              		.loc 1 2233 0
 8480 49f4 FF20A0E3 		mov	r2, #255
 8481              	.LVL1007:
 8482 49f8 AE0100EA 		b	.L786
 8483              	.LVL1008:
 8484              	.L695:
 8485              	.LBE294:
 8486              	.LBE293:
3979:../uvc.c      ****     		break;
 8487              		.loc 1 3979 0
 8488 49fc 0A00A0E3 		mov	r0, #10
 8489 4a00 FEFFFFEB 		bl	CTControlHandle
 8490              	.LVL1009:
 8491 4a04 44309DE5 		ldr	r3, [sp, #68]
 8492 4a08 C5FDFFEA 		b	.L642
 8493              	.L689:
 8494              	.LVL1010:
3947:../uvc.c      **** 			break;
 8495              		.loc 1 3947 0
 8496 4a0c 0300A0E3 		mov	r0, #3
 8497 4a10 FEFFFFEB 		bl	CTControlHandle
 8498              	.LVL1011:
 8499 4a14 44309DE5 		ldr	r3, [sp, #68]
 8500 4a18 C1FDFFEA 		b	.L642
 8501              	.L691:
 8502              	.LVL1012:
 8503              	.LBB301:
 8504              	.LBB302:
2237:../uvc.c      **** 
 8505              		.loc 1 2237 0
 8506 4a1c 48469FE5 		ldr	r4, .L1018+76
2229:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8507              		.loc 1 2229 0
 8508 4a20 67C6DAE5 		ldrb	ip, [r10, #1639]	@ zero_extendqisi2
 8509              	.LVL1013:
2237:../uvc.c      **** 
 8510              		.loc 1 2237 0
 8511 4a24 24408DE5 		str	r4, [sp, #36]
 8512 4a28 0040D4E5 		ldrb	r4, [r4]	@ zero_extendqisi2
2230:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8513              		.loc 1 2230 0
 8514 4a2c 5836DAE5 		ldrb	r3, [r10, #1624]	@ zero_extendqisi2
 8515              	.LVL1014:
2239:../uvc.c      **** 		 {
 8516              		.loc 1 2239 0
 8517 4a30 830054E3 		cmp	r4, #131
2232:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8518              		.loc 1 2232 0
 8519 4a34 5A56DAE5 		ldrb	r5, [r10, #1626]	@ zero_extendqisi2
 8520              	.LVL1015:
2239:../uvc.c      **** 		 {
 8521              		.loc 1 2239 0
 8522 4a38 8103000A 		beq	.L753
 8523 4a3c 4501009A 		bls	.L994
 8524 4a40 850054E3 		cmp	r4, #133
 8525 4a44 0204000A 		beq	.L758
 8526 4a48 FD03003A 		bcc	.L759
 8527 4a4c 860054E3 		cmp	r4, #134
 8528 4a50 3F02000A 		beq	.L760
 8529 4a54 870054E3 		cmp	r4, #135
 8530 4a58 B503001A 		bne	.L752
2301:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8531              		.loc 1 2301 0
 8532 4a5c C0259FE5 		ldr	r2, .L1018+4
 8533 4a60 6316D2E5 		ldrb	r1, [r2, #1635]	@ zero_extendqisi2
2302:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8534              		.loc 1 2302 0
 8535 4a64 6426D2E5 		ldrb	r2, [r2, #1636]	@ zero_extendqisi2
 8536              	.L955:
2280:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8537              		.loc 1 2280 0
 8538 4a68 0030A0E3 		mov	r3, #0
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8539              		.loc 1 2277 0
 8540 4a6c 2810C7E5 		strb	r1, [r7, #40]
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8541              		.loc 1 2282 0
 8542 4a70 0500A0E1 		mov	r0, r5
 8543 4a74 14169FE5 		ldr	r1, .L1018+112
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8544              		.loc 1 2278 0
 8545 4a78 2920C7E5 		strb	r2, [r7, #41]
2280:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8546              		.loc 1 2280 0
 8547 4a7c 2A30C7E5 		strb	r3, [r7, #42]
2281:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8548              		.loc 1 2281 0
 8549 4a80 2B30C7E5 		strb	r3, [r7, #43]
2282:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8550              		.loc 1 2282 0
 8551 4a84 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8552              	.LVL1016:
2283:../uvc.c      **** 			  break;
 8553              		.loc 1 2283 0
 8554 4a88 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8555              	.LVL1017:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8556              		.loc 1 2233 0
 8557 4a8c FF20A0E3 		mov	r2, #255
 8558 4a90 0230A0E1 		mov	r3, r2
 8559              	.LVL1018:
 8560              	.L762:
2452:../uvc.c      **** }
 8561              		.loc 1 2452 0
 8562 4a94 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 8563 4a98 FF00A0E3 		mov	r0, #255
 8564 4a9c 00208DE5 		str	r2, [sp]
 8565 4aa0 04108DE5 		str	r1, [sp, #4]
 8566 4aa4 10108DE5 		str	r1, [sp, #16]
 8567 4aa8 0C008DE5 		str	r0, [sp, #12]
 8568 4aac 08C08DE5 		str	ip, [sp, #8]
 8569 4ab0 14508DE5 		str	r5, [sp, #20]
 8570 4ab4 0420A0E1 		mov	r2, r4
 8571              	.LVL1019:
 8572 4ab8 0400A0E3 		mov	r0, #4
 8573 4abc 9C159FE5 		ldr	r1, .L1018+64
 8574 4ac0 FEFFFFEB 		bl	CyU3PDebugPrint
 8575              	.LVL1020:
 8576 4ac4 44309DE5 		ldr	r3, [sp, #68]
 8577 4ac8 95FDFFEA 		b	.L642
 8578              	.LVL1021:
 8579              	.L981:
 8580 4acc 0030A0E1 		mov	r3, r0
 8581              	.LBE302:
 8582              	.LBE301:
 8583              	.LBE368:
 8584              	.LBE401:
4843:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8585              		.loc 1 4843 0
 8586 4ad0 0320A0E1 		mov	r2, r3
 8587 4ad4 0500A0E1 		mov	r0, r5
 8588              	.LVL1022:
 8589 4ad8 90159FE5 		ldr	r1, .L1018+80
 8590 4adc 20308DE5 		str	r3, [sp, #32]
 8591 4ae0 FEFFFFEB 		bl	CyU3PDebugPrint
 8592              	.LVL1023:
4844:../uvc.c      **** 					}
 8593              		.loc 1 4844 0
 8594 4ae4 20309DE5 		ldr	r3, [sp, #32]
 8595 4ae8 0300A0E1 		mov	r0, r3
 8596 4aec FEFFFFEB 		bl	CyFxAppErrorHandler
 8597              	.LVL1024:
 8598              	.L815:
 8599              	.LBB402:
 8600              	.LBB230:
4240:../uvc.c      **** 			CyU3PDebugPrint (4, "The hyster command 0x%x 0x%x\r\n", wValue, bRequest);
 8601              		.loc 1 4240 0
 8602 4af0 2700A0E3 		mov	r0, #39
 8603 4af4 FEFFFFEB 		bl	ControlHandle
 8604              	.LVL1025:
4241:../uvc.c      ****     		break;
 8605              		.loc 1 4241 0
 8606 4af8 6C359FE5 		ldr	r3, .L1018+76
 8607 4afc B020D4E1 		ldrh	r2, [r4]
 8608 4b00 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8609 4b04 0400A0E3 		mov	r0, #4
 8610 4b08 3C159FE5 		ldr	r1, .L1018+44
 8611 4b0c FEFFFFEB 		bl	CyU3PDebugPrint
 8612              	.LVL1026:
 8613 4b10 44309DE5 		ldr	r3, [sp, #68]
 8614 4b14 82FDFFEA 		b	.L642
 8615              	.L806:
 8616              	.LVL1027:
4206:../uvc.c      ****     		break;
 8617              		.loc 1 4206 0
 8618 4b18 1B00A0E3 		mov	r0, #27
 8619 4b1c FEFFFFEB 		bl	ControlHandle
 8620              	.LVL1028:
 8621 4b20 44309DE5 		ldr	r3, [sp, #68]
 8622 4b24 7EFDFFEA 		b	.L642
 8623              	.L819:
4250:../uvc.c      **** 			CyU3PDebugPrint (4, "The edgeMode command 0x%x 0x%x\r\n", wValue, bRequest);
 8624              		.loc 1 4250 0
 8625 4b28 2900A0E3 		mov	r0, #41
 8626 4b2c FEFFFFEB 		bl	ControlHandle
 8627              	.LVL1029:
4251:../uvc.c      ****     		break;
 8628              		.loc 1 4251 0
 8629 4b30 34359FE5 		ldr	r3, .L1018+76
 8630 4b34 B020D4E1 		ldrh	r2, [r4]
 8631 4b38 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8632 4b3c 0400A0E3 		mov	r0, #4
 8633 4b40 08159FE5 		ldr	r1, .L1018+48
 8634 4b44 FEFFFFEB 		bl	CyU3PDebugPrint
 8635              	.LVL1030:
 8636 4b48 44309DE5 		ldr	r3, [sp, #68]
 8637 4b4c 74FDFFEA 		b	.L642
 8638              	.L799:
 8639              	.LVL1031:
4171:../uvc.c      ****     		break;
 8640              		.loc 1 4171 0
 8641 4b50 1300A0E3 		mov	r0, #19
 8642 4b54 FEFFFFEB 		bl	ControlHandle
 8643              	.LVL1032:
 8644 4b58 44309DE5 		ldr	r3, [sp, #68]
 8645 4b5c 70FDFFEA 		b	.L642
 8646              	.L812:
 8647              	.LVL1033:
4220:../uvc.c      ****     		break;
 8648              		.loc 1 4220 0
 8649 4b60 1E00A0E3 		mov	r0, #30
 8650 4b64 FEFFFFEB 		bl	ControlHandle
 8651              	.LVL1034:
 8652 4b68 44309DE5 		ldr	r3, [sp, #68]
 8653 4b6c 6CFDFFEA 		b	.L642
 8654              	.L803:
 8655              	.LVL1035:
 8656              	.LBB170:
 8657              	.LBB171:
1359:../uvc.c      ****     /*
 8658              		.loc 1 1359 0
 8659 4b70 F4349FE5 		ldr	r3, .L1018+76
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8660              		.loc 1 1341 0
 8661 4b74 3027DAE5 		ldrb	r2, [r10, #1840]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8662              		.loc 1 1359 0
 8663 4b78 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8664              		.loc 1 1342 0
 8665 4b7c 3147DAE5 		ldrb	r4, [r10, #1841]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 8666              		.loc 1 1359 0
 8667 4b80 28308DE5 		str	r3, [sp, #40]
1367:../uvc.c      **** 		 {
 8668              		.loc 1 1367 0
 8669 4b84 28C09DE5 		ldr	ip, [sp, #40]
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8670              		.loc 1 1343 0
 8671 4b88 3F37DAE5 		ldrb	r3, [r10, #1855]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8672              		.loc 1 1344 0
 8673 4b8c 3257DAE5 		ldrb	r5, [r10, #1842]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8674              		.loc 1 1341 0
 8675 4b90 FF2002E2 		and	r2, r2, #255
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8676              		.loc 1 1343 0
 8677 4b94 FF3003E2 		and	r3, r3, #255
1367:../uvc.c      **** 		 {
 8678              		.loc 1 1367 0
 8679 4b98 83005CE3 		cmp	ip, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 8680              		.loc 1 1341 0
 8681 4b9c 30208DE5 		str	r2, [sp, #48]
 8682              	.LVL1036:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 8683              		.loc 1 1342 0
 8684 4ba0 FF4004E2 		and	r4, r4, #255
 8685              	.LVL1037:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 8686              		.loc 1 1343 0
 8687 4ba4 2C308DE5 		str	r3, [sp, #44]
 8688              	.LVL1038:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 8689              		.loc 1 1344 0
 8690 4ba8 FF5005E2 		and	r5, r5, #255
 8691              	.LVL1039:
1367:../uvc.c      **** 		 {
 8692              		.loc 1 1367 0
 8693 4bac F203000A 		beq	.L825
 8694 4bb0 5502009A 		bls	.L995
 8695 4bb4 28409DE5 		ldr	r4, [sp, #40]
 8696              	.LVL1040:
 8697 4bb8 850054E3 		cmp	r4, #133
 8698 4bbc 1202000A 		beq	.L830
 8699 4bc0 3D04003A 		bcc	.L831
 8700 4bc4 860054E3 		cmp	r4, #134
 8701 4bc8 2C04000A 		beq	.L832
 8702 4bcc 870054E3 		cmp	r4, #135
 8703 4bd0 2004001A 		bne	.L824
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8704              		.loc 1 1756 0
 8705 4bd4 020055E3 		cmp	r5, #2
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8706              		.loc 1 1762 0
 8707 4bd8 3BC7DA15 		ldrneb	ip, [r10, #1851]	@ zero_extendqisi2
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8708              		.loc 1 1764 0
 8709 4bdc 3C27DA15 		ldrneb	r2, [r10, #1852]	@ zero_extendqisi2
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 8710              		.loc 1 1756 0
 8711 4be0 0305000A 		beq	.L996
 8712              	.L959:
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8713              		.loc 1 1763 0
 8714 4be4 0030A0E3 		mov	r3, #0
1787:../uvc.c      **** 		 	 }
 8715              		.loc 1 1787 0
 8716 4be8 0340A0E1 		mov	r4, r3
1781:../uvc.c      **** 		 	 if(Len == 2){
 8717              		.loc 1 1781 0
 8718 4bec 0500A0E1 		mov	r0, r5
 8719 4bf0 98149FE5 		ldr	r1, .L1018+112
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 8720              		.loc 1 1762 0
 8721 4bf4 28C0C7E5 		strb	ip, [r7, #40]
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 8722              		.loc 1 1764 0
 8723 4bf8 2A20C7E5 		strb	r2, [r7, #42]
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 8724              		.loc 1 1763 0
 8725 4bfc 2930C7E5 		strb	r3, [r7, #41]
1765:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 8726              		.loc 1 1765 0
 8727 4c00 2B30C7E5 		strb	r3, [r7, #43]
1787:../uvc.c      **** 		 	 }
 8728              		.loc 1 1787 0
 8729 4c04 24308DE5 		str	r3, [sp, #36]
 8730 4c08 0450A0E1 		mov	r5, r4
 8731              	.LVL1041:
1781:../uvc.c      **** 		 	 if(Len == 2){
 8732              		.loc 1 1781 0
 8733 4c0c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8734              	.LVL1042:
1786:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 8735              		.loc 1 1786 0
 8736 4c10 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8737              	.LVL1043:
1787:../uvc.c      **** 		 	 }
 8738              		.loc 1 1787 0
 8739 4c14 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 8740              	.LVL1044:
 8741 4c18 050200EA 		b	.L834
 8742              	.LVL1045:
 8743              	.L797:
 8744              	.LBE171:
 8745              	.LBE170:
4159:../uvc.c      ****     		break;
 8746              		.loc 1 4159 0
 8747 4c1c 1000A0E3 		mov	r0, #16
 8748 4c20 FEFFFFEB 		bl	ControlHandle
 8749              	.LVL1046:
 8750 4c24 44309DE5 		ldr	r3, [sp, #68]
 8751 4c28 3DFDFFEA 		b	.L642
 8752              	.L822:
4275:../uvc.c      **** 			CyU3PDebugPrint (4, "The AGC Max command 0x%x 0x%x\r\n", wValue, bRequest);
 8753              		.loc 1 4275 0
 8754 4c2c 2F00A0E3 		mov	r0, #47
 8755 4c30 FEFFFFEB 		bl	ControlHandle
 8756              	.LVL1047:
4276:../uvc.c      ****     		break;
 8757              		.loc 1 4276 0
 8758 4c34 30349FE5 		ldr	r3, .L1018+76
 8759 4c38 B020D4E1 		ldrh	r2, [r4]
 8760 4c3c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 8761 4c40 0400A0E3 		mov	r0, #4
 8762 4c44 08149FE5 		ldr	r1, .L1018+52
 8763 4c48 FEFFFFEB 		bl	CyU3PDebugPrint
 8764              	.LVL1048:
 8765 4c4c 44309DE5 		ldr	r3, [sp, #68]
 8766 4c50 33FDFFEA 		b	.L642
 8767              	.LVL1049:
 8768              	.L978:
 8769              	.LBE230:
 8770              	.LBE402:
 8771              	.LBB403:
 8772              	.LBB388:
 8773              	.LBB381:
 8774              	.LBB377:
1367:../uvc.c      **** 		 {
 8775              		.loc 1 1367 0
 8776 4c54 810054E3 		cmp	r4, #129
 8777 4c58 B802000A 		beq	.L666
 8778 4c5c 8701008A 		bhi	.L667
 8779 4c60 010054E3 		cmp	r4, #1
 8780 4c64 AC02001A 		bne	.L663
1791:../uvc.c      **** 				  glEp0Buffer, &readCount);
 8781              		.loc 1 1791 0
 8782 4c68 42208DE2 		add	r2, sp, #66
 8783 4c6c 2000A0E3 		mov	r0, #32
 8784 4c70 18149FE5 		ldr	r1, .L1018+112
 8785 4c74 20308DE5 		str	r3, [sp, #32]
 8786 4c78 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8787              	.LVL1050:
1793:../uvc.c      **** 			   {
 8788              		.loc 1 1793 0
 8789 4c7c 20309DE5 		ldr	r3, [sp, #32]
 8790 4c80 002050E2 		subs	r2, r0, #0
 8791 4c84 0205001A 		bne	.L679
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8792              		.loc 1 1803 0
 8793 4c88 2CE09DE5 		ldr	lr, [sp, #44]
 8794 4c8c 24109DE5 		ldr	r1, [sp, #36]
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 8795              		.loc 1 1796 0
 8796 4c90 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1795:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 8797              		.loc 1 1795 0
 8798 4c94 020053E3 		cmp	r3, #2
 8799              	.LVL1051:
1797:../uvc.c      **** 				 }else{
 8800              		.loc 1 1797 0
 8801 4c98 2950DB05 		ldreqb	r5, [fp, #41]	@ zero_extendqisi2
 8802              	.LVL1052:
1800:../uvc.c      **** 				 }
 8803              		.loc 1 1800 0
 8804 4c9c 2A50DB15 		ldrneb	r5, [fp, #42]	@ zero_extendqisi2
 8805              	.LVL1053:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 8806              		.loc 1 1803 0
 8807 4ca0 0120A0E3 		mov	r2, #1
 8808 4ca4 00E08DE5 		str	lr, [sp]
 8809 4ca8 0A008DE9 		stmib	sp, {r1, r3}
 8810 4cac 28309DE5 		ldr	r3, [sp, #40]
 8811 4cb0 C8139FE5 		ldr	r1, .L1018+96
 8812 4cb4 0400A0E3 		mov	r0, #4
 8813              	.LVL1054:
 8814 4cb8 1CC08DE5 		str	ip, [sp, #28]
 8815 4cbc FEFFFFEB 		bl	CyU3PDebugPrint
 8816              	.LVL1055:
2039:../uvc.c      **** 								  /****** double check the register0 Data1 ******/
 8817              		.loc 1 2039 0
 8818 4cc0 90239FE5 		ldr	r2, .L1018+56
 8819 4cc4 0010E0E3 		mvn	r1, #0
 8820 4cc8 1C0092E5 		ldr	r0, [r2, #28]
 8821 4ccc FEFFFFEB 		bl	_txe_mutex_get
 8822              	.LVL1056:
2048:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 8823              		.loc 1 2048 0
 8824 4cd0 1CC09DE5 		ldr	ip, [sp, #28]
 8825 4cd4 0010A0E3 		mov	r1, #0
 8826 4cd8 00C08DE5 		str	ip, [sp]
 8827 4cdc 2C209DE5 		ldr	r2, [sp, #44]
 8828 4ce0 24309DE5 		ldr	r3, [sp, #36]
 8829 4ce4 04108DE5 		str	r1, [sp, #4]
 8830 4ce8 68039FE5 		ldr	r0, .L1018+56
 8831 4cec 0110A0E3 		mov	r1, #1
 8832 4cf0 FEFFFFEB 		bl	cmdSet
 8833              	.LVL1057:
2049:../uvc.c      **** 
 8834              		.loc 1 2049 0
 8835 4cf4 5C339FE5 		ldr	r3, .L1018+56
 8836 4cf8 1C0093E5 		ldr	r0, [r3, #28]
 8837 4cfc FEFFFFEB 		bl	_txe_mutex_put
 8838              	.LVL1058:
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8839              		.loc 1 2051 0
 8840 4d00 1CC09DE5 		ldr	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8841              		.loc 1 1355 0
 8842 4d04 FF30A0E3 		mov	r3, #255
2052:../uvc.c      **** 							 break;
 8843              		.loc 1 2052 0
 8844 4d08 0110A0E3 		mov	r1, #1
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8845              		.loc 1 1355 0
 8846 4d0c 0320A0E1 		mov	r2, r3
2051:../uvc.c      **** 								 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 8847              		.loc 1 2051 0
 8848 4d10 2DC5CAE5 		strb	ip, [r10, #1325]
2052:../uvc.c      **** 							 break;
 8849              		.loc 1 2052 0
 8850 4d14 3115CAE5 		strb	r1, [r10, #1329]
 8851              	.LVL1059:
 8852              	.L673:
2213:../uvc.c      **** }
 8853              		.loc 1 2213 0
 8854 4d18 0C008DE9 		stmib	sp, {r2, r3}
 8855 4d1c 54139FE5 		ldr	r1, .L1018+88
 8856 4d20 0C30A0E1 		mov	r3, ip
 8857              	.LVL1060:
 8858 4d24 00508DE5 		str	r5, [sp]
 8859 4d28 0420A0E1 		mov	r2, r4
 8860              	.LVL1061:
 8861 4d2c 0400A0E3 		mov	r0, #4
 8862 4d30 FEFFFFEB 		bl	CyU3PDebugPrint
 8863              	.LVL1062:
 8864 4d34 44309DE5 		ldr	r3, [sp, #68]
 8865 4d38 F9FCFFEA 		b	.L642
 8866              	.LVL1063:
 8867              	.L986:
 8868              	.LBE377:
 8869              	.LBE381:
 8870              	.LBE388:
 8871              	.LBE403:
 8872              	.LBB404:
 8873              	.LBB369:
 8874              	.LBB311:
 8875              	.LBB240:
2239:../uvc.c      **** 		 {
 8876              		.loc 1 2239 0
 8877 4d3c 810054E3 		cmp	r4, #129
 8878 4d40 2B03000A 		beq	.L722
 8879 4d44 5E01008A 		bhi	.L723
 8880 4d48 010054E3 		cmp	r4, #1
 8881 4d4c 20FEFF1A 		bne	.L719
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8882              		.loc 1 2310 0
 8883 4d50 38139FE5 		ldr	r1, .L1018+112
 8884 4d54 42208DE2 		add	r2, sp, #66
 8885 4d58 2000A0E3 		mov	r0, #32
 8886 4d5c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8887              	.LVL1064:
2441:../uvc.c      **** 			  		 break;
 8888              		.loc 1 2441 0
 8889 4d60 24109DE5 		ldr	r1, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8890              		.loc 1 2440 0
 8891 4d64 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2441:../uvc.c      **** 			  		 break;
 8892              		.loc 1 2441 0
 8893 4d68 0400A0E3 		mov	r0, #4
 8894 4d6c 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 8895 4d70 0020A0E1 		mov	r2, r0
 8896 4d74 E0129FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8897              		.loc 1 2440 0
 8898 4d78 1DC6CAE5 		strb	ip, [r10, #1565]
2441:../uvc.c      **** 			  		 break;
 8899              		.loc 1 2441 0
 8900 4d7c FEFFFFEB 		bl	CyU3PDebugPrint
 8901              	.LVL1065:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8902              		.loc 1 2233 0
 8903 4d80 FF20A0E3 		mov	r2, #255
 8904 4d84 CB0000EA 		b	.L786
 8905              	.LVL1066:
 8906              	.L989:
 8907              	.LBE240:
 8908              	.LBE311:
 8909              	.LBB312:
 8910              	.LBB258:
2239:../uvc.c      **** 		 {
 8911              		.loc 1 2239 0
 8912 4d88 810054E3 		cmp	r4, #129
 8913 4d8c 3A03000A 		beq	.L779
 8914 4d90 5801008A 		bhi	.L780
 8915 4d94 010054E3 		cmp	r4, #1
 8916 4d98 9CFEFF1A 		bne	.L776
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8917              		.loc 1 2310 0
 8918 4d9c EC129FE5 		ldr	r1, .L1018+112
 8919 4da0 42208DE2 		add	r2, sp, #66
 8920 4da4 2000A0E3 		mov	r0, #32
 8921 4da8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8922              	.LVL1067:
2441:../uvc.c      **** 			  		 break;
 8923              		.loc 1 2441 0
 8924 4dac 24E09DE5 		ldr	lr, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8925              		.loc 1 2440 0
 8926 4db0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2441:../uvc.c      **** 			  		 break;
 8927              		.loc 1 2441 0
 8928 4db4 0920A0E3 		mov	r2, #9
 8929 4db8 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8930 4dbc 0400A0E3 		mov	r0, #4
 8931 4dc0 94129FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8932              		.loc 1 2440 0
 8933 4dc4 95C6CAE5 		strb	ip, [r10, #1685]
2441:../uvc.c      **** 			  		 break;
 8934              		.loc 1 2441 0
 8935 4dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 8936              	.LVL1068:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8937              		.loc 1 2233 0
 8938 4dcc FF20A0E3 		mov	r2, #255
 8939 4dd0 B80000EA 		b	.L786
 8940              	.LVL1069:
 8941              	.L992:
 8942              	.LBE258:
 8943              	.LBE312:
 8944              	.LBB313:
 8945              	.LBB287:
2239:../uvc.c      **** 		 {
 8946              		.loc 1 2239 0
 8947 4dd4 810054E3 		cmp	r4, #129
 8948 4dd8 EC02000A 		beq	.L744
 8949 4ddc 4901008A 		bhi	.L745
 8950 4de0 010054E3 		cmp	r4, #1
 8951 4de4 DCFEFF1A 		bne	.L741
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8952              		.loc 1 2310 0
 8953 4de8 A0129FE5 		ldr	r1, .L1018+112
 8954 4dec 42208DE2 		add	r2, sp, #66
 8955 4df0 2000A0E3 		mov	r0, #32
 8956 4df4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8957              	.LVL1070:
2441:../uvc.c      **** 			  		 break;
 8958              		.loc 1 2441 0
 8959 4df8 24E09DE5 		ldr	lr, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8960              		.loc 1 2440 0
 8961 4dfc 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2441:../uvc.c      **** 			  		 break;
 8962              		.loc 1 2441 0
 8963 4e00 0620A0E3 		mov	r2, #6
 8964 4e04 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 8965 4e08 0400A0E3 		mov	r0, #4
 8966 4e0c 48129FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8967              		.loc 1 2440 0
 8968 4e10 4DC6CAE5 		strb	ip, [r10, #1613]
2441:../uvc.c      **** 			  		 break;
 8969              		.loc 1 2441 0
 8970 4e14 FEFFFFEB 		bl	CyU3PDebugPrint
 8971              	.LVL1071:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8972              		.loc 1 2233 0
 8973 4e18 FF20A0E3 		mov	r2, #255
 8974 4e1c A50000EA 		b	.L786
 8975              	.LVL1072:
 8976              	.L991:
 8977              	.LBE287:
 8978              	.LBE313:
 8979              	.LBB314:
 8980              	.LBB277:
2239:../uvc.c      **** 		 {
 8981              		.loc 1 2239 0
 8982 4e20 810054E3 		cmp	r4, #129
 8983 4e24 1C03000A 		beq	.L711
 8984 4e28 3A01008A 		bhi	.L712
 8985 4e2c 010054E3 		cmp	r4, #1
 8986 4e30 B302001A 		bne	.L708
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 8987              		.loc 1 2310 0
 8988 4e34 54129FE5 		ldr	r1, .L1018+112
 8989 4e38 42208DE2 		add	r2, sp, #66
 8990 4e3c 2000A0E3 		mov	r0, #32
 8991 4e40 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 8992              	.LVL1073:
2441:../uvc.c      **** 			  		 break;
 8993              		.loc 1 2441 0
 8994 4e44 24109DE5 		ldr	r1, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 8995              		.loc 1 2440 0
 8996 4e48 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 8997 4e4c D0E19FE5 		ldr	lr, .L1018+4
2441:../uvc.c      **** 			  		 break;
 8998              		.loc 1 2441 0
 8999 4e50 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 9000 4e54 0220A0E3 		mov	r2, #2
 9001 4e58 0400A0E3 		mov	r0, #4
 9002 4e5c F8119FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9003              		.loc 1 2440 0
 9004 4e60 EDC5CEE5 		strb	ip, [lr, #1517]
2441:../uvc.c      **** 			  		 break;
 9005              		.loc 1 2441 0
 9006 4e64 FEFFFFEB 		bl	CyU3PDebugPrint
 9007              	.LVL1074:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9008              		.loc 1 2233 0
 9009 4e68 FF20A0E3 		mov	r2, #255
 9010 4e6c 910000EA 		b	.L786
 9011              	.LVL1075:
 9012              	.L990:
 9013              	.LBE277:
 9014              	.LBE314:
 9015              	.LBB315:
 9016              	.LBB269:
2239:../uvc.c      **** 		 {
 9017              		.loc 1 2239 0
 9018 4e70 810054E3 		cmp	r4, #129
 9019 4e74 0403000A 		beq	.L700
 9020 4e78 1A01008A 		bhi	.L701
 9021 4e7c 010054E3 		cmp	r4, #1
 9022 4e80 7EFEFF1A 		bne	.L697
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9023              		.loc 1 2310 0
 9024 4e84 04129FE5 		ldr	r1, .L1018+112
 9025 4e88 42208DE2 		add	r2, sp, #66
 9026 4e8c 2000A0E3 		mov	r0, #32
 9027 4e90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9028              	.LVL1076:
2441:../uvc.c      **** 			  		 break;
 9029              		.loc 1 2441 0
 9030 4e94 24E09DE5 		ldr	lr, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9031              		.loc 1 2440 0
 9032 4e98 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2441:../uvc.c      **** 			  		 break;
 9033              		.loc 1 2441 0
 9034 4e9c 0020A0E3 		mov	r2, #0
 9035 4ea0 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9036 4ea4 0400A0E3 		mov	r0, #4
 9037 4ea8 AC119FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9038              		.loc 1 2440 0
 9039 4eac BDC5CAE5 		strb	ip, [r10, #1469]
2441:../uvc.c      **** 			  		 break;
 9040              		.loc 1 2441 0
 9041 4eb0 FEFFFFEB 		bl	CyU3PDebugPrint
 9042              	.LVL1077:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9043              		.loc 1 2233 0
 9044 4eb4 FF20A0E3 		mov	r2, #255
 9045 4eb8 7E0000EA 		b	.L786
 9046              	.LVL1078:
 9047              	.L988:
 9048              	.LBE269:
 9049              	.LBE315:
 9050              	.LBB316:
 9051              	.LBB248:
2239:../uvc.c      **** 		 {
 9052              		.loc 1 2239 0
 9053 4ebc 810054E3 		cmp	r4, #129
 9054 4ec0 C302000A 		beq	.L733
 9055 4ec4 1A01008A 		bhi	.L734
 9056 4ec8 010054E3 		cmp	r4, #1
 9057 4ecc D002001A 		bne	.L730
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9058              		.loc 1 2310 0
 9059 4ed0 B8119FE5 		ldr	r1, .L1018+112
 9060 4ed4 42208DE2 		add	r2, sp, #66
 9061 4ed8 2000A0E3 		mov	r0, #32
 9062 4edc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9063              	.LVL1079:
2441:../uvc.c      **** 			  		 break;
 9064              		.loc 1 2441 0
 9065 4ee0 24109DE5 		ldr	r1, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9066              		.loc 1 2440 0
 9067 4ee4 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9068 4ee8 34E19FE5 		ldr	lr, .L1018+4
2441:../uvc.c      **** 			  		 break;
 9069              		.loc 1 2441 0
 9070 4eec 0030D1E5 		ldrb	r3, [r1]	@ zero_extendqisi2
 9071 4ef0 0520A0E3 		mov	r2, #5
 9072 4ef4 0400A0E3 		mov	r0, #4
 9073 4ef8 5C119FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9074              		.loc 1 2440 0
 9075 4efc 35C6CEE5 		strb	ip, [lr, #1589]
2441:../uvc.c      **** 			  		 break;
 9076              		.loc 1 2441 0
 9077 4f00 FEFFFFEB 		bl	CyU3PDebugPrint
 9078              	.LVL1080:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9079              		.loc 1 2233 0
 9080 4f04 FF20A0E3 		mov	r2, #255
 9081 4f08 6A0000EA 		b	.L786
 9082              	.LVL1081:
 9083              	.L993:
 9084              	.LBE248:
 9085              	.LBE316:
 9086              	.LBB317:
 9087              	.LBB295:
2239:../uvc.c      **** 		 {
 9088              		.loc 1 2239 0
 9089 4f0c 810054E3 		cmp	r4, #129
 9090 4f10 E502000A 		beq	.L768
 9091 4f14 0301008A 		bhi	.L769
 9092 4f18 010054E3 		cmp	r4, #1
 9093 4f1c AAFEFF1A 		bne	.L765
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9094              		.loc 1 2310 0
 9095 4f20 68119FE5 		ldr	r1, .L1018+112
 9096 4f24 42208DE2 		add	r2, sp, #66
 9097 4f28 2000A0E3 		mov	r0, #32
 9098 4f2c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9099              	.LVL1082:
2441:../uvc.c      **** 			  		 break;
 9100              		.loc 1 2441 0
 9101 4f30 24E09DE5 		ldr	lr, [sp, #36]
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9102              		.loc 1 2440 0
 9103 4f34 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
2441:../uvc.c      **** 			  		 break;
 9104              		.loc 1 2441 0
 9105 4f38 0820A0E3 		mov	r2, #8
 9106 4f3c 0030DEE5 		ldrb	r3, [lr]	@ zero_extendqisi2
 9107 4f40 0400A0E3 		mov	r0, #4
 9108 4f44 10119FE5 		ldr	r1, .L1018+60
2440:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9109              		.loc 1 2440 0
 9110 4f48 7DC6CAE5 		strb	ip, [r10, #1661]
2441:../uvc.c      **** 			  		 break;
 9111              		.loc 1 2441 0
 9112 4f4c FEFFFFEB 		bl	CyU3PDebugPrint
 9113              	.LVL1083:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9114              		.loc 1 2233 0
 9115 4f50 FF20A0E3 		mov	r2, #255
 9116 4f54 570000EA 		b	.L786
 9117              	.LVL1084:
 9118              	.L994:
 9119              	.LBE295:
 9120              	.LBE317:
 9121              	.LBB318:
 9122              	.LBB303:
2239:../uvc.c      **** 		 {
 9123              		.loc 1 2239 0
 9124 4f58 810054E3 		cmp	r4, #129
 9125 4f5c 5802000A 		beq	.L755
 9126 4f60 DA00008A 		bhi	.L756
 9127 4f64 010054E3 		cmp	r4, #1
 9128 4f68 7102001A 		bne	.L752
2310:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9129              		.loc 1 2310 0
 9130 4f6c 1C119FE5 		ldr	r1, .L1018+112
 9131 4f70 42208DE2 		add	r2, sp, #66
 9132 4f74 2000A0E3 		mov	r0, #32
 9133 4f78 20308DE5 		str	r3, [sp, #32]
 9134 4f7c 1CC08DE5 		str	ip, [sp, #28]
 9135 4f80 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9136              	.LVL1085:
2402:../uvc.c      **** 					  {
 9137              		.loc 1 2402 0
 9138 4f84 98E09FE5 		ldr	lr, .L1018+4
2312:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9139              		.loc 1 2312 0
 9140 4f88 2810D7E5 		ldrb	r1, [r7, #40]	@ zero_extendqisi2
2402:../uvc.c      **** 					  {
 9141              		.loc 1 2402 0
 9142 4f8c D505DEE5 		ldrb	r0, [lr, #1493]	@ zero_extendqisi2
2313:../uvc.c      **** 			  value = Data1;
 9143              		.loc 1 2313 0
 9144 4f90 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
2402:../uvc.c      **** 					  {
 9145              		.loc 1 2402 0
 9146 4f94 010050E3 		cmp	r0, #1
 9147 4f98 08005013 		cmpne	r0, #8
2312:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9148              		.loc 1 2312 0
 9149 4f9c 24108DE5 		str	r1, [sp, #36]
 9150              	.LVL1086:
2402:../uvc.c      **** 					  {
 9151              		.loc 1 2402 0
 9152 4fa0 0000A013 		movne	r0, #0
 9153 4fa4 0100A003 		moveq	r0, #1
2313:../uvc.c      **** 			  value = Data1;
 9154              		.loc 1 2313 0
 9155 4fa8 28208DE5 		str	r2, [sp, #40]
 9156              	.LVL1087:
2402:../uvc.c      **** 					  {
 9157              		.loc 1 2402 0
 9158 4fac 5203001A 		bne	.L763
 9159              	.LVL1088:
2405:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9160              		.loc 1 2405 0
 9161 4fb0 A0E09FE5 		ldr	lr, .L1018+56
 9162 4fb4 0010E0E3 		mvn	r1, #0
 9163 4fb8 1C009EE5 		ldr	r0, [lr, #28]
 9164 4fbc FEFFFFEB 		bl	_txe_mutex_get
 9165              	.LVL1089:
2406:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9166              		.loc 1 2406 0
 9167 4fc0 1CC09DE5 		ldr	ip, [sp, #28]
 9168 4fc4 24209DE5 		ldr	r2, [sp, #36]
 9169 4fc8 20309DE5 		ldr	r3, [sp, #32]
 9170 4fcc 0010A0E3 		mov	r1, #0
 9171 4fd0 00208DE5 		str	r2, [sp]
 9172 4fd4 04108DE5 		str	r1, [sp, #4]
 9173 4fd8 0320A0E1 		mov	r2, r3
 9174 4fdc 2210A0E3 		mov	r1, #34
 9175 4fe0 0C30A0E1 		mov	r3, ip
 9176 4fe4 6C009FE5 		ldr	r0, .L1018+56
 9177 4fe8 FEFFFFEB 		bl	cmdSet
 9178              	.LVL1090:
2407:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9179              		.loc 1 2407 0
 9180 4fec 64309FE5 		ldr	r3, .L1018+56
 9181 4ff0 1C0093E5 		ldr	r0, [r3, #28]
 9182 4ff4 FEFFFFEB 		bl	_txe_mutex_put
 9183              	.LVL1091:
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9184              		.loc 1 2410 0
 9185 4ff8 24E09FE5 		ldr	lr, .L1018+4
 9186 4ffc 24C09DE5 		ldr	ip, [sp, #36]
2412:../uvc.c      **** 					  }else{
 9187              		.loc 1 2412 0
 9188 5000 6846CEE5 		strb	r4, [lr, #1640]
2410:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9189              		.loc 1 2410 0
 9190 5004 65C6CEE5 		strb	ip, [lr, #1637]
2411:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9191              		.loc 1 2411 0
 9192 5008 28C09DE5 		ldr	ip, [sp, #40]
 9193 500c 66C6CEE5 		strb	ip, [lr, #1638]
 9194              	.LVL1092:
 9195              	.L764:
2416:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9196              		.loc 1 2416 0
 9197 5010 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
 9198              	.LVL1093:
2417:../uvc.c      **** 
 9199              		.loc 1 2417 0
 9200 5014 2920D7E5 		ldrb	r2, [r7, #41]	@ zero_extendqisi2
 9201              	.LVL1094:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9202              		.loc 1 2233 0
 9203 5018 FFC0A0E3 		mov	ip, #255
 9204 501c 9CFEFFEA 		b	.L762
 9205              	.L1019:
 9206              		.align	2
 9207              	.L1018:
 9208 5020 00000000 		.word	.LANCHOR0
 9209 5024 00000000 		.word	.LANCHOR1
 9210 5028 00000000 		.word	glInterStaBuffer
 9211 502c 00000000 		.word	wIndex
 9212 5030 00000000 		.word	wValue
 9213 5034 940C0000 		.word	.LC70
 9214 5038 00000000 		.word	bmReqType
 9215 503c 00000000 		.word	wLength
 9216 5040 180C0000 		.word	.LC69
 9217 5044 00000000 		.word	glChHandleInterStat
 9218 5048 700D0000 		.word	.LC76
 9219 504c C00C0000 		.word	.LC71
 9220 5050 000D0000 		.word	.LC73
 9221 5054 B80D0000 		.word	.LC78
 9222 5058 00000000 		.word	cmdQu
 9223 505c 8C060000 		.word	.LC37
 9224 5060 D4060000 		.word	.LC39
 9225 5064 E00C0000 		.word	.LC72
 9226 5068 980D0000 		.word	.LC77
 9227 506c 00000000 		.word	bRequest
 9228 5070 D80D0000 		.word	.LC79
 9229 5074 480D0000 		.word	.LC75
 9230 5078 14060000 		.word	.LC35
 9231 507c 240D0000 		.word	.LC74
 9232 5080 68040000 		.word	.LC27
 9233 5084 4C050000 		.word	.LC31
 9234 5088 B0060000 		.word	.LC38
 9235 508c 38040000 		.word	.LC26
 9236 5090 28000000 		.word	.LANCHOR0+40
 9237 5094 E4050000 		.word	.LC34
 9238 5098 00000000 		.word	.LANCHOR1
 9239              	.LVL1095:
 9240              	.L782:
 9241              	.LBE303:
 9242              	.LBE318:
 9243              	.LBB319:
 9244              	.LBB259:
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9245              		.loc 1 2244 0
 9246 509c 0030A0E3 		mov	r3, #0
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9247              		.loc 1 2245 0
 9248 50a0 0200A0E3 		mov	r0, #2
 9249 50a4 1C101FE5 		ldr	r1, .L1018+112
2243:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9250              		.loc 1 2243 0
 9251 50a8 2850C7E5 		strb	r5, [r7, #40]
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9252              		.loc 1 2244 0
 9253 50ac 2930C7E5 		strb	r3, [r7, #41]
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9254              		.loc 1 2245 0
 9255 50b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9256              	.LVL1096:
2246:../uvc.c      **** 			  break;
 9257              		.loc 1 2246 0
 9258 50b4 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9259              	.LVL1097:
 9260              	.L786:
2452:../uvc.c      **** }
 9261              		.loc 1 2452 0
 9262 50b8 2A10D7E5 		ldrb	r1, [r7, #42]	@ zero_extendqisi2
 9263 50bc FF30A0E3 		mov	r3, #255
 9264 50c0 08208DE5 		str	r2, [sp, #8]
 9265 50c4 04108DE5 		str	r1, [sp, #4]
 9266 50c8 10108DE5 		str	r1, [sp, #16]
 9267 50cc 00308DE5 		str	r3, [sp]
 9268 50d0 0C308DE5 		str	r3, [sp, #12]
 9269 50d4 14508DE5 		str	r5, [sp, #20]
 9270 50d8 0420A0E1 		mov	r2, r4
 9271              	.LVL1098:
 9272 50dc 0400A0E3 		mov	r0, #4
 9273 50e0 88101FE5 		ldr	r1, .L1018+64
 9274 50e4 FEFFFFEB 		bl	CyU3PDebugPrint
 9275              	.LVL1099:
 9276 50e8 44309DE5 		ldr	r3, [sp, #68]
 9277 50ec 0CFCFFEA 		b	.L642
 9278              	.LVL1100:
 9279              	.L805:
 9280              	.LBE259:
 9281              	.LBE319:
 9282              	.LBE369:
 9283              	.LBE404:
 9284              	.LBB405:
 9285              	.LBB231:
4202:../uvc.c      ****     		break;
 9286              		.loc 1 4202 0
 9287 50f0 1A00A0E3 		mov	r0, #26
 9288 50f4 FEFFFFEB 		bl	ControlHandle
 9289              	.LVL1101:
 9290 50f8 44309DE5 		ldr	r3, [sp, #68]
 9291 50fc 08FCFFEA 		b	.L642
 9292              	.L801:
 9293              	.LVL1102:
4191:../uvc.c      ****      		break;
 9294              		.loc 1 4191 0
 9295 5100 1800A0E3 		mov	r0, #24
 9296 5104 FEFFFFEB 		bl	ControlHandle
 9297              	.LVL1103:
 9298 5108 44309DE5 		ldr	r3, [sp, #68]
 9299 510c 04FCFFEA 		b	.L642
 9300              	.L793:
 9301              	.LVL1104:
4179:../uvc.c      ****      		break;
 9302              		.loc 1 4179 0
 9303 5110 1500A0E3 		mov	r0, #21
 9304 5114 FEFFFFEB 		bl	ControlHandle
 9305              	.LVL1105:
 9306 5118 44309DE5 		ldr	r3, [sp, #68]
 9307 511c 00FCFFEA 		b	.L642
 9308              	.L791:
 9309              	.LVL1106:
4212:../uvc.c      ****     		break;
 9310              		.loc 1 4212 0
 9311 5120 1C00A0E3 		mov	r0, #28
 9312 5124 FEFFFFEB 		bl	ControlHandle
 9313              	.LVL1107:
 9314 5128 44309DE5 		ldr	r3, [sp, #68]
 9315 512c FCFBFFEA 		b	.L642
 9316              	.L808:
4245:../uvc.c      **** 			CyU3PDebugPrint (4, "The ctrlspd command 0x%x 0x%x\r\n", wValue, bRequest);
 9317              		.loc 1 4245 0
 9318 5130 2800A0E3 		mov	r0, #40
 9319 5134 FEFFFFEB 		bl	ControlHandle
 9320              	.LVL1108:
4246:../uvc.c      ****     		break;
 9321              		.loc 1 4246 0
 9322 5138 D4301FE5 		ldr	r3, .L1018+76
 9323 513c B020D4E1 		ldrh	r2, [r4]
 9324 5140 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9325 5144 0400A0E3 		mov	r0, #4
 9326 5148 EC101FE5 		ldr	r1, .L1018+68
 9327 514c FEFFFFEB 		bl	CyU3PDebugPrint
 9328              	.LVL1109:
 9329 5150 44309DE5 		ldr	r3, [sp, #68]
 9330 5154 F2FBFFEA 		b	.L642
 9331              	.L814:
 9332              	.LVL1110:
4236:../uvc.c      ****     		break;
 9333              		.loc 1 4236 0
 9334 5158 2600A0E3 		mov	r0, #38
 9335 515c FEFFFFEB 		bl	ControlHandle
 9336              	.LVL1111:
 9337 5160 44309DE5 		ldr	r3, [sp, #68]
 9338 5164 EEFBFFEA 		b	.L642
 9339              	.L810:
 9340              	.LVL1112:
4228:../uvc.c      ****     		break;
 9341              		.loc 1 4228 0
 9342 5168 2400A0E3 		mov	r0, #36
 9343 516c FEFFFFEB 		bl	ControlHandle
 9344              	.LVL1113:
 9345 5170 44309DE5 		ldr	r3, [sp, #68]
 9346 5174 EAFBFFEA 		b	.L642
 9347              	.L795:
 9348              	.LVL1114:
4167:../uvc.c      ****      		break;
 9349              		.loc 1 4167 0
 9350 5178 1200A0E3 		mov	r0, #18
 9351 517c FEFFFFEB 		bl	ControlHandle
 9352              	.LVL1115:
 9353 5180 44309DE5 		ldr	r3, [sp, #68]
 9354 5184 E6FBFFEA 		b	.L642
 9355              	.L821:
4270:../uvc.c      **** 			CyU3PDebugPrint (4, "The gamma command 0x%x 0x%x\r\n", wValue, bRequest);
 9356              		.loc 1 4270 0
 9357 5188 2E00A0E3 		mov	r0, #46
 9358 518c FEFFFFEB 		bl	ControlHandle
 9359              	.LVL1116:
4271:../uvc.c      ****     		break;
 9360              		.loc 1 4271 0
 9361 5190 2C311FE5 		ldr	r3, .L1018+76
 9362 5194 B020D4E1 		ldrh	r2, [r4]
 9363 5198 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 9364 519c 0400A0E3 		mov	r0, #4
 9365 51a0 40111FE5 		ldr	r1, .L1018+72
 9366 51a4 FEFFFFEB 		bl	CyU3PDebugPrint
 9367              	.LVL1117:
 9368 51a8 44309DE5 		ldr	r3, [sp, #68]
 9369 51ac DCFBFFEA 		b	.L642
 9370              	.L817:
 9371              	.LVL1118:
 9372              	.LBB182:
 9373              	.LBB183:
1359:../uvc.c      ****     /*
 9374              		.loc 1 1359 0
 9375 51b0 4CC11FE5 		ldr	ip, .L1018+76
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9376              		.loc 1 1341 0
 9377 51b4 5837DAE5 		ldrb	r3, [r10, #1880]	@ zero_extendqisi2
1359:../uvc.c      ****     /*
 9378              		.loc 1 1359 0
 9379 51b8 0040DCE5 		ldrb	r4, [ip]	@ zero_extendqisi2
 9380 51bc 24C08DE5 		str	ip, [sp, #36]
 9381 51c0 2C408DE5 		str	r4, [sp, #44]
1367:../uvc.c      **** 		 {
 9382              		.loc 1 1367 0
 9383 51c4 2CE09DE5 		ldr	lr, [sp, #44]
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9384              		.loc 1 1342 0
 9385 51c8 5947DAE5 		ldrb	r4, [r10, #1881]	@ zero_extendqisi2
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9386              		.loc 1 1343 0
 9387 51cc 6757DAE5 		ldrb	r5, [r10, #1895]	@ zero_extendqisi2
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9388              		.loc 1 1344 0
 9389 51d0 5AC7DAE5 		ldrb	ip, [r10, #1882]	@ zero_extendqisi2
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9390              		.loc 1 1341 0
 9391 51d4 FF3003E2 		and	r3, r3, #255
1367:../uvc.c      **** 		 {
 9392              		.loc 1 1367 0
 9393 51d8 83005EE3 		cmp	lr, #131
1341:../uvc.c      ****         RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2;//ExUCtrlParArry[locCtrlID][1];
 9394              		.loc 1 1341 0
 9395 51dc 30308DE5 		str	r3, [sp, #48]
 9396              	.LVL1119:
1342:../uvc.c      ****         devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;//ExUCtrlParArry[locCtrlID][15];
 9397              		.loc 1 1342 0
 9398 51e0 FF4004E2 		and	r4, r4, #255
 9399              	.LVL1120:
1343:../uvc.c      ****         Len = pEXTSenCtrl[CtrlID - 0x10]->UVCLn;//ExUCtrlParArry[locCtrlID][2];
 9400              		.loc 1 1343 0
 9401 51e4 FF5005E2 		and	r5, r5, #255
 9402              	.LVL1121:
1344:../uvc.c      ****     	//CyU3PDebugPrint (4, "The CT/EX control ctrlID: 0x%x Reg1: 0x%x Reg1: 0x%x devADD: 0x%x Len: 
 9403              		.loc 1 1344 0
 9404 51e8 FFC00CE2 		and	ip, ip, #255
 9405              	.LVL1122:
1367:../uvc.c      **** 		 {
 9406              		.loc 1 1367 0
 9407 51ec 8602000A 		beq	.L879
 9408 51f0 EF00009A 		bls	.L997
 9409 51f4 2C409DE5 		ldr	r4, [sp, #44]
 9410              	.LVL1123:
 9411 51f8 850054E3 		cmp	r4, #133
 9412 51fc 6700000A 		beq	.L884
 9413 5200 4302003A 		bcc	.L885
 9414 5204 860054E3 		cmp	r4, #134
 9415 5208 3302000A 		beq	.L886
 9416 520c 870054E3 		cmp	r4, #135
 9417 5210 2802001A 		bne	.L878
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9418              		.loc 1 1756 0
 9419 5214 02005CE3 		cmp	ip, #2
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 9420              		.loc 1 1757 0
 9421 5218 6327DA05 		ldreqb	r2, [r10, #1891]	@ zero_extendqisi2
1758:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 9422              		.loc 1 1758 0
 9423 521c 6437DA05 		ldreqb	r3, [r10, #1892]	@ zero_extendqisi2
1756:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVLo;//ExUCtrlParArry[locCtrlID][11];
 9424              		.loc 1 1756 0
 9425 5220 FD02000A 		beq	.L968
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9426              		.loc 1 1762 0
 9427 5224 63E7DAE5 		ldrb	lr, [r10, #1891]	@ zero_extendqisi2
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9428              		.loc 1 1764 0
 9429 5228 6427DAE5 		ldrb	r2, [r10, #1892]	@ zero_extendqisi2
 9430 522c EA0200EA 		b	.L966
 9431              	.LVL1124:
 9432              	.L982:
 9433 5230 0250A0E1 		mov	r5, r2
 9434              	.LBE183:
 9435              	.LBE182:
 9436              	.LBE231:
 9437              	.LBE405:
4816:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 9438              		.loc 1 4816 0
 9439 5234 0C00A0E1 		mov	r0, ip
 9440              	.LVL1125:
 9441 5238 D0111FE5 		ldr	r1, .L1018+80
 9442 523c FEFFFFEB 		bl	CyU3PDebugPrint
 9443              	.LVL1126:
4817:../uvc.c      **** 					}
 9444              		.loc 1 4817 0
 9445 5240 0500A0E1 		mov	r0, r5
 9446 5244 FEFFFFEB 		bl	CyFxAppErrorHandler
 9447              	.LVL1127:
 9448              	.L671:
 9449              	.LBB406:
 9450              	.LBB389:
 9451              	.LBB382:
 9452              	.LBB378:
1743:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9453              		.loc 1 1743 0
 9454 5248 2925DAE5 		ldrb	r2, [r10, #1321]	@ zero_extendqisi2
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9455              		.loc 1 1749 0
 9456 524c C4111FE5 		ldr	r1, .L1018+112
1744:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9457              		.loc 1 1744 0
 9458 5250 0030A0E3 		mov	r3, #0
 9459              	.LVL1128:
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 9460              		.loc 1 1749 0
 9461 5254 0100A0E3 		mov	r0, #1
1743:../uvc.c      **** 		 		 glEp0Buffer[1] = 0;//pPUCSenCtrl[CtrlID]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 9462              		.loc 1 1743 0
 9463 5258 2820C7E5 		strb	r2, [r7, #40]
1744:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 9464              		.loc 1 1744 0
 9465 525c 2930C7E5 		strb	r3, [r7, #41]
1745:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 9466              		.loc 1 1745 0
 9467 5260 2A30C7E5 		strb	r3, [r7, #42]
1746:../uvc.c      **** 		 	 }
 9468              		.loc 1 1746 0
 9469 5264 2B30C7E5 		strb	r3, [r7, #43]
 9470              	.LVL1129:
 9471              	.L949:
1711:../uvc.c      **** 				  }else{
 9472              		.loc 1 1711 0
 9473 5268 0050A0E3 		mov	r5, #0
1708:../uvc.c      **** 				  if(Len == 2){
 9474              		.loc 1 1708 0
 9475 526c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9476              	.LVL1130:
1711:../uvc.c      **** 				  }else{
 9477              		.loc 1 1711 0
 9478 5270 05C0A0E1 		mov	ip, r5
1710:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9479              		.loc 1 1710 0
 9480 5274 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9481              	.LVL1131:
1711:../uvc.c      **** 				  }else{
 9482              		.loc 1 1711 0
 9483 5278 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 9484              	.LVL1132:
 9485 527c A5FEFFEA 		b	.L673
 9486              	.LVL1133:
 9487              	.L667:
1660:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9488              		.loc 1 1660 0
 9489 5280 020053E3 		cmp	r3, #2
1661:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 9490              		.loc 1 1661 0
 9491 5284 23C5DAE5 		ldrb	ip, [r10, #1315]	@ zero_extendqisi2
1672:../uvc.c      **** 		 	 if(Len == 2){
 9492              		.loc 1 1672 0
 9493 5288 0300A0E1 		mov	r0, r3
1662:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9494              		.loc 1 1662 0
 9495 528c 2425DAE5 		ldrb	r2, [r10, #1316]	@ zero_extendqisi2
1660:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 9496              		.loc 1 1660 0
 9497 5290 E0FBFF1A 		bne	.L948
 9498              	.LVL1134:
 9499              	.L947:
1708:../uvc.c      **** 				  if(Len == 2){
 9500              		.loc 1 1708 0
 9501 5294 0C121FE5 		ldr	r1, .L1018+112
1697:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9502              		.loc 1 1697 0
 9503 5298 28C0C7E5 		strb	ip, [r7, #40]
1698:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 9504              		.loc 1 1698 0
 9505 529c 2920C7E5 		strb	r2, [r7, #41]
 9506 52a0 F0FFFFEA 		b	.L949
 9507              	.LVL1135:
 9508              	.L773:
 9509              	.LBE378:
 9510              	.LBE382:
 9511              	.LBE389:
 9512              	.LBE406:
 9513              	.LBB407:
 9514              	.LBB370:
 9515              	.LBB320:
 9516              	.LBB296:
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9517              		.loc 1 2295 0
 9518 52a4 7936DAE5 		ldrb	r3, [r10, #1657]	@ zero_extendqisi2
 9519              	.LVL1136:
 9520              	.L970:
 9521              	.LBE296:
 9522              	.LBE320:
 9523              	.LBB321:
 9524              	.LBB260:
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9525              		.loc 1 2296 0
 9526 52a8 0100A0E3 		mov	r0, #1
 9527 52ac 24121FE5 		ldr	r1, .L1018+112
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9528              		.loc 1 2295 0
 9529 52b0 2830C7E5 		strb	r3, [r7, #40]
2298:../uvc.c      **** 			  break;
 9530              		.loc 1 2298 0
 9531 52b4 0150A0E3 		mov	r5, #1
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9532              		.loc 1 2296 0
 9533 52b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9534              	.LVL1137:
2297:../uvc.c      **** 			  Len = 1;
 9535              		.loc 1 2297 0
 9536 52bc 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 9537              	.LVL1138:
 9538 52c0 7CFFFFEA 		b	.L786
 9539              	.LVL1139:
 9540              	.L723:
 9541              	.LBE260:
 9542              	.LBE321:
 9543              	.LBB322:
 9544              	.LBB241:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9545              		.loc 1 2268 0
 9546 52c4 1316DAE5 		ldrb	r1, [r10, #1555]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9547              		.loc 1 2269 0
 9548 52c8 1426DAE5 		ldrb	r2, [r10, #1556]	@ zero_extendqisi2
 9549 52cc 88FDFFEA 		b	.L957
 9550              	.LVL1140:
 9551              	.L756:
 9552              	.LBE241:
 9553              	.LBE322:
 9554              	.LBB323:
 9555              	.LBB304:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9556              		.loc 1 2268 0
 9557 52d0 40221FE5 		ldr	r2, .L1018+120
 9558 52d4 5B16D2E5 		ldrb	r1, [r2, #1627]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9559              		.loc 1 2269 0
 9560 52d8 5C26D2E5 		ldrb	r2, [r2, #1628]	@ zero_extendqisi2
 9561 52dc E1FDFFEA 		b	.L955
 9562              	.LVL1141:
 9563              	.L784:
 9564              	.LBE304:
 9565              	.LBE323:
 9566              	.LBB324:
 9567              	.LBB261:
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9568              		.loc 1 2295 0
 9569 52e0 9136DAE5 		ldrb	r3, [r10, #1681]	@ zero_extendqisi2
 9570 52e4 EFFFFFEA 		b	.L970
 9571              	.LVL1142:
 9572              	.L701:
 9573              	.LBE261:
 9574              	.LBE324:
 9575              	.LBB325:
 9576              	.LBB270:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9577              		.loc 1 2268 0
 9578 52e8 58E21FE5 		ldr	lr, .L1018+120
 9579 52ec B315DEE5 		ldrb	r1, [lr, #1459]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9580              		.loc 1 2269 0
 9581 52f0 B425DEE5 		ldrb	r2, [lr, #1460]	@ zero_extendqisi2
 9582 52f4 7EFDFFEA 		b	.L957
 9583              	.LVL1143:
 9584              	.L780:
 9585              	.LBE270:
 9586              	.LBE325:
 9587              	.LBB326:
 9588              	.LBB262:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9589              		.loc 1 2268 0
 9590 52f8 68E21FE5 		ldr	lr, .L1018+120
 9591 52fc 8B16DEE5 		ldrb	r1, [lr, #1675]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9592              		.loc 1 2269 0
 9593 5300 8C26DEE5 		ldrb	r2, [lr, #1676]	@ zero_extendqisi2
 9594 5304 7AFDFFEA 		b	.L957
 9595              	.LVL1144:
 9596              	.L745:
 9597              	.LBE262:
 9598              	.LBE326:
 9599              	.LBB327:
 9600              	.LBB288:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9601              		.loc 1 2268 0
 9602 5308 78E21FE5 		ldr	lr, .L1018+120
 9603 530c 4316DEE5 		ldrb	r1, [lr, #1603]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9604              		.loc 1 2269 0
 9605 5310 4426DEE5 		ldrb	r2, [lr, #1604]	@ zero_extendqisi2
 9606 5314 76FDFFEA 		b	.L957
 9607              	.LVL1145:
 9608              	.L712:
 9609              	.LBE288:
 9610              	.LBE327:
 9611              	.LBB328:
 9612              	.LBB278:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9613              		.loc 1 2268 0
 9614 5318 88E21FE5 		ldr	lr, .L1018+120
 9615 531c E315DEE5 		ldrb	r1, [lr, #1507]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9616              		.loc 1 2269 0
 9617 5320 E425DEE5 		ldrb	r2, [lr, #1508]	@ zero_extendqisi2
 9618 5324 72FDFFEA 		b	.L957
 9619              	.LVL1146:
 9620              	.L769:
 9621              	.LBE278:
 9622              	.LBE328:
 9623              	.LBB329:
 9624              	.LBB297:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9625              		.loc 1 2268 0
 9626 5328 7316DAE5 		ldrb	r1, [r10, #1651]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9627              		.loc 1 2269 0
 9628 532c 7426DAE5 		ldrb	r2, [r10, #1652]	@ zero_extendqisi2
 9629 5330 6FFDFFEA 		b	.L957
 9630              	.LVL1147:
 9631              	.L734:
 9632              	.LBE297:
 9633              	.LBE329:
 9634              	.LBB330:
 9635              	.LBB249:
2268:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 9636              		.loc 1 2268 0
 9637 5334 A4E21FE5 		ldr	lr, .L1018+120
 9638 5338 2B16DEE5 		ldrb	r1, [lr, #1579]	@ zero_extendqisi2
2269:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 9639              		.loc 1 2269 0
 9640 533c 2C26DEE5 		ldrb	r2, [lr, #1580]	@ zero_extendqisi2
 9641 5340 6BFDFFEA 		b	.L957
 9642              	.LVL1148:
 9643              	.L749:
 9644              	.LBE249:
 9645              	.LBE330:
 9646              	.LBB331:
 9647              	.LBB289:
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9648              		.loc 1 2295 0
 9649 5344 4936DAE5 		ldrb	r3, [r10, #1609]	@ zero_extendqisi2
 9650 5348 D6FFFFEA 		b	.L970
 9651              	.LVL1149:
 9652              	.L727:
 9653              	.LBE289:
 9654              	.LBE331:
 9655              	.LBB332:
 9656              	.LBB242:
 9657 534c 1936DAE5 		ldrb	r3, [r10, #1561]	@ zero_extendqisi2
 9658 5350 D4FFFFEA 		b	.L970
 9659              	.LVL1150:
 9660              	.L760:
 9661              	.LBE242:
 9662              	.LBE332:
 9663              	.LBB333:
 9664              	.LBB305:
 9665 5354 C4E21FE5 		ldr	lr, .L1018+120
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9666              		.loc 1 2296 0
 9667 5358 0100A0E3 		mov	r0, #1
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9668              		.loc 1 2295 0
 9669 535c 6136DEE5 		ldrb	r3, [lr, #1633]	@ zero_extendqisi2
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9670              		.loc 1 2296 0
 9671 5360 D8121FE5 		ldr	r1, .L1018+112
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9672              		.loc 1 2295 0
 9673 5364 2830C7E5 		strb	r3, [r7, #40]
2296:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9674              		.loc 1 2296 0
 9675 5368 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9676              	.LVL1151:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9677              		.loc 1 2233 0
 9678 536c FF20A0E3 		mov	r2, #255
 9679 5370 0230A0E1 		mov	r3, r2
2297:../uvc.c      **** 			  Len = 1;
 9680              		.loc 1 2297 0
 9681 5374 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9682              	.LVL1152:
2298:../uvc.c      **** 			  break;
 9683              		.loc 1 2298 0
 9684 5378 0150A0E3 		mov	r5, #1
 9685 537c C4FDFFEA 		b	.L762
 9686              	.LVL1153:
 9687              	.L738:
 9688              	.LBE305:
 9689              	.LBE333:
 9690              	.LBB334:
 9691              	.LBB250:
2295:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 9692              		.loc 1 2295 0
 9693 5380 F0C21FE5 		ldr	ip, .L1018+120
 9694 5384 3136DCE5 		ldrb	r3, [ip, #1585]	@ zero_extendqisi2
 9695 5388 C6FFFFEA 		b	.L970
 9696              	.LVL1154:
 9697              	.L705:
 9698              	.LBE250:
 9699              	.LBE334:
 9700              	.LBB335:
 9701              	.LBB271:
 9702 538c B935DAE5 		ldrb	r3, [r10, #1465]	@ zero_extendqisi2
 9703 5390 C4FFFFEA 		b	.L970
 9704              	.LVL1155:
 9705              	.L716:
 9706              	.LBE271:
 9707              	.LBE335:
 9708              	.LBB336:
 9709              	.LBB279:
 9710 5394 04C31FE5 		ldr	ip, .L1018+120
 9711 5398 E935DCE5 		ldrb	r3, [ip, #1513]	@ zero_extendqisi2
 9712 539c C1FFFFEA 		b	.L970
 9713              	.LVL1156:
 9714              	.L884:
 9715              	.LBE279:
 9716              	.LBE336:
 9717              	.LBE370:
 9718              	.LBE407:
 9719              	.LBB408:
 9720              	.LBB232:
 9721              	.LBB194:
 9722              	.LBB184:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9723              		.loc 1 1372 0
 9724 53a0 0030A0E3 		mov	r3, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9725              		.loc 1 1373 0
 9726 53a4 0200A0E3 		mov	r0, #2
 9727 53a8 20131FE5 		ldr	r1, .L1018+112
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9728              		.loc 1 1371 0
 9729 53ac 28C0C7E5 		strb	ip, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9730              		.loc 1 1372 0
 9731 53b0 2930C7E5 		strb	r3, [r7, #41]
1374:../uvc.c      **** 			  break;
 9732              		.loc 1 1374 0
 9733 53b4 28308DE5 		str	r3, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9734              		.loc 1 1373 0
 9735 53b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9736              	.LVL1157:
1374:../uvc.c      **** 			  break;
 9737              		.loc 1 1374 0
 9738 53bc 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9739              	.LVL1158:
 9740 53c0 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9741              		.loc 1 1355 0
 9742 53c4 FF40A0E3 		mov	r4, #255
 9743              	.LVL1159:
 9744              	.L888:
2213:../uvc.c      **** }
 9745              		.loc 1 2213 0
 9746 53c8 28E09DE5 		ldr	lr, [sp, #40]
 9747 53cc 0C30A0E1 		mov	r3, ip
 9748 53d0 00E08DE5 		str	lr, [sp]
 9749 53d4 08408DE5 		str	r4, [sp, #8]
 9750 53d8 2C209DE5 		ldr	r2, [sp, #44]
 9751 53dc 6C131FE5 		ldr	r1, .L1018+88
 9752 53e0 04508DE5 		str	r5, [sp, #4]
 9753 53e4 0400A0E3 		mov	r0, #4
 9754 53e8 FEFFFFEB 		bl	CyU3PDebugPrint
 9755              	.LVL1160:
 9756              	.LBE184:
 9757              	.LBE194:
4261:../uvc.c      ****     		break;
 9758              		.loc 1 4261 0
 9759 53ec 24409DE5 		ldr	r4, [sp, #36]
 9760              	.LVL1161:
 9761 53f0 0400A0E3 		mov	r0, #4
 9762 53f4 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9763 53f8 8C131FE5 		ldr	r1, .L1018+84
 9764 53fc B020D8E1 		ldrh	r2, [r8]
 9765 5400 FEFFFFEB 		bl	CyU3PDebugPrint
 9766              	.LVL1162:
 9767 5404 44309DE5 		ldr	r3, [sp, #68]
 9768 5408 45FBFFEA 		b	.L642
 9769              	.LVL1163:
 9770              	.L830:
 9771              	.LBB195:
 9772              	.LBB172:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9773              		.loc 1 1372 0
 9774 540c 0030A0E3 		mov	r3, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9775              		.loc 1 1373 0
 9776 5410 0200A0E3 		mov	r0, #2
 9777 5414 8C131FE5 		ldr	r1, .L1018+112
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9778              		.loc 1 1371 0
 9779 5418 2850C7E5 		strb	r5, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9780              		.loc 1 1372 0
 9781 541c 2930C7E5 		strb	r3, [r7, #41]
1374:../uvc.c      **** 			  break;
 9782              		.loc 1 1374 0
 9783 5420 24308DE5 		str	r3, [sp, #36]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9784              		.loc 1 1373 0
 9785 5424 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9786              	.LVL1164:
1374:../uvc.c      **** 			  break;
 9787              		.loc 1 1374 0
 9788 5428 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 9789              	.LVL1165:
 9790 542c 0050A0E3 		mov	r5, #0
 9791              	.LVL1166:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9792              		.loc 1 1355 0
 9793 5430 FF40A0E3 		mov	r4, #255
 9794              	.LVL1167:
 9795              	.L834:
2213:../uvc.c      **** }
 9796              		.loc 1 2213 0
 9797 5434 24209DE5 		ldr	r2, [sp, #36]
 9798 5438 0530A0E1 		mov	r3, r5
 9799 543c 04108DE8 		stmia	sp, {r2, ip}
 9800 5440 D0131FE5 		ldr	r1, .L1018+88
 9801 5444 08408DE5 		str	r4, [sp, #8]
 9802 5448 28209DE5 		ldr	r2, [sp, #40]
 9803 544c 0400A0E3 		mov	r0, #4
 9804 5450 FEFFFFEB 		bl	CyU3PDebugPrint
 9805              	.LVL1168:
 9806 5454 44309DE5 		ldr	r3, [sp, #68]
 9807 5458 31FBFFEA 		b	.L642
 9808              	.LVL1169:
 9809              	.L857:
 9810              	.LBE172:
 9811              	.LBE195:
 9812              	.LBB196:
 9813              	.LBB158:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9814              		.loc 1 1372 0
 9815 545c 0030A0E3 		mov	r3, #0
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9816              		.loc 1 1373 0
 9817 5460 0200A0E3 		mov	r0, #2
 9818 5464 DC131FE5 		ldr	r1, .L1018+112
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 9819              		.loc 1 1371 0
 9820 5468 28C0C7E5 		strb	ip, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 9821              		.loc 1 1372 0
 9822 546c 2930C7E5 		strb	r3, [r7, #41]
1374:../uvc.c      **** 			  break;
 9823              		.loc 1 1374 0
 9824 5470 28308DE5 		str	r3, [sp, #40]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9825              		.loc 1 1373 0
 9826 5474 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9827              	.LVL1170:
1374:../uvc.c      **** 			  break;
 9828              		.loc 1 1374 0
 9829 5478 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9830              	.LVL1171:
 9831 547c 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9832              		.loc 1 1355 0
 9833 5480 FF40A0E3 		mov	r4, #255
 9834              	.LVL1172:
 9835              	.L861:
2213:../uvc.c      **** }
 9836              		.loc 1 2213 0
 9837 5484 28E09DE5 		ldr	lr, [sp, #40]
 9838 5488 0C30A0E1 		mov	r3, ip
 9839 548c 00E08DE5 		str	lr, [sp]
 9840 5490 08408DE5 		str	r4, [sp, #8]
 9841 5494 2C209DE5 		ldr	r2, [sp, #44]
 9842 5498 28141FE5 		ldr	r1, .L1018+88
 9843 549c 04508DE5 		str	r5, [sp, #4]
 9844 54a0 0400A0E3 		mov	r0, #4
 9845 54a4 FEFFFFEB 		bl	CyU3PDebugPrint
 9846              	.LVL1173:
 9847              	.LBE158:
 9848              	.LBE196:
4256:../uvc.c      ****    		break;
 9849              		.loc 1 4256 0
 9850 54a8 24409DE5 		ldr	r4, [sp, #36]
 9851              	.LVL1174:
 9852 54ac 0400A0E3 		mov	r0, #4
 9853 54b0 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 9854 54b4 40141FE5 		ldr	r1, .L1018+92
 9855 54b8 B020D8E1 		ldrh	r2, [r8]
 9856 54bc FEFFFFEB 		bl	CyU3PDebugPrint
 9857              	.LVL1175:
 9858 54c0 44309DE5 		ldr	r3, [sp, #68]
 9859 54c4 16FBFFEA 		b	.L642
 9860              	.LVL1176:
 9861              	.L852:
 9862              	.LBB197:
 9863              	.LBB159:
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9864              		.loc 1 1683 0
 9865 54c8 02005CE3 		cmp	ip, #2
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 9866              		.loc 1 1689 0
 9867 54cc 49E7DA15 		ldrneb	lr, [r10, #1865]	@ zero_extendqisi2
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 9868              		.loc 1 1691 0
 9869 54d0 4A27DA15 		ldrneb	r2, [r10, #1866]	@ zero_extendqisi2
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 9870              		.loc 1 1683 0
 9871 54d4 8EFCFF1A 		bne	.L963
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9872              		.loc 1 1684 0
 9873 54d8 4927DAE5 		ldrb	r2, [r10, #1865]	@ zero_extendqisi2
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 9874              		.loc 1 1685 0
 9875 54dc 4A37DAE5 		ldrb	r3, [r10, #1866]	@ zero_extendqisi2
1708:../uvc.c      **** 				  if(Len == 2){
 9876              		.loc 1 1708 0
 9877 54e0 0200A0E3 		mov	r0, #2
 9878              	.LVL1177:
 9879              	.L962:
 9880 54e4 5C141FE5 		ldr	r1, .L1018+112
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 9881              		.loc 1 1684 0
 9882 54e8 2820C7E5 		strb	r2, [r7, #40]
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 9883              		.loc 1 1685 0
 9884 54ec 2930C7E5 		strb	r3, [r7, #41]
 9885              	.L964:
1711:../uvc.c      **** 				  }else{
 9886              		.loc 1 1711 0
 9887 54f0 0040A0E3 		mov	r4, #0
 9888 54f4 28408DE5 		str	r4, [sp, #40]
1708:../uvc.c      **** 				  if(Len == 2){
 9889              		.loc 1 1708 0
 9890 54f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9891              	.LVL1178:
1711:../uvc.c      **** 				  }else{
 9892              		.loc 1 1711 0
 9893 54fc 04C0A0E1 		mov	ip, r4
1710:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 9894              		.loc 1 1710 0
 9895 5500 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 9896              	.LVL1179:
1711:../uvc.c      **** 				  }else{
 9897              		.loc 1 1711 0
 9898 5504 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 9899              	.LVL1180:
 9900 5508 DDFFFFEA 		b	.L861
 9901              	.LVL1181:
 9902              	.L995:
 9903              	.LBE159:
 9904              	.LBE197:
 9905              	.LBB198:
 9906              	.LBB173:
1367:../uvc.c      **** 		 {
 9907              		.loc 1 1367 0
 9908 550c 81005CE3 		cmp	ip, #129
 9909 5510 1002000A 		beq	.L827
 9910 5514 FC01008A 		bhi	.L828
 9911 5518 01005CE3 		cmp	ip, #1
 9912 551c CD01001A 		bne	.L824
1791:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9913              		.loc 1 1791 0
 9914 5520 2000A0E3 		mov	r0, #32
 9915 5524 9C141FE5 		ldr	r1, .L1018+112
 9916 5528 42208DE2 		add	r2, sp, #66
 9917 552c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9918              	.LVL1182:
1793:../uvc.c      **** 			   {
 9919              		.loc 1 1793 0
 9920 5530 000050E3 		cmp	r0, #0
 9921 5534 34008DE5 		str	r0, [sp, #52]
 9922 5538 A302001A 		bne	.L843
1795:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9923              		.loc 1 1795 0
 9924 553c 020055E3 		cmp	r5, #2
 9925 5540 2B03000A 		beq	.L998
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 9926              		.loc 1 1803 0
 9927 5544 2CC09DE5 		ldr	ip, [sp, #44]
 9928 5548 08508DE5 		str	r5, [sp, #8]
 9929 554c 00408DE5 		str	r4, [sp]
 9930 5550 04C08DE5 		str	ip, [sp, #4]
1800:../uvc.c      **** 				 }
 9931              		.loc 1 1800 0
 9932 5554 2AC0DBE5 		ldrb	ip, [fp, #42]	@ zero_extendqisi2
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 9933              		.loc 1 1803 0
 9934 5558 0400A0E3 		mov	r0, #4
 9935              	.LVL1183:
 9936 555c E4141FE5 		ldr	r1, .L1018+96
 9937 5560 1620A0E3 		mov	r2, #22
 9938 5564 30309DE5 		ldr	r3, [sp, #48]
 9939 5568 38508DE5 		str	r5, [sp, #56]
1800:../uvc.c      **** 				 }
 9940              		.loc 1 1800 0
 9941 556c 24C08DE5 		str	ip, [sp, #36]
1799:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 9942              		.loc 1 1799 0
 9943 5570 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 9944              	.LVL1184:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 9945              		.loc 1 1803 0
 9946 5574 FEFFFFEB 		bl	CyU3PDebugPrint
 9947              	.LVL1185:
1992:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 9948              		.loc 1 1992 0
 9949 5578 38C09DE5 		ldr	ip, [sp, #56]
 9950 557c 04005CE3 		cmp	ip, #4
 9951 5580 4103000A 		beq	.L999
 9952              	.LVL1186:
 9953              	.L848:
2009:../uvc.c      **** 				 	 			 break;
 9954              		.loc 1 2009 0
 9955 5584 3E27DAE5 		ldrb	r2, [r10, #1854]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9956              		.loc 1 2008 0
 9957 5588 38C09DE5 		ldr	ip, [sp, #56]
2009:../uvc.c      **** 				 	 			 break;
 9958              		.loc 1 2009 0
 9959 558c 3D37DAE5 		ldrb	r3, [r10, #1853]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 9960              		.loc 1 2008 0
 9961 5590 0400A0E3 		mov	r0, #4
 9962 5594 0C108DE8 		stmia	sp, {r2, r3, ip}
 9963 5598 1C151FE5 		ldr	r1, .L1018+100
 9964 559c 0520A0E1 		mov	r2, r5
 9965 55a0 24309DE5 		ldr	r3, [sp, #36]
 9966 55a4 FEFFFFEB 		bl	CyU3PDebugPrint
 9967              	.LVL1187:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9968              		.loc 1 1355 0
 9969 55a8 FF40A0E3 		mov	r4, #255
 9970 55ac 04C0A0E1 		mov	ip, r4
 9971 55b0 9FFFFFEA 		b	.L834
 9972              	.LVL1188:
 9973              	.L997:
 9974              	.LBE173:
 9975              	.LBE198:
 9976              	.LBB199:
 9977              	.LBB185:
1367:../uvc.c      **** 		 {
 9978              		.loc 1 1367 0
 9979 55b4 81005EE3 		cmp	lr, #129
 9980 55b8 1C02000A 		beq	.L881
 9981 55bc FF01008A 		bhi	.L882
 9982 55c0 01005EE3 		cmp	lr, #1
 9983 55c4 3B01001A 		bne	.L878
1791:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9984              		.loc 1 1791 0
 9985 55c8 2000A0E3 		mov	r0, #32
 9986 55cc 44151FE5 		ldr	r1, .L1018+112
 9987 55d0 42208DE2 		add	r2, sp, #66
 9988 55d4 1CC08DE5 		str	ip, [sp, #28]
 9989 55d8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9990              	.LVL1189:
1793:../uvc.c      **** 			   {
 9991              		.loc 1 1793 0
 9992 55dc 1CC09DE5 		ldr	ip, [sp, #28]
 9993 55e0 000050E3 		cmp	r0, #0
 9994 55e4 34008DE5 		str	r0, [sp, #52]
 9995 55e8 9102001A 		bne	.L897
1795:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 9996              		.loc 1 1795 0
 9997 55ec 02005CE3 		cmp	ip, #2
 9998 55f0 D702000A 		beq	.L1000
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 9999              		.loc 1 1803 0
 10000 55f4 30108DE8 		stmia	sp, {r4, r5, ip}
1800:../uvc.c      **** 				 }
 10001              		.loc 1 1800 0
 10002 55f8 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10003              		.loc 1 1803 0
 10004 55fc 38C08DE5 		str	ip, [sp, #56]
1799:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10005              		.loc 1 1799 0
 10006 5600 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 10007              	.LVL1190:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10008              		.loc 1 1803 0
 10009 5604 8C151FE5 		ldr	r1, .L1018+96
 10010 5608 0400A0E3 		mov	r0, #4
 10011              	.LVL1191:
 10012 560c 2B20A0E3 		mov	r2, #43
 10013 5610 30309DE5 		ldr	r3, [sp, #48]
 10014 5614 1CC08DE5 		str	ip, [sp, #28]
1800:../uvc.c      **** 				 }
 10015              		.loc 1 1800 0
 10016 5618 28E08DE5 		str	lr, [sp, #40]
 10017              	.LVL1192:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10018              		.loc 1 1803 0
 10019 561c FEFFFFEB 		bl	CyU3PDebugPrint
 10020              	.LVL1193:
1992:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10021              		.loc 1 1992 0
 10022 5620 38109DE5 		ldr	r1, [sp, #56]
 10023 5624 1CC09DE5 		ldr	ip, [sp, #28]
 10024 5628 040051E3 		cmp	r1, #4
 10025 562c AC03000A 		beq	.L1001
 10026              	.LVL1194:
 10027              	.L902:
2009:../uvc.c      **** 				 	 			 break;
 10028              		.loc 1 2009 0
 10029 5630 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10030              		.loc 1 2008 0
 10031 5634 38409DE5 		ldr	r4, [sp, #56]
2009:../uvc.c      **** 				 	 			 break;
 10032              		.loc 1 2009 0
 10033 5638 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10034              		.loc 1 2008 0
 10035 563c 0400A0E3 		mov	r0, #4
 10036 5640 1C008DE8 		stmia	sp, {r2, r3, r4}
 10037 5644 C8151FE5 		ldr	r1, .L1018+100
 10038 5648 0C20A0E1 		mov	r2, ip
 10039 564c 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10040              		.loc 1 1355 0
 10041 5650 FF40A0E3 		mov	r4, #255
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10042              		.loc 1 2008 0
 10043 5654 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10044              		.loc 1 1355 0
 10045 5658 0450A0E1 		mov	r5, r4
 10046              	.LVL1195:
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10047              		.loc 1 2008 0
 10048 565c FEFFFFEB 		bl	CyU3PDebugPrint
 10049              	.LVL1196:
 10050 5660 1CC09DE5 		ldr	ip, [sp, #28]
 10051 5664 57FFFFEA 		b	.L888
 10052              	.LVL1197:
 10053              	.L987:
 10054              	.LBE185:
 10055              	.LBE199:
 10056              	.LBB200:
 10057              	.LBB160:
1367:../uvc.c      **** 		 {
 10058              		.loc 1 1367 0
 10059 5668 81005EE3 		cmp	lr, #129
 10060 566c 1202000A 		beq	.L854
 10061 5670 0902008A 		bhi	.L855
 10062 5674 01005EE3 		cmp	lr, #1
 10063 5678 3601001A 		bne	.L851
1791:../uvc.c      **** 				  glEp0Buffer, &readCount);
 10064              		.loc 1 1791 0
 10065 567c 2000A0E3 		mov	r0, #32
 10066 5680 F8151FE5 		ldr	r1, .L1018+112
 10067 5684 42208DE2 		add	r2, sp, #66
 10068 5688 1CC08DE5 		str	ip, [sp, #28]
 10069 568c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 10070              	.LVL1198:
1793:../uvc.c      **** 			   {
 10071              		.loc 1 1793 0
 10072 5690 1CC09DE5 		ldr	ip, [sp, #28]
 10073 5694 000050E3 		cmp	r0, #0
 10074 5698 34008DE5 		str	r0, [sp, #52]
 10075 569c 5B02001A 		bne	.L870
1795:../uvc.c      **** 					 Data0 = glEp0Buffer[0];
 10076              		.loc 1 1795 0
 10077 56a0 02005CE3 		cmp	ip, #2
 10078 56a4 8202000A 		beq	.L1002
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10079              		.loc 1 1803 0
 10080 56a8 30108DE8 		stmia	sp, {r4, r5, ip}
1800:../uvc.c      **** 				 }
 10081              		.loc 1 1800 0
 10082 56ac 2AE0DBE5 		ldrb	lr, [fp, #42]	@ zero_extendqisi2
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10083              		.loc 1 1803 0
 10084 56b0 38C08DE5 		str	ip, [sp, #56]
1799:../uvc.c      **** 					 Data1 = glEp0Buffer[2];
 10085              		.loc 1 1799 0
 10086 56b4 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 10087              	.LVL1199:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10088              		.loc 1 1803 0
 10089 56b8 40161FE5 		ldr	r1, .L1018+96
 10090 56bc 0400A0E3 		mov	r0, #4
 10091              	.LVL1200:
 10092 56c0 2A20A0E3 		mov	r2, #42
 10093 56c4 30309DE5 		ldr	r3, [sp, #48]
 10094 56c8 1CC08DE5 		str	ip, [sp, #28]
1800:../uvc.c      **** 				 }
 10095              		.loc 1 1800 0
 10096 56cc 28E08DE5 		str	lr, [sp, #40]
 10097              	.LVL1201:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 10098              		.loc 1 1803 0
 10099 56d0 FEFFFFEB 		bl	CyU3PDebugPrint
 10100              	.LVL1202:
1992:../uvc.c      **** 									 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);   //get mutex 4Btyes
 10101              		.loc 1 1992 0
 10102 56d4 38109DE5 		ldr	r1, [sp, #56]
 10103 56d8 1CC09DE5 		ldr	ip, [sp, #28]
 10104 56dc 040051E3 		cmp	r1, #4
 10105 56e0 5003000A 		beq	.L1003
 10106              	.LVL1203:
 10107              	.L875:
2009:../uvc.c      **** 				 	 			 break;
 10108              		.loc 1 2009 0
 10109 56e4 5227DAE5 		ldrb	r2, [r10, #1874]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10110              		.loc 1 2008 0
 10111 56e8 38409DE5 		ldr	r4, [sp, #56]
2009:../uvc.c      **** 				 	 			 break;
 10112              		.loc 1 2009 0
 10113 56ec 5137DAE5 		ldrb	r3, [r10, #1873]	@ zero_extendqisi2
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10114              		.loc 1 2008 0
 10115 56f0 0400A0E3 		mov	r0, #4
 10116 56f4 1C008DE8 		stmia	sp, {r2, r3, r4}
 10117 56f8 7C161FE5 		ldr	r1, .L1018+100
 10118 56fc 0C20A0E1 		mov	r2, ip
 10119 5700 28309DE5 		ldr	r3, [sp, #40]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10120              		.loc 1 1355 0
 10121 5704 FF40A0E3 		mov	r4, #255
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10122              		.loc 1 2008 0
 10123 5708 1CC08DE5 		str	ip, [sp, #28]
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10124              		.loc 1 1355 0
 10125 570c 0450A0E1 		mov	r5, r4
 10126              	.LVL1204:
2008:../uvc.c      **** 											 Data0, Data1, pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi, pEXTSenCtrl[CtrlID - 0x10]->UVCCur
 10127              		.loc 1 2008 0
 10128 5710 FEFFFFEB 		bl	CyU3PDebugPrint
 10129              	.LVL1205:
 10130 5714 1CC09DE5 		ldr	ip, [sp, #28]
 10131 5718 59FFFFEA 		b	.L861
 10132              	.LVL1206:
 10133              	.L663:
 10134              	.LBE160:
 10135              	.LBE200:
 10136              	.LBE232:
 10137              	.LBE408:
 10138              	.LBB409:
 10139              	.LBB390:
 10140              	.LBB383:
 10141              	.LBB379:
2210:../uvc.c      **** 			  break;
 10142              		.loc 1 2210 0
 10143 571c 0000A0E3 		mov	r0, #0
 10144 5720 0020A0E1 		mov	r2, r0
 10145 5724 0110A0E3 		mov	r1, #1
 10146 5728 FEFFFFEB 		bl	CyU3PUsbStall
 10147              	.LVL1207:
 10148 572c 0050A0E3 		mov	r5, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10149              		.loc 1 1355 0
 10150 5730 FF30A0E3 		mov	r3, #255
 10151 5734 0320A0E1 		mov	r2, r3
2210:../uvc.c      **** 			  break;
 10152              		.loc 1 2210 0
 10153 5738 05C0A0E1 		mov	ip, r5
 10154 573c 75FDFFEA 		b	.L673
 10155              	.LVL1208:
 10156              	.L666:
1521:../uvc.c      **** 							Data0 = pPUCSenCtrl[CtrlID]->UVCCurVLo; // CtrlParArry[CtrlID][13];
 10157              		.loc 1 1521 0
 10158 5740 A120D7E5 		ldrb	r2, [r7, #161]	@ zero_extendqisi2
 10159 5744 000052E3 		cmp	r2, #0
 10160 5748 4202000A 		beq	.L674
1522:../uvc.c      **** 						 }else{
 10161              		.loc 1 1522 0
 10162 574c 2DC5DAE5 		ldrb	ip, [r10, #1325]	@ zero_extendqisi2
 10163 5750 FFC00CE2 		and	ip, ip, #255
 10164              	.LVL1209:
 10165              	.L675:
1537:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10166              		.loc 1 1537 0
 10167 5754 0020A0E3 		mov	r2, #0
1639:../uvc.c      **** 
 10168              		.loc 1 1639 0
 10169 5758 0300A0E1 		mov	r0, r3
 10170 575c D4161FE5 		ldr	r1, .L1018+112
1536:../uvc.c      **** 						 glEp0Buffer[1] = 0;
 10171              		.loc 1 1536 0
 10172 5760 28C0C7E5 		strb	ip, [r7, #40]
1639:../uvc.c      **** 
 10173              		.loc 1 1639 0
 10174 5764 1CC08DE5 		str	ip, [sp, #28]
1537:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 10175              		.loc 1 1537 0
 10176 5768 2920C7E5 		strb	r2, [r7, #41]
 10177              	.LVL1210:
1639:../uvc.c      **** 
 10178              		.loc 1 1639 0
 10179 576c 20308DE5 		str	r3, [sp, #32]
 10180 5770 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10181              	.LVL1211:
1642:../uvc.c      **** //#endif
 10182              		.loc 1 1642 0
 10183 5774 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 10184 5778 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 10185 577c 20309DE5 		ldr	r3, [sp, #32]
 10186 5780 29E0D7E5 		ldrb	lr, [r7, #41]	@ zero_extendqisi2
 10187 5784 03008DE8 		stmia	sp, {r0, r1}
 10188 5788 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10189 578c 08308DE5 		str	r3, [sp, #8]
 10190 5790 0400A0E3 		mov	r0, #4
 10191 5794 0E30A0E1 		mov	r3, lr
 10192 5798 14171FE5 		ldr	r1, .L1018+108
 10193 579c FEFFFFEB 		bl	CyU3PDebugPrint
 10194              	.LVL1212:
 10195 57a0 1CC09DE5 		ldr	ip, [sp, #28]
 10196 57a4 0050A0E3 		mov	r5, #0
 10197 57a8 0C20A0E1 		mov	r2, ip
 10198 57ac FF30A0E3 		mov	r3, #255
 10199 57b0 58FDFFEA 		b	.L673
 10200              	.LVL1213:
 10201              	.L670:
1725:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10202              		.loc 1 1725 0
 10203 57b4 27C5DAE5 		ldrb	ip, [r10, #1319]	@ zero_extendqisi2
1726:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10204              		.loc 1 1726 0
 10205 57b8 2825DAE5 		ldrb	r2, [r10, #1320]	@ zero_extendqisi2
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10206              		.loc 1 1730 0
 10207 57bc 0300A0E1 		mov	r0, r3
1727:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10208              		.loc 1 1727 0
 10209 57c0 0030A0E3 		mov	r3, #0
 10210              	.LVL1214:
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10211              		.loc 1 1730 0
 10212 57c4 3C171FE5 		ldr	r1, .L1018+112
1725:../uvc.c      **** 		 		 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10213              		.loc 1 1725 0
 10214 57c8 28C0C7E5 		strb	ip, [r7, #40]
1726:../uvc.c      **** 		 		 glEp0Buffer[2] = 0;
 10215              		.loc 1 1726 0
 10216 57cc 2920C7E5 		strb	r2, [r7, #41]
1727:../uvc.c      **** 		 		 glEp0Buffer[3] = 0;
 10217              		.loc 1 1727 0
 10218 57d0 2A30C7E5 		strb	r3, [r7, #42]
1728:../uvc.c      **** 		 	 }
 10219              		.loc 1 1728 0
 10220 57d4 2B30C7E5 		strb	r3, [r7, #43]
 10221 57d8 A2FEFFEA 		b	.L949
 10222              	.LVL1215:
 10223              	.L669:
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10224              		.loc 1 1372 0
 10225 57dc 0020A0E3 		mov	r2, #0
1374:../uvc.c      **** 			  break;
 10226              		.loc 1 1374 0
 10227 57e0 0250A0E1 		mov	r5, r2
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10228              		.loc 1 1373 0
 10229 57e4 0200A0E3 		mov	r0, #2
 10230 57e8 60171FE5 		ldr	r1, .L1018+112
1371:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10231              		.loc 1 1371 0
 10232 57ec 2830C7E5 		strb	r3, [r7, #40]
1372:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10233              		.loc 1 1372 0
 10234 57f0 2920C7E5 		strb	r2, [r7, #41]
1373:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10235              		.loc 1 1373 0
 10236 57f4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10237              	.LVL1216:
1374:../uvc.c      **** 			  break;
 10238              		.loc 1 1374 0
 10239 57f8 05C0A0E1 		mov	ip, r5
 10240 57fc 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 10241              	.LVL1217:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10242              		.loc 1 1355 0
 10243 5800 FF30A0E3 		mov	r3, #255
 10244 5804 43FDFFEA 		b	.L673
 10245              	.LVL1218:
 10246              	.L664:
1696:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10247              		.loc 1 1696 0
 10248 5808 020053E3 		cmp	r3, #2
 10249 580c 1B02000A 		beq	.L1004
1701:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10250              		.loc 1 1701 0
 10251 5810 80271FE5 		ldr	r2, .L1018+120
1708:../uvc.c      **** 				  if(Len == 2){
 10252              		.loc 1 1708 0
 10253 5814 0300A0E1 		mov	r0, r3
1701:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10254              		.loc 1 1701 0
 10255 5818 25C5D2E5 		ldrb	ip, [r2, #1317]	@ zero_extendqisi2
1703:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10256              		.loc 1 1703 0
 10257 581c 2625D2E5 		ldrb	r2, [r2, #1318]	@ zero_extendqisi2
 10258 5820 7CFAFFEA 		b	.L948
 10259              	.LVL1219:
 10260              	.L720:
 10261              	.LBE379:
 10262              	.LBE383:
 10263              	.LBE390:
 10264              	.LBE409:
 10265              	.LBB410:
 10266              	.LBB371:
 10267              	.LBB337:
 10268              	.LBB243:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10269              		.loc 1 2277 0
 10270 5824 94E71FE5 		ldr	lr, .L1018+120
 10271 5828 1516DEE5 		ldrb	r1, [lr, #1557]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10272              		.loc 1 2278 0
 10273 582c 1626DEE5 		ldrb	r2, [lr, #1558]	@ zero_extendqisi2
 10274 5830 2FFCFFEA 		b	.L957
 10275              	.LVL1220:
 10276              	.L777:
 10277              	.LBE243:
 10278              	.LBE337:
 10279              	.LBB338:
 10280              	.LBB263:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10281              		.loc 1 2277 0
 10282 5834 A4271FE5 		ldr	r2, .L1018+120
 10283 5838 8D16D2E5 		ldrb	r1, [r2, #1677]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10284              		.loc 1 2278 0
 10285 583c 8E26D2E5 		ldrb	r2, [r2, #1678]	@ zero_extendqisi2
 10286 5840 2BFCFFEA 		b	.L957
 10287              	.LVL1221:
 10288              	.L753:
 10289              	.LBE263:
 10290              	.LBE338:
 10291              	.LBB339:
 10292              	.LBB306:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10293              		.loc 1 2277 0
 10294 5844 B4371FE5 		ldr	r3, .L1018+120
 10295 5848 5D16D3E5 		ldrb	r1, [r3, #1629]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10296              		.loc 1 2278 0
 10297 584c 5E26D3E5 		ldrb	r2, [r3, #1630]	@ zero_extendqisi2
 10298 5850 84FCFFEA 		b	.L955
 10299              	.LVL1222:
 10300              	.L698:
 10301              	.LBE306:
 10302              	.LBE339:
 10303              	.LBB340:
 10304              	.LBB272:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10305              		.loc 1 2277 0
 10306 5854 C4271FE5 		ldr	r2, .L1018+120
 10307 5858 B515D2E5 		ldrb	r1, [r2, #1461]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10308              		.loc 1 2278 0
 10309 585c B625D2E5 		ldrb	r2, [r2, #1462]	@ zero_extendqisi2
 10310 5860 23FCFFEA 		b	.L957
 10311              	.LVL1223:
 10312              	.L709:
 10313              	.LBE272:
 10314              	.LBE340:
 10315              	.LBB341:
 10316              	.LBB280:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10317              		.loc 1 2277 0
 10318 5864 D4271FE5 		ldr	r2, .L1018+120
 10319 5868 E515D2E5 		ldrb	r1, [r2, #1509]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10320              		.loc 1 2278 0
 10321 586c E625D2E5 		ldrb	r2, [r2, #1510]	@ zero_extendqisi2
 10322 5870 1FFCFFEA 		b	.L957
 10323              	.LVL1224:
 10324              	.L742:
 10325              	.LBE280:
 10326              	.LBE341:
 10327              	.LBB342:
 10328              	.LBB290:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10329              		.loc 1 2277 0
 10330 5874 E4271FE5 		ldr	r2, .L1018+120
 10331 5878 4516D2E5 		ldrb	r1, [r2, #1605]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10332              		.loc 1 2278 0
 10333 587c 4626D2E5 		ldrb	r2, [r2, #1606]	@ zero_extendqisi2
 10334 5880 1BFCFFEA 		b	.L957
 10335              	.LVL1225:
 10336              	.L731:
 10337              	.LBE290:
 10338              	.LBE342:
 10339              	.LBB343:
 10340              	.LBB251:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10341              		.loc 1 2277 0
 10342 5884 F4271FE5 		ldr	r2, .L1018+120
 10343 5888 2D16D2E5 		ldrb	r1, [r2, #1581]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10344              		.loc 1 2278 0
 10345 588c 2E26D2E5 		ldrb	r2, [r2, #1582]	@ zero_extendqisi2
 10346 5890 17FCFFEA 		b	.L957
 10347              	.LVL1226:
 10348              	.L766:
 10349              	.LBE251:
 10350              	.LBE343:
 10351              	.LBB344:
 10352              	.LBB298:
2277:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 10353              		.loc 1 2277 0
 10354 5894 04C81FE5 		ldr	ip, .L1018+120
 10355 5898 7516DCE5 		ldrb	r1, [ip, #1653]	@ zero_extendqisi2
2278:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10356              		.loc 1 2278 0
 10357 589c 7626DCE5 		ldrb	r2, [ip, #1654]	@ zero_extendqisi2
 10358 58a0 13FCFFEA 		b	.L957
 10359              	.LVL1227:
 10360              	.L737:
 10361              	.LBE298:
 10362              	.LBE344:
 10363              	.LBB345:
 10364              	.LBB252:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10365              		.loc 1 2286 0
 10366 58a4 14381FE5 		ldr	r3, .L1018+120
 10367 58a8 2F16D3E5 		ldrb	r1, [r3, #1583]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10368              		.loc 1 2287 0
 10369 58ac 3026D3E5 		ldrb	r2, [r3, #1584]	@ zero_extendqisi2
 10370 58b0 0FFCFFEA 		b	.L957
 10371              	.LVL1228:
 10372              	.L704:
 10373              	.LBE252:
 10374              	.LBE345:
 10375              	.LBB346:
 10376              	.LBB273:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10377              		.loc 1 2286 0
 10378 58b4 24381FE5 		ldr	r3, .L1018+120
 10379 58b8 B715D3E5 		ldrb	r1, [r3, #1463]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10380              		.loc 1 2287 0
 10381 58bc B825D3E5 		ldrb	r2, [r3, #1464]	@ zero_extendqisi2
 10382 58c0 0BFCFFEA 		b	.L957
 10383              	.LVL1229:
 10384              	.L755:
 10385              	.LBE273:
 10386              	.LBE346:
 10387              	.LBB347:
 10388              	.LBB307:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10389              		.loc 1 2253 0
 10390 58c4 34E81FE5 		ldr	lr, .L1018+120
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10391              		.loc 1 2255 0
 10392 58c8 0030A0E3 		mov	r3, #0
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10393              		.loc 1 2253 0
 10394 58cc 65C6DEE5 		ldrb	ip, [lr, #1637]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10395              		.loc 1 2254 0
 10396 58d0 6626DEE5 		ldrb	r2, [lr, #1638]	@ zero_extendqisi2
2261:../uvc.c      **** 
 10397              		.loc 1 2261 0
 10398 58d4 0500A0E1 		mov	r0, r5
 10399 58d8 50181FE5 		ldr	r1, .L1018+112
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10400              		.loc 1 2253 0
 10401 58dc 28C0C7E5 		strb	ip, [r7, #40]
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10402              		.loc 1 2254 0
 10403 58e0 2920C7E5 		strb	r2, [r7, #41]
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10404              		.loc 1 2255 0
 10405 58e4 2A30C7E5 		strb	r3, [r7, #42]
2256:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10406              		.loc 1 2256 0
 10407 58e8 2B30C7E5 		strb	r3, [r7, #43]
 10408              	.LVL1230:
2261:../uvc.c      **** 
 10409              		.loc 1 2261 0
 10410 58ec 1CC08DE5 		str	ip, [sp, #28]
 10411 58f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10412              	.LVL1231:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10413              		.loc 1 2233 0
 10414 58f4 FF20A0E3 		mov	r2, #255
 10415 58f8 0230A0E1 		mov	r3, r2
 10416 58fc 1CC09DE5 		ldr	ip, [sp, #28]
 10417 5900 63FCFFEA 		b	.L762
 10418              	.LVL1232:
 10419              	.L708:
 10420              	.LBE307:
 10421              	.LBE347:
 10422              	.LBB348:
 10423              	.LBB281:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10424              		.loc 1 2446 0
 10425 5904 0000A0E3 		mov	r0, #0
 10426 5908 0020A0E1 		mov	r2, r0
 10427 590c 0110A0E3 		mov	r1, #1
 10428 5910 FEFFFFEB 		bl	CyU3PUsbStall
 10429              	.LVL1233:
2447:../uvc.c      **** 			  break;
 10430              		.loc 1 2447 0
 10431 5914 24C09DE5 		ldr	ip, [sp, #36]
 10432 5918 0220A0E3 		mov	r2, #2
 10433 591c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10434 5920 0400A0E3 		mov	r0, #4
 10435 5924 A4181FE5 		ldr	r1, .L1018+104
 10436 5928 FEFFFFEB 		bl	CyU3PDebugPrint
 10437              	.LVL1234:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10438              		.loc 1 2233 0
 10439 592c FF20A0E3 		mov	r2, #255
 10440              	.LVL1235:
 10441 5930 E0FDFFEA 		b	.L786
 10442              	.LVL1236:
 10443              	.L752:
 10444              	.LBE281:
 10445              	.LBE348:
 10446              	.LBB349:
 10447              	.LBB308:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10448              		.loc 1 2446 0
 10449 5934 0000A0E3 		mov	r0, #0
 10450 5938 0020A0E1 		mov	r2, r0
 10451 593c 0110A0E3 		mov	r1, #1
 10452 5940 FEFFFFEB 		bl	CyU3PUsbStall
 10453              	.LVL1237:
2447:../uvc.c      **** 			  break;
 10454              		.loc 1 2447 0
 10455 5944 24C09DE5 		ldr	ip, [sp, #36]
 10456 5948 0720A0E3 		mov	r2, #7
 10457 594c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10458 5950 0400A0E3 		mov	r0, #4
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10459              		.loc 1 2233 0
 10460 5954 FFC0A0E3 		mov	ip, #255
2447:../uvc.c      **** 			  break;
 10461              		.loc 1 2447 0
 10462 5958 D8181FE5 		ldr	r1, .L1018+104
 10463 595c 1CC08DE5 		str	ip, [sp, #28]
 10464 5960 FEFFFFEB 		bl	CyU3PDebugPrint
 10465              	.LVL1238:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10466              		.loc 1 2233 0
 10467 5964 1CC09DE5 		ldr	ip, [sp, #28]
 10468 5968 0C20A0E1 		mov	r2, ip
 10469 596c 0C30A0E1 		mov	r3, ip
 10470 5970 47FCFFEA 		b	.L762
 10471              	.LVL1239:
 10472              	.L726:
 10473              	.LBE308:
 10474              	.LBE349:
 10475              	.LBB350:
 10476              	.LBB244:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10477              		.loc 1 2286 0
 10478 5974 1716DAE5 		ldrb	r1, [r10, #1559]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10479              		.loc 1 2287 0
 10480 5978 1826DAE5 		ldrb	r2, [r10, #1560]	@ zero_extendqisi2
 10481 597c DCFBFFEA 		b	.L957
 10482              	.LVL1240:
 10483              	.L783:
 10484              	.LBE244:
 10485              	.LBE350:
 10486              	.LBB351:
 10487              	.LBB264:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10488              		.loc 1 2286 0
 10489 5980 F0381FE5 		ldr	r3, .L1018+120
 10490 5984 8F16D3E5 		ldrb	r1, [r3, #1679]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10491              		.loc 1 2287 0
 10492 5988 9026D3E5 		ldrb	r2, [r3, #1680]	@ zero_extendqisi2
 10493 598c D8FBFFEA 		b	.L957
 10494              	.LVL1241:
 10495              	.L744:
 10496              	.LBE264:
 10497              	.LBE351:
 10498              	.LBB352:
 10499              	.LBB291:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10500              		.loc 1 2253 0
 10501 5990 00C91FE5 		ldr	ip, .L1018+120
 10502 5994 4D26DCE5 		ldrb	r2, [ip, #1613]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10503              		.loc 1 2254 0
 10504 5998 4E16DCE5 		ldrb	r1, [ip, #1614]	@ zero_extendqisi2
 10505              	.LVL1242:
 10506              	.L969:
 10507              	.LBE291:
 10508              	.LBE352:
 10509              	.LBB353:
 10510              	.LBB265:
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10511              		.loc 1 2255 0
 10512 599c 0030A0E3 		mov	r3, #0
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10513              		.loc 1 2254 0
 10514 59a0 2910C7E5 		strb	r1, [r7, #41]
2261:../uvc.c      **** 
 10515              		.loc 1 2261 0
 10516 59a4 0500A0E1 		mov	r0, r5
 10517 59a8 20191FE5 		ldr	r1, .L1018+112
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10518              		.loc 1 2253 0
 10519 59ac 2820C7E5 		strb	r2, [r7, #40]
2261:../uvc.c      **** 
 10520              		.loc 1 2261 0
 10521 59b0 20208DE5 		str	r2, [sp, #32]
2255:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10522              		.loc 1 2255 0
 10523 59b4 2A30C7E5 		strb	r3, [r7, #42]
2256:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10524              		.loc 1 2256 0
 10525 59b8 2B30C7E5 		strb	r3, [r7, #43]
 10526              	.LVL1243:
2261:../uvc.c      **** 
 10527              		.loc 1 2261 0
 10528 59bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10529              	.LVL1244:
 10530 59c0 20209DE5 		ldr	r2, [sp, #32]
 10531 59c4 BBFDFFEA 		b	.L786
 10532              	.LVL1245:
 10533              	.L772:
 10534              	.LBE265:
 10535              	.LBE353:
 10536              	.LBB354:
 10537              	.LBB299:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10538              		.loc 1 2286 0
 10539 59c8 7716DAE5 		ldrb	r1, [r10, #1655]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10540              		.loc 1 2287 0
 10541 59cc 7826DAE5 		ldrb	r2, [r10, #1656]	@ zero_extendqisi2
 10542 59d0 C7FBFFEA 		b	.L957
 10543              	.LVL1246:
 10544              	.L733:
 10545              	.LBE299:
 10546              	.LBE354:
 10547              	.LBB355:
 10548              	.LBB253:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10549              		.loc 1 2253 0
 10550 59d4 44C91FE5 		ldr	ip, .L1018+120
 10551 59d8 3526DCE5 		ldrb	r2, [ip, #1589]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10552              		.loc 1 2254 0
 10553 59dc 3616DCE5 		ldrb	r1, [ip, #1590]	@ zero_extendqisi2
 10554 59e0 EDFFFFEA 		b	.L969
 10555              	.LVL1247:
 10556              	.L748:
 10557              	.LBE253:
 10558              	.LBE355:
 10559              	.LBB356:
 10560              	.LBB292:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10561              		.loc 1 2286 0
 10562 59e4 54391FE5 		ldr	r3, .L1018+120
 10563 59e8 4716D3E5 		ldrb	r1, [r3, #1607]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10564              		.loc 1 2287 0
 10565 59ec 4826D3E5 		ldrb	r2, [r3, #1608]	@ zero_extendqisi2
 10566 59f0 BFFBFFEA 		b	.L957
 10567              	.LVL1248:
 10568              	.L722:
 10569              	.LBE292:
 10570              	.LBE356:
 10571              	.LBB357:
 10572              	.LBB245:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10573              		.loc 1 2253 0
 10574 59f4 64C91FE5 		ldr	ip, .L1018+120
 10575 59f8 1D26DCE5 		ldrb	r2, [ip, #1565]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10576              		.loc 1 2254 0
 10577 59fc 1E16DCE5 		ldrb	r1, [ip, #1566]	@ zero_extendqisi2
 10578 5a00 E5FFFFEA 		b	.L969
 10579              	.LVL1249:
 10580              	.L715:
 10581              	.LBE245:
 10582              	.LBE357:
 10583              	.LBB358:
 10584              	.LBB282:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10585              		.loc 1 2286 0
 10586 5a04 74391FE5 		ldr	r3, .L1018+120
 10587 5a08 E715D3E5 		ldrb	r1, [r3, #1511]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10588              		.loc 1 2287 0
 10589 5a0c E825D3E5 		ldrb	r2, [r3, #1512]	@ zero_extendqisi2
 10590 5a10 B7FBFFEA 		b	.L957
 10591              	.LVL1250:
 10592              	.L730:
 10593              	.LBE282:
 10594              	.LBE358:
 10595              	.LBB359:
 10596              	.LBB254:
2446:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 10597              		.loc 1 2446 0
 10598 5a14 0000A0E3 		mov	r0, #0
 10599 5a18 0020A0E1 		mov	r2, r0
 10600 5a1c 0110A0E3 		mov	r1, #1
 10601 5a20 FEFFFFEB 		bl	CyU3PUsbStall
 10602              	.LVL1251:
2447:../uvc.c      **** 			  break;
 10603              		.loc 1 2447 0
 10604 5a24 24C09DE5 		ldr	ip, [sp, #36]
 10605 5a28 0520A0E3 		mov	r2, #5
 10606 5a2c 0030DCE5 		ldrb	r3, [ip]	@ zero_extendqisi2
 10607 5a30 0400A0E3 		mov	r0, #4
 10608 5a34 B4191FE5 		ldr	r1, .L1018+104
 10609 5a38 FEFFFFEB 		bl	CyU3PDebugPrint
 10610              	.LVL1252:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10611              		.loc 1 2233 0
 10612 5a3c FF20A0E3 		mov	r2, #255
 10613              	.LVL1253:
 10614 5a40 9CFDFFEA 		b	.L786
 10615              	.LVL1254:
 10616              	.L759:
 10617              	.LBE254:
 10618              	.LBE359:
 10619              	.LBB360:
 10620              	.LBB309:
2286:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 10621              		.loc 1 2286 0
 10622 5a44 B4C91FE5 		ldr	ip, .L1018+120
 10623 5a48 5F16DCE5 		ldrb	r1, [ip, #1631]	@ zero_extendqisi2
2287:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 10624              		.loc 1 2287 0
 10625 5a4c 6026DCE5 		ldrb	r2, [ip, #1632]	@ zero_extendqisi2
 10626 5a50 04FCFFEA 		b	.L955
 10627              	.L758:
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10628              		.loc 1 2244 0
 10629 5a54 0030A0E3 		mov	r3, #0
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10630              		.loc 1 2245 0
 10631 5a58 0200A0E3 		mov	r0, #2
 10632 5a5c D4191FE5 		ldr	r1, .L1018+112
2244:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10633              		.loc 1 2244 0
 10634 5a60 2930C7E5 		strb	r3, [r7, #41]
2243:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10635              		.loc 1 2243 0
 10636 5a64 2850C7E5 		strb	r5, [r7, #40]
2245:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10637              		.loc 1 2245 0
 10638 5a68 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10639              	.LVL1255:
2233:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10640              		.loc 1 2233 0
 10641 5a6c FF20A0E3 		mov	r2, #255
 10642 5a70 0230A0E1 		mov	r3, r2
2246:../uvc.c      **** 			  break;
 10643              		.loc 1 2246 0
 10644 5a74 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10645              	.LVL1256:
 10646 5a78 05FCFFEA 		b	.L762
 10647              	.LVL1257:
 10648              	.L779:
 10649              	.LBE309:
 10650              	.LBE360:
 10651              	.LBB361:
 10652              	.LBB266:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10653              		.loc 1 2253 0
 10654 5a7c ECC91FE5 		ldr	ip, .L1018+120
 10655 5a80 9526DCE5 		ldrb	r2, [ip, #1685]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10656              		.loc 1 2254 0
 10657 5a84 9616DCE5 		ldrb	r1, [ip, #1686]	@ zero_extendqisi2
 10658 5a88 C3FFFFEA 		b	.L969
 10659              	.LVL1258:
 10660              	.L700:
 10661              	.LBE266:
 10662              	.LBE361:
 10663              	.LBB362:
 10664              	.LBB274:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10665              		.loc 1 2253 0
 10666 5a8c FCC91FE5 		ldr	ip, .L1018+120
 10667 5a90 BD25DCE5 		ldrb	r2, [ip, #1469]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10668              		.loc 1 2254 0
 10669 5a94 BE15DCE5 		ldrb	r1, [ip, #1470]	@ zero_extendqisi2
 10670 5a98 BFFFFFEA 		b	.L969
 10671              	.LVL1259:
 10672              	.L711:
 10673              	.LBE274:
 10674              	.LBE362:
 10675              	.LBB363:
 10676              	.LBB283:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10677              		.loc 1 2253 0
 10678 5a9c 0CCA1FE5 		ldr	ip, .L1018+120
 10679 5aa0 ED25DCE5 		ldrb	r2, [ip, #1517]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10680              		.loc 1 2254 0
 10681 5aa4 EE15DCE5 		ldrb	r1, [ip, #1518]	@ zero_extendqisi2
 10682 5aa8 BBFFFFEA 		b	.L969
 10683              	.LVL1260:
 10684              	.L768:
 10685              	.LBE283:
 10686              	.LBE363:
 10687              	.LBB364:
 10688              	.LBB300:
2253:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 10689              		.loc 1 2253 0
 10690 5aac 7D26DAE5 		ldrb	r2, [r10, #1661]	@ zero_extendqisi2
2254:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 10691              		.loc 1 2254 0
 10692 5ab0 7E16DAE5 		ldrb	r1, [r10, #1662]	@ zero_extendqisi2
 10693 5ab4 B8FFFFEA 		b	.L969
 10694              	.LVL1261:
 10695              	.L878:
 10696              	.LBE300:
 10697              	.LBE364:
 10698              	.LBE371:
 10699              	.LBE410:
 10700              	.LBB411:
 10701              	.LBB233:
 10702              	.LBB201:
 10703              	.LBB186:
2210:../uvc.c      **** 			  break;
 10704              		.loc 1 2210 0
 10705 5ab8 0000A0E3 		mov	r0, #0
 10706 5abc 0020A0E1 		mov	r2, r0
 10707 5ac0 0110A0E3 		mov	r1, #1
 10708 5ac4 FEFFFFEB 		bl	CyU3PUsbStall
 10709              	.LVL1262:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10710              		.loc 1 1355 0
 10711 5ac8 FF40A0E3 		mov	r4, #255
2210:../uvc.c      **** 			  break;
 10712              		.loc 1 2210 0
 10713 5acc 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10714              		.loc 1 1355 0
 10715 5ad0 0450A0E1 		mov	r5, r4
 10716              	.LVL1263:
2210:../uvc.c      **** 			  break;
 10717              		.loc 1 2210 0
 10718 5ad4 28C08DE5 		str	ip, [sp, #40]
 10719 5ad8 3AFEFFEA 		b	.L888
 10720              	.LVL1264:
 10721              	.L886:
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10722              		.loc 1 1737 0
 10723 5adc 6127DAE5 		ldrb	r2, [r10, #1889]	@ zero_extendqisi2
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10724              		.loc 1 1738 0
 10725 5ae0 0030A0E3 		mov	r3, #0
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10726              		.loc 1 1749 0
 10727 5ae4 0100A0E3 		mov	r0, #1
 10728 5ae8 601A1FE5 		ldr	r1, .L1018+112
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10729              		.loc 1 1737 0
 10730 5aec 2820C7E5 		strb	r2, [r7, #40]
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10731              		.loc 1 1738 0
 10732 5af0 2930C7E5 		strb	r3, [r7, #41]
1739:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10733              		.loc 1 1739 0
 10734 5af4 2A30C7E5 		strb	r3, [r7, #42]
1740:../uvc.c      **** 		 	 }
 10735              		.loc 1 1740 0
 10736 5af8 2B30C7E5 		strb	r3, [r7, #43]
 10737              	.LVL1265:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10738              		.loc 1 1751 0
 10739 5afc 28308DE5 		str	r3, [sp, #40]
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10740              		.loc 1 1749 0
 10741 5b00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10742              	.LVL1266:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10743              		.loc 1 1751 0
 10744 5b04 00C0A0E3 		mov	ip, #0
1750:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 10745              		.loc 1 1750 0
 10746 5b08 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10747              	.LVL1267:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10748              		.loc 1 1751 0
 10749 5b0c 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10750              	.LVL1268:
 10751 5b10 2CFEFFEA 		b	.L888
 10752              	.LVL1269:
 10753              	.L885:
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10754              		.loc 1 1719 0
 10755 5b14 841A1FE5 		ldr	r1, .L1018+120
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10756              		.loc 1 1721 0
 10757 5b18 0030A0E3 		mov	r3, #0
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10758              		.loc 1 1719 0
 10759 5b1c 5FE7D1E5 		ldrb	lr, [r1, #1887]	@ zero_extendqisi2
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10760              		.loc 1 1720 0
 10761 5b20 6027D1E5 		ldrb	r2, [r1, #1888]	@ zero_extendqisi2
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10762              		.loc 1 1730 0
 10763 5b24 9C1A1FE5 		ldr	r1, .L1018+112
 10764 5b28 0C00A0E1 		mov	r0, ip
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10765              		.loc 1 1719 0
 10766 5b2c 28E0C7E5 		strb	lr, [r7, #40]
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10767              		.loc 1 1720 0
 10768 5b30 2920C7E5 		strb	r2, [r7, #41]
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10769              		.loc 1 1721 0
 10770 5b34 2A30C7E5 		strb	r3, [r7, #42]
1722:../uvc.c      **** 		 	 }
 10771              		.loc 1 1722 0
 10772 5b38 2B30C7E5 		strb	r3, [r7, #43]
 10773              	.L967:
1711:../uvc.c      **** 				  }else{
 10774              		.loc 1 1711 0
 10775 5b3c 0040A0E3 		mov	r4, #0
 10776 5b40 28408DE5 		str	r4, [sp, #40]
1708:../uvc.c      **** 				  if(Len == 2){
 10777              		.loc 1 1708 0
 10778 5b44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10779              	.LVL1270:
1711:../uvc.c      **** 				  }else{
 10780              		.loc 1 1711 0
 10781 5b48 04C0A0E1 		mov	ip, r4
1710:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10782              		.loc 1 1710 0
 10783 5b4c 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10784              	.LVL1271:
1711:../uvc.c      **** 				  }else{
 10785              		.loc 1 1711 0
 10786 5b50 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10787              	.LVL1272:
 10788 5b54 1BFEFFEA 		b	.L888
 10789              	.LVL1273:
 10790              	.L851:
 10791              	.LBE186:
 10792              	.LBE201:
 10793              	.LBB202:
 10794              	.LBB161:
2210:../uvc.c      **** 			  break;
 10795              		.loc 1 2210 0
 10796 5b58 0000A0E3 		mov	r0, #0
 10797 5b5c 0020A0E1 		mov	r2, r0
 10798 5b60 0110A0E3 		mov	r1, #1
 10799 5b64 FEFFFFEB 		bl	CyU3PUsbStall
 10800              	.LVL1274:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10801              		.loc 1 1355 0
 10802 5b68 FF40A0E3 		mov	r4, #255
2210:../uvc.c      **** 			  break;
 10803              		.loc 1 2210 0
 10804 5b6c 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10805              		.loc 1 1355 0
 10806 5b70 0450A0E1 		mov	r5, r4
 10807              	.LVL1275:
2210:../uvc.c      **** 			  break;
 10808              		.loc 1 2210 0
 10809 5b74 28C08DE5 		str	ip, [sp, #40]
 10810 5b78 41FEFFEA 		b	.L861
 10811              	.LVL1276:
 10812              	.L825:
 10813              	.LBE161:
 10814              	.LBE202:
 10815              	.LBB203:
 10816              	.LBB174:
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10817              		.loc 1 1684 0
 10818 5b7c ECEA1FE5 		ldr	lr, .L1018+120
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10819              		.loc 1 1683 0
 10820 5b80 020055E3 		cmp	r5, #2
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10821              		.loc 1 1689 0
 10822 5b84 35C7DE15 		ldrneb	ip, [lr, #1845]	@ zero_extendqisi2
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10823              		.loc 1 1691 0
 10824 5b88 3627DE15 		ldrneb	r2, [lr, #1846]	@ zero_extendqisi2
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10825              		.loc 1 1683 0
 10826 5b8c 14FCFF1A 		bne	.L959
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10827              		.loc 1 1684 0
 10828 5b90 3527DEE5 		ldrb	r2, [lr, #1845]	@ zero_extendqisi2
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10829              		.loc 1 1685 0
 10830 5b94 3637DEE5 		ldrb	r3, [lr, #1846]	@ zero_extendqisi2
 10831              	.L958:
1708:../uvc.c      **** 				  if(Len == 2){
 10832              		.loc 1 1708 0
 10833 5b98 0500A0E1 		mov	r0, r5
 10834 5b9c 141B1FE5 		ldr	r1, .L1018+112
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10835              		.loc 1 1684 0
 10836 5ba0 2820C7E5 		strb	r2, [r7, #40]
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10837              		.loc 1 1685 0
 10838 5ba4 2930C7E5 		strb	r3, [r7, #41]
 10839 5ba8 3C0000EA 		b	.L961
 10840              	.LVL1277:
 10841              	.L859:
 10842              	.LBE174:
 10843              	.LBE203:
 10844              	.LBB204:
 10845              	.LBB162:
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10846              		.loc 1 1737 0
 10847 5bac 4D27DAE5 		ldrb	r2, [r10, #1869]	@ zero_extendqisi2
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10848              		.loc 1 1738 0
 10849 5bb0 0030A0E3 		mov	r3, #0
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10850              		.loc 1 1749 0
 10851 5bb4 0100A0E3 		mov	r0, #1
 10852 5bb8 301B1FE5 		ldr	r1, .L1018+112
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10853              		.loc 1 1737 0
 10854 5bbc 2820C7E5 		strb	r2, [r7, #40]
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10855              		.loc 1 1738 0
 10856 5bc0 2930C7E5 		strb	r3, [r7, #41]
1739:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10857              		.loc 1 1739 0
 10858 5bc4 2A30C7E5 		strb	r3, [r7, #42]
1740:../uvc.c      **** 		 	 }
 10859              		.loc 1 1740 0
 10860 5bc8 2B30C7E5 		strb	r3, [r7, #43]
 10861              	.LVL1278:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10862              		.loc 1 1751 0
 10863 5bcc 28308DE5 		str	r3, [sp, #40]
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10864              		.loc 1 1749 0
 10865 5bd0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10866              	.LVL1279:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10867              		.loc 1 1751 0
 10868 5bd4 00C0A0E3 		mov	ip, #0
1750:../uvc.c      **** 		 	 sendData1 = glEp0Buffer[1];
 10869              		.loc 1 1750 0
 10870 5bd8 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10871              	.LVL1280:
1751:../uvc.c      **** 		 	 //CyU3PDebugPrint (4, "The control InfoLo: 0x%x, InfoHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0],
 10872              		.loc 1 1751 0
 10873 5bdc 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10874              	.LVL1281:
 10875 5be0 27FEFFEA 		b	.L861
 10876              	.LVL1282:
 10877              	.L858:
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10878              		.loc 1 1719 0
 10879 5be4 4BE7DAE5 		ldrb	lr, [r10, #1867]	@ zero_extendqisi2
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10880              		.loc 1 1720 0
 10881 5be8 4C27DAE5 		ldrb	r2, [r10, #1868]	@ zero_extendqisi2
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10882              		.loc 1 1721 0
 10883 5bec 0030A0E3 		mov	r3, #0
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10884              		.loc 1 1730 0
 10885 5bf0 0C00A0E1 		mov	r0, ip
 10886 5bf4 6C1B1FE5 		ldr	r1, .L1018+112
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 10887              		.loc 1 1719 0
 10888 5bf8 28E0C7E5 		strb	lr, [r7, #40]
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10889              		.loc 1 1720 0
 10890 5bfc 2920C7E5 		strb	r2, [r7, #41]
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10891              		.loc 1 1721 0
 10892 5c00 2A30C7E5 		strb	r3, [r7, #42]
1722:../uvc.c      **** 		 	 }
 10893              		.loc 1 1722 0
 10894 5c04 2B30C7E5 		strb	r3, [r7, #43]
 10895 5c08 38FEFFEA 		b	.L964
 10896              	.LVL1283:
 10897              	.L879:
 10898              	.LBE162:
 10899              	.LBE204:
 10900              	.LBB205:
 10901              	.LBB187:
1683:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxLo;//ExUCtrlParArry[locCtrlID][5];
 10902              		.loc 1 1683 0
 10903 5c0c 02005CE3 		cmp	ip, #2
 10904 5c10 7E00000A 		beq	.L1005
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10905              		.loc 1 1689 0
 10906 5c14 841B1FE5 		ldr	r1, .L1018+120
1690:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10907              		.loc 1 1690 0
 10908 5c18 0030A0E3 		mov	r3, #0
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10909              		.loc 1 1689 0
 10910 5c1c 5DE7D1E5 		ldrb	lr, [r1, #1885]	@ zero_extendqisi2
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10911              		.loc 1 1691 0
 10912 5c20 5E27D1E5 		ldrb	r2, [r1, #1886]	@ zero_extendqisi2
1714:../uvc.c      **** 				  }
 10913              		.loc 1 1714 0
 10914 5c24 0340A0E1 		mov	r4, r3
 10915              	.LVL1284:
1708:../uvc.c      **** 				  if(Len == 2){
 10916              		.loc 1 1708 0
 10917 5c28 0C00A0E1 		mov	r0, ip
 10918 5c2c A41B1FE5 		ldr	r1, .L1018+112
1689:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 10919              		.loc 1 1689 0
 10920 5c30 28E0C7E5 		strb	lr, [r7, #40]
1691:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10921              		.loc 1 1691 0
 10922 5c34 2A20C7E5 		strb	r2, [r7, #42]
1690:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 10923              		.loc 1 1690 0
 10924 5c38 2930C7E5 		strb	r3, [r7, #41]
1692:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 10925              		.loc 1 1692 0
 10926 5c3c 2B30C7E5 		strb	r3, [r7, #43]
1714:../uvc.c      **** 				  }
 10927              		.loc 1 1714 0
 10928 5c40 28308DE5 		str	r3, [sp, #40]
1708:../uvc.c      **** 				  if(Len == 2){
 10929              		.loc 1 1708 0
 10930 5c44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10931              	.LVL1285:
1714:../uvc.c      **** 				  }
 10932              		.loc 1 1714 0
 10933 5c48 04C0A0E1 		mov	ip, r4
1713:../uvc.c      **** 					  sendData1 = glEp0Buffer[2];
 10934              		.loc 1 1713 0
 10935 5c4c 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 10936              	.LVL1286:
1714:../uvc.c      **** 				  }
 10937              		.loc 1 1714 0
 10938 5c50 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 10939              	.LVL1287:
 10940 5c54 DBFDFFEA 		b	.L888
 10941              	.LVL1288:
 10942              	.L824:
 10943              	.LBE187:
 10944              	.LBE205:
 10945              	.LBB206:
 10946              	.LBB175:
2210:../uvc.c      **** 			  break;
 10947              		.loc 1 2210 0
 10948 5c58 0000A0E3 		mov	r0, #0
 10949 5c5c 0110A0E3 		mov	r1, #1
 10950 5c60 0020A0E1 		mov	r2, r0
 10951 5c64 FEFFFFEB 		bl	CyU3PUsbStall
 10952              	.LVL1289:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10953              		.loc 1 1355 0
 10954 5c68 FF40A0E3 		mov	r4, #255
2210:../uvc.c      **** 			  break;
 10955              		.loc 1 2210 0
 10956 5c6c 0010A0E3 		mov	r1, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10957              		.loc 1 1355 0
 10958 5c70 04C0A0E1 		mov	ip, r4
2210:../uvc.c      **** 			  break;
 10959              		.loc 1 2210 0
 10960 5c74 24108DE5 		str	r1, [sp, #36]
 10961 5c78 0150A0E1 		mov	r5, r1
 10962              	.LVL1290:
 10963 5c7c ECFDFFEA 		b	.L834
 10964              	.LVL1291:
 10965              	.L832:
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10966              		.loc 1 1737 0
 10967 5c80 3927DAE5 		ldrb	r2, [r10, #1849]	@ zero_extendqisi2
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10968              		.loc 1 1749 0
 10969 5c84 FC1B1FE5 		ldr	r1, .L1018+112
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10970              		.loc 1 1738 0
 10971 5c88 0030A0E3 		mov	r3, #0
1749:../uvc.c      **** 		 	 sendData = glEp0Buffer[0];
 10972              		.loc 1 1749 0
 10973 5c8c 0100A0E3 		mov	r0, #1
1737:../uvc.c      **** 				 glEp0Buffer[1] = 0;//pEXTSenCtrl[CtrlID - 0x10]->UVCInfoHi;//ExUCtrlParArry[locCtrlID][10];
 10974              		.loc 1 1737 0
 10975 5c90 2820C7E5 		strb	r2, [r7, #40]
1738:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 10976              		.loc 1 1738 0
 10977 5c94 2930C7E5 		strb	r3, [r7, #41]
1739:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 10978              		.loc 1 1739 0
 10979 5c98 2A30C7E5 		strb	r3, [r7, #42]
1740:../uvc.c      **** 		 	 }
 10980              		.loc 1 1740 0
 10981 5c9c 2B30C7E5 		strb	r3, [r7, #43]
 10982              	.LVL1292:
 10983              	.L961:
1711:../uvc.c      **** 				  }else{
 10984              		.loc 1 1711 0
 10985 5ca0 0040A0E3 		mov	r4, #0
 10986 5ca4 24408DE5 		str	r4, [sp, #36]
 10987 5ca8 0450A0E1 		mov	r5, r4
1708:../uvc.c      **** 				  if(Len == 2){
 10988              		.loc 1 1708 0
 10989 5cac FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10990              	.LVL1293:
1710:../uvc.c      **** 					  sendData1 = glEp0Buffer[1];
 10991              		.loc 1 1710 0
 10992 5cb0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 10993              	.LVL1294:
1711:../uvc.c      **** 				  }else{
 10994              		.loc 1 1711 0
 10995 5cb4 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 10996              	.LVL1295:
 10997 5cb8 DDFDFFEA 		b	.L834
 10998              	.LVL1296:
 10999              	.L831:
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11000              		.loc 1 1719 0
 11001 5cbc 37C7DAE5 		ldrb	ip, [r10, #1847]	@ zero_extendqisi2
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11002              		.loc 1 1730 0
 11003 5cc0 381C1FE5 		ldr	r1, .L1018+112
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11004              		.loc 1 1720 0
 11005 5cc4 3827DAE5 		ldrb	r2, [r10, #1848]	@ zero_extendqisi2
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11006              		.loc 1 1721 0
 11007 5cc8 0030A0E3 		mov	r3, #0
1730:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11008              		.loc 1 1730 0
 11009 5ccc 0500A0E1 		mov	r0, r5
1719:../uvc.c      **** 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCResHi;//ExUCtrlParArry[locCtrlID][8];
 11010              		.loc 1 1719 0
 11011 5cd0 28C0C7E5 		strb	ip, [r7, #40]
1720:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 11012              		.loc 1 1720 0
 11013 5cd4 2920C7E5 		strb	r2, [r7, #41]
1721:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 11014              		.loc 1 1721 0
 11015 5cd8 2A30C7E5 		strb	r3, [r7, #42]
1722:../uvc.c      **** 		 	 }
 11016              		.loc 1 1722 0
 11017 5cdc 2B30C7E5 		strb	r3, [r7, #43]
 11018              	.LVL1297:
 11019              	.L960:
1784:../uvc.c      **** 		 	 }else{
 11020              		.loc 1 1784 0
 11021 5ce0 00C0A0E3 		mov	ip, #0
 11022 5ce4 24C08DE5 		str	ip, [sp, #36]
 11023 5ce8 0050A0E3 		mov	r5, #0
1781:../uvc.c      **** 		 	 if(Len == 2){
 11024              		.loc 1 1781 0
 11025 5cec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11026              	.LVL1298:
1783:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[1];
 11027              		.loc 1 1783 0
 11028 5cf0 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11029              	.LVL1299:
1784:../uvc.c      **** 		 	 }else{
 11030              		.loc 1 1784 0
 11031 5cf4 2940D7E5 		ldrb	r4, [r7, #41]	@ zero_extendqisi2
 11032              	.LVL1300:
 11033 5cf8 CDFDFFEA 		b	.L834
 11034              	.LVL1301:
 11035              	.L763:
 11036              	.LBE175:
 11037              	.LBE206:
 11038              	.LBE233:
 11039              	.LBE411:
 11040              	.LBB412:
 11041              	.LBB372:
 11042              	.LBB365:
 11043              	.LBB310:
2414:../uvc.c      **** 					  }
 11044              		.loc 1 2414 0
 11045 5cfc 0020A0E1 		mov	r2, r0
 11046 5d00 0410A0E1 		mov	r1, r4
 11047 5d04 FEFFFFEB 		bl	CyU3PUsbStall
 11048              	.LVL1302:
 11049 5d08 C0FCFFEA 		b	.L764
 11050              	.LVL1303:
 11051              	.L828:
 11052              	.LBE310:
 11053              	.LBE365:
 11054              	.LBE372:
 11055              	.LBE412:
 11056              	.LBB413:
 11057              	.LBB234:
 11058              	.LBB207:
 11059              	.LBB176:
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11060              		.loc 1 1647 0
 11061 5d0c 020055E3 		cmp	r5, #2
1648:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11062              		.loc 1 1648 0
 11063 5d10 3327DA05 		ldreqb	r2, [r10, #1843]	@ zero_extendqisi2
1649:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11064              		.loc 1 1649 0
 11065 5d14 3437DA05 		ldreqb	r3, [r10, #1844]	@ zero_extendqisi2
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11066              		.loc 1 1647 0
 11067 5d18 9EFFFF0A 		beq	.L958
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11068              		.loc 1 1653 0
 11069 5d1c 33C7DAE5 		ldrb	ip, [r10, #1843]	@ zero_extendqisi2
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11070              		.loc 1 1655 0
 11071 5d20 3427DAE5 		ldrb	r2, [r10, #1844]	@ zero_extendqisi2
1654:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11072              		.loc 1 1654 0
 11073 5d24 0030A0E3 		mov	r3, #0
1672:../uvc.c      **** 		 	 if(Len == 2){
 11074              		.loc 1 1672 0
 11075 5d28 0500A0E1 		mov	r0, r5
 11076 5d2c A41C1FE5 		ldr	r1, .L1018+112
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11077              		.loc 1 1653 0
 11078 5d30 28C0C7E5 		strb	ip, [r7, #40]
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11079              		.loc 1 1655 0
 11080 5d34 2A20C7E5 		strb	r2, [r7, #42]
1654:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11081              		.loc 1 1654 0
 11082 5d38 2930C7E5 		strb	r3, [r7, #41]
1656:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11083              		.loc 1 1656 0
 11084 5d3c 2B30C7E5 		strb	r3, [r7, #43]
1678:../uvc.c      **** 			  }
 11085              		.loc 1 1678 0
 11086 5d40 24308DE5 		str	r3, [sp, #36]
 11087 5d44 0050A0E3 		mov	r5, #0
 11088              	.LVL1304:
1672:../uvc.c      **** 		 	 if(Len == 2){
 11089              		.loc 1 1672 0
 11090 5d48 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11091              	.LVL1305:
1677:../uvc.c      **** 				  sendData1 = glEp0Buffer[2];
 11092              		.loc 1 1677 0
 11093 5d4c 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
 11094              	.LVL1306:
1678:../uvc.c      **** 			  }
 11095              		.loc 1 1678 0
 11096 5d50 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 11097              	.LVL1307:
 11098 5d54 B6FDFFEA 		b	.L834
 11099              	.LVL1308:
 11100              	.L827:
1466:../uvc.c      **** 			 	 			 if(Len == 2)
 11101              		.loc 1 1466 0
 11102 5d58 B630D7E5 		ldrb	r3, [r7, #182]	@ zero_extendqisi2
 11103 5d5c 000053E3 		cmp	r3, #0
 11104 5d60 8000000A 		beq	.L835
1467:../uvc.c      **** 			 	 			 {
 11105              		.loc 1 1467 0
 11106 5d64 020055E3 		cmp	r5, #2
 11107 5d68 1602000A 		beq	.L1006
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11108              		.loc 1 1473 0
 11109 5d6c 040055E3 		cmp	r5, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11110              		.loc 1 1355 0
 11111 5d70 FF40A013 		movne	r4, #255
 11112              	.LVL1309:
 11113 5d74 04C0A011 		movne	ip, r4
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11114              		.loc 1 1473 0
 11115 5d78 0802000A 		beq	.L1007
 11116              	.LVL1310:
 11117              	.L837:
1639:../uvc.c      **** 
 11118              		.loc 1 1639 0
 11119 5d7c 0500A0E1 		mov	r0, r5
 11120 5d80 F81C1FE5 		ldr	r1, .L1018+112
 11121 5d84 1CC08DE5 		str	ip, [sp, #28]
 11122 5d88 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11123              	.LVL1311:
1642:../uvc.c      **** //#endif
 11124              		.loc 1 1642 0
 11125 5d8c 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11126 5d90 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11127 5d94 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11128 5d98 23008DE8 		stmia	sp, {r0, r1, r5}
 11129 5d9c 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11130 5da0 0400A0E3 		mov	r0, #4
 11131 5da4 201D1FE5 		ldr	r1, .L1018+108
 11132 5da8 FEFFFFEB 		bl	CyU3PDebugPrint
 11133              	.LVL1312:
 11134 5dac 00E0A0E3 		mov	lr, #0
 11135 5db0 24E08DE5 		str	lr, [sp, #36]
 11136 5db4 0E50A0E1 		mov	r5, lr
 11137              	.LVL1313:
 11138 5db8 1CC09DE5 		ldr	ip, [sp, #28]
 11139 5dbc 9CFDFFEA 		b	.L834
 11140              	.LVL1314:
 11141              	.L882:
 11142              	.LBE176:
 11143              	.LBE207:
 11144              	.LBB208:
 11145              	.LBB188:
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11146              		.loc 1 1647 0
 11147 5dc0 02005CE3 		cmp	ip, #2
1648:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11148              		.loc 1 1648 0
 11149 5dc4 5B27DA05 		ldreqb	r2, [r10, #1883]	@ zero_extendqisi2
1672:../uvc.c      **** 		 	 if(Len == 2){
 11150              		.loc 1 1672 0
 11151 5dc8 0200A003 		moveq	r0, #2
1649:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11152              		.loc 1 1649 0
 11153 5dcc 5C37DA05 		ldreqb	r3, [r10, #1884]	@ zero_extendqisi2
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11154              		.loc 1 1647 0
 11155 5dd0 1200000A 		beq	.L965
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11156              		.loc 1 1653 0
 11157 5dd4 5BE7DAE5 		ldrb	lr, [r10, #1883]	@ zero_extendqisi2
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11158              		.loc 1 1655 0
 11159 5dd8 5C27DAE5 		ldrb	r2, [r10, #1884]	@ zero_extendqisi2
 11160              	.LVL1315:
 11161              	.L966:
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11162              		.loc 1 1763 0
 11163 5ddc 0030A0E3 		mov	r3, #0
1781:../uvc.c      **** 		 	 if(Len == 2){
 11164              		.loc 1 1781 0
 11165 5de0 0C00A0E1 		mov	r0, ip
 11166 5de4 5C1D1FE5 		ldr	r1, .L1018+112
1762:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11167              		.loc 1 1762 0
 11168 5de8 28E0C7E5 		strb	lr, [r7, #40]
1764:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11169              		.loc 1 1764 0
 11170 5dec 2A20C7E5 		strb	r2, [r7, #42]
1763:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11171              		.loc 1 1763 0
 11172 5df0 2930C7E5 		strb	r3, [r7, #41]
1765:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 11173              		.loc 1 1765 0
 11174 5df4 2B30C7E5 		strb	r3, [r7, #43]
1787:../uvc.c      **** 		 	 }
 11175              		.loc 1 1787 0
 11176 5df8 28308DE5 		str	r3, [sp, #40]
1781:../uvc.c      **** 		 	 if(Len == 2){
 11177              		.loc 1 1781 0
 11178 5dfc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11179              	.LVL1316:
1787:../uvc.c      **** 		 	 }
 11180              		.loc 1 1787 0
 11181 5e00 00C0A0E3 		mov	ip, #0
1786:../uvc.c      **** 		 		 sendData1 = glEp0Buffer[2];
 11182              		.loc 1 1786 0
 11183 5e04 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 11184              	.LVL1317:
1787:../uvc.c      **** 		 	 }
 11185              		.loc 1 1787 0
 11186 5e08 2A40D7E5 		ldrb	r4, [r7, #42]	@ zero_extendqisi2
 11187              	.LVL1318:
 11188 5e0c 6DFDFFEA 		b	.L888
 11189              	.LVL1319:
 11190              	.L1005:
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11191              		.loc 1 1684 0
 11192 5e10 80ED1FE5 		ldr	lr, .L1018+120
 11193 5e14 5D27DEE5 		ldrb	r2, [lr, #1885]	@ zero_extendqisi2
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11194              		.loc 1 1685 0
 11195 5e18 5E37DEE5 		ldrb	r3, [lr, #1886]	@ zero_extendqisi2
 11196              	.LVL1320:
 11197              	.L968:
1708:../uvc.c      **** 				  if(Len == 2){
 11198              		.loc 1 1708 0
 11199 5e1c 0C00A0E1 		mov	r0, ip
 11200              	.L965:
 11201 5e20 981D1FE5 		ldr	r1, .L1018+112
1684:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11202              		.loc 1 1684 0
 11203 5e24 2820C7E5 		strb	r2, [r7, #40]
1685:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11204              		.loc 1 1685 0
 11205 5e28 2930C7E5 		strb	r3, [r7, #41]
 11206 5e2c 42FFFFEA 		b	.L967
 11207              	.LVL1321:
 11208              	.L881:
1466:../uvc.c      **** 			 	 			 if(Len == 2)
 11209              		.loc 1 1466 0
 11210 5e30 CB30D7E5 		ldrb	r3, [r7, #203]	@ zero_extendqisi2
 11211 5e34 000053E3 		cmp	r3, #0
 11212 5e38 3A00001A 		bne	.L1008
1482:../uvc.c      **** 			 	 			 {
 11213              		.loc 1 1482 0
 11214 5e3c 02005CE3 		cmp	ip, #2
 11215 5e40 FA01000A 		beq	.L1009
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11216              		.loc 1 1490 0
 11217 5e44 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11218              		.loc 1 1355 0
 11219 5e48 FF40A013 		movne	r4, #255
 11220              	.LVL1322:
 11221 5e4c 0450A011 		movne	r5, r4
 11222              	.LVL1323:
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11223              		.loc 1 1490 0
 11224 5e50 E301000A 		beq	.L1010
 11225              	.LVL1324:
 11226              	.L893:
1500:../uvc.c      **** 			 	 		 }
 11227              		.loc 1 1500 0
 11228 5e54 0130A0E3 		mov	r3, #1
 11229 5e58 CB30C7E5 		strb	r3, [r7, #203]
 11230              	.LVL1325:
 11231              	.L891:
1639:../uvc.c      **** 
 11232              		.loc 1 1639 0
 11233 5e5c 0C00A0E1 		mov	r0, ip
 11234 5e60 D81D1FE5 		ldr	r1, .L1018+112
 11235 5e64 1CC08DE5 		str	ip, [sp, #28]
 11236 5e68 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11237              	.LVL1326:
1642:../uvc.c      **** //#endif
 11238              		.loc 1 1642 0
 11239 5e6c 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11240 5e70 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11241 5e74 1CC09DE5 		ldr	ip, [sp, #28]
 11242 5e78 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11243 5e7c 03108DE8 		stmia	sp, {r0, r1, ip}
 11244 5e80 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11245 5e84 0400A0E3 		mov	r0, #4
 11246 5e88 041E1FE5 		ldr	r1, .L1018+108
 11247 5e8c FEFFFFEB 		bl	CyU3PDebugPrint
 11248              	.LVL1327:
 11249 5e90 00C0A0E3 		mov	ip, #0
 11250 5e94 28C08DE5 		str	ip, [sp, #40]
 11251 5e98 4AFDFFEA 		b	.L888
 11252              	.LVL1328:
 11253              	.L855:
 11254              	.LBE188:
 11255              	.LBE208:
 11256              	.LBB209:
 11257              	.LBB163:
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11258              		.loc 1 1647 0
 11259 5e9c 02005CE3 		cmp	ip, #2
1648:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinHi;//ExUCtrlParArry[locCtrlID][4];
 11260              		.loc 1 1648 0
 11261 5ea0 4727DA05 		ldreqb	r2, [r10, #1863]	@ zero_extendqisi2
1672:../uvc.c      **** 		 	 if(Len == 2){
 11262              		.loc 1 1672 0
 11263 5ea4 0C00A001 		moveq	r0, ip
1649:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control MinLo: 0x%x, MinHi: 0x%x, Len: 0x%x\r\n", glEp0Buffe
 11264              		.loc 1 1649 0
 11265 5ea8 4837DA05 		ldreqb	r3, [r10, #1864]	@ zero_extendqisi2
1647:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCMinLo;//ExUCtrlParArry[locCtrlID][3];
 11266              		.loc 1 1647 0
 11267 5eac 8CFDFF0A 		beq	.L962
1653:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11268              		.loc 1 1653 0
 11269 5eb0 47E7DAE5 		ldrb	lr, [r10, #1863]	@ zero_extendqisi2
1655:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11270              		.loc 1 1655 0
 11271 5eb4 4827DAE5 		ldrb	r2, [r10, #1864]	@ zero_extendqisi2
 11272 5eb8 15FAFFEA 		b	.L963
 11273              	.L854:
1466:../uvc.c      **** 			 	 			 if(Len == 2)
 11274              		.loc 1 1466 0
 11275 5ebc CA30D7E5 		ldrb	r3, [r7, #202]	@ zero_extendqisi2
 11276 5ec0 000053E3 		cmp	r3, #0
 11277 5ec4 3000001A 		bne	.L1011
1482:../uvc.c      **** 			 	 			 {
 11278              		.loc 1 1482 0
 11279 5ec8 02005CE3 		cmp	ip, #2
 11280 5ecc 2901000A 		beq	.L1012
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11281              		.loc 1 1490 0
 11282 5ed0 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11283              		.loc 1 1355 0
 11284 5ed4 FF40A013 		movne	r4, #255
 11285              	.LVL1329:
 11286 5ed8 0450A011 		movne	r5, r4
 11287              	.LVL1330:
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11288              		.loc 1 1490 0
 11289 5edc 1101000A 		beq	.L1013
 11290              	.LVL1331:
 11291              	.L866:
1500:../uvc.c      **** 			 	 		 }
 11292              		.loc 1 1500 0
 11293 5ee0 0130A0E3 		mov	r3, #1
 11294 5ee4 CA30C7E5 		strb	r3, [r7, #202]
 11295              	.LVL1332:
 11296              	.L864:
1639:../uvc.c      **** 
 11297              		.loc 1 1639 0
 11298 5ee8 0C00A0E1 		mov	r0, ip
 11299 5eec 641E1FE5 		ldr	r1, .L1018+112
 11300 5ef0 1CC08DE5 		str	ip, [sp, #28]
 11301 5ef4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11302              	.LVL1333:
1642:../uvc.c      **** //#endif
 11303              		.loc 1 1642 0
 11304 5ef8 2B00D7E5 		ldrb	r0, [r7, #43]	@ zero_extendqisi2
 11305 5efc 2C10D7E5 		ldrb	r1, [r7, #44]	@ zero_extendqisi2
 11306 5f00 1CC09DE5 		ldr	ip, [sp, #28]
 11307 5f04 2820D7E5 		ldrb	r2, [r7, #40]	@ zero_extendqisi2
 11308 5f08 03108DE8 		stmia	sp, {r0, r1, ip}
 11309 5f0c 2930D7E5 		ldrb	r3, [r7, #41]	@ zero_extendqisi2
 11310 5f10 0400A0E3 		mov	r0, #4
 11311 5f14 901E1FE5 		ldr	r1, .L1018+108
 11312 5f18 FEFFFFEB 		bl	CyU3PDebugPrint
 11313              	.LVL1334:
 11314 5f1c 00C0A0E3 		mov	ip, #0
 11315 5f20 28C08DE5 		str	ip, [sp, #40]
 11316 5f24 56FDFFEA 		b	.L861
 11317              	.LVL1335:
 11318              	.L1008:
 11319              	.LBE163:
 11320              	.LBE209:
 11321              	.LBB210:
 11322              	.LBB189:
1467:../uvc.c      **** 			 	 			 {
 11323              		.loc 1 1467 0
 11324 5f28 02005CE3 		cmp	ip, #2
 11325 5f2c CB01000A 		beq	.L1014
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11326              		.loc 1 1473 0
 11327 5f30 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11328              		.loc 1 1355 0
 11329 5f34 FF40A013 		movne	r4, #255
 11330              	.LVL1336:
 11331 5f38 0450A011 		movne	r5, r4
 11332              	.LVL1337:
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11333              		.loc 1 1473 0
 11334 5f3c C6FFFF1A 		bne	.L891
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11335              		.loc 1 1474 0
 11336 5f40 6527DAE5 		ldrb	r2, [r10, #1893]	@ zero_extendqisi2
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11337              		.loc 1 1476 0
 11338 5f44 6647DAE5 		ldrb	r4, [r10, #1894]	@ zero_extendqisi2
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11339              		.loc 1 1475 0
 11340 5f48 0030A0E3 		mov	r3, #0
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11341              		.loc 1 1476 0
 11342 5f4c FF4004E2 		and	r4, r4, #255
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11343              		.loc 1 1474 0
 11344 5f50 2820C7E5 		strb	r2, [r7, #40]
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11345              		.loc 1 1476 0
 11346 5f54 2A40C7E5 		strb	r4, [r7, #42]
1478:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11347              		.loc 1 1478 0
 11348 5f58 FF5002E2 		and	r5, r2, #255
 11349              	.LVL1338:
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11350              		.loc 1 1475 0
 11351 5f5c 2930C7E5 		strb	r3, [r7, #41]
1477:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11352              		.loc 1 1477 0
 11353 5f60 2B30C7E5 		strb	r3, [r7, #43]
 11354 5f64 BCFFFFEA 		b	.L891
 11355              	.LVL1339:
 11356              	.L835:
 11357              	.LBE189:
 11358              	.LBE210:
 11359              	.LBB211:
 11360              	.LBB177:
1482:../uvc.c      **** 			 	 			 {
 11361              		.loc 1 1482 0
 11362 5f68 020055E3 		cmp	r5, #2
 11363 5f6c 2101000A 		beq	.L1015
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11364              		.loc 1 1490 0
 11365 5f70 040055E3 		cmp	r5, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11366              		.loc 1 1355 0
 11367 5f74 FF40A013 		movne	r4, #255
 11368              	.LVL1340:
 11369 5f78 04C0A011 		movne	ip, r4
1490:../uvc.c      **** 			 	 				 glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 11370              		.loc 1 1490 0
 11371 5f7c 0B01000A 		beq	.L1016
 11372              	.LVL1341:
 11373              	.L839:
1500:../uvc.c      **** 			 	 		 }
 11374              		.loc 1 1500 0
 11375 5f80 0130A0E3 		mov	r3, #1
 11376 5f84 B630C7E5 		strb	r3, [r7, #182]
 11377 5f88 7BFFFFEA 		b	.L837
 11378              	.LVL1342:
 11379              	.L1011:
 11380              	.LBE177:
 11381              	.LBE211:
 11382              	.LBB212:
 11383              	.LBB164:
1467:../uvc.c      **** 			 	 			 {
 11384              		.loc 1 1467 0
 11385 5f8c 02005CE3 		cmp	ip, #2
 11386 5f90 B901000A 		beq	.L1017
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11387              		.loc 1 1473 0
 11388 5f94 04005CE3 		cmp	ip, #4
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11389              		.loc 1 1355 0
 11390 5f98 FF40A013 		movne	r4, #255
 11391              	.LVL1343:
 11392 5f9c 0450A011 		movne	r5, r4
 11393              	.LVL1344:
1473:../uvc.c      **** 			 	 				 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 11394              		.loc 1 1473 0
 11395 5fa0 D0FFFF1A 		bne	.L864
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11396              		.loc 1 1474 0
 11397 5fa4 5127DAE5 		ldrb	r2, [r10, #1873]	@ zero_extendqisi2
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11398              		.loc 1 1476 0
 11399 5fa8 5247DAE5 		ldrb	r4, [r10, #1874]	@ zero_extendqisi2
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11400              		.loc 1 1475 0
 11401 5fac 0030A0E3 		mov	r3, #0
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11402              		.loc 1 1476 0
 11403 5fb0 FF4004E2 		and	r4, r4, #255
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11404              		.loc 1 1474 0
 11405 5fb4 2820CBE5 		strb	r2, [fp, #40]
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11406              		.loc 1 1476 0
 11407 5fb8 2A40CBE5 		strb	r4, [fp, #42]
1478:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11408              		.loc 1 1478 0
 11409 5fbc FF5002E2 		and	r5, r2, #255
 11410              	.LVL1345:
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 11411              		.loc 1 1475 0
 11412 5fc0 2930CBE5 		strb	r3, [fp, #41]
1477:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11413              		.loc 1 1477 0
 11414 5fc4 2B30CBE5 		strb	r3, [fp, #43]
 11415 5fc8 C6FFFFEA 		b	.L864
 11416              	.LVL1346:
 11417              	.L843:
 11418              	.LBE164:
 11419              	.LBE212:
 11420              	.LBB213:
 11421              	.LBB178:
2202:../uvc.c      **** 			   }
 11422              		.loc 1 2202 0
 11423 5fcc 34209DE5 		ldr	r2, [sp, #52]
 11424 5fd0 0400A0E3 		mov	r0, #4
 11425              	.LVL1347:
 11426 5fd4 481F1FE5 		ldr	r1, .L1018+116
 11427 5fd8 FEFFFFEB 		bl	CyU3PDebugPrint
 11428              	.LVL1348:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11429              		.loc 1 1355 0
 11430 5fdc FF40A0E3 		mov	r4, #255
 11431              	.LVL1349:
2202:../uvc.c      **** 			   }
 11432              		.loc 1 2202 0
 11433 5fe0 00E0A0E3 		mov	lr, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11434              		.loc 1 1355 0
 11435 5fe4 04C0A0E1 		mov	ip, r4
2202:../uvc.c      **** 			   }
 11436              		.loc 1 2202 0
 11437 5fe8 24E08DE5 		str	lr, [sp, #36]
 11438 5fec 0E50A0E1 		mov	r5, lr
 11439              	.LVL1350:
 11440 5ff0 0FFDFFEA 		b	.L834
 11441              	.LVL1351:
 11442              	.L996:
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11443              		.loc 1 1757 0
 11444 5ff4 3B27DAE5 		ldrb	r2, [r10, #1851]	@ zero_extendqisi2
1758:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 11445              		.loc 1 1758 0
 11446 5ff8 3C37DAE5 		ldrb	r3, [r10, #1852]	@ zero_extendqisi2
1781:../uvc.c      **** 		 	 if(Len == 2){
 11447              		.loc 1 1781 0
 11448 5ffc 0500A0E1 		mov	r0, r5
 11449 6000 781F1FE5 		ldr	r1, .L1018+112
1757:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCDefVHi;//ExUCtrlParArry[locCtrlID][12];
 11450              		.loc 1 1757 0
 11451 6004 2820C7E5 		strb	r2, [r7, #40]
1758:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The CT/EX control DefVLo: 0x%x, DefVHi: 0x%x, Len: 0x%x\r\n", glEp0Buf
 11452              		.loc 1 1758 0
 11453 6008 2930C7E5 		strb	r3, [r7, #41]
 11454 600c 33FFFFEA 		b	.L960
 11455              	.LVL1352:
 11456              	.L870:
 11457              	.LBE178:
 11458              	.LBE213:
 11459              	.LBB214:
 11460              	.LBB165:
2202:../uvc.c      **** 			   }
 11461              		.loc 1 2202 0
 11462 6010 34209DE5 		ldr	r2, [sp, #52]
 11463 6014 0400A0E3 		mov	r0, #4
 11464              	.LVL1353:
 11465 6018 8C1F1FE5 		ldr	r1, .L1018+116
 11466 601c FEFFFFEB 		bl	CyU3PDebugPrint
 11467              	.LVL1354:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11468              		.loc 1 1355 0
 11469 6020 FF40A0E3 		mov	r4, #255
 11470              	.LVL1355:
2202:../uvc.c      **** 			   }
 11471              		.loc 1 2202 0
 11472 6024 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11473              		.loc 1 1355 0
 11474 6028 0450A0E1 		mov	r5, r4
 11475              	.LVL1356:
2202:../uvc.c      **** 			   }
 11476              		.loc 1 2202 0
 11477 602c 28C08DE5 		str	ip, [sp, #40]
 11478 6030 13FDFFEA 		b	.L861
 11479              	.LVL1357:
 11480              	.L897:
 11481              	.LBE165:
 11482              	.LBE214:
 11483              	.LBB215:
 11484              	.LBB190:
 11485 6034 34209DE5 		ldr	r2, [sp, #52]
 11486 6038 0400A0E3 		mov	r0, #4
 11487              	.LVL1358:
 11488 603c B01F1FE5 		ldr	r1, .L1018+116
 11489 6040 FEFFFFEB 		bl	CyU3PDebugPrint
 11490              	.LVL1359:
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11491              		.loc 1 1355 0
 11492 6044 FF40A0E3 		mov	r4, #255
 11493              	.LVL1360:
2202:../uvc.c      **** 			   }
 11494              		.loc 1 2202 0
 11495 6048 00C0A0E3 		mov	ip, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11496              		.loc 1 1355 0
 11497 604c 0450A0E1 		mov	r5, r4
 11498              	.LVL1361:
2202:../uvc.c      **** 			   }
 11499              		.loc 1 2202 0
 11500 6050 28C08DE5 		str	ip, [sp, #40]
 11501 6054 DBFCFFEA 		b	.L888
 11502              	.LVL1362:
 11503              	.L674:
 11504              	.LBE190:
 11505              	.LBE215:
 11506              	.LBE234:
 11507              	.LBE413:
 11508              	.LBB414:
 11509              	.LBB391:
 11510              	.LBB384:
 11511              	.LBB380:
1524:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 11512              		.loc 1 1524 0
 11513 6058 28009DE5 		ldr	r0, [sp, #40]
 11514 605c 24109DE5 		ldr	r1, [sp, #36]
 11515 6060 20308DE5 		str	r3, [sp, #32]
 11516 6064 FEFFFFEB 		bl	SensorGetControl
 11517              	.LVL1363:
1526:../uvc.c      **** 						 }
 11518              		.loc 1 1526 0
 11519 6068 0120A0E3 		mov	r2, #1
 11520 606c A120C7E5 		strb	r2, [r7, #161]
 11521 6070 20309DE5 		ldr	r3, [sp, #32]
1524:../uvc.c      **** 							pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 11522              		.loc 1 1524 0
 11523 6074 00C0A0E1 		mov	ip, r0
 11524              	.LVL1364:
1525:../uvc.c      **** 							curFlag[CtrlID] = CyTrue;
 11525              		.loc 1 1525 0
 11526 6078 2D05CAE5 		strb	r0, [r10, #1325]
 11527 607c B4FDFFEA 		b	.L675
 11528              	.LVL1365:
 11529              	.L1004:
1697:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11530              		.loc 1 1697 0
 11531 6080 F01F1FE5 		ldr	r1, .L1018+120
1708:../uvc.c      **** 				  if(Len == 2){
 11532              		.loc 1 1708 0
 11533 6084 0300A0E1 		mov	r0, r3
1697:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCMaxHi;//ExUCtrlParArry[locCtrlID][6];
 11534              		.loc 1 1697 0
 11535 6088 25C5D1E5 		ldrb	ip, [r1, #1317]	@ zero_extendqisi2
1698:../uvc.c      **** 					 //CyU3PDebugPrint (4, "The PU control MaxLo: 0x%x, MaxHi: 0x%x, Len: 0x%x\r\n", glEp0Buffer[0
 11536              		.loc 1 1698 0
 11537 608c 2625D1E5 		ldrb	r2, [r1, #1318]	@ zero_extendqisi2
 11538 6090 7FFCFFEA 		b	.L947
 11539              	.LVL1366:
 11540              	.L679:
2202:../uvc.c      **** 			   }
 11541              		.loc 1 2202 0
 11542 6094 0400A0E3 		mov	r0, #4
 11543              	.LVL1367:
 11544 6098 F8159FE5 		ldr	r1, .L1020
 11545 609c FEFFFFEB 		bl	CyU3PDebugPrint
 11546              	.LVL1368:
 11547 60a0 0050A0E3 		mov	r5, #0
1355:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11548              		.loc 1 1355 0
 11549 60a4 FF30A0E3 		mov	r3, #255
 11550 60a8 0320A0E1 		mov	r2, r3
2202:../uvc.c      **** 			   }
 11551              		.loc 1 2202 0
 11552 60ac 05C0A0E1 		mov	ip, r5
 11553 60b0 18FBFFEA 		b	.L673
 11554              	.LVL1369:
 11555              	.L1002:
 11556              	.LBE380:
 11557              	.LBE384:
 11558              	.LBE391:
 11559              	.LBE414:
 11560              	.LBB415:
 11561              	.LBB235:
 11562              	.LBB216:
 11563              	.LBB166:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11564              		.loc 1 1803 0
 11565 60b4 30108DE8 		stmia	sp, {r4, r5, ip}
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11566              		.loc 1 1796 0
 11567 60b8 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 11568              	.LVL1370:
1797:../uvc.c      **** 				 }else{
 11569              		.loc 1 1797 0
 11570 60bc 2940DBE5 		ldrb	r4, [fp, #41]	@ zero_extendqisi2
 11571              	.LVL1371:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11572              		.loc 1 1803 0
 11573 60c0 30309DE5 		ldr	r3, [sp, #48]
 11574 60c4 0400A0E3 		mov	r0, #4
 11575              	.LVL1372:
 11576 60c8 CC159FE5 		ldr	r1, .L1020+4
 11577 60cc 2A20A0E3 		mov	r2, #42
 11578 60d0 1CC08DE5 		str	ip, [sp, #28]
1797:../uvc.c      **** 				 }else{
 11579              		.loc 1 1797 0
 11580 60d4 28408DE5 		str	r4, [sp, #40]
 11581              	.LVL1373:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11582              		.loc 1 1803 0
 11583 60d8 FEFFFFEB 		bl	CyU3PDebugPrint
 11584              	.LVL1374:
1984:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11585              		.loc 1 1984 0
 11586 60dc 5137DAE5 		ldrb	r3, [r10, #1873]	@ zero_extendqisi2
 11587 60e0 1CC09DE5 		ldr	ip, [sp, #28]
 11588 60e4 03005CE1 		cmp	ip, r3
 11589 60e8 1400000A 		beq	.L873
1985:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11590              		.loc 1 1985 0
 11591 60ec AC459FE5 		ldr	r4, .L1020+8
 11592 60f0 0010E0E3 		mvn	r1, #0
 11593 60f4 1C0094E5 		ldr	r0, [r4, #28]
 11594 60f8 1CC08DE5 		str	ip, [sp, #28]
 11595              	.LVL1375:
 11596 60fc FEFFFFEB 		bl	_txe_mutex_get
 11597              	.LVL1376:
1986:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11598              		.loc 1 1986 0
 11599 6100 1CC09DE5 		ldr	ip, [sp, #28]
 11600 6104 34209DE5 		ldr	r2, [sp, #52]
 11601 6108 00C08DE5 		str	ip, [sp]
 11602 610c 0530A0E1 		mov	r3, r5
 11603 6110 04208DE5 		str	r2, [sp, #4]
 11604 6114 0400A0E1 		mov	r0, r4
 11605 6118 30209DE5 		ldr	r2, [sp, #48]
 11606 611c 2A10A0E3 		mov	r1, #42
 11607 6120 FEFFFFEB 		bl	cmdSet
 11608              	.LVL1377:
1987:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11609              		.loc 1 1987 0
 11610 6124 1C0094E5 		ldr	r0, [r4, #28]
 11611 6128 FEFFFFEB 		bl	_txe_mutex_put
 11612              	.LVL1378:
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11613              		.loc 1 1988 0
 11614 612c 1CC09DE5 		ldr	ip, [sp, #28]
 11615 6130 6C359FE5 		ldr	r3, .L1020+12
1989:../uvc.c      **** 									 }
 11616              		.loc 1 1989 0
 11617 6134 34409DE5 		ldr	r4, [sp, #52]
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11618              		.loc 1 1988 0
 11619 6138 51C7C3E5 		strb	ip, [r3, #1873]
1989:../uvc.c      **** 									 }
 11620              		.loc 1 1989 0
 11621 613c 5247C3E5 		strb	r4, [r3, #1874]
 11622              	.L873:
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11623              		.loc 1 1991 0
 11624 6140 0130A0E3 		mov	r3, #1
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11625              		.loc 1 1803 0
 11626 6144 0240A0E3 		mov	r4, #2
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11627              		.loc 1 1991 0
 11628 6148 5537CAE5 		strb	r3, [r10, #1877]
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11629              		.loc 1 1803 0
 11630 614c 38408DE5 		str	r4, [sp, #56]
 11631 6150 63FDFFEA 		b	.L875
 11632              	.LVL1379:
 11633              	.L1000:
 11634              	.LBE166:
 11635              	.LBE216:
 11636              	.LBB217:
 11637              	.LBB191:
 11638 6154 30108DE8 		stmia	sp, {r4, r5, ip}
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11639              		.loc 1 1796 0
 11640 6158 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 11641              	.LVL1380:
1797:../uvc.c      **** 				 }else{
 11642              		.loc 1 1797 0
 11643 615c 2940DBE5 		ldrb	r4, [fp, #41]	@ zero_extendqisi2
 11644              	.LVL1381:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11645              		.loc 1 1803 0
 11646 6160 30309DE5 		ldr	r3, [sp, #48]
 11647 6164 0400A0E3 		mov	r0, #4
 11648              	.LVL1382:
 11649 6168 2C159FE5 		ldr	r1, .L1020+4
 11650 616c 2B20A0E3 		mov	r2, #43
 11651 6170 1CC08DE5 		str	ip, [sp, #28]
1797:../uvc.c      **** 				 }else{
 11652              		.loc 1 1797 0
 11653 6174 28408DE5 		str	r4, [sp, #40]
 11654              	.LVL1383:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11655              		.loc 1 1803 0
 11656 6178 FEFFFFEB 		bl	CyU3PDebugPrint
 11657              	.LVL1384:
1984:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11658              		.loc 1 1984 0
 11659 617c 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 11660 6180 1CC09DE5 		ldr	ip, [sp, #28]
 11661 6184 03005CE1 		cmp	ip, r3
 11662 6188 1400000A 		beq	.L900
1985:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11663              		.loc 1 1985 0
 11664 618c 0C459FE5 		ldr	r4, .L1020+8
 11665 6190 0010E0E3 		mvn	r1, #0
 11666 6194 1C0094E5 		ldr	r0, [r4, #28]
 11667 6198 1CC08DE5 		str	ip, [sp, #28]
 11668              	.LVL1385:
 11669 619c FEFFFFEB 		bl	_txe_mutex_get
 11670              	.LVL1386:
1986:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11671              		.loc 1 1986 0
 11672 61a0 1CC09DE5 		ldr	ip, [sp, #28]
 11673 61a4 34209DE5 		ldr	r2, [sp, #52]
 11674 61a8 00C08DE5 		str	ip, [sp]
 11675 61ac 0530A0E1 		mov	r3, r5
 11676 61b0 04208DE5 		str	r2, [sp, #4]
 11677 61b4 0400A0E1 		mov	r0, r4
 11678 61b8 30209DE5 		ldr	r2, [sp, #48]
 11679 61bc 2B10A0E3 		mov	r1, #43
 11680 61c0 FEFFFFEB 		bl	cmdSet
 11681              	.LVL1387:
1987:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11682              		.loc 1 1987 0
 11683 61c4 1C0094E5 		ldr	r0, [r4, #28]
 11684 61c8 FEFFFFEB 		bl	_txe_mutex_put
 11685              	.LVL1388:
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11686              		.loc 1 1988 0
 11687 61cc 1CC09DE5 		ldr	ip, [sp, #28]
 11688 61d0 CC349FE5 		ldr	r3, .L1020+12
1989:../uvc.c      **** 									 }
 11689              		.loc 1 1989 0
 11690 61d4 34409DE5 		ldr	r4, [sp, #52]
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11691              		.loc 1 1988 0
 11692 61d8 65C7C3E5 		strb	ip, [r3, #1893]
1989:../uvc.c      **** 									 }
 11693              		.loc 1 1989 0
 11694 61dc 6647C3E5 		strb	r4, [r3, #1894]
 11695              	.L900:
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11696              		.loc 1 1991 0
 11697 61e0 0130A0E3 		mov	r3, #1
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11698              		.loc 1 1803 0
 11699 61e4 0240A0E3 		mov	r4, #2
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11700              		.loc 1 1991 0
 11701 61e8 6937CAE5 		strb	r3, [r10, #1897]
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11702              		.loc 1 1803 0
 11703 61ec 38408DE5 		str	r4, [sp, #56]
 11704 61f0 0EFDFFEA 		b	.L902
 11705              	.LVL1389:
 11706              	.L998:
 11707              	.LBE191:
 11708              	.LBE217:
 11709              	.LBB218:
 11710              	.LBB179:
 11711 61f4 2CC09DE5 		ldr	ip, [sp, #44]
 11712 61f8 00408DE5 		str	r4, [sp]
 11713 61fc 04C08DE5 		str	ip, [sp, #4]
 11714 6200 08508DE5 		str	r5, [sp, #8]
1797:../uvc.c      **** 				 }else{
 11715              		.loc 1 1797 0
 11716 6204 2940DBE5 		ldrb	r4, [fp, #41]	@ zero_extendqisi2
 11717              	.LVL1390:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11718              		.loc 1 1803 0
 11719 6208 30309DE5 		ldr	r3, [sp, #48]
 11720 620c 0400A0E3 		mov	r0, #4
 11721              	.LVL1391:
 11722 6210 84149FE5 		ldr	r1, .L1020+4
 11723 6214 1620A0E3 		mov	r2, #22
1796:../uvc.c      **** 					 Data1 = glEp0Buffer[1];
 11724              		.loc 1 1796 0
 11725 6218 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 11726              	.LVL1392:
1797:../uvc.c      **** 				 }else{
 11727              		.loc 1 1797 0
 11728 621c 24408DE5 		str	r4, [sp, #36]
 11729              	.LVL1393:
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11730              		.loc 1 1803 0
 11731 6220 FEFFFFEB 		bl	CyU3PDebugPrint
 11732              	.LVL1394:
1984:../uvc.c      **** 										 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 11733              		.loc 1 1984 0
 11734 6224 3D37DAE5 		ldrb	r3, [r10, #1853]	@ zero_extendqisi2
 11735 6228 030055E1 		cmp	r5, r3
 11736 622c 1100000A 		beq	.L846
1985:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set data
 11737              		.loc 1 1985 0
 11738 6230 68449FE5 		ldr	r4, .L1020+8
 11739 6234 0010E0E3 		mvn	r1, #0
 11740 6238 1C0094E5 		ldr	r0, [r4, #28]
 11741 623c FEFFFFEB 		bl	_txe_mutex_get
 11742              	.LVL1395:
1986:../uvc.c      **** 										 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11743              		.loc 1 1986 0
 11744 6240 34C09DE5 		ldr	ip, [sp, #52]
 11745 6244 30209DE5 		ldr	r2, [sp, #48]
 11746 6248 04C08DE5 		str	ip, [sp, #4]
 11747 624c 2C309DE5 		ldr	r3, [sp, #44]
 11748 6250 0400A0E1 		mov	r0, r4
 11749 6254 1610A0E3 		mov	r1, #22
 11750 6258 00508DE5 		str	r5, [sp]
 11751 625c FEFFFFEB 		bl	cmdSet
 11752              	.LVL1396:
1987:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;//AGC. CtrlParArry[CtrlID][14]
 11753              		.loc 1 1987 0
 11754 6260 1C0094E5 		ldr	r0, [r4, #28]
 11755 6264 FEFFFFEB 		bl	_txe_mutex_put
 11756              	.LVL1397:
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11757              		.loc 1 1988 0
 11758 6268 34E49FE5 		ldr	lr, .L1020+12
1989:../uvc.c      **** 									 }
 11759              		.loc 1 1989 0
 11760 626c 34409DE5 		ldr	r4, [sp, #52]
1988:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = 0;
 11761              		.loc 1 1988 0
 11762 6270 3D57CEE5 		strb	r5, [lr, #1853]
1989:../uvc.c      **** 									 }
 11763              		.loc 1 1989 0
 11764 6274 3E47CEE5 		strb	r4, [lr, #1854]
 11765              	.L846:
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11766              		.loc 1 1991 0
 11767 6278 0130A0E3 		mov	r3, #1
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11768              		.loc 1 1803 0
 11769 627c 02C0A0E3 		mov	ip, #2
1991:../uvc.c      **** 				 	 			 }else if(Len == 4){
 11770              		.loc 1 1991 0
 11771 6280 4137CAE5 		strb	r3, [r10, #1857]
1803:../uvc.c      **** 						 CtrlID, RegAdd0, RegAdd1, devAdd, Len);
 11772              		.loc 1 1803 0
 11773 6284 38C08DE5 		str	ip, [sp, #56]
 11774 6288 BDFCFFEA 		b	.L848
 11775              	.LVL1398:
 11776              	.L999:
1993:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11777              		.loc 1 1993 0
 11778 628c 0CC49FE5 		ldr	ip, .L1020+8
 11779 6290 0010E0E3 		mvn	r1, #0
 11780 6294 1C009CE5 		ldr	r0, [ip, #28]
 11781 6298 3CC08DE5 		str	ip, [sp, #60]
 11782 629c FEFFFFEB 		bl	_txe_mutex_get
 11783              	.LVL1399:
1994:../uvc.c      **** 									 {
 11784              		.loc 1 1994 0
 11785 62a0 3D37DAE5 		ldrb	r3, [r10, #1853]	@ zero_extendqisi2
 11786 62a4 030055E1 		cmp	r5, r3
1802:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 11787              		.loc 1 1802 0
 11788 62a8 34309D05 		ldreq	r3, [sp, #52]
1994:../uvc.c      **** 									 {
 11789              		.loc 1 1994 0
 11790 62ac 0A00000A 		beq	.L849
1997:../uvc.c      **** 										 dataIdx++;
 11791              		.loc 1 1997 0
 11792 62b0 34C09DE5 		ldr	ip, [sp, #52]
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11793              		.loc 1 1996 0
 11794 62b4 E8E39FE5 		ldr	lr, .L1020+12
1997:../uvc.c      **** 										 dataIdx++;
 11795              		.loc 1 1997 0
 11796 62b8 00508DE5 		str	r5, [sp]
 11797 62bc 04C08DE5 		str	ip, [sp, #4]
 11798 62c0 2C309DE5 		ldr	r3, [sp, #44]
 11799 62c4 30209DE5 		ldr	r2, [sp, #48]
 11800 62c8 3C009DE5 		ldr	r0, [sp, #60]
 11801 62cc 1610A0E3 		mov	r1, #22
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 11802              		.loc 1 1996 0
 11803 62d0 3D57CEE5 		strb	r5, [lr, #1853]
1997:../uvc.c      **** 										 dataIdx++;
 11804              		.loc 1 1997 0
 11805 62d4 FEFFFFEB 		bl	cmdSet
 11806              	.LVL1400:
1998:../uvc.c      **** 									 }
 11807              		.loc 1 1998 0
 11808 62d8 28309DE5 		ldr	r3, [sp, #40]
 11809              	.LVL1401:
 11810              	.L849:
2000:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 11811              		.loc 1 2000 0
 11812 62dc 3E27DAE5 		ldrb	r2, [r10, #1854]	@ zero_extendqisi2
 11813 62e0 24C09DE5 		ldr	ip, [sp, #36]
 11814 62e4 02005CE1 		cmp	ip, r2
 11815 62e8 0800000A 		beq	.L850
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11816              		.loc 1 2001 0
 11817 62ec B0E39FE5 		ldr	lr, .L1020+12
2002:../uvc.c      **** 									 }
 11818              		.loc 1 2002 0
 11819 62f0 04308DE5 		str	r3, [sp, #4]
 11820 62f4 00C08DE5 		str	ip, [sp]
 11821 62f8 0420A0E1 		mov	r2, r4
 11822 62fc 2C309DE5 		ldr	r3, [sp, #44]
 11823              	.LVL1402:
 11824 6300 98039FE5 		ldr	r0, .L1020+8
 11825 6304 1610A0E3 		mov	r1, #22
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 11826              		.loc 1 2001 0
 11827 6308 3EC7CEE5 		strb	ip, [lr, #1854]
2002:../uvc.c      **** 									 }
 11828              		.loc 1 2002 0
 11829 630c FEFFFFEB 		bl	cmdSet
 11830              	.LVL1403:
 11831              	.L850:
2005:../uvc.c      **** 
 11832              		.loc 1 2005 0
 11833 6310 3C409DE5 		ldr	r4, [sp, #60]
 11834              	.LVL1404:
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11835              		.loc 1 2004 0
 11836 6314 0130A0E3 		mov	r3, #1
2005:../uvc.c      **** 
 11837              		.loc 1 2005 0
 11838 6318 1C0094E5 		ldr	r0, [r4, #28]
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11839              		.loc 1 2004 0
 11840 631c 4137CAE5 		strb	r3, [r10, #1857]
2005:../uvc.c      **** 
 11841              		.loc 1 2005 0
 11842 6320 FEFFFFEB 		bl	_txe_mutex_put
 11843              	.LVL1405:
 11844 6324 96FCFFEA 		b	.L848
 11845              	.LVL1406:
 11846              	.L1013:
 11847              	.LBE179:
 11848              	.LBE218:
 11849              	.LBB219:
 11850              	.LBB167:
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11851              		.loc 1 1491 0
 11852 6328 0510A0E1 		mov	r1, r5
 11853 632c 0400A0E1 		mov	r0, r4
 11854 6330 20308DE5 		str	r3, [sp, #32]
 11855 6334 1CC08DE5 		str	ip, [sp, #28]
 11856 6338 FEFFFFEB 		bl	SensorGetControl
 11857              	.LVL1407:
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11858              		.loc 1 1493 0
 11859 633c 0510A0E1 		mov	r1, r5
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11860              		.loc 1 1491 0
 11861 6340 0020A0E1 		mov	r2, r0
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11862              		.loc 1 1493 0
 11863 6344 30009DE5 		ldr	r0, [sp, #48]
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11864              		.loc 1 1491 0
 11865 6348 2820CBE5 		strb	r2, [fp, #40]
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11866              		.loc 1 1492 0
 11867 634c 5127CAE5 		strb	r2, [r10, #1873]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11868              		.loc 1 1493 0
 11869 6350 FEFFFFEB 		bl	SensorGetControl
 11870              	.LVL1408:
1497:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11871              		.loc 1 1497 0
 11872 6354 2850DBE5 		ldrb	r5, [fp, #40]	@ zero_extendqisi2
 11873              	.LVL1409:
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11874              		.loc 1 1493 0
 11875 6358 2A00CBE5 		strb	r0, [fp, #42]
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11876              		.loc 1 1495 0
 11877 635c 20309DE5 		ldr	r3, [sp, #32]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11878              		.loc 1 1493 0
 11879 6360 0040A0E1 		mov	r4, r0
 11880              	.LVL1410:
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11881              		.loc 1 1495 0
 11882 6364 2930CBE5 		strb	r3, [fp, #41]
1496:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11883              		.loc 1 1496 0
 11884 6368 2B30CBE5 		strb	r3, [fp, #43]
1494:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11885              		.loc 1 1494 0
 11886 636c 5207CAE5 		strb	r0, [r10, #1874]
 11887 6370 1CC09DE5 		ldr	ip, [sp, #28]
 11888 6374 D9FEFFEA 		b	.L866
 11889              	.LVL1411:
 11890              	.L1012:
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11891              		.loc 1 1484 0
 11892 6378 0400A0E1 		mov	r0, r4
 11893 637c 0510A0E1 		mov	r1, r5
 11894 6380 20308DE5 		str	r3, [sp, #32]
 11895 6384 1CC08DE5 		str	ip, [sp, #28]
 11896 6388 FEFFFFEB 		bl	SensorGetControl
 11897              	.LVL1412:
 11898 638c 2800CBE5 		strb	r0, [fp, #40]
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11899              		.loc 1 1486 0
 11900 6390 20309DE5 		ldr	r3, [sp, #32]
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11901              		.loc 1 1485 0
 11902 6394 5107CAE5 		strb	r0, [r10, #1873]
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11903              		.loc 1 1486 0
 11904 6398 2930CBE5 		strb	r3, [fp, #41]
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11905              		.loc 1 1484 0
 11906 639c 0050A0E1 		mov	r5, r0
 11907              	.LVL1413:
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11908              		.loc 1 1487 0
 11909 63a0 5237CAE5 		strb	r3, [r10, #1874]
 11910              	.LVL1414:
1489:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11911              		.loc 1 1489 0
 11912 63a4 0340A0E1 		mov	r4, r3
 11913              	.LVL1415:
 11914 63a8 1CC09DE5 		ldr	ip, [sp, #28]
 11915 63ac CBFEFFEA 		b	.L866
 11916              	.LVL1416:
 11917              	.L1016:
 11918              	.LBE167:
 11919              	.LBE219:
 11920              	.LBB220:
 11921              	.LBB180:
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11922              		.loc 1 1491 0
 11923 63b0 0400A0E1 		mov	r0, r4
 11924 63b4 2C109DE5 		ldr	r1, [sp, #44]
 11925 63b8 20308DE5 		str	r3, [sp, #32]
 11926 63bc FEFFFFEB 		bl	SensorGetControl
 11927              	.LVL1417:
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11928              		.loc 1 1493 0
 11929 63c0 2C109DE5 		ldr	r1, [sp, #44]
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11930              		.loc 1 1491 0
 11931 63c4 0020A0E1 		mov	r2, r0
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11932              		.loc 1 1493 0
 11933 63c8 30009DE5 		ldr	r0, [sp, #48]
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11934              		.loc 1 1491 0
 11935 63cc 2820CBE5 		strb	r2, [fp, #40]
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 11936              		.loc 1 1492 0
 11937 63d0 3D27CAE5 		strb	r2, [r10, #1853]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11938              		.loc 1 1493 0
 11939 63d4 FEFFFFEB 		bl	SensorGetControl
 11940              	.LVL1418:
1497:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 11941              		.loc 1 1497 0
 11942 63d8 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 11943              	.LVL1419:
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11944              		.loc 1 1493 0
 11945 63dc 2A00CBE5 		strb	r0, [fp, #42]
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11946              		.loc 1 1495 0
 11947 63e0 20309DE5 		ldr	r3, [sp, #32]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 11948              		.loc 1 1493 0
 11949 63e4 0040A0E1 		mov	r4, r0
 11950              	.LVL1420:
1494:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11951              		.loc 1 1494 0
 11952 63e8 3E07CAE5 		strb	r0, [r10, #1854]
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 11953              		.loc 1 1495 0
 11954 63ec 2930CBE5 		strb	r3, [fp, #41]
1496:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11955              		.loc 1 1496 0
 11956 63f0 2B30CBE5 		strb	r3, [fp, #43]
 11957 63f4 E1FEFFEA 		b	.L839
 11958              	.LVL1421:
 11959              	.L1015:
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11960              		.loc 1 1484 0
 11961 63f8 0400A0E1 		mov	r0, r4
 11962 63fc 2C109DE5 		ldr	r1, [sp, #44]
 11963 6400 20308DE5 		str	r3, [sp, #32]
 11964 6404 FEFFFFEB 		bl	SensorGetControl
 11965              	.LVL1422:
 11966 6408 2800CBE5 		strb	r0, [fp, #40]
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11967              		.loc 1 1486 0
 11968 640c 20309DE5 		ldr	r3, [sp, #32]
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 11969              		.loc 1 1485 0
 11970 6410 3D07CAE5 		strb	r0, [r10, #1853]
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 11971              		.loc 1 1484 0
 11972 6414 00C0A0E1 		mov	ip, r0
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 11973              		.loc 1 1486 0
 11974 6418 2930CBE5 		strb	r3, [fp, #41]
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 11975              		.loc 1 1487 0
 11976 641c 3E37CAE5 		strb	r3, [r10, #1854]
 11977              	.LVL1423:
1489:../uvc.c      **** 			 	 			 }else if(Len == 4){
 11978              		.loc 1 1489 0
 11979 6420 0340A0E1 		mov	r4, r3
 11980              	.LVL1424:
 11981 6424 D5FEFFEA 		b	.L839
 11982              	.LVL1425:
 11983              	.L1003:
 11984              	.LBE180:
 11985              	.LBE220:
 11986              	.LBB221:
 11987              	.LBB168:
1993:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 11988              		.loc 1 1993 0
 11989 6428 70E29FE5 		ldr	lr, .L1020+8
 11990 642c 0010E0E3 		mvn	r1, #0
 11991 6430 1C009EE5 		ldr	r0, [lr, #28]
 11992 6434 3CE08DE5 		str	lr, [sp, #60]
 11993 6438 1CC08DE5 		str	ip, [sp, #28]
 11994              	.LVL1426:
 11995 643c FEFFFFEB 		bl	_txe_mutex_get
 11996              	.LVL1427:
1994:../uvc.c      **** 									 {
 11997              		.loc 1 1994 0
 11998 6440 5137DAE5 		ldrb	r3, [r10, #1873]	@ zero_extendqisi2
 11999 6444 1CC09DE5 		ldr	ip, [sp, #28]
 12000 6448 03005CE1 		cmp	ip, r3
1802:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 12001              		.loc 1 1802 0
 12002 644c 34309D05 		ldreq	r3, [sp, #52]
1994:../uvc.c      **** 									 {
 12003              		.loc 1 1994 0
 12004 6450 0C00000A 		beq	.L876
1997:../uvc.c      **** 										 dataIdx++;
 12005              		.loc 1 1997 0
 12006 6454 34109DE5 		ldr	r1, [sp, #52]
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12007              		.loc 1 1996 0
 12008 6458 44E29FE5 		ldr	lr, .L1020+12
1997:../uvc.c      **** 										 dataIdx++;
 12009              		.loc 1 1997 0
 12010 645c 00C08DE5 		str	ip, [sp]
 12011 6460 04108DE5 		str	r1, [sp, #4]
 12012 6464 0530A0E1 		mov	r3, r5
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12013              		.loc 1 1996 0
 12014 6468 51C7CEE5 		strb	ip, [lr, #1873]
1997:../uvc.c      **** 										 dataIdx++;
 12015              		.loc 1 1997 0
 12016 646c 30209DE5 		ldr	r2, [sp, #48]
 12017 6470 3C009DE5 		ldr	r0, [sp, #60]
 12018 6474 2A10A0E3 		mov	r1, #42
 12019 6478 1CC08DE5 		str	ip, [sp, #28]
 12020 647c FEFFFFEB 		bl	cmdSet
 12021              	.LVL1428:
1998:../uvc.c      **** 									 }
 12022              		.loc 1 1998 0
 12023 6480 2C309DE5 		ldr	r3, [sp, #44]
 12024 6484 1CC09DE5 		ldr	ip, [sp, #28]
 12025              	.LVL1429:
 12026              	.L876:
2000:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 12027              		.loc 1 2000 0
 12028 6488 5227DAE5 		ldrb	r2, [r10, #1874]	@ zero_extendqisi2
 12029 648c 28109DE5 		ldr	r1, [sp, #40]
 12030 6490 020051E1 		cmp	r1, r2
 12031 6494 0A00000A 		beq	.L877
2002:../uvc.c      **** 									 }
 12032              		.loc 1 2002 0
 12033 6498 0420A0E1 		mov	r2, r4
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12034              		.loc 1 2001 0
 12035 649c 00E29FE5 		ldr	lr, .L1020+12
 12036 64a0 28409DE5 		ldr	r4, [sp, #40]
 12037              	.LVL1430:
2002:../uvc.c      **** 									 }
 12038              		.loc 1 2002 0
 12039 64a4 0A008DE8 		stmia	sp, {r1, r3}
 12040 64a8 F0019FE5 		ldr	r0, .L1020+8
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12041              		.loc 1 2001 0
 12042 64ac 5247CEE5 		strb	r4, [lr, #1874]
2002:../uvc.c      **** 									 }
 12043              		.loc 1 2002 0
 12044 64b0 0530A0E1 		mov	r3, r5
 12045              	.LVL1431:
 12046 64b4 2A10A0E3 		mov	r1, #42
 12047 64b8 1CC08DE5 		str	ip, [sp, #28]
 12048 64bc FEFFFFEB 		bl	cmdSet
 12049              	.LVL1432:
 12050 64c0 1CC09DE5 		ldr	ip, [sp, #28]
 12051              	.L877:
2005:../uvc.c      **** 
 12052              		.loc 1 2005 0
 12053 64c4 3C409DE5 		ldr	r4, [sp, #60]
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12054              		.loc 1 2004 0
 12055 64c8 0130A0E3 		mov	r3, #1
2005:../uvc.c      **** 
 12056              		.loc 1 2005 0
 12057 64cc 1C0094E5 		ldr	r0, [r4, #28]
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12058              		.loc 1 2004 0
 12059 64d0 5537CAE5 		strb	r3, [r10, #1877]
2005:../uvc.c      **** 
 12060              		.loc 1 2005 0
 12061 64d4 1CC08DE5 		str	ip, [sp, #28]
 12062 64d8 FEFFFFEB 		bl	_txe_mutex_put
 12063              	.LVL1433:
 12064 64dc 1CC09DE5 		ldr	ip, [sp, #28]
 12065 64e0 7FFCFFEA 		b	.L875
 12066              	.LVL1434:
 12067              	.L1001:
 12068              	.LBE168:
 12069              	.LBE221:
 12070              	.LBB222:
 12071              	.LBB192:
1993:../uvc.c      **** 									 if(pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo != Data0)
 12072              		.loc 1 1993 0
 12073 64e4 B4E19FE5 		ldr	lr, .L1020+8
 12074 64e8 0010E0E3 		mvn	r1, #0
 12075 64ec 1C009EE5 		ldr	r0, [lr, #28]
 12076 64f0 3CE08DE5 		str	lr, [sp, #60]
 12077 64f4 1CC08DE5 		str	ip, [sp, #28]
 12078              	.LVL1435:
 12079 64f8 FEFFFFEB 		bl	_txe_mutex_get
 12080              	.LVL1436:
1994:../uvc.c      **** 									 {
 12081              		.loc 1 1994 0
 12082 64fc 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
 12083 6500 1CC09DE5 		ldr	ip, [sp, #28]
 12084 6504 03005CE1 		cmp	ip, r3
1802:../uvc.c      **** 				 CyU3PDebugPrint (4, "The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x devADD: 0x%x Len: 0x%x\
 12085              		.loc 1 1802 0
 12086 6508 34309D05 		ldreq	r3, [sp, #52]
1994:../uvc.c      **** 									 {
 12087              		.loc 1 1994 0
 12088 650c 0C00000A 		beq	.L903
1997:../uvc.c      **** 										 dataIdx++;
 12089              		.loc 1 1997 0
 12090 6510 34109DE5 		ldr	r1, [sp, #52]
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12091              		.loc 1 1996 0
 12092 6514 88E19FE5 		ldr	lr, .L1020+12
1997:../uvc.c      **** 										 dataIdx++;
 12093              		.loc 1 1997 0
 12094 6518 00C08DE5 		str	ip, [sp]
 12095 651c 04108DE5 		str	r1, [sp, #4]
 12096 6520 0530A0E1 		mov	r3, r5
1996:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set first byte
 12097              		.loc 1 1996 0
 12098 6524 65C7CEE5 		strb	ip, [lr, #1893]
1997:../uvc.c      **** 										 dataIdx++;
 12099              		.loc 1 1997 0
 12100 6528 30209DE5 		ldr	r2, [sp, #48]
 12101 652c 3C009DE5 		ldr	r0, [sp, #60]
 12102 6530 2B10A0E3 		mov	r1, #43
 12103 6534 1CC08DE5 		str	ip, [sp, #28]
 12104 6538 FEFFFFEB 		bl	cmdSet
 12105              	.LVL1437:
 12106 653c 1CC09DE5 		ldr	ip, [sp, #28]
1998:../uvc.c      **** 									 }
 12107              		.loc 1 1998 0
 12108 6540 0130A0E3 		mov	r3, #1
 12109              	.LVL1438:
 12110              	.L903:
2000:../uvc.c      **** 										 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = Data1;//AGC. CtrlParArry[CtrlID][14]
 12111              		.loc 1 2000 0
 12112 6544 6627DAE5 		ldrb	r2, [r10, #1894]	@ zero_extendqisi2
 12113 6548 28109DE5 		ldr	r1, [sp, #40]
 12114 654c 020051E1 		cmp	r1, r2
 12115 6550 0A00000A 		beq	.L904
2002:../uvc.c      **** 									 }
 12116              		.loc 1 2002 0
 12117 6554 0420A0E1 		mov	r2, r4
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12118              		.loc 1 2001 0
 12119 6558 44E19FE5 		ldr	lr, .L1020+12
 12120 655c 28409DE5 		ldr	r4, [sp, #40]
 12121              	.LVL1439:
2002:../uvc.c      **** 									 }
 12122              		.loc 1 2002 0
 12123 6560 0A008DE8 		stmia	sp, {r1, r3}
 12124 6564 34019FE5 		ldr	r0, .L1020+8
2001:../uvc.c      **** 										 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set second byte
 12125              		.loc 1 2001 0
 12126 6568 6647CEE5 		strb	r4, [lr, #1894]
2002:../uvc.c      **** 									 }
 12127              		.loc 1 2002 0
 12128 656c 0530A0E1 		mov	r3, r5
 12129              	.LVL1440:
 12130 6570 2B10A0E3 		mov	r1, #43
 12131 6574 1CC08DE5 		str	ip, [sp, #28]
 12132 6578 FEFFFFEB 		bl	cmdSet
 12133              	.LVL1441:
 12134 657c 1CC09DE5 		ldr	ip, [sp, #28]
 12135              	.L904:
2005:../uvc.c      **** 
 12136              		.loc 1 2005 0
 12137 6580 3C409DE5 		ldr	r4, [sp, #60]
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12138              		.loc 1 2004 0
 12139 6584 0130A0E3 		mov	r3, #1
2005:../uvc.c      **** 
 12140              		.loc 1 2005 0
 12141 6588 1C0094E5 		ldr	r0, [r4, #28]
2004:../uvc.c      **** 									 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 12142              		.loc 1 2004 0
 12143 658c 6937CAE5 		strb	r3, [r10, #1897]
2005:../uvc.c      **** 
 12144              		.loc 1 2005 0
 12145 6590 1CC08DE5 		str	ip, [sp, #28]
 12146 6594 FEFFFFEB 		bl	_txe_mutex_put
 12147              	.LVL1442:
 12148 6598 1CC09DE5 		ldr	ip, [sp, #28]
 12149 659c 23FCFFEA 		b	.L902
 12150              	.LVL1443:
 12151              	.L1007:
 12152              	.LBE192:
 12153              	.LBE222:
 12154              	.LBB223:
 12155              	.LBB181:
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12156              		.loc 1 1474 0
 12157 65a0 3D27DAE5 		ldrb	r2, [r10, #1853]	@ zero_extendqisi2
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12158              		.loc 1 1476 0
 12159 65a4 3E47DAE5 		ldrb	r4, [r10, #1854]	@ zero_extendqisi2
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12160              		.loc 1 1475 0
 12161 65a8 0030A0E3 		mov	r3, #0
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12162              		.loc 1 1476 0
 12163 65ac FF4004E2 		and	r4, r4, #255
1474:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12164              		.loc 1 1474 0
 12165 65b0 2820CBE5 		strb	r2, [fp, #40]
1476:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12166              		.loc 1 1476 0
 12167 65b4 2A40CBE5 		strb	r4, [fp, #42]
1478:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12168              		.loc 1 1478 0
 12169 65b8 FFC002E2 		and	ip, r2, #255
 12170              	.LVL1444:
1475:../uvc.c      **** 			 	 				 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12171              		.loc 1 1475 0
 12172 65bc 2930CBE5 		strb	r3, [fp, #41]
1477:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12173              		.loc 1 1477 0
 12174 65c0 2B30CBE5 		strb	r3, [fp, #43]
 12175 65c4 ECFDFFEA 		b	.L837
 12176              	.LVL1445:
 12177              	.L1006:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12178              		.loc 1 1469 0
 12179 65c8 3D37DAE5 		ldrb	r3, [r10, #1853]	@ zero_extendqisi2
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12180              		.loc 1 1470 0
 12181 65cc 3E47DAE5 		ldrb	r4, [r10, #1854]	@ zero_extendqisi2
 12182              	.LVL1446:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12183              		.loc 1 1469 0
 12184 65d0 2830CBE5 		strb	r3, [fp, #40]
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12185              		.loc 1 1470 0
 12186 65d4 FF4004E2 		and	r4, r4, #255
1471:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12187              		.loc 1 1471 0
 12188 65d8 FFC003E2 		and	ip, r3, #255
 12189              	.LVL1447:
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12190              		.loc 1 1470 0
 12191 65dc 2940CBE5 		strb	r4, [fp, #41]
 12192 65e0 E5FDFFEA 		b	.L837
 12193              	.LVL1448:
 12194              	.L1010:
 12195              	.LBE181:
 12196              	.LBE223:
 12197              	.LBB224:
 12198              	.LBB193:
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12199              		.loc 1 1491 0
 12200 65e4 0510A0E1 		mov	r1, r5
 12201 65e8 0400A0E1 		mov	r0, r4
 12202 65ec 1CC08DE5 		str	ip, [sp, #28]
 12203 65f0 FEFFFFEB 		bl	SensorGetControl
 12204              	.LVL1449:
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12205              		.loc 1 1493 0
 12206 65f4 0510A0E1 		mov	r1, r5
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12207              		.loc 1 1491 0
 12208 65f8 0030A0E1 		mov	r3, r0
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12209              		.loc 1 1493 0
 12210 65fc 30009DE5 		ldr	r0, [sp, #48]
1491:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12211              		.loc 1 1491 0
 12212 6600 2830C7E5 		strb	r3, [r7, #40]
1492:../uvc.c      **** 			 	 				 glEp0Buffer[2] = SensorGetControl(RegAdd0, devAdd);
 12213              		.loc 1 1492 0
 12214 6604 6537CAE5 		strb	r3, [r10, #1893]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12215              		.loc 1 1493 0
 12216 6608 FEFFFFEB 		bl	SensorGetControl
 12217              	.LVL1450:
1495:../uvc.c      **** 			 	 				 glEp0Buffer[3] = 0;
 12218              		.loc 1 1495 0
 12219 660c 0030A0E3 		mov	r3, #0
 12220 6610 2930C7E5 		strb	r3, [r7, #41]
1496:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12221              		.loc 1 1496 0
 12222 6614 2B30C7E5 		strb	r3, [r7, #43]
1497:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[2];
 12223              		.loc 1 1497 0
 12224 6618 2850D7E5 		ldrb	r5, [r7, #40]	@ zero_extendqisi2
 12225              	.LVL1451:
 12226 661c 1CC09DE5 		ldr	ip, [sp, #28]
1493:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 12227              		.loc 1 1493 0
 12228 6620 0040A0E1 		mov	r4, r0
 12229              	.LVL1452:
 12230 6624 2A00C7E5 		strb	r0, [r7, #42]
1494:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12231              		.loc 1 1494 0
 12232 6628 6607CAE5 		strb	r0, [r10, #1894]
 12233 662c 08FEFFEA 		b	.L893
 12234              	.LVL1453:
 12235              	.L1009:
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12236              		.loc 1 1484 0
 12237 6630 0400A0E1 		mov	r0, r4
 12238 6634 0510A0E1 		mov	r1, r5
 12239 6638 1CC08DE5 		str	ip, [sp, #28]
 12240 663c FEFFFFEB 		bl	SensorGetControl
 12241              	.LVL1454:
1486:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[1];
 12242              		.loc 1 1486 0
 12243 6640 0040A0E3 		mov	r4, #0
 12244              	.LVL1455:
 12245 6644 2940C7E5 		strb	r4, [r7, #41]
 12246 6648 1CC09DE5 		ldr	ip, [sp, #28]
1485:../uvc.c      **** 			 	 				 glEp0Buffer[1] = 0;
 12247              		.loc 1 1485 0
 12248 664c 6507CAE5 		strb	r0, [r10, #1893]
1484:../uvc.c      **** 			 	 				 pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12249              		.loc 1 1484 0
 12250 6650 0050A0E1 		mov	r5, r0
 12251              	.LVL1456:
 12252 6654 2800C7E5 		strb	r0, [r7, #40]
1487:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12253              		.loc 1 1487 0
 12254 6658 6647CAE5 		strb	r4, [r10, #1894]
 12255              	.LVL1457:
 12256 665c FCFDFFEA 		b	.L893
 12257              	.LVL1458:
 12258              	.L1014:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12259              		.loc 1 1469 0
 12260 6660 6537DAE5 		ldrb	r3, [r10, #1893]	@ zero_extendqisi2
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12261              		.loc 1 1470 0
 12262 6664 6647DAE5 		ldrb	r4, [r10, #1894]	@ zero_extendqisi2
 12263              	.LVL1459:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12264              		.loc 1 1469 0
 12265 6668 2830C7E5 		strb	r3, [r7, #40]
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12266              		.loc 1 1470 0
 12267 666c FF4004E2 		and	r4, r4, #255
1471:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12268              		.loc 1 1471 0
 12269 6670 FF5003E2 		and	r5, r3, #255
 12270              	.LVL1460:
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12271              		.loc 1 1470 0
 12272 6674 2940C7E5 		strb	r4, [r7, #41]
 12273 6678 F7FDFFEA 		b	.L891
 12274              	.LVL1461:
 12275              	.L1017:
 12276              	.LBE193:
 12277              	.LBE224:
 12278              	.LBB225:
 12279              	.LBB169:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12280              		.loc 1 1469 0
 12281 667c 5137DAE5 		ldrb	r3, [r10, #1873]	@ zero_extendqisi2
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12282              		.loc 1 1470 0
 12283 6680 5247DAE5 		ldrb	r4, [r10, #1874]	@ zero_extendqisi2
 12284              	.LVL1462:
1469:../uvc.c      **** 			 	 				 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12285              		.loc 1 1469 0
 12286 6684 2830CBE5 		strb	r3, [fp, #40]
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12287              		.loc 1 1470 0
 12288 6688 FF4004E2 		and	r4, r4, #255
1471:../uvc.c      **** 			 	 				 sendData1 = glEp0Buffer[1];
 12289              		.loc 1 1471 0
 12290 668c FF5003E2 		and	r5, r3, #255
 12291              	.LVL1463:
1470:../uvc.c      **** 			 	 				 sendData = glEp0Buffer[0];
 12292              		.loc 1 1470 0
 12293 6690 2940CBE5 		strb	r4, [fp, #41]
 12294 6694 13FEFFEA 		b	.L864
 12295              	.L1021:
 12296              		.align	2
 12297              	.L1020:
 12298 6698 E4050000 		.word	.LC34
 12299 669c 68040000 		.word	.LC27
 12300 66a0 00000000 		.word	cmdQu
 12301 66a4 00000000 		.word	.LANCHOR1
 12302              	.LBE169:
 12303              	.LBE225:
 12304              	.LBE235:
 12305              	.LBE415:
 12306              		.cfi_endproc
 12307              	.LFE25:
 12309              		.align	2
 12310              		.global	CyFxGpifCB
 12312              	CyFxGpifCB:
 12313              	.LFB13:
2976:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12314              		.loc 1 2976 0
 12315              		.cfi_startproc
 12316              		@ args = 0, pretend = 0, frame = 0
 12317              		@ frame_needed = 0, uses_anonymous_args = 0
2977:../uvc.c      ****     {
 12318              		.loc 1 2977 0
 12319 66a8 010050E3 		cmp	r0, #1
2976:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12320              		.loc 1 2976 0
 12321 66ac 10402DE9 		stmfd	sp!, {r4, lr}
 12322              	.LCFI29:
 12323              		.cfi_def_cfa_offset 8
 12324              		.cfi_offset 4, -8
 12325              		.cfi_offset 14, -4
2977:../uvc.c      ****     {
 12326              		.loc 1 2977 0
 12327 66b0 1080BD18 		ldmnefd	sp!, {r4, pc}
 12328              	.LBB420:
 12329              	.LBB421:
2874:../uvc.c      ****     {
 12330              		.loc 1 2874 0
 12331 66b4 C4309FE5 		ldr	r3, .L1039
 12332 66b8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12333 66bc 030053E3 		cmp	r3, #3
 12334 66c0 1000000A 		beq	.L1038
2900:../uvc.c      ****     {
 12335              		.loc 1 2900 0
 12336 66c4 020053E3 		cmp	r3, #2
 12337 66c8 1080BD18 		ldmnefd	sp!, {r4, pc}
2902:../uvc.c      ****         {
 12338              		.loc 1 2902 0
 12339 66cc 083041E2 		sub	r3, r1, #8
 12340 66d0 0A0053E3 		cmp	r3, #10
 12341 66d4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12342 66d8 200000EA 		b	.L1031
 12343              	.L1033:
 12344 66dc 58670000 		.word	.L1026
 12345 66e0 60670000 		.word	.L1031
 12346 66e4 60670000 		.word	.L1031
 12347 66e8 28670000 		.word	.L1022
 12348 66ec 60670000 		.word	.L1031
 12349 66f0 60670000 		.word	.L1031
 12350 66f4 60670000 		.word	.L1031
 12351 66f8 2C670000 		.word	.L1037
 12352 66fc 60670000 		.word	.L1031
 12353 6700 60670000 		.word	.L1031
 12354 6704 28670000 		.word	.L1022
 12355              	.L1038:
2876:../uvc.c      ****         {
 12356              		.loc 1 2876 0
 12357 6708 0B1041E2 		sub	r1, r1, #11
 12358 670c 030051E3 		cmp	r1, #3
 12359 6710 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12360 6714 150000EA 		b	.L1025
 12361              	.L1027:
 12362 6718 58670000 		.word	.L1026
 12363 671c 2C670000 		.word	.L1037
 12364 6720 28670000 		.word	.L1022
 12365 6724 28670000 		.word	.L1022
 12366              	.L1022:
 12367 6728 1080BDE8 		ldmfd	sp!, {r4, pc}
 12368              	.L1037:
2902:../uvc.c      ****         {
 12369              		.loc 1 2902 0
 12370 672c 0110A0E3 		mov	r1, #1
 12371              	.L1028:
2959:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12372              		.loc 1 2959 0
 12373 6730 4C009FE5 		ldr	r0, .L1039+4
 12374 6734 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
2960:../uvc.c      ****         {
 12375              		.loc 1 2960 0
 12376 6738 004050E2 		subs	r4, r0, #0
 12377 673c 1080BD08 		ldmeqfd	sp!, {r4, pc}
2962:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12378              		.loc 1 2962 0
 12379 6740 0400A0E3 		mov	r0, #4
 12380 6744 3C109FE5 		ldr	r1, .L1039+8
 12381 6748 0420A0E1 		mov	r2, r4
 12382 674c FEFFFFEB 		bl	CyU3PDebugPrint
2963:../uvc.c      ****         }
 12383              		.loc 1 2963 0
 12384 6750 0400A0E1 		mov	r0, r4
 12385 6754 FEFFFFEB 		bl	CyFxAppErrorHandler
 12386              	.L1026:
2876:../uvc.c      ****         {
 12387              		.loc 1 2876 0
 12388 6758 0010A0E3 		mov	r1, #0
 12389 675c F3FFFFEA 		b	.L1028
 12390              	.L1031:
2948:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12391              		.loc 1 2948 0
 12392 6760 0120A0E1 		mov	r2, r1
 12393 6764 0100A0E3 		mov	r0, #1
 12394 6768 1C109FE5 		ldr	r1, .L1039+12
 12395 676c FEFFFFEB 		bl	CyU3PDebugPrint
 12396              	.L1025:
 12397              	.LBE421:
 12398              	.LBE420:
 12399              	.LBB422:
 12400              	.LBB423:
2983:../uvc.c      ****     }
 12401              		.loc 1 2983 0
 12402 6770 0400A0E3 		mov	r0, #4
 12403 6774 14109FE5 		ldr	r1, .L1039+16
 12404              	.LBE423:
 12405              	.LBE422:
2986:../uvc.c      **** 
 12406              		.loc 1 2986 0
 12407 6778 1040BDE8 		ldmfd	sp!, {r4, lr}
 12408              	.LBB425:
 12409              	.LBB424:
2983:../uvc.c      ****     }
 12410              		.loc 1 2983 0
 12411 677c FEFFFFEA 		b	CyU3PDebugPrint
 12412              	.L1040:
 12413              		.align	2
 12414              	.L1039:
 12415 6780 00000000 		.word	.LANCHOR0
 12416 6784 00000000 		.word	glChHandleUVCStream
 12417 6788 240E0000 		.word	.LC81
 12418 678c 0C0E0000 		.word	.LC80
 12419 6790 540E0000 		.word	.LC82
 12420              	.LBE424:
 12421              	.LBE425:
 12422              		.cfi_endproc
 12423              	.LFE13:
 12425              		.align	2
 12426              		.global	CyFxApplicationDefine
 12428              	CyFxApplicationDefine:
 12429              	.LFB27:
5213:../uvc.c      **** }
5214:../uvc.c      **** 
5215:../uvc.c      **** 
5216:../uvc.c      **** /*
5217:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
5218:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
5219:../uvc.c      ****  */
5220:../uvc.c      **** void
5221:../uvc.c      **** CyFxApplicationDefine (
5222:../uvc.c      ****         void)
5223:../uvc.c      **** {
 12430              		.loc 1 5223 0
 12431              		.cfi_startproc
 12432              		@ args = 0, pretend = 0, frame = 32
 12433              		@ frame_needed = 0, uses_anonymous_args = 0
 12434              	.LVL1464:
 12435 6794 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12436              	.LCFI30:
 12437              		.cfi_def_cfa_offset 32
 12438              		.cfi_offset 4, -32
 12439              		.cfi_offset 5, -28
 12440              		.cfi_offset 6, -24
 12441              		.cfi_offset 7, -20
 12442              		.cfi_offset 8, -16
 12443              		.cfi_offset 9, -12
 12444              		.cfi_offset 10, -8
 12445              		.cfi_offset 14, -4
5224:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
5225:../uvc.c      ****     uint32_t retThrdCreate;
5226:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
5227:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
5228:../uvc.c      **** 
5229:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
5230:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12446              		.loc 1 5230 0
 12447 6798 010AA0E3 		mov	r0, #4096
5223:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12448              		.loc 1 5223 0
 12449 679c 40D04DE2 		sub	sp, sp, #64
 12450              	.LCFI31:
 12451              		.cfi_def_cfa_offset 96
 12452              		.loc 1 5230 0
 12453 67a0 FEFFFFEB 		bl	CyU3PMemAlloc
 12454              	.LVL1465:
 12455 67a4 0070A0E1 		mov	r7, r0
 12456              	.LVL1466:
5231:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12457              		.loc 1 5231 0
 12458 67a8 010AA0E3 		mov	r0, #4096
 12459              	.LVL1467:
 12460 67ac FEFFFFEB 		bl	CyU3PMemAlloc
 12461              	.LVL1468:
 12462 67b0 0060A0E1 		mov	r6, r0
 12463              	.LVL1469:
5232:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12464              		.loc 1 5232 0
 12465 67b4 010AA0E3 		mov	r0, #4096
 12466              	.LVL1470:
 12467 67b8 FEFFFFEB 		bl	CyU3PMemAlloc
 12468              	.LVL1471:
5233:../uvc.c      **** 
5234:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12469              		.loc 1 5234 0
 12470 67bc 000056E3 		cmp	r6, #0
 12471 67c0 00005713 		cmpne	r7, #0
 12472 67c4 00A0A013 		movne	r10, #0
 12473 67c8 01A0A003 		moveq	r10, #1
5232:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12474              		.loc 1 5232 0
 12475 67cc 0090A0E1 		mov	r9, r0
 12476              	.LVL1472:
 12477              		.loc 1 5234 0
 12478 67d0 0000001A 		bne	.L1052
 12479              	.LVL1473:
 12480              	.L1042:
 12481              	.L1044:
 12482 67d4 FEFFFFEA 		b	.L1044
 12483              	.LVL1474:
 12484              	.L1052:
 12485              		.loc 1 5234 0 is_stmt 0 discriminator 1
 12486 67d8 000050E3 		cmp	r0, #0
 12487 67dc FCFFFF0A 		beq	.L1042
 12488              	.LVL1475:
5235:../uvc.c      ****         goto fatalErrorHandler;
5236:../uvc.c      **** 
5237:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
5238:../uvc.c      ****     char *cmdName = "I2CcmdQue";
5239:../uvc.c      ****     char *staName = "I2CstaQue";
5240:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12489              		.loc 1 5240 0 is_stmt 1
 12490 67e0 F4309FE5 		ldr	r3, .L1053
 12491 67e4 20008DE2 		add	r0, sp, #32
 12492              	.LVL1476:
 12493 67e8 00308DE5 		str	r3, [sp]
 12494 67ec 4010A0E3 		mov	r1, #64
 12495 67f0 E8209FE5 		ldr	r2, .L1053+4
 12496 67f4 0A30A0E1 		mov	r3, r10
 12497 67f8 FEFFFFEB 		bl	cmdbufCreate
 12498              	.LVL1477:
 12499 67fc 20E08DE2 		add	lr, sp, #32
 12500 6800 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12501 6804 D8C09FE5 		ldr	ip, .L1053+8
5241:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
5242:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
5243:../uvc.c      **** 
5244:../uvc.c      **** 	/****** initialize command descriptor ***********/
5245:../uvc.c      **** 	cmdquInit(cmdQuptr);
5246:../uvc.c      **** 	cmdquInit(statQuptr);
5247:../uvc.c      **** 
5248:../uvc.c      ****     /* Create the UVC application thread. */
5249:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12502              		.loc 1 5249 0
 12503 6808 0840A0E3 		mov	r4, #8
5240:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12504              		.loc 1 5240 0
 12505 680c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12506 6810 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12507              		.loc 1 5249 0
 12508 6814 0150A0E3 		mov	r5, #1
5240:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12509              		.loc 1 5240 0
 12510 6818 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
5245:../uvc.c      **** 	cmdquInit(statQuptr);
 12511              		.loc 1 5245 0
 12512 681c 10004CE2 		sub	r0, ip, #16
 12513 6820 FEFFFFEB 		bl	cmdquInit
 12514              	.LVL1478:
5246:../uvc.c      **** 
 12515              		.loc 1 5246 0
 12516 6824 BC009FE5 		ldr	r0, .L1053+12
 12517 6828 FEFFFFEB 		bl	cmdquInit
 12518              	.LVL1479:
 12519              		.loc 1 5249 0
 12520 682c A880A0E3 		mov	r8, #168
 12521 6830 012AA0E3 		mov	r2, #4096
 12522 6834 0A30A0E1 		mov	r3, r10
 12523 6838 14008DE9 		stmib	sp, {r2, r4}
 12524 683c A8009FE5 		ldr	r0, .L1053+16
 12525 6840 00708DE5 		str	r7, [sp]
 12526 6844 10A08DE5 		str	r10, [sp, #16]
 12527 6848 0C408DE5 		str	r4, [sp, #12]
 12528 684c 14508DE5 		str	r5, [sp, #20]
 12529 6850 18808DE5 		str	r8, [sp, #24]
 12530 6854 94109FE5 		ldr	r1, .L1053+20
 12531 6858 94209FE5 		ldr	r2, .L1053+24
 12532 685c FEFFFFEB 		bl	_txe_thread_create
 12533              	.LVL1480:
5250:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
5251:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
5252:../uvc.c      ****             0,                                          /* No input parameter to thread */
5253:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
5254:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
5255:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5256:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
5257:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5258:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5259:../uvc.c      ****             );
5260:../uvc.c      ****     if (retThrdCreate != 0)
 12534              		.loc 1 5260 0
 12535 6860 003050E2 		subs	r3, r0, #0
 12536 6864 DAFFFF1A 		bne	.L1042
5261:../uvc.c      ****     {
5262:../uvc.c      ****         goto fatalErrorHandler;
5263:../uvc.c      ****     }
5264:../uvc.c      **** 
5265:../uvc.c      ****     /* Create the control request handling thread. */
5266:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12537              		.loc 1 5266 0
 12538 6868 027BA0E3 		mov	r7, #2048
 12539              	.LVL1481:
 12540 686c 10308DE5 		str	r3, [sp, #16]
 12541 6870 00608DE5 		str	r6, [sp]
 12542 6874 08408DE5 		str	r4, [sp, #8]
 12543 6878 0C408DE5 		str	r4, [sp, #12]
 12544 687c 14508DE5 		str	r5, [sp, #20]
 12545 6880 18808DE5 		str	r8, [sp, #24]
 12546 6884 04708DE5 		str	r7, [sp, #4]
 12547 6888 68009FE5 		ldr	r0, .L1053+28
 12548              	.LVL1482:
 12549 688c 68109FE5 		ldr	r1, .L1053+32
 12550 6890 68209FE5 		ldr	r2, .L1053+36
 12551 6894 FEFFFFEB 		bl	_txe_thread_create
 12552              	.LVL1483:
5267:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
5268:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
5269:../uvc.c      ****             0,                                                  /* No input parameter to thread */
5270:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
5271:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
5272:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
5273:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
5274:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
5275:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
5276:../uvc.c      ****             );
5277:../uvc.c      ****     if (retThrdCreate != 0)
 12553              		.loc 1 5277 0
 12554 6898 003050E2 		subs	r3, r0, #0
 12555 689c CCFFFF1A 		bne	.L1042
5278:../uvc.c      ****     {
5279:../uvc.c      ****         goto fatalErrorHandler;
5280:../uvc.c      ****     }
5281:../uvc.c      **** #if 1
5282:../uvc.c      ****     /* Create the I2C control command handling thread. */
5283:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12556              		.loc 1 5283 0
 12557 68a0 00908DE5 		str	r9, [sp]
 12558 68a4 04708DE5 		str	r7, [sp, #4]
 12559 68a8 08408DE5 		str	r4, [sp, #8]
 12560 68ac 0C408DE5 		str	r4, [sp, #12]
 12561 68b0 10308DE5 		str	r3, [sp, #16]
 12562 68b4 14508DE5 		str	r5, [sp, #20]
 12563 68b8 18808DE5 		str	r8, [sp, #24]
 12564 68bc 40009FE5 		ldr	r0, .L1053+40
 12565              	.LVL1484:
 12566 68c0 40109FE5 		ldr	r1, .L1053+44
 12567 68c4 40209FE5 		ldr	r2, .L1053+48
 12568 68c8 FEFFFFEB 		bl	_txe_thread_create
 12569              	.LVL1485:
5284:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
5285:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
5286:../uvc.c      ****             0,                                          /* No input parameter to thread */
5287:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
5288:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
5289:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
5290:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
5291:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
5292:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
5293:../uvc.c      ****             );
5294:../uvc.c      ****     if (retThrdCreate != 0)
 12570              		.loc 1 5294 0
 12571 68cc 000050E3 		cmp	r0, #0
 12572 68d0 BFFFFF1A 		bne	.L1042
5295:../uvc.c      ****     {
5296:../uvc.c      ****         goto fatalErrorHandler;
5297:../uvc.c      ****     }
5298:../uvc.c      **** #endif
5299:../uvc.c      **** 
5300:../uvc.c      ****     return;
5301:../uvc.c      **** 
5302:../uvc.c      **** fatalErrorHandler:
5303:../uvc.c      ****     /* Add custom recovery or debug actions here */
5304:../uvc.c      ****     /* Loop indefinitely */
5305:../uvc.c      ****     while (1);
5306:../uvc.c      **** }
 12573              		.loc 1 5306 0
 12574 68d4 40D08DE2 		add	sp, sp, #64
 12575              		@ sp needed
 12576 68d8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12577              	.LVL1486:
 12578              	.L1054:
 12579              		.align	2
 12580              	.L1053:
 12581 68dc 00000000 		.word	cmdQuMux
 12582 68e0 6C0E0000 		.word	.LC83
 12583 68e4 00000000 		.word	cmdQu
 12584 68e8 00000000 		.word	statQu
 12585 68ec E4000000 		.word	.LANCHOR0+228
 12586 68f0 780E0000 		.word	.LC84
 12587 68f4 00000000 		.word	UVCAppThread_Entry
 12588 68f8 8C010000 		.word	.LANCHOR0+396
 12589 68fc 8C0E0000 		.word	.LC85
 12590 6900 00000000 		.word	UVCAppEP0Thread_Entry
 12591 6904 34020000 		.word	.LANCHOR0+564
 12592 6908 A40E0000 		.word	.LC86
 12593 690c 00000000 		.word	I2cAppThread_Entry
 12594              		.cfi_endproc
 12595              	.LFE27:
 12597              		.section	.text.startup,"ax",%progbits
 12598              		.align	2
 12599              		.global	main
 12601              	main:
 12602              	.LFB28:
5307:../uvc.c      **** 
5308:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
5309:../uvc.c      ****  * the ThreadX RTOS here.
5310:../uvc.c      ****  */
5311:../uvc.c      **** int
5312:../uvc.c      **** main (
5313:../uvc.c      ****         void)
5314:../uvc.c      **** {
 12603              		.loc 1 5314 0
 12604              		.cfi_startproc
 12605              		@ args = 0, pretend = 0, frame = 56
 12606              		@ frame_needed = 0, uses_anonymous_args = 0
 12607 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12608              	.LCFI32:
 12609              		.cfi_def_cfa_offset 12
 12610              		.cfi_offset 4, -12
 12611              		.cfi_offset 5, -8
 12612              		.cfi_offset 14, -4
 12613 0004 3CD04DE2 		sub	sp, sp, #60
 12614              	.LCFI33:
 12615              		.cfi_def_cfa_offset 72
5315:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
5316:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
5317:../uvc.c      **** 
5318:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
5319:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
5320:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12616              		.loc 1 5320 0
 12617 0008 0230A0E3 		mov	r3, #2
5321:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
5322:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
5323:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12618              		.loc 1 5323 0
 12619 000c 0010A0E3 		mov	r1, #0
5324:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12620              		.loc 1 5324 0
 12621 0010 0320A0E3 		mov	r2, #3
5319:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12622              		.loc 1 5319 0
 12623 0014 0150A0E3 		mov	r5, #1
5325:../uvc.c      **** 
5326:../uvc.c      ****     /* Initialize the device */
5327:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12624              		.loc 1 5327 0
 12625 0018 0D00A0E1 		mov	r0, sp
5319:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12626              		.loc 1 5319 0
 12627 001c 00508DE5 		str	r5, [sp]
5320:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12628              		.loc 1 5320 0
 12629 0020 0430CDE5 		strb	r3, [sp, #4]
5321:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12630              		.loc 1 5321 0
 12631 0024 0530CDE5 		strb	r3, [sp, #5]
5322:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12632              		.loc 1 5322 0
 12633 0028 0630CDE5 		strb	r3, [sp, #6]
5323:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12634              		.loc 1 5323 0
 12635 002c 08108DE5 		str	r1, [sp, #8]
5324:../uvc.c      **** 
 12636              		.loc 1 5324 0
 12637 0030 0C20CDE5 		strb	r2, [sp, #12]
 12638              		.loc 1 5327 0
 12639 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12640              	.LVL1487:
5328:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12641              		.loc 1 5328 0
 12642 0038 004050E2 		subs	r4, r0, #0
 12643 003c 0000000A 		beq	.L1060
 12644              	.L1056:
 12645              	.L1057:
 12646 0040 FEFFFFEA 		b	.L1057
 12647              	.L1060:
5329:../uvc.c      ****     {
5330:../uvc.c      ****         goto handle_fatal_error;
5331:../uvc.c      ****     }
5332:../uvc.c      **** 
5333:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
5334:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12648              		.loc 1 5334 0
 12649 0044 0410A0E1 		mov	r1, r4
 12650 0048 0420A0E1 		mov	r2, r4
 12651 004c 0500A0E1 		mov	r0, r5
 12652              	.LVL1488:
 12653 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12654              	.LVL1489:
5335:../uvc.c      **** 
5336:../uvc.c      ****     /* Configure the IO matrix for the device. */
5337:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
5338:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
5339:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
5340:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
5341:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
5342:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
5343:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
5344:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
5345:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
5346:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
5347:../uvc.c      **** 
5348:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12655              		.loc 1 5348 0
 12656 0054 10008DE2 		add	r0, sp, #16
5338:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12657              		.loc 1 5338 0
 12658 0058 2640CDE5 		strb	r4, [sp, #38]
5339:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12659              		.loc 1 5339 0
 12660 005c 28408DE5 		str	r4, [sp, #40]
5340:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12661              		.loc 1 5340 0
 12662 0060 2C408DE5 		str	r4, [sp, #44]
5341:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12663              		.loc 1 5341 0
 12664 0064 30408DE5 		str	r4, [sp, #48]
5342:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12665              		.loc 1 5342 0
 12666 0068 34408DE5 		str	r4, [sp, #52]
5345:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12667              		.loc 1 5345 0
 12668 006c 1C408DE5 		str	r4, [sp, #28]
5346:../uvc.c      **** 
 12669              		.loc 1 5346 0
 12670 0070 20408DE5 		str	r4, [sp, #32]
5337:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12671              		.loc 1 5337 0
 12672 0074 10508DE5 		str	r5, [sp, #16]
5343:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12673              		.loc 1 5343 0
 12674 0078 14508DE5 		str	r5, [sp, #20]
5344:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12675              		.loc 1 5344 0
 12676 007c 18508DE5 		str	r5, [sp, #24]
 12677              		.loc 1 5348 0
 12678 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12679              	.LVL1490:
5349:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12680              		.loc 1 5349 0
 12681 0084 004050E2 		subs	r4, r0, #0
 12682 0088 ECFFFF1A 		bne	.L1056
5350:../uvc.c      ****     {
5351:../uvc.c      ****         goto handle_fatal_error;
5352:../uvc.c      ****     }
5353:../uvc.c      **** 
5354:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
5355:../uvc.c      ****     CyU3PKernelEntry ();
 12683              		.loc 1 5355 0
 12684 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12685              	.LVL1491:
5356:../uvc.c      **** 
5357:../uvc.c      ****     /* Dummy return to make the compiler happy */
5358:../uvc.c      ****     return 0;
5359:../uvc.c      **** 
5360:../uvc.c      **** handle_fatal_error:
5361:../uvc.c      ****     /* Cannot recover from this error. */
5362:../uvc.c      ****     while (1);
5363:../uvc.c      **** }
 12686              		.loc 1 5363 0
 12687 0090 0400A0E1 		mov	r0, r4
 12688 0094 3CD08DE2 		add	sp, sp, #60
 12689              		@ sp needed
 12690 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12691              		.cfi_endproc
 12692              	.LFE28:
 12694              		.comm	I2CCmdTimer,44,4
 12695              		.comm	posTick,4,4
 12696              		.global	glUVCHeader
 12697              		.global	glProbeStilCtrl20
 12698              		.global	glProbeCtrl20
 12699              		.global	glProbeStilCtrl
 12700              		.global	glProbeCtrlFull
 12701              		.global	glProbeCtrl
 12702              		.global	streamingStarted
 12703              		.global	clearFeatureRqtReceived
 12704              		.global	usbSpeed
 12705              		.global	isUsbConnected
 12706              		.global	pbcpbak
 12707              		.global	pbcbak
 12708              		.global	pbbak
 12709              		.global	fbbak
 12710              		.global	pbc
 12711              		.global	pb
 12712              		.global	fb
 12713              		.comm	wLength,2,2
 12714              		.comm	wIndex,2,2
 12715              		.comm	wValue,2,2
 12716              		.comm	bRequest,1,1
 12717              		.comm	bmReqType,1,1
 12718              		.comm	imgHdMux,56,4
 12719              		.comm	timMux,56,4
 12720              		.comm	staQuMux,56,4
 12721              		.comm	cmdQuMux,56,4
 12722              		.comm	statQu,32,4
 12723              		.comm	cmdQu,32,4
 12724              		.global	testSnap
 12725              		.global	snapButFlag
 12726              		.comm	glInterStaBuffer,4,4
 12727              		.comm	glChHandleInterStat,172,4
 12728              		.comm	glChHandleStillStream,232,4
 12729              		.comm	glChHandleUVCStream,232,4
 12730              		.global	CyFxGpifConfig_usb2
 12731              		.global	CyFxGpifRegValue_usb2
 12732              		.global	CyFxGpifWavedataPosition_usb2
 12733              		.global	CyFxGpifWavedata_usb2
 12734              		.global	CyFxGpifTransition_usb2
 12735              		.global	CyFxGpifConfig
 12736              		.global	CyFxGpifRegValue
 12737              		.global	CyFxGpifWavedataPosition
 12738              		.global	CyFxGpifWavedata
 12739              		.global	CyFxGpifTransition
 12740              		.section	.rodata
 12741              		.align	2
 12742              		.set	.LANCHOR2,. + 0
 12745              	ShutSp:
 12746 0000 3582     		.short	-32203
 12747 0002 1B41     		.short	16667
 12748 0004 8D20     		.short	8333
 12749 0006 A00F     		.short	4000
 12750 0008 D007     		.short	2000
 12751 000a E803     		.short	1000
 12752 000c F401     		.short	500
 12753 000e C800     		.short	200
 12754 0010 6400     		.short	100
 12755 0012 0A00     		.short	10
 12756 0014 0000     		.short	0
 12757 0016 00000000 		.space	10
 12757      00000000 
 12757      0000
 12760              	pEXTSenCtrl:
 12761 0020 74050000 		.word	EXTShutter
 12762 0024 D4080000 		.word	EXTSensUp
 12763 0028 C0080000 		.word	EXTMirror
 12764 002c AC080000 		.word	EXT3DnoiseReduceMode
 12765 0030 98080000 		.word	EXT3DNoiseLev
 12766 0034 84080000 		.word	EXTDayNightMode
 12767 0038 30070000 		.word	EXTDayNightdely
 12768 003c 70080000 		.word	EXTDayNightlev
 12769 0040 5C080000 		.word	EXTNightDaylev
 12770 0044 0C050000 		.word	EXTAexModGainlev
 12771 0048 48080000 		.word	EXTExpReflev
 12772 004c 88050000 		.word	EXTShutlev
 12773 0050 34080000 		.word	EXTCamMode
 12774 0054 00000000 		.word	0
 12775 0058 20080000 		.word	EXTSensorPare
 12776 005c 0C080000 		.word	EXTI2Ccmd
 12777 0060 00000000 		.word	0
 12778 0064 00000000 		.word	0
 12779 0068 00000000 		.word	0
 12780 006c 00000000 		.word	0
 12781 0070 9C050000 		.word	EXTBLCWinPos
 12782 0074 F8070000 		.word	EXTBLCWeight
 12783 0078 F8040000 		.word	EXTBLCGrid
 12784 007c E4070000 		.word	EXTExHyster
 12785 0080 D0070000 		.word	EXTExCtrlSped
 12786 0084 BC070000 		.word	EXTEnhanceMode
 12787 0088 44070000 		.word	EXTEnhanceGain
 12788 008c 58070000 		.word	EXTEnhanceSTED
 12789 0090 A8070000 		.word	EXT2DNRGain
 12790 0094 94070000 		.word	EXT2DNRSTED
 12791 0098 80070000 		.word	EXTGammaCor
 12792 009c 6C070000 		.word	EXTAGCMaxLimit
 12793 00a0 00000000 		.word	0
 12794 00a4 00000000 		.space	124
 12794      00000000 
 12794      00000000 
 12794      00000000 
 12794      00000000 
 12797              	pPUCSenCtrl:
 12798 0120 60050000 		.word	PUCBLC
 12799 0124 20050000 		.word	PUCBright
 12800 0128 4C090000 		.word	PUCContrast
 12801 012c 00000000 		.word	0
 12802 0130 48050000 		.word	PUCPLFreq
 12803 0134 34050000 		.word	PUCHueC
 12804 0138 38090000 		.word	PUCSaturation
 12805 013c 24090000 		.word	PUCSharp
 12806 0140 00000000 		.word	0
 12807 0144 10090000 		.word	PUCWBMd
 12808 0148 00000000 		.word	0
 12809 014c FC080000 		.word	PUCWBLC
 12810 0150 00000000 		.word	0
 12811 0154 00000000 		.word	0
 12812 0158 E8080000 		.word	PUCDZoom
 12813 015c 00000000 		.word	0
 12816              	CyFxGpifConfig:
 12817 0160 0F00     		.short	15
 12818 0162 0000     		.space	2
 12819 0164 00000000 		.word	CyFxGpifWavedata
 12820 0168 00000000 		.word	CyFxGpifWavedataPosition
 12821 016c 0500     		.short	5
 12822 016e 0000     		.space	2
 12823 0170 00000000 		.word	CyFxGpifTransition
 12824 0174 4C00     		.short	76
 12825 0176 0000     		.space	2
 12826 0178 00000000 		.word	CyFxGpifRegValue
 12829              	CyFxGpifConfig_usb2:
 12830 017c 9300     		.short	147
 12831 017e 0000     		.space	2
 12832 0180 00000000 		.word	CyFxGpifWavedata_usb2
 12833 0184 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12834 0188 0800     		.short	8
 12835 018a 0000     		.space	2
 12836 018c 00000000 		.word	CyFxGpifTransition_usb2
 12837 0190 4C00     		.short	76
 12838 0192 0000     		.space	2
 12839 0194 00000000 		.word	CyFxGpifRegValue_usb2
 12840              		.data
 12841              		.align	2
 12842              		.set	.LANCHOR1,. + 0
 12845              	glProbeCtrlFull:
 12846 0000 00       		.byte	0
 12847 0001 00       		.byte	0
 12848 0002 01       		.byte	1
 12849 0003 01       		.byte	1
 12850 0004 15       		.byte	21
 12851 0005 16       		.byte	22
 12852 0006 05       		.byte	5
 12853 0007 00       		.byte	0
 12854 0008 00       		.byte	0
 12855 0009 00       		.byte	0
 12856 000a 00       		.byte	0
 12857 000b 00       		.byte	0
 12858 000c 00       		.byte	0
 12859 000d 00       		.byte	0
 12860 000e 00       		.byte	0
 12861 000f 00       		.byte	0
 12862 0010 00       		.byte	0
 12863 0011 00       		.byte	0
 12864 0012 00       		.byte	0
 12865 0013 C6       		.byte	-58
 12866 0014 99       		.byte	-103
 12867 0015 00       		.byte	0
 12868 0016 00       		.byte	0
 12869 0017 40       		.byte	64
 12870 0018 00       		.byte	0
 12871 0019 00       		.byte	0
 12872 001a 0000     		.space	2
 12875              	glProbeCtrl20:
 12876 001c 00       		.byte	0
 12877 001d 00       		.byte	0
 12878 001e 01       		.byte	1
 12879 001f 01       		.byte	1
 12880 0020 80       		.byte	-128
 12881 0021 1A       		.byte	26
 12882 0022 06       		.byte	6
 12883 0023 00       		.byte	0
 12884 0024 00       		.byte	0
 12885 0025 00       		.byte	0
 12886 0026 00       		.byte	0
 12887 0027 00       		.byte	0
 12888 0028 00       		.byte	0
 12889 0029 00       		.byte	0
 12890 002a 00       		.byte	0
 12891 002b 00       		.byte	0
 12892 002c 00       		.byte	0
 12893 002d 00       		.byte	0
 12894 002e 00       		.byte	0
 12895 002f D2       		.byte	-46
 12896 0030 0F       		.byte	15
 12897 0031 00       		.byte	0
 12898 0032 00       		.byte	0
 12899 0033 40       		.byte	64
 12900 0034 00       		.byte	0
 12901 0035 00       		.byte	0
 12902 0036 0000     		.space	2
 12905              	glProbeCtrl:
 12906 0038 00       		.byte	0
 12907 0039 00       		.byte	0
 12908 003a 01       		.byte	1
 12909 003b 01       		.byte	1
 12910 003c 15       		.byte	21
 12911 003d 16       		.byte	22
 12912 003e 05       		.byte	5
 12913 003f 00       		.byte	0
 12914 0040 00       		.byte	0
 12915 0041 00       		.byte	0
 12916 0042 00       		.byte	0
 12917 0043 00       		.byte	0
 12918 0044 00       		.byte	0
 12919 0045 00       		.byte	0
 12920 0046 00       		.byte	0
 12921 0047 00       		.byte	0
 12922 0048 00       		.byte	0
 12923 0049 00       		.byte	0
 12924 004a 00       		.byte	0
 12925 004b 48       		.byte	72
 12926 004c 3F       		.byte	63
 12927 004d 00       		.byte	0
 12928 004e 00       		.byte	0
 12929 004f 40       		.byte	64
 12930 0050 00       		.byte	0
 12931 0051 00       		.byte	0
 12934              	ROIMode:
 12935 0052 01       		.byte	1
 12936 0053 00       		.space	1
 12939              	glProbeStilCtrl:
 12940 0054 01       		.byte	1
 12941 0055 02       		.byte	2
 12942 0056 00       		.byte	0
 12943 0057 00       		.byte	0
 12944 0058 C6       		.byte	-58
 12945 0059 99       		.byte	-103
 12946 005a 00       		.byte	0
 12947 005b 00       		.byte	0
 12948 005c 40       		.byte	64
 12949 005d 00       		.byte	0
 12950 005e 00       		.byte	0
 12951 005f 00       		.space	1
 12954              	glProbeStilCtrl20:
 12955 0060 01       		.byte	1
 12956 0061 01       		.byte	1
 12957 0062 00       		.byte	0
 12958 0063 00       		.byte	0
 12959 0064 D2       		.byte	-46
 12960 0065 0F       		.byte	15
 12961 0066 00       		.byte	0
 12962 0067 00       		.byte	0
 12963 0068 40       		.byte	64
 12964 0069 00       		.byte	0
 12965 006a 00       		.byte	0
 12966 006b 00       		.space	1
 12969              	ExUCtrlParArry:
 12970 006c 00       		.byte	0
 12971 006d 00       		.byte	0
 12972 006e 04       		.byte	4
 12973 006f 01       		.byte	1
 12974 0070 00       		.byte	0
 12975 0071 38       		.byte	56
 12976 0072 01       		.byte	1
 12977 0073 01       		.byte	1
 12978 0074 00       		.byte	0
 12979 0075 03       		.byte	3
 12980 0076 00       		.byte	0
 12981 0077 4E       		.byte	78
 12982 0078 00       		.byte	0
 12983 0079 4E       		.byte	78
 12984 007a 00       		.byte	0
 12985 007b 30       		.byte	48
 12986 007c 01       		.byte	1
 12987 007d 00       		.byte	0
 12988 007e 00       		.byte	0
 12989 007f 00000000 		.space	5
 12989      00
 12990 0084 00       		.byte	0
 12991 0085 00       		.byte	0
 12992 0086 01       		.byte	1
 12993 0087 00       		.byte	0
 12994 0088 00       		.byte	0
 12995 0089 00       		.byte	0
 12996 008a 00       		.byte	0
 12997 008b 01       		.byte	1
 12998 008c 00       		.byte	0
 12999 008d 03       		.byte	3
 13000 008e 00       		.byte	0
 13001 008f 00       		.byte	0
 13002 0090 00       		.byte	0
 13003 0091 00       		.byte	0
 13004 0092 00       		.byte	0
 13005 0093 30       		.byte	48
 13006 0094 01       		.byte	1
 13007 0095 00       		.byte	0
 13008 0096 00       		.byte	0
 13009 0097 00000000 		.space	5
 13009      00
 13010 009c 00       		.byte	0
 13011 009d 00       		.byte	0
 13012 009e 02       		.byte	2
 13013 009f 00       		.byte	0
 13014 00a0 00       		.byte	0
 13015 00a1 FF       		.byte	-1
 13016 00a2 00       		.byte	0
 13017 00a3 01       		.byte	1
 13018 00a4 00       		.byte	0
 13019 00a5 03       		.byte	3
 13020 00a6 00       		.byte	0
 13021 00a7 01       		.byte	1
 13022 00a8 00       		.byte	0
 13023 00a9 00       		.byte	0
 13024 00aa 00       		.byte	0
 13025 00ab 30       		.byte	48
 13026 00ac 01       		.byte	1
 13027 00ad 01       		.byte	1
 13028 00ae 00       		.byte	0
 13029 00af 00000000 		.space	5
 13029      00
 13030 00b4 00       		.byte	0
 13031 00b5 00       		.byte	0
 13032 00b6 02       		.byte	2
 13033 00b7 00       		.byte	0
 13034 00b8 00       		.byte	0
 13035 00b9 00       		.byte	0
 13036 00ba 00       		.byte	0
 13037 00bb 00       		.byte	0
 13038 00bc 00       		.byte	0
 13039 00bd 03       		.byte	3
 13040 00be 00       		.byte	0
 13041 00bf 00       		.byte	0
 13042 00c0 00       		.byte	0
 13043 00c1 00       		.byte	0
 13044 00c2 00       		.byte	0
 13045 00c3 30       		.byte	48
 13046 00c4 01       		.byte	1
 13047 00c5 01       		.byte	1
 13048 00c6 00       		.byte	0
 13049 00c7 00000000 		.space	5
 13049      00
 13050 00cc 13       		.byte	19
 13051 00cd 14       		.byte	20
 13052 00ce 02       		.byte	2
 13053 00cf 00       		.byte	0
 13054 00d0 00       		.byte	0
 13055 00d1 FF       		.byte	-1
 13056 00d2 FF       		.byte	-1
 13057 00d3 01       		.byte	1
 13058 00d4 00       		.byte	0
 13059 00d5 03       		.byte	3
 13060 00d6 00       		.byte	0
 13061 00d7 66       		.byte	102
 13062 00d8 66       		.byte	102
 13063 00d9 66       		.byte	102
 13064 00da 66       		.byte	102
 13065 00db 30       		.byte	48
 13066 00dc 01       		.byte	1
 13067 00dd 00       		.byte	0
 13068 00de 00       		.byte	0
 13069 00df 00000000 		.space	5
 13069      00
 13070 00e4 11       		.byte	17
 13071 00e5 00       		.byte	0
 13072 00e6 02       		.byte	2
 13073 00e7 01       		.byte	1
 13074 00e8 00       		.byte	0
 13075 00e9 03       		.byte	3
 13076 00ea 00       		.byte	0
 13077 00eb 01       		.byte	1
 13078 00ec 00       		.byte	0
 13079 00ed 03       		.byte	3
 13080 00ee 00       		.byte	0
 13081 00ef 80       		.byte	-128
 13082 00f0 00       		.byte	0
 13083 00f1 80       		.byte	-128
 13084 00f2 00       		.byte	0
 13085 00f3 30       		.byte	48
 13086 00f4 01       		.byte	1
 13087 00f5 01       		.byte	1
 13088 00f6 00       		.byte	0
 13089 00f7 00000000 		.space	5
 13089      00
 13090 00fc 10       		.byte	16
 13091 00fd 00       		.byte	0
 13092 00fe 01       		.byte	1
 13093 00ff 01       		.byte	1
 13094 0100 00       		.byte	0
 13095 0101 02       		.byte	2
 13096 0102 00       		.byte	0
 13097 0103 01       		.byte	1
 13098 0104 00       		.byte	0
 13099 0105 03       		.byte	3
 13100 0106 00       		.byte	0
 13101 0107 00       		.byte	0
 13102 0108 00       		.byte	0
 13103 0109 00       		.byte	0
 13104 010a 00       		.byte	0
 13105 010b 30       		.byte	48
 13106 010c 01       		.byte	1
 13107 010d 01       		.byte	1
 13108 010e 00       		.byte	0
 13109 010f 00000000 		.space	5
 13109      00
 13110 0114 00       		.byte	0
 13111 0115 00       		.byte	0
 13112 0116 04       		.byte	4
 13113 0117 01       		.byte	1
 13114 0118 00       		.byte	0
 13115 0119 38       		.byte	56
 13116 011a 01       		.byte	1
 13117 011b 01       		.byte	1
 13118 011c 00       		.byte	0
 13119 011d 03       		.byte	3
 13120 011e 00       		.byte	0
 13121 011f 4E       		.byte	78
 13122 0120 00       		.byte	0
 13123 0121 4E       		.byte	78
 13124 0122 00       		.byte	0
 13125 0123 30       		.byte	48
 13126 0124 01       		.byte	1
 13127 0125 00       		.byte	0
 13128 0126 00       		.byte	0
 13129 0127 00000000 		.space	5
 13129      00
 13130 012c 00       		.byte	0
 13131 012d 00       		.byte	0
 13132 012e 01       		.byte	1
 13133 012f 00       		.byte	0
 13134 0130 00       		.byte	0
 13135 0131 00       		.byte	0
 13136 0132 00       		.byte	0
 13137 0133 01       		.byte	1
 13138 0134 00       		.byte	0
 13139 0135 03       		.byte	3
 13140 0136 00       		.byte	0
 13141 0137 00       		.byte	0
 13142 0138 00       		.byte	0
 13143 0139 00       		.byte	0
 13144 013a 00       		.byte	0
 13145 013b 30       		.byte	48
 13146 013c 01       		.byte	1
 13147 013d 00       		.byte	0
 13148 013e 00       		.byte	0
 13149 013f 00000000 		.space	5
 13149      00
 13150 0144 00       		.byte	0
 13151 0145 00       		.byte	0
 13152 0146 02       		.byte	2
 13153 0147 00       		.byte	0
 13154 0148 00       		.byte	0
 13155 0149 05       		.byte	5
 13156 014a 00       		.byte	0
 13157 014b 01       		.byte	1
 13158 014c 00       		.byte	0
 13159 014d 03       		.byte	3
 13160 014e 00       		.byte	0
 13161 014f 00       		.byte	0
 13162 0150 00       		.byte	0
 13163 0151 00       		.byte	0
 13164 0152 00       		.byte	0
 13165 0153 30       		.byte	48
 13166 0154 01       		.byte	1
 13167 0155 00       		.byte	0
 13168 0156 00       		.byte	0
 13169 0157 00000000 		.space	5
 13169      00
 13170 015c 00       		.byte	0
 13171 015d 00       		.byte	0
 13172 015e 03       		.byte	3
 13173 015f 00       		.byte	0
 13174 0160 00       		.byte	0
 13175 0161 0A       		.byte	10
 13176 0162 00       		.byte	0
 13177 0163 01       		.byte	1
 13178 0164 00       		.byte	0
 13179 0165 03       		.byte	3
 13180 0166 00       		.byte	0
 13181 0167 00       		.byte	0
 13182 0168 00       		.byte	0
 13183 0169 00       		.byte	0
 13184 016a 00       		.byte	0
 13185 016b 30       		.byte	48
 13186 016c 01       		.byte	1
 13187 016d 00       		.byte	0
 13188 016e 00       		.byte	0
 13189 016f 00000000 		.space	5
 13189      00
 13190 0174 00       		.byte	0
 13191 0175 00       		.byte	0
 13192 0176 02       		.byte	2
 13193 0177 00       		.byte	0
 13194 0178 00       		.byte	0
 13195 0179 40       		.byte	64
 13196 017a 00       		.byte	0
 13197 017b 01       		.byte	1
 13198 017c 00       		.byte	0
 13199 017d 03       		.byte	3
 13200 017e 00       		.byte	0
 13201 017f 0F       		.byte	15
 13202 0180 11       		.byte	17
 13203 0181 00       		.byte	0
 13204 0182 00       		.byte	0
 13205 0183 30       		.byte	48
 13206 0184 01       		.byte	1
 13207 0185 00       		.byte	0
 13208 0186 00       		.byte	0
 13209 0187 00000000 		.space	5
 13209      00
 13210 018c 00       		.byte	0
 13211 018d 00       		.byte	0
 13212 018e 02       		.byte	2
 13213 018f 00       		.byte	0
 13214 0190 00       		.byte	0
 13215 0191 64       		.byte	100
 13216 0192 00       		.byte	0
 13217 0193 01       		.byte	1
 13218 0194 00       		.byte	0
 13219 0195 03       		.byte	3
 13220 0196 00       		.byte	0
 13221 0197 00       		.byte	0
 13222 0198 00       		.byte	0
 13223 0199 00       		.byte	0
 13224 019a 00       		.byte	0
 13225 019b 30       		.byte	48
 13226 019c 01       		.byte	1
 13227 019d 00       		.byte	0
 13228 019e 00       		.byte	0
 13229 019f 00000000 		.space	5
 13229      00
 13230 01a4 00       		.byte	0
 13231 01a5 00       		.byte	0
 13232 01a6 02       		.byte	2
 13233 01a7 00       		.byte	0
 13234 01a8 00       		.byte	0
 13235 01a9 64       		.byte	100
 13236 01aa 00       		.byte	0
 13237 01ab 01       		.byte	1
 13238 01ac 00       		.byte	0
 13239 01ad 03       		.byte	3
 13240 01ae 00       		.byte	0
 13241 01af 00       		.byte	0
 13242 01b0 00       		.byte	0
 13243 01b1 00       		.byte	0
 13244 01b2 00       		.byte	0
 13245 01b3 30       		.byte	48
 13246 01b4 01       		.byte	1
 13247 01b5 00       		.byte	0
 13248 01b6 00       		.byte	0
 13249 01b7 00000000 		.space	5
 13249      00
 13250 01bc 00       		.byte	0
 13251 01bd 00       		.byte	0
 13252 01be 02       		.byte	2
 13253 01bf 00       		.byte	0
 13254 01c0 00       		.byte	0
 13255 01c1 64       		.byte	100
 13256 01c2 00       		.byte	0
 13257 01c3 01       		.byte	1
 13258 01c4 00       		.byte	0
 13259 01c5 03       		.byte	3
 13260 01c6 00       		.byte	0
 13261 01c7 00       		.byte	0
 13262 01c8 00       		.byte	0
 13263 01c9 00       		.byte	0
 13264 01ca 00       		.byte	0
 13265 01cb 30       		.byte	48
 13266 01cc 01       		.byte	1
 13267 01cd 00       		.byte	0
 13268 01ce 00       		.byte	0
 13269 01cf 00000000 		.space	5
 13269      00
 13270 01d4 00       		.byte	0
 13271 01d5 00       		.byte	0
 13272 01d6 02       		.byte	2
 13273 01d7 00       		.byte	0
 13274 01d8 00       		.byte	0
 13275 01d9 64       		.byte	100
 13276 01da 00       		.byte	0
 13277 01db 01       		.byte	1
 13278 01dc 00       		.byte	0
 13279 01dd 03       		.byte	3
 13280 01de 00       		.byte	0
 13281 01df 00       		.byte	0
 13282 01e0 00       		.byte	0
 13283 01e1 00       		.byte	0
 13284 01e2 00       		.byte	0
 13285 01e3 30       		.byte	48
 13286 01e4 01       		.byte	1
 13287 01e5 00       		.byte	0
 13288 01e6 00       		.byte	0
 13289 01e7 00000000 		.space	5
 13289      00
 13292              	CtrlParArry:
 13293 01ec 10       		.byte	16
 13294 01ed 10       		.byte	16
 13295 01ee 02       		.byte	2
 13296 01ef 00       		.byte	0
 13297 01f0 00       		.byte	0
 13298 01f1 03       		.byte	3
 13299 01f2 00       		.byte	0
 13300 01f3 01       		.byte	1
 13301 01f4 00       		.byte	0
 13302 01f5 03       		.byte	3
 13303 01f6 00       		.byte	0
 13304 01f7 03       		.byte	3
 13305 01f8 00       		.byte	0
 13306 01f9 03       		.byte	3
 13307 01fa 00       		.byte	0
 13308 01fb 30       		.byte	48
 13309 01fc 01       		.byte	1
 13310 01fd 00       		.byte	0
 13311 01fe 00       		.byte	0
 13312 01ff 00000000 		.space	5
 13312      00
 13313 0204 15       		.byte	21
 13314 0205 15       		.byte	21
 13315 0206 02       		.byte	2
 13316 0207 00       		.byte	0
 13317 0208 00       		.byte	0
 13318 0209 FF       		.byte	-1
 13319 020a 00       		.byte	0
 13320 020b 01       		.byte	1
 13321 020c 00       		.byte	0
 13322 020d 03       		.byte	3
 13323 020e 00       		.byte	0
 13324 020f 76       		.byte	118
 13325 0210 00       		.byte	0
 13326 0211 76       		.byte	118
 13327 0212 C7       		.byte	-57
 13328 0213 30       		.byte	48
 13329 0214 01       		.byte	1
 13330 0215 01       		.byte	1
 13331 0216 00       		.byte	0
 13332 0217 00000000 		.space	5
 13332      00
 13333 021c 04       		.byte	4
 13334 021d 04       		.byte	4
 13335 021e 02       		.byte	2
 13336 021f 00       		.byte	0
 13337 0220 00       		.byte	0
 13338 0221 FF       		.byte	-1
 13339 0222 00       		.byte	0
 13340 0223 01       		.byte	1
 13341 0224 00       		.byte	0
 13342 0225 03       		.byte	3
 13343 0226 00       		.byte	0
 13344 0227 70       		.byte	112
 13345 0228 00       		.byte	0
 13346 0229 70       		.byte	112
 13347 022a 00       		.byte	0
 13348 022b 30       		.byte	48
 13349 022c 01       		.byte	1
 13350 022d 01       		.byte	1
 13351 022e 00       		.byte	0
 13352 022f 00000000 		.space	5
 13352      00
 13353 0234 00       		.byte	0
 13354 0235 00       		.byte	0
 13355 0236 02       		.byte	2
 13356 0237 00       		.byte	0
 13357 0238 00       		.byte	0
 13358 0239 64       		.byte	100
 13359 023a 00       		.byte	0
 13360 023b 01       		.byte	1
 13361 023c 00       		.byte	0
 13362 023d 03       		.byte	3
 13363 023e 00       		.byte	0
 13364 023f 00       		.byte	0
 13365 0240 00       		.byte	0
 13366 0241 00       		.byte	0
 13367 0242 00       		.byte	0
 13368 0243 30       		.byte	48
 13369 0244 01       		.byte	1
 13370 0245 00       		.byte	0
 13371 0246 00       		.byte	0
 13372 0247 00000000 		.space	5
 13372      00
 13373 024c 07       		.byte	7
 13374 024d 07       		.byte	7
 13375 024e 02       		.byte	2
 13376 024f 00       		.byte	0
 13377 0250 00       		.byte	0
 13378 0251 01       		.byte	1
 13379 0252 00       		.byte	0
 13380 0253 01       		.byte	1
 13381 0254 00       		.byte	0
 13382 0255 03       		.byte	3
 13383 0256 00       		.byte	0
 13384 0257 01       		.byte	1
 13385 0258 00       		.byte	0
 13386 0259 01       		.byte	1
 13387 025a 00       		.byte	0
 13388 025b 30       		.byte	48
 13389 025c 01       		.byte	1
 13390 025d 00       		.byte	0
 13391 025e 00       		.byte	0
 13392 025f 00000000 		.space	5
 13392      00
 13393 0264 DF       		.byte	-33
 13394 0265 E1       		.byte	-31
 13395 0266 02       		.byte	2
 13396 0267 00       		.byte	0
 13397 0268 00       		.byte	0
 13398 0269 FF       		.byte	-1
 13399 026a 00       		.byte	0
 13400 026b 01       		.byte	1
 13401 026c 00       		.byte	0
 13402 026d 03       		.byte	3
 13403 026e 00       		.byte	0
 13404 026f 80       		.byte	-128
 13405 0270 00       		.byte	0
 13406 0271 00       		.byte	0
 13407 0272 00       		.byte	0
 13408 0273 C6       		.byte	-58
 13409 0274 01       		.byte	1
 13410 0275 01       		.byte	1
 13411 0276 00       		.byte	0
 13412 0277 00000000 		.space	5
 13412      00
 13413 027c 85       		.byte	-123
 13414 027d 86       		.byte	-122
 13415 027e 02       		.byte	2
 13416 027f 00       		.byte	0
 13417 0280 00       		.byte	0
 13418 0281 64       		.byte	100
 13419 0282 00       		.byte	0
 13420 0283 01       		.byte	1
 13421 0284 00       		.byte	0
 13422 0285 03       		.byte	3
 13423 0286 00       		.byte	0
 13424 0287 32       		.byte	50
 13425 0288 00       		.byte	0
 13426 0289 32       		.byte	50
 13427 028a 00       		.byte	0
 13428 028b F2       		.byte	-14
 13429 028c 01       		.byte	1
 13430 028d 01       		.byte	1
 13431 028e 00       		.byte	0
 13432 028f 00000000 		.space	5
 13432      00
 13433 0294 06       		.byte	6
 13434 0295 07       		.byte	7
 13435 0296 02       		.byte	2
 13436 0297 00       		.byte	0
 13437 0298 00       		.byte	0
 13438 0299 FF       		.byte	-1
 13439 029a 00       		.byte	0
 13440 029b 01       		.byte	1
 13441 029c 00       		.byte	0
 13442 029d 03       		.byte	3
 13443 029e 00       		.byte	0
 13444 029f 20       		.byte	32
 13445 02a0 00       		.byte	0
 13446 02a1 20       		.byte	32
 13447 02a2 00       		.byte	0
 13448 02a3 30       		.byte	48
 13449 02a4 01       		.byte	1
 13450 02a5 01       		.byte	1
 13451 02a6 00       		.byte	0
 13452 02a7 00000000 		.space	5
 13452      00
 13453 02ac 00       		.byte	0
 13454 02ad 00       		.byte	0
 13455 02ae 02       		.byte	2
 13456 02af 00       		.byte	0
 13457 02b0 00       		.byte	0
 13458 02b1 64       		.byte	100
 13459 02b2 00       		.byte	0
 13460 02b3 01       		.byte	1
 13461 02b4 00       		.byte	0
 13462 02b5 03       		.byte	3
 13463 02b6 00       		.byte	0
 13464 02b7 00       		.byte	0
 13465 02b8 00       		.byte	0
 13466 02b9 00       		.byte	0
 13467 02ba 00       		.byte	0
 13468 02bb 30       		.byte	48
 13469 02bc 01       		.byte	1
 13470 02bd 00       		.byte	0
 13471 02be 00       		.byte	0
 13472 02bf 00000000 		.space	5
 13472      00
 13473 02c4 08       		.byte	8
 13474 02c5 08       		.byte	8
 13475 02c6 02       		.byte	2
 13476 02c7 00       		.byte	0
 13477 02c8 00       		.byte	0
 13478 02c9 05       		.byte	5
 13479 02ca 00       		.byte	0
 13480 02cb 01       		.byte	1
 13481 02cc 00       		.byte	0
 13482 02cd 03       		.byte	3
 13483 02ce 00       		.byte	0
 13484 02cf 00       		.byte	0
 13485 02d0 00       		.byte	0
 13486 02d1 00       		.byte	0
 13487 02d2 00       		.byte	0
 13488 02d3 30       		.byte	48
 13489 02d4 01       		.byte	1
 13490 02d5 00       		.byte	0
 13491 02d6 00       		.byte	0
 13492 02d7 00000000 		.space	5
 13492      00
 13493 02dc 00       		.byte	0
 13494 02dd 00       		.byte	0
 13495 02de 02       		.byte	2
 13496 02df 00       		.byte	0
 13497 02e0 00       		.byte	0
 13498 02e1 40       		.byte	64
 13499 02e2 00       		.byte	0
 13500 02e3 01       		.byte	1
 13501 02e4 00       		.byte	0
 13502 02e5 03       		.byte	3
 13503 02e6 00       		.byte	0
 13504 02e7 00       		.byte	0
 13505 02e8 00       		.byte	0
 13506 02e9 00       		.byte	0
 13507 02ea 00       		.byte	0
 13508 02eb 30       		.byte	48
 13509 02ec 01       		.byte	1
 13510 02ed 00       		.byte	0
 13511 02ee 00       		.byte	0
 13512 02ef 00000000 		.space	5
 13512      00
 13513 02f4 09       		.byte	9
 13514 02f5 0A       		.byte	10
 13515 02f6 04       		.byte	4
 13516 02f7 00       		.byte	0
 13517 02f8 00       		.byte	0
 13518 02f9 40       		.byte	64
 13519 02fa 00       		.byte	0
 13520 02fb 01       		.byte	1
 13521 02fc 00       		.byte	0
 13522 02fd 03       		.byte	3
 13523 02fe 00       		.byte	0
 13524 02ff 20       		.byte	32
 13525 0300 38       		.byte	56
 13526 0301 20       		.byte	32
 13527 0302 38       		.byte	56
 13528 0303 30       		.byte	48
 13529 0304 01       		.byte	1
 13530 0305 00       		.byte	0
 13531 0306 00       		.byte	0
 13532 0307 00000000 		.space	5
 13532      00
 13533 030c 00       		.byte	0
 13534 030d 00       		.byte	0
 13535 030e 02       		.byte	2
 13536 030f 00       		.byte	0
 13537 0310 00       		.byte	0
 13538 0311 64       		.byte	100
 13539 0312 00       		.byte	0
 13540 0313 01       		.byte	1
 13541 0314 00       		.byte	0
 13542 0315 03       		.byte	3
 13543 0316 00       		.byte	0
 13544 0317 00       		.byte	0
 13545 0318 00       		.byte	0
 13546 0319 00       		.byte	0
 13547 031a 00       		.byte	0
 13548 031b 30       		.byte	48
 13549 031c 01       		.byte	1
 13550 031d 00       		.byte	0
 13551 031e 00       		.byte	0
 13552 031f 00000000 		.space	5
 13552      00
 13553 0324 00       		.byte	0
 13554 0325 00       		.byte	0
 13555 0326 02       		.byte	2
 13556 0327 00       		.byte	0
 13557 0328 00       		.byte	0
 13558 0329 64       		.byte	100
 13559 032a 00       		.byte	0
 13560 032b 01       		.byte	1
 13561 032c 00       		.byte	0
 13562 032d 03       		.byte	3
 13563 032e 00       		.byte	0
 13564 032f 00       		.byte	0
 13565 0330 00       		.byte	0
 13566 0331 00       		.byte	0
 13567 0332 00       		.byte	0
 13568 0333 30       		.byte	48
 13569 0334 01       		.byte	1
 13570 0335 00       		.byte	0
 13571 0336 00       		.byte	0
 13572 0337 00000000 		.space	5
 13572      00
 13573 033c 2A       		.byte	42
 13574 033d 2A       		.byte	42
 13575 033e 02       		.byte	2
 13576 033f 00       		.byte	0
 13577 0340 00       		.byte	0
 13578 0341 1B       		.byte	27
 13579 0342 00       		.byte	0
 13580 0343 01       		.byte	1
 13581 0344 00       		.byte	0
 13582 0345 03       		.byte	3
 13583 0346 00       		.byte	0
 13584 0347 00       		.byte	0
 13585 0348 00       		.byte	0
 13586 0349 00       		.byte	0
 13587 034a 00       		.byte	0
 13588 034b 30       		.byte	48
 13589 034c 01       		.byte	1
 13590 034d 00       		.byte	0
 13591 034e 00       		.byte	0
 13592 034f 00000000 		.space	5
 13592      00
 13593 0354 00       		.byte	0
 13594 0355 00       		.byte	0
 13595 0356 02       		.byte	2
 13596 0357 00       		.byte	0
 13597 0358 00       		.byte	0
 13598 0359 64       		.byte	100
 13599 035a 00       		.byte	0
 13600 035b 01       		.byte	1
 13601 035c 00       		.byte	0
 13602 035d 03       		.byte	3
 13603 035e 00       		.byte	0
 13604 035f 00       		.byte	0
 13605 0360 00       		.byte	0
 13606 0361 00       		.byte	0
 13607 0362 00       		.byte	0
 13608 0363 30       		.byte	48
 13609 0364 01       		.byte	1
 13610 0365 00       		.byte	0
 13611 0366 00       		.byte	0
 13612 0367 00000000 		.space	5
 13612      00
 13613 036c 00       		.byte	0
 13614 036d 00       		.byte	0
 13615 036e 02       		.byte	2
 13616 036f 00       		.byte	0
 13617 0370 00       		.byte	0
 13618 0371 12       		.byte	18
 13619 0372 00       		.byte	0
 13620 0373 01       		.byte	1
 13621 0374 00       		.byte	0
 13622 0375 03       		.byte	3
 13623 0376 00       		.byte	0
 13624 0377 00       		.byte	0
 13625 0378 00       		.byte	0
 13626 0379 00       		.byte	0
 13627 037a 00       		.byte	0
 13628 037b 30       		.byte	48
 13629 037c 01       		.byte	1
 13630 037d 00       		.byte	0
 13631 037e 00       		.byte	0
 13632 037f 00000000 		.space	5
 13632      00
 13633 0384 01       		.byte	1
 13634 0385 01       		.byte	1
 13635 0386 02       		.byte	2
 13636 0387 00       		.byte	0
 13637 0388 00       		.byte	0
 13638 0389 09       		.byte	9
 13639 038a 00       		.byte	0
 13640 038b 01       		.byte	1
 13641 038c 00       		.byte	0
 13642 038d 03       		.byte	3
 13643 038e 00       		.byte	0
 13644 038f 00       		.byte	0
 13645 0390 00       		.byte	0
 13646 0391 01       		.byte	1
 13647 0392 00       		.byte	0
 13648 0393 30       		.byte	48
 13649 0394 01       		.byte	1
 13650 0395 00       		.byte	0
 13651 0396 00       		.byte	0
 13652 0397 00000000 		.space	5
 13652      00
 13653 039c 05       		.byte	5
 13654 039d 05       		.byte	5
 13655 039e 02       		.byte	2
 13656 039f 00       		.byte	0
 13657 03a0 00       		.byte	0
 13658 03a1 03       		.byte	3
 13659 03a2 00       		.byte	0
 13660 03a3 01       		.byte	1
 13661 03a4 00       		.byte	0
 13662 03a5 03       		.byte	3
 13663 03a6 00       		.byte	0
 13664 03a7 00       		.byte	0
 13665 03a8 00       		.byte	0
 13666 03a9 00       		.byte	0
 13667 03aa 00       		.byte	0
 13668 03ab 30       		.byte	48
 13669 03ac 01       		.byte	1
 13670 03ad 00       		.byte	0
 13671 03ae 00       		.byte	0
 13672 03af 00000000 		.space	5
 13672      00
 13673 03b4 18       		.byte	24
 13674 03b5 18       		.byte	24
 13675 03b6 02       		.byte	2
 13676 03b7 00       		.byte	0
 13677 03b8 00       		.byte	0
 13678 03b9 01       		.byte	1
 13679 03ba 00       		.byte	0
 13680 03bb 01       		.byte	1
 13681 03bc 00       		.byte	0
 13682 03bd 03       		.byte	3
 13683 03be 00       		.byte	0
 13684 03bf 00       		.byte	0
 13685 03c0 00       		.byte	0
 13686 03c1 00       		.byte	0
 13687 03c2 00       		.byte	0
 13688 03c3 30       		.byte	48
 13689 03c4 01       		.byte	1
 13690 03c5 00       		.byte	0
 13691 03c6 00       		.byte	0
 13692 03c7 00000000 		.space	5
 13692      00
 13693 03cc 19       		.byte	25
 13694 03cd 19       		.byte	25
 13695 03ce 01       		.byte	1
 13696 03cf 00       		.byte	0
 13697 03d0 00       		.byte	0
 13698 03d1 40       		.byte	64
 13699 03d2 00       		.byte	0
 13700 03d3 01       		.byte	1
 13701 03d4 00       		.byte	0
 13702 03d5 03       		.byte	3
 13703 03d6 00       		.byte	0
 13704 03d7 20       		.byte	32
 13705 03d8 00       		.byte	0
 13706 03d9 20       		.byte	32
 13707 03da 00       		.byte	0
 13708 03db 30       		.byte	48
 13709 03dc 01       		.byte	1
 13710 03dd 00       		.byte	0
 13711 03de 00       		.byte	0
 13712 03df 00000000 		.space	5
 13712      00
 13713 03e4 20       		.byte	32
 13714 03e5 20       		.byte	32
 13715 03e6 02       		.byte	2
 13716 03e7 00       		.byte	0
 13717 03e8 00       		.byte	0
 13718 03e9 02       		.byte	2
 13719 03ea 00       		.byte	0
 13720 03eb 01       		.byte	1
 13721 03ec 00       		.byte	0
 13722 03ed 03       		.byte	3
 13723 03ee 00       		.byte	0
 13724 03ef 00       		.byte	0
 13725 03f0 00       		.byte	0
 13726 03f1 00       		.byte	0
 13727 03f2 00       		.byte	0
 13728 03f3 30       		.byte	48
 13729 03f4 01       		.byte	1
 13730 03f5 00       		.byte	0
 13731 03f6 00       		.byte	0
 13732 03f7 00000000 		.space	5
 13732      00
 13733 03fc 22       		.byte	34
 13734 03fd 22       		.byte	34
 13735 03fe 02       		.byte	2
 13736 03ff 00       		.byte	0
 13737 0400 00       		.byte	0
 13738 0401 3F       		.byte	63
 13739 0402 00       		.byte	0
 13740 0403 01       		.byte	1
 13741 0404 00       		.byte	0
 13742 0405 03       		.byte	3
 13743 0406 00       		.byte	0
 13744 0407 00       		.byte	0
 13745 0408 00       		.byte	0
 13746 0409 00       		.byte	0
 13747 040a 00       		.byte	0
 13748 040b 30       		.byte	48
 13749 040c 01       		.byte	1
 13750 040d 00       		.byte	0
 13751 040e 00       		.byte	0
 13752 040f 00000000 		.space	5
 13752      00
 13753 0414 23       		.byte	35
 13754 0415 23       		.byte	35
 13755 0416 02       		.byte	2
 13756 0417 00       		.byte	0
 13757 0418 00       		.byte	0
 13758 0419 64       		.byte	100
 13759 041a 00       		.byte	0
 13760 041b 01       		.byte	1
 13761 041c 00       		.byte	0
 13762 041d 03       		.byte	3
 13763 041e 00       		.byte	0
 13764 041f 10       		.byte	16
 13765 0420 00       		.byte	0
 13766 0421 10       		.byte	16
 13767 0422 00       		.byte	0
 13768 0423 30       		.byte	48
 13769 0424 01       		.byte	1
 13770 0425 00       		.byte	0
 13771 0426 00       		.byte	0
 13772 0427 00000000 		.space	5
 13772      00
 13773 042c 24       		.byte	36
 13774 042d 24       		.byte	36
 13775 042e 02       		.byte	2
 13776 042f 00       		.byte	0
 13777 0430 00       		.byte	0
 13778 0431 64       		.byte	100
 13779 0432 00       		.byte	0
 13780 0433 01       		.byte	1
 13781 0434 00       		.byte	0
 13782 0435 03       		.byte	3
 13783 0436 00       		.byte	0
 13784 0437 10       		.byte	16
 13785 0438 00       		.byte	0
 13786 0439 10       		.byte	16
 13787 043a 00       		.byte	0
 13788 043b 30       		.byte	48
 13789 043c 01       		.byte	1
 13790 043d 00       		.byte	0
 13791 043e 00       		.byte	0
 13792 043f 00000000 		.space	5
 13792      00
 13793 0444 00       		.byte	0
 13794 0445 03       		.byte	3
 13795 0446 04       		.byte	4
 13796 0447 00       		.byte	0
 13797 0448 00       		.byte	0
 13798 0449 7F       		.byte	127
 13799 044a 00       		.byte	0
 13800 044b 01       		.byte	1
 13801 044c 00       		.byte	0
 13802 044d 03       		.byte	3
 13803 044e 00       		.byte	0
 13804 044f 00       		.byte	0
 13805 0450 20       		.byte	32
 13806 0451 00       		.byte	0
 13807 0452 20       		.byte	32
 13808 0453 30       		.byte	48
 13809 0454 01       		.byte	1
 13810 0455 00       		.byte	0
 13811 0456 00       		.byte	0
 13812 0457 00000000 		.space	5
 13812      00
 13813 045c 04       		.byte	4
 13814 045d 04       		.byte	4
 13815 045e 02       		.byte	2
 13816 045f 00       		.byte	0
 13817 0460 00       		.byte	0
 13818 0461 FF       		.byte	-1
 13819 0462 00       		.byte	0
 13820 0463 01       		.byte	1
 13821 0464 00       		.byte	0
 13822 0465 03       		.byte	3
 13823 0466 00       		.byte	0
 13824 0467 60       		.byte	96
 13825 0468 00       		.byte	0
 13826 0469 60       		.byte	96
 13827 046a 00       		.byte	0
 13828 046b 30       		.byte	48
 13829 046c 01       		.byte	1
 13830 046d 00       		.byte	0
 13831 046e 00       		.byte	0
 13832 046f 00000000 		.space	5
 13832      00
 13833 0474 00       		.byte	0
 13834 0475 00       		.byte	0
 13835 0476 02       		.byte	2
 13836 0477 00       		.byte	0
 13837 0478 00       		.byte	0
 13838 0479 19       		.byte	25
 13839 047a 00       		.byte	0
 13840 047b 01       		.byte	1
 13841 047c 00       		.byte	0
 13842 047d 03       		.byte	3
 13843 047e 00       		.byte	0
 13844 047f 00       		.byte	0
 13845 0480 00       		.byte	0
 13846 0481 00       		.byte	0
 13847 0482 00       		.byte	0
 13848 0483 30       		.byte	48
 13849 0484 01       		.byte	1
 13850 0485 00       		.byte	0
 13851 0486 00       		.byte	0
 13852 0487 00000000 		.space	5
 13852      00
 13853 048c 10       		.byte	16
 13854 048d 10       		.byte	16
 13855 048e 02       		.byte	2
 13856 048f 00       		.byte	0
 13857 0490 00       		.byte	0
 13858 0491 06       		.byte	6
 13859 0492 00       		.byte	0
 13860 0493 01       		.byte	1
 13861 0494 00       		.byte	0
 13862 0495 03       		.byte	3
 13863 0496 00       		.byte	0
 13864 0497 03       		.byte	3
 13865 0498 00       		.byte	0
 13866 0499 03       		.byte	3
 13867 049a 00       		.byte	0
 13868 049b 30       		.byte	48
 13869 049c 01       		.byte	1
 13870 049d 00       		.byte	0
 13871 049e 00       		.byte	0
 13872 049f 00000000 		.space	5
 13872      00
 13873 04a4 00       		.byte	0
 13874 04a5 00       		.byte	0
 13875 04a6 02       		.byte	2
 13876 04a7 00       		.byte	0
 13877 04a8 00       		.byte	0
 13878 04a9 03       		.byte	3
 13879 04aa 00       		.byte	0
 13880 04ab 01       		.byte	1
 13881 04ac 00       		.byte	0
 13882 04ad 03       		.byte	3
 13883 04ae 00       		.byte	0
 13884 04af 00       		.byte	0
 13885 04b0 00       		.byte	0
 13886 04b1 00       		.byte	0
 13887 04b2 00       		.byte	0
 13888 04b3 30       		.byte	48
 13889 04b4 01       		.byte	1
 13890 04b5 00       		.byte	0
 13891 04b6 00       		.byte	0
 13892 04b7 00000000 		.space	5
 13892      00
 13893 04bc 50       		.byte	80
 13894 04bd 50       		.byte	80
 13895 04be 01       		.byte	1
 13896 04bf 00       		.byte	0
 13897 04c0 00       		.byte	0
 13898 04c1 03       		.byte	3
 13899 04c2 00       		.byte	0
 13900 04c3 01       		.byte	1
 13901 04c4 00       		.byte	0
 13902 04c5 03       		.byte	3
 13903 04c6 00       		.byte	0
 13904 04c7 00       		.byte	0
 13905 04c8 00       		.byte	0
 13906 04c9 00       		.byte	0
 13907 04ca 00       		.byte	0
 13908 04cb 30       		.byte	48
 13909 04cc 01       		.byte	1
 13910 04cd 00       		.byte	0
 13911 04ce 00       		.byte	0
 13912 04cf 00000000 		.space	5
 13912      00
 13913 04d4 00       		.byte	0
 13914 04d5 00       		.byte	0
 13915 04d6 0B       		.byte	11
 13916 04d7 00       		.byte	0
 13917 04d8 00       		.byte	0
 13918 04d9 FF       		.byte	-1
 13919 04da FF       		.byte	-1
 13920 04db 01       		.byte	1
 13921 04dc 00       		.byte	0
 13922 04dd 03       		.byte	3
 13923 04de 00       		.byte	0
 13924 04df 00       		.byte	0
 13925 04e0 00       		.byte	0
 13926 04e1 00       		.byte	0
 13927 04e2 00       		.byte	0
 13928 04e3 00       		.byte	0
 13929 04e4 01       		.byte	1
 13930 04e5 00       		.byte	0
 13931 04e6 00       		.byte	0
 13932 04e7 00000000 		.space	5
 13932      00
 13935              	glUVCHeader:
 13936 04ec 0C       		.byte	12
 13937 04ed 8C       		.byte	-116
 13938 04ee 00       		.byte	0
 13939 04ef 00       		.byte	0
 13940 04f0 00       		.byte	0
 13941 04f1 00       		.byte	0
 13942 04f2 00       		.byte	0
 13943 04f3 00       		.byte	0
 13944 04f4 00       		.byte	0
 13945 04f5 00       		.byte	0
 13946 04f6 00       		.byte	0
 13947 04f7 00       		.byte	0
 13950              	EXTBLCGrid:
 13951 04f8 10       		.byte	16
 13952 04f9 10       		.byte	16
 13953 04fa 02       		.byte	2
 13954 04fb 01       		.byte	1
 13955 04fc 00       		.byte	0
 13956 04fd 02       		.byte	2
 13957 04fe 00       		.byte	0
 13958 04ff 01       		.byte	1
 13959 0500 00       		.byte	0
 13960 0501 03       		.byte	3
 13961 0502 00       		.byte	0
 13962 0503 00       		.byte	0
 13963 0504 00       		.byte	0
 13964 0505 00       		.byte	0
 13965 0506 00       		.byte	0
 13966 0507 30       		.byte	48
 13967 0508 01       		.byte	1
 13968 0509 00       		.byte	0
 13969 050a 0000     		.space	2
 13972              	EXTAexModGainlev:
 13973 050c 00       		.byte	0
 13974 050d 03       		.byte	3
 13975 050e 04       		.byte	4
 13976 050f 00       		.byte	0
 13977 0510 00       		.byte	0
 13978 0511 7F       		.byte	127
 13979 0512 00       		.byte	0
 13980 0513 01       		.byte	1
 13981 0514 00       		.byte	0
 13982 0515 03       		.byte	3
 13983 0516 00       		.byte	0
 13984 0517 00       		.byte	0
 13985 0518 3F       		.byte	63
 13986 0519 00       		.byte	0
 13987 051a 3F       		.byte	63
 13988 051b 30       		.byte	48
 13989 051c 01       		.byte	1
 13990 051d 00       		.byte	0
 13991 051e 0000     		.space	2
 13994              	PUCBright:
 13995 0520 15       		.byte	21
 13996 0521 15       		.byte	21
 13997 0522 02       		.byte	2
 13998 0523 00       		.byte	0
 13999 0524 00       		.byte	0
 14000 0525 FF       		.byte	-1
 14001 0526 00       		.byte	0
 14002 0527 01       		.byte	1
 14003 0528 00       		.byte	0
 14004 0529 03       		.byte	3
 14005 052a 00       		.byte	0
 14006 052b 76       		.byte	118
 14007 052c 00       		.byte	0
 14008 052d 76       		.byte	118
 14009 052e 77       		.byte	119
 14010 052f 30       		.byte	48
 14011 0530 01       		.byte	1
 14012 0531 00       		.byte	0
 14013 0532 0000     		.space	2
 14016              	PUCHueC:
 14017 0534 DF       		.byte	-33
 14018 0535 E1       		.byte	-31
 14019 0536 02       		.byte	2
 14020 0537 00       		.byte	0
 14021 0538 00       		.byte	0
 14022 0539 FF       		.byte	-1
 14023 053a 00       		.byte	0
 14024 053b 01       		.byte	1
 14025 053c 00       		.byte	0
 14026 053d 03       		.byte	3
 14027 053e 00       		.byte	0
 14028 053f 80       		.byte	-128
 14029 0540 00       		.byte	0
 14030 0541 00       		.byte	0
 14031 0542 00       		.byte	0
 14032 0543 30       		.byte	48
 14033 0544 01       		.byte	1
 14034 0545 00       		.byte	0
 14035 0546 0000     		.space	2
 14038              	PUCPLFreq:
 14039 0548 07       		.byte	7
 14040 0549 07       		.byte	7
 14041 054a 02       		.byte	2
 14042 054b 00       		.byte	0
 14043 054c 00       		.byte	0
 14044 054d 01       		.byte	1
 14045 054e 00       		.byte	0
 14046 054f 01       		.byte	1
 14047 0550 00       		.byte	0
 14048 0551 03       		.byte	3
 14049 0552 00       		.byte	0
 14050 0553 01       		.byte	1
 14051 0554 00       		.byte	0
 14052 0555 01       		.byte	1
 14053 0556 00       		.byte	0
 14054 0557 30       		.byte	48
 14055 0558 01       		.byte	1
 14056 0559 00       		.byte	0
 14057 055a 0000     		.space	2
 14060              	WBMenuCmpArry:
 14061 055c 20       		.byte	32
 14062 055d 0F       		.byte	15
 14063 055e 38       		.byte	56
 14064 055f F0       		.byte	-16
 14067              	PUCBLC:
 14068 0560 10       		.byte	16
 14069 0561 11       		.byte	17
 14070 0562 02       		.byte	2
 14071 0563 00       		.byte	0
 14072 0564 00       		.byte	0
 14073 0565 03       		.byte	3
 14074 0566 00       		.byte	0
 14075 0567 01       		.byte	1
 14076 0568 00       		.byte	0
 14077 0569 03       		.byte	3
 14078 056a 00       		.byte	0
 14079 056b 03       		.byte	3
 14080 056c 00       		.byte	0
 14081 056d 03       		.byte	3
 14082 056e 00       		.byte	0
 14083 056f 30       		.byte	48
 14084 0570 01       		.byte	1
 14085 0571 00       		.byte	0
 14086 0572 0000     		.space	2
 14089              	EXTShutter:
 14090 0574 00       		.byte	0
 14091 0575 02       		.byte	2
 14092 0576 02       		.byte	2
 14093 0577 00       		.byte	0
 14094 0578 00       		.byte	0
 14095 0579 08       		.byte	8
 14096 057a 00       		.byte	0
 14097 057b 01       		.byte	1
 14098 057c 00       		.byte	0
 14099 057d 03       		.byte	3
 14100 057e 00       		.byte	0
 14101 057f 00       		.byte	0
 14102 0580 00       		.byte	0
 14103 0581 00       		.byte	0
 14104 0582 00       		.byte	0
 14105 0583 30       		.byte	48
 14106 0584 01       		.byte	1
 14107 0585 00       		.byte	0
 14108 0586 0000     		.space	2
 14111              	EXTShutlev:
 14112 0588 02       		.byte	2
 14113 0589 12       		.byte	18
 14114 058a 02       		.byte	2
 14115 058b 00       		.byte	0
 14116 058c 00       		.byte	0
 14117 058d FF       		.byte	-1
 14118 058e 7F       		.byte	127
 14119 058f 01       		.byte	1
 14120 0590 00       		.byte	0
 14121 0591 03       		.byte	3
 14122 0592 00       		.byte	0
 14123 0593 3F       		.byte	63
 14124 0594 00       		.byte	0
 14125 0595 3F       		.byte	63
 14126 0596 00       		.byte	0
 14127 0597 30       		.byte	48
 14128 0598 01       		.byte	1
 14129 0599 00       		.byte	0
 14130 059a 0000     		.space	2
 14133              	EXTBLCWinPos:
 14134 059c 14       		.byte	20
 14135 059d 13       		.byte	19
 14136 059e 02       		.byte	2
 14137 059f 00       		.byte	0
 14138 05a0 00       		.byte	0
 14139 05a1 FF       		.byte	-1
 14140 05a2 FF       		.byte	-1
 14141 05a3 01       		.byte	1
 14142 05a4 00       		.byte	0
 14143 05a5 03       		.byte	3
 14144 05a6 00       		.byte	0
 14145 05a7 66       		.byte	102
 14146 05a8 66       		.byte	102
 14147 05a9 66       		.byte	102
 14148 05aa 66       		.byte	102
 14149 05ab 30       		.byte	48
 14150 05ac 01       		.byte	1
 14151 05ad 00       		.byte	0
 14152 05ae 0000     		.space	2
 14155              	CTCtrlParArry:
 14156 05b0 00       		.byte	0
 14157 05b1 00       		.byte	0
 14158 05b2 01       		.byte	1
 14159 05b3 00       		.byte	0
 14160 05b4 00       		.byte	0
 14161 05b5 03       		.byte	3
 14162 05b6 00       		.byte	0
 14163 05b7 01       		.byte	1
 14164 05b8 00       		.byte	0
 14165 05b9 03       		.byte	3
 14166 05ba 00       		.byte	0
 14167 05bb 03       		.byte	3
 14168 05bc 00       		.byte	0
 14169 05bd 03       		.byte	3
 14170 05be 00       		.byte	0
 14171 05bf 30       		.byte	48
 14172 05c0 01       		.byte	1
 14173 05c1 00       		.byte	0
 14174 05c2 00       		.byte	0
 14175 05c3 00000000 		.space	5
 14175      00
 14176 05c8 00       		.byte	0
 14177 05c9 00       		.byte	0
 14178 05ca 01       		.byte	1
 14179 05cb 01       		.byte	1
 14180 05cc 00       		.byte	0
 14181 05cd 0F       		.byte	15
 14182 05ce 00       		.byte	0
 14183 05cf 0F       		.byte	15
 14184 05d0 00       		.byte	0
 14185 05d1 03       		.byte	3
 14186 05d2 00       		.byte	0
 14187 05d3 02       		.byte	2
 14188 05d4 00       		.byte	0
 14189 05d5 02       		.byte	2
 14190 05d6 00       		.byte	0
 14191 05d7 30       		.byte	48
 14192 05d8 01       		.byte	1
 14193 05d9 01       		.byte	1
 14194 05da 00       		.byte	0
 14195 05db 00000000 		.space	5
 14195      00
 14196 05e0 02       		.byte	2
 14197 05e1 00       		.byte	0
 14198 05e2 01       		.byte	1
 14199 05e3 00       		.byte	0
 14200 05e4 00       		.byte	0
 14201 05e5 01       		.byte	1
 14202 05e6 00       		.byte	0
 14203 05e7 01       		.byte	1
 14204 05e8 00       		.byte	0
 14205 05e9 03       		.byte	3
 14206 05ea 00       		.byte	0
 14207 05eb 00       		.byte	0
 14208 05ec 00       		.byte	0
 14209 05ed 00       		.byte	0
 14210 05ee 00       		.byte	0
 14211 05ef 30       		.byte	48
 14212 05f0 01       		.byte	1
 14213 05f1 01       		.byte	1
 14214 05f2 00       		.byte	0
 14215 05f3 00000000 		.space	5
 14215      00
 14216 05f8 00       		.byte	0
 14217 05f9 00       		.byte	0
 14218 05fa 04       		.byte	4
 14219 05fb 01       		.byte	1
 14220 05fc 00       		.byte	0
 14221 05fd 38       		.byte	56
 14222 05fe 01       		.byte	1
 14223 05ff 01       		.byte	1
 14224 0600 00       		.byte	0
 14225 0601 03       		.byte	3
 14226 0602 00       		.byte	0
 14227 0603 4E       		.byte	78
 14228 0604 00       		.byte	0
 14229 0605 4E       		.byte	78
 14230 0606 00       		.byte	0
 14231 0607 30       		.byte	48
 14232 0608 01       		.byte	1
 14233 0609 00       		.byte	0
 14234 060a 00       		.byte	0
 14235 060b 00000000 		.space	5
 14235      00
 14236 0610 04       		.byte	4
 14237 0611 00       		.byte	0
 14238 0612 01       		.byte	1
 14239 0613 00       		.byte	0
 14240 0614 00       		.byte	0
 14241 0615 00       		.byte	0
 14242 0616 00       		.byte	0
 14243 0617 01       		.byte	1
 14244 0618 00       		.byte	0
 14245 0619 03       		.byte	3
 14246 061a 00       		.byte	0
 14247 061b 00       		.byte	0
 14248 061c 00       		.byte	0
 14249 061d 00       		.byte	0
 14250 061e 00       		.byte	0
 14251 061f 30       		.byte	48
 14252 0620 01       		.byte	1
 14253 0621 00       		.byte	0
 14254 0622 00       		.byte	0
 14255 0623 00000000 		.space	5
 14255      00
 14256 0628 05       		.byte	5
 14257 0629 00       		.byte	0
 14258 062a 02       		.byte	2
 14259 062b 00       		.byte	0
 14260 062c 00       		.byte	0
 14261 062d FF       		.byte	-1
 14262 062e 00       		.byte	0
 14263 062f 01       		.byte	1
 14264 0630 00       		.byte	0
 14265 0631 03       		.byte	3
 14266 0632 00       		.byte	0
 14267 0633 01       		.byte	1
 14268 0634 00       		.byte	0
 14269 0635 00       		.byte	0
 14270 0636 00       		.byte	0
 14271 0637 30       		.byte	48
 14272 0638 01       		.byte	1
 14273 0639 01       		.byte	1
 14274 063a 00       		.byte	0
 14275 063b 00000000 		.space	5
 14275      00
 14276 0640 06       		.byte	6
 14277 0641 00       		.byte	0
 14278 0642 02       		.byte	2
 14279 0643 00       		.byte	0
 14280 0644 00       		.byte	0
 14281 0645 00       		.byte	0
 14282 0646 00       		.byte	0
 14283 0647 00       		.byte	0
 14284 0648 00       		.byte	0
 14285 0649 03       		.byte	3
 14286 064a 00       		.byte	0
 14287 064b 00       		.byte	0
 14288 064c 00       		.byte	0
 14289 064d 00       		.byte	0
 14290 064e 00       		.byte	0
 14291 064f 30       		.byte	48
 14292 0650 01       		.byte	1
 14293 0651 01       		.byte	1
 14294 0652 00       		.byte	0
 14295 0653 00000000 		.space	5
 14295      00
 14296 0658 23       		.byte	35
 14297 0659 00       		.byte	0
 14298 065a 02       		.byte	2
 14299 065b 00       		.byte	0
 14300 065c 00       		.byte	0
 14301 065d 30       		.byte	48
 14302 065e 00       		.byte	0
 14303 065f 01       		.byte	1
 14304 0660 00       		.byte	0
 14305 0661 03       		.byte	3
 14306 0662 0A       		.byte	10
 14307 0663 00       		.byte	0
 14308 0664 00       		.byte	0
 14309 0665 0A       		.byte	10
 14310 0666 00       		.byte	0
 14311 0667 30       		.byte	48
 14312 0668 01       		.byte	1
 14313 0669 01       		.byte	1
 14314 066a 00       		.byte	0
 14315 066b 00000000 		.space	5
 14315      00
 14316 0670 08       		.byte	8
 14317 0671 00       		.byte	0
 14318 0672 01       		.byte	1
 14319 0673 00       		.byte	0
 14320 0674 00       		.byte	0
 14321 0675 7F       		.byte	127
 14322 0676 00       		.byte	0
 14323 0677 01       		.byte	1
 14324 0678 00       		.byte	0
 14325 0679 03       		.byte	3
 14326 067a 00       		.byte	0
 14327 067b 00       		.byte	0
 14328 067c 00       		.byte	0
 14329 067d 00       		.byte	0
 14330 067e 00       		.byte	0
 14331 067f 30       		.byte	48
 14332 0680 01       		.byte	1
 14333 0681 00       		.byte	0
 14334 0682 00       		.byte	0
 14335 0683 00000000 		.space	5
 14335      00
 14336 0688 09       		.byte	9
 14337 0689 00       		.byte	0
 14338 068a 02       		.byte	2
 14339 068b 00       		.byte	0
 14340 068c 00       		.byte	0
 14341 068d 05       		.byte	5
 14342 068e 00       		.byte	0
 14343 068f 01       		.byte	1
 14344 0690 00       		.byte	0
 14345 0691 03       		.byte	3
 14346 0692 00       		.byte	0
 14347 0693 00       		.byte	0
 14348 0694 00       		.byte	0
 14349 0695 00       		.byte	0
 14350 0696 00       		.byte	0
 14351 0697 30       		.byte	48
 14352 0698 01       		.byte	1
 14353 0699 00       		.byte	0
 14354 069a 00       		.byte	0
 14355 069b 00000000 		.space	5
 14355      00
 14356 06a0 10       		.byte	16
 14357 06a1 00       		.byte	0
 14358 06a2 03       		.byte	3
 14359 06a3 00       		.byte	0
 14360 06a4 00       		.byte	0
 14361 06a5 00       		.byte	0
 14362 06a6 00       		.byte	0
 14363 06a7 00       		.byte	0
 14364 06a8 00       		.byte	0
 14365 06a9 03       		.byte	3
 14366 06aa 00       		.byte	0
 14367 06ab 00       		.byte	0
 14368 06ac 00       		.byte	0
 14369 06ad 00       		.byte	0
 14370 06ae 00       		.byte	0
 14371 06af 30       		.byte	48
 14372 06b0 01       		.byte	1
 14373 06b1 00       		.byte	0
 14374 06b2 00       		.byte	0
 14375 06b3 00000000 		.space	5
 14375      00
 14376 06b8 00       		.byte	0
 14377 06b9 00       		.byte	0
 14378 06ba 02       		.byte	2
 14379 06bb 00       		.byte	0
 14380 06bc 00       		.byte	0
 14381 06bd 40       		.byte	64
 14382 06be 00       		.byte	0
 14383 06bf 01       		.byte	1
 14384 06c0 00       		.byte	0
 14385 06c1 03       		.byte	3
 14386 06c2 00       		.byte	0
 14387 06c3 0F       		.byte	15
 14388 06c4 11       		.byte	17
 14389 06c5 00       		.byte	0
 14390 06c6 00       		.byte	0
 14391 06c7 30       		.byte	48
 14392 06c8 01       		.byte	1
 14393 06c9 00       		.byte	0
 14394 06ca 00       		.byte	0
 14395 06cb 00000000 		.space	5
 14395      00
 14396 06d0 00       		.byte	0
 14397 06d1 00       		.byte	0
 14398 06d2 02       		.byte	2
 14399 06d3 00       		.byte	0
 14400 06d4 00       		.byte	0
 14401 06d5 64       		.byte	100
 14402 06d6 00       		.byte	0
 14403 06d7 01       		.byte	1
 14404 06d8 00       		.byte	0
 14405 06d9 03       		.byte	3
 14406 06da 00       		.byte	0
 14407 06db 00       		.byte	0
 14408 06dc 00       		.byte	0
 14409 06dd 00       		.byte	0
 14410 06de 00       		.byte	0
 14411 06df 30       		.byte	48
 14412 06e0 01       		.byte	1
 14413 06e1 00       		.byte	0
 14414 06e2 00       		.byte	0
 14415 06e3 00000000 		.space	5
 14415      00
 14416 06e8 00       		.byte	0
 14417 06e9 00       		.byte	0
 14418 06ea 02       		.byte	2
 14419 06eb 00       		.byte	0
 14420 06ec 00       		.byte	0
 14421 06ed 64       		.byte	100
 14422 06ee 00       		.byte	0
 14423 06ef 01       		.byte	1
 14424 06f0 00       		.byte	0
 14425 06f1 03       		.byte	3
 14426 06f2 00       		.byte	0
 14427 06f3 00       		.byte	0
 14428 06f4 00       		.byte	0
 14429 06f5 00       		.byte	0
 14430 06f6 00       		.byte	0
 14431 06f7 30       		.byte	48
 14432 06f8 01       		.byte	1
 14433 06f9 00       		.byte	0
 14434 06fa 00       		.byte	0
 14435 06fb 00000000 		.space	5
 14435      00
 14436 0700 00       		.byte	0
 14437 0701 00       		.byte	0
 14438 0702 02       		.byte	2
 14439 0703 00       		.byte	0
 14440 0704 00       		.byte	0
 14441 0705 64       		.byte	100
 14442 0706 00       		.byte	0
 14443 0707 01       		.byte	1
 14444 0708 00       		.byte	0
 14445 0709 03       		.byte	3
 14446 070a 00       		.byte	0
 14447 070b 00       		.byte	0
 14448 070c 00       		.byte	0
 14449 070d 00       		.byte	0
 14450 070e 00       		.byte	0
 14451 070f 30       		.byte	48
 14452 0710 01       		.byte	1
 14453 0711 00       		.byte	0
 14454 0712 00       		.byte	0
 14455 0713 00000000 		.space	5
 14455      00
 14456 0718 00       		.byte	0
 14457 0719 00       		.byte	0
 14458 071a 02       		.byte	2
 14459 071b 00       		.byte	0
 14460 071c 00       		.byte	0
 14461 071d 64       		.byte	100
 14462 071e 00       		.byte	0
 14463 071f 01       		.byte	1
 14464 0720 00       		.byte	0
 14465 0721 03       		.byte	3
 14466 0722 00       		.byte	0
 14467 0723 00       		.byte	0
 14468 0724 00       		.byte	0
 14469 0725 00       		.byte	0
 14470 0726 00       		.byte	0
 14471 0727 30       		.byte	48
 14472 0728 01       		.byte	1
 14473 0729 00       		.byte	0
 14474 072a 00       		.byte	0
 14475 072b 00000000 		.space	5
 14475      00
 14478              	EXTDayNightdely:
 14479 0730 22       		.byte	34
 14480 0731 22       		.byte	34
 14481 0732 02       		.byte	2
 14482 0733 00       		.byte	0
 14483 0734 00       		.byte	0
 14484 0735 3F       		.byte	63
 14485 0736 00       		.byte	0
 14486 0737 01       		.byte	1
 14487 0738 00       		.byte	0
 14488 0739 03       		.byte	3
 14489 073a 00       		.byte	0
 14490 073b 00       		.byte	0
 14491 073c 00       		.byte	0
 14492 073d 00       		.byte	0
 14493 073e 00       		.byte	0
 14494 073f 30       		.byte	48
 14495 0740 01       		.byte	1
 14496 0741 00       		.byte	0
 14497 0742 0000     		.space	2
 14500              	EXTEnhanceGain:
 14501 0744 07       		.byte	7
 14502 0745 07       		.byte	7
 14503 0746 02       		.byte	2
 14504 0747 00       		.byte	0
 14505 0748 00       		.byte	0
 14506 0749 FF       		.byte	-1
 14507 074a 00       		.byte	0
 14508 074b 01       		.byte	1
 14509 074c 00       		.byte	0
 14510 074d 03       		.byte	3
 14511 074e 00       		.byte	0
 14512 074f 80       		.byte	-128
 14513 0750 00       		.byte	0
 14514 0751 80       		.byte	-128
 14515 0752 00       		.byte	0
 14516 0753 30       		.byte	48
 14517 0754 01       		.byte	1
 14518 0755 00       		.byte	0
 14519 0756 0000     		.space	2
 14522              	EXTEnhanceSTED:
 14523 0758 08       		.byte	8
 14524 0759 09       		.byte	9
 14525 075a 04       		.byte	4
 14526 075b 00       		.byte	0
 14527 075c 00       		.byte	0
 14528 075d FF       		.byte	-1
 14529 075e 00       		.byte	0
 14530 075f 01       		.byte	1
 14531 0760 00       		.byte	0
 14532 0761 03       		.byte	3
 14533 0762 00       		.byte	0
 14534 0763 80       		.byte	-128
 14535 0764 00       		.byte	0
 14536 0765 80       		.byte	-128
 14537 0766 00       		.byte	0
 14538 0767 30       		.byte	48
 14539 0768 01       		.byte	1
 14540 0769 00       		.byte	0
 14543              	snapButFlag:
 14544 076a 01       		.byte	1
 14545 076b 00       		.space	1
 14548              	EXTAGCMaxLimit:
 14549 076c 0C       		.byte	12
 14550 076d 0C       		.byte	12
 14551 076e 02       		.byte	2
 14552 076f 00       		.byte	0
 14553 0770 00       		.byte	0
 14554 0771 10       		.byte	16
 14555 0772 00       		.byte	0
 14556 0773 01       		.byte	1
 14557 0774 00       		.byte	0
 14558 0775 03       		.byte	3
 14559 0776 00       		.byte	0
 14560 0777 00       		.byte	0
 14561 0778 00       		.byte	0
 14562 0779 00       		.byte	0
 14563 077a 00       		.byte	0
 14564 077b 30       		.byte	48
 14565 077c 01       		.byte	1
 14566 077d 00       		.byte	0
 14567 077e 0000     		.space	2
 14570              	EXTGammaCor:
 14571 0780 17       		.byte	23
 14572 0781 17       		.byte	23
 14573 0782 02       		.byte	2
 14574 0783 00       		.byte	0
 14575 0784 00       		.byte	0
 14576 0785 10       		.byte	16
 14577 0786 00       		.byte	0
 14578 0787 01       		.byte	1
 14579 0788 00       		.byte	0
 14580 0789 03       		.byte	3
 14581 078a 00       		.byte	0
 14582 078b 00       		.byte	0
 14583 078c 00       		.byte	0
 14584 078d 00       		.byte	0
 14585 078e 00       		.byte	0
 14586 078f 30       		.byte	48
 14587 0790 01       		.byte	1
 14588 0791 00       		.byte	0
 14589 0792 0000     		.space	2
 14592              	EXT2DNRSTED:
 14593 0794 1A       		.byte	26
 14594 0795 1B       		.byte	27
 14595 0796 04       		.byte	4
 14596 0797 00       		.byte	0
 14597 0798 00       		.byte	0
 14598 0799 FF       		.byte	-1
 14599 079a 00       		.byte	0
 14600 079b 01       		.byte	1
 14601 079c 00       		.byte	0
 14602 079d 03       		.byte	3
 14603 079e 00       		.byte	0
 14604 079f 80       		.byte	-128
 14605 07a0 00       		.byte	0
 14606 07a1 80       		.byte	-128
 14607 07a2 00       		.byte	0
 14608 07a3 30       		.byte	48
 14609 07a4 01       		.byte	1
 14610 07a5 00       		.byte	0
 14611 07a6 0000     		.space	2
 14614              	EXT2DNRGain:
 14615 07a8 18       		.byte	24
 14616 07a9 19       		.byte	25
 14617 07aa 02       		.byte	2
 14618 07ab 00       		.byte	0
 14619 07ac 00       		.byte	0
 14620 07ad FF       		.byte	-1
 14621 07ae 00       		.byte	0
 14622 07af 01       		.byte	1
 14623 07b0 00       		.byte	0
 14624 07b1 03       		.byte	3
 14625 07b2 00       		.byte	0
 14626 07b3 80       		.byte	-128
 14627 07b4 00       		.byte	0
 14628 07b5 80       		.byte	-128
 14629 07b6 00       		.byte	0
 14630 07b7 30       		.byte	48
 14631 07b8 01       		.byte	1
 14632 07b9 00       		.byte	0
 14633 07ba 0000     		.space	2
 14636              	EXTEnhanceMode:
 14637 07bc 06       		.byte	6
 14638 07bd 06       		.byte	6
 14639 07be 02       		.byte	2
 14640 07bf 00       		.byte	0
 14641 07c0 00       		.byte	0
 14642 07c1 FF       		.byte	-1
 14643 07c2 00       		.byte	0
 14644 07c3 01       		.byte	1
 14645 07c4 00       		.byte	0
 14646 07c5 03       		.byte	3
 14647 07c6 00       		.byte	0
 14648 07c7 80       		.byte	-128
 14649 07c8 00       		.byte	0
 14650 07c9 80       		.byte	-128
 14651 07ca 00       		.byte	0
 14652 07cb 30       		.byte	48
 14653 07cc 01       		.byte	1
 14654 07cd 00       		.byte	0
 14655 07ce 0000     		.space	2
 14658              	EXTExCtrlSped:
 14659 07d0 F8       		.byte	-8
 14660 07d1 F8       		.byte	-8
 14661 07d2 02       		.byte	2
 14662 07d3 00       		.byte	0
 14663 07d4 00       		.byte	0
 14664 07d5 FF       		.byte	-1
 14665 07d6 00       		.byte	0
 14666 07d7 01       		.byte	1
 14667 07d8 00       		.byte	0
 14668 07d9 03       		.byte	3
 14669 07da 00       		.byte	0
 14670 07db 80       		.byte	-128
 14671 07dc 00       		.byte	0
 14672 07dd 80       		.byte	-128
 14673 07de 00       		.byte	0
 14674 07df 30       		.byte	48
 14675 07e0 01       		.byte	1
 14676 07e1 00       		.byte	0
 14677 07e2 0000     		.space	2
 14680              	EXTExHyster:
 14681 07e4 0B       		.byte	11
 14682 07e5 0B       		.byte	11
 14683 07e6 02       		.byte	2
 14684 07e7 00       		.byte	0
 14685 07e8 00       		.byte	0
 14686 07e9 FF       		.byte	-1
 14687 07ea 00       		.byte	0
 14688 07eb 01       		.byte	1
 14689 07ec 00       		.byte	0
 14690 07ed 03       		.byte	3
 14691 07ee 00       		.byte	0
 14692 07ef 80       		.byte	-128
 14693 07f0 00       		.byte	0
 14694 07f1 80       		.byte	-128
 14695 07f2 00       		.byte	0
 14696 07f3 30       		.byte	48
 14697 07f4 01       		.byte	1
 14698 07f5 00       		.byte	0
 14699 07f6 0000     		.space	2
 14702              	EXTBLCWeight:
 14703 07f8 11       		.byte	17
 14704 07f9 11       		.byte	17
 14705 07fa 02       		.byte	2
 14706 07fb 00       		.byte	0
 14707 07fc 00       		.byte	0
 14708 07fd FF       		.byte	-1
 14709 07fe 00       		.byte	0
 14710 07ff 01       		.byte	1
 14711 0800 00       		.byte	0
 14712 0801 03       		.byte	3
 14713 0802 00       		.byte	0
 14714 0803 80       		.byte	-128
 14715 0804 00       		.byte	0
 14716 0805 80       		.byte	-128
 14717 0806 00       		.byte	0
 14718 0807 30       		.byte	48
 14719 0808 01       		.byte	1
 14720 0809 00       		.byte	0
 14721 080a 0000     		.space	2
 14724              	EXTI2Ccmd:
 14725 080c 00       		.byte	0
 14726 080d 00       		.byte	0
 14727 080e 0B       		.byte	11
 14728 080f 00       		.byte	0
 14729 0810 00       		.byte	0
 14730 0811 FF       		.byte	-1
 14731 0812 FF       		.byte	-1
 14732 0813 01       		.byte	1
 14733 0814 00       		.byte	0
 14734 0815 03       		.byte	3
 14735 0816 00       		.byte	0
 14736 0817 00       		.byte	0
 14737 0818 00       		.byte	0
 14738 0819 00       		.byte	0
 14739 081a 00       		.byte	0
 14740 081b 00       		.byte	0
 14741 081c 01       		.byte	1
 14742 081d 00       		.byte	0
 14743 081e 0000     		.space	2
 14746              	EXTSensorPare:
 14747 0820 50       		.byte	80
 14748 0821 50       		.byte	80
 14749 0822 02       		.byte	2
 14750 0823 00       		.byte	0
 14751 0824 00       		.byte	0
 14752 0825 03       		.byte	3
 14753 0826 00       		.byte	0
 14754 0827 01       		.byte	1
 14755 0828 00       		.byte	0
 14756 0829 03       		.byte	3
 14757 082a 00       		.byte	0
 14758 082b 00       		.byte	0
 14759 082c 00       		.byte	0
 14760 082d 00       		.byte	0
 14761 082e 00       		.byte	0
 14762 082f 30       		.byte	48
 14763 0830 01       		.byte	1
 14764 0831 00       		.byte	0
 14765 0832 0000     		.space	2
 14768              	EXTCamMode:
 14769 0834 10       		.byte	16
 14770 0835 10       		.byte	16
 14771 0836 02       		.byte	2
 14772 0837 00       		.byte	0
 14773 0838 00       		.byte	0
 14774 0839 06       		.byte	6
 14775 083a 00       		.byte	0
 14776 083b 01       		.byte	1
 14777 083c 00       		.byte	0
 14778 083d 03       		.byte	3
 14779 083e 00       		.byte	0
 14780 083f 03       		.byte	3
 14781 0840 00       		.byte	0
 14782 0841 03       		.byte	3
 14783 0842 00       		.byte	0
 14784 0843 30       		.byte	48
 14785 0844 01       		.byte	1
 14786 0845 00       		.byte	0
 14787 0846 0000     		.space	2
 14790              	EXTExpReflev:
 14791 0848 04       		.byte	4
 14792 0849 04       		.byte	4
 14793 084a 02       		.byte	2
 14794 084b 00       		.byte	0
 14795 084c 00       		.byte	0
 14796 084d FF       		.byte	-1
 14797 084e 00       		.byte	0
 14798 084f 01       		.byte	1
 14799 0850 00       		.byte	0
 14800 0851 03       		.byte	3
 14801 0852 00       		.byte	0
 14802 0853 3C       		.byte	60
 14803 0854 00       		.byte	0
 14804 0855 3C       		.byte	60
 14805 0856 00       		.byte	0
 14806 0857 30       		.byte	48
 14807 0858 01       		.byte	1
 14808 0859 00       		.byte	0
 14809 085a 0000     		.space	2
 14812              	EXTNightDaylev:
 14813 085c 24       		.byte	36
 14814 085d 24       		.byte	36
 14815 085e 02       		.byte	2
 14816 085f 00       		.byte	0
 14817 0860 00       		.byte	0
 14818 0861 64       		.byte	100
 14819 0862 00       		.byte	0
 14820 0863 01       		.byte	1
 14821 0864 00       		.byte	0
 14822 0865 03       		.byte	3
 14823 0866 00       		.byte	0
 14824 0867 10       		.byte	16
 14825 0868 00       		.byte	0
 14826 0869 10       		.byte	16
 14827 086a 00       		.byte	0
 14828 086b 30       		.byte	48
 14829 086c 01       		.byte	1
 14830 086d 00       		.byte	0
 14831 086e 0000     		.space	2
 14834              	EXTDayNightlev:
 14835 0870 23       		.byte	35
 14836 0871 23       		.byte	35
 14837 0872 02       		.byte	2
 14838 0873 00       		.byte	0
 14839 0874 00       		.byte	0
 14840 0875 64       		.byte	100
 14841 0876 00       		.byte	0
 14842 0877 01       		.byte	1
 14843 0878 00       		.byte	0
 14844 0879 03       		.byte	3
 14845 087a 00       		.byte	0
 14846 087b 10       		.byte	16
 14847 087c 00       		.byte	0
 14848 087d 10       		.byte	16
 14849 087e 00       		.byte	0
 14850 087f 30       		.byte	48
 14851 0880 01       		.byte	1
 14852 0881 00       		.byte	0
 14853 0882 0000     		.space	2
 14856              	EXTDayNightMode:
 14857 0884 20       		.byte	32
 14858 0885 20       		.byte	32
 14859 0886 02       		.byte	2
 14860 0887 00       		.byte	0
 14861 0888 00       		.byte	0
 14862 0889 02       		.byte	2
 14863 088a 00       		.byte	0
 14864 088b 01       		.byte	1
 14865 088c 00       		.byte	0
 14866 088d 03       		.byte	3
 14867 088e 00       		.byte	0
 14868 088f 00       		.byte	0
 14869 0890 00       		.byte	0
 14870 0891 00       		.byte	0
 14871 0892 00       		.byte	0
 14872 0893 30       		.byte	48
 14873 0894 01       		.byte	1
 14874 0895 00       		.byte	0
 14875 0896 0000     		.space	2
 14878              	EXT3DNoiseLev:
 14879 0898 19       		.byte	25
 14880 0899 19       		.byte	25
 14881 089a 02       		.byte	2
 14882 089b 00       		.byte	0
 14883 089c 00       		.byte	0
 14884 089d 40       		.byte	64
 14885 089e 00       		.byte	0
 14886 089f 01       		.byte	1
 14887 08a0 00       		.byte	0
 14888 08a1 03       		.byte	3
 14889 08a2 00       		.byte	0
 14890 08a3 20       		.byte	32
 14891 08a4 00       		.byte	0
 14892 08a5 20       		.byte	32
 14893 08a6 00       		.byte	0
 14894 08a7 30       		.byte	48
 14895 08a8 01       		.byte	1
 14896 08a9 00       		.byte	0
 14897 08aa 0000     		.space	2
 14900              	EXT3DnoiseReduceMode:
 14901 08ac 18       		.byte	24
 14902 08ad 18       		.byte	24
 14903 08ae 02       		.byte	2
 14904 08af 00       		.byte	0
 14905 08b0 00       		.byte	0
 14906 08b1 01       		.byte	1
 14907 08b2 00       		.byte	0
 14908 08b3 01       		.byte	1
 14909 08b4 00       		.byte	0
 14910 08b5 03       		.byte	3
 14911 08b6 00       		.byte	0
 14912 08b7 00       		.byte	0
 14913 08b8 00       		.byte	0
 14914 08b9 00       		.byte	0
 14915 08ba 00       		.byte	0
 14916 08bb 30       		.byte	48
 14917 08bc 01       		.byte	1
 14918 08bd 00       		.byte	0
 14919 08be 0000     		.space	2
 14922              	EXTMirror:
 14923 08c0 05       		.byte	5
 14924 08c1 05       		.byte	5
 14925 08c2 02       		.byte	2
 14926 08c3 00       		.byte	0
 14927 08c4 00       		.byte	0
 14928 08c5 03       		.byte	3
 14929 08c6 00       		.byte	0
 14930 08c7 01       		.byte	1
 14931 08c8 00       		.byte	0
 14932 08c9 03       		.byte	3
 14933 08ca 00       		.byte	0
 14934 08cb 00       		.byte	0
 14935 08cc 00       		.byte	0
 14936 08cd 00       		.byte	0
 14937 08ce 00       		.byte	0
 14938 08cf 30       		.byte	48
 14939 08d0 01       		.byte	1
 14940 08d1 00       		.byte	0
 14941 08d2 0000     		.space	2
 14944              	EXTSensUp:
 14945 08d4 01       		.byte	1
 14946 08d5 01       		.byte	1
 14947 08d6 02       		.byte	2
 14948 08d7 00       		.byte	0
 14949 08d8 00       		.byte	0
 14950 08d9 09       		.byte	9
 14951 08da 00       		.byte	0
 14952 08db 01       		.byte	1
 14953 08dc 00       		.byte	0
 14954 08dd 03       		.byte	3
 14955 08de 00       		.byte	0
 14956 08df 00       		.byte	0
 14957 08e0 00       		.byte	0
 14958 08e1 01       		.byte	1
 14959 08e2 00       		.byte	0
 14960 08e3 30       		.byte	48
 14961 08e4 01       		.byte	1
 14962 08e5 00       		.byte	0
 14963 08e6 0000     		.space	2
 14966              	PUCDZoom:
 14967 08e8 2A       		.byte	42
 14968 08e9 2A       		.byte	42
 14969 08ea 02       		.byte	2
 14970 08eb 00       		.byte	0
 14971 08ec 00       		.byte	0
 14972 08ed 1B       		.byte	27
 14973 08ee 00       		.byte	0
 14974 08ef 01       		.byte	1
 14975 08f0 00       		.byte	0
 14976 08f1 03       		.byte	3
 14977 08f2 00       		.byte	0
 14978 08f3 00       		.byte	0
 14979 08f4 00       		.byte	0
 14980 08f5 00       		.byte	0
 14981 08f6 00       		.byte	0
 14982 08f7 30       		.byte	48
 14983 08f8 01       		.byte	1
 14984 08f9 00       		.byte	0
 14985 08fa 0000     		.space	2
 14988              	PUCWBLC:
 14989 08fc 09       		.byte	9
 14990 08fd 0A       		.byte	10
 14991 08fe 04       		.byte	4
 14992 08ff 00       		.byte	0
 14993 0900 00       		.byte	0
 14994 0901 40       		.byte	64
 14995 0902 00       		.byte	0
 14996 0903 01       		.byte	1
 14997 0904 00       		.byte	0
 14998 0905 03       		.byte	3
 14999 0906 00       		.byte	0
 15000 0907 20       		.byte	32
 15001 0908 00       		.byte	0
 15002 0909 38       		.byte	56
 15003 090a 00       		.byte	0
 15004 090b 30       		.byte	48
 15005 090c 01       		.byte	1
 15006 090d 00       		.byte	0
 15007 090e 0000     		.space	2
 15010              	PUCWBMd:
 15011 0910 08       		.byte	8
 15012 0911 08       		.byte	8
 15013 0912 02       		.byte	2
 15014 0913 00       		.byte	0
 15015 0914 00       		.byte	0
 15016 0915 05       		.byte	5
 15017 0916 00       		.byte	0
 15018 0917 01       		.byte	1
 15019 0918 00       		.byte	0
 15020 0919 03       		.byte	3
 15021 091a 00       		.byte	0
 15022 091b 00       		.byte	0
 15023 091c 00       		.byte	0
 15024 091d 00       		.byte	0
 15025 091e 00       		.byte	0
 15026 091f 30       		.byte	48
 15027 0920 01       		.byte	1
 15028 0921 00       		.byte	0
 15029 0922 0000     		.space	2
 15032              	PUCSharp:
 15033 0924 06       		.byte	6
 15034 0925 07       		.byte	7
 15035 0926 02       		.byte	2
 15036 0927 00       		.byte	0
 15037 0928 00       		.byte	0
 15038 0929 08       		.byte	8
 15039 092a 00       		.byte	0
 15040 092b 01       		.byte	1
 15041 092c 00       		.byte	0
 15042 092d 03       		.byte	3
 15043 092e 00       		.byte	0
 15044 092f 00       		.byte	0
 15045 0930 00       		.byte	0
 15046 0931 00       		.byte	0
 15047 0932 00       		.byte	0
 15048 0933 30       		.byte	48
 15049 0934 01       		.byte	1
 15050 0935 00       		.byte	0
 15051 0936 0000     		.space	2
 15054              	PUCSaturation:
 15055 0938 85       		.byte	-123
 15056 0939 86       		.byte	-122
 15057 093a 02       		.byte	2
 15058 093b 00       		.byte	0
 15059 093c 00       		.byte	0
 15060 093d 64       		.byte	100
 15061 093e 00       		.byte	0
 15062 093f 01       		.byte	1
 15063 0940 00       		.byte	0
 15064 0941 03       		.byte	3
 15065 0942 00       		.byte	0
 15066 0943 32       		.byte	50
 15067 0944 00       		.byte	0
 15068 0945 32       		.byte	50
 15069 0946 00       		.byte	0
 15070 0947 30       		.byte	48
 15071 0948 01       		.byte	1
 15072 0949 00       		.byte	0
 15073 094a 0000     		.space	2
 15076              	PUCContrast:
 15077 094c 0D       		.byte	13
 15078 094d 0D       		.byte	13
 15079 094e 02       		.byte	2
 15080 094f 00       		.byte	0
 15081 0950 00       		.byte	0
 15082 0951 FF       		.byte	-1
 15083 0952 00       		.byte	0
 15084 0953 01       		.byte	1
 15085 0954 00       		.byte	0
 15086 0955 03       		.byte	3
 15087 0956 00       		.byte	0
 15088 0957 70       		.byte	112
 15089 0958 00       		.byte	0
 15090 0959 70       		.byte	112
 15091 095a 00       		.byte	0
 15092 095b 30       		.byte	48
 15093 095c 01       		.byte	1
 15094 095d 00       		.byte	0
 15095 095e 0000     		.space	2
 15098              	CyFxGpifRegValue_usb2:
 15099 0960 08830080 		.word	-2147450104
 15100 0964 67000000 		.word	103
 15101 0968 01000000 		.word	1
 15102 096c 46000000 		.word	70
 15103 0970 00000000 		.word	0
 15104 0974 00000000 		.word	0
 15105 0978 02000000 		.word	2
 15106 097c 82000000 		.word	130
 15107 0980 82070000 		.word	1922
 15108 0984 40040000 		.word	1088
 15109 0988 FCFF0000 		.word	65532
 15110 098c 28000000 		.word	40
 15111 0990 00000000 		.word	0
 15112 0994 00000000 		.word	0
 15113 0998 00000000 		.word	0
 15114 099c 00000000 		.word	0
 15115 09a0 01000000 		.word	1
 15116 09a4 00000000 		.word	0
 15117 09a8 00000000 		.word	0
 15118 09ac 00000000 		.word	0
 15119 09b0 00000000 		.word	0
 15120 09b4 00000000 		.word	0
 15121 09b8 00000000 		.word	0
 15122 09bc 00000000 		.word	0
 15123 09c0 00000000 		.word	0
 15124 09c4 00000000 		.word	0
 15125 09c8 00000000 		.word	0
 15126 09cc 00000000 		.word	0
 15127 09d0 00000000 		.word	0
 15128 09d4 06000000 		.word	6
 15129 09d8 00000000 		.word	0
 15130 09dc FFFF0000 		.word	65535
 15131 09e0 09010000 		.word	265
 15132 09e4 00000000 		.word	0
 15133 09e8 F71F0000 		.word	8183
 15134 09ec 00000000 		.word	0
 15135 09f0 FFFF0000 		.word	65535
 15136 09f4 09010000 		.word	265
 15137 09f8 00000000 		.word	0
 15138 09fc F71F0000 		.word	8183
 15139 0a00 00000000 		.word	0
 15140 0a04 00000000 		.word	0
 15141 0a08 00000000 		.word	0
 15142 0a0c 00000000 		.word	0
 15143 0a10 00000000 		.word	0
 15144 0a14 00000000 		.word	0
 15145 0a18 00000000 		.word	0
 15146 0a1c 00000000 		.word	0
 15147 0a20 00000000 		.word	0
 15148 0a24 00000000 		.word	0
 15149 0a28 00000000 		.word	0
 15150 0a2c 00000000 		.word	0
 15151 0a30 00000000 		.word	0
 15152 0a34 00000000 		.word	0
 15153 0a38 00000000 		.word	0
 15154 0a3c 00000000 		.word	0
 15155 0a40 00000000 		.word	0
 15156 0a44 00000000 		.word	0
 15157 0a48 00000000 		.word	0
 15158 0a4c 00000000 		.word	0
 15159 0a50 00000000 		.word	0
 15160 0a54 00000000 		.word	0
 15161 0a58 00000000 		.word	0
 15162 0a5c 00040180 		.word	-2147417088
 15163 0a60 01040180 		.word	-2147417087
 15164 0a64 02040180 		.word	-2147417086
 15165 0a68 03040180 		.word	-2147417085
 15166 0a6c 00000000 		.word	0
 15167 0a70 00000000 		.word	0
 15168 0a74 00000000 		.word	0
 15169 0a78 00000000 		.word	0
 15170 0a7c 00000000 		.word	0
 15171 0a80 00000000 		.word	0
 15172 0a84 00000000 		.word	0
 15173 0a88 00000000 		.word	0
 15174 0a8c C1FFFFFF 		.word	-63
 15177              	CyFxGpifWavedataPosition_usb2:
 15178 0a90 00       		.byte	0
 15179 0a91 01       		.byte	1
 15180 0a92 02       		.byte	2
 15181 0a93 03       		.byte	3
 15182 0a94 04       		.byte	4
 15183 0a95 05       		.byte	5
 15184 0a96 06       		.byte	6
 15185 0a97 07       		.byte	7
 15186 0a98 08       		.byte	8
 15187 0a99 09       		.byte	9
 15188 0a9a 0A       		.byte	10
 15189 0a9b 08       		.byte	8
 15190 0a9c 0B       		.byte	11
 15191 0a9d 0C       		.byte	12
 15192 0a9e 0D       		.byte	13
 15193 0a9f 08       		.byte	8
 15194 0aa0 0E       		.byte	14
 15195 0aa1 0F       		.byte	15
 15196 0aa2 08       		.byte	8
 15197 0aa3 08       		.byte	8
 15198 0aa4 08       		.byte	8
 15199 0aa5 08       		.byte	8
 15200 0aa6 08       		.byte	8
 15201 0aa7 08       		.byte	8
 15202 0aa8 08       		.byte	8
 15203 0aa9 08       		.byte	8
 15204 0aaa 08       		.byte	8
 15205 0aab 08       		.byte	8
 15206 0aac 08       		.byte	8
 15207 0aad 08       		.byte	8
 15208 0aae 08       		.byte	8
 15209 0aaf 08       		.byte	8
 15210 0ab0 08       		.byte	8
 15211 0ab1 08       		.byte	8
 15212 0ab2 08       		.byte	8
 15213 0ab3 08       		.byte	8
 15214 0ab4 08       		.byte	8
 15215 0ab5 08       		.byte	8
 15216 0ab6 08       		.byte	8
 15217 0ab7 08       		.byte	8
 15218 0ab8 08       		.byte	8
 15219 0ab9 08       		.byte	8
 15220 0aba 08       		.byte	8
 15221 0abb 08       		.byte	8
 15222 0abc 08       		.byte	8
 15223 0abd 08       		.byte	8
 15224 0abe 08       		.byte	8
 15225 0abf 08       		.byte	8
 15226 0ac0 08       		.byte	8
 15227 0ac1 08       		.byte	8
 15228 0ac2 08       		.byte	8
 15229 0ac3 08       		.byte	8
 15230 0ac4 08       		.byte	8
 15231 0ac5 08       		.byte	8
 15232 0ac6 08       		.byte	8
 15233 0ac7 08       		.byte	8
 15234 0ac8 08       		.byte	8
 15235 0ac9 08       		.byte	8
 15236 0aca 08       		.byte	8
 15237 0acb 08       		.byte	8
 15238 0acc 08       		.byte	8
 15239 0acd 08       		.byte	8
 15240 0ace 08       		.byte	8
 15241 0acf 08       		.byte	8
 15242 0ad0 08       		.byte	8
 15243 0ad1 08       		.byte	8
 15244 0ad2 08       		.byte	8
 15245 0ad3 08       		.byte	8
 15246 0ad4 08       		.byte	8
 15247 0ad5 08       		.byte	8
 15248 0ad6 08       		.byte	8
 15249 0ad7 08       		.byte	8
 15250 0ad8 08       		.byte	8
 15251 0ad9 08       		.byte	8
 15252 0ada 08       		.byte	8
 15253 0adb 08       		.byte	8
 15254 0adc 08       		.byte	8
 15255 0add 08       		.byte	8
 15256 0ade 08       		.byte	8
 15257 0adf 08       		.byte	8
 15258 0ae0 08       		.byte	8
 15259 0ae1 08       		.byte	8
 15260 0ae2 08       		.byte	8
 15261 0ae3 08       		.byte	8
 15262 0ae4 08       		.byte	8
 15263 0ae5 08       		.byte	8
 15264 0ae6 08       		.byte	8
 15265 0ae7 08       		.byte	8
 15266 0ae8 08       		.byte	8
 15267 0ae9 08       		.byte	8
 15268 0aea 08       		.byte	8
 15269 0aeb 08       		.byte	8
 15270 0aec 08       		.byte	8
 15271 0aed 08       		.byte	8
 15272 0aee 08       		.byte	8
 15273 0aef 08       		.byte	8
 15274 0af0 08       		.byte	8
 15275 0af1 08       		.byte	8
 15276 0af2 08       		.byte	8
 15277 0af3 08       		.byte	8
 15278 0af4 08       		.byte	8
 15279 0af5 08       		.byte	8
 15280 0af6 08       		.byte	8
 15281 0af7 08       		.byte	8
 15282 0af8 08       		.byte	8
 15283 0af9 08       		.byte	8
 15284 0afa 08       		.byte	8
 15285 0afb 08       		.byte	8
 15286 0afc 08       		.byte	8
 15287 0afd 08       		.byte	8
 15288 0afe 08       		.byte	8
 15289 0aff 08       		.byte	8
 15290 0b00 08       		.byte	8
 15291 0b01 08       		.byte	8
 15292 0b02 08       		.byte	8
 15293 0b03 08       		.byte	8
 15294 0b04 08       		.byte	8
 15295 0b05 08       		.byte	8
 15296 0b06 08       		.byte	8
 15297 0b07 08       		.byte	8
 15298 0b08 08       		.byte	8
 15299 0b09 08       		.byte	8
 15300 0b0a 08       		.byte	8
 15301 0b0b 08       		.byte	8
 15302 0b0c 08       		.byte	8
 15303 0b0d 08       		.byte	8
 15304 0b0e 08       		.byte	8
 15305 0b0f 08       		.byte	8
 15306 0b10 00       		.byte	0
 15307 0b11 01       		.byte	1
 15308 0b12 02       		.byte	2
 15309 0b13 10       		.byte	16
 15310 0b14 04       		.byte	4
 15311 0b15 05       		.byte	5
 15312 0b16 06       		.byte	6
 15313 0b17 07       		.byte	7
 15314 0b18 08       		.byte	8
 15315 0b19 09       		.byte	9
 15316 0b1a 0A       		.byte	10
 15317 0b1b 08       		.byte	8
 15318 0b1c 11       		.byte	17
 15319 0b1d 0C       		.byte	12
 15320 0b1e 0D       		.byte	13
 15321 0b1f 08       		.byte	8
 15322 0b20 0E       		.byte	14
 15323 0b21 0F       		.byte	15
 15324 0b22 08       		.byte	8
 15325 0b23 00       		.space	1
 15328              	CyFxGpifWavedata_usb2:
 15329 0b24 0181731E 		.word	510886145
 15330 0b28 00000000 		.word	0
 15331 0b2c 00000080 		.word	-2147483648
 15332 0b30 00000000 		.word	0
 15333 0b34 00000000 		.word	0
 15334 0b38 00000000 		.word	0
 15335 0b3c 0201703E 		.word	1047527682
 15336 0b40 00010000 		.word	256
 15337 0b44 A00000C0 		.word	-1073741664
 15338 0b48 00000000 		.word	0
 15339 0b4c 00000000 		.word	0
 15340 0b50 00000000 		.word	0
 15341 0b54 0394731E 		.word	510891011
 15342 0b58 04000020 		.word	536870916
 15343 0b5c 60004080 		.word	-2143289248
 15344 0b60 00000000 		.word	0
 15345 0b64 00000000 		.word	0
 15346 0b68 00000000 		.word	0
 15347 0b6c 0620702E 		.word	779100166
 15348 0b70 0C000000 		.word	12
 15349 0b74 00000080 		.word	-2147483648
 15350 0b78 0620702E 		.word	779100166
 15351 0b7c 0C000000 		.word	12
 15352 0b80 00000080 		.word	-2147483648
 15353 0b84 0394731E 		.word	510891011
 15354 0b88 04000020 		.word	536870916
 15355 0b8c 60004080 		.word	-2143289248
 15356 0b90 0620702E 		.word	779100166
 15357 0b94 0C000000 		.word	12
 15358 0b98 00000080 		.word	-2147483648
 15359 0b9c 0C93731E 		.word	510890764
 15360 0ba0 04000024 		.word	603979780
 15361 0ba4 90004080 		.word	-2143289200
 15362 0ba8 0D20702E 		.word	779100173
 15363 0bac 0C000000 		.word	12
 15364 0bb0 00000080 		.word	-2147483648
 15365 0bb4 0780724E 		.word	1316126727
 15366 0bb8 0A000000 		.word	10
 15367 0bbc 00000080 		.word	-2147483648
 15368 0bc0 08000000 		.word	8
 15369 0bc4 00000000 		.word	0
 15370 0bc8 00010080 		.word	-2147483392
 15371 0bcc 0920702E 		.word	779100169
 15372 0bd0 0C010000 		.word	268
 15373 0bd4 00000080 		.word	-2147483648
 15374 0bd8 0A01701E 		.word	510656778
 15375 0bdc 0E000100 		.word	65550
 15376 0be0 00000080 		.word	-2147483648
 15377 0be4 00000000 		.word	0
 15378 0be8 00000000 		.word	0
 15379 0bec 00000000 		.word	0
 15380 0bf0 00000000 		.word	0
 15381 0bf4 00000000 		.word	0
 15382 0bf8 00000000 		.word	0
 15383 0bfc 0394731E 		.word	510891011
 15384 0c00 04000020 		.word	536870916
 15385 0c04 60004080 		.word	-2143289248
 15386 0c08 08000000 		.word	8
 15387 0c0c 00000000 		.word	0
 15388 0c10 00010080 		.word	-2147483392
 15389 0c14 0B000000 		.word	11
 15390 0c18 00000000 		.word	0
 15391 0c1c 00010080 		.word	-2147483392
 15392 0c20 0C93731E 		.word	510890764
 15393 0c24 04000024 		.word	603979780
 15394 0c28 90004080 		.word	-2143289200
 15395 0c2c 0D20702E 		.word	779100173
 15396 0c30 0C000000 		.word	12
 15397 0c34 00000080 		.word	-2147483648
 15398 0c38 0D20702E 		.word	779100173
 15399 0c3c 0C000000 		.word	12
 15400 0c40 00000080 		.word	-2147483648
 15401 0c44 0E60724E 		.word	1316118542
 15402 0c48 0A000000 		.word	10
 15403 0c4c 00000080 		.word	-2147483648
 15404 0c50 0F000000 		.word	15
 15405 0c54 00000000 		.word	0
 15406 0c58 00010080 		.word	-2147483392
 15407 0c5c 1020702E 		.word	779100176
 15408 0c60 0C010000 		.word	268
 15409 0c64 00000080 		.word	-2147483648
 15410 0c68 1101701E 		.word	510656785
 15411 0c6c 0E000100 		.word	65550
 15412 0c70 00000080 		.word	-2147483648
 15413 0c74 0C93731E 		.word	510890764
 15414 0c78 04000024 		.word	603979780
 15415 0c7c 90004080 		.word	-2143289200
 15416 0c80 0F000000 		.word	15
 15417 0c84 00000000 		.word	0
 15418 0c88 00010080 		.word	-2147483392
 15419 0c8c 12000000 		.word	18
 15420 0c90 00000000 		.word	0
 15421 0c94 00010080 		.word	-2147483392
 15422 0c98 0394731E 		.word	510891011
 15423 0c9c 04000020 		.word	536870916
 15424 0ca0 60004080 		.word	-2143289248
 15425 0ca4 0480732E 		.word	779321348
 15426 0ca8 02010000 		.word	258
 15427 0cac 0000C0C0 		.word	-1061158912
 15428 0cb0 0580732E 		.word	779321349
 15429 0cb4 02010000 		.word	258
 15430 0cb8 0000C0C0 		.word	-1061158912
 15431 0cbc 0580732E 		.word	779321349
 15432 0cc0 02010000 		.word	258
 15433 0cc4 0000C0C0 		.word	-1061158912
 15434 0cc8 0480732E 		.word	779321348
 15435 0ccc 02010000 		.word	258
 15436 0cd0 0000C0C0 		.word	-1061158912
 15439              	CyFxGpifTransition_usb2:
 15440 0cd4 0000     		.short	0
 15441 0cd6 5555     		.short	21845
 15442 0cd8 AAAA     		.short	-21846
 15443 0cda 8888     		.short	-30584
 15444 0cdc 1111     		.short	4369
 15445 0cde 4444     		.short	17476
 15446 0ce0 3333     		.short	13107
 15447 0ce2 CCCC     		.short	-13108
 15450              	CyFxGpifRegValue:
 15451 0ce4 08830080 		.word	-2147450104
 15452 0ce8 67000000 		.word	103
 15453 0cec 00000000 		.word	0
 15454 0cf0 46000000 		.word	70
 15455 0cf4 00000000 		.word	0
 15456 0cf8 00000000 		.word	0
 15457 0cfc 02000000 		.word	2
 15458 0d00 82000000 		.word	130
 15459 0d04 82070000 		.word	1922
 15460 0d08 40040000 		.word	1088
 15461 0d0c FCFF0000 		.word	65532
 15462 0d10 28000000 		.word	40
 15463 0d14 00000000 		.word	0
 15464 0d18 00000000 		.word	0
 15465 0d1c 00000000 		.word	0
 15466 0d20 00000000 		.word	0
 15467 0d24 01000000 		.word	1
 15468 0d28 00000000 		.word	0
 15469 0d2c 00000000 		.word	0
 15470 0d30 00000000 		.word	0
 15471 0d34 00000000 		.word	0
 15472 0d38 00000000 		.word	0
 15473 0d3c 00000000 		.word	0
 15474 0d40 00000000 		.word	0
 15475 0d44 00000000 		.word	0
 15476 0d48 00000000 		.word	0
 15477 0d4c 00000000 		.word	0
 15478 0d50 00000000 		.word	0
 15479 0d54 00000000 		.word	0
 15480 0d58 06000000 		.word	6
 15481 0d5c 00000000 		.word	0
 15482 0d60 FFFF0000 		.word	65535
 15483 0d64 09010000 		.word	265
 15484 0d68 00000000 		.word	0
 15485 0d6c F71F0000 		.word	8183
 15486 0d70 00000000 		.word	0
 15487 0d74 FFFF0000 		.word	65535
 15488 0d78 09010000 		.word	265
 15489 0d7c 00000000 		.word	0
 15490 0d80 F71F0000 		.word	8183
 15491 0d84 00000000 		.word	0
 15492 0d88 00000000 		.word	0
 15493 0d8c 00000000 		.word	0
 15494 0d90 00000000 		.word	0
 15495 0d94 00000000 		.word	0
 15496 0d98 00000000 		.word	0
 15497 0d9c 00000000 		.word	0
 15498 0da0 00000000 		.word	0
 15499 0da4 00000000 		.word	0
 15500 0da8 00000000 		.word	0
 15501 0dac 00000000 		.word	0
 15502 0db0 00000000 		.word	0
 15503 0db4 00000000 		.word	0
 15504 0db8 00000000 		.word	0
 15505 0dbc 00000000 		.word	0
 15506 0dc0 00000000 		.word	0
 15507 0dc4 00000000 		.word	0
 15508 0dc8 00000000 		.word	0
 15509 0dcc 00000000 		.word	0
 15510 0dd0 00000000 		.word	0
 15511 0dd4 00000000 		.word	0
 15512 0dd8 00000000 		.word	0
 15513 0ddc 00000000 		.word	0
 15514 0de0 00040180 		.word	-2147417088
 15515 0de4 01040180 		.word	-2147417087
 15516 0de8 02040180 		.word	-2147417086
 15517 0dec 03040180 		.word	-2147417085
 15518 0df0 00000000 		.word	0
 15519 0df4 00000000 		.word	0
 15520 0df8 00000000 		.word	0
 15521 0dfc 00000000 		.word	0
 15522 0e00 00000000 		.word	0
 15523 0e04 00000000 		.word	0
 15524 0e08 00000000 		.word	0
 15525 0e0c 00000000 		.word	0
 15526 0e10 C1FFFFFF 		.word	-63
 15529              	CyFxGpifWavedataPosition:
 15530 0e14 00       		.byte	0
 15531 0e15 01       		.byte	1
 15532 0e16 02       		.byte	2
 15533 0e17 03       		.byte	3
 15534 0e18 04       		.byte	4
 15535 0e19 05       		.byte	5
 15536 0e1a 06       		.byte	6
 15537 0e1b 07       		.byte	7
 15538 0e1c 08       		.byte	8
 15539 0e1d 09       		.byte	9
 15540 0e1e 0A       		.byte	10
 15541 0e1f 0B       		.byte	11
 15542 0e20 0B       		.byte	11
 15543 0e21 0B       		.byte	11
 15544 0e22 0B       		.byte	11
 15545 0e23 00       		.space	1
 15548              	CyFxGpifWavedata:
 15549 0e24 0181731E 		.word	510886145
 15550 0e28 00000000 		.word	0
 15551 0e2c 00000080 		.word	-2147483648
 15552 0e30 00000000 		.word	0
 15553 0e34 00000000 		.word	0
 15554 0e38 00000000 		.word	0
 15555 0e3c 0201702E 		.word	779092226
 15556 0e40 00010000 		.word	256
 15557 0e44 A0000080 		.word	-2147483488
 15558 0e48 00000000 		.word	0
 15559 0e4c 00000000 		.word	0
 15560 0e50 00000000 		.word	0
 15561 0e54 0380722E 		.word	779255811
 15562 0e58 02010020 		.word	536871170
 15563 0e5c 60000080 		.word	-2147483552
 15564 0e60 00000000 		.word	0
 15565 0e64 00000000 		.word	0
 15566 0e68 00000000 		.word	0
 15567 0e6c 0460722E 		.word	779247620
 15568 0e70 02010024 		.word	603980034
 15569 0e74 90000080 		.word	-2147483504
 15570 0e78 0594731E 		.word	510891013
 15571 0e7c 06000000 		.word	6
 15572 0e80 00000080 		.word	-2147483648
 15573 0e84 0380722E 		.word	779255811
 15574 0e88 02010020 		.word	536871170
 15575 0e8c 60000080 		.word	-2147483552
 15576 0e90 0693731E 		.word	510890758
 15577 0e94 06000000 		.word	6
 15578 0e98 00000080 		.word	-2147483648
 15579 0e9c 0720703E 		.word	1047535623
 15580 0ea0 08010000 		.word	264
 15581 0ea4 00000080 		.word	-2147483648
 15582 0ea8 0820703E 		.word	1047535624
 15583 0eac 08010000 		.word	264
 15584 0eb0 00000080 		.word	-2147483648
 15585 0eb4 0920703E 		.word	1047535625
 15586 0eb8 08010000 		.word	264
 15587 0ebc 00000080 		.word	-2147483648
 15588 0ec0 0A20703E 		.word	1047535626
 15589 0ec4 08010000 		.word	264
 15590 0ec8 00000080 		.word	-2147483648
 15591 0ecc 0380722E 		.word	779255811
 15592 0ed0 02010020 		.word	536871170
 15593 0ed4 60000080 		.word	-2147483552
 15594 0ed8 0B000000 		.word	11
 15595 0edc 00000000 		.word	0
 15596 0ee0 00010080 		.word	-2147483392
 15597 0ee4 0460722E 		.word	779247620
 15598 0ee8 02010024 		.word	603980034
 15599 0eec 90000080 		.word	-2147483504
 15600 0ef0 0D000000 		.word	13
 15601 0ef4 00000000 		.word	0
 15602 0ef8 00010080 		.word	-2147483392
 15603 0efc 0460722E 		.word	779247620
 15604 0f00 02010024 		.word	603980034
 15605 0f04 90000080 		.word	-2147483504
 15606 0f08 0C000000 		.word	12
 15607 0f0c 00000000 		.word	0
 15608 0f10 00010080 		.word	-2147483392
 15609 0f14 0380722E 		.word	779255811
 15610 0f18 02010020 		.word	536871170
 15611 0f1c 60000080 		.word	-2147483552
 15612 0f20 0E000000 		.word	14
 15613 0f24 00000000 		.word	0
 15614 0f28 00010080 		.word	-2147483392
 15615 0f2c 00000000 		.word	0
 15616 0f30 00000000 		.word	0
 15617 0f34 00000000 		.word	0
 15618 0f38 00000000 		.word	0
 15619 0f3c 00000000 		.word	0
 15620 0f40 00000000 		.word	0
 15623              	CyFxGpifTransition:
 15624 0f44 0000     		.short	0
 15625 0f46 5555     		.short	21845
 15626 0f48 8888     		.short	-30584
 15627 0f4a AAAA     		.short	-21846
 15628 0f4c 3333     		.short	13107
 15629 0f4e 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 15630              		.align	2
 15631              	.LC0:
 15632 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 15632      706F732D 
 15632      74696D65 
 15632      72202564 
 15632      2025640D 
 15633 0016 0000     		.space	2
 15634              	.LC1:
 15635 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 15635      6F207374 
 15635      7265616D 
 15635      20474554 
 15635      20726571 
 15636 003d 000000   		.space	3
 15637              	.LC2:
 15638 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 15638      74686520 
 15638      76696465 
 15638      6F206D6F 
 15638      64652066 
 15639 0061 000000   		.space	3
 15640              	.LC3:
 15641 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 15641      74686520 
 15641      76696465 
 15641      6F206D6F 
 15641      64652066 
 15642 0089 000000   		.space	3
 15643              	.LC4:
 15644 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 15644      43595F46 
 15644      585F5556 
 15644      435F5354 
 15644      5245414D 
 15645 00b2 0000     		.space	2
 15646              	.LC5:
 15647 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 15647      55564320 
 15647      7374696C 
 15647      6C205072 
 15647      6F622873 
 15648 00df 00       		.space	1
 15649              	.LC6:
 15650 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 15650      74686520 
 15650      7374696C 
 15650      6C206D6F 
 15650      64652066 
 15651 0101 000000   		.space	3
 15652              	.LC7:
 15653 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 15653      7374696C 
 15653      6C20636F 
 15653      6D6D6974 
 15653      20636F6E 
 15654              	.LC8:
 15655 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 15655      43595F46 
 15655      585F5556 
 15655      435F5354 
 15655      494C5F45 
 15656              	.LC9:
 15657 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 15657      55564320 
 15657      7374696C 
 15657      6C207472 
 15657      69676765 
 15658 0179 000000   		.space	3
 15659              	.LC10:
 15660 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 15660      7374696C 
 15660      6C207472 
 15660      69676765 
 15660      7220636F 
 15661 01a3 00       		.space	1
 15662              	.LC11:
 15663 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 15663      7065722D 
 15663      74696D65 
 15663      72202564 
 15663      0D0A00
 15664 01b7 00       		.space	1
 15665              	.LC12:
 15666 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 15666      636F6D6D 
 15666      616E6420 
 15666      71756575 
 15666      65206973 
 15667 01db 00       		.space	1
 15668              	.LC13:
 15669 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 15669      7220696E 
 15669      206D756C 
 15669      74696368 
 15669      616E6E65 
 15670 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 15670      2025782C 
 15670      20646D61 
 15670      446F6E65 
 15670      20256420 
 15671              	.LC14:
 15672 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 15672      5420656E 
 15672      636F756E 
 15672      74657265 
 15672      642E2E2E 
 15673              	.LC15:
 15674 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 15674      454E4420 
 15674      656E636F 
 15674      756E7465 
 15674      7265642E 
 15675 026a 0000     		.space	2
 15676              	.LC16:
 15677 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 15677      64697363 
 15677      6F6E6E65 
 15677      63746564 
 15677      2E2E2E30 
 15678 028b 00       		.space	1
 15679              	.LC17:
 15680 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 15680      43595F46 
 15680      585F5556 
 15680      435F5649 
 15680      44454F5F 
 15681 02bf 0A00     		.ascii	"\012\000"
 15682 02c1 000000   		.space	3
 15683              	.LC18:
 15684 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 15684      43595F46 
 15684      585F5556 
 15684      435F5649 
 15684      44454F5F 
 15685 02f7 00       		.ascii	"\000"
 15686              	.LC19:
 15687 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 15687      726E6174 
 15687      65207365 
 15687      7474696E 
 15687      6720302E 
 15688              	.LC20:
 15689 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 15689      72206665 
 15689      61747572 
 15689      65207265 
 15689      71756573 
 15690 0333 00       		.space	1
 15691              	.LC21:
 15692 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 15692      49324320 
 15692      636F6D6D 
 15692      616E6420 
 15692      69732030 
 15693 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15693      78257820 
 15693      30782578 
 15693      20307825 
 15693      78203078 
 15694              	.LC22:
 15695 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 15695      49324320 
 15695      636F6D6D 
 15695      616E6420 
 15695      73657474 
 15696 03a6 0000     		.space	2
 15697              	.LC23:
 15698 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 15698      73687574 
 15698      74657220 
 15698      73657420 
 15698      76616C75 
 15699 03d2 0000     		.space	2
 15700              	.LC24:
 15701 03d4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 15701      26414743 
 15701      2073656E 
 15701      7420746F 
 15701      20686F73 
 15702 03fa 0000     		.space	2
 15703              	.LC25:
 15704 03fc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 15704      49324320 
 15704      63757272 
 15704      656E7420 
 15704      64617461 
 15705 042f 64202564 		.ascii	"d %d\015\012\000"
 15705      0D0A00
 15706 0436 0000     		.space	2
 15707              	.LC26:
 15708 0438 54686520 		.ascii	"The current value 0x%x 0x%x 0x%x, 0x%x, %d\015\012\000"
 15708      63757272 
 15708      656E7420 
 15708      76616C75 
 15708      65203078 
 15709 0465 000000   		.space	3
 15710              	.LC27:
 15711 0468 54686520 		.ascii	"The set control ctrlID: 0x%x Reg1: 0x%x Reg1:0x%x d"
 15711      73657420 
 15711      636F6E74 
 15711      726F6C20 
 15711      6374726C 
 15712 049b 65764144 		.ascii	"evADD: 0x%x Len: 0x%x\015\012\000"
 15712      443A2030 
 15712      78257820 
 15712      4C656E3A 
 15712      20307825 
 15713 04b3 00       		.space	1
 15714              	.LC28:
 15715 04b4 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 15715      26414743 
 15715      20676F74 
 15715      74656E20 
 15715      66726F6D 
 15716 04e5 0A00     		.ascii	"\012\000"
 15717 04e7 00       		.space	1
 15718              	.LC29:
 15719 04e8 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 15719      73687574 
 15719      74657226 
 15719      6578706F 
 15719      73757265 
 15720 0513 00       		.space	1
 15721              	.LC30:
 15722 0514 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 15722      74657220 
 15722      6C657665 
 15722      6C20676F 
 15722      7474656E 
 15723 0547 25640D0A 		.ascii	"%d\015\012\000"
 15723      00
 15724              	.LC31:
 15725 054c 54686520 		.ascii	"The data gets from host. [0]: 0x%x [1]: 0x%x curLo:"
 15725      64617461 
 15725      20676574 
 15725      73206672 
 15725      6F6D2068 
 15726 057f 20307825 		.ascii	" 0x%x curHi: 0x%x Len: 0x%x\015\012\000"
 15726      78206375 
 15726      7248693A 
 15726      20307825 
 15726      78204C65 
 15727 059d 000000   		.space	3
 15728              	.LC32:
 15729 05a0 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 15729      75656E63 
 15729      79207365 
 15729      7474696E 
 15729      67206973 
 15730 05be 0000     		.space	2
 15731              	.LC33:
 15732 05c0 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 15732      20746865 
 15732      20766964 
 15732      656F206D 
 15732      6F646520 
 15733 05e2 0000     		.space	2
 15734              	.LC34:
 15735 05e4 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 15735      67657420 
 15735      64617461 
 15735      2066726F 
 15735      6D20686F 
 15736 0611 000000   		.space	3
 15737              	.LC35:
 15738 0614 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 15738      52657175 
 15738      65737420 
 15738      30782578 
 15738      20706172 
 15739 0647 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 15739      6E642074 
 15739      6F20686F 
 15739      73742030 
 15739      78257820 
 15740 0662 0000     		.space	2
 15741              	.LC36:
 15742 0664 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 15742      204F7020 
 15742      72656365 
 15742      69766573 
 15742      20284354 
 15743 068b 00       		.space	1
 15744              	.LC37:
 15745 068c 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 15745      756C7420 
 15745      73656C65 
 15745      63746F72 
 15745      20284354 
 15746 06ae 0000     		.space	2
 15747              	.LC38:
 15748 06b0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 15748      756C7420 
 15748      72657175 
 15748      65737420 
 15748      28435429 
 15749 06d1 000000   		.space	3
 15750              	.LC39:
 15751 06d4 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 15751      52657175 
 15751      65737420 
 15751      30782578 
 15751      20706172 
 15752 0707 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 15752      20307825 
 15752      78202F20 
 15752      73656E64 
 15752      20746F20 
 15753 0734 00       		.ascii	"\000"
 15754 0735 000000   		.space	3
 15755              	.LC40:
 15756 0738 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 15756      73657420 
 15756      64656620 
 15756      64617461 
 15756      20307825 
 15757 0757 00       		.space	1
 15758              	.LC41:
 15759 0758 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 15759      73657420 
 15759      64656620 
 15759      64617461 
 15759      20307825 
 15760 078b 2E0D0A00 		.ascii	".\015\012\000"
 15761 078f 00       		.space	1
 15762              	.LC42:
 15763 0790 4572726F 		.ascii	"Error handler...\015\012\000"
 15763      72206861 
 15763      6E646C65 
 15763      722E2E2E 
 15763      0D0A00
 15764 07a3 00       		.space	1
 15765              	.LC43:
 15766 07a4 55415254 		.ascii	"UART initialization failed!\012\000"
 15766      20696E69 
 15766      7469616C 
 15766      697A6174 
 15766      696F6E20 
 15767 07c1 000000   		.space	3
 15768              	.LC44:
 15769 07c4 49324320 		.ascii	"I2C initialization failed!\012\000"
 15769      696E6974 
 15769      69616C69 
 15769      7A617469 
 15769      6F6E2066 
 15770              	.LC45:
 15771 07e0 49324320 		.ascii	"I2C configuration failed!\012\000"
 15771      636F6E66 
 15771      69677572 
 15771      6174696F 
 15771      6E206661 
 15772 07fb 00       		.space	1
 15773              	.LC46:
 15774 07fc 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 15774      43726561 
 15774      74652045 
 15774      76656E74 
 15774      20666169 
 15775 0826 0000     		.space	2
 15776              	.LC47:
 15777 0828 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 15777      20496E69 
 15777      74206661 
 15777      696C6564 
 15777      2C204572 
 15778 084b 00       		.space	1
 15779              	.LC48:
 15780 084c 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 15780      204F7665 
 15780      72726964 
 15780      65206661 
 15780      696C6564 
 15781 0873 00       		.space	1
 15782              	.LC49:
 15783 0874 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 15783      28323029 
 15783      204F7665 
 15783      72726964 
 15783      65206661 
 15784 089f 00       		.space	1
 15785              	.LC50:
 15786 08a0 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 15786      28323429 
 15786      204F7665 
 15786      72726964 
 15786      65206661 
 15787 08cb 00       		.space	1
 15788              	.LC51:
 15789 08cc 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 15789      20536574 
 15789      20287265 
 15789      73657420 
 15789      32322920 
 15790 08fe 00       		.ascii	"\000"
 15791 08ff 00       		.space	1
 15792              	.LC52:
 15793 0900 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 15793      20536574 
 15793      2028706F 
 15793      77657220 
 15793      32302920 
 15794 0932 00       		.ascii	"\000"
 15795 0933 00       		.space	1
 15796              	.LC53:
 15797 0934 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 15797      20536574 
 15797      2028736E 
 15797      61702073 
 15797      686F7420 
 15798 0967 25640A00 		.ascii	"%d\012\000"
 15799 096b 00       		.space	1
 15800              	.LC54:
 15801 096c 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 15801      46756E63 
 15801      74696F6E 
 15801      20466169 
 15801      6C656420 
 15802 099b 00       		.space	1
 15803              	.LC55:
 15804 099c 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 15804      46756E63 
 15804      74696F6E 
 15804      20466169 
 15804      6C656420 
 15805 09cb 00       		.space	1
 15806              	.LC56:
 15807 09cc 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 15807      53657420 
 15807      456E6470 
 15807      6F696E74 
 15807      20636F6E 
 15808 09fc 00       		.ascii	"\000"
 15809 09fd 000000   		.space	3
 15810              	.LC57:
 15811 0a00 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 15811      496E7465 
 15811      72727570 
 15811      74205374 
 15811      61747573 
 15812 0a33 20436F64 		.ascii	" Code = %d\012\000"
 15812      65203D20 
 15812      25640A00 
 15813 0a3f 00       		.space	1
 15814              	.LC58:
 15815 0a40 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15815      65642074 
 15815      6F20616C 
 15815      6C6F6361 
 15815      7465206D 
 15816 0a73 65720D0A 		.ascii	"er\015\012\000"
 15816      00
 15817              	.LC59:
 15818 0a78 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15818      4368616E 
 15818      6E656C20 
 15818      43726561 
 15818      74696F6E 
 15819 0aa6 0000     		.space	2
 15820              	.LC60:
 15821 0aa8 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15821      436F6E6E 
 15821      65637420 
 15821      6661696C 
 15821      65642C20 
 15822 0acd 000000   		.space	3
 15823              	.LC61:
 15824 0ad0 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15824      74686520 
 15824      76696465 
 15824      6F206D6F 
 15824      64652066 
 15825 0af2 0000     		.space	2
 15826              	.LC62:
 15827 0af4 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15827      4368616E 
 15827      6E656C20 
 15827      52657365 
 15827      74204661 
 15828 0b1f 00       		.space	1
 15829              	.LC63:
 15830 0b20 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15830      4368616E 
 15830      6E656C20 
 15830      53657420 
 15830      5472616E 
 15831 0b51 00       		.ascii	"\000"
 15832 0b52 0000     		.space	2
 15833              	.LC64:
 15834 0b54 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15834      4368616E 
 15834      6E656C20 
 15834      53657420 
 15834      5472616E 
 15835 0b85 0A00     		.ascii	"\012\000"
 15836 0b87 00       		.space	1
 15837              	.LC65:
 15838 0b88 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15838      75706572 
 15838      20677069 
 15838      6600
 15839 0b96 0000     		.space	2
 15840              	.LC66:
 15841 0b98 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15841      69676820 
 15841      67706966 
 15841      00
 15842 0ba5 000000   		.space	3
 15843              	.LC67:
 15844 0ba8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15844      696E6720 
 15844      47504946 
 15844      20436F6E 
 15844      66696775 
 15845 0bdb 0A00     		.ascii	"\012\000"
 15846 0bdd 000000   		.space	3
 15847              	.LC68:
 15848 0be0 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15848      74696E67 
 15848      20475049 
 15848      46207374 
 15848      61746520 
 15849 0c13 0D0A00   		.ascii	"\015\012\000"
 15850 0c16 0000     		.space	2
 15851              	.LC69:
 15852 0c18 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15852      73706565 
 15852      64203D20 
 15852      25642065 
 15852      76656E66 
 15853 0c48 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15853      71756573 
 15853      74203D20 
 15853      30782578 
 15853      20775661 
 15854 0c78 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15854      203D2030 
 15854      78257820 
 15854      6973666C 
 15854      61672030 
 15855 0c92 0000     		.space	2
 15856              	.LC70:
 15857 0c94 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15857      64656661 
 15857      756C7420 
 15857      73657475 
 15857      70207265 
 15858              	.LC71:
 15859 0cc0 54686520 		.ascii	"The hyster command 0x%x 0x%x\015\012\000"
 15859      68797374 
 15859      65722063 
 15859      6F6D6D61 
 15859      6E642030 
 15860 0cdf 00       		.space	1
 15861              	.LC72:
 15862 0ce0 54686520 		.ascii	"The ctrlspd command 0x%x 0x%x\015\012\000"
 15862      6374726C 
 15862      73706420 
 15862      636F6D6D 
 15862      616E6420 
 15863              	.LC73:
 15864 0d00 54686520 		.ascii	"The edgeMode command 0x%x 0x%x\015\012\000"
 15864      65646765 
 15864      4D6F6465 
 15864      20636F6D 
 15864      6D616E64 
 15865 0d21 000000   		.space	3
 15866              	.LC74:
 15867 0d24 54686520 		.ascii	"The edgegain command 0x%x 0x%x\015\012\000"
 15867      65646765 
 15867      6761696E 
 15867      20636F6D 
 15867      6D616E64 
 15868 0d45 000000   		.space	3
 15869              	.LC75:
 15870 0d48 54686520 		.ascii	"The edge start/end command 0x%x 0x%x\015\012\000"
 15870      65646765 
 15870      20737461 
 15870      72742F65 
 15870      6E642063 
 15871 0d6f 00       		.space	1
 15872              	.LC76:
 15873 0d70 54686520 		.ascii	"The 2DNR start/end command 0x%x 0x%x\015\012\000"
 15873      32444E52 
 15873      20737461 
 15873      72742F65 
 15873      6E642063 
 15874 0d97 00       		.space	1
 15875              	.LC77:
 15876 0d98 54686520 		.ascii	"The gamma command 0x%x 0x%x\015\012\000"
 15876      67616D6D 
 15876      6120636F 
 15876      6D6D616E 
 15876      64203078 
 15877 0db6 0000     		.space	2
 15878              	.LC78:
 15879 0db8 54686520 		.ascii	"The AGC Max command 0x%x 0x%x\015\012\000"
 15879      41474320 
 15879      4D617820 
 15879      636F6D6D 
 15879      616E6420 
 15880              	.LC79:
 15881 0dd8 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15881      65642074 
 15881      6F207365 
 15881      6E642069 
 15881      6E746572 
 15882 0e09 0A00     		.ascii	"\012\000"
 15883 0e0b 00       		.space	1
 15884              	.LC80:
 15885 0e0c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15885      6F6D6D69 
 15885      74656F66 
 15885      20737461 
 15885      7465203D 
 15886              	.LC81:
 15887 0e24 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15887      6E656C20 
 15887      53657420 
 15887      57726170 
 15887      55702066 
 15888 0e51 000000   		.space	3
 15889              	.LC82:
 15890 0e54 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15890      69742045 
 15890      4F462066 
 15890      61696C65 
 15890      64210D0A 
 15891 0e69 000000   		.space	3
 15892              	.LC83:
 15893 0e6c 49324363 		.ascii	"I2CcmdQue\000"
 15893      6D645175 
 15893      6500
 15894 0e76 0000     		.space	2
 15895              	.LC84:
 15896 0e78 33303A55 		.ascii	"30:UVC App Thread\000"
 15896      56432041 
 15896      70702054 
 15896      68726561 
 15896      6400
 15897 0e8a 0000     		.space	2
 15898              	.LC85:
 15899 0e8c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15899      56432041 
 15899      70702045 
 15899      50302054 
 15899      68726561 
 15900 0ea2 0000     		.space	2
 15901              	.LC86:
 15902 0ea4 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15902      32432041 
 15902      70702043 
 15902      54524C20 
 15902      54687265 
 15903 0ebb 00       		.bss
 15904              		.align	2
 15905              		.set	.LANCHOR0,. + 0
 15908              	glFxUVCEvent:
 15909 0000 00000000 		.space	40
 15909      00000000 
 15909      00000000 
 15909      00000000 
 15909      00000000 
 15912              	glEp0Buffer:
 15913 0028 00000000 		.space	32
 15913      00000000 
 15913      00000000 
 15913      00000000 
 15913      00000000 
 15916              	usbSpeed:
 15917 0048 00       		.space	1
 15918 0049 000000   		.space	3
 15921              	glCommitCtrl:
 15922 004c 00000000 		.space	32
 15922      00000000 
 15922      00000000 
 15922      00000000 
 15922      00000000 
 15925              	is60Hz:
 15926 006c 00000000 		.space	4
 15929              	setRes:
 15930 0070 00       		.space	1
 15933              	setstilRes:
 15934 0071 00       		.space	1
 15937              	stiflag:
 15938 0072 00       		.space	1
 15939 0073 00       		.space	1
 15942              	fb:
 15943 0074 0000     		.space	2
 15946              	pb:
 15947 0076 0000     		.space	2
 15950              	pbc:
 15951 0078 0000     		.space	2
 15952 007a 0000     		.space	2
 15955              	hitFV:
 15956 007c 00000000 		.space	4
 15959              	prodCount:
 15960 0080 0000     		.space	2
 15963              	consCount:
 15964 0082 0000     		.space	2
 15967              	streamingStarted:
 15968 0084 00000000 		.space	4
 15971              	gpif_initialized:
 15972 0088 00000000 		.space	4
 15975              	isUsbConnected:
 15976 008c 00000000 		.space	4
 15979              	clearFeatureRqtReceived:
 15980 0090 00000000 		.space	4
 15983              	I2CCMDArry:
 15984 0094 00000000 		.space	12
 15984      00000000 
 15984      00000000 
 15987              	curFlag:
 15988 00a0 00000000 		.space	64
 15988      00000000 
 15988      00000000 
 15988      00000000 
 15988      00000000 
 15991              	IMcount.8242:
 15992 00e0 00       		.space	1
 15993 00e1 000000   		.space	3
 15996              	uvcAppThread:
 15997 00e4 00000000 		.space	168
 15997      00000000 
 15997      00000000 
 15997      00000000 
 15997      00000000 
 16000              	uvcAppEP0Thread:
 16001 018c 00000000 		.space	168
 16001      00000000 
 16001      00000000 
 16001      00000000 
 16001      00000000 
 16004              	i2cAppThread:
 16005 0234 00000000 		.space	168
 16005      00000000 
 16005      00000000 
 16005      00000000 
 16005      00000000 
 16008              	pbcpbak:
 16009 02dc 0000     		.space	2
 16012              	pbcbak:
 16013 02de 0000     		.space	2
 16016              	pbbak:
 16017 02e0 0000     		.space	2
 16020              	fbbak:
 16021 02e2 0000     		.space	2
 16024              	testSnap:
 16025 02e4 00       		.space	1
 16026 02e5 000000   		.text
 16027              	.Letext0:
 16028              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 16029              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16030              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 16031              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 16032              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 16033              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16034              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16035              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 16036              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16037              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16038              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16039              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16040              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16041              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16042              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16043              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 16044              		.file 18 "../sensor.h"
 16045              		.file 19 "../cmdqu.h"
 16046              		.file 20 "../uvc.h"
 16047              		.file 21 "../cyfxgpif2config.h"
 16048              		.file 22 "../cyfxgpif2config_usb2_720.h"
 16049              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2536   .text:000014b0 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2562   .text:0000150c $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2649   .text:000015cc $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2665   .text:00001604 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2792   .text:0000170c $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2805   .text:00001738 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2865   .text:000017b8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:2880   .text:000017e8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4124   .text:0000233c $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4146   .text:00002388 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4290   .text:000024bc $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4296   .text:000024cc $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4762   .text:00002964 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4909   .text:00002a8c $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:4922   .text:00002ab4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5338   .text:00002ee4 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5349   .text:00002f04 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5619   .text:00003198 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5631   .text:000031bc $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5634   .text:000031bc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5935   .text:00003478 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5942   .text:00003488 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5945   .text:00003488 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5989   .text:000034cc $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5994   .text:000034d4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:5997   .text:000034d4 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:6025   .text:000034f0 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:6029   .text:000034f4 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:6032   .text:000034f4 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:6817   .text:00003b70 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:6823   .text:00003b80 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:7298   .text:00003f68 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12312  .text:000066a8 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:7357   .text:00004040 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:7360   .text:00004040 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:7429   .text:000040b8 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:7437   .text:000040c8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:9208   .text:00005020 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:9246   .text:0000509c $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12298  .text:00006698 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12309  .text:000066a8 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12344  .text:000066dc $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12357  .text:00006708 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12362  .text:00006718 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12367  .text:00006728 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12415  .text:00006780 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12425  .text:00006794 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12428  .text:00006794 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12581  .text:000068dc $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12598  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12601  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:13935  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12954  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12875  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12939  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12845  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12905  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15967  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15979  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15916  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15975  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16008  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16012  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16016  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16020  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15950  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15946  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15942  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16024  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14543  .data:0000076a snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12829  .rodata:0000017c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15098  .data:00000960 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15177  .data:00000a90 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15328  .data:00000b24 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15439  .data:00000cd4 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12816  .rodata:00000160 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15450  .data:00000ce4 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15529  .data:00000e14 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15548  .data:00000e24 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15623  .data:00000f44 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12741  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12745  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12760  .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14089  .data:00000574 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14944  .data:000008d4 EXTSensUp
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14922  .data:000008c0 EXTMirror
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14900  .data:000008ac EXT3DnoiseReduceMode
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14878  .data:00000898 EXT3DNoiseLev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14856  .data:00000884 EXTDayNightMode
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14478  .data:00000730 EXTDayNightdely
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14834  .data:00000870 EXTDayNightlev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14812  .data:0000085c EXTNightDaylev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:13972  .data:0000050c EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14790  .data:00000848 EXTExpReflev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14111  .data:00000588 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14768  .data:00000834 EXTCamMode
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14746  .data:00000820 EXTSensorPare
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14724  .data:0000080c EXTI2Ccmd
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14133  .data:0000059c EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14702  .data:000007f8 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:13950  .data:000004f8 EXTBLCGrid
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14680  .data:000007e4 EXTExHyster
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14658  .data:000007d0 EXTExCtrlSped
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14636  .data:000007bc EXTEnhanceMode
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14500  .data:00000744 EXTEnhanceGain
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14522  .data:00000758 EXTEnhanceSTED
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14614  .data:000007a8 EXT2DNRGain
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14592  .data:00000794 EXT2DNRSTED
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14570  .data:00000780 EXTGammaCor
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14548  .data:0000076c EXTAGCMaxLimit
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12797  .rodata:00000120 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14067  .data:00000560 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:13994  .data:00000520 PUCBright
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15076  .data:0000094c PUCContrast
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14038  .data:00000548 PUCPLFreq
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14016  .data:00000534 PUCHueC
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15054  .data:00000938 PUCSaturation
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15032  .data:00000924 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15010  .data:00000910 PUCWBMd
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14988  .data:000008fc PUCWBLC
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14966  .data:000008e8 PUCDZoom
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12841  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12934  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:12969  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:13292  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14060  .data:0000055c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:14155  .data:000005b0 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15630  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15904  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15908  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15912  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15921  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15925  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15929  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15933  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15937  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15955  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15959  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15963  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15971  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15983  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15987  .bss:000000a0 curFlag
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15991  .bss:000000e0 IMcount.8242
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:15996  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16000  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc9OhoQY.s:16004  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
