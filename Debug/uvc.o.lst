   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** //uint16_t lineCount = 0; //res test
 105:../uvc.c      **** 
 106:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 107:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 108:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 109:../uvc.c      ****                                                            received. */
 110:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 111:../uvc.c      **** #ifdef BACKFLOW_DETECT
 112:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 113:../uvc.c      **** #endif
 114:../uvc.c      **** 
 115:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 116:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 117:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 118:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 119:../uvc.c      **** #endif
 120:../uvc.c      **** 
 121:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 122:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 123:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 126:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 127:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 128:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 129:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 130:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 131:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 132:../uvc.c      ****                                    with adjustable compression parameters */
 133:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 134:../uvc.c      ****                                    streaming with adjustable compression parameters */
 135:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 136:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 137:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 138:../uvc.c      **** };
 139:../uvc.c      **** 
 140:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 141:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 144:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 145:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 146:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 147:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 148:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 149:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 150:../uvc.c      ****                                    with adjustable compression parameters */
 151:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 152:../uvc.c      ****                                    streaming with adjustable compression parameters */
 153:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 154:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 155:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 156:../uvc.c      **** };
 157:../uvc.c      **** 
 158:../uvc.c      **** 
 159:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 160:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 161:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 162:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 163:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 164:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** 
 169:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 170:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 171:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 172:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 174:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 175:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 176:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 177:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 178:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 179:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 180:../uvc.c      ****                                    with adjustable compression parameters */
 181:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 182:../uvc.c      ****                                    streaming with adjustable compression parameters */
 183:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 184:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 185:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 186:../uvc.c      **** };
 187:../uvc.c      **** 
 188:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 189:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 190:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 191:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 192:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 193:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 194:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 195:../uvc.c      **** };
 196:../uvc.c      **** 
 197:../uvc.c      **** 
 198:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 199:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 200:../uvc.c      **** 
 201:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 202:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 203:../uvc.c      **** {
 204:../uvc.c      ****     0x0C,                               /* Header Length */
 205:../uvc.c      ****     0x8C,                               /* Bit field header field */
 206:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 208:../uvc.c      **** };
 209:../uvc.c      **** 
 210:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 211:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 212:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 213:../uvc.c      ****                                                            the current video frame. */
 214:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 215:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 216:../uvc.c      **** 
 217:../uvc.c      **** #define isWBMamu   0  // Is white balance control manual mode.
 218:../uvc.c      **** 
 219:../uvc.c      **** /************ control parameters array ***********
 220:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 221:../uvc.c      ****  *    e.g.
 222:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 223:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 224:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 225:../uvc.c      ****  **************************************************/
 226:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 227:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 228:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 229:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 230:../uvc.c      **** 		{BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0, 118,
 231:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 232:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 233:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 234:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 235:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 236:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 237:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 239:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 240:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 241:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 247:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 248:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 250:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 251:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 253:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 254:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 255:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 256:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 257:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 258:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 259:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		/**********************************
 261:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 262:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 263:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 264:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 265:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 266:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 267:../uvc.c      **** 		 *
 268:../uvc.c      **** 		 *********************************/
 269:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 270:../uvc.c      **** };
 271:../uvc.c      **** 
 272:../uvc.c      **** #ifndef CAM720
 273:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 274:../uvc.c      **** #else
 275:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 276:../uvc.c      **** #endif
 277:../uvc.c      **** 
 278:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 279:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 280:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 281:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 282:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 283:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 284:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 285:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 286:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 287:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 288:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 289:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 290:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 291:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 295:../uvc.c      **** };
 296:../uvc.c      **** 
 297:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 298:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 299:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 300:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 301:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 302:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 303:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 304:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 305:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 306:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 307:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 308:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 309:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 310:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 311:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 312:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 313:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 314:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 315:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 316:../uvc.c      **** };
 317:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 318:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 319:../uvc.c      **** /*
 320:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 321:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 322:../uvc.c      ****  */
 323:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 324:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 325:../uvc.c      **** };
 326:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 327:../uvc.c      **** 		0
 328:../uvc.c      **** };
 329:../uvc.c      **** 
 330:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 331:../uvc.c      **** 
 332:../uvc.c      **** void I2CCmdHandler(){
 333:../uvc.c      **** 	uint8_t buf[2];
 334:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 336:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 337:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 338:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 339:../uvc.c      **** 	uint8_t i;
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 341:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 342:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 343:../uvc.c      **** 
 344:../uvc.c      **** 	if(CmdType == 0)//I2C read
 345:../uvc.c      **** 	{
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 347:../uvc.c      **** #if 0 //for debugging
 348:../uvc.c      **** 		/* test still image operation */
 349:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 350:../uvc.c      **** 			snapButFlag = 0; //press
 351:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 352:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 353:../uvc.c      **** 			snapButFlag = 0xf; //release
 354:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 355:../uvc.c      **** 		}
 356:../uvc.c      **** 
 357:../uvc.c      **** 		/* end of the test */
 358:../uvc.c      **** #endif
 359:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 361:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 362:../uvc.c      **** 			}
 363:../uvc.c      **** 			else{
 364:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 366:../uvc.c      **** 				if(CmdDataLen == 2){
 367:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 368:../uvc.c      **** 				}
 369:../uvc.c      **** 			}
 370:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 371:../uvc.c      **** 		}else{//not support currently
 372:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 373:../uvc.c      **** 		}
 374:../uvc.c      **** 	}else if(CmdType == 1){
 375:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 376:../uvc.c      **** 			if(CmdRegLen == 2){
 377:../uvc.c      **** 				for(i = 0; i<4; i++)
 378:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 379:../uvc.c      **** 			}
 380:../uvc.c      **** 			else{
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 382:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 383:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 385:../uvc.c      **** 				}
 386:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 387:../uvc.c      **** 			}
 388:../uvc.c      **** 		}else{//not support currently
 389:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 390:../uvc.c      **** 		}
 391:../uvc.c      **** 
 392:../uvc.c      **** 	}
 393:../uvc.c      **** }
 394:../uvc.c      **** 
 395:../uvc.c      **** /************************************
 396:../uvc.c      ****  * set Iris mode
 397:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 398:../uvc.c      ****  */
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 400:../uvc.c      **** 	uint8_t dataIdx;
 401:../uvc.c      **** 	  dataIdx = 0;
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 406:../uvc.c      **** }
 407:../uvc.c      **** 
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 409:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 410:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 411:../uvc.c      ****     uint16_t readCount;
 412:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 413:../uvc.c      ****     uint8_t devAdd;
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 417:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 418:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 419:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 420:../uvc.c      ****     }else{
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 422:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 423:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 424:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 425:../uvc.c      ****     }
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 427:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 428:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 429:../uvc.c      **** #endif
 430:../uvc.c      ****     reqData = bRequest;
 431:../uvc.c      ****     /*
 432:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 433:../uvc.c      ****      */
 434:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 435:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 436:../uvc.c      ****     	goto EndofSet;
 437:../uvc.c      ****     }
 438:../uvc.c      ****     switch (bRequest)
 439:../uvc.c      **** 		 {
 440:../uvc.c      **** 
 441:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 443:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 445:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 446:../uvc.c      **** 			  break;
 447:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 448:../uvc.c      **** 
 449:../uvc.c      **** 			 switch(CtrlID)
 450:../uvc.c      **** 			 {
 451:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 452:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 453:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 454:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 457:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 458:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 459:../uvc.c      **** 			 	 		 break;
 460:../uvc.c      **** 			 	 }
 461:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 462:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 464:../uvc.c      **** 						if(sendData >= 3){
 465:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 466:../uvc.c      **** 							sendData = 0; //set back to default
 467:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 468:../uvc.c      **** 						}
 469:../uvc.c      **** 						sendData += 4;
 470:../uvc.c      **** 					 }
 471:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 472:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 474:../uvc.c      **** 					 break;
 475:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 478:../uvc.c      **** 			 		 }
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 480:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 481:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 482:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 483:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 484:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 485:../uvc.c      **** #endif
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 487:../uvc.c      **** 			 		 {
 488:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 489:../uvc.c      **** 			 		 }
 490:../uvc.c      **** 			 		 break;
 491:../uvc.c      **** 				 case ExtAexModCtlID9:
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 495:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 496:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 497:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 498:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 499:../uvc.c      **** 					 break;
 500:../uvc.c      **** 
 501:../uvc.c      **** 			 	 case BrgtCtlID1:
 502:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 503:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 504:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 505:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 506:../uvc.c      **** 					 }else{
 507:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 508:../uvc.c      **** 					 }
 509:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 511:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 512:../uvc.c      **** 					 break;
 513:../uvc.c      **** 				 case HueCtlID5:
 514:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 515:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 516:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 517:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 518:../uvc.c      **** 					 break;
 519:../uvc.c      **** 				 case WBTLevCtlID11:
 520:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 522:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 523:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 524:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 525:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 526:../uvc.c      **** 					 break;
 527:../uvc.c      **** 				 case SaturCtlID6:
 528:../uvc.c      **** 				 default:
 529:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 531:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 532:../uvc.c      **** 					 break;
 533:../uvc.c      **** 			 }
 534:../uvc.c      **** 
 535:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 536:../uvc.c      **** 
 537:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 538:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 539:../uvc.c      **** #endif
 540:../uvc.c      **** 			  break;
 541:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 542:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 543:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 544:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 545:../uvc.c      **** 		 	 }
 546:../uvc.c      **** 
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 548:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 549:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 550:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 551:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 552:../uvc.c      **** 			 }else
 553:../uvc.c      **** 			 {
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 556:../uvc.c      **** 			 }
 557:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 558:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 559:../uvc.c      **** 			  break;
 560:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 564:../uvc.c      **** 		 	 }
 565:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 566:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 567:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 568:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 569:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 570:../uvc.c      **** 			 }else
 571:../uvc.c      **** 			 {
 572:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 573:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 574:../uvc.c      **** 			 }
 575:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 576:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 577:../uvc.c      **** 			  break;
 578:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 579:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 580:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 581:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 582:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 583:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 584:../uvc.c      **** 		 	 }
 585:../uvc.c      **** 		 	 else{
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 587:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 588:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 589:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 590:../uvc.c      **** 		 	 }
 591:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 592:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 593:../uvc.c      **** 			  break;
 594:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 595:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 596:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 597:../uvc.c      **** 		 	 }
 598:../uvc.c      **** 		 	 else{
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 600:../uvc.c      **** 		 	 }
 601:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 602:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 603:../uvc.c      **** 			  Len = 1;
 604:../uvc.c      **** 			  break;
 605:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 606:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 608:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 609:../uvc.c      **** 		 	 }
 610:../uvc.c      **** 
 611:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 613:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 614:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 615:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 616:../uvc.c      **** 			 }else{
 617:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 618:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 619:../uvc.c      **** 			 }
 620:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 621:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 622:../uvc.c      **** 			  break;
 623:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 624:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 625:../uvc.c      **** 				  glEp0Buffer, &readCount);
 626:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 627:../uvc.c      **** 			   {
 628:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 629:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 630:../uvc.c      **** 				  getData = glEp0Buffer[0];
 631:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 632:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 633:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 634:../uvc.c      **** #endif
 635:../uvc.c      **** 				  switch(CtrlID)
 636:../uvc.c      **** 					 {
 637:../uvc.c      **** 						 case ExtShutCtlID0:
 638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 639:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 640:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 641:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 642:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 643:../uvc.c      **** 									 }else{
 644:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 645:../uvc.c      **** 									 }
 646:../uvc.c      **** 								 }
 647:../uvc.c      **** 							 }else{
 648:../uvc.c      **** 								 Data1 = Data0 - 1;
 649:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 650:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 651:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 652:../uvc.c      **** 									 }else{
 653:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 654:../uvc.c      **** 									 }
 655:../uvc.c      **** 								 }
 656:../uvc.c      **** 								 if(Data1 < 8){
 657:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 658:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 659:../uvc.c      **** 								 }else{
 660:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 661:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 662:../uvc.c      **** 								 }
 663:../uvc.c      **** 							 }
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 665:../uvc.c      **** 							 dataIdx = 0;
 666:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 667:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 668:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 669:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 670:../uvc.c      **** 							 break;
 671:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 674:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 675:../uvc.c      **** 							 dataIdx = 0;
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 677:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 678:../uvc.c      **** 							 if(getData != 0){
 679:../uvc.c      **** 								 dataIdx++;
 680:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 681:../uvc.c      **** 							 }
 682:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 683:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 684:../uvc.c      **** 							 break;
 685:../uvc.c      **** 						 case ExtCamMCtlID12:
 686:../uvc.c      **** 							 dataIdx = 0;
 687:../uvc.c      **** 							 if(Data0 <= 3){
 688:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 689:../uvc.c      **** 								 Data1 = Data0;
 690:../uvc.c      **** 							 }else{
 691:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 692:../uvc.c      **** 								 Data1 = Data0-4;
 693:../uvc.c      **** 							 }
 694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 695:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 697:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 698:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 699:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 700:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 701:../uvc.c      **** 							 break;
 702:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 703:../uvc.c      **** 							 dataIdx = 0;
 704:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 705:../uvc.c      **** 								 Data0 = 1;
 706:../uvc.c      **** 							 }else{ //save current sensor parameters.
 707:../uvc.c      **** 								 Data0 = 0;
 708:../uvc.c      **** 							 }
 709:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 710:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 711:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 713:../uvc.c      **** 							 break;
 714:../uvc.c      **** 						 case ExtI2CCtlID15:
 715:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 716:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 717:../uvc.c      **** 					 		 }
 718:../uvc.c      **** 					 		I2CCmdHandler();
 719:../uvc.c      **** 							 break;
 720:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 721:../uvc.c      **** 							 dataIdx = 0;
 722:../uvc.c      **** #if 0 //seperate version
 723:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 724:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 725:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 726:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 727:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 728:../uvc.c      **** 							 }else{ //disable BLD window
 729:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 730:../uvc.c      **** 							 }
 731:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 732:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 733:../uvc.c      **** 							 dataIdx++;
 734:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 735:../uvc.c      **** 							 dataIdx++;
 736:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 737:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 738:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 739:../uvc.c      **** 							 dataIdx++;
 740:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 741:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 742:../uvc.c      **** #else //combination version
 743:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 744:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 745:../uvc.c      **** 						     /* end test */
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 747:../uvc.c      **** 							 dataIdx++;
 748:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 749:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 750:../uvc.c      **** 							 getData1 = Data1;
 751:../uvc.c      **** #endif
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 753:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 754:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 755:../uvc.c      **** 							 break;
 756:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 757:../uvc.c      **** 							 dataIdx = 0;
 758:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 760:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 761:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 762:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 763:../uvc.c      **** 							 break;
 764:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 765:../uvc.c      **** 							 dataIdx = 0;
 766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 767:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 768:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 769:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 770:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 771:../uvc.c      **** 							 break;
 772:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 773:../uvc.c      **** 							 dataIdx = 0;
 774:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 775:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 776:../uvc.c      **** 							  if(Data0&0x80){
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 778:../uvc.c      **** 							  }else{
 779:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 780:../uvc.c      **** 							  }
 781:../uvc.c      **** 							 Data1 |= ~0x03;
 782:../uvc.c      **** 							 Data1 &= 0xC7;
 783:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 784:../uvc.c      **** 						  	 dataIdx++;
 785:../uvc.c      **** 
 786:../uvc.c      **** 							 Data0 = (Data0 << 2);
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 788:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 789:../uvc.c      **** 
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 792:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 793:../uvc.c      **** 
 794:../uvc.c      **** 							 break;
 795:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 796:../uvc.c      **** 							 dataIdx = 0;
 797:../uvc.c      **** 
 798:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 800:../uvc.c      **** 							 dataIdx++;
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 802:../uvc.c      **** 							 dataIdx++;
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 804:../uvc.c      **** 							 dataIdx++;
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 806:../uvc.c      **** 							 dataIdx++;
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 808:../uvc.c      **** 							 dataIdx++;
 809:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 810:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 811:../uvc.c      **** 
 812:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 813:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 814:../uvc.c      **** 							 break;
 815:../uvc.c      **** 						 case SaturCtlID6:
 816:../uvc.c      **** 							 dataIdx = 0;
 817:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 820:../uvc.c      **** 							 dataIdx++;
 821:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 822:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 824:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 825:../uvc.c      **** 							 break;
 826:../uvc.c      **** 
 827:../uvc.c      **** 						 case WBTLevCtlID11:
 828:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 829:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 830:../uvc.c      **** 							 dataIdx = 0;
 831:../uvc.c      **** 
 832:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 834:../uvc.c      **** 							 dataIdx++;
 835:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 836:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 837:../uvc.c      **** 
 838:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 839:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 841:../uvc.c      **** 							 break;
 842:../uvc.c      **** 						 case MFreqCtlID4:
 843:../uvc.c      **** 							 dataIdx = 0;
 844:../uvc.c      **** 							 Data0 = Data0 - 1;
 845:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 846:../uvc.c      **** 								 Data0 = 0;
 847:../uvc.c      **** 							 else if(Data0 >2)
 848:../uvc.c      **** 								 Data0 = 1;
 849:../uvc.c      **** 
 850:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 851:../uvc.c      **** 							 //cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 852:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 853:../uvc.c      **** 
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 855:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 856:../uvc.c      **** 							 break;
 857:../uvc.c      **** 					 	 case BLCCtlID0:
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 860:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 861:../uvc.c      **** 							 {
 862:../uvc.c      **** 								 if(Data0 < 3){
 863:../uvc.c      **** 					 				 Data0 += 4;
 864:../uvc.c      **** 					 			 }else{
 865:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 866:../uvc.c      **** 									Data0 = 4; //set to default.
 867:../uvc.c      **** 					 			 }
 868:../uvc.c      **** 					 		 }
 869:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 870:../uvc.c      **** 							 dataIdx = 0;
 871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 873:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 874:../uvc.c      **** 
 875:../uvc.c      **** 					 		 break;
 876:../uvc.c      **** 						 default:
 877:../uvc.c      **** 							 dataIdx = 0;
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 882:../uvc.c      **** 
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 885:../uvc.c      **** 							 break;
 886:../uvc.c      **** 					 }
 887:../uvc.c      **** 			   }else{
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 889:../uvc.c      **** 			   }
 890:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 891:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 892:../uvc.c      **** #endif
 893:../uvc.c      **** 
 894:../uvc.c      **** 			  break;
 895:../uvc.c      **** 		  default:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 897:../uvc.c      **** 			  break;
 898:../uvc.c      **** 		 }
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 900:../uvc.c      **** }
 901:../uvc.c      **** /************** CT control requests handler *************************/
 902:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 903:../uvc.c      **** 
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 905:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 906:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 907:../uvc.c      ****     uint16_t readCount;
 908:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 909:../uvc.c      ****     uint16_t diff, value, diffRd;
 910:../uvc.c      ****     uint8_t i, shutter, index;
 911:../uvc.c      ****     diff = 0xffff;
 912:../uvc.c      ****     shutter = 1;
 913:../uvc.c      ****     index = 1;
 914:../uvc.c      **** 
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 917:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 919:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 920:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 921:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 922:../uvc.c      **** #endif
 923:../uvc.c      ****     reqData = bRequest;
 924:../uvc.c      **** 
 925:../uvc.c      ****     switch (bRequest)
 926:../uvc.c      **** 		 {
 927:../uvc.c      **** 
 928:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 932:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 933:../uvc.c      **** 			  break;
 934:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 935:../uvc.c      **** 
 936:../uvc.c      **** 			 switch(CtrlID)
 937:../uvc.c      **** 			 {
 938:../uvc.c      **** 				 default:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 943:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 944:../uvc.c      **** 					 break;
 945:../uvc.c      **** 			 }
 946:../uvc.c      **** 
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 948:../uvc.c      **** 
 949:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 950:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 951:../uvc.c      **** #endif
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 966:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 967:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 968:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 969:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 970:../uvc.c      **** 			  break;
 971:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 975:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 976:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 977:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 978:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 983:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 984:../uvc.c      **** 			  Len = 1;
 985:../uvc.c      **** 			  break;
 986:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 993:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 994:../uvc.c      **** 			  break;
 995:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 997:../uvc.c      **** 			  glEp0Buffer, &readCount);
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1000:../uvc.c      **** 			  value = Data1;
1001:../uvc.c      **** 
1002:../uvc.c      **** 			  switch(CtrlID)
1003:../uvc.c      **** 			  {
1004:../uvc.c      **** 		  	      case AutoExMCtlID1:
1005:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1006:../uvc.c      **** 
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1009:../uvc.c      **** 				    getData = glEp0Buffer[0];
1010:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1011:../uvc.c      **** 		  		    switch (getData){
1012:../uvc.c      **** 						case 1:
1013:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1014:../uvc.c      **** 							break;
1015:../uvc.c      **** 						case 2:
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1017:../uvc.c      **** 							dataIdx = 0;
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1021:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1022:../uvc.c      **** 
1023:../uvc.c      **** 							break;
1024:../uvc.c      **** 						case 4:
1025:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1026:../uvc.c      **** 							break;
1027:../uvc.c      **** 						case 8:
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1029:../uvc.c      **** 			  		    	dataIdx = 0;
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1033:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1034:../uvc.c      **** 							break;
1035:../uvc.c      **** 		  		    }
1036:../uvc.c      **** #if 0
1037:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1038:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1039:../uvc.c      **** 						  dataIdx = 0;
1040:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1041:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1042:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1043:../uvc.c      **** 		  		    }
1044:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1045:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1046:../uvc.c      **** 		  		    }
1047:../uvc.c      **** #endif
1048:../uvc.c      **** 				    break;
1049:../uvc.c      **** 
1050:../uvc.c      **** 			  	  case ExTmACtlID3:
1051:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1052:../uvc.c      **** 
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1056:../uvc.c      **** 					  {
1057:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1058:../uvc.c      **** 						  {
1059:../uvc.c      **** 							if(value > ShutValueArry[i]){
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1061:../uvc.c      **** 							}else{
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1063:../uvc.c      **** 							}
1064:../uvc.c      **** 							  if(diff > diffRd){
1065:../uvc.c      **** 								  diff = diffRd;
1066:../uvc.c      **** 								  index = i;
1067:../uvc.c      **** 							  }
1068:../uvc.c      **** 						  }
1069:../uvc.c      **** 						  shutter = shutter+index;
1070:../uvc.c      **** 
1071:../uvc.c      **** 						  dataIdx = 0;
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1075:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1076:../uvc.c      **** 
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1081:../uvc.c      **** 					  }else{
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1083:../uvc.c      **** 					  }
1084:../uvc.c      **** 					  getData = glEp0Buffer[0];
1085:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1086:../uvc.c      **** 					  break;
1087:../uvc.c      **** 			  	  case IriACtlID7:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1089:../uvc.c      **** 					  {
1090:../uvc.c      **** 							 dataIdx = 0;
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1094:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1095:../uvc.c      **** 
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1099:../uvc.c      **** 					  }else{
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1101:../uvc.c      **** 					  }
1102:../uvc.c      **** 					  getData = glEp0Buffer[0];
1103:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					  break;
1106:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1107:../uvc.c      **** 					  getData = glEp0Buffer[0];
1108:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1109:../uvc.c      **** #if 1
1110:../uvc.c      **** 					  dataIdx = 0;
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1112:../uvc.c      **** 					  if(getData == 1)
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1114:../uvc.c      **** 					  else if(getData == 0xff)
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1116:../uvc.c      **** 					  else
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1118:../uvc.c      **** 					  //dataIdx++;
1119:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1121:../uvc.c      **** #endif
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1123:../uvc.c      **** 					  break;
1124:../uvc.c      **** 
1125:../uvc.c      **** 			  	  default:
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1128:../uvc.c      **** 			  		 break;
1129:../uvc.c      **** 			  }
1130:../uvc.c      **** 			  break;
1131:../uvc.c      **** 		  default:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1134:../uvc.c      **** 			  break;
1135:../uvc.c      **** 		 }
1136:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1137:../uvc.c      **** 
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1139:../uvc.c      **** }
1140:../uvc.c      **** 
1141:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1142:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1143:../uvc.c      **** {
1144:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1145:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1146:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1147:../uvc.c      **** 
1148:../uvc.c      ****     CtrlID = BrgtCtlID1;
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1152:../uvc.c      ****     Data1 = Data0;
1153:../uvc.c      **** 
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1155:../uvc.c      ****     if(Data1&0x80){
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1157:../uvc.c      ****     }else{
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1159:../uvc.c      ****     }
1160:../uvc.c      ****     Data0 = (Data0 << 2);
1161:../uvc.c      **** 
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1163:../uvc.c      **** 
1164:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1169:../uvc.c      **** 
1170:../uvc.c      ****     CtrlID = ConsCtlID2;
1171:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1172:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1177:../uvc.c      **** 
1178:../uvc.c      ****     CtrlID = HueCtlID5;
1179:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1190:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1191:../uvc.c      **** 
1192:../uvc.c      ****     CtrlID = SaturCtlID6;
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1199:../uvc.c      **** 
1200:../uvc.c      ****     CtrlID = ShapCtlID7;
1201:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1202:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1207:../uvc.c      **** 
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1209:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1210:../uvc.c      **** 	return;
1211:../uvc.c      **** }
1212:../uvc.c      **** 
1213:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1214:../uvc.c      **** void
1215:../uvc.c      **** CyFxUVCAddHeader (
1216:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1217:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1218:../uvc.c      ****         )
1219:../uvc.c      **** {
1220:../uvc.c      ****     /* Copy header to buffer */
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1222:../uvc.c      **** 
1223:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1225:../uvc.c      ****     {
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1227:../uvc.c      ****     }
1228:../uvc.c      **** }
1229:../uvc.c      **** 
1230:../uvc.c      **** 
1231:../uvc.c      **** /* Application Error Handler */
1232:../uvc.c      **** void
1233:../uvc.c      **** CyFxAppErrorHandler (
1234:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1235:../uvc.c      ****         )
1236:../uvc.c      **** {
1237:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1238:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1239:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1240:../uvc.c      **** 
1241:../uvc.c      ****        This function can be modified to take additional error handling actions such
1242:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1243:../uvc.c      ****      */
1244:../uvc.c      ****     for (;;)
1245:../uvc.c      ****     {
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
1248:../uvc.c      ****     }
1249:../uvc.c      **** }
1250:../uvc.c      **** 
1251:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1252:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1253:../uvc.c      ****  */
1254:../uvc.c      **** static void
1255:../uvc.c      **** CyFxUVCApplnAbortHandler (
1256:../uvc.c      ****         void)
1257:../uvc.c      **** {
1258:../uvc.c      **** 	uint32_t flag;
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1260:../uvc.c      **** 	{
1261:../uvc.c      ****         /* Clear the Video Stream Request Event */
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1263:../uvc.c      **** 
1264:../uvc.c      ****         /* Set Video Stream Abort Event */
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1266:../uvc.c      **** 	}
1267:../uvc.c      **** }
1268:../uvc.c      **** 
1269:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1270:../uvc.c      **** static void
1271:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1272:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1273:../uvc.c      ****         uint16_t             evdata  /* Event data */
1274:../uvc.c      ****         )
1275:../uvc.c      **** {
1276:../uvc.c      ****     switch (evtype)
1277:../uvc.c      ****     {
1278:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1281:../uvc.c      ****             gpif_initialized = 0;
1282:../uvc.c      ****             streamingStarted = CyFalse;
1283:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1284:../uvc.c      ****             break;
1285:../uvc.c      **** 
1286:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1289:../uvc.c      ****             gpif_initialized = 0;
1290:../uvc.c      ****             streamingStarted = CyFalse;
1291:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1292:../uvc.c      ****             break;
1293:../uvc.c      **** 
1294:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1297:../uvc.c      ****             gpif_initialized = 0;
1298:../uvc.c      ****             isUsbConnected = CyFalse;
1299:../uvc.c      ****             streamingStarted = CyFalse;
1300:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1301:../uvc.c      ****             break;
1302:../uvc.c      **** 
1303:../uvc.c      **** #ifdef BACKFLOW_DETECT
1304:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1305:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1306:../uvc.c      ****             break;
1307:../uvc.c      **** #endif
1308:../uvc.c      **** 
1309:../uvc.c      ****         default:
1310:../uvc.c      ****             break;
1311:../uvc.c      ****     }
1312:../uvc.c      **** }
1313:../uvc.c      **** 
1314:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1315:../uvc.c      **** static CyBool_t
1316:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1317:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1318:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1319:../uvc.c      ****         )
1320:../uvc.c      **** {
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1322:../uvc.c      ****     uint32_t status;
1323:../uvc.c      **** 
1324:../uvc.c      ****     /* Obtain Request Type and Request */
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1330:../uvc.c      **** 
1331:../uvc.c      ****     /* Check for UVC Class Requests */
1332:../uvc.c      ****     switch (bmReqType)
1333:../uvc.c      ****     {
1334:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1335:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1336:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1337:../uvc.c      ****             switch (wIndex & 0xFF)
1338:../uvc.c      ****             {
1339:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1340:../uvc.c      ****                     {
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1343:../uvc.c      ****                                 CYU3P_EVENT_OR);
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1345:../uvc.c      ****                         {
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1348:../uvc.c      ****                         }
1349:../uvc.c      ****                     }
1350:../uvc.c      ****                     break;
1351:../uvc.c      **** 
1352:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1353:../uvc.c      ****                     {
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1356:../uvc.c      ****                                 CYU3P_EVENT_OR);
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1358:../uvc.c      ****                         {
1359:../uvc.c      ****                             /* Error handling */
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1362:../uvc.c      ****                         }
1363:../uvc.c      ****                     }
1364:../uvc.c      ****                     break;
1365:../uvc.c      **** 
1366:../uvc.c      ****                 default:
1367:../uvc.c      ****                     break;
1368:../uvc.c      ****             }
1369:../uvc.c      ****             break;
1370:../uvc.c      **** 
1371:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1373:../uvc.c      ****             {
1374:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1375:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1377:../uvc.c      ****                 {
1378:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1381:../uvc.c      ****                     gpif_initialized = 0;
1382:../uvc.c      ****                     streamingStarted = CyFalse;
1383:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1385:../uvc.c      ****                     CyU3PBusyWait (100);
1386:../uvc.c      **** 
1387:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1391:../uvc.c      ****                     CyU3PBusyWait (100);
1392:../uvc.c      **** 
1393:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
1396:../uvc.c      ****                     /* Complete Control request handshake */
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
1398:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1400:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1401:../uvc.c      **** 
1402:../uvc.c      ****                 }
1403:../uvc.c      ****             }
1404:../uvc.c      ****             break;
1405:../uvc.c      **** 
1406:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1408:../uvc.c      ****             {
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1410:../uvc.c      ****                 {
1411:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1412:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1413:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1414:../uvc.c      ****                 	 * has started. */
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
1416:../uvc.c      ****                     {
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1418:../uvc.c      **** 
1419:../uvc.c      ****                         /* Disable the GPIF state machine. */
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1421:../uvc.c      ****                         gpif_initialized = 0;
1422:../uvc.c      ****                         streamingStarted = CyFalse;
1423:../uvc.c      **** 
1424:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1426:../uvc.c      ****                         CyU3PBusyWait (100);
1427:../uvc.c      **** 
1428:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1432:../uvc.c      ****                         CyU3PBusyWait (100);
1433:../uvc.c      **** 
1434:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1436:../uvc.c      **** 
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
1438:../uvc.c      ****                         /* Complete Control request handshake */
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
1440:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1442:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1443:../uvc.c      ****                     }
1444:../uvc.c      ****                     else
1445:../uvc.c      ****                     {
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
1448:../uvc.c      ****                     }
1449:../uvc.c      ****                 }
1450:../uvc.c      ****             }
1451:../uvc.c      ****             break;
1452:../uvc.c      **** 
1453:../uvc.c      ****         default:
1454:../uvc.c      ****             break;
1455:../uvc.c      ****     }
1456:../uvc.c      **** 
1457:../uvc.c      ****     /* Return status of request handling to the USB driver */
1458:../uvc.c      ****     return uvcHandleReq;
1459:../uvc.c      **** }
1460:../uvc.c      **** 
1461:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1462:../uvc.c      **** 
1463:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1464:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1465:../uvc.c      ****  */
1466:../uvc.c      **** void
1467:../uvc.c      **** CyFxUvcApplnDmaCallback (
1468:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1469:../uvc.c      ****         CyU3PDmaCbType_t      type,
1470:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1471:../uvc.c      ****         )
1472:../uvc.c      **** {
1473:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1474:../uvc.c      **** #if 1
1475:../uvc.c      ****     CyU3PReturnStatus_t status;
1476:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1477:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1478:../uvc.c      **** 
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1480:../uvc.c      ****     {
1481:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1482:../uvc.c      ****             {
1483:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1484:../uvc.c      ****                 fb++;
1485:../uvc.c      ****             }
1486:../uvc.c      ****             else
1487:../uvc.c      ****             {
1488:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1489:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1490:../uvc.c      ****                 pb++;
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
1492:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1493:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1494:../uvc.c      ****                 //lineCount = 0; //res test
1495:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
1496:../uvc.c      ****             }
1497:../uvc.c      **** 
1498:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1499:../uvc.c      ****             prodCount++;
1500:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1501:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1502:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1503:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1504:../uvc.c      ****             {
1505:../uvc.c      ****                 prodCount--;
1506:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1507:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1508:../uvc.c      ****             }
1509:../uvc.c      ****     }
1510:../uvc.c      **** #endif
1511:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1512:../uvc.c      ****     {
1513:../uvc.c      ****         consCount++;
1514:../uvc.c      ****         streamingStarted = CyTrue;
1515:../uvc.c      ****     }
1516:../uvc.c      **** }
1517:../uvc.c      **** 
1518:../uvc.c      **** /*
1519:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1520:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1521:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1522:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1523:../uvc.c      ****  * to commit the buffer.
1524:../uvc.c      ****  */
1525:../uvc.c      **** static uint8_t
1526:../uvc.c      **** CyFxUvcAppCommitEOF (
1527:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1528:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1529:../uvc.c      ****         )
1530:../uvc.c      **** {
1531:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1532:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1533:../uvc.c      **** 
1534:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1535:../uvc.c      **** 
1536:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1537:../uvc.c      ****     {
1538:../uvc.c      ****         switch (stateId)
1539:../uvc.c      ****         {
1540:../uvc.c      **** 
1541:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1542:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1543:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1544:../uvc.c      ****                 break;
1545:../uvc.c      **** 
1546:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1547:../uvc.c      ****                 socket = 0;
1548:../uvc.c      ****                 break;
1549:../uvc.c      **** 
1550:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1551:../uvc.c      ****                 socket = 1;
1552:../uvc.c      ****                 break;
1553:../uvc.c      **** 
1554:../uvc.c      ****             default:
1555:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1556:../uvc.c      ****                 /* Unexpected current state. Return error. */
1557:../uvc.c      ****             	//lineCount++;
1558:../uvc.c      ****             	return 1;
1559:../uvc.c      ****         }
1560:../uvc.c      ****     }
1561:../uvc.c      **** 
1562:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1563:../uvc.c      ****     {
1564:../uvc.c      ****         switch (stateId)
1565:../uvc.c      ****         {
1566:../uvc.c      **** #ifndef CAM720
1567:../uvc.c      **** #ifdef GPIFIIM
1568:../uvc.c      ****             case 13:
1569:../uvc.c      ****             case 24:
1570:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1571:../uvc.c      ****                 break;
1572:../uvc.c      **** 
1573:../uvc.c      ****             case 8:
1574:../uvc.c      ****                 socket = 0;
1575:../uvc.c      ****                 break;
1576:../uvc.c      **** 
1577:../uvc.c      ****             case 20:
1578:../uvc.c      ****                 socket = 1;
1579:../uvc.c      ****                 break;
1580:../uvc.c      **** #else
1581:../uvc.c      ****             case 11:
1582:../uvc.c      ****             case 18:
1583:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1584:../uvc.c      ****                 break;
1585:../uvc.c      **** 
1586:../uvc.c      ****             case 8:
1587:../uvc.c      ****                 socket = 0;
1588:../uvc.c      ****                 break;
1589:../uvc.c      **** 
1590:../uvc.c      ****             case 15:
1591:../uvc.c      ****                 socket = 1;
1592:../uvc.c      ****                 break;
1593:../uvc.c      **** #endif
1594:../uvc.c      **** #else
1595:../uvc.c      ****             case 11:
1596:../uvc.c      ****             case 18:
1597:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1598:../uvc.c      ****                 break;
1599:../uvc.c      **** 
1600:../uvc.c      ****             case 8:
1601:../uvc.c      ****                 socket = 0;
1602:../uvc.c      ****                 break;
1603:../uvc.c      **** 
1604:../uvc.c      ****             case 15:
1605:../uvc.c      ****                 socket = 1;
1606:../uvc.c      ****                 break;
1607:../uvc.c      **** 
1608:../uvc.c      **** #endif
1609:../uvc.c      ****              default:
1610:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1611:../uvc.c      ****                 /* Unexpected current state. Return error. */
1612:../uvc.c      ****                return 1;
1613:../uvc.c      ****         }
1614:../uvc.c      ****     }
1615:../uvc.c      **** 
1616:../uvc.c      ****     if (socket != 0xFF)
1617:../uvc.c      ****     {
1618:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1619:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1620:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1621:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1622:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1623:../uvc.c      ****         {
1624:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1625:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1626:../uvc.c      ****         }
1627:../uvc.c      ****     }
1628:../uvc.c      **** 
1629:../uvc.c      ****     return 0;
1630:../uvc.c      **** }
1631:../uvc.c      **** 
1632:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1633:../uvc.c      **** void
1634:../uvc.c      **** CyFxGpifCB (
1635:../uvc.c      ****         CyU3PGpifEventType event,
1636:../uvc.c      ****         uint8_t currentState
1637:../uvc.c      ****         )
1638:../uvc.c      **** {
1639:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1640:../uvc.c      ****     {
1641:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1642:../uvc.c      ****     	           in the UVC implementation. */
1643:../uvc.c      ****     	//hitFV = CyTrue;
1644:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1645:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1646:../uvc.c      ****     }
1647:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1648:../uvc.c      **** }
1649:../uvc.c      **** 
1650:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1651:../uvc.c      **** static void
1652:../uvc.c      **** CyFxUVCApplnDebugInit (
1653:../uvc.c      ****         void)
1654:../uvc.c      **** {
1655:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1656:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1657:../uvc.c      **** 
1658:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1659:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1660:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1661:../uvc.c      ****     {
1662:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1663:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1664:../uvc.c      ****     }
1665:../uvc.c      **** 
1666:../uvc.c      ****     /* Set UART Configuration */
1667:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1668:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1669:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1670:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1671:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1672:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1673:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1674:../uvc.c      **** 
1675:../uvc.c      ****     /* Set the UART configuration */
1676:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1677:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1678:../uvc.c      ****     {
1679:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1680:../uvc.c      ****     }
1681:../uvc.c      **** 
1682:../uvc.c      ****     /* Set the UART transfer */
1683:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1684:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1685:../uvc.c      ****     {
1686:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1687:../uvc.c      ****     }
1688:../uvc.c      **** 
1689:../uvc.c      ****     /* Initialize the Debug logger module. */
1690:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1691:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1692:../uvc.c      ****     {
1693:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1694:../uvc.c      ****     }
1695:../uvc.c      **** 
1696:../uvc.c      ****     /* Disable log message headers. */
1697:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1698:../uvc.c      **** }
1699:../uvc.c      **** 
1700:../uvc.c      **** /* I2C initialization. */
1701:../uvc.c      **** static void
1702:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1703:../uvc.c      **** {
1704:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1705:../uvc.c      ****     CyU3PReturnStatus_t status;
1706:../uvc.c      **** 
1707:../uvc.c      ****     status = CyU3PI2cInit ();
1708:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1709:../uvc.c      ****     {
1710:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1711:../uvc.c      ****         CyFxAppErrorHandler (status);
1712:../uvc.c      ****     }
1713:../uvc.c      **** 
1714:../uvc.c      ****     /*  Set I2C Configuration */
1715:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1716:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1717:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1718:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1719:../uvc.c      **** 
1720:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1721:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1722:../uvc.c      ****     {
1723:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1724:../uvc.c      ****         CyFxAppErrorHandler (status);
1725:../uvc.c      ****     }
1726:../uvc.c      **** }
1727:../uvc.c      **** 
1728:../uvc.c      **** #ifdef BACKFLOW_DETECT
1729:../uvc.c      **** static void CyFxUvcAppPibCallback (
1730:../uvc.c      ****         CyU3PPibIntrType cbType,
1731:../uvc.c      ****         uint16_t cbArg)
1732:../uvc.c      **** {
1733:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1734:../uvc.c      ****     {
1735:../uvc.c      ****         if (!back_flow_detected)
1736:../uvc.c      ****         {
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1738:../uvc.c      ****             back_flow_detected = 1;
1739:../uvc.c      ****         }
1740:../uvc.c      ****     }
1741:../uvc.c      **** }
1742:../uvc.c      **** #endif
1743:../uvc.c      **** 
1744:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1745:../uvc.c      **** static void
1746:../uvc.c      **** CyFxUvcAppDebugCallback (
1747:../uvc.c      ****         CyU3PDmaChannel   *handle,
1748:../uvc.c      ****         CyU3PDmaCbType_t   type,
1749:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1750:../uvc.c      **** {
1751:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1752:../uvc.c      ****     {
1753:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1754:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1755:../uvc.c      ****     }
1756:../uvc.c      **** }
1757:../uvc.c      **** #endif
1758:../uvc.c      **** 
1759:../uvc.c      **** #if 0
1760:../uvc.c      **** static void CyFxAppIntEpCb(
1761:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1762:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1763:../uvc.c      **** 		uint8_t  ebNum)
1764:../uvc.c      **** 		{
1765:../uvc.c      **** 			//CyBool_t value;
1766:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1767:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1768:../uvc.c      **** 
1769:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1770:../uvc.c      **** 		}
1771:../uvc.c      **** #endif
1772:../uvc.c      **** 
1773:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1774:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1775:../uvc.c      ****    configures the DMA module for the UVC Application */
1776:../uvc.c      **** static void
1777:../uvc.c      **** CyFxUVCApplnInit (void)
1778:../uvc.c      **** {
1779:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1780:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1781:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1782:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1783:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1784:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1785:../uvc.c      **** 
1786:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1787:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1788:../uvc.c      **** 
1789:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1790:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1791:../uvc.c      **** #endif
1792:../uvc.c      **** 
1793:../uvc.c      ****     /* Create UVC event group */
1794:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1795:../uvc.c      ****     if (apiRetStatus != 0)
1796:../uvc.c      ****     {
1797:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1798:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1799:../uvc.c      ****     }
1800:../uvc.c      **** 
1801:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1802:../uvc.c      ****     CyFxUvcAppPTZInit ();
1803:../uvc.c      **** #endif
1804:../uvc.c      **** 
1805:../uvc.c      ****     isUsbConnected = CyFalse;
1806:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1807:../uvc.c      **** 
1808:../uvc.c      ****     /* Init the GPIO module */
1809:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1810:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1811:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1812:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1813:../uvc.c      ****     gpioClock.halfDiv    = 0;
1814:../uvc.c      **** 
1815:../uvc.c      ****     /* Initialize Gpio interface */
1816:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1817:../uvc.c      ****     if (apiRetStatus != 0)
1818:../uvc.c      ****     {
1819:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1820:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1821:../uvc.c      ****     }
1822:../uvc.c      **** 
1823:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1824:../uvc.c      ****      * must use GpioOverride to configure it */
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1826:../uvc.c      ****     if (apiRetStatus != 0)
1827:../uvc.c      ****     {
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1829:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1830:../uvc.c      ****     }
1831:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1832:../uvc.c      ****     if (apiRetStatus != 0)
1833:../uvc.c      ****     {
1834:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1835:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1836:../uvc.c      ****     }
1837:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1838:../uvc.c      ****     if (apiRetStatus != 0)
1839:../uvc.c      ****     {
1840:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1841:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1842:../uvc.c      ****     }
1843:../uvc.c      **** 
1844:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1845:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1846:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1847:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1848:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1849:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1850:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1851:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1852:../uvc.c      ****     {
1853:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1854:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1855:../uvc.c      ****     }
1856:../uvc.c      **** 
1857:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1858:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1859:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1860:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1861:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1862:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1863:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1864:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1865:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1866:../uvc.c      ****     {
1867:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1868:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1869:../uvc.c      ****     }
1870:../uvc.c      **** 
1871:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1872:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1873:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1874:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1875:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1876:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1877:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1878:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1880:../uvc.c      ****     {
1881:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1883:../uvc.c      ****     }
1884:../uvc.c      **** 
1885:../uvc.c      ****     /* Initialize the P-port. */
1886:../uvc.c      ****     pibclock.clkDiv      = 2;
1887:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1888:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1889:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1890:../uvc.c      **** 
1891:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1892:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1893:../uvc.c      ****     {
1894:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1895:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1896:../uvc.c      ****     }
1897:../uvc.c      **** 
1898:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1899:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1900:../uvc.c      **** 
1901:../uvc.c      **** #ifdef BACKFLOW_DETECT
1902:../uvc.c      ****     back_flow_detected = 0;
1903:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1904:../uvc.c      **** #endif
1905:../uvc.c      **** 
1906:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1907:../uvc.c      ****     SensorReset ();
1908:../uvc.c      ****     CyU3PThreadSleep(5000);
1909:../uvc.c      ****     //SensorInit ();
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* USB initialization. */
1912:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1913:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1914:../uvc.c      ****     {
1915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1917:../uvc.c      ****     }
1918:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1919:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1920:../uvc.c      **** 
1921:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1922:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1923:../uvc.c      **** 
1924:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1925:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1926:../uvc.c      **** 
1927:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1930:../uvc.c      **** 
1931:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1933:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1934:../uvc.c      **** 
1935:../uvc.c      ****     /* Configuration descriptors. */
1936:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1937:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1938:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1939:../uvc.c      **** 
1940:../uvc.c      ****     /* String Descriptors */
1941:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1942:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1943:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1944:../uvc.c      **** 
1945:../uvc.c      ****     /* Configure the status interrupt endpoint.
1946:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1947:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1948:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1949:../uvc.c      ****      */
1950:../uvc.c      ****     endPointConfig.enable   = 1;
1951:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1952:../uvc.c      ****     endPointConfig.pcktSize = 64;
1953:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1954:../uvc.c      ****     endPointConfig.streams  = 0;
1955:../uvc.c      ****     endPointConfig.burstLen = 1;
1956:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1958:../uvc.c      ****     {
1959:../uvc.c      ****         /* Error Handling */
1960:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1961:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1962:../uvc.c      ****     }
1963:../uvc.c      **** 
1964:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1965:../uvc.c      ****     dmaInterConfig.size           = 1024;
1966:../uvc.c      ****     dmaInterConfig.count          = 1;
1967:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1968:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1969:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1970:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1971:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1972:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1973:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1974:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1975:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1976:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1977:../uvc.c      ****             &dmaInterConfig);
1978:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1979:../uvc.c      ****     {
1980:../uvc.c      ****         /* Error handling */
1981:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1982:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1983:../uvc.c      ****     }
1984:../uvc.c      **** 
1985:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1986:../uvc.c      ****     if (glInterStaBuffer == 0)
1987:../uvc.c      ****     {
1988:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1989:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1990:../uvc.c      ****     }
1991:../uvc.c      **** 
1992:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1993:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1994:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1995:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1996:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1997:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1998:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1999:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2000:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2001:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2002:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2003:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2004:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2005:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2006:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2007:../uvc.c      ****             &dmaMultiConfig);
2008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2009:../uvc.c      ****     {
2010:../uvc.c      ****         /* Error handling */
2011:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2012:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2013:../uvc.c      ****     }
2014:../uvc.c      **** 
2015:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2016:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2017:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2018:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2019:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2020:../uvc.c      ****      */
2021:../uvc.c      **** 
2022:../uvc.c      ****     endPointConfig.enable   = 1;
2023:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2024:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2025:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2026:../uvc.c      ****     endPointConfig.streams  = 0;
2027:../uvc.c      ****     endPointConfig.burstLen = 1;
2028:../uvc.c      **** 
2029:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2030:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2031:../uvc.c      ****     {
2032:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2033:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2034:../uvc.c      ****     }
2035:../uvc.c      **** 
2036:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2037:../uvc.c      **** 
2038:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2039:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2042:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2043:../uvc.c      ****     }
2044:../uvc.c      **** 
2045:../uvc.c      ****     channelConfig.size           = 1024;
2046:../uvc.c      ****     channelConfig.count          = 1;
2047:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2048:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2049:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2050:../uvc.c      ****     channelConfig.prodHeader     = 0;
2051:../uvc.c      ****     channelConfig.prodFooter     = 0;
2052:../uvc.c      ****     channelConfig.consHeader     = 0;
2053:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2054:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2055:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2056:../uvc.c      **** 
2057:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2058:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2059:../uvc.c      ****     {
2060:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2061:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2062:../uvc.c      ****     }
2063:../uvc.c      **** 
2064:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2065:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2066:../uvc.c      ****     {
2067:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2068:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2069:../uvc.c      ****     }
2070:../uvc.c      **** 
2071:../uvc.c      ****     channelConfig.size           = 1024;
2072:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2073:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2074:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2075:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2076:../uvc.c      ****     channelConfig.prodHeader     = 0;
2077:../uvc.c      ****     channelConfig.prodFooter     = 0;
2078:../uvc.c      ****     channelConfig.consHeader     = 0;
2079:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2080:../uvc.c      ****     channelConfig.notification   = 0;
2081:../uvc.c      ****     channelConfig.cb             = 0;
2082:../uvc.c      **** 
2083:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2084:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2085:../uvc.c      ****     {
2086:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2087:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2088:../uvc.c      ****     }
2089:../uvc.c      **** 
2090:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2091:../uvc.c      ****     if (glDebugRspBuffer == 0)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2094:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2095:../uvc.c      ****     }
2096:../uvc.c      **** #endif
2097:../uvc.c      **** 
2098:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2099:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2100:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2101:../uvc.c      ****     {
2102:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2103:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2104:../uvc.c      ****     }
2105:../uvc.c      **** 
2106:../uvc.c      ****     CyU3PBusyWait(100);
2107:../uvc.c      **** 
2108:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2109:../uvc.c      **** 
2110:../uvc.c      ****     endPointConfig.enable   = 1;
2111:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2112:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2113:../uvc.c      ****     {
2114:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2115:../uvc.c      ****     	endPointConfig.burstLen = 16;
2116:../uvc.c      ****     }
2117:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2118:../uvc.c      ****     {
2119:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2120:../uvc.c      ****     	endPointConfig.burstLen = 1;
2121:../uvc.c      ****     }
2122:../uvc.c      ****     endPointConfig.streams  = 0;
2123:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2124:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2125:../uvc.c      ****     {
2126:../uvc.c      ****         /* Error Handling */
2127:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2128:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2129:../uvc.c      ****     }
2130:../uvc.c      **** #if 0    //for still image method 3 using
2131:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2132:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2133:../uvc.c      ****     {
2134:../uvc.c      ****         /* Error Handling */
2135:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2136:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2137:../uvc.c      ****     }
2138:../uvc.c      **** #endif
2139:../uvc.c      **** 
2140:../uvc.c      **** }
2141:../uvc.c      **** 
2142:../uvc.c      **** /*
2143:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2144:../uvc.c      ****  * streaming session is started.
2145:../uvc.c      ****  */
2146:../uvc.c      **** static void
2147:../uvc.c      **** CyFxUvcAppGpifInit (
2148:../uvc.c      ****         void)
2149:../uvc.c      **** {
2150:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2151:../uvc.c      **** 
2152:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2153:../uvc.c      ****     {
2154:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2155:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2156:../uvc.c      ****     }
2157:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2158:../uvc.c      ****     {
2159:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2160:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2161:../uvc.c      ****     }
2162:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2163:../uvc.c      ****     {
2164:../uvc.c      ****         /* Error Handling */
2165:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2166:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2167:../uvc.c      ****     }
2168:../uvc.c      **** 
2169:../uvc.c      ****     /* Start the state machine from the designated start state. */
2170:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2171:../uvc.c      ****     {
2172:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2173:../uvc.c      ****     }
2174:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2175:../uvc.c      ****     {
2176:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2177:../uvc.c      ****     }
2178:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2179:../uvc.c      ****     {
2180:../uvc.c      ****         /* Error Handling */
2181:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2182:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2183:../uvc.c      ****     }
2184:../uvc.c      **** }
2185:../uvc.c      **** 
2186:../uvc.c      **** /*
2187:../uvc.c      ****  * Entry function for the UVC Application Thread
2188:../uvc.c      ****  */
2189:../uvc.c      **** 
2190:../uvc.c      **** uint32_t posTick;
2191:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2192:../uvc.c      **** 
2193:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2194:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2195:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2196:../uvc.c      **** }
2197:../uvc.c      **** 
2198:../uvc.c      **** 
2199:../uvc.c      **** void
2200:../uvc.c      **** UVCAppThread_Entry (
2201:../uvc.c      ****         uint32_t input)
2202:../uvc.c      **** {
2203:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2204:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2205:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2206:../uvc.c      ****     uint8_t i = 0;
2207:../uvc.c      ****     uint32_t flag;
2208:../uvc.c      ****     uint32_t prinflag = 0;
2209:../uvc.c      **** 
2210:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2211:../uvc.c      ****     uint32_t frameCnt = 0;
2212:../uvc.c      **** #endif
2213:../uvc.c      ****     /* Initialize the Uart Debug Module */
2214:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2215:../uvc.c      **** 
2216:../uvc.c      ****     /* Initialize the I2C interface */
2217:../uvc.c      **** 	while (i++ < 6){
2218:../uvc.c      **** 		CyU3PThreadSleep(500);
2219:../uvc.c      **** 	}
2220:../uvc.c      **** 
2221:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2222:../uvc.c      **** 
2223:../uvc.c      ****     /* Initialize the UVC Application */
2224:../uvc.c      ****     CyFxUVCApplnInit ();
2225:../uvc.c      ****     /*
2226:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2227:../uvc.c      **** 
2228:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2229:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2230:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2231:../uvc.c      **** 
2232:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2233:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2234:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2235:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2236:../uvc.c      **** 
2237:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2238:../uvc.c      ****        of handling the abort request.
2239:../uvc.c      ****      */
2240:../uvc.c      **** 
2241:../uvc.c      ****     for (;;)
2242:../uvc.c      ****     {
2243:../uvc.c      ****         /* Waiting for the Video Stream Event */
2244:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2245:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2246:../uvc.c      ****         {
2247:../uvc.c      **** #if 0 //test for new firmware no video bring up
2248:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2249:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2250:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2251:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2252:../uvc.c      ****             {
2253:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2254:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2255:../uvc.c      ****                 {
2256:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2257:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2258:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2259:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2260:../uvc.c      **** #endif
2261:../uvc.c      **** #endif
2262:../uvc.c      ****                     }
2263:../uvc.c      ****                 else
2264:../uvc.c      ****                 {
2265:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2266:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2267:../uvc.c      **** #ifdef USB_LOWRES_IMG
2268:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2269:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2270:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2271:../uvc.c      **** #endif
2272:../uvc.c      **** #endif
2273:../uvc.c      ****                 }
2274:../uvc.c      **** 
2275:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2276:../uvc.c      ****                 prodCount++;
2277:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2278:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2279:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2280:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2281:../uvc.c      ****                 {
2282:../uvc.c      ****                     prodCount--;
2283:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2284:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2285:../uvc.c      ****                 }
2286:../uvc.c      ****             }
2287:../uvc.c      **** #endif
2288:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2289:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2290:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2291:../uvc.c      ****             {
2292:../uvc.c      ****             	if(0&&(prinflag == 0)){
2293:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2294:../uvc.c      ****             		prinflag = 1;
2295:../uvc.c      ****             	}
2296:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2297:../uvc.c      ****             	fb=0;
2298:../uvc.c      ****             	pb=0;
2299:../uvc.c      ****             	pbc=0;
2300:../uvc.c      ****                 prodCount = 0;
2301:../uvc.c      ****                 consCount = 0;
2302:../uvc.c      ****                 hitFV     = CyFalse;
2303:../uvc.c      **** 
2304:../uvc.c      **** #ifdef BACKFLOW_DETECT
2305:../uvc.c      ****                 back_flow_detected = 0;
2306:../uvc.c      **** #endif
2307:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2308:../uvc.c      ****                 frameCnt++;
2309:../uvc.c      **** #endif
2310:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2311:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2312:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2313:../uvc.c      ****                 //}
2314:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2315:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2316:../uvc.c      ****                 if(stiflag){
2317:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
2318:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
2319:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
2320:../uvc.c      ****                 		stiflag = CyFalse;
2321:../uvc.c      ****                 	}
2322:../uvc.c      ****                 }else{
2323:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2324:../uvc.c      ****                 }
2325:../uvc.c      ****                 /* Reset the DMA channel. */
2326:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2327:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2328:../uvc.c      ****                 {
2329:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2330:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2331:../uvc.c      ****                 }
2332:../uvc.c      **** 
2333:../uvc.c      ****                 /* Start Channel Immediately */
2334:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2335:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2336:../uvc.c      ****                 {
2337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2338:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2339:../uvc.c      ****                 }
2340:../uvc.c      **** 
2341:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2342:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2343:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2344:../uvc.c      ****                 }
2345:../uvc.c      ****         }
2346:../uvc.c      ****         else
2347:../uvc.c      ****         {
2348:../uvc.c      ****             /* If we have a stream abort request pending. */
2349:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2350:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2351:../uvc.c      ****             {
2352:../uvc.c      ****                 hitFV     = CyFalse;
2353:../uvc.c      ****                 prodCount = 0;
2354:../uvc.c      ****                 consCount = 0;
2355:../uvc.c      ****                 if(0&&(prinflag == 0)){
2356:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2357:../uvc.c      ****                 	prinflag = 1;
2358:../uvc.c      ****                 }
2359:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2360:../uvc.c      ****                 fb=0;
2361:../uvc.c      ****                 pb=0;
2362:../uvc.c      ****                 pbc=0;
2363:../uvc.c      **** 
2364:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2365:../uvc.c      ****                 {
2366:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2367:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2368:../uvc.c      ****                     {
2369:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2370:../uvc.c      ****                     }
2371:../uvc.c      **** 
2372:../uvc.c      ****                     /* Flush the Endpoint memory */
2373:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2374:../uvc.c      ****                 }
2375:../uvc.c      **** 
2376:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2377:../uvc.c      ****             }
2378:../uvc.c      ****             else
2379:../uvc.c      ****             {
2380:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2381:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2382:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2383:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2384:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2385:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2386:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2387:../uvc.c      ****                 {
2388:../uvc.c      ****                     /* Error handling */
2389:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2390:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2391:../uvc.c      ****                 }
2392:../uvc.c      **** 
2393:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2394:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2395:../uvc.c      ****                 {
2396:../uvc.c      **** #if 0
2397:../uvc.c      ****                 	//for start up of the AF Lens
2398:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2399:../uvc.c      ****                     CyU3PThreadSleep(500);
2400:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2401:../uvc.c      ****                     CyU3PThreadSleep(500);
2402:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2403:../uvc.c      ****                    	CyU3PThreadSleep(300);
2404:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2405:../uvc.c      ****                     CyU3PThreadSleep(500);
2406:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2407:../uvc.c      ****                     CyU3PThreadSleep(500);
2408:../uvc.c      **** //#if 0
2409:../uvc.c      ****                     //CyFxUVCApplnI2CInit ();
2410:../uvc.c      ****                     for(i = 0; i<1; i++){
2411:../uvc.c      ****     					//CyFxUVCApplnI2CInit ();
2412:../uvc.c      ****     					SensorWrite2B2(0x7a, 0x2, 0, 0x20, 0);
2413:../uvc.c      ****     					CyU3PThreadSleep(2000);
2414:../uvc.c      ****     				}
2415:../uvc.c      **** //#endif			// write sensor commands for hide the over write issue
2416:../uvc.c      ****                     CyU3PThreadSleep(1000);
2417:../uvc.c      ****                     SensorSetIrisControl(0x0, 0x30, 0x0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 5
2418:../uvc.c      ****                     CyU3PThreadSleep(1000);
2419:../uvc.c      ****                     SensorSetIrisControl(0x2, 0x30, 0x10, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2420:../uvc.c      ****                     CyU3PThreadSleep(1000);
2421:../uvc.c      ****                     SensorSetIrisControl(0x4, 0x30, 0x80, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2422:../uvc.c      **** #endif
2423:../uvc.c      ****                     CyU3PThreadSleep(1000);
2424:../uvc.c      ****                     SensorSetIrisControl(0x1, 0x30, 0x20, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
2425:../uvc.c      ****                     CyU3PThreadSleep(1000);
2426:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2427:../uvc.c      ****                     gpif_initialized = CyTrue;
2428:../uvc.c      ****                     CyU3PThreadSleep(200);
2429:../uvc.c      ****                     
2430:../uvc.c      ****                 }
2431:../uvc.c      ****                 else
2432:../uvc.c      ****                 {
2433:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2434:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2435:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2436:../uvc.c      ****                 }
2437:../uvc.c      ****             }
2438:../uvc.c      ****         }
2439:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2440:../uvc.c      **** 
2441:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2442:../uvc.c      ****         CyU3PThreadRelinquish ();
2443:../uvc.c      ****     }
2444:../uvc.c      **** }
2445:../uvc.c      **** 
2446:../uvc.c      **** /*
2447:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2448:../uvc.c      ****  */
2449:../uvc.c      **** 
2450:../uvc.c      **** static void
2451:../uvc.c      **** UVCHandleProcessingUnitRqts (
2452:../uvc.c      ****         void)
2453:../uvc.c      **** {
2454:../uvc.c      ****     uint8_t CtrlAdd;
2455:../uvc.c      **** #ifdef DbgInfo
2456:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2457:../uvc.c      **** #endif
2458:../uvc.c      ****     switch (wValue)
2459:../uvc.c      ****     {
2460:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2461:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2462:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2463:../uvc.c      ****     		break;
2464:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2465:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2466:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2467:../uvc.c      ****     		break;
2468:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2469:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2470:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2471:../uvc.c      **** 			break;
2472:../uvc.c      **** 
2473:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2474:../uvc.c      **** 
2475:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2476:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2477:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2478:../uvc.c      ****       		break;
2479:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2480:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2481:../uvc.c      ****      		ControlHandle(HueCtlID5);
2482:../uvc.c      ****      		break;
2483:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2484:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2485:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2486:../uvc.c      ****           		break;
2487:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2488:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2489:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2490:../uvc.c      ****           		break;
2491:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2492:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2493:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2494:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2495:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2496:../uvc.c      ****     		break;
2497:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2498:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2499:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2500:../uvc.c      ****     		break;
2501:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2502:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2503:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2504:../uvc.c      ****     		break;
2505:../uvc.c      **** 
2506:../uvc.c      ****         default:
2507:../uvc.c      ****             /*
2508:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2509:../uvc.c      ****              * other controls.
2510:../uvc.c      ****              */
2511:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2512:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2513:../uvc.c      ****             break;
2514:../uvc.c      ****     }
2515:../uvc.c      **** }
2516:../uvc.c      **** 
2517:../uvc.c      **** /*
2518:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2519:../uvc.c      ****  */
2520:../uvc.c      **** static void
2521:../uvc.c      **** UVCHandleCameraTerminalRqts (
2522:../uvc.c      ****         void)
2523:../uvc.c      **** {
2524:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2525:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2526:../uvc.c      ****     uint16_t readCount;
2527:../uvc.c      ****     uint16_t zoomVal;
2528:../uvc.c      ****     int32_t  panVal, tiltVal;
2529:../uvc.c      ****     CyBool_t sendData = CyFalse;
2530:../uvc.c      **** #endif
2531:../uvc.c      ****     uint8_t CtrlAdd;
2532:../uvc.c      **** 
2533:../uvc.c      ****     switch (wValue)
2534:../uvc.c      ****     {
2535:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2536:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2537:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2538:../uvc.c      ****     		break;
2539:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2540:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2541:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2542:../uvc.c      ****     		break;
2543:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2544:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2545:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2546:../uvc.c      **** 			break;
2547:../uvc.c      **** 
2548:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2549:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2550:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2551:../uvc.c      **** 			break;
2552:../uvc.c      **** 
2553:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2554:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2555:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2556:../uvc.c      ****       		break;
2557:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2558:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2559:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2560:../uvc.c      ****      		break;
2561:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2562:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2563:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2564:../uvc.c      ****           		break;
2565:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2566:../uvc.c      ****           		break;
2567:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2568:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2569:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2570:../uvc.c      ****      		break;
2571:../uvc.c      **** 
2572:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2573:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2574:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2575:../uvc.c      ****     		break;
2576:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2577:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2578:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2579:../uvc.c      ****     		break;
2580:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2581:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2582:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2583:../uvc.c      ****     		break;
2584:../uvc.c      **** 
2585:../uvc.c      ****         default:
2586:../uvc.c      ****             /*
2587:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2588:../uvc.c      ****              * other controls.
2589:../uvc.c      ****              */
2590:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2591:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2592:../uvc.c      ****             break;
2593:../uvc.c      ****     }
2594:../uvc.c      **** 
2595:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2596:../uvc.c      ****     switch (wValue)
2597:../uvc.c      ****     {
2598:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2599:../uvc.c      ****             switch (bRequest)
2600:../uvc.c      ****             {
2601:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2602:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2603:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2604:../uvc.c      ****                     break;
2605:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2606:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2607:../uvc.c      ****                     sendData = CyTrue;
2608:../uvc.c      ****                     break;
2609:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2610:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2611:../uvc.c      ****                     sendData = CyTrue;
2612:../uvc.c      ****                     break;
2613:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2614:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2615:../uvc.c      ****                     sendData = CyTrue;
2616:../uvc.c      ****                     break;
2617:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2618:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2619:../uvc.c      ****                     sendData = CyTrue;
2620:../uvc.c      ****                     break;
2621:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2622:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2623:../uvc.c      ****                     sendData = CyTrue;
2624:../uvc.c      ****                     break;
2625:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2626:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2627:../uvc.c      ****                             glEp0Buffer, &readCount);
2628:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2629:../uvc.c      ****                     {
2630:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2631:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2632:../uvc.c      ****                     }
2633:../uvc.c      ****                     break;
2634:../uvc.c      ****                 default:
2635:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2636:../uvc.c      ****                     break;
2637:../uvc.c      ****             }
2638:../uvc.c      **** 
2639:../uvc.c      ****             if (sendData)
2640:../uvc.c      ****             {
2641:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2642:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2643:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2644:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2645:../uvc.c      ****             }
2646:../uvc.c      ****             break;
2647:../uvc.c      **** 
2648:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2649:../uvc.c      ****             switch (bRequest)
2650:../uvc.c      ****             {
2651:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2652:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2653:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2654:../uvc.c      ****                     break;
2655:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2656:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2657:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2658:../uvc.c      ****                     sendData = CyTrue;
2659:../uvc.c      ****                     break;
2660:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2661:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2662:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2663:../uvc.c      ****                     sendData = CyTrue;
2664:../uvc.c      ****                     break;
2665:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2666:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2667:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2668:../uvc.c      ****                     sendData = CyTrue;
2669:../uvc.c      ****                     break;
2670:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2671:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2672:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2673:../uvc.c      ****                     sendData = CyTrue;
2674:../uvc.c      ****                     break;
2675:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2676:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2677:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2678:../uvc.c      ****                     sendData = CyTrue;
2679:../uvc.c      ****                     break;
2680:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2681:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2682:../uvc.c      ****                             glEp0Buffer, &readCount);
2683:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2684:../uvc.c      ****                     {
2685:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2686:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2687:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2688:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2689:../uvc.c      **** 
2690:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2691:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2692:../uvc.c      ****                     }
2693:../uvc.c      ****                     break;
2694:../uvc.c      ****                 default:
2695:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2696:../uvc.c      ****                     break;
2697:../uvc.c      ****             }
2698:../uvc.c      **** 
2699:../uvc.c      ****             if (sendData)
2700:../uvc.c      ****             {
2701:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2702:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2703:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2704:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2705:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2706:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2707:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2708:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2709:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2710:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2711:../uvc.c      ****             }
2712:../uvc.c      ****             break;
2713:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2714:../uvc.c      ****         default:
2715:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2716:../uvc.c      ****             break;
2717:../uvc.c      ****     }
2718:../uvc.c      **** #endif
2719:../uvc.c      **** }
2720:../uvc.c      **** 
2721:../uvc.c      **** /*
2722:../uvc.c      ****  * Handler for UVC Interface control requests.
2723:../uvc.c      ****  */
2724:../uvc.c      **** static void
2725:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2726:../uvc.c      ****         void)
2727:../uvc.c      **** {
2728:../uvc.c      **** 
2729:../uvc.c      ****     switch (wValue)
2730:../uvc.c      ****     {
2731:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2732:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2733:../uvc.c      ****     		break;
2734:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2735:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2736:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2737:../uvc.c      ****     		break;
2738:../uvc.c      ****     	default:
2739:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2740:../uvc.c      ****      		break;
2741:../uvc.c      ****     }
2742:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2743:../uvc.c      **** 
2744:../uvc.c      **** }
2745:../uvc.c      **** 
2746:../uvc.c      **** /*
2747:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2748:../uvc.c      ****  */
2749:../uvc.c      **** static void
2750:../uvc.c      **** UVCHandleExtensionUnitRqts (
2751:../uvc.c      ****         void)
2752:../uvc.c      **** {
2753:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2754:../uvc.c      **** 
2755:../uvc.c      **** #ifdef DbgInfo
2756:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2757:../uvc.c      **** #endif
2758:../uvc.c      ****     switch (wValue)
2759:../uvc.c      ****     {
2760:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2761:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2762:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2763:../uvc.c      ****     		break;
2764:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2765:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2766:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2767:../uvc.c      ****     		break;
2768:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2769:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2770:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2771:../uvc.c      ****      		break;
2772:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2773:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2774:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2775:../uvc.c      ****     		break;
2776:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2777:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2778:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2779:../uvc.c      ****     		break;
2780:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2781:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2782:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2783:../uvc.c      ****      		break;
2784:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2785:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2786:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2787:../uvc.c      ****     		break;
2788:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2789:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2790:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2791:../uvc.c      ****     		break;
2792:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2793:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2794:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2795:../uvc.c      ****      		break;
2796:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2797:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2798:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2799:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2800:../uvc.c      ****     		}else/* no support for 1080p camera */
2801:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2802:../uvc.c      ****     		break;
2803:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2804:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2805:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2806:../uvc.c      ****     		break;
2807:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2808:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2809:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2810:../uvc.c      ****     		break;
2811:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2812:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2813:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2814:../uvc.c      ****     		//break;
2815:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2816:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2817:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2818:../uvc.c      ****     		break;
2819:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2820:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2821:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2822:../uvc.c      ****     		break;
2823:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2824:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2825:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2826:../uvc.c      ****     		break;
2827:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2828:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2829:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2830:../uvc.c      ****     		break;
2831:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2832:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2833:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2834:../uvc.c      ****     		break;
2835:../uvc.c      ****    	default:
2836:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2837:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2838:../uvc.c      ****     		break;
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      **** }
2842:../uvc.c      **** 
2843:../uvc.c      **** /*
2844:../uvc.c      ****  * Handler for the video streaming control requests.
2845:../uvc.c      ****  */
2846:../uvc.c      **** static void
2847:../uvc.c      **** UVCHandleVideoStreamingRqts (
2848:../uvc.c      ****         void)
2849:../uvc.c      **** {
2850:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2851:../uvc.c      ****     uint16_t readCount;
2852:../uvc.c      **** 
2853:../uvc.c      ****     switch (wValue)
2854:../uvc.c      ****     {
2855:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2856:../uvc.c      ****             switch (bRequest)
2857:../uvc.c      ****             {
2858:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2859:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2860:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2861:../uvc.c      ****                     break;
2862:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2863:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2864:../uvc.c      ****                     glEp0Buffer[1] = 0;
2865:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2866:../uvc.c      ****                     break;
2867:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2868:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2869:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2870:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2871:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2872:../uvc.c      ****                     {
2873:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
2874:../uvc.c      ****                     }
2875:../uvc.c      ****                     else
2876:../uvc.c      ****                     {
2877:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2878:../uvc.c      ****                     }
2879:../uvc.c      ****                     break;
2880:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2881:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2882:../uvc.c      ****                             glCommitCtrl, &readCount);
2883:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2884:../uvc.c      ****                     {
2885:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2886:../uvc.c      ****                         {
2887:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2888:../uvc.c      ****                                active data structure. */
2889:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
2890:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
2891:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
2892:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
2893:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
2894:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
2895:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
2896:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
2897:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
2898:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
2899:../uvc.c      **** 
2900:../uvc.c      **** 
2901:../uvc.c      ****                         }
2902:../uvc.c      ****                     }
2903:../uvc.c      ****                     break;
2904:../uvc.c      ****                 default:
2905:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2906:../uvc.c      ****                     break;
2907:../uvc.c      ****             }
2908:../uvc.c      ****             break;
2909:../uvc.c      **** 
2910:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2911:../uvc.c      ****             switch (bRequest)
2912:../uvc.c      ****             {
2913:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2914:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2915:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2916:../uvc.c      ****                     break;
2917:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2918:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2919:../uvc.c      ****                     glEp0Buffer[1] = 0;
2920:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2921:../uvc.c      ****                     break;
2922:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2923:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2924:../uvc.c      ****                     {
2925:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2926:../uvc.c      ****                     }
2927:../uvc.c      ****                     else
2928:../uvc.c      ****                     {
2929:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2930:../uvc.c      ****                     }
2931:../uvc.c      ****                     break;
2932:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2933:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2934:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2935:../uvc.c      ****                        */
2936:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2937:../uvc.c      ****                             glCommitCtrl, &readCount);
2938:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2939:../uvc.c      ****                     {
2940:../uvc.c      **** #if 0
2941:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2942:../uvc.c      ****                         {
2943:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2944:../uvc.c      ****                         }
2945:../uvc.c      ****                         else
2946:../uvc.c      ****                         {
2947:../uvc.c      ****                             SensorScaling_VGA ();
2948:../uvc.c      ****                         }
2949:../uvc.c      **** #endif
2950:../uvc.c      ****                         /* We can start streaming video now. */
2951:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2952:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2953:../uvc.c      ****                         {
2954:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2955:../uvc.c      ****                         }
2956:../uvc.c      ****                     }
2957:../uvc.c      ****                     break;
2958:../uvc.c      **** 
2959:../uvc.c      ****                 default:
2960:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2961:../uvc.c      ****                     break;
2962:../uvc.c      ****             }
2963:../uvc.c      ****             break;
2964:../uvc.c      **** 
2965:../uvc.c      **** /* still image streaming handler */
2966:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2967:../uvc.c      ****                 switch (bRequest)
2968:../uvc.c      ****                 {
2969:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2970:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2971:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2972:../uvc.c      ****                         break;
2973:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2974:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2975:../uvc.c      ****                         glEp0Buffer[1] = 0;
2976:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2977:../uvc.c      ****                         break;
2978:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2979:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2980:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2981:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2982:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2983:../uvc.c      ****                         {
2984:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2985:../uvc.c      ****                         }
2986:../uvc.c      ****                         else
2987:../uvc.c      ****                         {
2988:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2989:../uvc.c      ****                         }
2990:../uvc.c      ****                         break;
2991:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2992:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2993:../uvc.c      ****                                 glCommitCtrl, &readCount);
2994:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2995:../uvc.c      ****                         {
2996:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2997:../uvc.c      ****                             {
2998:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2999:../uvc.c      ****                                    active data structure. */
3000:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3001:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3002:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3003:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3004:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3005:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3006:../uvc.c      ****                             }
3007:../uvc.c      ****                         }
3008:../uvc.c      ****                         break;
3009:../uvc.c      ****                     default:
3010:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3011:../uvc.c      ****                         break;
3012:../uvc.c      ****                 }
3013:../uvc.c      ****                 break;
3014:../uvc.c      **** 
3015:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3016:../uvc.c      ****                 switch (bRequest)
3017:../uvc.c      ****                 {
3018:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3019:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3020:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3021:../uvc.c      ****                         break;
3022:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3023:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3024:../uvc.c      ****                         glEp0Buffer[1] = 0;
3025:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3026:../uvc.c      ****                         break;
3027:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3028:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3029:../uvc.c      ****                         {
3030:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3031:../uvc.c      ****                         }
3032:../uvc.c      ****                         else
3033:../uvc.c      ****                         {
3034:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3035:../uvc.c      ****                         }
3036:../uvc.c      ****                         break;
3037:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3038:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3039:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3040:../uvc.c      ****                            */
3041:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3042:../uvc.c      ****                                 glCommitCtrl, &readCount);
3043:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3044:../uvc.c      ****                         {
3045:../uvc.c      ****     #if 0
3046:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3047:../uvc.c      ****                             {
3048:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3049:../uvc.c      ****                             }
3050:../uvc.c      ****                             else
3051:../uvc.c      ****                             {
3052:../uvc.c      ****                                 SensorScaling_VGA ();
3053:../uvc.c      ****                             }
3054:../uvc.c      ****     #endif
3055:../uvc.c      ****                             /* We can start streaming video now. */
3056:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3057:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3058:../uvc.c      ****                             {
3059:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3060:../uvc.c      ****                             }
3061:../uvc.c      ****                         }
3062:../uvc.c      ****                         break;
3063:../uvc.c      **** 
3064:../uvc.c      ****                     default:
3065:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3066:../uvc.c      ****                         break;
3067:../uvc.c      ****                 }
3068:../uvc.c      ****                 break;
3069:../uvc.c      **** 
3070:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3071:../uvc.c      ****                 switch (bRequest)
3072:../uvc.c      ****                 {
3073:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3074:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3075:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3076:../uvc.c      ****                         break;
3077:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3078:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3079:../uvc.c      ****                         glEp0Buffer[1] = 0;
3080:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3081:../uvc.c      ****                         break;
3082:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3083:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3084:../uvc.c      ****                         {
3085:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3086:../uvc.c      ****                         }
3087:../uvc.c      ****                         else
3088:../uvc.c      ****                         {
3089:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3090:../uvc.c      ****                         }
3091:../uvc.c      ****                         break;
3092:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3093:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3094:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3095:../uvc.c      ****                            */
3096:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3097:../uvc.c      ****                                 glCommitCtrl, &readCount);
3098:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3099:../uvc.c      ****                         {
3100:../uvc.c      ****     #if 1
3101:../uvc.c      ****                             /* We can start still streaming video now. */
3102:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3103:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3104:../uvc.c      ****                             {
3105:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3106:../uvc.c      ****                             }
3107:../uvc.c      ****     #endif
3108:../uvc.c      ****                             stiflag = CyTrue;//set still flag
3109:../uvc.c      ****                             //stillcont = 0;
3110:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3111:../uvc.c      ****                         }else{
3112:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3113:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3114:../uvc.c      ****                         }
3115:../uvc.c      ****                         break;
3116:../uvc.c      **** 
3117:../uvc.c      ****                     default:
3118:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3119:../uvc.c      ****                         break;
3120:../uvc.c      ****                 }
3121:../uvc.c      ****                 break;
3122:../uvc.c      **** 
3123:../uvc.c      ****         default:
3124:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3125:../uvc.c      ****             break;
3126:../uvc.c      ****     }
3127:../uvc.c      **** }
3128:../uvc.c      **** 
3129:../uvc.c      **** /*
3130:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3131:../uvc.c      ****  */
3132:../uvc.c      **** void
3133:../uvc.c      **** UVCAppEP0Thread_Entry (
3134:../uvc.c      ****         uint32_t input)
3135:../uvc.c      **** {
3136:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3137:../uvc.c      ****     uint32_t eventFlag;
3138:../uvc.c      **** 	CyBool_t value;
3139:../uvc.c      **** 	CyBool_t *valueptr = &value;
3140:../uvc.c      **** 
3141:../uvc.c      **** 
3142:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3143:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3144:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3145:../uvc.c      **** 
3146:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3147:../uvc.c      **** #endif
3148:../uvc.c      **** 
3149:../uvc.c      ****     /* for interrupt status test */
3150:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3151:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3152:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3153:../uvc.c      **** 
3154:../uvc.c      ****     for (;;)
3155:../uvc.c      ****     {
3156:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3157:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3158:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3159:../uvc.c      ****         {
3160:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3161:../uvc.c      ****             if (!isUsbConnected)
3162:../uvc.c      ****             {
3163:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3164:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3165:../uvc.c      ****                 {
3166:../uvc.c      ****                     isUsbConnected = CyTrue;
3167:../uvc.c      ****                 }
3168:../uvc.c      ****             }
3169:../uvc.c      **** //#ifdef DbgInfo
3170:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3171:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3172:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3173:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3174:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3175:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3176:../uvc.c      **** //#endif
3177:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3178:../uvc.c      ****             {
3179:../uvc.c      ****             	switch ((wIndex >> 8))
3180:../uvc.c      ****                 {
3181:../uvc.c      **** 
3182:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3183:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3184:../uvc.c      ****                         break;
3185:../uvc.c      **** 
3186:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3187:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3188:../uvc.c      ****                         break;
3189:../uvc.c      **** 
3190:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3191:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3192:../uvc.c      ****                         break;
3193:../uvc.c      **** 
3194:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3195:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3196:../uvc.c      ****                         break;
3197:../uvc.c      **** 
3198:../uvc.c      ****                     default:
3199:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3200:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3201:../uvc.c      ****                         break;
3202:../uvc.c      ****                 }
3203:../uvc.c      ****             }
3204:../uvc.c      **** 
3205:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3206:../uvc.c      ****             {
3207:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3208:../uvc.c      **** 
3209:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3210:../uvc.c      ****                 {
3211:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3212:../uvc.c      ****                 }
3213:../uvc.c      ****                 else
3214:../uvc.c      ****                 {
3215:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3216:../uvc.c      ****                 }
3217:../uvc.c      ****             }
3218:../uvc.c      **** 
3219:../uvc.c      ****             /* handle interrupt status event */
3220:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3221:../uvc.c      ****             {
3222:../uvc.c      **** 
3223:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3224:../uvc.c      ****             	/** preparing interrupt status data **/
3225:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3226:../uvc.c      **** 
3227:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3228:../uvc.c      **** 
3229:../uvc.c      **** #if 1 //for real button
3230:../uvc.c      **** 				if(value&&(!snapButFlag)){
3231:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3232:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3233:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3234:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3235:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3236:../uvc.c      **** 
3237:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3238:../uvc.c      **** 					interStabuf.size   = 1024;
3239:../uvc.c      **** 					interStabuf.status = 0;
3240:../uvc.c      **** 
3241:../uvc.c      **** 					interStabuf.count = 4;
3242:../uvc.c      **** 
3243:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3244:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3245:../uvc.c      **** 
3246:../uvc.c      **** 					/** send a interrupt status data **/
3247:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3248:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3249:../uvc.c      **** 					{
3250:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3251:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3252:../uvc.c      **** 					}
3253:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3254:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3255:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3256:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3257:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3258:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3259:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3260:../uvc.c      **** 
3261:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3262:../uvc.c      **** 					interStabuf.size   = 1024;
3263:../uvc.c      **** 					interStabuf.status = 0;
3264:../uvc.c      **** 
3265:../uvc.c      **** 					interStabuf.count = 4;
3266:../uvc.c      **** 
3267:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3268:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3269:../uvc.c      **** 
3270:../uvc.c      **** 					/** send a interrupt status data **/
3271:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3272:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3273:../uvc.c      **** 					{
3274:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3275:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3276:../uvc.c      **** 					}
3277:../uvc.c      **** 
3278:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3279:../uvc.c      **** 					stiflag = CyTrue;
3280:../uvc.c      **** 				}
3281:../uvc.c      **** #else			//for botton simulation
3282:../uvc.c      **** 				if(snapButFlag == 0x0f){
3283:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3284:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3285:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3286:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3287:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3288:../uvc.c      **** 
3289:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3290:../uvc.c      **** 					interStabuf.size   = 1024;
3291:../uvc.c      **** 					interStabuf.status = 0;
3292:../uvc.c      **** 
3293:../uvc.c      **** 					interStabuf.count = 4;
3294:../uvc.c      **** 
3295:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3296:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3297:../uvc.c      **** 
3298:../uvc.c      **** 					/** send a interrupt status data **/
3299:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3300:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3301:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3302:../uvc.c      **** 					{
3303:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3304:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3305:../uvc.c      **** 					}
3306:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3307:../uvc.c      **** 
3308:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3309:../uvc.c      **** 				}else if(!snapButFlag){
3310:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3311:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3312:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3313:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3314:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3315:../uvc.c      **** 
3316:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3317:../uvc.c      **** 					interStabuf.size   = 1024;
3318:../uvc.c      **** 					interStabuf.status = 0;
3319:../uvc.c      **** 
3320:../uvc.c      **** 					interStabuf.count = 4;
3321:../uvc.c      **** 
3322:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3323:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3324:../uvc.c      **** 
3325:../uvc.c      **** 					/** send a interrupt status data **/
3326:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3327:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3328:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3329:../uvc.c      **** 					{
3330:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3331:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3332:../uvc.c      **** 					}
3333:../uvc.c      **** 
3334:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3335:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3336:../uvc.c      **** 				}
3337:../uvc.c      **** #endif
3338:../uvc.c      **** 
3339:../uvc.c      ****             }
3340:../uvc.c      **** 
3341:../uvc.c      **** 
3342:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3343:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3344:../uvc.c      ****             {
3345:../uvc.c      ****                 /* Get the command buffer */
3346:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3347:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3348:../uvc.c      ****                 {
3349:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3350:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3351:../uvc.c      ****                 }
3352:../uvc.c      **** 
3353:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3354:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3355:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3356:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3357:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3358:../uvc.c      ****                  * register value high byte and register value low byte.
3359:../uvc.c      ****                  */
3360:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3361:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3362:../uvc.c      ****                 {
3363:../uvc.c      ****                     if (dmaInfo.count == 3)
3364:../uvc.c      ****                     {
3365:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3366:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3367:../uvc.c      ****                         dmaInfo.count = 3;
3368:../uvc.c      ****                     }
3369:../uvc.c      ****                     else if (dmaInfo.count == 4)
3370:../uvc.c      ****                     {
3371:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3372:../uvc.c      ****                         {
3373:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3374:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3375:../uvc.c      ****                         }
3376:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3377:../uvc.c      ****                     }
3378:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3379:../uvc.c      ****                 }
3380:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3381:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3382:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3383:../uvc.c      ****                  */
3384:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3385:../uvc.c      ****                 {
3386:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3387:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3388:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3389:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3390:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3391:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3392:../uvc.c      ****                         	break;
3393:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3394:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3395:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3396:../uvc.c      ****                         	break;*/
3397:../uvc.c      ****                     dmaInfo.count -= 2;
3398:../uvc.c      ****                 }
3399:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3400:../uvc.c      ****                 else
3401:../uvc.c      ****                 {
3402:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3403:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3404:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3405:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3406:../uvc.c      ****                 }
3407:../uvc.c      **** 
3408:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3409:../uvc.c      ****                 dmaInfo.size   = 1024;
3410:../uvc.c      ****                 dmaInfo.status = 0;
3411:../uvc.c      **** 
3412:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3413:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3414:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3415:../uvc.c      ****                 {
3416:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3417:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3418:../uvc.c      ****                 }
3419:../uvc.c      **** 
3420:../uvc.c      ****                 /* Wait until the response has gone out. */
3421:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3422:../uvc.c      **** 
3423:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3424:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3425:../uvc.c      ****                 {
3426:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3427:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3428:../uvc.c      ****                 }
3429:../uvc.c      ****             }
3430:../uvc.c      **** #endif
3431:../uvc.c      ****         }
3432:../uvc.c      ****         /* Allow other ready threads to run. */
3433:../uvc.c      ****         CyU3PThreadRelinquish ();
3434:../uvc.c      ****     }
3435:../uvc.c      **** }
3436:../uvc.c      **** 
3437:../uvc.c      **** /*
3438:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3439:../uvc.c      ****  * added 10/2013
3440:../uvc.c      ****  */
3441:../uvc.c      **** /*
3442:../uvc.c      **** static uint8_t timeDelay[64] = {
3443:../uvc.c      **** 
3444:../uvc.c      **** };
3445:../uvc.c      **** */
3446:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3446 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3447:../uvc.c      **** 
3448:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3449:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3450:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3451:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3452:../uvc.c      **** 	VdstateDes *lcStaDes;
3453:../uvc.c      **** 	uint32_t flag = 0;
3454:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3455:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3456:../uvc.c      **** 	uint8_t i;
3457:../uvc.c      **** 	uint16_t delaytime;
3458:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3459:../uvc.c      **** 
3460:../uvc.c      **** #if 0 //for test the command queue
3461:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3462:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3463:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3464:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3465:../uvc.c      **** 		lcCmdDes += 1;
3466:../uvc.c      **** 	}
3467:../uvc.c      **** #endif
3468:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3469:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3469 0
  36 0004 10229FE5 		ldr	r2, .L22
3453:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3453 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3446:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3446 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3469 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3453:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3453 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3469 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3470:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3470 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3471:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3471 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3472:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3472 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3473:../uvc.c      **** 
3474:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3474 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3475:../uvc.c      ****         /* Allow other ready threads to run. */
3476:../uvc.c      **** 
3477:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3477 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3474:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3474 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3478:../uvc.c      **** 	}
3479:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3479 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3480:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3481:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3482:../uvc.c      **** 	//CyU3PThreadSleep(100);
3483:../uvc.c      **** 	//SetCurCmd();
3484:../uvc.c      **** 	/*********** the loop of the thread ***********/
3485:../uvc.c      **** 	for(;;){
3486:../uvc.c      **** 
3487:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3487 0
 101 0098 0060E0E3 		mvn	r6, #0
3488:../uvc.c      **** /*  // for test GPIO output
3489:../uvc.c      **** 		if(trigger)
3490:../uvc.c      **** 		{
3491:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3492:../uvc.c      **** 			{
3493:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3494:../uvc.c      **** 			}
3495:../uvc.c      **** 
3496:../uvc.c      **** 		}else{
3497:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3498:../uvc.c      **** 			{
3499:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3500:../uvc.c      **** 			}
3501:../uvc.c      **** 
3502:../uvc.c      **** 		}
3503:../uvc.c      **** */
3504:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3505:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3506:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3507:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3508:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3509:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3510:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3511:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3512:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3513:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3514:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3515:../uvc.c      **** #endif
3516:../uvc.c      **** 				}
3517:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3518:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3519:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3520:../uvc.c      **** 			}
3521:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3522:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3523:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3524:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3525:../uvc.c      **** 
3526:../uvc.c      **** 				/*
3527:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3528:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3529:../uvc.c      **** 				*/
3530:../uvc.c      **** 
3531:../uvc.c      **** 				/* find a available command */
3532:../uvc.c      **** 				i = 0;
3533:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3533 0
 103 009c 0090A0E3 		mov	r9, #0
3534:../uvc.c      **** 					i++;
3535:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3536:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3537:../uvc.c      **** 				}
3538:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3539:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3540:../uvc.c      **** 					i = lcCmdDes->curNum;
3541:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3542:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3543:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3544:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3545:../uvc.c      **** #if 1
3546:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3547:../uvc.c      **** 						case 20:
3548:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3549:../uvc.c      **** 							delaytime = 500;
3550:../uvc.c      **** 							break;
3551:../uvc.c      **** 						case 21:
3552:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3553:../uvc.c      **** 							delaytime = 500;
3554:../uvc.c      **** 							break;
3555:../uvc.c      **** 						case 22:
3556:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3557:../uvc.c      **** 							delaytime = 300;
3558:../uvc.c      **** 							break;
3559:../uvc.c      **** 						case 23:
3560:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3561:../uvc.c      **** 							delaytime = 300;
3562:../uvc.c      **** 							break;
3563:../uvc.c      **** 						default:
3564:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3565:../uvc.c      **** 							break;
3566:../uvc.c      **** 					}
3567:../uvc.c      **** #endif
3568:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3569:../uvc.c      **** 					/** timer's ticket modify **/
3570:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3571:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3572:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3573:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3574:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3575:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3576:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3577:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3578:../uvc.c      **** #endif
3579:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3580:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3581:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3582:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3583:../uvc.c      **** 						}else{
3584:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3585:../uvc.c      **** 						}
3586:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3587:../uvc.c      **** 					}else{
3588:../uvc.c      **** 						lcCmdDes->curNum ++;
3589:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3589 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3487:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3487 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3504:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3504 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3521:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3521 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3523:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3523 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3524:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3524 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3533:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3533 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3535:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3535 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3534:../uvc.c      **** 					i++;
 140              		.loc 1 3534 0
 141 00f4 011083E2 		add	r1, r3, #1
3533:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3533 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3534:../uvc.c      **** 					i++;
 144              		.loc 1 3534 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3533:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3533 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3539:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3539 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3541:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3541 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3546:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3546 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3541:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3541 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3546:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3546 0
 166 0128 14C042E2 		sub	ip, r2, #20
3541:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3541 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3542:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3542 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3543:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3543 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3544:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3544 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3546:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3546 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3560:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3560 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3562:../uvc.c      **** 							break;
 193              		.loc 1 3562 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3571:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3571 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3572:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3572 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3579:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3579 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3588:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3588 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3589 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3579:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3579 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3590:../uvc.c      **** 					}
3591:../uvc.c      **** 				}else{
3592:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3593:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3594:../uvc.c      **** 				}
3595:../uvc.c      **** 			}
3596:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3596 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3597:../uvc.c      **** /*
3598:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3599:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3600:../uvc.c      **** */
3601:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3602:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3603:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3604:../uvc.c      **** #endif
3605:../uvc.c      **** 
3606:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3607:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3608:../uvc.c      **** #if 0
3609:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3610:../uvc.c      **** 
3611:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3612:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3613:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3614:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3615:../uvc.c      **** 			    i = 0;
3616:../uvc.c      **** 				 switch(cmdCopyIdx)
3617:../uvc.c      **** 				 {
3618:../uvc.c      **** 					 case BrgtCtlID1:
3619:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3620:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3621:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3622:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3623:../uvc.c      **** 							 i++;
3624:../uvc.c      **** 						 }
3625:../uvc.c      **** 						 else{
3626:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3627:../uvc.c      **** 						 }
3628:../uvc.c      **** 
3629:../uvc.c      **** 						 CyU3PBusyWait(500);
3630:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3631:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3632:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3633:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3634:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3635:../uvc.c      **** 						 }
3636:../uvc.c      **** 						 else{
3637:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3638:../uvc.c      **** 						 }
3639:../uvc.c      **** 						 break;
3640:../uvc.c      **** 					 case HueCtlID5:
3641:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3642:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3643:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3644:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3645:../uvc.c      **** 						 }
3646:../uvc.c      **** 						 else{
3647:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3648:../uvc.c      **** 						 }
3649:../uvc.c      **** 						 break;
3650:../uvc.c      **** 					 case SaturCtlID6:
3651:../uvc.c      **** 					 case WBTLevCtlID10:
3652:../uvc.c      **** 					 default:
3653:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3654:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3655:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3656:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3657:../uvc.c      **** 						 }
3658:../uvc.c      **** 						 else{
3659:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3660:../uvc.c      **** 						 }
3661:../uvc.c      **** 						 break;
3662:../uvc.c      **** 				 }
3663:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3664:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3665:../uvc.c      **** 			}
3666:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3667:../uvc.c      **** #endif
3668:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3669:../uvc.c      **** 		/* Allow other ready threads to run. */
3670:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3671:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3671 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3672:../uvc.c      **** 		}
 224              		.loc 1 3672 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3552:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3552 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3554:../uvc.c      **** 							break;
 232              		.loc 1 3554 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3564:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3564 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3565:../uvc.c      **** 							break;
 241              		.loc 1 3565 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3548:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3548 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3550:../uvc.c      **** 							break;
 249              		.loc 1 3550 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3592:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3592 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3593:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3593 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3581:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3581 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3580:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3580 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3581:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3581 0
 269 01f0 1F005CE3 		cmp	ip, #31
3582:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3582 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3584:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3584 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3582:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3582 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3584:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3584 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3582:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3582 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3584:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3584 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3586:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3586 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2193:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2193 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2195:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2195 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2196:../uvc.c      **** }
 318              		.loc 1 2196 0
2195:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2195 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 329              		.global	CyFxUvcApplnDmaCallback
 331              	CyFxUvcApplnDmaCallback:
 332              	.LFB10:
1472:../uvc.c      **** {
 333              		.loc 1 1472 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL31:
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 338              		.loc 1 1479 0
 339 0250 080051E3 		cmp	r1, #8
1472:../uvc.c      **** {
 340              		.loc 1 1472 0
 341 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 12
 344 0258 0240A0E1 		mov	r4, r2
 345              		.cfi_offset 14, -4
 346              		.cfi_offset 5, -8
 347              		.cfi_offset 4, -12
 348 025c 0CD04DE2 		sub	sp, sp, #12
 349              	.LCFI3:
 350              		.cfi_def_cfa_offset 24
1479:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 351              		.loc 1 1479 0
 352 0260 0B00000A 		beq	.L32
1511:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 353              		.loc 1 1511 0
 354 0264 100051E3 		cmp	r1, #16
 355 0268 0700001A 		bne	.L27
1513:../uvc.c      ****         consCount++;
 356              		.loc 1 1513 0
 357 026c 0C319FE5 		ldr	r3, .L34
1514:../uvc.c      ****         streamingStarted = CyTrue;
 358              		.loc 1 1514 0
 359 0270 0110A0E3 		mov	r1, #1
 360              	.LVL32:
1513:../uvc.c      ****         consCount++;
 361              		.loc 1 1513 0
 362 0274 B603D3E1 		ldrh	r0, [r3, #54]
 363              	.LVL33:
1514:../uvc.c      ****         streamingStarted = CyTrue;
 364              		.loc 1 1514 0
 365 0278 381083E5 		str	r1, [r3, #56]
1513:../uvc.c      ****         consCount++;
 366              		.loc 1 1513 0
 367 027c 01C080E0 		add	ip, r0, r1
 368 0280 0C28A0E1 		mov	r2, ip, asl #16
 369              	.LVL34:
 370 0284 2218A0E1 		mov	r1, r2, lsr #16
 371 0288 B613C3E1 		strh	r1, [r3, #54]	@ movhi
 372              	.L27:
1516:../uvc.c      **** }
 373              		.loc 1 1516 0
 374 028c 0CD08DE2 		add	sp, sp, #12
 375 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 376              	.LVL35:
 377              	.L32:
1481:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 378              		.loc 1 1481 0
 379 0294 B420D2E1 		ldrh	r2, [r2, #4]
 380 0298 E4309FE5 		ldr	r3, .L34+4
 381 029c 030052E1 		cmp	r2, r3
 382 02a0 2B00000A 		beq	.L33
1489:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 383              		.loc 1 1489 0
 384 02a4 005094E5 		ldr	r5, [r4, #0]
 385              	.LVL36:
 386              	.LBB14:
 387              	.LBB15:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 388              		.loc 1 1221 0
 389 02a8 D8109FE5 		ldr	r1, .L34+8
 390              	.LVL37:
 391 02ac 0C0045E2 		sub	r0, r5, #12
 392              	.LVL38:
 393 02b0 0C20A0E3 		mov	r2, #12
 394 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 395              	.LVL39:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 396              		.loc 1 1226 0
 397 02b8 0B2055E5 		ldrb	r2, [r5, #-11]	@ zero_extendqisi2
 398              	.LBE15:
 399              	.LBE14:
1490:../uvc.c      ****                 pb++;
 400              		.loc 1 1490 0
 401 02bc BC309FE5 		ldr	r3, .L34
 402              	.LBB17:
 403              	.LBB16:
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 404              		.loc 1 1226 0
 405 02c0 021082E3 		orr	r1, r2, #2
 406 02c4 0B1045E5 		strb	r1, [r5, #-11]
 407              	.LBE16:
 408              	.LBE17:
1490:../uvc.c      ****                 pb++;
 409              		.loc 1 1490 0
 410 02c8 BAC2D3E1 		ldrh	ip, [r3, #42]
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
 411              		.loc 1 1491 0
 412 02cc B410D4E1 		ldrh	r1, [r4, #4]
1490:../uvc.c      ****                 pb++;
 413              		.loc 1 1490 0
 414 02d0 01008CE2 		add	r0, ip, #1
1495:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 415              		.loc 1 1495 0
 416 02d4 0120A0E3 		mov	r2, #1
1490:../uvc.c      ****                 pb++;
 417              		.loc 1 1490 0
 418 02d8 BA02C3E1 		strh	r0, [r3, #42]	@ movhi
1491:../uvc.c      ****                 pbc = input->buffer_p.count;
 419              		.loc 1 1491 0
 420 02dc BC12C3E1 		strh	r1, [r3, #44]	@ movhi
1495:../uvc.c      ****                hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been co
 421              		.loc 1 1495 0
 422 02e0 302083E5 		str	r2, [r3, #48]
 423              	.LVL40:
 424              	.L30:
1499:../uvc.c      ****             prodCount++;
 425              		.loc 1 1499 0
 426 02e4 B4E3D3E1 		ldrh	lr, [r3, #52]
1500:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 427              		.loc 1 1500 0
 428 02e8 0C2081E2 		add	r2, r1, #12
1499:../uvc.c      ****             prodCount++;
 429              		.loc 1 1499 0
 430 02ec 01C08EE2 		add	ip, lr, #1
 431 02f0 0C08A0E1 		mov	r0, ip, asl #16
 432 02f4 20E8A0E1 		mov	lr, r0, lsr #16
1500:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 433              		.loc 1 1500 0
 434 02f8 0218A0E1 		mov	r1, r2, asl #16
 435 02fc 2118A0E1 		mov	r1, r1, lsr #16
 436 0300 0020A0E3 		mov	r2, #0
 437 0304 80009FE5 		ldr	r0, .L34+12
1499:../uvc.c      ****             prodCount++;
 438              		.loc 1 1499 0
 439 0308 B4E3C3E1 		strh	lr, [r3, #52]	@ movhi
1500:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 440              		.loc 1 1500 0
 441 030c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 442              	.LVL41:
1499:../uvc.c      ****             prodCount++;
 443              		.loc 1 1499 0
 444 0310 68109FE5 		ldr	r1, .L34
1503:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 445              		.loc 1 1503 0
 446 0314 002050E2 		subs	r2, r0, #0
 447 0318 DBFFFF0A 		beq	.L27
1505:../uvc.c      ****                 prodCount--;
 448              		.loc 1 1505 0
 449 031c B403D1E1 		ldrh	r0, [r1, #52]
 450              	.LVL42:
1506:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 451              		.loc 1 1506 0
 452 0320 B430D4E1 		ldrh	r3, [r4, #4]
1505:../uvc.c      ****                 prodCount--;
 453              		.loc 1 1505 0
 454 0324 01E040E2 		sub	lr, r0, #1
 455 0328 0EC8A0E1 		mov	ip, lr, asl #16
 456 032c 2C08A0E1 		mov	r0, ip, lsr #16
 457 0330 B403C1E1 		strh	r0, [r1, #52]	@ movhi
1506:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 458              		.loc 1 1506 0
 459 0334 B4E3D1E1 		ldrh	lr, [r1, #52]
 460 0338 B6C3D1E1 		ldrh	ip, [r1, #54]
 461 033c 0400A0E3 		mov	r0, #4
 462 0340 48109FE5 		ldr	r1, .L34+16
 463 0344 00E08DE5 		str	lr, [sp, #0]
 464 0348 04C08DE5 		str	ip, [sp, #4]
 465 034c FEFFFFEB 		bl	CyU3PDebugPrint
 466              	.LVL43:
 467 0350 CDFFFFEA 		b	.L27
 468              	.LVL44:
 469              	.L33:
1483:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 470              		.loc 1 1483 0
 471 0354 00E094E5 		ldr	lr, [r4, #0]
 472              	.LBB18:
 473              	.LBB19:
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 474              		.loc 1 1221 0
 475 0358 28109FE5 		ldr	r1, .L34+8
 476              	.LVL45:
 477 035c 0C004EE2 		sub	r0, lr, #12
 478              	.LVL46:
 479 0360 0C20A0E3 		mov	r2, #12
 480 0364 FEFFFFEB 		bl	CyU3PMemCopy
 481              	.LVL47:
 482              	.LBE19:
 483              	.LBE18:
1484:../uvc.c      ****                 fb++;
 484              		.loc 1 1484 0
 485 0368 10309FE5 		ldr	r3, .L34
 486 036c B410D4E1 		ldrh	r1, [r4, #4]
 487 0370 B8C2D3E1 		ldrh	ip, [r3, #40]
 488 0374 01008CE2 		add	r0, ip, #1
 489 0378 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 490 037c D8FFFFEA 		b	.L30
 491              	.L35:
 492              		.align	2
 493              	.L34:
 494 0380 00000000 		.word	.LANCHOR0
 495 0384 F03F0000 		.word	16368
 496 0388 80040000 		.word	.LANCHOR1+1152
 497 038c 00000000 		.word	glChHandleUVCStream
 498 0390 38000000 		.word	.LC2
 499              		.cfi_endproc
 500              	.LFE10:
 502              		.align	2
 504              	CyFxUVCApplnUSBEventCB:
 505              	.LFB8:
1275:../uvc.c      **** {
 506              		.loc 1 1275 0
 507              		.cfi_startproc
 508              		@ args = 0, pretend = 0, frame = 8
 509              		@ frame_needed = 0, uses_anonymous_args = 0
 510              	.LVL48:
1276:../uvc.c      ****     switch (evtype)
 511              		.loc 1 1276 0
 512 0394 020050E3 		cmp	r0, #2
1275:../uvc.c      **** {
 513              		.loc 1 1275 0
 514 0398 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 515              	.LCFI4:
 516              		.cfi_def_cfa_offset 16
 517 039c 0130A0E1 		mov	r3, r1
 518 03a0 10D04DE2 		sub	sp, sp, #16
 519              	.LCFI5:
 520              		.cfi_def_cfa_offset 32
1275:../uvc.c      **** {
 521              		.loc 1 1275 0
 522 03a4 0040A0E1 		mov	r4, r0
 523              		.cfi_offset 14, -4
 524              		.cfi_offset 6, -8
 525              		.cfi_offset 5, -12
 526              		.cfi_offset 4, -16
1276:../uvc.c      ****     switch (evtype)
 527              		.loc 1 1276 0
 528 03a8 3600000A 		beq	.L39
 529 03ac 040050E3 		cmp	r0, #4
 530 03b0 1F00000A 		beq	.L40
 531 03b4 010050E3 		cmp	r0, #1
 532 03b8 0100000A 		beq	.L42
 533              	.LVL49:
 534              	.L36:
1312:../uvc.c      **** }
 535              		.loc 1 1312 0
 536 03bc 10D08DE2 		add	sp, sp, #16
 537 03c0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 538              	.LVL50:
 539              	.L42:
1297:../uvc.c      ****             gpif_initialized = 0;
 540              		.loc 1 1297 0
 541 03c4 28519FE5 		ldr	r5, .L43
1295:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 542              		.loc 1 1295 0
 543 03c8 0020A0E1 		mov	r2, r0
 544 03cc 24119FE5 		ldr	r1, .L43+4
 545              	.LVL51:
 546 03d0 0400A0E3 		mov	r0, #4
 547              	.LVL52:
 548 03d4 FEFFFFEB 		bl	CyU3PDebugPrint
1296:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 549              		.loc 1 1296 0
 550 03d8 0400A0E1 		mov	r0, r4
 551 03dc FEFFFFEB 		bl	CyU3PGpifDisable
1297:../uvc.c      ****             gpif_initialized = 0;
 552              		.loc 1 1297 0
 553 03e0 00C0A0E3 		mov	ip, #0
 554              	.LBB26:
 555              	.LBB27:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 556              		.loc 1 1259 0
 557 03e4 0410A0E1 		mov	r1, r4
 558 03e8 0500A0E1 		mov	r0, r5
 559 03ec 0220A0E3 		mov	r2, #2
 560 03f0 0C308DE2 		add	r3, sp, #12
 561              	.LBE27:
 562              	.LBE26:
1297:../uvc.c      ****             gpif_initialized = 0;
 563              		.loc 1 1297 0
 564 03f4 3CC085E5 		str	ip, [r5, #60]
1298:../uvc.c      ****             isUsbConnected = CyFalse;
 565              		.loc 1 1298 0
 566 03f8 40C085E5 		str	ip, [r5, #64]
1299:../uvc.c      ****             streamingStarted = CyFalse;
 567              		.loc 1 1299 0
 568 03fc 38C085E5 		str	ip, [r5, #56]
 569              	.LBB29:
 570              	.LBB28:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 571              		.loc 1 1259 0
 572 0400 00C08DE5 		str	ip, [sp, #0]
 573 0404 FEFFFFEB 		bl	_txe_event_flags_get
 574 0408 004050E2 		subs	r4, r0, #0
 575 040c EAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 576              		.loc 1 1262 0
 577 0410 0110E0E3 		mvn	r1, #1
 578 0414 0220A0E3 		mov	r2, #2
 579 0418 0500A0E1 		mov	r0, r5
 580              	.L41:
 581 041c FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 582              		.loc 1 1265 0
 583 0420 0500A0E1 		mov	r0, r5
 584 0424 0210A0E3 		mov	r1, #2
 585 0428 0420A0E1 		mov	r2, r4
 586 042c FEFFFFEB 		bl	_txe_event_flags_set
 587 0430 E1FFFFEA 		b	.L36
 588              	.LVL53:
 589              	.L40:
 590              	.LBE28:
 591              	.LBE29:
1281:../uvc.c      ****             gpif_initialized = 0;
 592              		.loc 1 1281 0
 593 0434 B8509FE5 		ldr	r5, .L43
1279:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 594              		.loc 1 1279 0
 595 0438 BC109FE5 		ldr	r1, .L43+8
 596              	.LVL54:
 597 043c 0020A0E1 		mov	r2, r0
 598 0440 FEFFFFEB 		bl	CyU3PDebugPrint
 599              	.LVL55:
1280:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 600              		.loc 1 1280 0
 601 0444 0100A0E3 		mov	r0, #1
 602 0448 FEFFFFEB 		bl	CyU3PGpifDisable
1281:../uvc.c      ****             gpif_initialized = 0;
 603              		.loc 1 1281 0
 604 044c 00C0A0E3 		mov	ip, #0
 605              	.LBB30:
 606              	.LBB31:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 607              		.loc 1 1259 0
 608 0450 0110A0E3 		mov	r1, #1
 609 0454 0220A0E3 		mov	r2, #2
 610 0458 0500A0E1 		mov	r0, r5
 611 045c 0C308DE2 		add	r3, sp, #12
 612              	.LBE31:
 613              	.LBE30:
1281:../uvc.c      ****             gpif_initialized = 0;
 614              		.loc 1 1281 0
 615 0460 3CC085E5 		str	ip, [r5, #60]
1282:../uvc.c      ****             streamingStarted = CyFalse;
 616              		.loc 1 1282 0
 617 0464 38C085E5 		str	ip, [r5, #56]
 618              	.LBB33:
 619              	.LBB32:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 620              		.loc 1 1259 0
 621 0468 00C08DE5 		str	ip, [sp, #0]
 622 046c FEFFFFEB 		bl	_txe_event_flags_get
 623 0470 004050E2 		subs	r4, r0, #0
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 624              		.loc 1 1262 0
 625 0474 0500A001 		moveq	r0, r5
 626 0478 0110E003 		mvneq	r1, #1
 627 047c 0220A003 		moveq	r2, #2
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 628              		.loc 1 1259 0
 629 0480 CDFFFF1A 		bne	.L36
 630 0484 E4FFFFEA 		b	.L41
 631              	.LVL56:
 632              	.L39:
 633              	.LBE32:
 634              	.LBE33:
1289:../uvc.c      ****             gpif_initialized = 0;
 635              		.loc 1 1289 0
 636 0488 64509FE5 		ldr	r5, .L43
1287:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 637              		.loc 1 1287 0
 638 048c 0020A0E1 		mov	r2, r0
 639 0490 68109FE5 		ldr	r1, .L43+12
 640              	.LVL57:
 641 0494 0400A0E3 		mov	r0, #4
 642              	.LVL58:
 643 0498 FEFFFFEB 		bl	CyU3PDebugPrint
1288:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 644              		.loc 1 1288 0
 645 049c 0100A0E3 		mov	r0, #1
 646 04a0 FEFFFFEB 		bl	CyU3PGpifDisable
1289:../uvc.c      ****             gpif_initialized = 0;
 647              		.loc 1 1289 0
 648 04a4 0060A0E3 		mov	r6, #0
 649              	.LBB34:
 650              	.LBB35:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 651              		.loc 1 1259 0
 652 04a8 0500A0E1 		mov	r0, r5
 653 04ac 0110A0E3 		mov	r1, #1
 654 04b0 0420A0E1 		mov	r2, r4
 655 04b4 0C308DE2 		add	r3, sp, #12
 656              	.LBE35:
 657              	.LBE34:
1289:../uvc.c      ****             gpif_initialized = 0;
 658              		.loc 1 1289 0
 659 04b8 3C6085E5 		str	r6, [r5, #60]
1290:../uvc.c      ****             streamingStarted = CyFalse;
 660              		.loc 1 1290 0
 661 04bc 386085E5 		str	r6, [r5, #56]
 662              	.LBB37:
 663              	.LBB36:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 664              		.loc 1 1259 0
 665 04c0 00608DE5 		str	r6, [sp, #0]
 666 04c4 FEFFFFEB 		bl	_txe_event_flags_get
 667 04c8 006050E2 		subs	r6, r0, #0
 668 04cc BAFFFF1A 		bne	.L36
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 669              		.loc 1 1262 0
 670 04d0 0420A0E1 		mov	r2, r4
 671 04d4 0500A0E1 		mov	r0, r5
 672 04d8 0110E0E3 		mvn	r1, #1
 673 04dc FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 674              		.loc 1 1265 0
 675 04e0 0500A0E1 		mov	r0, r5
 676 04e4 0410A0E1 		mov	r1, r4
 677 04e8 0620A0E1 		mov	r2, r6
 678 04ec FEFFFFEB 		bl	_txe_event_flags_set
 679 04f0 B1FFFFEA 		b	.L36
 680              	.L44:
 681              		.align	2
 682              	.L43:
 683 04f4 00000000 		.word	.LANCHOR0
 684 04f8 C8000000 		.word	.LC5
 685 04fc 84000000 		.word	.LC3
 686 0500 A4000000 		.word	.LC4
 687              	.LBE36:
 688              	.LBE37:
 689              		.cfi_endproc
 690              	.LFE8:
 692              		.align	2
 694              	CyFxUVCApplnUSBSetupCB:
 695              	.LFB9:
1320:../uvc.c      **** {
 696              		.loc 1 1320 0
 697              		.cfi_startproc
 698              		@ args = 0, pretend = 0, frame = 8
 699              		@ frame_needed = 0, uses_anonymous_args = 0
 700              	.LVL59:
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 701              		.loc 1 1325 0
 702 0504 C0329FE5 		ldr	r3, .L70
1320:../uvc.c      **** {
 703              		.loc 1 1320 0
 704 0508 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 705              	.LCFI6:
 706              		.cfi_def_cfa_offset 24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 707              		.loc 1 1326 0
 708 050c BCC29FE5 		ldr	ip, .L70+4
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 709              		.loc 1 1325 0
 710 0510 FF4000E2 		and	r4, r0, #255
 711              		.cfi_offset 14, -4
 712              		.cfi_offset 8, -8
 713              		.cfi_offset 7, -12
 714              		.cfi_offset 6, -16
 715              		.cfi_offset 5, -20
 716              		.cfi_offset 4, -24
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 717              		.loc 1 1326 0
 718 0514 FF8C00E2 		and	r8, r0, #65280
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 719              		.loc 1 1327 0
 720 0518 2078A0E1 		mov	r7, r0, lsr #16
1325:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 721              		.loc 1 1325 0
 722 051c 0040C3E5 		strb	r4, [r3, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 723              		.loc 1 1327 0
 724 0520 AC229FE5 		ldr	r2, .L70+8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 725              		.loc 1 1328 0
 726 0524 AC029FE5 		ldr	r0, .L70+12
 727              	.LVL60:
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 728              		.loc 1 1329 0
 729 0528 AC329FE5 		ldr	r3, .L70+16
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 730              		.loc 1 1328 0
 731 052c 0158A0E1 		mov	r5, r1, asl #16
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 732              		.loc 1 1326 0
 733 0530 2884A0E1 		mov	r8, r8, lsr #8
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 734              		.loc 1 1328 0
 735 0534 2558A0E1 		mov	r5, r5, lsr #16
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 736              		.loc 1 1329 0
 737 0538 2118A0E1 		mov	r1, r1, lsr #16
 738              	.LVL61:
1332:../uvc.c      ****     switch (bmReqType)
 739              		.loc 1 1332 0
 740 053c 020054E3 		cmp	r4, #2
1320:../uvc.c      **** {
 741              		.loc 1 1320 0
 742 0540 10D04DE2 		sub	sp, sp, #16
 743              	.LCFI7:
 744              		.cfi_def_cfa_offset 40
1326:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 745              		.loc 1 1326 0
 746 0544 0080CCE5 		strb	r8, [ip, #0]
1327:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 747              		.loc 1 1327 0
 748 0548 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1328:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 749              		.loc 1 1328 0
 750 054c B050C0E1 		strh	r5, [r0, #0]	@ movhi
1329:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 751              		.loc 1 1329 0
 752 0550 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1332:../uvc.c      ****     switch (bmReqType)
 753              		.loc 1 1332 0
 754 0554 4F00000A 		beq	.L48
 755 0558 0600009A 		bls	.L66
 756 055c 210054E3 		cmp	r4, #33
 757 0560 3A00000A 		beq	.L49
 758 0564 A10054E3 		cmp	r4, #161
 759 0568 3800000A 		beq	.L49
 760              	.L63:
1321:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 761              		.loc 1 1321 0
 762 056c 0000A0E3 		mov	r0, #0
 763              	.LVL62:
 764              	.L46:
1459:../uvc.c      **** }
 765              		.loc 1 1459 0
 766 0570 10D08DE2 		add	sp, sp, #16
 767 0574 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 768              	.LVL63:
 769              	.L66:
1332:../uvc.c      ****     switch (bmReqType)
 770              		.loc 1 1332 0
 771 0578 010054E3 		cmp	r4, #1
 772 057c FAFFFF1A 		bne	.L63
1372:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 773              		.loc 1 1372 0
 774 0580 0B0058E3 		cmp	r8, #11
 775 0584 F8FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 776              		.loc 1 1376 0
 777 0588 010055E3 		cmp	r5, #1
 778 058c F6FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 779              		.loc 1 1376 0 is_stmt 0 discriminator 1
 780 0590 000057E3 		cmp	r7, #0
 781 0594 F4FFFF1A 		bne	.L63
1381:../uvc.c      ****                     gpif_initialized = 0;
 782              		.loc 1 1381 0 is_stmt 1
 783 0598 40429FE5 		ldr	r4, .L70+20
1379:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 784              		.loc 1 1379 0
 785 059c 40129FE5 		ldr	r1, .L70+24
 786 05a0 0400A0E3 		mov	r0, #4
 787 05a4 FEFFFFEB 		bl	CyU3PDebugPrint
1380:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 788              		.loc 1 1380 0
 789 05a8 0500A0E1 		mov	r0, r5
 790 05ac FEFFFFEB 		bl	CyU3PGpifDisable
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 791              		.loc 1 1384 0
 792 05b0 0510A0E1 		mov	r1, r5
 793 05b4 8300A0E3 		mov	r0, #131
1381:../uvc.c      ****                     gpif_initialized = 0;
 794              		.loc 1 1381 0
 795 05b8 3C7084E5 		str	r7, [r4, #60]
1382:../uvc.c      ****                     streamingStarted = CyFalse;
 796              		.loc 1 1382 0
 797 05bc 387084E5 		str	r7, [r4, #56]
1384:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 798              		.loc 1 1384 0
 799 05c0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1385:../uvc.c      ****                     CyU3PBusyWait (100);
 800              		.loc 1 1385 0
 801 05c4 6400A0E3 		mov	r0, #100
 802 05c8 FEFFFFEB 		bl	CyU3PBusyWait
1388:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 803              		.loc 1 1388 0
 804 05cc 14029FE5 		ldr	r0, .L70+28
 805 05d0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1389:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 806              		.loc 1 1389 0
 807 05d4 8300A0E3 		mov	r0, #131
 808 05d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1390:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 809              		.loc 1 1390 0
 810 05dc 0710A0E1 		mov	r1, r7
 811 05e0 8300A0E3 		mov	r0, #131
 812 05e4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1391:../uvc.c      ****                     CyU3PBusyWait (100);
 813              		.loc 1 1391 0
 814 05e8 6400A0E3 		mov	r0, #100
 815 05ec FEFFFFEB 		bl	CyU3PBusyWait
1394:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 816              		.loc 1 1394 0
 817 05f0 0710A0E1 		mov	r1, r7
 818 05f4 0520A0E1 		mov	r2, r5
 819 05f8 8300A0E3 		mov	r0, #131
 820 05fc FEFFFFEB 		bl	CyU3PUsbStall
 821              	.LVL64:
1397:../uvc.c      ****                     CyU3PUsbAckSetup ();
 822              		.loc 1 1397 0
 823 0600 FEFFFFEB 		bl	CyU3PUsbAckSetup
1399:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 824              		.loc 1 1399 0
 825 0604 445084E5 		str	r5, [r4, #68]
 826              	.LBB42:
 827              	.LBB43:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 828              		.loc 1 1259 0
 829 0608 0400A0E1 		mov	r0, r4
 830 060c 0510A0E1 		mov	r1, r5
 831 0610 0220A0E3 		mov	r2, #2
 832 0614 0C308DE2 		add	r3, sp, #12
 833 0618 00708DE5 		str	r7, [sp, #0]
 834 061c FEFFFFEB 		bl	_txe_event_flags_get
 835 0620 006050E2 		subs	r6, r0, #0
 836 0624 2E00001A 		bne	.L61
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 837              		.loc 1 1262 0
 838 0628 0110E0E3 		mvn	r1, #1
 839 062c 0220A0E3 		mov	r2, #2
 840 0630 0400A0E1 		mov	r0, r4
 841 0634 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 842              		.loc 1 1265 0
 843 0638 0400A0E1 		mov	r0, r4
 844 063c 0210A0E3 		mov	r1, #2
 845 0640 0620A0E1 		mov	r2, r6
 846 0644 FEFFFFEB 		bl	_txe_event_flags_set
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 847              		.loc 1 1395 0
 848 0648 0500A0E1 		mov	r0, r5
 849 064c C7FFFFEA 		b	.L46
 850              	.LVL65:
 851              	.L49:
 852              	.LBE43:
 853              	.LBE42:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 854              		.loc 1 1337 0
 855 0650 FF5015E2 		ands	r5, r5, #255
 856 0654 1A00001A 		bne	.L67
 857              	.LVL66:
1342:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 858              		.loc 1 1342 0
 859 0658 0520A0E1 		mov	r2, r5
 860 065c 7C019FE5 		ldr	r0, .L70+20
 861 0660 0410A0E3 		mov	r1, #4
 862 0664 FEFFFFEB 		bl	_txe_event_flags_set
 863              	.LVL67:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 864              		.loc 1 1344 0
 865 0668 002050E2 		subs	r2, r0, #0
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 866              		.loc 1 1341 0
 867 066c 0100A003 		moveq	r0, #1
 868              	.LVL68:
1344:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 869              		.loc 1 1344 0
 870 0670 BEFFFF0A 		beq	.L46
1346:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 871              		.loc 1 1346 0
 872 0674 70119FE5 		ldr	r1, .L70+32
 873 0678 0400A0E3 		mov	r0, #4
 874 067c FEFFFFEB 		bl	CyU3PDebugPrint
 875              	.LVL69:
1347:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 876              		.loc 1 1347 0
 877 0680 0500A0E1 		mov	r0, r5
 878 0684 0110A0E3 		mov	r1, #1
 879 0688 0520A0E1 		mov	r2, r5
 880 068c FEFFFFEB 		bl	CyU3PUsbStall
1341:../uvc.c      ****                         uvcHandleReq = CyTrue;
 881              		.loc 1 1341 0
 882 0690 0100A0E3 		mov	r0, #1
 883 0694 B5FFFFEA 		b	.L46
 884              	.LVL70:
 885              	.L48:
1407:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 886              		.loc 1 1407 0
 887 0698 010058E3 		cmp	r8, #1
 888 069c B2FFFF1A 		bne	.L63
1409:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 889              		.loc 1 1409 0
 890 06a0 830055E3 		cmp	r5, #131
 891 06a4 B0FFFF1A 		bne	.L63
1415:../uvc.c      ****                     if (streamingStarted == CyTrue)
 892              		.loc 1 1415 0
 893 06a8 30719FE5 		ldr	r7, .L70+20
 894 06ac 386097E5 		ldr	r6, [r7, #56]
 895 06b0 010056E3 		cmp	r6, #1
 896 06b4 1500000A 		beq	.L68
 897              	.LVL71:
1447:../uvc.c      ****                         CyU3PUsbAckSetup ();
 898              		.loc 1 1447 0
 899 06b8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1446:../uvc.c      ****                         uvcHandleReq = CyTrue;
 900              		.loc 1 1446 0
 901 06bc 0800A0E1 		mov	r0, r8
 902 06c0 AAFFFFEA 		b	.L46
 903              	.LVL72:
 904              	.L67:
1337:../uvc.c      ****             switch (wIndex & 0xFF)
 905              		.loc 1 1337 0
 906 06c4 010055E3 		cmp	r5, #1
 907 06c8 A7FFFF1A 		bne	.L63
 908              	.LVL73:
1355:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 909              		.loc 1 1355 0
 910 06cc 0020A0E3 		mov	r2, #0
 911 06d0 08019FE5 		ldr	r0, .L70+20
 912 06d4 0810A0E3 		mov	r1, #8
 913 06d8 FEFFFFEB 		bl	_txe_event_flags_set
 914              	.LVL74:
1357:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 915              		.loc 1 1357 0
 916 06dc 002050E2 		subs	r2, r0, #0
 917 06e0 0100001A 		bne	.L69
 918              	.LVL75:
 919              	.L61:
 920              	.LBB45:
 921              	.LBB44:
1395:../uvc.c      ****                     uvcHandleReq = CyTrue;
 922              		.loc 1 1395 0
 923 06e4 0500A0E1 		mov	r0, r5
 924 06e8 A0FFFFEA 		b	.L46
 925              	.LVL76:
 926              	.L69:
 927              	.LBE44:
 928              	.LBE45:
1360:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 929              		.loc 1 1360 0
 930 06ec FC109FE5 		ldr	r1, .L70+36
 931 06f0 0400A0E3 		mov	r0, #4
 932              	.LVL77:
 933 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 934              	.LVL78:
1361:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 935              		.loc 1 1361 0
 936 06f8 0000A0E3 		mov	r0, #0
 937 06fc 0510A0E1 		mov	r1, r5
 938 0700 0020A0E1 		mov	r2, r0
 939 0704 FEFFFFEB 		bl	CyU3PUsbStall
1354:../uvc.c      ****                         uvcHandleReq = CyTrue;
 940              		.loc 1 1354 0
 941 0708 0500A0E1 		mov	r0, r5
 942 070c 97FFFFEA 		b	.L46
 943              	.LVL79:
 944              	.L68:
1417:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 945              		.loc 1 1417 0
 946 0710 DC109FE5 		ldr	r1, .L70+40
 947 0714 0400A0E3 		mov	r0, #4
 948 0718 FEFFFFEB 		bl	CyU3PDebugPrint
1421:../uvc.c      ****                         gpif_initialized = 0;
 949              		.loc 1 1421 0
 950 071c 0080A0E3 		mov	r8, #0
1420:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 951              		.loc 1 1420 0
 952 0720 0600A0E1 		mov	r0, r6
 953 0724 FEFFFFEB 		bl	CyU3PGpifDisable
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 954              		.loc 1 1425 0
 955 0728 0610A0E1 		mov	r1, r6
 956 072c 0500A0E1 		mov	r0, r5
1421:../uvc.c      ****                         gpif_initialized = 0;
 957              		.loc 1 1421 0
 958 0730 3C8087E5 		str	r8, [r7, #60]
1422:../uvc.c      ****                         streamingStarted = CyFalse;
 959              		.loc 1 1422 0
 960 0734 388087E5 		str	r8, [r7, #56]
1425:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 961              		.loc 1 1425 0
 962 0738 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1426:../uvc.c      ****                         CyU3PBusyWait (100);
 963              		.loc 1 1426 0
 964 073c 6400A0E3 		mov	r0, #100
 965 0740 FEFFFFEB 		bl	CyU3PBusyWait
1429:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 966              		.loc 1 1429 0
 967 0744 9C009FE5 		ldr	r0, .L70+28
 968 0748 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1430:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 969              		.loc 1 1430 0
 970 074c 0500A0E1 		mov	r0, r5
 971 0750 FEFFFFEB 		bl	CyU3PUsbFlushEp
1431:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 972              		.loc 1 1431 0
 973 0754 0810A0E1 		mov	r1, r8
 974 0758 0500A0E1 		mov	r0, r5
 975 075c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1432:../uvc.c      ****                         CyU3PBusyWait (100);
 976              		.loc 1 1432 0
 977 0760 6400A0E3 		mov	r0, #100
 978 0764 FEFFFFEB 		bl	CyU3PBusyWait
1435:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 979              		.loc 1 1435 0
 980 0768 0810A0E1 		mov	r1, r8
 981 076c 0620A0E1 		mov	r2, r6
 982 0770 0500A0E1 		mov	r0, r5
 983 0774 FEFFFFEB 		bl	CyU3PUsbStall
 984              	.LVL80:
1439:../uvc.c      ****                         CyU3PUsbAckSetup ();
 985              		.loc 1 1439 0
 986 0778 FEFFFFEB 		bl	CyU3PUsbAckSetup
1441:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 987              		.loc 1 1441 0
 988 077c 446087E5 		str	r6, [r7, #68]
 989              	.LBB46:
 990              	.LBB47:
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 991              		.loc 1 1259 0
 992 0780 0700A0E1 		mov	r0, r7
 993 0784 0610A0E1 		mov	r1, r6
 994 0788 0420A0E1 		mov	r2, r4
 995 078c 0C308DE2 		add	r3, sp, #12
 996 0790 00808DE5 		str	r8, [sp, #0]
 997 0794 FEFFFFEB 		bl	_txe_event_flags_get
 998 0798 005050E2 		subs	r5, r0, #0
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 999              		.loc 1 1437 0
 1000 079c 0600A011 		movne	r0, r6
1259:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1001              		.loc 1 1259 0
 1002 07a0 72FFFF1A 		bne	.L46
1262:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1003              		.loc 1 1262 0
 1004 07a4 0110E0E3 		mvn	r1, #1
 1005 07a8 0420A0E1 		mov	r2, r4
 1006 07ac 0700A0E1 		mov	r0, r7
 1007 07b0 FEFFFFEB 		bl	_txe_event_flags_set
1265:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1008              		.loc 1 1265 0
 1009 07b4 0700A0E1 		mov	r0, r7
 1010 07b8 0410A0E1 		mov	r1, r4
 1011 07bc 0520A0E1 		mov	r2, r5
 1012 07c0 FEFFFFEB 		bl	_txe_event_flags_set
1437:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1013              		.loc 1 1437 0
 1014 07c4 0600A0E1 		mov	r0, r6
 1015 07c8 68FFFFEA 		b	.L46
 1016              	.L71:
 1017              		.align	2
 1018              	.L70:
 1019 07cc 00000000 		.word	bmReqType
 1020 07d0 00000000 		.word	bRequest
 1021 07d4 00000000 		.word	wValue
 1022 07d8 00000000 		.word	wIndex
 1023 07dc 00000000 		.word	wLength
 1024 07e0 00000000 		.word	.LANCHOR0
 1025 07e4 54010000 		.word	.LC8
 1026 07e8 00000000 		.word	glChHandleUVCStream
 1027 07ec E8000000 		.word	.LC6
 1028 07f0 20010000 		.word	.LC7
 1029 07f4 6C010000 		.word	.LC9
 1030              	.LBE47:
 1031              	.LBE46:
 1032              		.cfi_endproc
 1033              	.LFE9:
 1035              		.align	2
 1036              		.global	CyFxGpifCB
 1038              	CyFxGpifCB:
 1039              	.LFB12:
1638:../uvc.c      **** {
 1040              		.loc 1 1638 0
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 0
 1043              		@ frame_needed = 0, uses_anonymous_args = 0
 1044              	.LVL81:
1639:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1045              		.loc 1 1639 0
 1046 07f8 010050E3 		cmp	r0, #1
1638:../uvc.c      **** {
 1047              		.loc 1 1638 0
 1048 07fc 10402DE9 		stmfd	sp!, {r4, lr}
 1049              	.LCFI8:
 1050              		.cfi_def_cfa_offset 8
1638:../uvc.c      **** {
 1051              		.loc 1 1638 0
 1052 0800 0120A0E1 		mov	r2, r1
1639:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1053              		.loc 1 1639 0
 1054 0804 1080BD18 		ldmnefd	sp!, {r4, pc}
 1055              		.cfi_offset 14, -4
 1056              		.cfi_offset 4, -8
 1057              	.LVL82:
 1058              	.LBB52:
 1059              	.LBB53:
1536:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1060              		.loc 1 1536 0
 1061 0808 CC309FE5 		ldr	r3, .L87
 1062 080c 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1063 0810 030053E3 		cmp	r3, #3
 1064 0814 2100000A 		beq	.L86
1562:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1065              		.loc 1 1562 0
 1066 0818 020053E3 		cmp	r3, #2
 1067 081c 1080BD18 		ldmnefd	sp!, {r4, pc}
1564:../uvc.c      ****         switch (stateId)
 1068              		.loc 1 1564 0
 1069 0820 080041E2 		sub	r0, r1, #8
 1070              	.LVL83:
 1071 0824 0A0050E3 		cmp	r0, #10
 1072 0828 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1073 082c 230000EA 		b	.L79
 1074              	.L81:
 1075 0830 60080000 		.word	.L76
 1076 0834 C0080000 		.word	.L79
 1077 0838 C0080000 		.word	.L79
 1078 083c 5C080000 		.word	.L72
 1079 0840 C0080000 		.word	.L79
 1080 0844 C0080000 		.word	.L79
 1081 0848 C0080000 		.word	.L79
 1082 084c 98080000 		.word	.L85
 1083 0850 C0080000 		.word	.L79
 1084 0854 C0080000 		.word	.L79
 1085 0858 5C080000 		.word	.L72
 1086              	.LVL84:
 1087              	.L72:
 1088 085c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1089              	.LVL85:
 1090              	.L76:
1547:../uvc.c      ****                 socket = 0;
 1091              		.loc 1 1547 0
 1092 0860 0010A0E3 		mov	r1, #0
 1093              	.LVL86:
 1094              	.L77:
1621:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1095              		.loc 1 1621 0
 1096 0864 74009FE5 		ldr	r0, .L87+4
 1097 0868 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1098              	.LVL87:
1622:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1099              		.loc 1 1622 0
 1100 086c 002050E2 		subs	r2, r0, #0
 1101 0870 F9FFFF0A 		beq	.L72
1624:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1102              		.loc 1 1624 0
 1103 0874 0400A0E3 		mov	r0, #4
 1104              	.LVL88:
 1105 0878 64109FE5 		ldr	r1, .L87+8
 1106 087c FEFFFFEB 		bl	CyU3PDebugPrint
 1107              	.LVL89:
 1108              	.L82:
 1109              	.LBB54:
 1110              	.LBB55:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1111              		.loc 1 1246 0
 1112 0880 60109FE5 		ldr	r1, .L87+12
 1113 0884 0400A0E3 		mov	r0, #4
 1114 0888 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 1115              		.loc 1 1247 0
 1116 088c FA0FA0E3 		mov	r0, #1000
 1117 0890 FEFFFFEB 		bl	_tx_thread_sleep
 1118 0894 F9FFFFEA 		b	.L82
 1119              	.LVL90:
 1120              	.L85:
 1121              	.LBE55:
 1122              	.LBE54:
1591:../uvc.c      ****                 socket = 1;
 1123              		.loc 1 1591 0
 1124 0898 0110A0E3 		mov	r1, #1
 1125              	.LVL91:
 1126 089c F0FFFFEA 		b	.L77
 1127              	.LVL92:
 1128              	.L86:
1538:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1538 0
 1130 08a0 0B2041E2 		sub	r2, r1, #11
 1131 08a4 030052E3 		cmp	r2, #3
 1132 08a8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1133 08ac 060000EA 		b	.L75
 1134              	.L78:
 1135 08b0 60080000 		.word	.L76
 1136 08b4 98080000 		.word	.L85
 1137 08b8 5C080000 		.word	.L72
 1138 08bc 5C080000 		.word	.L72
 1139              	.LVL93:
 1140              	.L79:
1610:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1141              		.loc 1 1610 0
 1142 08c0 24109FE5 		ldr	r1, .L87+16
 1143              	.LVL94:
 1144 08c4 0100A0E3 		mov	r0, #1
 1145 08c8 FEFFFFEB 		bl	CyU3PDebugPrint
 1146              	.LVL95:
 1147              	.L75:
 1148              	.LBE53:
 1149              	.LBE52:
1645:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1150              		.loc 1 1645 0
 1151 08cc 1C109FE5 		ldr	r1, .L87+20
 1152 08d0 0400A0E3 		mov	r0, #4
1648:../uvc.c      **** }
 1153              		.loc 1 1648 0
 1154 08d4 1040BDE8 		ldmfd	sp!, {r4, lr}
1645:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1155              		.loc 1 1645 0
 1156 08d8 FEFFFFEA 		b	CyU3PDebugPrint
 1157              	.L88:
 1158              		.align	2
 1159              	.L87:
 1160 08dc 00000000 		.word	.LANCHOR0
 1161 08e0 00000000 		.word	glChHandleUVCStream
 1162 08e4 A8010000 		.word	.LC11
 1163 08e8 D8010000 		.word	.LC12
 1164 08ec 90010000 		.word	.LC10
 1165 08f0 EC010000 		.word	.LC13
 1166              		.cfi_endproc
 1167              	.LFE12:
 1169              		.align	2
 1170              		.global	I2CCmdHandler
 1172              	I2CCmdHandler:
 1173              	.LFB0:
 332:../uvc.c      **** void I2CCmdHandler(){
 1174              		.loc 1 332 0
 1175              		.cfi_startproc
 1176              		@ args = 0, pretend = 0, frame = 16
 1177              		@ frame_needed = 0, uses_anonymous_args = 0
 1178 08f4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1179              	.LCFI9:
 1180              		.cfi_def_cfa_offset 36
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1181              		.loc 1 335 0
 1182 08f8 08429FE5 		ldr	r4, .L101
 1183              		.cfi_offset 14, -4
 1184              		.cfi_offset 11, -8
 1185              		.cfi_offset 10, -12
 1186              		.cfi_offset 9, -16
 1187              		.cfi_offset 8, -20
 1188              		.cfi_offset 7, -24
 1189              		.cfi_offset 6, -28
 1190              		.cfi_offset 5, -32
 1191              		.cfi_offset 4, -36
 332:../uvc.c      **** void I2CCmdHandler(){
 1192              		.loc 1 332 0
 1193 08fc 3CD04DE2 		sub	sp, sp, #60
 1194              	.LCFI10:
 1195              		.cfi_def_cfa_offset 96
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1196              		.loc 1 340 0
 1197 0900 5310D4E5 		ldrb	r1, [r4, #83]	@ zero_extendqisi2
 335:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1198              		.loc 1 335 0
 1199 0904 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1200              	.LVL96:
 336:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1201              		.loc 1 336 0
 1202 0908 4D60D4E5 		ldrb	r6, [r4, #77]	@ zero_extendqisi2
 1203              	.LVL97:
 337:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1204              		.loc 1 337 0
 1205 090c 5470D4E5 		ldrb	r7, [r4, #84]	@ zero_extendqisi2
 1206              	.LVL98:
 340:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1207              		.loc 1 340 0
 1208 0910 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1209 0914 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1210 0918 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1211 091c 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1212 0920 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1213 0924 14108DE5 		str	r1, [sp, #20]
 1214 0928 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1215 092c 0400A0E3 		mov	r0, #4
 1216 0930 1C308DE5 		str	r3, [sp, #28]
 1217 0934 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1218 0938 CC119FE5 		ldr	r1, .L101+4
 1219 093c 0520A0E1 		mov	r2, r5
 1220 0940 0630A0E1 		mov	r3, r6
 1221 0944 00E08DE5 		str	lr, [sp, #0]
 1222 0948 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1223 094c 0C908DE5 		str	r9, [sp, #12]
 1224 0950 10B08DE5 		str	fp, [sp, #16]
 1225 0954 18708DE5 		str	r7, [sp, #24]
 1226 0958 20C08DE5 		str	ip, [sp, #32]
 1227 095c FEFFFFEB 		bl	CyU3PDebugPrint
 344:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1228              		.loc 1 344 0
 1229 0960 000055E3 		cmp	r5, #0
 1230 0964 1500001A 		bne	.L90
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1231              		.loc 1 346 0
 1232 0968 0F00A0E3 		mov	r0, #15
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 1233              		.loc 1 360 0
 1234 096c 020056E3 		cmp	r6, #2
 346:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1235              		.loc 1 346 0
 1236 0970 5700C4E5 		strb	r0, [r4, #87]
 360:../uvc.c      **** 			if(CmdRegLen == 2){
 1237              		.loc 1 360 0
 1238 0974 2500000A 		beq	.L99
 364:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1239              		.loc 1 364 0
 1240 0978 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1241 097c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1242 0980 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1243 0984 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1244 0988 34C08DE2 		add	ip, sp, #52
 1245 098c 010080E3 		orr	r0, r0, #1
 1246 0990 011081E3 		orr	r1, r1, #1
 1247 0994 00C08DE5 		str	ip, [sp, #0]
 1248 0998 FEFFFFEB 		bl	SensorRead2B
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1249              		.loc 1 365 0
 1250 099c 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 366:../uvc.c      **** 				if(CmdDataLen == 2){
 1251              		.loc 1 366 0
 1252 09a0 020057E3 		cmp	r7, #2
 365:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1253              		.loc 1 365 0
 1254 09a4 5530C4E5 		strb	r3, [r4, #85]
 367:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1255              		.loc 1 367 0
 1256 09a8 3530DD05 		ldreqb	r3, [sp, #53]	@ zero_extendqisi2
 1257 09ac 5630C405 		streqb	r3, [r4, #86]
 1258              	.L92:
 370:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1259              		.loc 1 370 0
 1260 09b0 0020E0E3 		mvn	r2, #0
 1261 09b4 5720C4E5 		strb	r2, [r4, #87]
 1262              	.LVL99:
 1263              	.L89:
 393:../uvc.c      **** }
 1264              		.loc 1 393 0
 1265 09b8 3CD08DE2 		add	sp, sp, #60
 1266 09bc F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1267              	.LVL100:
 1268              	.L90:
 374:../uvc.c      **** 	}else if(CmdType == 1){
 1269              		.loc 1 374 0
 1270 09c0 010055E3 		cmp	r5, #1
 1271 09c4 FBFFFF1A 		bne	.L89
 376:../uvc.c      **** 			if(CmdRegLen == 2){
 1272              		.loc 1 376 0
 1273 09c8 020056E3 		cmp	r6, #2
 1274 09cc 1900000A 		beq	.L100
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1275              		.loc 1 381 0
 1276 09d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1277 09d4 FE1003E2 		and	r1, r3, #254
 1278 09d8 820051E3 		cmp	r1, #130
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1279              		.loc 1 384 0
 1280 09dc 5050D415 		ldrneb	r5, [r4, #80]	@ zero_extendqisi2
 1281              	.LVL101:
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1282              		.loc 1 381 0
 1283 09e0 0200001A 		bne	.L98
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1284              		.loc 1 381 0 is_stmt 0 discriminator 1
 1285 09e4 5050D4E5 		ldrb	r5, [r4, #80]	@ zero_extendqisi2
 1286 09e8 300055E3 		cmp	r5, #48
 1287 09ec 3200000A 		beq	.L96
 1288              	.L98:
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1289              		.loc 1 384 0 is_stmt 1
 1290 09f0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1291              	.L97:
 386:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1292              		.loc 1 386 0
 1293 09f4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1294 09f8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1295 09fc 0520A0E1 		mov	r2, r5
 1296 0a00 FE0000E2 		and	r0, r0, #254
 1297 0a04 00E08DE5 		str	lr, [sp, #0]
 1298 0a08 FEFFFFEB 		bl	SensorWrite2B
 1299 0a0c E9FFFFEA 		b	.L89
 1300              	.LVL102:
 1301              	.L99:
 1302              	.LBB56:
 361:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 1303              		.loc 1 361 0
 1304 0a10 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 1305 0a14 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1306 0a18 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1307 0a1c 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1308 0a20 011082E3 		orr	r1, r2, #1
 1309 0a24 01008EE3 		orr	r0, lr, #1
 1310 0a28 0520A0E1 		mov	r2, r5
 1311 0a2c 00C08DE5 		str	ip, [sp, #0]
 1312 0a30 FEFFFFEB 		bl	SensorRead2B2
 1313 0a34 DDFFFFEA 		b	.L92
 1314              	.L100:
 1315              	.LBE56:
 378:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1316              		.loc 1 378 0
 1317 0a38 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1318 0a3c 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1319 0a40 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1320 0a44 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1321 0a48 FE0002E2 		and	r0, r2, #254
 1322 0a4c 0020A0E3 		mov	r2, #0
 1323 0a50 00E08DE5 		str	lr, [sp, #0]
 1324 0a54 FEFFFFEB 		bl	SensorWrite2B2
 1325 0a58 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1326 0a5c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1327 0a60 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1328 0a64 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1329 0a68 0020A0E3 		mov	r2, #0
 1330 0a6c FE0000E2 		and	r0, r0, #254
 1331 0a70 00C08DE5 		str	ip, [sp, #0]
 1332 0a74 FEFFFFEB 		bl	SensorWrite2B2
 1333              	.LVL103:
 1334 0a78 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1335 0a7c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1336 0a80 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1337 0a84 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1338 0a88 FE0002E2 		and	r0, r2, #254
 1339 0a8c 0020A0E3 		mov	r2, #0
 1340 0a90 00C08DE5 		str	ip, [sp, #0]
 1341 0a94 FEFFFFEB 		bl	SensorWrite2B2
 1342 0a98 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1343 0a9c 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1344 0aa0 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1345 0aa4 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1346 0aa8 0020A0E3 		mov	r2, #0
 1347 0aac FE0000E2 		and	r0, r0, #254
 1348 0ab0 00C08DE5 		str	ip, [sp, #0]
 1349 0ab4 FEFFFFEB 		bl	SensorWrite2B2
 1350 0ab8 BEFFFFEA 		b	.L89
 1351              	.LVL104:
 1352              	.L96:
 381:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1353              		.loc 1 381 0 discriminator 1
 1354 0abc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1355 0ac0 100053E3 		cmp	r3, #16
 1356 0ac4 CAFFFF1A 		bne	.L97
 382:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1357              		.loc 1 382 0
 1358 0ac8 40409FE5 		ldr	r4, .L101+8
 1359 0acc 0010E0E3 		mvn	r1, #0
 1360 0ad0 1C0094E5 		ldr	r0, [r4, #28]
 1361 0ad4 2C308DE5 		str	r3, [sp, #44]
 1362 0ad8 FEFFFFEB 		bl	_txe_mutex_get
 383:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1363              		.loc 1 383 0
 1364 0adc 00C0A0E3 		mov	ip, #0
 1365 0ae0 0400A0E1 		mov	r0, r4
 1366 0ae4 1710A0E3 		mov	r1, #23
 1367 0ae8 2C209DE5 		ldr	r2, [sp, #44]
 1368 0aec 0530A0E1 		mov	r3, r5
 1369 0af0 00C08DE5 		str	ip, [sp, #0]
 1370 0af4 04C08DE5 		str	ip, [sp, #4]
 1371 0af8 FEFFFFEB 		bl	cmdSet
 384:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1372              		.loc 1 384 0
 1373 0afc 1C0094E5 		ldr	r0, [r4, #28]
 1374 0b00 FEFFFFEB 		bl	_txe_mutex_put
 1375 0b04 ABFFFFEA 		b	.L89
 1376              	.L102:
 1377              		.align	2
 1378              	.L101:
 1379 0b08 00000000 		.word	.LANCHOR0
 1380 0b0c 04020000 		.word	.LC14
 1381 0b10 00000000 		.word	cmdQu
 1382              		.cfi_endproc
 1383              	.LFE0:
 1385              		.align	2
 1386              		.global	setIrisauto
 1388              	setIrisauto:
 1389              	.LFB1:
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1390              		.loc 1 399 0
 1391              		.cfi_startproc
 1392              		@ args = 0, pretend = 0, frame = 0
 1393              		@ frame_needed = 0, uses_anonymous_args = 0
 1394              	.LVL105:
 1395 0b14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1396              	.LCFI11:
 1397              		.cfi_def_cfa_offset 16
 1398 0b18 0160A0E1 		mov	r6, r1
 1399              		.cfi_offset 14, -4
 1400              		.cfi_offset 6, -8
 1401              		.cfi_offset 5, -12
 1402              		.cfi_offset 4, -16
 1403 0b1c 08D04DE2 		sub	sp, sp, #8
 1404              	.LCFI12:
 1405              		.cfi_def_cfa_offset 24
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1406              		.loc 1 403 0
 1407 0b20 0050A0E3 		mov	r5, #0
 399:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1408              		.loc 1 399 0
 1409 0b24 0040A0E1 		mov	r4, r0
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1410              		.loc 1 402 0
 1411 0b28 0010E0E3 		mvn	r1, #0
 1412              	.LVL106:
 1413 0b2c 1C0090E5 		ldr	r0, [r0, #28]
 1414              	.LVL107:
 1415 0b30 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1416              		.loc 1 403 0
 1417 0b34 060065E0 		rsb	r0, r5, r6
 1418 0b38 00C070E2 		rsbs	ip, r0, #0
 1419 0b3c 00C0ACE0 		adc	ip, ip, r0
 1420 0b40 1410A0E3 		mov	r1, #20
 1421 0b44 2720A0E3 		mov	r2, #39
 1422 0b48 3030A0E3 		mov	r3, #48
 1423 0b4c 0400A0E1 		mov	r0, r4
 1424 0b50 00C08DE5 		str	ip, [sp, #0]
 1425 0b54 04508DE5 		str	r5, [sp, #4]
 1426 0b58 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1427              		.loc 1 404 0
 1428 0b5c 050056E1 		cmp	r6, r5
 1429 0b60 0260A003 		moveq	r6, #2
 1430 0b64 0560A011 		movne	r6, r5
 1431 0b68 0400A0E1 		mov	r0, r4
 1432 0b6c 1510A0E3 		mov	r1, #21
 1433 0b70 2520A0E3 		mov	r2, #37
 1434 0b74 3030A0E3 		mov	r3, #48
 1435 0b78 00608DE5 		str	r6, [sp, #0]
 1436 0b7c 04508DE5 		str	r5, [sp, #4]
 1437 0b80 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1438              		.loc 1 405 0
 1439 0b84 1C0094E5 		ldr	r0, [r4, #28]
 406:../uvc.c      **** }
 1440              		.loc 1 406 0
 1441 0b88 08D08DE2 		add	sp, sp, #8
 1442 0b8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1443              		.loc 1 405 0
 1444 0b90 FEFFFFEA 		b	_txe_mutex_put
 1445              		.cfi_endproc
 1446              	.LFE1:
 1448              		.align	2
 1449              		.global	ControlHandle
 1451              	ControlHandle:
 1452              	.LFB2:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1453              		.loc 1 408 0
 1454              		.cfi_startproc
 1455              		@ args = 0, pretend = 0, frame = 24
 1456              		@ frame_needed = 0, uses_anonymous_args = 0
 1457              	.LVL108:
 1458 0b94 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1459              	.LCFI13:
 1460              		.cfi_def_cfa_offset 36
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1461              		.loc 1 415 0
 1462 0b98 1F0050E3 		cmp	r0, #31
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1463              		.loc 1 414 0
 1464 0b9c 207040E2 		sub	r7, r0, #32
 1465              		.cfi_offset 14, -4
 1466              		.cfi_offset 11, -8
 1467              		.cfi_offset 10, -12
 1468              		.cfi_offset 9, -16
 1469              		.cfi_offset 8, -20
 1470              		.cfi_offset 7, -24
 1471              		.cfi_offset 6, -28
 1472              		.cfi_offset 5, -32
 1473              		.cfi_offset 4, -36
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1474              		.loc 1 408 0
 1475 0ba0 2CD04DE2 		sub	sp, sp, #44
 1476              	.LCFI14:
 1477              		.cfi_def_cfa_offset 80
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1478              		.loc 1 408 0
 1479 0ba4 0040A0E1 		mov	r4, r0
 414:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1480              		.loc 1 414 0
 1481 0ba8 FF7007E2 		and	r7, r7, #255
 1482              	.LVL109:
 415:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1483              		.loc 1 415 0
 1484 0bac 2300009A 		bls	.L107
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1485              		.loc 1 416 0
 1486 0bb0 A46E9FE5 		ldr	r6, .L215
 1487 0bb4 872087E0 		add	r2, r7, r7, asl #1
 1488 0bb8 8221A0E1 		mov	r2, r2, asl #3
 1489 0bbc 023086E0 		add	r3, r6, r2
 417:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1490              		.loc 1 417 0
 1491 0bc0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 418:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1492              		.loc 1 418 0
 1493 0bc4 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 419:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1494              		.loc 1 419 0
 1495 0bc8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 430:../uvc.c      ****     reqData = bRequest;
 1496              		.loc 1 430 0
 1497 0bcc 8C3E9FE5 		ldr	r3, .L215+4
 416:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1498              		.loc 1 416 0
 1499 0bd0 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1500              	.LVL110:
 430:../uvc.c      ****     reqData = bRequest;
 1501              		.loc 1 430 0
 1502 0bd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1503              	.LVL111:
 438:../uvc.c      ****     switch (bRequest)
 1504              		.loc 1 438 0
 1505 0bd8 830055E3 		cmp	r5, #131
 1506 0bdc 2200000A 		beq	.L113
 1507              	.LVL112:
 1508              	.L210:
 1509 0be0 2B00009A 		bls	.L208
 1510 0be4 850055E3 		cmp	r5, #133
 1511 0be8 8400000A 		beq	.L115
 1512 0bec 7200003A 		bcc	.L114
 1513 0bf0 860055E3 		cmp	r5, #134
 1514 0bf4 BD00000A 		beq	.L116
 1515 0bf8 870055E3 		cmp	r5, #135
 1516 0bfc B100000A 		beq	.L209
 1517              	.L109:
 896:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1518              		.loc 1 896 0
 1519 0c00 0000A0E3 		mov	r0, #0
 1520 0c04 0110A0E3 		mov	r1, #1
 1521 0c08 0020A0E1 		mov	r2, r0
 1522 0c0c FEFFFFEB 		bl	CyU3PUsbStall
 897:../uvc.c      **** 			  break;
 1523              		.loc 1 897 0
 1524 0c10 FFE0A0E3 		mov	lr, #255
 1525 0c14 0E40A0E1 		mov	r4, lr
 1526 0c18 0EC0A0E1 		mov	ip, lr
 1527 0c1c 0E30A0E1 		mov	r3, lr
 1528              	.LVL113:
 1529              	.L119:
 899:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1530              		.loc 1 899 0
 1531 0c20 3C1E9FE5 		ldr	r1, .L215+8
 1532 0c24 0520A0E1 		mov	r2, r5
 1533 0c28 0400A0E3 		mov	r0, #4
 1534 0c2c 00C08DE5 		str	ip, [sp, #0]
 1535 0c30 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1536 0c34 FEFFFFEB 		bl	CyU3PDebugPrint
 900:../uvc.c      **** }
 1537              		.loc 1 900 0
 1538 0c38 2CD08DE2 		add	sp, sp, #44
 1539 0c3c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1540              	.LVL114:
 1541              	.L107:
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1542              		.loc 1 421 0
 1543 0c40 146E9FE5 		ldr	r6, .L215
 430:../uvc.c      ****     reqData = bRequest;
 1544              		.loc 1 430 0
 1545 0c44 143E9FE5 		ldr	r3, .L215+4
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1546              		.loc 1 421 0
 1547 0c48 805080E0 		add	r5, r0, r0, asl #1
 1548 0c4c 850186E0 		add	r0, r6, r5, asl #3
 1549              	.LVL115:
 430:../uvc.c      ****     reqData = bRequest;
 1550              		.loc 1 430 0
 1551 0c50 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 421:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1552              		.loc 1 421 0
 1553 0c54 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1554              	.LVL116:
 438:../uvc.c      ****     switch (bRequest)
 1555              		.loc 1 438 0
 1556 0c58 830055E3 		cmp	r5, #131
 422:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1557              		.loc 1 422 0
 1558 0c5c 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1559              	.LVL117:
 423:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1560              		.loc 1 423 0
 1561 0c60 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1562              	.LVL118:
 424:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1563              		.loc 1 424 0
 1564 0c64 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1565              	.LVL119:
 438:../uvc.c      ****     switch (bRequest)
 1566              		.loc 1 438 0
 1567 0c68 DCFFFF1A 		bne	.L210
 1568              	.LVL120:
 1569              	.L113:
 561:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1570              		.loc 1 561 0
 1571 0c6c 1F0054E3 		cmp	r4, #31
 1572 0c70 BC00009A 		bls	.L144
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1573              		.loc 1 562 0
 1574 0c74 877087E0 		add	r7, r7, r7, asl #1
 1575              	.LVL121:
 1576 0c78 876186E0 		add	r6, r6, r7, asl #3
 1577 0c7c E4AD9FE5 		ldr	sl, .L215+12
 1578 0c80 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1579              		.loc 1 563 0
 1580 0c84 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 562:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1581              		.loc 1 562 0
 1582 0c88 5800CAE5 		strb	r0, [sl, #88]
 563:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1583              		.loc 1 563 0
 1584 0c8c 59C0CAE5 		strb	ip, [sl, #89]
 1585 0c90 0B0000EA 		b	.L152
 1586              	.LVL122:
 1587              	.L208:
 438:../uvc.c      ****     switch (bRequest)
 1588              		.loc 1 438 0
 1589 0c94 810055E3 		cmp	r5, #129
 1590 0c98 6400000A 		beq	.L111
 1591 0c9c 1000009A 		bls	.L211
 542:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1592              		.loc 1 542 0
 1593 0ca0 1F0054E3 		cmp	r4, #31
 1594 0ca4 A300009A 		bls	.L141
 543:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1595              		.loc 1 543 0
 1596 0ca8 877087E0 		add	r7, r7, r7, asl #1
 1597              	.LVL123:
 1598 0cac 876186E0 		add	r6, r6, r7, asl #3
 1599 0cb0 B0AD9FE5 		ldr	sl, .L215+12
 1600 0cb4 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 544:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1601              		.loc 1 544 0
 1602 0cb8 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 543:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1603              		.loc 1 543 0
 1604 0cbc 5840CAE5 		strb	r4, [sl, #88]
 544:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1605              		.loc 1 544 0
 1606 0cc0 59E0CAE5 		strb	lr, [sl, #89]
 1607              	.L152:
 620:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1608              		.loc 1 620 0
 1609 0cc4 0800A0E1 		mov	r0, r8
 1610 0cc8 9C1D9FE5 		ldr	r1, .L215+16
 1611 0ccc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1612              	.LVL124:
 622:../uvc.c      **** 			  break;
 1613              		.loc 1 622 0
 1614 0cd0 FFE0A0E3 		mov	lr, #255
 620:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1615              		.loc 1 620 0
 1616 0cd4 5840DAE5 		ldrb	r4, [sl, #88]	@ zero_extendqisi2
 622:../uvc.c      **** 			  break;
 1617              		.loc 1 622 0
 1618 0cd8 0EC0A0E1 		mov	ip, lr
 1619 0cdc 0E30A0E1 		mov	r3, lr
 1620 0ce0 CEFFFFEA 		b	.L119
 1621              	.LVL125:
 1622              	.L211:
 438:../uvc.c      ****     switch (bRequest)
 1623              		.loc 1 438 0
 1624 0ce4 010055E3 		cmp	r5, #1
 1625 0ce8 C4FFFF1A 		bne	.L109
 624:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1626              		.loc 1 624 0
 1627 0cec 741D9FE5 		ldr	r1, .L215+12
 1628 0cf0 26208DE2 		add	r2, sp, #38
 1629 0cf4 2000A0E3 		mov	r0, #32
 1630 0cf8 581081E2 		add	r1, r1, #88
 1631 0cfc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1632              	.LVL126:
 626:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1633              		.loc 1 626 0
 1634 0d00 002050E2 		subs	r2, r0, #0
 1635 0d04 1903001A 		bne	.L154
 628:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1636              		.loc 1 628 0
 1637 0d08 58ED9FE5 		ldr	lr, .L215+12
 1638 0d0c 5830DEE5 		ldrb	r3, [lr, #88]	@ zero_extendqisi2
 629:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1639              		.loc 1 629 0
 1640 0d10 50ED9FE5 		ldr	lr, .L215+12
 628:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1641              		.loc 1 628 0
 1642 0d14 18308DE5 		str	r3, [sp, #24]
 1643              	.LVL127:
 631:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1644              		.loc 1 631 0
 1645 0d18 5A00DEE5 		ldrb	r0, [lr, #90]	@ zero_extendqisi2
 1646              	.LVL128:
 629:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1647              		.loc 1 629 0
 1648 0d1c 59C0DEE5 		ldrb	ip, [lr, #89]	@ zero_extendqisi2
 1649              	.LVL129:
 631:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1650              		.loc 1 631 0
 1651 0d20 1C008DE5 		str	r0, [sp, #28]
 1652              	.LVL130:
 635:../uvc.c      **** 				  switch(CtrlID)
 1653              		.loc 1 635 0
 1654 0d24 220054E3 		cmp	r4, #34
 1655 0d28 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1656 0d2c F60200EA 		b	.L155
 1657              	.L170:
 1658 0d30 BC180000 		.word	.L156
 1659 0d34 00180000 		.word	.L157
 1660 0d38 0C190000 		.word	.L155
 1661 0d3c 0C190000 		.word	.L155
 1662 0d40 B8170000 		.word	.L158
 1663 0d44 74160000 		.word	.L159
 1664 0d48 F4150000 		.word	.L160
 1665 0d4c 0C190000 		.word	.L155
 1666 0d50 0C190000 		.word	.L155
 1667 0d54 0C190000 		.word	.L155
 1668 0d58 0C190000 		.word	.L155
 1669 0d5c 70150000 		.word	.L161
 1670 0d60 0C190000 		.word	.L155
 1671 0d64 0C190000 		.word	.L155
 1672 0d68 0C190000 		.word	.L155
 1673 0d6c 0C190000 		.word	.L155
 1674 0d70 78140000 		.word	.L162
 1675 0d74 0C190000 		.word	.L155
 1676 0d78 0C190000 		.word	.L155
 1677 0d7c 0C190000 		.word	.L155
 1678 0d80 0C190000 		.word	.L155
 1679 0d84 0C190000 		.word	.L155
 1680 0d88 0C190000 		.word	.L155
 1681 0d8c 0C190000 		.word	.L155
 1682 0d90 0C190000 		.word	.L155
 1683 0d94 BC130000 		.word	.L163
 1684 0d98 0C190000 		.word	.L155
 1685 0d9c 0C190000 		.word	.L155
 1686 0da0 00150000 		.word	.L164
 1687 0da4 0C190000 		.word	.L155
 1688 0da8 60130000 		.word	.L165
 1689 0dac DC120000 		.word	.L166
 1690 0db0 44120000 		.word	.L167
 1691 0db4 2C120000 		.word	.L168
 1692 0db8 C8110000 		.word	.L169
 1693              	.LVL131:
 1694              	.L114:
 579:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1695              		.loc 1 579 0
 1696 0dbc 1F0054E3 		cmp	r4, #31
 580:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1697              		.loc 1 580 0
 1698 0dc0 87708780 		addhi	r7, r7, r7, asl #1
 1699              	.LVL132:
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1700              		.loc 1 586 0
 1701 0dc4 84408490 		addls	r4, r4, r4, asl #1
 580:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1702              		.loc 1 580 0
 1703 0dc8 87618680 		addhi	r6, r6, r7, asl #3
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1704              		.loc 1 586 0
 1705 0dcc 84618690 		addls	r6, r6, r4, asl #3
 580:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1706              		.loc 1 580 0
 1707 0dd0 90AC9F85 		ldrhi	sl, .L215+12
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1708              		.loc 1 586 0
 1709 0dd4 8CAC9F95 		ldrls	sl, .L215+12
 580:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1710              		.loc 1 580 0
 1711 0dd8 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 581:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1712              		.loc 1 581 0
 1713 0ddc 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1714              		.loc 1 586 0
 1715 0de0 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 587:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1716              		.loc 1 587 0
 1717 0de4 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 588:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1718              		.loc 1 588 0
 1719 0de8 0030A0E3 		mov	r3, #0
 586:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1720              		.loc 1 586 0
 1721 0dec 5810CAE5 		strb	r1, [sl, #88]
 587:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1722              		.loc 1 587 0
 1723 0df0 5920CAE5 		strb	r2, [sl, #89]
 588:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1724              		.loc 1 588 0
 1725 0df4 5A30CAE5 		strb	r3, [sl, #90]
 589:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1726              		.loc 1 589 0
 1727 0df8 5B30CAE5 		strb	r3, [sl, #91]
 1728 0dfc B0FFFFEA 		b	.L152
 1729              	.LVL133:
 1730              	.L115:
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1731              		.loc 1 442 0
 1732 0e00 604C9FE5 		ldr	r4, .L215+12
 443:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1733              		.loc 1 443 0
 1734 0e04 00C0A0E3 		mov	ip, #0
 1735 0e08 59C0C4E5 		strb	ip, [r4, #89]
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1736              		.loc 1 444 0
 1737 0e0c 581084E2 		add	r1, r4, #88
 442:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1738              		.loc 1 442 0
 1739 0e10 5880C4E5 		strb	r8, [r4, #88]
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1740              		.loc 1 444 0
 1741 0e14 0200A0E3 		mov	r0, #2
 1742 0e18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1743              	.LVL134:
 446:../uvc.c      **** 			  break;
 1744              		.loc 1 446 0
 1745 0e1c FFE0A0E3 		mov	lr, #255
 444:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1746              		.loc 1 444 0
 1747 0e20 5840D4E5 		ldrb	r4, [r4, #88]	@ zero_extendqisi2
 446:../uvc.c      **** 			  break;
 1748              		.loc 1 446 0
 1749 0e24 0EC0A0E1 		mov	ip, lr
 1750 0e28 0E30A0E1 		mov	r3, lr
 1751 0e2c 7BFFFFEA 		b	.L119
 1752              	.LVL135:
 1753              	.L111:
 449:../uvc.c      **** 			 switch(CtrlID)
 1754              		.loc 1 449 0
 1755 0e30 011044E2 		sub	r1, r4, #1
 1756 0e34 210051E3 		cmp	r1, #33
 1757 0e38 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1758 0e3c D80000EA 		b	.L120
 1759              	.L128:
 1760 0e40 60110000 		.word	.L121
 1761 0e44 A4110000 		.word	.L120
 1762 0e48 A4110000 		.word	.L120
 1763 0e4c A4110000 		.word	.L120
 1764 0e50 40110000 		.word	.L122
 1765 0e54 A4110000 		.word	.L120
 1766 0e58 A4110000 		.word	.L120
 1767 0e5c A4110000 		.word	.L120
 1768 0e60 A4110000 		.word	.L120
 1769 0e64 A4110000 		.word	.L120
 1770 0e68 1C110000 		.word	.L123
 1771 0e6c A4110000 		.word	.L120
 1772 0e70 A4110000 		.word	.L120
 1773 0e74 A4110000 		.word	.L120
 1774 0e78 A4110000 		.word	.L120
 1775 0e7c A4110000 		.word	.L120
 1776 0e80 A4110000 		.word	.L120
 1777 0e84 A4110000 		.word	.L120
 1778 0e88 A4110000 		.word	.L120
 1779 0e8c A4110000 		.word	.L120
 1780 0e90 A4110000 		.word	.L120
 1781 0e94 A4110000 		.word	.L120
 1782 0e98 A4110000 		.word	.L120
 1783 0e9c A4110000 		.word	.L120
 1784 0ea0 E0100000 		.word	.L124
 1785 0ea4 A4110000 		.word	.L120
 1786 0ea8 A4110000 		.word	.L120
 1787 0eac B8100000 		.word	.L125
 1788 0eb0 A4110000 		.word	.L120
 1789 0eb4 A4110000 		.word	.L120
 1790 0eb8 1C100000 		.word	.L126
 1791 0ebc E40F0000 		.word	.L127
 1792 0ec0 E40F0000 		.word	.L127
 1793 0ec4 E40F0000 		.word	.L127
 1794              	.L209:
 606:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1795              		.loc 1 606 0
 1796 0ec8 1F0054E3 		cmp	r4, #31
 1797 0ecc 3100009A 		bls	.L151
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1798              		.loc 1 607 0
 1799 0ed0 877087E0 		add	r7, r7, r7, asl #1
 1800              	.LVL136:
 1801 0ed4 876186E0 		add	r6, r6, r7, asl #3
 1802 0ed8 88AB9FE5 		ldr	sl, .L215+12
 1803 0edc 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 608:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1804              		.loc 1 608 0
 1805 0ee0 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 607:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1806              		.loc 1 607 0
 1807 0ee4 5820CAE5 		strb	r2, [sl, #88]
 608:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1808              		.loc 1 608 0
 1809 0ee8 5910CAE5 		strb	r1, [sl, #89]
 1810 0eec 74FFFFEA 		b	.L152
 1811              	.LVL137:
 1812              	.L116:
 595:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1813              		.loc 1 595 0
 1814 0ef0 1F0054E3 		cmp	r4, #31
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1815              		.loc 1 599 0
 1816 0ef4 84408490 		addls	r4, r4, r4, asl #1
 596:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1817              		.loc 1 596 0
 1818 0ef8 87708780 		addhi	r7, r7, r7, asl #1
 1819              	.LVL138:
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1820              		.loc 1 599 0
 1821 0efc 84618690 		addls	r6, r6, r4, asl #3
 596:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1822              		.loc 1 596 0
 1823 0f00 87618680 		addhi	r6, r6, r7, asl #3
 1824 0f04 5C8B9F85 		ldrhi	r8, .L215+12
 1825 0f08 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1826              		.loc 1 599 0
 1827 0f0c 548B9F95 		ldrls	r8, .L215+12
 1828 0f10 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 601:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1829              		.loc 1 601 0
 1830 0f14 0100A0E3 		mov	r0, #1
 599:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1831              		.loc 1 599 0
 1832 0f18 5830C8E5 		strb	r3, [r8, #88]
 601:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1833              		.loc 1 601 0
 1834 0f1c 481B9FE5 		ldr	r1, .L215+16
 1835 0f20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1836              	.LVL139:
 604:../uvc.c      **** 			  break;
 1837              		.loc 1 604 0
 1838 0f24 FFE0A0E3 		mov	lr, #255
 601:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1839              		.loc 1 601 0
 1840 0f28 5840D8E5 		ldrb	r4, [r8, #88]	@ zero_extendqisi2
 604:../uvc.c      **** 			  break;
 1841              		.loc 1 604 0
 1842 0f2c 0EC0A0E1 		mov	ip, lr
 1843 0f30 0E30A0E1 		mov	r3, lr
 1844 0f34 39FFFFEA 		b	.L119
 1845              	.LVL140:
 1846              	.L141:
 547:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1847              		.loc 1 547 0
 1848 0f38 0B0054E3 		cmp	r4, #11
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1849              		.loc 1 554 0
 1850 0f3c 84408410 		addne	r4, r4, r4, asl #1
 1851 0f40 84618610 		addne	r6, r6, r4, asl #3
 1852 0f44 1CAB9F15 		ldrne	sl, .L215+12
 548:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1853              		.loc 1 548 0
 1854 0f48 18AB9F05 		ldreq	sl, .L215+12
 1855 0f4c 1C3B9F05 		ldreq	r3, .L215+20
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1856              		.loc 1 554 0
 1857 0f50 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1858              		.loc 1 555 0
 1859 0f54 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1860              		.loc 1 548 0
 1861 0f58 58308A05 		streq	r3, [sl, #88]
 554:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1862              		.loc 1 554 0
 1863 0f5c 5820CA15 		strneb	r2, [sl, #88]
 555:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1864              		.loc 1 555 0
 1865 0f60 5930CA15 		strneb	r3, [sl, #89]
 1866 0f64 56FFFFEA 		b	.L152
 1867              	.L144:
 565:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1868              		.loc 1 565 0
 1869 0f68 0B0054E3 		cmp	r4, #11
 572:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1870              		.loc 1 572 0
 1871 0f6c 84408410 		addne	r4, r4, r4, asl #1
 1872 0f70 84618610 		addne	r6, r6, r4, asl #3
 1873 0f74 ECAA9F15 		ldrne	sl, .L215+12
 566:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1874              		.loc 1 566 0
 1875 0f78 E8AA9F05 		ldreq	sl, .L215+12
 1876 0f7c F03A9F05 		ldreq	r3, .L215+24
 572:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1877              		.loc 1 572 0
 1878 0f80 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 573:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1879              		.loc 1 573 0
 1880 0f84 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 566:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1881              		.loc 1 566 0
 1882 0f88 58308A05 		streq	r3, [sl, #88]
 572:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1883              		.loc 1 572 0
 1884 0f8c 5820CA15 		strneb	r2, [sl, #88]
 573:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1885              		.loc 1 573 0
 1886 0f90 5930CA15 		strneb	r3, [sl, #89]
 1887 0f94 4AFFFFEA 		b	.L152
 1888              	.L151:
 611:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1889              		.loc 1 611 0
 1890 0f98 0B0054E3 		cmp	r4, #11
 1891 0f9c 0700000A 		beq	.L212
 617:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1892              		.loc 1 617 0
 1893 0fa0 84A084E0 		add	sl, r4, r4, asl #1
 1894 0fa4 8A6186E0 		add	r6, r6, sl, asl #3
 1895 0fa8 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1896 0fac B4AA9FE5 		ldr	sl, .L215+12
 618:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1897              		.loc 1 618 0
 1898 0fb0 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 617:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1899              		.loc 1 617 0
 1900 0fb4 5830CAE5 		strb	r3, [sl, #88]
 618:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1901              		.loc 1 618 0
 1902 0fb8 5900CAE5 		strb	r0, [sl, #89]
 1903 0fbc 40FFFFEA 		b	.L152
 1904              	.L212:
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1905              		.loc 1 612 0
 1906 0fc0 A0AA9FE5 		ldr	sl, .L215+12
 1907 0fc4 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 614:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1908              		.loc 1 614 0
 1909 0fc8 9442D6E5 		ldrb	r4, [r6, #660]	@ zero_extendqisi2
 613:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1910              		.loc 1 613 0
 1911 0fcc 00E0A0E3 		mov	lr, #0
 612:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1912              		.loc 1 612 0
 1913 0fd0 58C0CAE5 		strb	ip, [sl, #88]
 613:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1914              		.loc 1 613 0
 1915 0fd4 59E0CAE5 		strb	lr, [sl, #89]
 614:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1916              		.loc 1 614 0
 1917 0fd8 5A40CAE5 		strb	r4, [sl, #90]
 615:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1918              		.loc 1 615 0
 1919 0fdc 5BE0CAE5 		strb	lr, [sl, #91]
 1920 0fe0 37FFFFEA 		b	.L152
 1921              	.L127:
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1922              		.loc 1 455 0
 1923 0fe4 877087E0 		add	r7, r7, r7, asl #1
 1924              	.LVL141:
 1925 0fe8 876186E0 		add	r6, r6, r7, asl #3
 1926 0fec 74EA9FE5 		ldr	lr, .L215+12
 1927 0ff0 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1928              		.loc 1 456 0
 1929 0ff4 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 455:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1930              		.loc 1 455 0
 1931 0ff8 5840CEE5 		strb	r4, [lr, #88]
 456:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1932              		.loc 1 456 0
 1933 0ffc 5960CEE5 		strb	r6, [lr, #89]
 1934              	.LVL142:
 1935              	.L131:
 535:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1936              		.loc 1 535 0
 1937 1000 0800A0E1 		mov	r0, r8
 1938 1004 601A9FE5 		ldr	r1, .L215+16
 1939 1008 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 540:../uvc.c      **** 			  break;
 1940              		.loc 1 540 0
 1941 100c FFC0A0E3 		mov	ip, #255
 535:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1942              		.loc 1 535 0
 1943 1010 06E0A0E1 		mov	lr, r6
 540:../uvc.c      **** 			  break;
 1944              		.loc 1 540 0
 1945 1014 0C30A0E1 		mov	r3, ip
 1946 1018 00FFFFEA 		b	.L119
 1947              	.LVL143:
 1948              	.L126:
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1949              		.loc 1 476 0 discriminator 1
 1950 101c 000058E3 		cmp	r8, #0
 1951 1020 8602000A 		beq	.L204
 474:../uvc.c      **** 					 break;
 1952              		.loc 1 474 0
 1953 1024 28E1A0E1 		mov	lr, r8, lsr #2
 1954 1028 00005EE3 		cmp	lr, #0
 1955 102c 03005813 		cmpne	r8, #3
 1956 1030 0020A083 		movhi	r2, #0
 1957 1034 0120A093 		movls	r2, #1
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1958              		.loc 1 408 0
 1959 1038 0E31A0E1 		mov	r3, lr, asl #2
 474:../uvc.c      **** 					 break;
 1960              		.loc 1 474 0
 1961 103c 8302009A 		bls	.L191
 1962 1040 241A9FE5 		ldr	r1, .L215+16
 1963 1044 0C0041E2 		sub	r0, r1, #12
 1964              	.LVL144:
 1965              	.L136:
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1966              		.loc 1 477 0 discriminator 2
 1967 1048 044090E4 		ldr	r4, [r0], #4
 1968 104c 01C082E2 		add	ip, r2, #1
 1969 1050 FF200CE2 		and	r2, ip, #255
 1970 1054 02005EE1 		cmp	lr, r2
 1971 1058 044081E4 		str	r4, [r1], #4
 1972 105c F9FFFF8A 		bhi	.L136
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1973              		.loc 1 477 0 is_stmt 0
 1974 1060 030058E1 		cmp	r8, r3
 1975 1064 FC099F15 		ldrne	r0, .L215+12
 1976 1068 7402000A 		beq	.L204
 1977              	.L196:
 1978 106c 03E080E0 		add	lr, r0, r3
 1979 1070 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1980              		.loc 1 476 0 is_stmt 1
 1981 1074 016083E2 		add	r6, r3, #1
 1982 1078 FF3006E2 		and	r3, r6, #255
 1983              	.LVL145:
 1984 107c 030058E1 		cmp	r8, r3
 477:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1985              		.loc 1 477 0
 1986 1080 5810CEE5 		strb	r1, [lr, #88]
 476:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1987              		.loc 1 476 0
 1988 1084 F8FFFF8A 		bhi	.L196
 1989              	.LVL146:
 1990              	.L130:
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1991              		.loc 1 486 0
 1992 1088 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1993              		.loc 1 479 0
 1994 108c D4399FE5 		ldr	r3, .L215+12
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1995              		.loc 1 486 0
 1996 1090 FF0052E3 		cmp	r2, #255
 479:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1997              		.loc 1 479 0
 1998 1094 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1999              	.LVL147:
 480:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2000              		.loc 1 480 0
 2001 1098 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 2002              	.LVL148:
 486:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2003              		.loc 1 486 0
 2004 109c D7FFFF0A 		beq	.L131
 488:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2005              		.loc 1 488 0
 2006 10a0 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2007 10a4 CC199FE5 		ldr	r1, .L215+28
 2008 10a8 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2009 10ac 0400A0E3 		mov	r0, #4
 2010 10b0 FEFFFFEB 		bl	CyU3PDebugPrint
 2011 10b4 D1FFFFEA 		b	.L131
 2012              	.LVL149:
 2013              	.L125:
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 2014              		.loc 1 463 0
 2015 10b8 A8799FE5 		ldr	r7, .L215+12
 2016              	.LVL150:
 462:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2017              		.loc 1 462 0
 2018 10bc 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2019              	.LVL151:
 463:../uvc.c      **** 					 if(CamMode == 1){//720p
 2020              		.loc 1 463 0
 2021 10c0 7820D7E5 		ldrb	r2, [r7, #120]	@ zero_extendqisi2
 2022 10c4 010052E3 		cmp	r2, #1
 2023 10c8 3002000A 		beq	.L213
 2024              	.LVL152:
 2025              	.L132:
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2026              		.loc 1 473 0
 2027 10cc 0000A0E3 		mov	r0, #0
 472:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2028              		.loc 1 472 0
 2029 10d0 5840C7E5 		strb	r4, [r7, #88]
 473:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2030              		.loc 1 473 0
 2031 10d4 5900C7E5 		strb	r0, [r7, #89]
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2032              		.loc 1 426 0
 2033 10d8 FF60A0E3 		mov	r6, #255
 474:../uvc.c      **** 					 break;
 2034              		.loc 1 474 0
 2035 10dc C7FFFFEA 		b	.L131
 2036              	.LVL153:
 2037              	.L124:
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2038              		.loc 1 492 0
 2039 10e0 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2040 10e4 7CC99FE5 		ldr	ip, .L215+12
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2041              		.loc 1 494 0
 2042 10e8 E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2043              		.loc 1 493 0
 2044 10ec 00E0A0E3 		mov	lr, #0
 492:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2045              		.loc 1 492 0
 2046 10f0 5840CCE5 		strb	r4, [ip, #88]
 493:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2047              		.loc 1 493 0
 2048 10f4 59E0CCE5 		strb	lr, [ip, #89]
 494:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2049              		.loc 1 494 0
 2050 10f8 5A60CCE5 		strb	r6, [ip, #90]
 495:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2051              		.loc 1 495 0
 2052 10fc 5BE0CCE5 		strb	lr, [ip, #91]
 2053              	.LVL154:
 498:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2054              		.loc 1 498 0
 2055 1100 74199FE5 		ldr	r1, .L215+32
 2056 1104 0420A0E1 		mov	r2, r4
 2057 1108 0E30A0E1 		mov	r3, lr
 2058 110c 0400A0E3 		mov	r0, #4
 2059 1110 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2060 1114 FEFFFFEB 		bl	CyU3PDebugPrint
 499:../uvc.c      **** 					 break;
 2061              		.loc 1 499 0
 2062 1118 B8FFFFEA 		b	.L131
 2063              	.LVL155:
 2064              	.L123:
 520:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2065              		.loc 1 520 0
 2066 111c 44099FE5 		ldr	r0, .L215+12
 2067 1120 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 522:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2068              		.loc 1 522 0
 2069 1124 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2070              		.loc 1 521 0
 2071 1128 00C0A0E3 		mov	ip, #0
 520:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2072              		.loc 1 520 0
 2073 112c 5840C0E5 		strb	r4, [r0, #88]
 521:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2074              		.loc 1 521 0
 2075 1130 59C0C0E5 		strb	ip, [r0, #89]
 522:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2076              		.loc 1 522 0
 2077 1134 5A60C0E5 		strb	r6, [r0, #90]
 523:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2078              		.loc 1 523 0
 2079 1138 5BC0C0E5 		strb	ip, [r0, #91]
 2080              	.LVL156:
 526:../uvc.c      **** 					 break;
 2081              		.loc 1 526 0
 2082 113c AFFFFFEA 		b	.L131
 2083              	.LVL157:
 2084              	.L122:
 515:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2085              		.loc 1 515 0
 2086 1140 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2087 1144 1CE99FE5 		ldr	lr, .L215+12
 2088 1148 804024E2 		eor	r4, r4, #128
 516:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2089              		.loc 1 516 0
 2090 114c 0020A0E3 		mov	r2, #0
 515:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2091              		.loc 1 515 0
 2092 1150 5840CEE5 		strb	r4, [lr, #88]
 516:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2093              		.loc 1 516 0
 2094 1154 5920CEE5 		strb	r2, [lr, #89]
 2095              	.LVL158:
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2096              		.loc 1 426 0
 2097 1158 FF60A0E3 		mov	r6, #255
 518:../uvc.c      **** 					 break;
 2098              		.loc 1 518 0
 2099 115c A7FFFFEA 		b	.L131
 2100              	.LVL159:
 2101              	.L121:
 504:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2102              		.loc 1 504 0
 2103 1160 A611D6E5 		ldrb	r1, [r6, #422]	@ zero_extendqisi2
 502:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2104              		.loc 1 502 0
 2105 1164 A561D6E5 		ldrb	r6, [r6, #421]	@ zero_extendqisi2
 2106              	.LVL160:
 504:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2107              		.loc 1 504 0
 2108 1168 020011E3 		tst	r1, #2
 507:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2109              		.loc 1 507 0
 2110 116c 2661A001 		moveq	r6, r6, lsr #2
 2111              	.LVL161:
 2112 1170 866CE001 		mvneq	r6, r6, asl #25
 2113 1174 A66CE001 		mvneq	r6, r6, lsr #25
 509:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2114              		.loc 1 509 0
 2115 1178 E8389FE5 		ldr	r3, .L215+12
 505:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2116              		.loc 1 505 0
 2117 117c 0113A011 		movne	r1, r1, asl #6
 2118 1180 40400112 		andne	r4, r1, #64
 507:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2119              		.loc 1 507 0
 2120 1184 01138601 		orreq	r1, r6, r1, asl #6
 505:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2121              		.loc 1 505 0
 2122 1188 26418411 		orrne	r4, r4, r6, lsr #2
 2123              	.LVL162:
 507:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2124              		.loc 1 507 0
 2125 118c FF400102 		andeq	r4, r1, #255
 2126              	.LVL163:
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2127              		.loc 1 510 0
 2128 1190 0000A0E3 		mov	r0, #0
 509:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2129              		.loc 1 509 0
 2130 1194 5840C3E5 		strb	r4, [r3, #88]
 510:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2131              		.loc 1 510 0
 2132 1198 5900C3E5 		strb	r0, [r3, #89]
 2133              	.LVL164:
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2134              		.loc 1 426 0
 2135 119c FF60A0E3 		mov	r6, #255
 512:../uvc.c      **** 					 break;
 2136              		.loc 1 512 0
 2137 11a0 96FFFFEA 		b	.L131
 2138              	.LVL165:
 2139              	.L120:
 529:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2140              		.loc 1 529 0
 2141 11a4 842084E0 		add	r2, r4, r4, asl #1
 2142 11a8 826186E0 		add	r6, r6, r2, asl #3
 2143 11ac B4389FE5 		ldr	r3, .L215+12
 2144 11b0 8D41D6E5 		ldrb	r4, [r6, #397]	@ zero_extendqisi2
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2145              		.loc 1 530 0
 2146 11b4 0010A0E3 		mov	r1, #0
 426:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2147              		.loc 1 426 0
 2148 11b8 FF60A0E3 		mov	r6, #255
 529:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2149              		.loc 1 529 0
 2150 11bc 5840C3E5 		strb	r4, [r3, #88]
 530:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2151              		.loc 1 530 0
 2152 11c0 5910C3E5 		strb	r1, [r3, #89]
 2153              	.LVL166:
 532:../uvc.c      **** 					 break;
 2154              		.loc 1 532 0
 2155 11c4 8DFFFFEA 		b	.L131
 2156              	.LVL167:
 2157              	.L169:
 766:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2158              		.loc 1 766 0
 2159 11c8 B0489FE5 		ldr	r4, .L215+36
 2160 11cc 0010E0E3 		mvn	r1, #0
 2161 11d0 1C0094E5 		ldr	r0, [r4, #28]
 2162 11d4 FEFFFFEB 		bl	_txe_mutex_get
 2163              	.LVL168:
 767:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2164              		.loc 1 767 0
 2165 11d8 2210A0E3 		mov	r1, #34
 2166              	.L207:
 2167 11dc 18C09DE5 		ldr	ip, [sp, #24]
 2168 11e0 00E0A0E3 		mov	lr, #0
 2169 11e4 0A30A0E1 		mov	r3, sl
 2170 11e8 0920A0E1 		mov	r2, r9
 2171 11ec 0400A0E1 		mov	r0, r4
 2172 11f0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2173 11f4 FEFFFFEB 		bl	cmdSet
 768:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2174              		.loc 1 768 0
 2175 11f8 1C0094E5 		ldr	r0, [r4, #28]
 2176 11fc FEFFFFEB 		bl	_txe_mutex_put
 769:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2177              		.loc 1 769 0
 2178 1200 18109DE5 		ldr	r1, [sp, #24]
 2179 1204 877087E0 		add	r7, r7, r7, asl #1
 2180              	.LVL169:
 2181 1208 876186E0 		add	r6, r6, r7, asl #3
 770:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2182              		.loc 1 770 0
 2183 120c 0130A0E3 		mov	r3, #1
 771:../uvc.c      **** 							 break;
 2184              		.loc 1 771 0
 2185 1210 FFE0A0E3 		mov	lr, #255
 770:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2186              		.loc 1 770 0
 2187 1214 1030C6E5 		strb	r3, [r6, #16]
 769:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2188              		.loc 1 769 0
 2189 1218 0D10C6E5 		strb	r1, [r6, #13]
 770:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2190              		.loc 1 770 0
 2191 121c 0130A0E1 		mov	r3, r1
 2192 1220 1CC09DE5 		ldr	ip, [sp, #28]
 771:../uvc.c      **** 							 break;
 2193              		.loc 1 771 0
 2194 1224 0E40A0E1 		mov	r4, lr
 2195 1228 7CFEFFEA 		b	.L119
 2196              	.LVL170:
 2197              	.L168:
 758:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2198              		.loc 1 758 0
 2199 122c 4C489FE5 		ldr	r4, .L215+36
 2200 1230 0010E0E3 		mvn	r1, #0
 2201 1234 1C0094E5 		ldr	r0, [r4, #28]
 2202 1238 FEFFFFEB 		bl	_txe_mutex_get
 2203              	.LVL171:
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2204              		.loc 1 759 0
 2205 123c 2110A0E3 		mov	r1, #33
 2206 1240 E5FFFFEA 		b	.L207
 2207              	.LVL172:
 2208              	.L167:
 744:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2209              		.loc 1 744 0
 2210 1244 34489FE5 		ldr	r4, .L215+36
 2211 1248 0010E0E3 		mvn	r1, #0
 2212 124c 1C0094E5 		ldr	r0, [r4, #28]
 2213 1250 14C08DE5 		str	ip, [sp, #20]
 2214 1254 FEFFFFEB 		bl	_txe_mutex_get
 2215              	.LVL173:
 743:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2216              		.loc 1 743 0
 2217 1258 18209DE5 		ldr	r2, [sp, #24]
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2218              		.loc 1 746 0
 2219 125c 00E0A0E3 		mov	lr, #0
 743:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2220              		.loc 1 743 0
 2221 1260 7F8002E2 		and	r8, r2, #127
 2222 1264 1C808DE5 		str	r8, [sp, #28]
 2223              	.LVL174:
 746:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2224              		.loc 1 746 0
 2225 1268 1CC09DE5 		ldr	ip, [sp, #28]
 2226 126c 2010A0E3 		mov	r1, #32
 2227 1270 0920A0E1 		mov	r2, r9
 2228 1274 0A30A0E1 		mov	r3, sl
 2229 1278 0400A0E1 		mov	r0, r4
 2230 127c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2231 1280 FEFFFFEB 		bl	cmdSet
 2232              	.LVL175:
 748:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2233              		.loc 1 748 0
 2234 1284 14C09DE5 		ldr	ip, [sp, #20]
 2235 1288 0A30A0E1 		mov	r3, sl
 2236 128c 0180A0E3 		mov	r8, #1
 2237 1290 2010A0E3 		mov	r1, #32
 2238 1294 0B20A0E1 		mov	r2, fp
 2239 1298 0400A0E1 		mov	r0, r4
 2240 129c 00C08DE5 		str	ip, [sp, #0]
 2241 12a0 04808DE5 		str	r8, [sp, #4]
 2242 12a4 FEFFFFEB 		bl	cmdSet
 749:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2243              		.loc 1 749 0
 2244 12a8 1C0094E5 		ldr	r0, [r4, #28]
 2245 12ac FEFFFFEB 		bl	_txe_mutex_put
 2246              	.LVL176:
 752:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2247              		.loc 1 752 0
 2248 12b0 1C009DE5 		ldr	r0, [sp, #28]
 2249 12b4 877087E0 		add	r7, r7, r7, asl #1
 2250              	.LVL177:
 2251 12b8 876186E0 		add	r6, r6, r7, asl #3
 2252 12bc 0D00C6E5 		strb	r0, [r6, #13]
 753:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2253              		.loc 1 753 0
 2254 12c0 14C09DE5 		ldr	ip, [sp, #20]
 755:../uvc.c      **** 							 break;
 2255              		.loc 1 755 0
 2256 12c4 FFE0A0E3 		mov	lr, #255
 753:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2257              		.loc 1 753 0
 2258 12c8 0EC0C6E5 		strb	ip, [r6, #14]
 754:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2259              		.loc 1 754 0
 2260 12cc 1080C6E5 		strb	r8, [r6, #16]
 2261 12d0 18309DE5 		ldr	r3, [sp, #24]
 755:../uvc.c      **** 							 break;
 2262              		.loc 1 755 0
 2263 12d4 0E40A0E1 		mov	r4, lr
 2264 12d8 50FEFFEA 		b	.L119
 2265              	.LVL178:
 2266              	.L166:
 715:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2267              		.loc 1 715 0 discriminator 1
 2268 12dc 000058E3 		cmp	r8, #0
 2269 12e0 1800000A 		beq	.L172
 713:../uvc.c      **** 							 break;
 2270              		.loc 1 713 0
 2271 12e4 28E1A0E1 		mov	lr, r8, lsr #2
 2272 12e8 00005EE3 		cmp	lr, #0
 2273 12ec 03005813 		cmpne	r8, #3
 2274 12f0 0020A083 		movhi	r2, #0
 2275 12f4 0120A093 		movls	r2, #1
 2276              	.LVL179:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2277              		.loc 1 408 0
 2278 12f8 0E31A0E1 		mov	r3, lr, asl #2
 713:../uvc.c      **** 							 break;
 2279              		.loc 1 713 0
 2280 12fc D101009A 		bls	.L192
 2281 1300 7C179FE5 		ldr	r1, .L215+40
 2282 1304 0C0081E2 		add	r0, r1, #12
 2283              	.LVL180:
 2284              	.L183:
 716:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2285              		.loc 1 716 0 discriminator 2
 2286 1308 044090E4 		ldr	r4, [r0], #4
 2287 130c 012082E2 		add	r2, r2, #1
 2288 1310 FF2002E2 		and	r2, r2, #255
 2289 1314 02005EE1 		cmp	lr, r2
 2290 1318 044081E4 		str	r4, [r1], #4
 2291 131c F9FFFF8A 		bhi	.L183
 716:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2292              		.loc 1 716 0 is_stmt 0
 2293 1320 030058E1 		cmp	r8, r3
 2294 1324 0700000A 		beq	.L172
 2295              	.LVL181:
 2296              	.L197:
 2297 1328 38C79FE5 		ldr	ip, .L215+12
 2298 132c 03E08CE0 		add	lr, ip, r3
 2299 1330 5810DEE5 		ldrb	r1, [lr, #88]	@ zero_extendqisi2
 715:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2300              		.loc 1 715 0 is_stmt 1
 2301 1334 013083E2 		add	r3, r3, #1
 2302 1338 FF3003E2 		and	r3, r3, #255
 2303              	.LVL182:
 2304 133c 030058E1 		cmp	r8, r3
 716:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2305              		.loc 1 716 0
 2306 1340 4C10CEE5 		strb	r1, [lr, #76]
 715:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2307              		.loc 1 715 0
 2308 1344 F7FFFF8A 		bhi	.L197
 2309              	.LVL183:
 2310              	.L172:
 718:../uvc.c      **** 					 		I2CCmdHandler();
 2311              		.loc 1 718 0
 2312 1348 FEFFFFEB 		bl	I2CCmdHandler
 719:../uvc.c      **** 							 break;
 2313              		.loc 1 719 0
 2314 134c FFE0A0E3 		mov	lr, #255
 718:../uvc.c      **** 					 		I2CCmdHandler();
 2315              		.loc 1 718 0
 2316 1350 18309DE5 		ldr	r3, [sp, #24]
 2317 1354 1CC09DE5 		ldr	ip, [sp, #28]
 719:../uvc.c      **** 							 break;
 2318              		.loc 1 719 0
 2319 1358 0E40A0E1 		mov	r4, lr
 2320 135c 2FFEFFEA 		b	.L119
 2321              	.LVL184:
 2322              	.L165:
 709:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2323              		.loc 1 709 0
 2324 1360 18479FE5 		ldr	r4, .L215+36
 2325 1364 0010E0E3 		mvn	r1, #0
 2326 1368 1C0094E5 		ldr	r0, [r4, #28]
 2327 136c FEFFFFEB 		bl	_txe_mutex_get
 2328              	.LVL185:
 710:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2329              		.loc 1 710 0
 2330 1370 18009DE5 		ldr	r0, [sp, #24]
 2331 1374 00E0A0E3 		mov	lr, #0
 2332 1378 01C070E2 		rsbs	ip, r0, #1
 2333 137c 00C0A033 		movcc	ip, #0
 2334 1380 0A30A0E1 		mov	r3, sl
 2335 1384 1E10A0E3 		mov	r1, #30
 2336 1388 0920A0E1 		mov	r2, r9
 2337 138c 0400A0E1 		mov	r0, r4
 2338 1390 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2339 1394 FEFFFFEB 		bl	cmdSet
 711:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2340              		.loc 1 711 0
 2341 1398 1C0094E5 		ldr	r0, [r4, #28]
 2342 139c FEFFFFEB 		bl	_txe_mutex_put
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2343              		.loc 1 712 0
 2344 13a0 0130A0E3 		mov	r3, #1
 713:../uvc.c      **** 							 break;
 2345              		.loc 1 713 0
 2346 13a4 FFE0A0E3 		mov	lr, #255
 712:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2347              		.loc 1 712 0
 2348 13a8 6034C6E5 		strb	r3, [r6, #1120]
 2349 13ac 1CC09DE5 		ldr	ip, [sp, #28]
 2350 13b0 18309DE5 		ldr	r3, [sp, #24]
 713:../uvc.c      **** 							 break;
 2351              		.loc 1 713 0
 2352 13b4 0E40A0E1 		mov	r4, lr
 2353 13b8 18FEFFEA 		b	.L119
 2354              	.LVL186:
 2355              	.L163:
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2356              		.loc 1 676 0
 2357 13bc BC469FE5 		ldr	r4, .L215+36
 672:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2358              		.loc 1 672 0
 2359 13c0 E533C6E5 		strb	r3, [r6, #997]
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2360              		.loc 1 673 0
 2361 13c4 1C309DE5 		ldr	r3, [sp, #28]
 674:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2362              		.loc 1 674 0
 2363 13c8 0170A0E3 		mov	r7, #1
 2364              	.LVL187:
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2365              		.loc 1 676 0
 2366 13cc 0010E0E3 		mvn	r1, #0
 673:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2367              		.loc 1 673 0
 2368 13d0 E633C6E5 		strb	r3, [r6, #998]
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2369              		.loc 1 676 0
 2370 13d4 1C0094E5 		ldr	r0, [r4, #28]
 674:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2371              		.loc 1 674 0
 2372 13d8 E873C6E5 		strb	r7, [r6, #1000]
 2373              	.LVL188:
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2374              		.loc 1 676 0
 2375 13dc FEFFFFEB 		bl	_txe_mutex_get
 2376              	.LVL189:
 677:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2377              		.loc 1 677 0
 2378 13e0 18C09DE5 		ldr	ip, [sp, #24]
 2379 13e4 0400A0E1 		mov	r0, r4
 2380 13e8 00C08DE5 		str	ip, [sp, #0]
 2381 13ec 1910A0E3 		mov	r1, #25
 2382 13f0 00C0A0E3 		mov	ip, #0
 2383 13f4 0920A0E1 		mov	r2, r9
 2384 13f8 0A30A0E1 		mov	r3, sl
 2385 13fc 04C08DE5 		str	ip, [sp, #4]
 2386 1400 FEFFFFEB 		bl	cmdSet
 678:../uvc.c      **** 							 if(getData != 0){
 2387              		.loc 1 678 0
 2388 1404 18009DE5 		ldr	r0, [sp, #24]
 2389 1408 000050E3 		cmp	r0, #0
 2390 140c 0700000A 		beq	.L179
 2391              	.LVL190:
 680:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2392              		.loc 1 680 0
 2393 1410 1CE09DE5 		ldr	lr, [sp, #28]
 2394 1414 0400A0E1 		mov	r0, r4
 2395 1418 1910A0E3 		mov	r1, #25
 2396 141c 0B20A0E1 		mov	r2, fp
 2397 1420 0A30A0E1 		mov	r3, sl
 2398 1424 00E08DE5 		str	lr, [sp, #0]
 2399 1428 04708DE5 		str	r7, [sp, #4]
 2400 142c FEFFFFEB 		bl	cmdSet
 2401              	.LVL191:
 2402              	.L179:
 682:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2403              		.loc 1 682 0
 2404 1430 1C0094E5 		ldr	r0, [r4, #28]
 2405 1434 FEFFFFEB 		bl	_txe_mutex_put
 683:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2406              		.loc 1 683 0
 2407 1438 28069FE5 		ldr	r0, .L215+12
 2408 143c 24169FE5 		ldr	r1, .L215+12
 2409 1440 5AC0D0E5 		ldrb	ip, [r0, #90]	@ zero_extendqisi2
 2410 1444 5B40D1E5 		ldrb	r4, [r1, #91]	@ zero_extendqisi2
 2411 1448 5930D0E5 		ldrb	r3, [r0, #89]	@ zero_extendqisi2
 2412 144c 5820D0E5 		ldrb	r2, [r0, #88]	@ zero_extendqisi2
 2413 1450 30169FE5 		ldr	r1, .L215+44
 2414 1454 0400A0E3 		mov	r0, #4
 2415 1458 00C08DE5 		str	ip, [sp, #0]
 2416 145c 04408DE5 		str	r4, [sp, #4]
 2417 1460 FEFFFFEB 		bl	CyU3PDebugPrint
 684:../uvc.c      **** 							 break;
 2418              		.loc 1 684 0
 2419 1464 FFE0A0E3 		mov	lr, #255
 683:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2420              		.loc 1 683 0
 2421 1468 18309DE5 		ldr	r3, [sp, #24]
 2422 146c 1CC09DE5 		ldr	ip, [sp, #28]
 684:../uvc.c      **** 							 break;
 2423              		.loc 1 684 0
 2424 1470 0E40A0E1 		mov	r4, lr
 2425 1474 E9FDFFEA 		b	.L119
 2426              	.LVL192:
 2427              	.L162:
 639:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2428              		.loc 1 639 0
 2429 1478 001053E2 		subs	r1, r3, #0
 638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2430              		.loc 1 638 0
 2431 147c 0D13C6E5 		strb	r1, [r6, #781]
 2432 1480 D4359FE5 		ldr	r3, .L215
 639:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2433              		.loc 1 639 0
 2434 1484 4E01001A 		bne	.L173
 640:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2435              		.loc 1 640 0
 2436 1488 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2437              	.LVL193:
 2438 148c 020052E3 		cmp	r2, #2
 2439 1490 08005213 		cmpne	r2, #8
 2440 1494 0300000A 		beq	.L174
 641:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2441              		.loc 1 641 0
 2442 1498 010052E3 		cmp	r2, #1
 642:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2443              		.loc 1 642 0
 2444 149c 07208202 		addeq	r2, r2, #7
 644:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2445              		.loc 1 644 0
 2446 14a0 0220A013 		movne	r2, #2
 2447 14a4 B524C3E5 		strb	r2, [r3, #1205]
 2448              	.LVL194:
 2449              	.L174:
 666:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2450              		.loc 1 666 0
 2451 14a8 D0459FE5 		ldr	r4, .L215+36
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2452              		.loc 1 664 0
 2453 14ac 0120A0E3 		mov	r2, #1
 666:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2454              		.loc 1 666 0
 2455 14b0 0010E0E3 		mvn	r1, #0
 664:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2456              		.loc 1 664 0
 2457 14b4 1023C6E5 		strb	r2, [r6, #784]
 2458              	.LVL195:
 666:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2459              		.loc 1 666 0
 2460 14b8 1C0094E5 		ldr	r0, [r4, #28]
 2461 14bc FEFFFFEB 		bl	_txe_mutex_get
 667:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2462              		.loc 1 667 0
 2463 14c0 18C09DE5 		ldr	ip, [sp, #24]
 2464 14c4 1010A0E3 		mov	r1, #16
 2465 14c8 00C08DE5 		str	ip, [sp, #0]
 2466 14cc 0920A0E1 		mov	r2, r9
 2467 14d0 0A30A0E1 		mov	r3, sl
 2468 14d4 0400A0E1 		mov	r0, r4
 2469 14d8 00C0A0E3 		mov	ip, #0
 2470              	.LVL196:
 2471              	.L206:
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2472              		.loc 1 872 0
 2473 14dc 04C08DE5 		str	ip, [sp, #4]
 2474 14e0 FEFFFFEB 		bl	cmdSet
 873:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2475              		.loc 1 873 0
 2476 14e4 1C0094E5 		ldr	r0, [r4, #28]
 2477 14e8 FEFFFFEB 		bl	_txe_mutex_put
 875:../uvc.c      **** 					 		 break;
 2478              		.loc 1 875 0
 2479 14ec FFE0A0E3 		mov	lr, #255
 873:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2480              		.loc 1 873 0
 2481 14f0 18309DE5 		ldr	r3, [sp, #24]
 2482 14f4 1CC09DE5 		ldr	ip, [sp, #28]
 875:../uvc.c      **** 					 		 break;
 2483              		.loc 1 875 0
 2484 14f8 0E40A0E1 		mov	r4, lr
 2485 14fc C7FDFFEA 		b	.L119
 2486              	.LVL197:
 2487              	.L164:
 687:../uvc.c      **** 							 if(Data0 <= 3){
 2488              		.loc 1 687 0
 2489 1500 030053E3 		cmp	r3, #3
 688:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2490              		.loc 1 688 0
 2491 1504 5C259F95 		ldrls	r2, .L215+12
 2492              	.LVL198:
 691:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2493              		.loc 1 691 0
 2494 1508 58E59F85 		ldrhi	lr, .L215+12
 2495 150c 0340A0E1 		mov	r4, r3
 2496              	.LVL199:
 688:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2497              		.loc 1 688 0
 2498 1510 0030A093 		movls	r3, #0
 2499 1514 7830C295 		strlsb	r3, [r2, #120]
 2500              	.LVL200:
 691:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2501              		.loc 1 691 0
 2502 1518 0120A083 		movhi	r2, #1
 2503 151c 18209D95 		ldrls	r2, [sp, #24]
 688:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2504              		.loc 1 688 0
 2505 1520 0430A091 		movls	r3, r4
 691:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2506              		.loc 1 691 0
 2507 1524 7820CE85 		strhib	r2, [lr, #120]
 2508 1528 0420A081 		movhi	r2, r4
 697:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2509              		.loc 1 697 0
 2510 152c 4C459FE5 		ldr	r4, .L215+36
 692:../uvc.c      **** 								 Data1 = Data0-4;
 2511              		.loc 1 692 0
 2512 1530 04304382 		subhi	r3, r3, #4
 2513              	.LVL201:
 694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2514              		.loc 1 694 0
 2515 1534 2D24C6E5 		strb	r2, [r6, #1069]
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2516              		.loc 1 696 0
 2517 1538 0120A0E3 		mov	r2, #1
 697:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2518              		.loc 1 697 0
 2519 153c 0010E0E3 		mvn	r1, #0
 695:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2520              		.loc 1 695 0
 2521 1540 8D31C6E5 		strb	r3, [r6, #397]
 696:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2522              		.loc 1 696 0
 2523 1544 3024C6E5 		strb	r2, [r6, #1072]
 697:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2524              		.loc 1 697 0
 2525 1548 1C0094E5 		ldr	r0, [r4, #28]
 2526 154c FEFFFFEB 		bl	_txe_mutex_get
 2527              	.LVL202:
 698:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2528              		.loc 1 698 0
 2529 1550 18C09DE5 		ldr	ip, [sp, #24]
 2530 1554 1C10A0E3 		mov	r1, #28
 2531 1558 00C08DE5 		str	ip, [sp, #0]
 2532 155c 0920A0E1 		mov	r2, r9
 2533 1560 0A30A0E1 		mov	r3, sl
 2534 1564 0400A0E1 		mov	r0, r4
 2535 1568 00C0A0E3 		mov	ip, #0
 2536 156c DAFFFFEA 		b	.L206
 2537              	.LVL203:
 2538              	.L161:
 832:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2539              		.loc 1 832 0
 2540 1570 08459FE5 		ldr	r4, .L215+36
 2541 1574 0010E0E3 		mvn	r1, #0
 2542 1578 1C0094E5 		ldr	r0, [r4, #28]
 2543 157c FEFFFFEB 		bl	_txe_mutex_get
 2544              	.LVL204:
 833:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2545              		.loc 1 833 0
 2546 1580 18C09DE5 		ldr	ip, [sp, #24]
 2547 1584 0B10A0E3 		mov	r1, #11
 2548 1588 0920A0E1 		mov	r2, r9
 2549 158c 0A30A0E1 		mov	r3, sl
 2550 1590 0400A0E1 		mov	r0, r4
 2551 1594 00C08DE5 		str	ip, [sp, #0]
 2552 1598 00C0A0E3 		mov	ip, #0
 2553 159c 04C08DE5 		str	ip, [sp, #4]
 2554 15a0 FEFFFFEB 		bl	cmdSet
 2555              	.LVL205:
 835:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2556              		.loc 1 835 0
 2557 15a4 1CE09DE5 		ldr	lr, [sp, #28]
 2558 15a8 0B20A0E1 		mov	r2, fp
 2559 15ac 0A30A0E1 		mov	r3, sl
 2560 15b0 0170A0E3 		mov	r7, #1
 2561              	.LVL206:
 2562 15b4 0B10A0E3 		mov	r1, #11
 2563 15b8 0400A0E1 		mov	r0, r4
 2564 15bc 00E08DE5 		str	lr, [sp, #0]
 2565 15c0 04708DE5 		str	r7, [sp, #4]
 2566 15c4 FEFFFFEB 		bl	cmdSet
 836:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2567              		.loc 1 836 0
 2568 15c8 1C0094E5 		ldr	r0, [r4, #28]
 2569 15cc FEFFFFEB 		bl	_txe_mutex_put
 839:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2570              		.loc 1 839 0
 2571 15d0 1C209DE5 		ldr	r2, [sp, #28]
 838:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2572              		.loc 1 838 0
 2573 15d4 18309DE5 		ldr	r3, [sp, #24]
 841:../uvc.c      **** 							 break;
 2574              		.loc 1 841 0
 2575 15d8 FFE0A0E3 		mov	lr, #255
 838:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2576              		.loc 1 838 0
 2577 15dc 8C34C6E5 		strb	r3, [r6, #1164]
 839:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2578              		.loc 1 839 0
 2579 15e0 8E24C6E5 		strb	r2, [r6, #1166]
 840:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2580              		.loc 1 840 0
 2581 15e4 9872C6E5 		strb	r7, [r6, #664]
 2582 15e8 02C0A0E1 		mov	ip, r2
 841:../uvc.c      **** 							 break;
 2583              		.loc 1 841 0
 2584 15ec 0E40A0E1 		mov	r4, lr
 2585 15f0 8AFDFFEA 		b	.L119
 2586              	.LVL207:
 2587              	.L160:
 818:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2588              		.loc 1 818 0
 2589 15f4 84449FE5 		ldr	r4, .L215+36
 2590 15f8 0010E0E3 		mvn	r1, #0
 2591 15fc 1C0094E5 		ldr	r0, [r4, #28]
 2592 1600 FEFFFFEB 		bl	_txe_mutex_get
 2593              	.LVL208:
 819:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2594              		.loc 1 819 0
 2595 1604 18C09DE5 		ldr	ip, [sp, #24]
 2596 1608 0610A0E3 		mov	r1, #6
 2597 160c 0920A0E1 		mov	r2, r9
 2598 1610 0A30A0E1 		mov	r3, sl
 2599 1614 0400A0E1 		mov	r0, r4
 2600 1618 00C08DE5 		str	ip, [sp, #0]
 2601 161c 00C0A0E3 		mov	ip, #0
 2602 1620 04C08DE5 		str	ip, [sp, #4]
 2603 1624 FEFFFFEB 		bl	cmdSet
 2604              	.LVL209:
 821:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2605              		.loc 1 821 0
 2606 1628 18E09DE5 		ldr	lr, [sp, #24]
 2607 162c 0A30A0E1 		mov	r3, sl
 2608 1630 0170A0E3 		mov	r7, #1
 2609              	.LVL210:
 2610 1634 0610A0E3 		mov	r1, #6
 2611 1638 0B20A0E1 		mov	r2, fp
 2612 163c 0400A0E1 		mov	r0, r4
 2613 1640 00E08DE5 		str	lr, [sp, #0]
 2614 1644 04708DE5 		str	r7, [sp, #4]
 2615 1648 FEFFFFEB 		bl	cmdSet
 822:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2616              		.loc 1 822 0
 2617 164c 1C0094E5 		ldr	r0, [r4, #28]
 2618 1650 FEFFFFEB 		bl	_txe_mutex_put
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2619              		.loc 1 823 0
 2620 1654 18409DE5 		ldr	r4, [sp, #24]
 825:../uvc.c      **** 							 break;
 2621              		.loc 1 825 0
 2622 1658 FFE0A0E3 		mov	lr, #255
 823:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2623              		.loc 1 823 0
 2624 165c 1D42C6E5 		strb	r4, [r6, #541]
 824:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2625              		.loc 1 824 0
 2626 1660 0430A0E1 		mov	r3, r4
 2627 1664 2072C6E5 		strb	r7, [r6, #544]
 2628 1668 1CC09DE5 		ldr	ip, [sp, #28]
 825:../uvc.c      **** 							 break;
 2629              		.loc 1 825 0
 2630 166c 0E40A0E1 		mov	r4, lr
 2631 1670 6AFDFFEA 		b	.L119
 2632              	.LVL211:
 2633              	.L159:
 798:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2634              		.loc 1 798 0
 2635 1674 04449FE5 		ldr	r4, .L215+36
 2636 1678 0010E0E3 		mvn	r1, #0
 2637 167c 1C0094E5 		ldr	r0, [r4, #28]
 2638 1680 FEFFFFEB 		bl	_txe_mutex_get
 2639              	.LVL212:
 799:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2640              		.loc 1 799 0
 2641 1684 18109DE5 		ldr	r1, [sp, #24]
 2642 1688 00E0A0E3 		mov	lr, #0
 2643 168c 802041E2 		sub	r2, r1, #128
 2644 1690 FFC002E2 		and	ip, r2, #255
 2645 1694 0510A0E3 		mov	r1, #5
 2646 1698 0920A0E1 		mov	r2, r9
 2647 169c 0A30A0E1 		mov	r3, sl
 2648 16a0 0400A0E1 		mov	r0, r4
 2649 16a4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2650 16a8 FEFFFFEB 		bl	cmdSet
 2651              	.LVL213:
 801:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2652              		.loc 1 801 0
 2653 16ac 18009DE5 		ldr	r0, [sp, #24]
 2654 16b0 0510A0E3 		mov	r1, #5
 2655 16b4 767040E2 		sub	r7, r0, #118
 2656              	.LVL214:
 2657 16b8 FFC007E2 		and	ip, r7, #255
 2658 16bc DC20A0E3 		mov	r2, #220
 2659 16c0 0170A0E3 		mov	r7, #1
 2660 16c4 0A30A0E1 		mov	r3, sl
 2661 16c8 0400A0E1 		mov	r0, r4
 2662 16cc 00C08DE5 		str	ip, [sp, #0]
 2663 16d0 04708DE5 		str	r7, [sp, #4]
 2664 16d4 FEFFFFEB 		bl	cmdSet
 2665              	.LVL215:
 803:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2666              		.loc 1 803 0
 2667 16d8 18309DE5 		ldr	r3, [sp, #24]
 2668 16dc DE20A0E3 		mov	r2, #222
 2669 16e0 7E1083E2 		add	r1, r3, #126
 2670 16e4 FFC001E2 		and	ip, r1, #255
 2671 16e8 0A30A0E1 		mov	r3, sl
 2672 16ec 0510A0E3 		mov	r1, #5
 2673 16f0 0400A0E1 		mov	r0, r4
 2674 16f4 00C08DE5 		str	ip, [sp, #0]
 2675 16f8 02C0A0E3 		mov	ip, #2
 2676 16fc 04C08DE5 		str	ip, [sp, #4]
 2677 1700 FEFFFFEB 		bl	cmdSet
 2678              	.LVL216:
 805:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2679              		.loc 1 805 0
 2680 1704 18209DE5 		ldr	r2, [sp, #24]
 2681 1708 0510A0E3 		mov	r1, #5
 2682 170c 720082E2 		add	r0, r2, #114
 2683 1710 FFC000E2 		and	ip, r0, #255
 2684 1714 E020A0E3 		mov	r2, #224
 2685 1718 0A30A0E1 		mov	r3, sl
 2686 171c 0400A0E1 		mov	r0, r4
 2687 1720 00C08DE5 		str	ip, [sp, #0]
 2688 1724 03C0A0E3 		mov	ip, #3
 2689 1728 04C08DE5 		str	ip, [sp, #4]
 2690 172c FEFFFFEB 		bl	cmdSet
 2691              	.LVL217:
 807:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2692              		.loc 1 807 0
 2693 1730 18309DE5 		ldr	r3, [sp, #24]
 2694 1734 DD20A0E3 		mov	r2, #221
 2695 1738 6F1043E2 		sub	r1, r3, #111
 2696 173c FFC001E2 		and	ip, r1, #255
 2697 1740 0A30A0E1 		mov	r3, sl
 2698 1744 0510A0E3 		mov	r1, #5
 2699 1748 0400A0E1 		mov	r0, r4
 2700 174c 00C08DE5 		str	ip, [sp, #0]
 2701 1750 04C0A0E3 		mov	ip, #4
 2702 1754 04C08DE5 		str	ip, [sp, #4]
 2703 1758 FEFFFFEB 		bl	cmdSet
 2704              	.LVL218:
 809:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2705              		.loc 1 809 0
 2706 175c 04239FE5 		ldr	r2, .L215+12
 2707 1760 05E0A0E3 		mov	lr, #5
 2708 1764 5800D2E5 		ldrb	r0, [r2, #88]	@ zero_extendqisi2
 2709 1768 0E10A0E1 		mov	r1, lr
 2710 176c 7F3080E2 		add	r3, r0, #127
 2711 1770 FFC003E2 		and	ip, r3, #255
 2712 1774 0B20A0E1 		mov	r2, fp
 2713 1778 0A30A0E1 		mov	r3, sl
 2714 177c 0400A0E1 		mov	r0, r4
 2715 1780 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2716 1784 FEFFFFEB 		bl	cmdSet
 810:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2717              		.loc 1 810 0
 2718 1788 1C0094E5 		ldr	r0, [r4, #28]
 2719 178c FEFFFFEB 		bl	_txe_mutex_put
 812:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2720              		.loc 1 812 0
 2721 1790 D0129FE5 		ldr	r1, .L215+12
 814:../uvc.c      **** 							 break;
 2722              		.loc 1 814 0
 2723 1794 FFE0A0E3 		mov	lr, #255
 812:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2724              		.loc 1 812 0
 2725 1798 58C0D1E5 		ldrb	ip, [r1, #88]	@ zero_extendqisi2
 813:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2726              		.loc 1 813 0
 2727 179c 0872C6E5 		strb	r7, [r6, #520]
 812:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2728              		.loc 1 812 0
 2729 17a0 80204CE2 		sub	r2, ip, #128
 2730 17a4 0522C6E5 		strb	r2, [r6, #517]
 813:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2731              		.loc 1 813 0
 2732 17a8 18309DE5 		ldr	r3, [sp, #24]
 2733 17ac 1CC09DE5 		ldr	ip, [sp, #28]
 814:../uvc.c      **** 							 break;
 2734              		.loc 1 814 0
 2735 17b0 0E40A0E1 		mov	r4, lr
 2736 17b4 19FDFFEA 		b	.L119
 2737              	.LVL219:
 2738              	.L158:
 850:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2739              		.loc 1 850 0
 2740 17b8 C0429FE5 		ldr	r4, .L215+36
 844:../uvc.c      **** 							 Data0 = Data0 - 1;
 2741              		.loc 1 844 0
 2742 17bc 017043E2 		sub	r7, r3, #1
 2743              	.LVL220:
 2744 17c0 FF7007E2 		and	r7, r7, #255
 2745              	.LVL221:
 848:../uvc.c      **** 								 Data0 = 1;
 2746              		.loc 1 848 0
 2747 17c4 020057E3 		cmp	r7, #2
 850:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2748              		.loc 1 850 0
 2749 17c8 0010E0E3 		mvn	r1, #0
 2750 17cc 1C0094E5 		ldr	r0, [r4, #28]
 848:../uvc.c      **** 								 Data0 = 1;
 2751              		.loc 1 848 0
 2752 17d0 0170A083 		movhi	r7, #1
 2753              	.LVL222:
 850:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2754              		.loc 1 850 0
 2755 17d4 FEFFFFEB 		bl	_txe_mutex_get
 2756              	.LVL223:
 852:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2757              		.loc 1 852 0
 2758 17d8 1C0094E5 		ldr	r0, [r4, #28]
 2759 17dc FEFFFFEB 		bl	_txe_mutex_put
 856:../uvc.c      **** 							 break;
 2760              		.loc 1 856 0
 2761 17e0 FFE0A0E3 		mov	lr, #255
 855:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2762              		.loc 1 855 0
 2763 17e4 0100A0E3 		mov	r0, #1
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2764              		.loc 1 854 0
 2765 17e8 ED71C6E5 		strb	r7, [r6, #493]
 855:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2766              		.loc 1 855 0
 2767 17ec F001C6E5 		strb	r0, [r6, #496]
 2768 17f0 18309DE5 		ldr	r3, [sp, #24]
 2769 17f4 1CC09DE5 		ldr	ip, [sp, #28]
 856:../uvc.c      **** 							 break;
 2770              		.loc 1 856 0
 2771 17f8 0E40A0E1 		mov	r4, lr
 2772 17fc 07FDFFEA 		b	.L119
 2773              	.LVL224:
 2774              	.L157:
 774:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2775              		.loc 1 774 0
 2776 1800 78729FE5 		ldr	r7, .L215+36
 2777              	.LVL225:
 2778 1804 0010E0E3 		mvn	r1, #0
 2779 1808 1C0097E5 		ldr	r0, [r7, #28]
 2780 180c FEFFFFEB 		bl	_txe_mutex_get
 2781              	.LVL226:
 776:../uvc.c      **** 							  if(Data0&0x80){
 2782              		.loc 1 776 0
 2783 1810 18809DE5 		ldr	r8, [sp, #24]
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2784              		.loc 1 777 0
 2785 1814 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 776:../uvc.c      **** 							  if(Data0&0x80){
 2786              		.loc 1 776 0
 2787 1818 800018E3 		tst	r8, #128
 779:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2788              		.loc 1 779 0
 2789 181c 2843A001 		moveq	r4, r8, lsr #6
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2790              		.loc 1 777 0
 2791 1820 884CA011 		movne	r4, r8, asl #25
 779:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2792              		.loc 1 779 0
 2793 1824 02408403 		orreq	r4, r4, #2
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2794              		.loc 1 777 0
 2795 1828 0300C013 		bicne	r0, r0, #3
 779:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2796              		.loc 1 779 0
 2797 182c 0300C003 		biceq	r0, r0, #3
 777:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2798              		.loc 1 777 0
 2799 1830 A44F8011 		orrne	r4, r0, r4, lsr #31
 779:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2800              		.loc 1 779 0
 2801 1834 00408401 		orreq	r4, r4, r0
 2802              	.LVL227:
 781:../uvc.c      **** 							 Data1 |= ~0x03;
 2803              		.loc 1 781 0
 2804 1838 043FE0E1 		mvn	r3, r4, asl #30
 2805 183c 231FE0E1 		mvn	r1, r3, lsr #30
 2806              	.LVL228:
 782:../uvc.c      **** 							 Data1 &= 0xC7;
 2807              		.loc 1 782 0
 2808 1840 C7C001E2 		and	ip, r1, #199
 2809              	.LVL229:
 783:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2810              		.loc 1 783 0
 2811 1844 00E0A0E3 		mov	lr, #0
 2812 1848 0110A0E3 		mov	r1, #1
 2813 184c 0B20A0E1 		mov	r2, fp
 2814 1850 0A30A0E1 		mov	r3, sl
 2815 1854 24029FE5 		ldr	r0, .L215+36
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2816              		.loc 1 787 0
 2817 1858 0140A0E1 		mov	r4, r1
 783:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2818              		.loc 1 783 0
 2819 185c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2820 1860 14C08DE5 		str	ip, [sp, #20]
 2821 1864 FEFFFFEB 		bl	cmdSet
 2822              	.LVL230:
 786:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2823              		.loc 1 786 0
 2824 1868 18209DE5 		ldr	r2, [sp, #24]
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2825              		.loc 1 787 0
 2826 186c 0410A0E1 		mov	r1, r4
 786:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2827              		.loc 1 786 0
 2828 1870 0281A0E1 		mov	r8, r2, asl #2
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2829              		.loc 1 787 0
 2830 1874 0A30A0E1 		mov	r3, sl
 786:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2831              		.loc 1 786 0
 2832 1878 FF8008E2 		and	r8, r8, #255
 2833              	.LVL231:
 787:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2834              		.loc 1 787 0
 2835 187c 0920A0E1 		mov	r2, r9
 2836 1880 F8019FE5 		ldr	r0, .L215+36
 2837 1884 04408DE5 		str	r4, [sp, #4]
 2838 1888 00808DE5 		str	r8, [sp, #0]
 2839 188c FEFFFFEB 		bl	cmdSet
 788:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2840              		.loc 1 788 0
 2841 1890 1C0097E5 		ldr	r0, [r7, #28]
 2842 1894 FEFFFFEB 		bl	_txe_mutex_put
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2843              		.loc 1 790 0
 2844 1898 A581C6E5 		strb	r8, [r6, #421]
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2845              		.loc 1 791 0
 2846 189c 14009DE5 		ldr	r0, [sp, #20]
 794:../uvc.c      **** 							 break;
 2847              		.loc 1 794 0
 2848 18a0 FFE0A0E3 		mov	lr, #255
 792:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2849              		.loc 1 792 0
 2850 18a4 A841C6E5 		strb	r4, [r6, #424]
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2851              		.loc 1 791 0
 2852 18a8 A601C6E5 		strb	r0, [r6, #422]
 792:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2853              		.loc 1 792 0
 2854 18ac 18309DE5 		ldr	r3, [sp, #24]
 2855 18b0 1CC09DE5 		ldr	ip, [sp, #28]
 794:../uvc.c      **** 							 break;
 2856              		.loc 1 794 0
 2857 18b4 0E40A0E1 		mov	r4, lr
 2858 18b8 D8FCFFEA 		b	.L119
 2859              	.LVL232:
 2860              	.L156:
 860:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2861              		.loc 1 860 0
 2862 18bc A4219FE5 		ldr	r2, .L215+12
 2863              	.LVL233:
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2864              		.loc 1 859 0
 2865 18c0 0110A0E3 		mov	r1, #1
 860:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2866              		.loc 1 860 0
 2867 18c4 7820D2E5 		ldrb	r2, [r2, #120]	@ zero_extendqisi2
 858:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2868              		.loc 1 858 0
 2869 18c8 8D31C6E5 		strb	r3, [r6, #397]
 860:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2870              		.loc 1 860 0
 2871 18cc 010052E3 		cmp	r2, #1
 859:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2872              		.loc 1 859 0
 2873 18d0 9011C6E5 		strb	r1, [r6, #400]
 2874 18d4 0370A011 		movne	r7, r3
 2875              	.LVL234:
 860:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2876              		.loc 1 860 0
 2877 18d8 4E00000A 		beq	.L214
 2878              	.LVL235:
 2879              	.L189:
 871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2880              		.loc 1 871 0
 2881 18dc 9C419FE5 		ldr	r4, .L215+36
 2882 18e0 0010E0E3 		mvn	r1, #0
 2883 18e4 1C0094E5 		ldr	r0, [r4, #28]
 869:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2884              		.loc 1 869 0
 2885 18e8 2D74C6E5 		strb	r7, [r6, #1069]
 2886              	.LVL236:
 871:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2887              		.loc 1 871 0
 2888 18ec FEFFFFEB 		bl	_txe_mutex_get
 872:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2889              		.loc 1 872 0
 2890 18f0 00C0A0E3 		mov	ip, #0
 2891 18f4 0C10A0E1 		mov	r1, ip
 2892 18f8 0920A0E1 		mov	r2, r9
 2893 18fc 0A30A0E1 		mov	r3, sl
 2894 1900 0400A0E1 		mov	r0, r4
 2895 1904 00708DE5 		str	r7, [sp, #0]
 2896 1908 F3FEFFEA 		b	.L206
 2897              	.LVL237:
 2898              	.L155:
 879:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2899              		.loc 1 879 0
 2900 190c 6C719FE5 		ldr	r7, .L215+36
 2901              	.LVL238:
 2902 1910 0010E0E3 		mvn	r1, #0
 2903 1914 1C0097E5 		ldr	r0, [r7, #28]
 2904 1918 FEFFFFEB 		bl	_txe_mutex_get
 2905              	.LVL239:
 880:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2906              		.loc 1 880 0
 2907 191c 18C09DE5 		ldr	ip, [sp, #24]
 2908 1920 00E0A0E3 		mov	lr, #0
 2909 1924 0410A0E1 		mov	r1, r4
 2910 1928 0A30A0E1 		mov	r3, sl
 2911 192c 0920A0E1 		mov	r2, r9
 2912 1930 0700A0E1 		mov	r0, r7
 2913 1934 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2914 1938 FEFFFFEB 		bl	cmdSet
 881:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2915              		.loc 1 881 0
 2916 193c 1C0097E5 		ldr	r0, [r7, #28]
 2917 1940 FEFFFFEB 		bl	_txe_mutex_put
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2918              		.loc 1 883 0
 2919 1944 18C09DE5 		ldr	ip, [sp, #24]
 2920 1948 840084E0 		add	r0, r4, r4, asl #1
 2921 194c 806186E0 		add	r6, r6, r0, asl #3
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2922              		.loc 1 884 0
 2923 1950 0130A0E3 		mov	r3, #1
 885:../uvc.c      **** 							 break;
 2924              		.loc 1 885 0
 2925 1954 FFE0A0E3 		mov	lr, #255
 883:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2926              		.loc 1 883 0
 2927 1958 8DC1C6E5 		strb	ip, [r6, #397]
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2928              		.loc 1 884 0
 2929 195c 9031C6E5 		strb	r3, [r6, #400]
 885:../uvc.c      **** 							 break;
 2930              		.loc 1 885 0
 2931 1960 0E40A0E1 		mov	r4, lr
 884:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2932              		.loc 1 884 0
 2933 1964 0C30A0E1 		mov	r3, ip
 2934 1968 1CC09DE5 		ldr	ip, [sp, #28]
 885:../uvc.c      **** 							 break;
 2935              		.loc 1 885 0
 2936 196c ABFCFFEA 		b	.L119
 2937              	.LVL240:
 2938              	.L154:
 888:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2939              		.loc 1 888 0
 2940 1970 0400A0E3 		mov	r0, #4
 2941              	.LVL241:
 2942 1974 10119FE5 		ldr	r1, .L215+48
 2943 1978 FEFFFFEB 		bl	CyU3PDebugPrint
 2944              	.LVL242:
 2945 197c FFE0A0E3 		mov	lr, #255
 2946 1980 0E40A0E1 		mov	r4, lr
 2947 1984 0EC0A0E1 		mov	ip, lr
 2948 1988 0E30A0E1 		mov	r3, lr
 2949 198c A3FCFFEA 		b	.L119
 2950              	.LVL243:
 2951              	.L213:
 464:../uvc.c      **** 						if(sendData >= 3){
 2952              		.loc 1 464 0
 2953 1990 020054E3 		cmp	r4, #2
 2954 1994 04408492 		addls	r4, r4, #4
 2955              	.LVL244:
 2956 1998 FF400492 		andls	r4, r4, #255
 2957 199c CAFDFF9A 		bls	.L132
 465:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2958              		.loc 1 465 0
 2959 19a0 0430A0E1 		mov	r3, r4
 2960 19a4 0400A0E3 		mov	r0, #4
 2961 19a8 E0109FE5 		ldr	r1, .L215+52
 2962 19ac FEFFFFEB 		bl	CyU3PDebugPrint
 2963              	.LVL245:
 467:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2964              		.loc 1 467 0
 2965 19b0 A4309FE5 		ldr	r3, .L215
 2966 19b4 0020A0E3 		mov	r2, #0
 2967 19b8 0440A0E3 		mov	r4, #4
 2968 19bc 2D24C3E5 		strb	r2, [r3, #1069]
 2969              	.LVL246:
 2970 19c0 C1FDFFEA 		b	.L132
 2971              	.LVL247:
 2972              	.L173:
 649:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2973              		.loc 1 649 0
 2974 19c4 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2975              	.LVL248:
 648:../uvc.c      **** 								 Data1 = Data0 - 1;
 2976              		.loc 1 648 0
 2977 19c8 014041E2 		sub	r4, r1, #1
 649:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2978              		.loc 1 649 0
 2979 19cc 040052E3 		cmp	r2, #4
 2980 19d0 01005213 		cmpne	r2, #1
 648:../uvc.c      **** 								 Data1 = Data0 - 1;
 2981              		.loc 1 648 0
 2982 19d4 FF1004E2 		and	r1, r4, #255
 2983              	.LVL249:
 649:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2984              		.loc 1 649 0
 2985 19d8 0300000A 		beq	.L176
 650:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2986              		.loc 1 650 0
 2987 19dc 080052E3 		cmp	r2, #8
 651:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2988              		.loc 1 651 0
 2989 19e0 0120A003 		moveq	r2, #1
 653:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2990              		.loc 1 653 0
 2991 19e4 0420A013 		movne	r2, #4
 2992 19e8 B524C3E5 		strb	r2, [r3, #1205]
 2993              	.L176:
 656:../uvc.c      **** 								 if(Data1 < 8){
 2994              		.loc 1 656 0
 2995 19ec 070051E3 		cmp	r1, #7
 657:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2996              		.loc 1 657 0
 2997 19f0 9C309F95 		ldrls	r3, .L215+56
 660:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2998              		.loc 1 660 0
 2999 19f4 0130A083 		movhi	r3, #1
 658:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3000              		.loc 1 658 0
 3001 19f8 81008390 		addls	r0, r3, r1, asl #1
 657:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3002              		.loc 1 657 0
 3003 19fc 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 658:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3004              		.loc 1 658 0
 3005 1a00 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 660:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3006              		.loc 1 660 0
 3007 1a04 E534C685 		strhib	r3, [r6, #1253]
 661:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3008              		.loc 1 661 0
 3009 1a08 0030A083 		movhi	r3, #0
 657:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3010              		.loc 1 657 0
 3011 1a0c E524C695 		strlsb	r2, [r6, #1253]
 661:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3012              		.loc 1 661 0
 3013 1a10 E634C6E5 		strb	r3, [r6, #1254]
 3014 1a14 A3FEFFEA 		b	.L174
 3015              	.LVL250:
 3016              	.L214:
 862:../uvc.c      **** 								 if(Data0 < 3){
 3017              		.loc 1 862 0
 3018 1a18 020053E3 		cmp	r3, #2
 863:../uvc.c      **** 					 				 Data0 += 4;
 3019              		.loc 1 863 0
 3020 1a1c 04708392 		addls	r7, r3, #4
 3021 1a20 FF700792 		andls	r7, r7, #255
 862:../uvc.c      **** 								 if(Data0 < 3){
 3022              		.loc 1 862 0
 3023 1a24 ACFFFF9A 		bls	.L189
 865:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3024              		.loc 1 865 0
 3025 1a28 0400A0E3 		mov	r0, #4
 3026 1a2c 5C109FE5 		ldr	r1, .L215+52
 3027 1a30 18309DE5 		ldr	r3, [sp, #24]
 3028 1a34 FEFFFFEB 		bl	CyU3PDebugPrint
 3029              	.LVL251:
 866:../uvc.c      **** 									Data0 = 4; //set to default.
 3030              		.loc 1 866 0
 3031 1a38 0470A0E3 		mov	r7, #4
 3032 1a3c A6FFFFEA 		b	.L189
 3033              	.LVL252:
 3034              	.L204:
 3035 1a40 20009FE5 		ldr	r0, .L215+12
 3036 1a44 8FFDFFEA 		b	.L130
 3037              	.LVL253:
 3038              	.L192:
 408:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3039              		.loc 1 408 0
 3040 1a48 0030A0E3 		mov	r3, #0
 3041 1a4c 35FEFFEA 		b	.L197
 3042              	.LVL254:
 3043              	.L191:
 3044 1a50 10009FE5 		ldr	r0, .L215+12
 3045 1a54 0030A0E3 		mov	r3, #0
 3046 1a58 83FDFFEA 		b	.L196
 3047              	.L216:
 3048              		.align	2
 3049              	.L215:
 3050 1a5c 00000000 		.word	.LANCHOR1
 3051 1a60 00000000 		.word	bRequest
 3052 1a64 48030000 		.word	.LC20
 3053 1a68 00000000 		.word	.LANCHOR0
 3054 1a6c 58000000 		.word	.LANCHOR0+88
 3055 1a70 01000100 		.word	65537
 3056 1a74 FF00FF00 		.word	16711935
 3057 1a78 88020000 		.word	.LC16
 3058 1a7c C4020000 		.word	.LC17
 3059 1a80 00000000 		.word	cmdQu
 3060 1a84 4C000000 		.word	.LANCHOR0+76
 3061 1a88 EC020000 		.word	.LC18
 3062 1a8c 18030000 		.word	.LC19
 3063 1a90 50020000 		.word	.LC15
 3064 1a94 00000000 		.word	.LANCHOR2
 3065              		.cfi_endproc
 3066              	.LFE2:
 3068              		.align	2
 3069              		.global	CTControlHandle
 3071              	CTControlHandle:
 3072              	.LFB3:
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3073              		.loc 1 904 0
 3074              		.cfi_startproc
 3075              		@ args = 0, pretend = 0, frame = 64
 3076              		@ frame_needed = 0, uses_anonymous_args = 0
 3077              	.LVL255:
 3078 1a98 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3079              	.LCFI15:
 3080              		.cfi_def_cfa_offset 36
 923:../uvc.c      ****     reqData = bRequest;
 3081              		.loc 1 923 0
 3082 1a9c 60A99FE5 		ldr	sl, .L302
 3083              		.cfi_offset 14, -4
 3084              		.cfi_offset 11, -8
 3085              		.cfi_offset 10, -12
 3086              		.cfi_offset 9, -16
 3087              		.cfi_offset 8, -20
 3088              		.cfi_offset 7, -24
 3089              		.cfi_offset 6, -28
 3090              		.cfi_offset 5, -32
 3091              		.cfi_offset 4, -36
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3092              		.loc 1 915 0
 3093 1aa0 60899FE5 		ldr	r8, .L302+4
 923:../uvc.c      ****     reqData = bRequest;
 3094              		.loc 1 923 0
 3095 1aa4 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3096              		.loc 1 915 0
 3097 1aa8 8090A0E1 		mov	r9, r0, asl #1
 3098 1aac 002089E0 		add	r2, r9, r0
 3099 1ab0 822188E0 		add	r2, r8, r2, asl #3
 925:../uvc.c      ****     switch (bRequest)
 3100              		.loc 1 925 0
 3101 1ab4 830055E3 		cmp	r5, #131
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3102              		.loc 1 904 0
 3103 1ab8 5CD04DE2 		sub	sp, sp, #92
 3104              	.LCFI16:
 3105              		.cfi_def_cfa_offset 128
 904:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3106              		.loc 1 904 0
 3107 1abc 0060A0E1 		mov	r6, r0
 915:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3108              		.loc 1 915 0
 3109 1ac0 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3110              	.LVL256:
 916:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3111              		.loc 1 916 0
 3112 1ac4 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3113              	.LVL257:
 918:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3114              		.loc 1 918 0
 3115 1ac8 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3116              	.LVL258:
 925:../uvc.c      ****     switch (bRequest)
 3117              		.loc 1 925 0
 3118 1acc 7600000A 		beq	.L222
 3119 1ad0 2100009A 		bls	.L297
 3120 1ad4 850055E3 		cmp	r5, #133
 3121 1ad8 5900000A 		beq	.L224
 3122 1adc 4E00003A 		bcc	.L223
 3123 1ae0 860055E3 		cmp	r5, #134
 3124 1ae4 8000000A 		beq	.L225
 3125 1ae8 870055E3 		cmp	r5, #135
 3126 1aec 7600000A 		beq	.L298
 3127              	.L218:
1132:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3128              		.loc 1 1132 0
 3129 1af0 0000A0E3 		mov	r0, #0
 3130              	.LVL259:
 3131 1af4 0110A0E3 		mov	r1, #1
 3132 1af8 0020A0E1 		mov	r2, r0
 3133 1afc FEFFFFEB 		bl	CyU3PUsbStall
 3134              	.LVL260:
 3135 1b00 04499FE5 		ldr	r4, .L302+8
1133:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3136              		.loc 1 1133 0
 3137 1b04 0620A0E1 		mov	r2, r6
 3138 1b08 0400A0E3 		mov	r0, #4
 3139 1b0c FC189FE5 		ldr	r1, .L302+12
 3140 1b10 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3141 1b14 FEFFFFEB 		bl	CyU3PDebugPrint
1134:../uvc.c      **** 			  break;
 3142              		.loc 1 1134 0
 3143 1b18 FFC0A0E3 		mov	ip, #255
 3144 1b1c 0C60A0E1 		mov	r6, ip
 3145 1b20 0C80A0E1 		mov	r8, ip
 3146              	.LVL261:
 3147              	.L228:
1138:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3148              		.loc 1 1138 0
 3149 1b24 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3150 1b28 08C08DE5 		str	ip, [sp, #8]
 3151 1b2c E0189FE5 		ldr	r1, .L302+16
 3152 1b30 FFC0A0E3 		mov	ip, #255
 3153 1b34 0520A0E1 		mov	r2, r5
 3154 1b38 0830A0E1 		mov	r3, r8
 3155 1b3c 0400A0E3 		mov	r0, #4
 3156 1b40 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3157 1b44 0CC08DE5 		str	ip, [sp, #12]
 3158 1b48 10E08DE5 		str	lr, [sp, #16]
 3159 1b4c 14708DE5 		str	r7, [sp, #20]
 3160 1b50 FEFFFFEB 		bl	CyU3PDebugPrint
1139:../uvc.c      **** }
 3161              		.loc 1 1139 0
 3162 1b54 5CD08DE2 		add	sp, sp, #92
 3163 1b58 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3164              	.LVL262:
 3165              	.L297:
 925:../uvc.c      ****     switch (bRequest)
 3166              		.loc 1 925 0
 3167 1b5c 810055E3 		cmp	r5, #129
 3168 1b60 4200000A 		beq	.L220
 3169 1b64 1100009A 		bls	.L299
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3170              		.loc 1 954 0
 3171 1b68 9C489FE5 		ldr	r4, .L302+8
 3172 1b6c 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3173              		.loc 1 955 0
 3174 1b70 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3175              		.loc 1 956 0
 3176 1b74 0A0050E3 		cmp	r0, #10
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3177              		.loc 1 954 0
 3178 1b78 5810C4E5 		strb	r1, [r4, #88]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3179              		.loc 1 955 0
 3180 1b7c 5960C4E5 		strb	r6, [r4, #89]
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3181              		.loc 1 956 0
 3182 1b80 2C00000A 		beq	.L296
 3183              	.LVL263:
 3184              	.L235:
 990:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3185              		.loc 1 990 0
 3186 1b84 00E0A0E3 		mov	lr, #0
 3187 1b88 5AE0C4E5 		strb	lr, [r4, #90]
 3188              	.L236:
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3189              		.loc 1 991 0
 3190 1b8c 0030A0E3 		mov	r3, #0
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3191              		.loc 1 992 0
 3192 1b90 0700A0E1 		mov	r0, r7
 3193              	.LVL264:
 3194 1b94 7C189FE5 		ldr	r1, .L302+20
 994:../uvc.c      **** 			  break;
 3195              		.loc 1 994 0
 3196 1b98 FF60A0E3 		mov	r6, #255
 991:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3197              		.loc 1 991 0
 3198 1b9c 5B30C4E5 		strb	r3, [r4, #91]
 994:../uvc.c      **** 			  break;
 3199              		.loc 1 994 0
 3200 1ba0 0680A0E1 		mov	r8, r6
 992:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3201              		.loc 1 992 0
 3202 1ba4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3203              	.LVL265:
 3204 1ba8 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 994:../uvc.c      **** 			  break;
 3205              		.loc 1 994 0
 3206 1bac DCFFFFEA 		b	.L228
 3207              	.LVL266:
 3208              	.L299:
 925:../uvc.c      ****     switch (bRequest)
 3209              		.loc 1 925 0
 3210 1bb0 010055E3 		cmp	r5, #1
 3211 1bb4 CDFFFF1A 		bne	.L218
 996:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3212              		.loc 1 996 0
 3213 1bb8 4C489FE5 		ldr	r4, .L302+8
 3214 1bbc 56208DE2 		add	r2, sp, #86
 3215 1bc0 2000A0E3 		mov	r0, #32
 3216              	.LVL267:
 3217 1bc4 581084E2 		add	r1, r4, #88
 3218 1bc8 2C308DE5 		str	r3, [sp, #44]
 3219 1bcc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3220              	.LVL268:
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3221              		.loc 1 998 0
 3222 1bd0 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3223              		.loc 1 999 0
 3224 1bd4 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
1002:../uvc.c      **** 			  switch(CtrlID)
 3225              		.loc 1 1002 0
 3226 1bd8 012046E2 		sub	r2, r6, #1
 998:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3227              		.loc 1 998 0
 3228 1bdc 30008DE5 		str	r0, [sp, #48]
 3229              	.LVL269:
 999:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3230              		.loc 1 999 0
 3231 1be0 34C08DE5 		str	ip, [sp, #52]
 3232              	.LVL270:
1002:../uvc.c      **** 			  switch(CtrlID)
 3233              		.loc 1 1002 0
 3234 1be4 2C309DE5 		ldr	r3, [sp, #44]
 3235 1be8 090052E3 		cmp	r2, #9
 3236 1bec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3237 1bf0 550100EA 		b	.L237
 3238              	.L242:
 3239 1bf4 08210000 		.word	.L238
 3240 1bf8 4C210000 		.word	.L237
 3241 1bfc 181E0000 		.word	.L239
 3242 1c00 4C210000 		.word	.L237
 3243 1c04 4C210000 		.word	.L237
 3244 1c08 4C210000 		.word	.L237
 3245 1c0c 941D0000 		.word	.L240
 3246 1c10 4C210000 		.word	.L237
 3247 1c14 4C210000 		.word	.L237
 3248 1c18 181D0000 		.word	.L241
 3249              	.LVL271:
 3250              	.L223:
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3251              		.loc 1 972 0
 3252 1c1c E8479FE5 		ldr	r4, .L302+8
 3253 1c20 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3254              		.loc 1 973 0
 3255 1c24 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3256              		.loc 1 974 0
 3257 1c28 0A0050E3 		cmp	r0, #10
 972:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3258              		.loc 1 972 0
 3259 1c2c 5880C4E5 		strb	r8, [r4, #88]
 973:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3260              		.loc 1 973 0
 3261 1c30 5920C4E5 		strb	r2, [r4, #89]
 974:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3262              		.loc 1 974 0
 3263 1c34 D2FFFF1A 		bne	.L235
 3264              	.LVL272:
 3265              	.L296:
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3266              		.loc 1 989 0 discriminator 1
 3267 1c38 0110A0E3 		mov	r1, #1
 3268 1c3c 5A10C4E5 		strb	r1, [r4, #90]
 3269 1c40 D1FFFFEA 		b	.L236
 3270              	.LVL273:
 3271              	.L224:
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3272              		.loc 1 929 0
 3273 1c44 C0479FE5 		ldr	r4, .L302+8
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3274              		.loc 1 930 0
 3275 1c48 0030A0E3 		mov	r3, #0
 3276              	.LVL274:
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3277              		.loc 1 931 0
 3278 1c4c 0200A0E3 		mov	r0, #2
 3279              	.LVL275:
 3280 1c50 581084E2 		add	r1, r4, #88
 933:../uvc.c      **** 			  break;
 3281              		.loc 1 933 0
 3282 1c54 FF60A0E3 		mov	r6, #255
 929:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3283              		.loc 1 929 0
 3284 1c58 5870C4E5 		strb	r7, [r4, #88]
 930:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3285              		.loc 1 930 0
 3286 1c5c 5930C4E5 		strb	r3, [r4, #89]
 933:../uvc.c      **** 			  break;
 3287              		.loc 1 933 0
 3288 1c60 0680A0E1 		mov	r8, r6
 931:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3289              		.loc 1 931 0
 3290 1c64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3291              	.LVL276:
 3292 1c68 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 933:../uvc.c      **** 			  break;
 3293              		.loc 1 933 0
 3294 1c6c ACFFFFEA 		b	.L228
 3295              	.LVL277:
 3296              	.L220:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3297              		.loc 1 939 0
 3298 1c70 94479FE5 		ldr	r4, .L302+8
 3299 1c74 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3300              		.loc 1 940 0
 3301 1c78 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3302              		.loc 1 941 0
 3303 1c7c 0080A0E3 		mov	r8, #0
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3304              		.loc 1 947 0
 3305 1c80 0700A0E1 		mov	r0, r7
 3306              	.LVL278:
 3307 1c84 581084E2 		add	r1, r4, #88
 952:../uvc.c      **** 			  break;
 3308              		.loc 1 952 0
 3309 1c88 FF60A0E3 		mov	r6, #255
 940:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3310              		.loc 1 940 0
 3311 1c8c 59C0C4E5 		strb	ip, [r4, #89]
 941:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3312              		.loc 1 941 0
 3313 1c90 5A80C4E5 		strb	r8, [r4, #90]
 942:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3314              		.loc 1 942 0
 3315 1c94 5B80C4E5 		strb	r8, [r4, #91]
 3316              	.LVL279:
 939:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3317              		.loc 1 939 0
 3318 1c98 58A0C4E5 		strb	sl, [r4, #88]
 952:../uvc.c      **** 			  break;
 3319              		.loc 1 952 0
 3320 1c9c 0680A0E1 		mov	r8, r6
 947:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3321              		.loc 1 947 0
 3322 1ca0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3323              	.LVL280:
 3324 1ca4 0AC0A0E1 		mov	ip, sl
 952:../uvc.c      **** 			  break;
 3325              		.loc 1 952 0
 3326 1ca8 9DFFFFEA 		b	.L228
 3327              	.LVL281:
 3328              	.L222:
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3329              		.loc 1 963 0
 3330 1cac 58479FE5 		ldr	r4, .L302+8
 3331 1cb0 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3332              	.LVL282:
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3333              		.loc 1 964 0
 3334 1cb4 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3335              		.loc 1 965 0
 3336 1cb8 0A0050E3 		cmp	r0, #10
 963:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3337              		.loc 1 963 0
 3338 1cbc 5830C4E5 		strb	r3, [r4, #88]
 964:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3339              		.loc 1 964 0
 3340 1cc0 59E0C4E5 		strb	lr, [r4, #89]
 965:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3341              		.loc 1 965 0
 3342 1cc4 AEFFFF1A 		bne	.L235
 3343 1cc8 DAFFFFEA 		b	.L296
 3344              	.LVL283:
 3345              	.L298:
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3346              		.loc 1 987 0
 3347 1ccc 38479FE5 		ldr	r4, .L302+8
 3348 1cd0 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3349              		.loc 1 988 0
 3350 1cd4 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3351              		.loc 1 989 0
 3352 1cd8 0A0050E3 		cmp	r0, #10
 987:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3353              		.loc 1 987 0
 3354 1cdc 5860C4E5 		strb	r6, [r4, #88]
 988:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3355              		.loc 1 988 0
 3356 1ce0 59C0C4E5 		strb	ip, [r4, #89]
 989:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3357              		.loc 1 989 0
 3358 1ce4 A6FFFF1A 		bne	.L235
 3359 1ce8 D2FFFFEA 		b	.L296
 3360              	.L225:
 981:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3361              		.loc 1 981 0
 3362 1cec 18479FE5 		ldr	r4, .L302+8
 3363 1cf0 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3364              	.LVL284:
 3365 1cf4 0410A0E1 		mov	r1, r4
 3366 1cf8 5800E1E5 		strb	r0, [r1, #88]!
 985:../uvc.c      **** 			  break;
 3367              		.loc 1 985 0
 3368 1cfc FF60A0E3 		mov	r6, #255
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3369              		.loc 1 982 0
 3370 1d00 0100A0E3 		mov	r0, #1
 3371 1d04 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3372              	.LVL285:
 985:../uvc.c      **** 			  break;
 3373              		.loc 1 985 0
 3374 1d08 0680A0E1 		mov	r8, r6
 982:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3375              		.loc 1 982 0
 3376 1d0c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 985:../uvc.c      **** 			  break;
 3377              		.loc 1 985 0
 3378 1d10 0170A0E3 		mov	r7, #1
 3379 1d14 82FFFFEA 		b	.L228
 3380              	.LVL286:
 3381              	.L241:
1111:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3382              		.loc 1 1111 0
 3383 1d18 FC669FE5 		ldr	r6, .L302+24
 3384 1d1c 0010E0E3 		mvn	r1, #0
 3385 1d20 1C0096E5 		ldr	r0, [r6, #28]
 3386 1d24 2C308DE5 		str	r3, [sp, #44]
 3387 1d28 FEFFFFEB 		bl	_txe_mutex_get
1112:../uvc.c      **** 					  if(getData == 1)
 3388              		.loc 1 1112 0
 3389 1d2c 30E09DE5 		ldr	lr, [sp, #48]
 3390 1d30 2C309DE5 		ldr	r3, [sp, #44]
 3391 1d34 01005EE3 		cmp	lr, #1
 3392 1d38 A901000A 		beq	.L300
1114:../uvc.c      **** 					  else if(getData == 0xff)
 3393              		.loc 1 1114 0
 3394 1d3c FF005EE3 		cmp	lr, #255
 3395 1d40 9E01000A 		beq	.L301
1117:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3396              		.loc 1 1117 0
 3397 1d44 0080A0E3 		mov	r8, #0
 3398 1d48 0600A0E1 		mov	r0, r6
 3399 1d4c 1710A0E3 		mov	r1, #23
 3400 1d50 0B20A0E1 		mov	r2, fp
 3401 1d54 00808DE5 		str	r8, [sp, #0]
 3402 1d58 04808DE5 		str	r8, [sp, #4]
 3403 1d5c FEFFFFEB 		bl	cmdSet
 3404              	.L294:
1120:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3405              		.loc 1 1120 0
 3406 1d60 1C0096E5 		ldr	r0, [r6, #28]
 3407 1d64 FEFFFFEB 		bl	_txe_mutex_put
1122:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3408              		.loc 1 1122 0
 3409 1d68 30809DE5 		ldr	r8, [sp, #48]
 3410 1d6c 34609DE5 		ldr	r6, [sp, #52]
 3411 1d70 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3412 1d74 0400A0E3 		mov	r0, #4
 3413 1d78 A0169FE5 		ldr	r1, .L302+28
 3414 1d7c 0820A0E1 		mov	r2, r8
 3415 1d80 0630A0E1 		mov	r3, r6
 3416 1d84 00C08DE5 		str	ip, [sp, #0]
 3417 1d88 FEFFFFEB 		bl	CyU3PDebugPrint
1123:../uvc.c      **** 					  break;
 3418              		.loc 1 1123 0
 3419 1d8c FFC0A0E3 		mov	ip, #255
 3420 1d90 63FFFFEA 		b	.L228
 3421              	.LVL287:
 3422              	.L240:
1088:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3423              		.loc 1 1088 0
 3424 1d94 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3425 1d98 010058E3 		cmp	r8, #1
 3426 1d9c 08005813 		cmpne	r8, #8
 3427 1da0 0000A013 		movne	r0, #0
 3428 1da4 0100A003 		moveq	r0, #1
 3429 1da8 8001001A 		bne	.L291
 3430              	.LVL288:
1091:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3431              		.loc 1 1091 0
 3432 1dac 68869FE5 		ldr	r8, .L302+24
 3433 1db0 0010E0E3 		mvn	r1, #0
 3434 1db4 1C0098E5 		ldr	r0, [r8, #28]
 3435 1db8 2C308DE5 		str	r3, [sp, #44]
 3436 1dbc FEFFFFEB 		bl	_txe_mutex_get
1092:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3437              		.loc 1 1092 0
 3438 1dc0 30A09DE5 		ldr	sl, [sp, #48]
 3439 1dc4 1610A0E3 		mov	r1, #22
 3440 1dc8 0B20A0E1 		mov	r2, fp
 3441 1dcc 2C309DE5 		ldr	r3, [sp, #44]
 3442 1dd0 00C0A0E3 		mov	ip, #0
 3443 1dd4 0800A0E1 		mov	r0, r8
 3444 1dd8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3445 1ddc FEFFFFEB 		bl	cmdSet
1093:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3446              		.loc 1 1093 0
 3447 1de0 1C0098E5 		ldr	r0, [r8, #28]
 3448 1de4 FEFFFFEB 		bl	_txe_mutex_put
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3449              		.loc 1 1096 0
 3450 1de8 18069FE5 		ldr	r0, .L302+4
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3451              		.loc 1 1097 0
 3452 1dec 34209DE5 		ldr	r2, [sp, #52]
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3453              		.loc 1 1096 0
 3454 1df0 061089E0 		add	r1, r9, r6
 3455 1df4 813180E0 		add	r3, r0, r1, asl #3
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3456              		.loc 1 1098 0
 3457 1df8 0160A0E3 		mov	r6, #1
1096:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3458              		.loc 1 1096 0
 3459 1dfc 9DA4C3E5 		strb	sl, [r3, #1181]
1097:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3460              		.loc 1 1097 0
 3461 1e00 9E24C3E5 		strb	r2, [r3, #1182]
1098:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3462              		.loc 1 1098 0
 3463 1e04 A064C3E5 		strb	r6, [r3, #1184]
 3464              	.LVL289:
 3465              	.L292:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3466              		.loc 1 1100 0
 3467 1e08 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3468 1e0c 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1105:../uvc.c      **** 					  break;
 3469              		.loc 1 1105 0
 3470 1e10 FFC0A0E3 		mov	ip, #255
 3471 1e14 42FFFFEA 		b	.L228
 3472              	.LVL290:
 3473              	.L239:
1054:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3474              		.loc 1 1054 0
 3475 1e18 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3476 1e1c 010050E3 		cmp	r0, #1
 3477 1e20 04005013 		cmpne	r0, #4
 3478 1e24 5C01001A 		bne	.L249
1053:../uvc.c      **** 					  value = (value << 8)|Data0;
 3479              		.loc 1 1053 0
 3480 1e28 30109DE5 		ldr	r1, [sp, #48]
 3481 1e2c 34E09DE5 		ldr	lr, [sp, #52]
 3482 1e30 0E2481E1 		orr	r2, r1, lr, asl #8
1055:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3483              		.loc 1 1055 0
 3484 1e34 F90052E3 		cmp	r2, #249
 3485 1e38 5701008A 		bhi	.L249
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3486              		.loc 1 1060 0
 3487 1e3c C8A042E2 		sub	sl, r2, #200
 3488 1e40 0AC8A0E1 		mov	ip, sl, asl #16
 3489 1e44 3CC08DE5 		str	ip, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3490              		.loc 1 1062 0
 3491 1e48 27A062E2 		rsb	sl, r2, #39
 3492 1e4c 38A08DE5 		str	sl, [sp, #56]
 3493 1e50 3CA09DE5 		ldr	sl, [sp, #60]
 3494 1e54 C81062E2 		rsb	r1, r2, #200
 3495 1e58 C80052E3 		cmp	r2, #200
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3496              		.loc 1 1060 0
 3497 1e5c 640042E2 		sub	r0, r2, #100
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3498              		.loc 1 1062 0
 3499 1e60 0118A0E1 		mov	r1, r1, asl #16
 3500 1e64 64E062E2 		rsb	lr, r2, #100
 3501 1e68 2A18A081 		movhi	r1, sl, lsr #16
 3502 1e6c 2118A091 		movls	r1, r1, lsr #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3503              		.loc 1 1060 0
 3504 1e70 00C8A0E1 		mov	ip, r0, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3505              		.loc 1 1062 0
 3506 1e74 640052E3 		cmp	r2, #100
 3507 1e78 0E08A0E1 		mov	r0, lr, asl #16
 3508 1e7c 2C08A081 		movhi	r0, ip, lsr #16
 3509 1e80 38C09DE5 		ldr	ip, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3510              		.loc 1 1060 0
 3511 1e84 14A042E2 		sub	sl, r2, #20
 3512 1e88 38A08DE5 		str	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3513              		.loc 1 1062 0
 3514 1e8c 2008A091 		movls	r0, r0, lsr #16
 3515 1e90 14A062E2 		rsb	sl, r2, #20
 3516 1e94 3CA08DE5 		str	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3517              		.loc 1 1060 0
 3518 1e98 27E042E2 		sub	lr, r2, #39
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3519              		.loc 1 1062 0
 3520 1e9c 000051E1 		cmp	r1, r0
 3521 1ea0 01A0A031 		movcc	sl, r1
 3522 1ea4 00A0A021 		movcs	sl, r0
 3523 1ea8 0CC8A0E1 		mov	ip, ip, asl #16
 3524 1eac 270052E3 		cmp	r2, #39
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3525              		.loc 1 1060 0
 3526 1eb0 0EE8A0E1 		mov	lr, lr, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3527              		.loc 1 1062 0
 3528 1eb4 2CE8A091 		movls	lr, ip, lsr #16
 3529 1eb8 64C59FE5 		ldr	ip, .L302+32
 3530 1ebc 20A08DE5 		str	sl, [sp, #32]
 3531 1ec0 01A06CE0 		rsb	sl, ip, r1
 3532 1ec4 2EE8A081 		movhi	lr, lr, lsr #16
 3533 1ec8 00C07AE2 		rsbs	ip, sl, #0
 3534 1ecc 0AC0ACE0 		adc	ip, ip, sl
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3535              		.loc 1 1060 0
 3536 1ed0 38A09DE5 		ldr	sl, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3537              		.loc 1 1062 0
 3538 1ed4 44C08DE5 		str	ip, [sp, #68]
 3539              	.LVL291:
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3540              		.loc 1 1060 0
 3541 1ed8 0AC8A0E1 		mov	ip, sl, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3542              		.loc 1 1062 0
 3543 1edc 3CA09DE5 		ldr	sl, [sp, #60]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3544              		.loc 1 1060 0
 3545 1ee0 4CC08DE5 		str	ip, [sp, #76]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3546              		.loc 1 1062 0
 3547 1ee4 0AC8A0E1 		mov	ip, sl, asl #16
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3548              		.loc 1 1060 0
 3549 1ee8 0AA042E2 		sub	sl, r2, #10
 3550 1eec 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3551              		.loc 1 1062 0
 3552 1ef0 20A09DE5 		ldr	sl, [sp, #32]
 3553 1ef4 3CC08DE5 		str	ip, [sp, #60]
 3554 1ef8 0A005EE1 		cmp	lr, sl
 3555 1efc 0EA0A031 		movcc	sl, lr
 3556 1f00 0AC062E2 		rsb	ip, r2, #10
 3557 1f04 40C08DE5 		str	ip, [sp, #64]
 3558 1f08 38A08DE5 		str	sl, [sp, #56]
 3559 1f0c 3CC09DE5 		ldr	ip, [sp, #60]
 3560 1f10 4CA09DE5 		ldr	sl, [sp, #76]
 3561 1f14 140052E3 		cmp	r2, #20
 3562 1f18 2CA8A091 		movls	sl, ip, lsr #16
 3563 1f1c 2AA8A081 		movhi	sl, sl, lsr #16
 3564 1f20 44C09DE5 		ldr	ip, [sp, #68]
 3565 1f24 010050E1 		cmp	r0, r1
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3566              		.loc 1 1060 0
 3567 1f28 48109DE5 		ldr	r1, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3568              		.loc 1 1062 0
 3569 1f2c 01C0A033 		movcc	ip, #1
 3570 1f30 3CA08DE5 		str	sl, [sp, #60]
 3571 1f34 24C08DE5 		str	ip, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3572              		.loc 1 1060 0
 3573 1f38 01A8A0E1 		mov	sl, r1, asl #16
 3574 1f3c 05C042E2 		sub	ip, r2, #5
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3575              		.loc 1 1062 0
 3576 1f40 051062E2 		rsb	r1, r2, #5
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3577              		.loc 1 1060 0
 3578 1f44 48A08DE5 		str	sl, [sp, #72]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3579              		.loc 1 1062 0
 3580 1f48 40009DE5 		ldr	r0, [sp, #64]
 3581 1f4c 38A09DE5 		ldr	sl, [sp, #56]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3582              		.loc 1 1060 0
 3583 1f50 40C08DE5 		str	ip, [sp, #64]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3584              		.loc 1 1062 0
 3585 1f54 3CC09DE5 		ldr	ip, [sp, #60]
 3586 1f58 4C108DE5 		str	r1, [sp, #76]
 3587 1f5c 48109DE5 		ldr	r1, [sp, #72]
 3588 1f60 0008A0E1 		mov	r0, r0, asl #16
 3589 1f64 0A005CE1 		cmp	ip, sl
 3590 1f68 0AC0A021 		movcs	ip, sl
 3591 1f6c 0A0052E3 		cmp	r2, #10
 3592 1f70 20A09DE5 		ldr	sl, [sp, #32]
 3593 1f74 2108A081 		movhi	r0, r1, lsr #16
 3594 1f78 2008A091 		movls	r0, r0, lsr #16
 3595 1f7c 48008DE5 		str	r0, [sp, #72]
 3596 1f80 24009DE5 		ldr	r0, [sp, #36]
 3597 1f84 0A005EE1 		cmp	lr, sl
 3598 1f88 0200A033 		movcc	r0, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3599              		.loc 1 1060 0
 3600 1f8c 02E042E2 		sub	lr, r2, #2
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3601              		.loc 1 1062 0
 3602 1f90 44C08DE5 		str	ip, [sp, #68]
 3603 1f94 24008DE5 		str	r0, [sp, #36]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3604              		.loc 1 1060 0
 3605 1f98 40C09DE5 		ldr	ip, [sp, #64]
 3606 1f9c 1CE08DE5 		str	lr, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3607              		.loc 1 1062 0
 3608 1fa0 44009DE5 		ldr	r0, [sp, #68]
 3609 1fa4 48E09DE5 		ldr	lr, [sp, #72]
 3610 1fa8 4C109DE5 		ldr	r1, [sp, #76]
 3611 1fac 02A062E2 		rsb	sl, r2, #2
 3612 1fb0 00005EE1 		cmp	lr, r0
 3613 1fb4 00E0A021 		movcs	lr, r0
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3614              		.loc 1 1060 0
 3615 1fb8 0CC8A0E1 		mov	ip, ip, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3616              		.loc 1 1062 0
 3617 1fbc 050052E3 		cmp	r2, #5
 3618 1fc0 40A08DE5 		str	sl, [sp, #64]
 3619 1fc4 0118A0E1 		mov	r1, r1, asl #16
 3620 1fc8 3CA09DE5 		ldr	sl, [sp, #60]
 3621 1fcc 2C18A081 		movhi	r1, ip, lsr #16
 3622 1fd0 38C09DE5 		ldr	ip, [sp, #56]
 3623 1fd4 4CE08DE5 		str	lr, [sp, #76]
 3624 1fd8 24009DE5 		ldr	r0, [sp, #36]
 3625 1fdc 40E09DE5 		ldr	lr, [sp, #64]
 3626 1fe0 2118A091 		movls	r1, r1, lsr #16
 3627 1fe4 0C005AE1 		cmp	sl, ip
 3628 1fe8 20108DE5 		str	r1, [sp, #32]
 3629 1fec 0300A033 		movcc	r0, #3
 3630 1ff0 38008DE5 		str	r0, [sp, #56]
 3631 1ff4 4CA09DE5 		ldr	sl, [sp, #76]
 3632 1ff8 0E08A0E1 		mov	r0, lr, asl #16
 3633 1ffc 20E09DE5 		ldr	lr, [sp, #32]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3634              		.loc 1 1060 0
 3635 2000 1C109DE5 		ldr	r1, [sp, #28]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3636              		.loc 1 1062 0
 3637 2004 0A005EE1 		cmp	lr, sl
 3638 2008 0AE0A021 		movcs	lr, sl
 3639 200c 44C09DE5 		ldr	ip, [sp, #68]
 3640 2010 48A09DE5 		ldr	sl, [sp, #72]
 3641 2014 020052E3 		cmp	r2, #2
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3642              		.loc 1 1060 0
 3643 2018 0118A0E1 		mov	r1, r1, asl #16
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3644              		.loc 1 1062 0
 3645 201c 2018A091 		movls	r1, r0, lsr #16
 3646 2020 38009DE5 		ldr	r0, [sp, #56]
 3647 2024 2118A081 		movhi	r1, r1, lsr #16
 3648 2028 0C005AE1 		cmp	sl, ip
 3649 202c 0400A033 		movcc	r0, #4
 3650 2030 40008DE5 		str	r0, [sp, #64]
1060:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3651              		.loc 1 1060 0
 3652 2034 010042E2 		sub	r0, r2, #1
 3653 2038 38008DE5 		str	r0, [sp, #56]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3654              		.loc 1 1062 0
 3655 203c 4CA09DE5 		ldr	sl, [sp, #76]
 3656 2040 20009DE5 		ldr	r0, [sp, #32]
 3657 2044 01C062E2 		rsb	ip, r2, #1
 3658 2048 3CC08DE5 		str	ip, [sp, #60]
 3659 204c 0A0050E1 		cmp	r0, sl
1069:../uvc.c      **** 						  shutter = shutter+index;
 3660              		.loc 1 1069 0
 3661 2050 38A09DE5 		ldr	sl, [sp, #56]
 3662 2054 3C009DE5 		ldr	r0, [sp, #60]
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3663              		.loc 1 1062 0
 3664 2058 40C09DE5 		ldr	ip, [sp, #64]
 3665 205c 05C0A033 		movcc	ip, #5
1069:../uvc.c      **** 						  shutter = shutter+index;
 3666              		.loc 1 1069 0
 3667 2060 010052E3 		cmp	r2, #1
 3668 2064 0028A091 		movls	r2, r0, asl #16
 3669 2068 0A28A081 		movhi	r2, sl, asl #16
 3670 206c 0E0051E1 		cmp	r1, lr
 3671 2070 01A0A031 		movcc	sl, r1
 3672 2074 0EA0A021 		movcs	sl, lr
1062:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3673              		.loc 1 1062 0
 3674 2078 0E0051E1 		cmp	r1, lr
 3675 207c 0C10A021 		movcs	r1, ip
 3676 2080 0610A033 		movcc	r1, #6
1069:../uvc.c      **** 						  shutter = shutter+index;
 3677              		.loc 1 1069 0
 3678 2084 22085AE1 		cmp	sl, r2, lsr #16
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3679              		.loc 1 1072 0
 3680 2088 8CA39FE5 		ldr	sl, .L302+24
1069:../uvc.c      **** 						  shutter = shutter+index;
 3681              		.loc 1 1069 0
 3682 208c 0120A091 		movls	r2, r1
 3683 2090 0720A083 		movhi	r2, #7
 3684 2094 012082E2 		add	r2, r2, #1
 3685 2098 FFE002E2 		and	lr, r2, #255
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3686              		.loc 1 1072 0
 3687 209c 0010E0E3 		mvn	r1, #0
 3688 20a0 1C009AE5 		ldr	r0, [sl, #28]
1069:../uvc.c      **** 						  shutter = shutter+index;
 3689              		.loc 1 1069 0
 3690 20a4 38E08DE5 		str	lr, [sp, #56]
 3691              	.LVL292:
1072:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3692              		.loc 1 1072 0
 3693 20a8 2C308DE5 		str	r3, [sp, #44]
 3694 20ac FEFFFFEB 		bl	_txe_mutex_get
1073:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3695              		.loc 1 1073 0
 3696 20b0 38C09DE5 		ldr	ip, [sp, #56]
 3697 20b4 0310A0E3 		mov	r1, #3
 3698 20b8 0B20A0E1 		mov	r2, fp
 3699 20bc 2C309DE5 		ldr	r3, [sp, #44]
 3700 20c0 00C08DE5 		str	ip, [sp, #0]
 3701 20c4 0A00A0E1 		mov	r0, sl
 3702 20c8 00C0A0E3 		mov	ip, #0
 3703 20cc 04C08DE5 		str	ip, [sp, #4]
 3704 20d0 FEFFFFEB 		bl	cmdSet
1074:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3705              		.loc 1 1074 0
 3706 20d4 1C009AE5 		ldr	r0, [sl, #28]
 3707 20d8 FEFFFFEB 		bl	_txe_mutex_put
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3708              		.loc 1 1077 0
 3709 20dc 30009DE5 		ldr	r0, [sp, #48]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3710              		.loc 1 1078 0
 3711 20e0 34C09DE5 		ldr	ip, [sp, #52]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3712              		.loc 1 1080 0
 3713 20e4 38309DE5 		ldr	r3, [sp, #56]
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3714              		.loc 1 1077 0
 3715 20e8 061089E0 		add	r1, r9, r6
 3716 20ec 816188E0 		add	r6, r8, r1, asl #3
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3717              		.loc 1 1079 0
 3718 20f0 0120A0E3 		mov	r2, #1
1077:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3719              		.loc 1 1077 0
 3720 20f4 9D04C6E5 		strb	r0, [r6, #1181]
1078:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3721              		.loc 1 1078 0
 3722 20f8 9EC4C6E5 		strb	ip, [r6, #1182]
1079:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3723              		.loc 1 1079 0
 3724 20fc A024C6E5 		strb	r2, [r6, #1184]
1080:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3725              		.loc 1 1080 0
 3726 2100 0D33C8E5 		strb	r3, [r8, #781]
 3727 2104 3FFFFFEA 		b	.L292
 3728              	.LVL293:
 3729              	.L238:
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3730              		.loc 1 1007 0
 3731 2108 062089E0 		add	r2, r9, r6
 3732 210c 826188E0 		add	r6, r8, r2, asl #3
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3733              		.loc 1 1008 0
 3734 2110 0110A0E3 		mov	r1, #1
1011:../uvc.c      **** 		  		    switch (getData){
 3735              		.loc 1 1011 0
 3736 2114 01E040E2 		sub	lr, r0, #1
1007:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3737              		.loc 1 1007 0
 3738 2118 9D04C6E5 		strb	r0, [r6, #1181]
1008:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3739              		.loc 1 1008 0
 3740 211c A014C6E5 		strb	r1, [r6, #1184]
 3741              	.LVL294:
1011:../uvc.c      **** 		  		    switch (getData){
 3742              		.loc 1 1011 0
 3743 2120 07005EE3 		cmp	lr, #7
 3744 2124 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3745 2128 970000EA 		b	.L243
 3746              	.L248:
 3747 212c 20230000 		.word	.L244
 3748 2130 84220000 		.word	.L245
 3749 2134 8C230000 		.word	.L243
 3750 2138 20220000 		.word	.L246
 3751 213c 8C230000 		.word	.L243
 3752 2140 8C230000 		.word	.L243
 3753 2144 8C230000 		.word	.L243
 3754 2148 80210000 		.word	.L247
 3755              	.LVL295:
 3756              	.L237:
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3757              		.loc 1 1127 0
 3758 214c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3759              		.loc 1 1126 0
 3760 2150 30A09DE5 		ldr	sl, [sp, #48]
 3761 2154 069089E0 		add	r9, r9, r6
 3762 2158 89E188E0 		add	lr, r8, r9, asl #3
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3763              		.loc 1 1127 0
 3764 215c 0620A0E1 		mov	r2, r6
 3765 2160 0400A0E3 		mov	r0, #4
 3766 2164 BC129FE5 		ldr	r1, .L302+36
1126:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3767              		.loc 1 1126 0
 3768 2168 9DA4CEE5 		strb	sl, [lr, #1181]
1127:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3769              		.loc 1 1127 0
 3770 216c FEFFFFEB 		bl	CyU3PDebugPrint
1128:../uvc.c      **** 			  		 break;
 3771              		.loc 1 1128 0
 3772 2170 FFC0A0E3 		mov	ip, #255
 3773 2174 0C60A0E1 		mov	r6, ip
 3774 2178 0C80A0E1 		mov	r8, ip
 3775 217c 68FEFFEA 		b	.L228
 3776              	.LVL296:
 3777              	.L247:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3778              		.loc 1 1030 0
 3779 2180 94629FE5 		ldr	r6, .L302+24
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3780              		.loc 1 1028 0
 3781 2184 00A0A0E3 		mov	sl, #0
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3782              		.loc 1 1030 0
 3783 2188 1C0096E5 		ldr	r0, [r6, #28]
1028:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3784              		.loc 1 1028 0
 3785 218c 0DA3C8E5 		strb	sl, [r8, #781]
 3786              	.LVL297:
1030:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3787              		.loc 1 1030 0
 3788 2190 0010E0E3 		mvn	r1, #0
 3789 2194 2C308DE5 		str	r3, [sp, #44]
 3790 2198 FEFFFFEB 		bl	_txe_mutex_get
1031:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3791              		.loc 1 1031 0
 3792 219c 0B20A0E1 		mov	r2, fp
 3793 21a0 2C309DE5 		ldr	r3, [sp, #44]
 3794 21a4 1010A0E3 		mov	r1, #16
 3795 21a8 0600A0E1 		mov	r0, r6
 3796 21ac 00A08DE5 		str	sl, [sp, #0]
 3797 21b0 04A08DE5 		str	sl, [sp, #4]
 3798 21b4 FEFFFFEB 		bl	cmdSet
1032:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3799              		.loc 1 1032 0
 3800 21b8 1C0096E5 		ldr	r0, [r6, #28]
 3801 21bc FEFFFFEB 		bl	_txe_mutex_put
 3802              	.LVL298:
 3803              	.LBB65:
 3804              	.LBB66:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3805              		.loc 1 402 0
 3806 21c0 0010E0E3 		mvn	r1, #0
 3807 21c4 1C0096E5 		ldr	r0, [r6, #28]
 3808 21c8 FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3809              		.loc 1 403 0
 3810 21cc 0180A0E3 		mov	r8, #1
 3811 21d0 1410A0E3 		mov	r1, #20
 3812 21d4 2720A0E3 		mov	r2, #39
 3813 21d8 3030A0E3 		mov	r3, #48
 3814 21dc 0600A0E1 		mov	r0, r6
 3815 21e0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3816 21e4 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3817              		.loc 1 404 0
 3818 21e8 02C0A0E3 		mov	ip, #2
 3819 21ec 1510A0E3 		mov	r1, #21
 3820 21f0 2520A0E3 		mov	r2, #37
 3821 21f4 3030A0E3 		mov	r3, #48
 3822 21f8 0600A0E1 		mov	r0, r6
 3823 21fc 00C08DE5 		str	ip, [sp, #0]
 3824 2200 04A08DE5 		str	sl, [sp, #4]
 3825 2204 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3826              		.loc 1 405 0
 3827 2208 1C0096E5 		ldr	r0, [r6, #28]
 3828 220c FEFFFFEB 		bl	_txe_mutex_put
 3829              	.LBE66:
 3830              	.LBE65:
1034:../uvc.c      **** 							break;
 3831              		.loc 1 1034 0
 3832 2210 FFC0A0E3 		mov	ip, #255
 3833 2214 0C60A0E1 		mov	r6, ip
 3834 2218 0880A0E3 		mov	r8, #8
 3835 221c 40FEFFEA 		b	.L228
 3836              	.LVL299:
 3837              	.L246:
 3838              	.LBB67:
 3839              	.LBB68:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3840              		.loc 1 402 0
 3841 2220 F4819FE5 		ldr	r8, .L302+24
 3842 2224 0010E0E3 		mvn	r1, #0
 3843 2228 1C0098E5 		ldr	r0, [r8, #28]
 3844 222c FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3845              		.loc 1 403 0
 3846 2230 0060A0E3 		mov	r6, #0
 3847 2234 1410A0E3 		mov	r1, #20
 3848 2238 2720A0E3 		mov	r2, #39
 3849 223c 3030A0E3 		mov	r3, #48
 3850 2240 0800A0E1 		mov	r0, r8
 3851 2244 00608DE5 		str	r6, [sp, #0]
 3852 2248 04608DE5 		str	r6, [sp, #4]
 3853 224c FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3854              		.loc 1 404 0
 3855 2250 1510A0E3 		mov	r1, #21
 3856 2254 2520A0E3 		mov	r2, #37
 3857 2258 3030A0E3 		mov	r3, #48
 3858 225c 0800A0E1 		mov	r0, r8
 3859 2260 00608DE5 		str	r6, [sp, #0]
 3860 2264 04608DE5 		str	r6, [sp, #4]
 3861 2268 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3862              		.loc 1 405 0
 3863 226c 1C0098E5 		ldr	r0, [r8, #28]
 3864 2270 FEFFFFEB 		bl	_txe_mutex_put
 3865 2274 FFC0A0E3 		mov	ip, #255
 3866 2278 0C60A0E1 		mov	r6, ip
 3867 227c 0480A0E3 		mov	r8, #4
 3868 2280 27FEFFEA 		b	.L228
 3869              	.LVL300:
 3870              	.L245:
 3871              	.LBE68:
 3872              	.LBE67:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3873              		.loc 1 1018 0
 3874 2284 90A19FE5 		ldr	sl, .L302+24
1016:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3875              		.loc 1 1016 0
 3876 2288 0060A0E3 		mov	r6, #0
 3877 228c 0D63C8E5 		strb	r6, [r8, #781]
 3878              	.LVL301:
1018:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3879              		.loc 1 1018 0
 3880 2290 0010E0E3 		mvn	r1, #0
 3881 2294 1C009AE5 		ldr	r0, [sl, #28]
 3882 2298 2C308DE5 		str	r3, [sp, #44]
 3883 229c FEFFFFEB 		bl	_txe_mutex_get
1019:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3884              		.loc 1 1019 0
 3885 22a0 0B20A0E1 		mov	r2, fp
 3886 22a4 2C309DE5 		ldr	r3, [sp, #44]
 3887 22a8 1010A0E3 		mov	r1, #16
 3888 22ac 0A00A0E1 		mov	r0, sl
 3889 22b0 00608DE5 		str	r6, [sp, #0]
 3890 22b4 04608DE5 		str	r6, [sp, #4]
 3891 22b8 FEFFFFEB 		bl	cmdSet
1020:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3892              		.loc 1 1020 0
 3893 22bc 1C009AE5 		ldr	r0, [sl, #28]
 3894 22c0 FEFFFFEB 		bl	_txe_mutex_put
 3895              	.LVL302:
 3896              	.LBB69:
 3897              	.LBB70:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3898              		.loc 1 402 0
 3899 22c4 0010E0E3 		mvn	r1, #0
 3900 22c8 1C009AE5 		ldr	r0, [sl, #28]
 3901 22cc FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3902              		.loc 1 403 0
 3903 22d0 1410A0E3 		mov	r1, #20
 3904 22d4 2720A0E3 		mov	r2, #39
 3905 22d8 3030A0E3 		mov	r3, #48
 3906 22dc 0A00A0E1 		mov	r0, sl
 3907 22e0 00608DE5 		str	r6, [sp, #0]
 3908 22e4 04608DE5 		str	r6, [sp, #4]
 3909 22e8 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3910              		.loc 1 404 0
 3911 22ec 1510A0E3 		mov	r1, #21
 3912 22f0 2520A0E3 		mov	r2, #37
 3913 22f4 3030A0E3 		mov	r3, #48
 3914 22f8 0A00A0E1 		mov	r0, sl
 3915 22fc 00608DE5 		str	r6, [sp, #0]
 3916 2300 04608DE5 		str	r6, [sp, #4]
 3917 2304 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3918              		.loc 1 405 0
 3919 2308 1C009AE5 		ldr	r0, [sl, #28]
 3920 230c FEFFFFEB 		bl	_txe_mutex_put
 3921 2310 FFC0A0E3 		mov	ip, #255
 3922 2314 0C60A0E1 		mov	r6, ip
 3923 2318 0280A0E3 		mov	r8, #2
 3924 231c 00FEFFEA 		b	.L228
 3925              	.LVL303:
 3926              	.L244:
 3927              	.LBE70:
 3928              	.LBE69:
 3929              	.LBB71:
 3930              	.LBB72:
 402:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3931              		.loc 1 402 0
 3932 2320 F4609FE5 		ldr	r6, .L302+24
 3933 2324 0010E0E3 		mvn	r1, #0
 3934 2328 1C0096E5 		ldr	r0, [r6, #28]
 3935 232c FEFFFFEB 		bl	_txe_mutex_get
 403:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3936              		.loc 1 403 0
 3937 2330 0080A0E3 		mov	r8, #0
 3938 2334 01A0A0E3 		mov	sl, #1
 3939 2338 1410A0E3 		mov	r1, #20
 3940 233c 2720A0E3 		mov	r2, #39
 3941 2340 3030A0E3 		mov	r3, #48
 3942 2344 0600A0E1 		mov	r0, r6
 3943 2348 04808DE5 		str	r8, [sp, #4]
 3944 234c 00A08DE5 		str	sl, [sp, #0]
 3945 2350 FEFFFFEB 		bl	cmdSet
 404:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3946              		.loc 1 404 0
 3947 2354 02C0A0E3 		mov	ip, #2
 3948 2358 1510A0E3 		mov	r1, #21
 3949 235c 2520A0E3 		mov	r2, #37
 3950 2360 3030A0E3 		mov	r3, #48
 3951 2364 0600A0E1 		mov	r0, r6
 3952 2368 00C08DE5 		str	ip, [sp, #0]
 3953 236c 04808DE5 		str	r8, [sp, #4]
 3954 2370 FEFFFFEB 		bl	cmdSet
 405:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3955              		.loc 1 405 0
 3956 2374 1C0096E5 		ldr	r0, [r6, #28]
 3957 2378 FEFFFFEB 		bl	_txe_mutex_put
 3958              	.LBE72:
 3959              	.LBE71:
1014:../uvc.c      **** 							break;
 3960              		.loc 1 1014 0
 3961 237c FFC0A0E3 		mov	ip, #255
 3962 2380 0C60A0E1 		mov	r6, ip
 3963 2384 0A80A0E1 		mov	r8, sl
 3964 2388 E5FDFFEA 		b	.L228
 3965              	.LVL304:
 3966              	.L243:
1011:../uvc.c      **** 		  		    switch (getData){
 3967              		.loc 1 1011 0
 3968 238c FFC0A0E3 		mov	ip, #255
 3969 2390 0080A0E1 		mov	r8, r0
 3970 2394 0C60A0E1 		mov	r6, ip
 3971 2398 E1FDFFEA 		b	.L228
 3972              	.LVL305:
 3973              	.L249:
1082:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3974              		.loc 1 1082 0
 3975 239c 0000A0E3 		mov	r0, #0
 3976 23a0 0110A0E3 		mov	r1, #1
 3977 23a4 0020A0E1 		mov	r2, r0
 3978 23a8 FEFFFFEB 		bl	CyU3PUsbStall
 3979              	.LVL306:
 3980 23ac 95FEFFEA 		b	.L292
 3981              	.LVL307:
 3982              	.L291:
1100:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3983              		.loc 1 1100 0
 3984 23b0 0110A0E3 		mov	r1, #1
 3985 23b4 0020A0E1 		mov	r2, r0
 3986 23b8 FEFFFFEB 		bl	CyU3PUsbStall
 3987 23bc 91FEFFEA 		b	.L292
 3988              	.LVL308:
 3989              	.L301:
1115:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3990              		.loc 1 1115 0
 3991 23c0 08E0A0E3 		mov	lr, #8
 3992 23c4 00C0A0E3 		mov	ip, #0
 3993 23c8 0600A0E1 		mov	r0, r6
 3994 23cc 1710A0E3 		mov	r1, #23
 3995 23d0 0B20A0E1 		mov	r2, fp
 3996 23d4 00E08DE5 		str	lr, [sp, #0]
 3997 23d8 04C08DE5 		str	ip, [sp, #4]
 3998 23dc FEFFFFEB 		bl	cmdSet
 3999 23e0 5EFEFFEA 		b	.L294
 4000              	.L300:
1113:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4001              		.loc 1 1113 0
 4002 23e4 0480A0E3 		mov	r8, #4
 4003 23e8 00E0A0E3 		mov	lr, #0
 4004 23ec 0600A0E1 		mov	r0, r6
 4005 23f0 1710A0E3 		mov	r1, #23
 4006 23f4 0B20A0E1 		mov	r2, fp
 4007 23f8 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4008 23fc FEFFFFEB 		bl	cmdSet
 4009 2400 56FEFFEA 		b	.L294
 4010              	.L303:
 4011              		.align	2
 4012              	.L302:
 4013 2404 00000000 		.word	bRequest
 4014 2408 00000000 		.word	.LANCHOR1
 4015 240c 00000000 		.word	.LANCHOR0
 4016 2410 E4030000 		.word	.LC23
 4017 2414 08040000 		.word	.LC24
 4018 2418 58000000 		.word	.LANCHOR0+88
 4019 241c 00000000 		.word	cmdQu
 4020 2420 98030000 		.word	.LC21
 4021 2424 FFFF0000 		.word	65535
 4022 2428 C0030000 		.word	.LC22
 4023              		.cfi_endproc
 4024              	.LFE3:
 4026              		.align	2
 4027              		.global	UVCAppEP0Thread_Entry
 4029              	UVCAppEP0Thread_Entry:
 4030              	.LFB24:
3135:../uvc.c      **** {
 4031              		.loc 1 3135 0
 4032              		.cfi_startproc
 4033              		@ args = 0, pretend = 0, frame = 32
 4034              		@ frame_needed = 0, uses_anonymous_args = 0
 4035              	.LVL309:
 4036 242c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4037              	.LCFI17:
 4038              		.cfi_def_cfa_offset 36
 4039 2430 2C4A9FE5 		ldr	r4, .L452
 4040              		.cfi_offset 14, -4
 4041              		.cfi_offset 11, -8
 4042              		.cfi_offset 10, -12
 4043              		.cfi_offset 9, -16
 4044              		.cfi_offset 8, -20
 4045              		.cfi_offset 7, -24
 4046              		.cfi_offset 6, -28
 4047              		.cfi_offset 5, -32
 4048              		.cfi_offset 4, -36
 4049 2434 2C6A9FE5 		ldr	r6, .L452+4
 4050 2438 2CAA9FE5 		ldr	sl, .L452+8
 4051 243c 2C9A9FE5 		ldr	r9, .L452+12
 4052 2440 2C8A9FE5 		ldr	r8, .L452+16
 4053 2444 2C7A9FE5 		ldr	r7, .L452+20
 4054 2448 3CD04DE2 		sub	sp, sp, #60
 4055              	.LCFI18:
 4056              		.cfi_def_cfa_offset 96
 4057              	.LVL310:
3157:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4058              		.loc 1 3157 0
 4059 244c 0450A0E1 		mov	r5, r4
 4060              	.LVL311:
 4061              	.L429:
 4062 2450 00C0E0E3 		mvn	ip, #0
 4063 2454 080A9FE5 		ldr	r0, .L452
 4064 2458 4C10A0E3 		mov	r1, #76
 4065 245c 0120A0E3 		mov	r2, #1
 4066 2460 30308DE2 		add	r3, sp, #48
 4067 2464 00C08DE5 		str	ip, [sp, #0]
 4068 2468 FEFFFFEB 		bl	_txe_event_flags_get
 4069 246c 000050E3 		cmp	r0, #0
 4070 2470 3000001A 		bne	.L305
3161:../uvc.c      ****             if (!isUsbConnected)
 4071              		.loc 1 3161 0
 4072 2474 403095E5 		ldr	r3, [r5, #64]
 4073 2478 000053E3 		cmp	r3, #0
 4074 247c 8900000A 		beq	.L442
 4075              	.L306:
3170:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4076              		.loc 1 3170 0
 4077 2480 30309DE5 		ldr	r3, [sp, #48]
 4078 2484 0C0013E3 		tst	r3, #12
 4079 2488 7200001A 		bne	.L443
 4080              	.L307:
3177:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4081              		.loc 1 3177 0
 4082 248c 040013E3 		tst	r3, #4
 4083 2490 1C00000A 		beq	.L308
3179:../uvc.c      ****             	switch ((wIndex >> 8))
 4084              		.loc 1 3179 0
 4085 2494 B0E0D8E1 		ldrh	lr, [r8, #0]
 4086 2498 2E24A0E1 		mov	r2, lr, lsr #8
 4087 249c 030052E3 		cmp	r2, #3
 4088 24a0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4089 24a4 120000EA 		b	.L309
 4090              	.L314:
 4091 24a8 F4240000 		.word	.L309
 4092 24ac D8250000 		.word	.L311
 4093 24b0 B8240000 		.word	.L312
 4094 24b4 14260000 		.word	.L313
 4095              	.L312:
 4096              	.LBB87:
 4097              	.LBB89:
2458:../uvc.c      ****     switch (wValue)
 4098              		.loc 1 2458 0
 4099 24b8 B020D9E1 		ldrh	r2, [r9, #0]
 4100 24bc 060C52E3 		cmp	r2, #1536
 4101 24c0 E001000A 		beq	.L320
 4102 24c4 D700008A 		bhi	.L326
 4103 24c8 030C52E3 		cmp	r2, #768
 4104 24cc D901000A 		beq	.L318
 4105 24d0 D001008A 		bhi	.L327
 4106 24d4 010C52E3 		cmp	r2, #256
 4107 24d8 6F01000A 		beq	.L316
 4108 24dc 020C52E3 		cmp	r2, #512
 4109 24e0 6901000A 		beq	.L444
 4110              	.L329:
 4111              	.LBE89:
 4112              	.LBE87:
 4113              	.LBB92:
 4114              	.LBB96:
2590:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4115              		.loc 1 2590 0
 4116 24e4 90199FE5 		ldr	r1, .L452+24
 4117 24e8 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4118 24ec 0400A0E3 		mov	r0, #4
 4119 24f0 FEFFFFEB 		bl	CyU3PDebugPrint
 4120              	.L309:
 4121              	.LBE96:
 4122              	.LBE92:
3200:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4123              		.loc 1 3200 0
 4124 24f4 0000A0E3 		mov	r0, #0
 4125 24f8 0110A0E3 		mov	r1, #1
 4126 24fc 0020A0E1 		mov	r2, r0
 4127 2500 FEFFFFEB 		bl	CyU3PUsbStall
 4128 2504 30309DE5 		ldr	r3, [sp, #48]
 4129              	.L308:
3205:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4130              		.loc 1 3205 0
 4131 2508 080013E3 		tst	r3, #8
 4132 250c 0700000A 		beq	.L370
3209:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4133              		.loc 1 3209 0
 4134 2510 B030D8E1 		ldrh	r3, [r8, #0]
 4135 2514 010053E3 		cmp	r3, #1
 4136 2518 6800000A 		beq	.L371
 4137              	.L372:
 4138              	.LBB101:
 4139              	.LBB107:
3124:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4140              		.loc 1 3124 0
 4141 251c 0000A0E3 		mov	r0, #0
 4142 2520 0110A0E3 		mov	r1, #1
 4143 2524 0020A0E1 		mov	r2, r0
 4144 2528 FEFFFFEB 		bl	CyU3PUsbStall
 4145              	.L432:
 4146 252c 30309DE5 		ldr	r3, [sp, #48]
 4147              	.L370:
 4148              	.LBE107:
 4149              	.LBE101:
3220:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4150              		.loc 1 3220 0
 4151 2530 400013E3 		tst	r3, #64
 4152 2534 0100001A 		bne	.L445
 4153              	.L305:
3433:../uvc.c      ****         CyU3PThreadRelinquish ();
 4154              		.loc 1 3433 0
 4155 2538 FEFFFFEB 		bl	_txe_thread_relinquish
3434:../uvc.c      ****     }
 4156              		.loc 1 3434 0
 4157 253c C3FFFFEA 		b	.L429
 4158              	.L445:
3225:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4159              		.loc 1 3225 0
 4160 2540 1800A0E3 		mov	r0, #24
 4161 2544 2C108DE2 		add	r1, sp, #44
 4162 2548 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3230:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4163              		.loc 1 3230 0
 4164 254c 2C209DE5 		ldr	r2, [sp, #44]
 4165 2550 000052E3 		cmp	r2, #0
 4166 2554 6D00000A 		beq	.L424
3230:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4167              		.loc 1 3230 0 is_stmt 0 discriminator 1
 4168 2558 7B36D6E5 		ldrb	r3, [r6, #1659]	@ zero_extendqisi2
 4169 255c 000053E3 		cmp	r3, #0
 4170 2560 F4FFFF1A 		bne	.L305
3232:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4171              		.loc 1 3232 0 is_stmt 1
 4172 2564 002097E5 		ldr	r2, [r7, #0]
 4173 2568 02B0A0E3 		mov	fp, #2
 4174 256c 00B0C2E5 		strb	fp, [r2, #0]
3233:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4175              		.loc 1 3233 0
 4176 2570 001097E5 		ldr	r1, [r7, #0]
 4177 2574 01B0A0E3 		mov	fp, #1
 4178 2578 01B0C1E5 		strb	fp, [r1, #1]
3234:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4179              		.loc 1 3234 0
 4180 257c 000097E5 		ldr	r0, [r7, #0]
3238:../uvc.c      **** 					interStabuf.size   = 1024;
 4181              		.loc 1 3238 0
 4182 2580 01EBA0E3 		mov	lr, #1024	@ movhi
3234:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4183              		.loc 1 3234 0
 4184 2584 0230C0E5 		strb	r3, [r0, #2]
3235:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4185              		.loc 1 3235 0
 4186 2588 00C097E5 		ldr	ip, [r7, #0]
3244:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4187              		.loc 1 3244 0
 4188 258c 0010E0E3 		mvn	r1, #0
3235:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4189              		.loc 1 3235 0
 4190 2590 0330CCE5 		strb	r3, [ip, #3]
3237:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4191              		.loc 1 3237 0
 4192 2594 002097E5 		ldr	r2, [r7, #0]
3241:../uvc.c      **** 					interStabuf.count = 4;
 4193              		.loc 1 3241 0
 4194 2598 04C0A0E3 		mov	ip, #4	@ movhi
3244:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4195              		.loc 1 3244 0
 4196 259c DC089FE5 		ldr	r0, .L452+28
3237:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4197              		.loc 1 3237 0
 4198 25a0 20208DE5 		str	r2, [sp, #32]
3238:../uvc.c      **** 					interStabuf.size   = 1024;
 4199              		.loc 1 3238 0
 4200 25a4 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3239:../uvc.c      **** 					interStabuf.status = 0;
 4201              		.loc 1 3239 0
 4202 25a8 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3241:../uvc.c      **** 					interStabuf.count = 4;
 4203              		.loc 1 3241 0
 4204 25ac B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3244:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4205              		.loc 1 3244 0
 4206 25b0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3247:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4207              		.loc 1 3247 0
 4208 25b4 C4089FE5 		ldr	r0, .L452+28
 4209 25b8 20108DE2 		add	r1, sp, #32
 4210 25bc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4211              	.LVL312:
3248:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4212              		.loc 1 3248 0
 4213 25c0 002050E2 		subs	r2, r0, #0
 4214 25c4 6E01001A 		bne	.L446
3253:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4215              		.loc 1 3253 0
 4216 25c8 98389FE5 		ldr	r3, .L452+4
 4217 25cc 7BB6C3E5 		strb	fp, [r3, #1659]
3433:../uvc.c      ****         CyU3PThreadRelinquish ();
 4218              		.loc 1 3433 0
 4219 25d0 FEFFFFEB 		bl	_txe_thread_relinquish
 4220              	.LVL313:
 4221 25d4 9DFFFFEA 		b	.L429
 4222              	.L311:
 4223              	.LBB113:
 4224              	.LBB97:
2533:../uvc.c      ****     switch (wValue)
 4225              		.loc 1 2533 0
 4226 25d8 B020D9E1 		ldrh	r2, [r9, #0]
 4227 25dc 060C52E3 		cmp	r2, #1536
 4228 25e0 DC00000A 		beq	.L335
 4229 25e4 9A00008A 		bhi	.L341
 4230 25e8 030C52E3 		cmp	r2, #768
 4231 25ec 1E01000A 		beq	.L332
 4232 25f0 1501008A 		bhi	.L342
 4233 25f4 010C52E3 		cmp	r2, #256
 4234 25f8 5D01000A 		beq	.L330
 4235 25fc 020C52E3 		cmp	r2, #512
 4236 2600 B7FFFF1A 		bne	.L329
 4237              	.LVL314:
2541:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4238              		.loc 1 2541 0
 4239 2604 0100A0E3 		mov	r0, #1
 4240 2608 FEFFFFEB 		bl	CTControlHandle
 4241              	.LVL315:
 4242 260c 30309DE5 		ldr	r3, [sp, #48]
 4243 2610 BCFFFFEA 		b	.L308
 4244              	.L313:
 4245              	.LBE97:
 4246              	.LBE113:
 4247              	.LBB114:
 4248              	.LBB119:
2758:../uvc.c      ****     switch (wValue)
 4249              		.loc 1 2758 0
 4250 2614 B030D9E1 		ldrh	r3, [r9, #0]
 4251 2618 090C53E3 		cmp	r3, #2304
 4252 261c FD01000A 		beq	.L356
 4253 2620 9300008A 		bhi	.L365
 4254 2624 010B53E3 		cmp	r3, #1024
 4255 2628 F601000A 		beq	.L351
 4256 262c 8E01008A 		bhi	.L366
 4257 2630 020C53E3 		cmp	r3, #512
 4258 2634 EF01000A 		beq	.L349
 4259 2638 030C53E3 		cmp	r3, #768
 4260 263c E901000A 		beq	.L350
 4261 2640 010C53E3 		cmp	r3, #256
 4262 2644 AAFFFF1A 		bne	.L309
 4263              	.LVL316:
2762:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4264              		.loc 1 2762 0
 4265 2648 1000A0E3 		mov	r0, #16
 4266 264c FEFFFFEB 		bl	ControlHandle
 4267              	.LVL317:
 4268 2650 30309DE5 		ldr	r3, [sp, #48]
 4269 2654 ABFFFFEA 		b	.L308
 4270              	.L443:
 4271              	.LBE119:
 4272              	.LBE114:
3171:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4273              		.loc 1 3171 0
 4274 2658 24B89FE5 		ldr	fp, .L452+32
 4275 265c B0C0D9E1 		ldrh	ip, [r9, #0]
 4276 2660 B000D8E1 		ldrh	r0, [r8, #0]
 4277 2664 1C189FE5 		ldr	r1, .L452+36
 4278 2668 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4279 266c 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4280 2670 0C008DE5 		str	r0, [sp, #12]
 4281 2674 08C08DE5 		str	ip, [sp, #8]
 4282 2678 B0C0D1E1 		ldrh	ip, [r1, #0]
 4283 267c 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4284 2680 04B08DE5 		str	fp, [sp, #4]
 4285 2684 0400A0E3 		mov	r0, #4
 4286 2688 FC179FE5 		ldr	r1, .L452+40
 4287 268c 00B0A0E3 		mov	fp, #0
 4288 2690 00E08DE5 		str	lr, [sp, #0]
 4289 2694 10C08DE5 		str	ip, [sp, #16]
 4290 2698 14B08DE5 		str	fp, [sp, #20]
 4291 269c FEFFFFEB 		bl	CyU3PDebugPrint
 4292 26a0 30309DE5 		ldr	r3, [sp, #48]
 4293 26a4 78FFFFEA 		b	.L307
 4294              	.L442:
3163:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4295              		.loc 1 3163 0
 4296 26a8 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3164:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4297              		.loc 1 3164 0
 4298 26ac 000050E3 		cmp	r0, #0
3163:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4299              		.loc 1 3163 0
 4300 26b0 4800C5E5 		strb	r0, [r5, #72]
3166:../uvc.c      ****                     isUsbConnected = CyTrue;
 4301              		.loc 1 3166 0
 4302 26b4 0100A013 		movne	r0, #1
 4303 26b8 40008515 		strne	r0, [r5, #64]
 4304 26bc 6FFFFFEA 		b	.L306
 4305              	.L371:
 4306              	.LVL318:
 4307              	.LBB125:
 4308              	.LBB106:
2853:../uvc.c      ****     switch (wValue)
 4309              		.loc 1 2853 0
 4310 26c0 B020D9E1 		ldrh	r2, [r9, #0]
 4311 26c4 030C52E3 		cmp	r2, #768
 4312 26c8 8800000A 		beq	.L375
 4313 26cc 3300008A 		bhi	.L378
 4314 26d0 010C52E3 		cmp	r2, #256
 4315 26d4 9200000A 		beq	.L373
 4316 26d8 020C52E3 		cmp	r2, #512
 4317 26dc 8EFFFF1A 		bne	.L372
2911:../uvc.c      ****             switch (bRequest)
 4318              		.loc 1 2911 0
 4319 26e0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4320 26e4 810053E3 		cmp	r3, #129
 4321 26e8 B601000A 		beq	.L417
 4322 26ec 2D01008A 		bhi	.L393
 4323 26f0 010053E3 		cmp	r3, #1
 4324 26f4 A201000A 		beq	.L447
 4325              	.L406:
3065:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4326              		.loc 1 3065 0
 4327 26f8 0000A0E3 		mov	r0, #0
 4328 26fc 0110A0E3 		mov	r1, #1
 4329 2700 0020A0E1 		mov	r2, r0
 4330 2704 FEFFFFEB 		bl	CyU3PUsbStall
 4331 2708 30309DE5 		ldr	r3, [sp, #48]
 4332 270c 87FFFFEA 		b	.L370
 4333              	.LVL319:
 4334              	.L424:
 4335              	.LBE106:
 4336              	.LBE125:
3254:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4337              		.loc 1 3254 0
 4338 2710 7BE6D6E5 		ldrb	lr, [r6, #1659]	@ zero_extendqisi2
 4339 2714 00005EE3 		cmp	lr, #0
 4340 2718 86FFFF0A 		beq	.L305
3256:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4341              		.loc 1 3256 0
 4342 271c 003097E5 		ldr	r3, [r7, #0]
 4343 2720 02B0A0E3 		mov	fp, #2
 4344 2724 00B0C3E5 		strb	fp, [r3, #0]
3257:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4345              		.loc 1 3257 0
 4346 2728 001097E5 		ldr	r1, [r7, #0]
 4347 272c 01B0A0E3 		mov	fp, #1
 4348 2730 01B0C1E5 		strb	fp, [r1, #1]
3258:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4349              		.loc 1 3258 0
 4350 2734 000097E5 		ldr	r0, [r7, #0]
3262:../uvc.c      **** 					interStabuf.size   = 1024;
 4351              		.loc 1 3262 0
 4352 2738 01EBA0E3 		mov	lr, #1024	@ movhi
3258:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4353              		.loc 1 3258 0
 4354 273c 0220C0E5 		strb	r2, [r0, #2]
3259:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4355              		.loc 1 3259 0
 4356 2740 00C097E5 		ldr	ip, [r7, #0]
3268:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4357              		.loc 1 3268 0
 4358 2744 0010E0E3 		mvn	r1, #0
3259:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4359              		.loc 1 3259 0
 4360 2748 03B0CCE5 		strb	fp, [ip, #3]
3261:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4361              		.loc 1 3261 0
 4362 274c 003097E5 		ldr	r3, [r7, #0]
3263:../uvc.c      **** 					interStabuf.status = 0;
 4363              		.loc 1 3263 0
 4364 2750 02C0A0E1 		mov	ip, r2	@ movhi
 4365 2754 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3268:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4366              		.loc 1 3268 0
 4367 2758 20079FE5 		ldr	r0, .L452+28
3265:../uvc.c      **** 					interStabuf.count = 4;
 4368              		.loc 1 3265 0
 4369 275c 0420A0E3 		mov	r2, #4	@ movhi
3261:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4370              		.loc 1 3261 0
 4371 2760 20308DE5 		str	r3, [sp, #32]
3265:../uvc.c      **** 					interStabuf.count = 4;
 4372              		.loc 1 3265 0
 4373 2764 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3262:../uvc.c      **** 					interStabuf.size   = 1024;
 4374              		.loc 1 3262 0
 4375 2768 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3268:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4376              		.loc 1 3268 0
 4377 276c 1CC08DE5 		str	ip, [sp, #28]
 4378 2770 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3271:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4379              		.loc 1 3271 0
 4380 2774 04079FE5 		ldr	r0, .L452+28
 4381 2778 20108DE2 		add	r1, sp, #32
 4382 277c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4383              	.LVL320:
3272:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4384              		.loc 1 3272 0
 4385 2780 1C309DE5 		ldr	r3, [sp, #28]
 4386 2784 002050E2 		subs	r2, r0, #0
 4387 2788 C700001A 		bne	.L448
3278:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4388              		.loc 1 3278 0
 4389 278c D4269FE5 		ldr	r2, .L452+4
3279:../uvc.c      **** 					stiflag = CyTrue;
 4390              		.loc 1 3279 0
 4391 2790 9CB084E5 		str	fp, [r4, #156]
3278:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4392              		.loc 1 3278 0
 4393 2794 7B36C2E5 		strb	r3, [r2, #1659]
3433:../uvc.c      ****         CyU3PThreadRelinquish ();
 4394              		.loc 1 3433 0
 4395 2798 FEFFFFEB 		bl	_txe_thread_relinquish
 4396              	.LVL321:
 4397 279c 2BFFFFEA 		b	.L429
 4398              	.LVL322:
 4399              	.L378:
 4400              	.LBB126:
 4401              	.LBB108:
2853:../uvc.c      ****     switch (wValue)
 4402              		.loc 1 2853 0
 4403 27a0 010B52E3 		cmp	r2, #1024
 4404 27a4 3F00000A 		beq	.L376
 4405 27a8 050C52E3 		cmp	r2, #1280
 4406 27ac 5AFFFF1A 		bne	.L372
3071:../uvc.c      ****                 switch (bRequest)
 4407              		.loc 1 3071 0
 4408 27b0 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4409 27b4 810052E3 		cmp	r2, #129
 4410 27b8 8201000A 		beq	.L417
 4411 27bc 2501008A 		bhi	.L420
 4412 27c0 010052E3 		cmp	r2, #1
 4413 27c4 54FFFF1A 		bne	.L372
3096:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4414              		.loc 1 3096 0
 4415 27c8 2000A0E3 		mov	r0, #32
 4416 27cc BC169FE5 		ldr	r1, .L452+44
 4417 27d0 36208DE2 		add	r2, sp, #54
 4418 27d4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4419              	.LVL323:
3098:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4420              		.loc 1 3098 0
 4421 27d8 000050E3 		cmp	r0, #0
 4422 27dc 6201001A 		bne	.L422
3102:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4423              		.loc 1 3102 0
 4424 27e0 0020A0E3 		mov	r2, #0
 4425 27e4 78069FE5 		ldr	r0, .L452
 4426              	.LVL324:
 4427 27e8 8010A0E3 		mov	r1, #128
 4428 27ec FEFFFFEB 		bl	_txe_event_flags_set
 4429              	.LVL325:
3103:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4430              		.loc 1 3103 0
 4431 27f0 002050E2 		subs	r2, r0, #0
 4432 27f4 0200000A 		beq	.L423
3105:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4433              		.loc 1 3105 0
 4434 27f8 0400A0E3 		mov	r0, #4
 4435              	.LVL326:
 4436 27fc 90169FE5 		ldr	r1, .L452+48
 4437 2800 FEFFFFEB 		bl	CyU3PDebugPrint
 4438              	.LVL327:
 4439              	.L423:
3110:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4440              		.loc 1 3110 0
 4441 2804 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4442 2808 0400A0E3 		mov	r0, #4
 4443 280c 84169FE5 		ldr	r1, .L452+52
 4444 2810 B623DDE1 		ldrh	r2, [sp, #54]
3108:../uvc.c      ****                             stiflag = CyTrue;//set still flag
 4445              		.loc 1 3108 0
 4446 2814 01B0A0E3 		mov	fp, #1
 4447 2818 9CB084E5 		str	fp, [r4, #156]
3110:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4448              		.loc 1 3110 0
 4449 281c FEFFFFEB 		bl	CyU3PDebugPrint
 4450 2820 30309DE5 		ldr	r3, [sp, #48]
 4451 2824 41FFFFEA 		b	.L370
 4452              	.L326:
 4453              	.LBE108:
 4454              	.LBE126:
 4455              	.LBB127:
 4456              	.LBB90:
2458:../uvc.c      ****     switch (wValue)
 4457              		.loc 1 2458 0
 4458 2828 0A0C52E3 		cmp	r2, #2560
 4459 282c F100000A 		beq	.L323
 4460 2830 E600008A 		bhi	.L328
 4461 2834 070C52E3 		cmp	r2, #1792
 4462 2838 E000000A 		beq	.L321
 4463 283c 020B52E3 		cmp	r2, #2048
 4464 2840 27FFFF1A 		bne	.L329
 4465              	.LVL328:
2489:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4466              		.loc 1 2489 0
 4467 2844 0700A0E3 		mov	r0, #7
 4468 2848 FEFFFFEB 		bl	ControlHandle
 4469              	.LVL329:
 4470 284c 30309DE5 		ldr	r3, [sp, #48]
 4471 2850 2CFFFFEA 		b	.L308
 4472              	.L341:
 4473              	.LBE90:
 4474              	.LBE127:
 4475              	.LBB128:
 4476              	.LBB95:
2533:../uvc.c      ****     switch (wValue)
 4477              		.loc 1 2533 0
 4478 2854 090C52E3 		cmp	r2, #2304
 4479 2858 2201000A 		beq	.L337
 4480 285c 1701008A 		bhi	.L343
 4481 2860 070C52E3 		cmp	r2, #1792
 4482 2864 0901000A 		beq	.L336
 4483 2868 020B52E3 		cmp	r2, #2048
 4484 286c 1CFFFF1A 		bne	.L329
 4485 2870 24FFFFEA 		b	.L308
 4486              	.L365:
 4487              	.LBE95:
 4488              	.LBE128:
 4489              	.LBB129:
 4490              	.LBB120:
2758:../uvc.c      ****     switch (wValue)
 4491              		.loc 1 2758 0
 4492 2874 0F0C53E3 		cmp	r3, #3840
 4493 2878 3701000A 		beq	.L360
 4494 287c 3900008A 		bhi	.L368
 4495 2880 0B0C53E3 		cmp	r3, #2816
 4496 2884 3001000A 		beq	.L358
 4497 2888 0D0C53E3 		cmp	r3, #3328
 4498 288c 2A01000A 		beq	.L359
 4499 2890 0A0C53E3 		cmp	r3, #2560
 4500 2894 16FFFF1A 		bne	.L309
 4501              	.LVL330:
2799:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4502              		.loc 1 2799 0
 4503 2898 1900A0E3 		mov	r0, #25
 4504 289c FEFFFFEB 		bl	ControlHandle
 4505              	.LVL331:
 4506 28a0 30309DE5 		ldr	r3, [sp, #48]
 4507 28a4 17FFFFEA 		b	.L308
 4508              	.LVL332:
 4509              	.L376:
 4510              	.LBE120:
 4511              	.LBE129:
 4512              	.LBB130:
 4513              	.LBB105:
3016:../uvc.c      ****                 switch (bRequest)
 4514              		.loc 1 3016 0
 4515 28a8 00B0DAE5 		ldrb	fp, [sl, #0]	@ zero_extendqisi2
 4516 28ac 81005BE3 		cmp	fp, #129
 4517 28b0 1300000A 		beq	.L408
 4518 28b4 8500008A 		bhi	.L411
 4519 28b8 01005BE3 		cmp	fp, #1
 4520 28bc 8DFFFF1A 		bne	.L406
3041:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4521              		.loc 1 3041 0
 4522 28c0 36208DE2 		add	r2, sp, #54
 4523 28c4 2000A0E3 		mov	r0, #32
 4524 28c8 C0159FE5 		ldr	r1, .L452+44
 4525 28cc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4526              	.LVL333:
3043:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4527              		.loc 1 3043 0
 4528 28d0 002050E2 		subs	r2, r0, #0
 4529 28d4 14FFFF1A 		bne	.L432
3056:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4530              		.loc 1 3056 0
 4531 28d8 84059FE5 		ldr	r0, .L452
 4532              	.LVL334:
 4533 28dc 0B10A0E1 		mov	r1, fp
 4534 28e0 FEFFFFEB 		bl	_txe_event_flags_set
 4535              	.LVL335:
3057:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4536              		.loc 1 3057 0
 4537 28e4 002050E2 		subs	r2, r0, #0
 4538 28e8 0FFFFF0A 		beq	.L432
 4539 28ec 300100EA 		b	.L414
 4540              	.LVL336:
 4541              	.L375:
2967:../uvc.c      ****                 switch (bRequest)
 4542              		.loc 1 2967 0
 4543 28f0 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4544 28f4 830052E3 		cmp	r2, #131
 4545 28f8 9800008A 		bhi	.L402
 4546 28fc 810052E3 		cmp	r2, #129
 4547 2900 7D00003A 		bcc	.L449
 4548              	.L408:
3028:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4549              		.loc 1 3028 0
 4550 2904 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3030:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4551              		.loc 1 3030 0
 4552 2908 0B00A0E3 		mov	r0, #11
3028:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4553              		.loc 1 3028 0
 4554 290c 030053E3 		cmp	r3, #3
3030:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4555              		.loc 1 3030 0
 4556 2910 84159F05 		ldreq	r1, .L452+56
3034:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4557              		.loc 1 3034 0
 4558 2914 84159F15 		ldrne	r1, .L452+60
 4559 2918 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4560 291c 30309DE5 		ldr	r3, [sp, #48]
 4561 2920 02FFFFEA 		b	.L370
 4562              	.L373:
2856:../uvc.c      ****             switch (bRequest)
 4563              		.loc 1 2856 0
 4564 2924 0020DAE5 		ldrb	r2, [sl, #0]	@ zero_extendqisi2
 4565 2928 830052E3 		cmp	r2, #131
 4566 292c 2F00008A 		bhi	.L384
 4567 2930 810052E3 		cmp	r2, #129
 4568 2934 1400003A 		bcc	.L450
 4569              	.L381:
2871:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4570              		.loc 1 2871 0
 4571 2938 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4572 293c 030053E3 		cmp	r3, #3
 4573 2940 F800000A 		beq	.L451
 4574              	.L421:
3089:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4575              		.loc 1 3089 0
 4576 2944 1A00A0E3 		mov	r0, #26
 4577 2948 54159FE5 		ldr	r1, .L452+64
 4578 294c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4579 2950 30309DE5 		ldr	r3, [sp, #48]
 4580 2954 F5FEFFEA 		b	.L370
 4581              	.LVL337:
 4582              	.L335:
 4583              	.LBE105:
 4584              	.LBE130:
 4585              	.LBB131:
 4586              	.LBB98:
2559:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4587              		.loc 1 2559 0
 4588 2958 0500A0E3 		mov	r0, #5
 4589 295c FEFFFFEB 		bl	CTControlHandle
 4590              	.LVL338:
 4591 2960 30309DE5 		ldr	r3, [sp, #48]
 4592 2964 E7FEFFEA 		b	.L308
 4593              	.L368:
 4594              	.LBE98:
 4595              	.LBE131:
 4596              	.LBB132:
 4597              	.LBB118:
2758:../uvc.c      ****     switch (wValue)
 4598              		.loc 1 2758 0
 4599 2968 110C53E3 		cmp	r3, #4352
 4600 296c E900000A 		beq	.L362
 4601 2970 2D00008A 		bhi	.L369
 4602 2974 010A53E3 		cmp	r3, #4096
 4603 2978 DDFEFF1A 		bne	.L309
 4604              	.LVL339:
2821:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4605              		.loc 1 2821 0
 4606 297c 1F00A0E3 		mov	r0, #31
 4607 2980 FEFFFFEB 		bl	ControlHandle
 4608              	.LVL340:
 4609 2984 30309DE5 		ldr	r3, [sp, #48]
 4610 2988 DEFEFFEA 		b	.L308
 4611              	.LVL341:
 4612              	.L450:
 4613              	.LBE118:
 4614              	.LBE132:
 4615              	.LBB133:
 4616              	.LBB109:
2856:../uvc.c      ****             switch (bRequest)
 4617              		.loc 1 2856 0
 4618 298c 010052E3 		cmp	r2, #1
 4619 2990 58FFFF1A 		bne	.L406
2881:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4620              		.loc 1 2881 0
 4621 2994 2000A0E3 		mov	r0, #32
 4622 2998 F0149FE5 		ldr	r1, .L452+44
 4623 299c 36208DE2 		add	r2, sp, #54
 4624 29a0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4625              	.LVL342:
2883:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4626              		.loc 1 2883 0
 4627 29a4 000050E3 		cmp	r0, #0
 4628 29a8 DFFEFF1A 		bne	.L432
2885:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4629              		.loc 1 2885 0
 4630 29ac 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4631 29b0 030051E3 		cmp	r1, #3
 4632 29b4 DCFEFF1A 		bne	.L432
2892:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4633              		.loc 1 2892 0
 4634 29b8 8130D4E5 		ldrb	r3, [r4, #129]	@ zero_extendqisi2
2889:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4635              		.loc 1 2889 0
 4636 29bc 7EE0D4E5 		ldrb	lr, [r4, #126]	@ zero_extendqisi2
2890:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4637              		.loc 1 2890 0
 4638 29c0 7FC0D4E5 		ldrb	ip, [r4, #127]	@ zero_extendqisi2
2891:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4639              		.loc 1 2891 0
 4640 29c4 8000D4E5 		ldrb	r0, [r4, #128]	@ zero_extendqisi2
 4641              	.LVL343:
2893:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4642              		.loc 1 2893 0
 4643 29c8 8220D4E5 		ldrb	r2, [r4, #130]	@ zero_extendqisi2
2894:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4644              		.loc 1 2894 0
 4645 29cc 83B0D4E5 		ldrb	fp, [r4, #131]	@ zero_extendqisi2
2892:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4646              		.loc 1 2892 0
 4647 29d0 1536C6E5 		strb	r3, [r6, #1557]
2889:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4648              		.loc 1 2889 0
 4649 29d4 12E6C6E5 		strb	lr, [r6, #1554]
2890:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4650              		.loc 1 2890 0
 4651 29d8 13C6C6E5 		strb	ip, [r6, #1555]
2891:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4652              		.loc 1 2891 0
 4653 29dc 1406C6E5 		strb	r0, [r6, #1556]
2893:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4654              		.loc 1 2893 0
 4655 29e0 1626C6E5 		strb	r2, [r6, #1558]
2894:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4656              		.loc 1 2894 0
 4657 29e4 17B6C6E5 		strb	fp, [r6, #1559]
 4658 29e8 30309DE5 		ldr	r3, [sp, #48]
 4659 29ec CFFEFFEA 		b	.L370
 4660              	.LVL344:
 4661              	.L384:
2856:../uvc.c      ****             switch (bRequest)
 4662              		.loc 1 2856 0
 4663 29f0 860052E3 		cmp	r2, #134
 4664 29f4 3900000A 		beq	.L436
 4665 29f8 870052E3 		cmp	r2, #135
 4666 29fc CDFFFF0A 		beq	.L381
 4667              	.L441:
2967:../uvc.c      ****                 switch (bRequest)
 4668              		.loc 1 2967 0
 4669 2a00 850052E3 		cmp	r2, #133
 4670 2a04 3BFFFF1A 		bne	.L406
 4671              	.L409:
3025:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4672              		.loc 1 3025 0
 4673 2a08 98149FE5 		ldr	r1, .L452+68
 4674 2a0c 0200A0E3 		mov	r0, #2
3023:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4675              		.loc 1 3023 0
 4676 2a10 1A30A0E3 		mov	r3, #26
 4677              	.L433:
3079:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4678              		.loc 1 3079 0
 4679 2a14 0020A0E3 		mov	r2, #0
3078:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4680              		.loc 1 3078 0
 4681 2a18 5830C4E5 		strb	r3, [r4, #88]
3079:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4682              		.loc 1 3079 0
 4683 2a1c 5920C4E5 		strb	r2, [r4, #89]
3080:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4684              		.loc 1 3080 0
 4685 2a20 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4686 2a24 30309DE5 		ldr	r3, [sp, #48]
 4687 2a28 C0FEFFEA 		b	.L370
 4688              	.LVL345:
 4689              	.L369:
 4690              	.LBE109:
 4691              	.LBE133:
 4692              	.LBB134:
 4693              	.LBB121:
2758:../uvc.c      ****     switch (wValue)
 4694              		.loc 1 2758 0
 4695 2a2c 120C53E3 		cmp	r3, #4608
 4696 2a30 0701000A 		beq	.L363
 4697 2a34 130C53E3 		cmp	r3, #4864
 4698 2a38 ADFEFF1A 		bne	.L309
 4699              	.LVL346:
2833:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4700              		.loc 1 2833 0
 4701 2a3c 2200A0E3 		mov	r0, #34
 4702 2a40 FEFFFFEB 		bl	ControlHandle
 4703              	.LVL347:
 4704 2a44 30309DE5 		ldr	r3, [sp, #48]
 4705 2a48 AEFEFFEA 		b	.L308
 4706              	.L342:
 4707              	.LBE121:
 4708              	.LBE134:
 4709              	.LBB135:
 4710              	.LBB94:
2533:../uvc.c      ****     switch (wValue)
 4711              		.loc 1 2533 0
 4712 2a4c 010B52E3 		cmp	r2, #1024
 4713 2a50 0900000A 		beq	.L333
 4714 2a54 050C52E3 		cmp	r2, #1280
 4715 2a58 A1FEFF1A 		bne	.L329
 4716              	.LVL348:
2555:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4717              		.loc 1 2555 0
 4718 2a5c 0400A0E3 		mov	r0, #4
 4719 2a60 FEFFFFEB 		bl	CTControlHandle
 4720              	.LVL349:
 4721 2a64 30309DE5 		ldr	r3, [sp, #48]
 4722 2a68 A6FEFFEA 		b	.L308
 4723              	.L332:
 4724              	.LVL350:
2545:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4725              		.loc 1 2545 0
 4726 2a6c 0200A0E3 		mov	r0, #2
 4727 2a70 FEFFFFEB 		bl	CTControlHandle
 4728              	.LVL351:
 4729 2a74 30309DE5 		ldr	r3, [sp, #48]
 4730 2a78 A2FEFFEA 		b	.L308
 4731              	.L333:
 4732              	.LVL352:
2550:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4733              		.loc 1 2550 0
 4734 2a7c 0300A0E3 		mov	r0, #3
 4735 2a80 FEFFFFEB 		bl	CTControlHandle
 4736              	.LVL353:
 4737 2a84 30309DE5 		ldr	r3, [sp, #48]
 4738 2a88 9EFEFFEA 		b	.L308
 4739              	.L444:
 4740              	.LVL354:
 4741              	.LBE94:
 4742              	.LBE135:
 4743              	.LBB136:
 4744              	.LBB88:
2466:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4745              		.loc 1 2466 0
 4746 2a8c 0100A0E3 		mov	r0, #1
 4747 2a90 FEFFFFEB 		bl	ControlHandle
 4748              	.LVL355:
 4749 2a94 30309DE5 		ldr	r3, [sp, #48]
 4750 2a98 9AFEFFEA 		b	.L308
 4751              	.L316:
 4752              	.LVL356:
2462:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4753              		.loc 1 2462 0
 4754 2a9c 0000A0E3 		mov	r0, #0
 4755 2aa0 FEFFFFEB 		bl	ControlHandle
 4756              	.LVL357:
 4757 2aa4 30309DE5 		ldr	r3, [sp, #48]
 4758 2aa8 96FEFFEA 		b	.L308
 4759              	.LVL358:
 4760              	.L448:
 4761              	.LBE88:
 4762              	.LBE136:
3274:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4763              		.loc 1 3274 0
 4764 2aac 0400A0E3 		mov	r0, #4
 4765              	.LVL359:
 4766 2ab0 F4139FE5 		ldr	r1, .L452+72
 4767 2ab4 FEFFFFEB 		bl	CyU3PDebugPrint
 4768              	.LVL360:
 4769              	.L428:
 4770              	.LBB137:
 4771              	.LBB138:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4772              		.loc 1 1246 0
 4773 2ab8 F0139FE5 		ldr	r1, .L452+76
 4774 2abc 0400A0E3 		mov	r0, #4
 4775 2ac0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4776              		.loc 1 1247 0
 4777 2ac4 FA0FA0E3 		mov	r0, #1000
 4778 2ac8 FEFFFFEB 		bl	_tx_thread_sleep
 4779 2acc F9FFFFEA 		b	.L428
 4780              	.LVL361:
 4781              	.L411:
 4782              	.LBE138:
 4783              	.LBE137:
 4784              	.LBB139:
 4785              	.LBB104:
3016:../uvc.c      ****                 switch (bRequest)
 4786              		.loc 1 3016 0
 4787 2ad0 85005BE3 		cmp	fp, #133
 4788 2ad4 CBFFFF0A 		beq	.L409
 4789 2ad8 86005BE3 		cmp	fp, #134
 4790 2adc 05FFFF1A 		bne	.L406
 4791              	.L436:
3020:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4792              		.loc 1 3020 0
 4793 2ae0 0300A0E1 		mov	r0, r3
 4794              	.L431:
2915:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4795              		.loc 1 2915 0
 4796 2ae4 BC139FE5 		ldr	r1, .L452+68
2914:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4797              		.loc 1 2914 0
 4798 2ae8 03B0A0E3 		mov	fp, #3
 4799 2aec 58B0C4E5 		strb	fp, [r4, #88]
2915:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4800              		.loc 1 2915 0
 4801 2af0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4802 2af4 30309DE5 		ldr	r3, [sp, #48]
 4803 2af8 8CFEFFEA 		b	.L370
 4804              	.L449:
2967:../uvc.c      ****                 switch (bRequest)
 4805              		.loc 1 2967 0
 4806 2afc 010052E3 		cmp	r2, #1
 4807 2b00 FCFEFF1A 		bne	.L406
2992:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4808              		.loc 1 2992 0
 4809 2b04 2000A0E3 		mov	r0, #32
 4810 2b08 80139FE5 		ldr	r1, .L452+44
 4811 2b0c 36208DE2 		add	r2, sp, #54
 4812 2b10 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4813              	.LVL362:
2994:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4814              		.loc 1 2994 0
 4815 2b14 000050E3 		cmp	r0, #0
 4816 2b18 83FEFF1A 		bne	.L432
2996:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4817              		.loc 1 2996 0
 4818 2b1c 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4819 2b20 030051E3 		cmp	r1, #3
 4820 2b24 80FEFF1A 		bne	.L432
3005:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4821              		.loc 1 3005 0
 4822 2b28 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
3000:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4823              		.loc 1 3000 0
 4824 2b2c 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
3001:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4825              		.loc 1 3001 0
 4826 2b30 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
3002:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4827              		.loc 1 3002 0
 4828 2b34 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4829              	.LVL363:
3003:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4830              		.loc 1 3003 0
 4831 2b38 80B0D5E5 		ldrb	fp, [r5, #128]	@ zero_extendqisi2
3004:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4832              		.loc 1 3004 0
 4833 2b3c 8120D5E5 		ldrb	r2, [r5, #129]	@ zero_extendqisi2
3005:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4834              		.loc 1 3005 0
 4835 2b40 6A36C6E5 		strb	r3, [r6, #1642]
3000:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4836              		.loc 1 3000 0
 4837 2b44 65E6C6E5 		strb	lr, [r6, #1637]
3001:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4838              		.loc 1 3001 0
 4839 2b48 66C6C6E5 		strb	ip, [r6, #1638]
3002:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4840              		.loc 1 3002 0
 4841 2b4c 6706C6E5 		strb	r0, [r6, #1639]
3003:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4842              		.loc 1 3003 0
 4843 2b50 68B6C6E5 		strb	fp, [r6, #1640]
3004:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4844              		.loc 1 3004 0
 4845 2b54 6926C6E5 		strb	r2, [r6, #1641]
3005:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4846              		.loc 1 3005 0
 4847 2b58 30309DE5 		ldr	r3, [sp, #48]
 4848 2b5c 73FEFFEA 		b	.L370
 4849              	.LVL364:
 4850              	.L402:
2967:../uvc.c      ****                 switch (bRequest)
 4851              		.loc 1 2967 0
 4852 2b60 860052E3 		cmp	r2, #134
 4853 2b64 DDFFFF0A 		beq	.L436
 4854 2b68 870052E3 		cmp	r2, #135
 4855 2b6c A3FFFF1A 		bne	.L441
 4856 2b70 63FFFFEA 		b	.L408
 4857              	.LVL365:
 4858              	.L330:
 4859              	.LBE104:
 4860              	.LBE139:
 4861              	.LBB140:
 4862              	.LBB99:
2537:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4863              		.loc 1 2537 0
 4864 2b74 0000A0E3 		mov	r0, #0
 4865 2b78 FEFFFFEB 		bl	CTControlHandle
 4866              	.LVL366:
 4867 2b7c 30309DE5 		ldr	r3, [sp, #48]
 4868 2b80 60FEFFEA 		b	.L308
 4869              	.LVL367:
 4870              	.L446:
 4871              	.LBE99:
 4872              	.LBE140:
3250:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4873              		.loc 1 3250 0
 4874 2b84 0400A0E3 		mov	r0, #4
 4875              	.LVL368:
 4876 2b88 1C139FE5 		ldr	r1, .L452+72
 4877 2b8c FEFFFFEB 		bl	CyU3PDebugPrint
 4878              	.LVL369:
 4879              	.L426:
 4880              	.LBB141:
 4881              	.LBB142:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4882              		.loc 1 1246 0
 4883 2b90 18139FE5 		ldr	r1, .L452+76
 4884 2b94 0400A0E3 		mov	r0, #4
 4885 2b98 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 4886              		.loc 1 1247 0
 4887 2b9c FA0FA0E3 		mov	r0, #1000
 4888 2ba0 FEFFFFEB 		bl	_tx_thread_sleep
 4889 2ba4 F9FFFFEA 		b	.L426
 4890              	.LVL370:
 4891              	.L393:
 4892              	.LBE142:
 4893              	.LBE141:
 4894              	.LBB143:
 4895              	.LBB110:
2911:../uvc.c      ****             switch (bRequest)
 4896              		.loc 1 2911 0
 4897 2ba8 850053E3 		cmp	r3, #133
 4898 2bac 95FFFF0A 		beq	.L409
 4899 2bb0 860053E3 		cmp	r3, #134
 4900 2bb4 CFFEFF1A 		bne	.L406
 4901              	.L437:
2915:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4902              		.loc 1 2915 0
 4903 2bb8 0100A0E3 		mov	r0, #1
 4904 2bbc C8FFFFEA 		b	.L431
 4905              	.LVL371:
 4906              	.L321:
 4907              	.LBE110:
 4908              	.LBE143:
 4909              	.LBB144:
 4910              	.LBB91:
2485:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4911              		.loc 1 2485 0
 4912 2bc0 0600A0E3 		mov	r0, #6
 4913 2bc4 FEFFFFEB 		bl	ControlHandle
 4914              	.LVL372:
 4915 2bc8 30309DE5 		ldr	r3, [sp, #48]
 4916 2bcc 4DFEFFEA 		b	.L308
 4917              	.L328:
2458:../uvc.c      ****     switch (wValue)
 4918              		.loc 1 2458 0
 4919 2bd0 0D0C52E3 		cmp	r2, #3328
 4920 2bd4 0700000A 		beq	.L323
 4921 2bd8 0E0C52E3 		cmp	r2, #3584
 4922 2bdc 0900000A 		beq	.L325
 4923 2be0 030B52E3 		cmp	r2, #3072
 4924 2be4 3EFEFF1A 		bne	.L329
 4925              	.LVL373:
2499:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4926              		.loc 1 2499 0
 4927 2be8 0B00A0E3 		mov	r0, #11
 4928 2bec FEFFFFEB 		bl	ControlHandle
 4929              	.LVL374:
 4930 2bf0 30309DE5 		ldr	r3, [sp, #48]
 4931 2bf4 43FEFFEA 		b	.L308
 4932              	.L323:
 4933              	.LVL375:
2495:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4934              		.loc 1 2495 0
 4935 2bf8 0900A0E3 		mov	r0, #9
 4936 2bfc FEFFFFEB 		bl	ControlHandle
 4937              	.LVL376:
 4938 2c00 30309DE5 		ldr	r3, [sp, #48]
 4939 2c04 3FFEFFEA 		b	.L308
 4940              	.L325:
 4941              	.LVL377:
2503:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4942              		.loc 1 2503 0
 4943 2c08 0E00A0E3 		mov	r0, #14
 4944 2c0c FEFFFFEB 		bl	ControlHandle
 4945              	.LVL378:
 4946 2c10 30309DE5 		ldr	r3, [sp, #48]
 4947 2c14 3BFEFFEA 		b	.L308
 4948              	.L327:
2458:../uvc.c      ****     switch (wValue)
 4949              		.loc 1 2458 0
 4950 2c18 010B52E3 		cmp	r2, #1024
 4951 2c1c 39FEFF0A 		beq	.L308
 4952 2c20 050C52E3 		cmp	r2, #1280
 4953 2c24 2EFEFF1A 		bne	.L329
 4954              	.LVL379:
2477:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4955              		.loc 1 2477 0
 4956 2c28 0400A0E3 		mov	r0, #4
 4957 2c2c FEFFFFEB 		bl	ControlHandle
 4958              	.LVL380:
 4959 2c30 30309DE5 		ldr	r3, [sp, #48]
 4960 2c34 33FEFFEA 		b	.L308
 4961              	.L318:
 4962              	.LVL381:
2470:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4963              		.loc 1 2470 0
 4964 2c38 0200A0E3 		mov	r0, #2
 4965 2c3c FEFFFFEB 		bl	ControlHandle
 4966              	.LVL382:
 4967 2c40 30309DE5 		ldr	r3, [sp, #48]
 4968 2c44 2FFEFFEA 		b	.L308
 4969              	.L320:
 4970              	.LVL383:
2481:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4971              		.loc 1 2481 0
 4972 2c48 0500A0E3 		mov	r0, #5
 4973 2c4c FEFFFFEB 		bl	ControlHandle
 4974              	.LVL384:
 4975 2c50 30309DE5 		ldr	r3, [sp, #48]
 4976 2c54 2BFEFFEA 		b	.L308
 4977              	.LVL385:
 4978              	.L420:
 4979              	.LBE91:
 4980              	.LBE144:
 4981              	.LBB145:
 4982              	.LBB103:
3071:../uvc.c      ****                 switch (bRequest)
 4983              		.loc 1 3071 0
 4984 2c58 850052E3 		cmp	r2, #133
 4985 2c5c 7900000A 		beq	.L418
 4986 2c60 860052E3 		cmp	r2, #134
 4987 2c64 2CFEFF1A 		bne	.L372
 4988 2c68 D2FFFFEA 		b	.L437
 4989              	.LVL386:
 4990              	.L366:
 4991              	.LBE103:
 4992              	.LBE145:
 4993              	.LBB146:
 4994              	.LBB117:
2758:../uvc.c      ****     switch (wValue)
 4995              		.loc 1 2758 0
 4996 2c6c 060C53E3 		cmp	r3, #1536
 4997 2c70 7000000A 		beq	.L353
 4998 2c74 0900008A 		bhi	.L367
 4999 2c78 050C53E3 		cmp	r3, #1280
 5000 2c7c 1CFEFF1A 		bne	.L309
 5001              	.LVL387:
2778:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5002              		.loc 1 2778 0
 5003 2c80 1400A0E3 		mov	r0, #20
 5004 2c84 FEFFFFEB 		bl	ControlHandle
 5005              	.LVL388:
 5006 2c88 30309DE5 		ldr	r3, [sp, #48]
 5007 2c8c 1DFEFFEA 		b	.L308
 5008              	.L336:
 5009              	.LVL389:
 5010              	.LBE117:
 5011              	.LBE146:
 5012              	.LBB147:
 5013              	.LBB93:
2563:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5014              		.loc 1 2563 0
 5015 2c90 0600A0E3 		mov	r0, #6
 5016 2c94 FEFFFFEB 		bl	CTControlHandle
 5017              	.LVL390:
 5018 2c98 30309DE5 		ldr	r3, [sp, #48]
 5019 2c9c 19FEFFEA 		b	.L308
 5020              	.L367:
 5021              	.LBE93:
 5022              	.LBE147:
 5023              	.LBB148:
 5024              	.LBB122:
2758:../uvc.c      ****     switch (wValue)
 5025              		.loc 1 2758 0
 5026 2ca0 070C53E3 		cmp	r3, #1792
 5027 2ca4 5F00000A 		beq	.L354
 5028 2ca8 020B53E3 		cmp	r3, #2048
 5029 2cac 10FEFF1A 		bne	.L309
 5030              	.LVL391:
2790:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5031              		.loc 1 2790 0
 5032 2cb0 1700A0E3 		mov	r0, #23
 5033 2cb4 FEFFFFEB 		bl	ControlHandle
 5034              	.LVL392:
 5035 2cb8 30309DE5 		ldr	r3, [sp, #48]
 5036 2cbc 11FEFFEA 		b	.L308
 5037              	.L343:
 5038              	.LBE122:
 5039              	.LBE148:
 5040              	.LBB149:
 5041              	.LBB100:
2533:../uvc.c      ****     switch (wValue)
 5042              		.loc 1 2533 0
 5043 2cc0 0B0C52E3 		cmp	r2, #2816
 5044 2cc4 0F00000A 		beq	.L339
 5045 2cc8 030B52E3 		cmp	r2, #3072
 5046 2ccc 0900000A 		beq	.L340
 5047 2cd0 0A0C52E3 		cmp	r2, #2560
 5048 2cd4 02FEFF1A 		bne	.L329
 5049              	.LVL393:
2574:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5050              		.loc 1 2574 0
 5051 2cd8 0800A0E3 		mov	r0, #8
 5052 2cdc FEFFFFEB 		bl	CTControlHandle
 5053              	.LVL394:
 5054 2ce0 30309DE5 		ldr	r3, [sp, #48]
 5055 2ce4 07FEFFEA 		b	.L308
 5056              	.L337:
 5057              	.LVL395:
2569:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5058              		.loc 1 2569 0
 5059 2ce8 0700A0E3 		mov	r0, #7
 5060 2cec FEFFFFEB 		bl	CTControlHandle
 5061              	.LVL396:
 5062 2cf0 30309DE5 		ldr	r3, [sp, #48]
 5063 2cf4 03FEFFEA 		b	.L308
 5064              	.L340:
 5065              	.LVL397:
2582:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5066              		.loc 1 2582 0
 5067 2cf8 0A00A0E3 		mov	r0, #10
 5068 2cfc FEFFFFEB 		bl	CTControlHandle
 5069              	.LVL398:
 5070 2d00 30309DE5 		ldr	r3, [sp, #48]
 5071 2d04 FFFDFFEA 		b	.L308
 5072              	.L339:
 5073              	.LVL399:
2578:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5074              		.loc 1 2578 0
 5075 2d08 0900A0E3 		mov	r0, #9
 5076 2d0c FEFFFFEB 		bl	CTControlHandle
 5077              	.LVL400:
 5078 2d10 30309DE5 		ldr	r3, [sp, #48]
 5079 2d14 FBFDFFEA 		b	.L308
 5080              	.L362:
 5081              	.LVL401:
 5082              	.LBE100:
 5083              	.LBE149:
 5084              	.LBB150:
 5085              	.LBB116:
2825:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5086              		.loc 1 2825 0
 5087 2d18 2000A0E3 		mov	r0, #32
 5088 2d1c FEFFFFEB 		bl	ControlHandle
 5089              	.LVL402:
 5090 2d20 30309DE5 		ldr	r3, [sp, #48]
 5091 2d24 F7FDFFEA 		b	.L308
 5092              	.LVL403:
 5093              	.L451:
 5094              	.LBE116:
 5095              	.LBE150:
 5096              	.LBB151:
 5097              	.LBB111:
2873:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5098              		.loc 1 2873 0
 5099 2d28 1A00A0E3 		mov	r0, #26
 5100 2d2c 80119FE5 		ldr	r1, .L452+80
 5101 2d30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5102 2d34 30309DE5 		ldr	r3, [sp, #48]
 5103 2d38 FCFDFFEA 		b	.L370
 5104              	.LVL404:
 5105              	.L359:
 5106              	.LBE111:
 5107              	.LBE151:
 5108              	.LBB152:
 5109              	.LBB123:
2809:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5110              		.loc 1 2809 0
 5111 2d3c 1C00A0E3 		mov	r0, #28
 5112 2d40 FEFFFFEB 		bl	ControlHandle
 5113              	.LVL405:
 5114 2d44 30309DE5 		ldr	r3, [sp, #48]
 5115 2d48 EEFDFFEA 		b	.L308
 5116              	.L358:
 5117              	.LVL406:
2805:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5118              		.loc 1 2805 0
 5119 2d4c 1A00A0E3 		mov	r0, #26
 5120 2d50 FEFFFFEB 		bl	ControlHandle
 5121              	.LVL407:
 5122 2d54 30309DE5 		ldr	r3, [sp, #48]
 5123 2d58 EAFDFFEA 		b	.L308
 5124              	.L360:
 5125              	.LVL408:
2817:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5126              		.loc 1 2817 0
 5127 2d5c 1E00A0E3 		mov	r0, #30
 5128 2d60 FEFFFFEB 		bl	ControlHandle
 5129              	.LVL409:
 5130 2d64 30309DE5 		ldr	r3, [sp, #48]
 5131 2d68 E6FDFFEA 		b	.L308
 5132              	.LVL410:
 5133              	.L422:
 5134              	.LBE123:
 5135              	.LBE152:
 5136              	.LBB153:
 5137              	.LBB102:
3112:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5138              		.loc 1 3112 0
 5139 2d6c 44119FE5 		ldr	r1, .L452+84
 5140 2d70 B623DDE1 		ldrh	r2, [sp, #54]
 5141 2d74 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5142 2d78 0400A0E3 		mov	r0, #4
 5143              	.LVL411:
 5144 2d7c FEFFFFEB 		bl	CyU3PDebugPrint
 5145 2d80 E5FDFFEA 		b	.L372
 5146              	.LVL412:
 5147              	.L447:
2936:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5148              		.loc 1 2936 0
 5149 2d84 2000A0E3 		mov	r0, #32
 5150 2d88 00119FE5 		ldr	r1, .L452+44
 5151 2d8c 36208DE2 		add	r2, sp, #54
 5152 2d90 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5153              	.LVL413:
2938:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5154              		.loc 1 2938 0
 5155 2d94 000050E3 		cmp	r0, #0
 5156 2d98 E3FDFF1A 		bne	.L432
2951:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5157              		.loc 1 2951 0
 5158 2d9c 0020A0E3 		mov	r2, #0
 5159 2da0 BC009FE5 		ldr	r0, .L452
 5160              	.LVL414:
 5161 2da4 0110A0E3 		mov	r1, #1
 5162 2da8 FEFFFFEB 		bl	_txe_event_flags_set
 5163              	.LVL415:
2952:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5164              		.loc 1 2952 0
 5165 2dac 002050E2 		subs	r2, r0, #0
 5166 2db0 DDFDFF0A 		beq	.L432
 5167              	.L414:
3059:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5168              		.loc 1 3059 0
 5169 2db4 0400A0E3 		mov	r0, #4
 5170              	.LVL416:
 5171 2db8 D4109FE5 		ldr	r1, .L452+48
 5172 2dbc FEFFFFEB 		bl	CyU3PDebugPrint
 5173              	.LVL417:
 5174 2dc0 30309DE5 		ldr	r3, [sp, #48]
 5175 2dc4 D9FDFFEA 		b	.L370
 5176              	.LVL418:
 5177              	.L417:
3083:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5178              		.loc 1 3083 0
 5179 2dc8 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5180 2dcc 030051E3 		cmp	r1, #3
 5181 2dd0 DBFEFF1A 		bne	.L421
3085:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5182              		.loc 1 3085 0
 5183 2dd4 1A00A0E3 		mov	r0, #26
 5184 2dd8 DC109FE5 		ldr	r1, .L452+88
 5185 2ddc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5186 2de0 30309DE5 		ldr	r3, [sp, #48]
 5187 2de4 D1FDFFEA 		b	.L370
 5188              	.LVL419:
 5189              	.L350:
 5190              	.LBE102:
 5191              	.LBE153:
 5192              	.LBB154:
 5193              	.LBB115:
2770:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5194              		.loc 1 2770 0
 5195 2de8 1200A0E3 		mov	r0, #18
 5196 2dec FEFFFFEB 		bl	ControlHandle
 5197              	.LVL420:
 5198 2df0 30309DE5 		ldr	r3, [sp, #48]
 5199 2df4 C3FDFFEA 		b	.L308
 5200              	.L349:
 5201              	.LVL421:
2766:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5202              		.loc 1 2766 0
 5203 2df8 1100A0E3 		mov	r0, #17
 5204 2dfc FEFFFFEB 		bl	ControlHandle
 5205              	.LVL422:
 5206 2e00 30309DE5 		ldr	r3, [sp, #48]
 5207 2e04 BFFDFFEA 		b	.L308
 5208              	.L351:
 5209              	.LVL423:
2774:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5210              		.loc 1 2774 0
 5211 2e08 1300A0E3 		mov	r0, #19
 5212 2e0c FEFFFFEB 		bl	ControlHandle
 5213              	.LVL424:
 5214 2e10 30309DE5 		ldr	r3, [sp, #48]
 5215 2e14 BBFDFFEA 		b	.L308
 5216              	.L356:
 5217              	.LVL425:
2794:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5218              		.loc 1 2794 0
 5219 2e18 1800A0E3 		mov	r0, #24
 5220 2e1c FEFFFFEB 		bl	ControlHandle
 5221              	.LVL426:
 5222 2e20 30309DE5 		ldr	r3, [sp, #48]
 5223 2e24 B7FDFFEA 		b	.L308
 5224              	.L354:
 5225              	.LVL427:
2786:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5226              		.loc 1 2786 0
 5227 2e28 1600A0E3 		mov	r0, #22
 5228 2e2c FEFFFFEB 		bl	ControlHandle
 5229              	.LVL428:
 5230 2e30 30309DE5 		ldr	r3, [sp, #48]
 5231 2e34 B3FDFFEA 		b	.L308
 5232              	.L353:
 5233              	.LVL429:
2782:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5234              		.loc 1 2782 0
 5235 2e38 1500A0E3 		mov	r0, #21
 5236 2e3c FEFFFFEB 		bl	ControlHandle
 5237              	.LVL430:
 5238 2e40 30309DE5 		ldr	r3, [sp, #48]
 5239 2e44 AFFDFFEA 		b	.L308
 5240              	.LVL431:
 5241              	.L418:
 5242              	.LBE115:
 5243              	.LBE154:
 5244              	.LBB155:
 5245              	.LBB112:
3080:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5246              		.loc 1 3080 0
 5247 2e48 0200A0E3 		mov	r0, #2
 5248 2e4c 54109FE5 		ldr	r1, .L452+68
 5249 2e50 EFFEFFEA 		b	.L433
 5250              	.LVL432:
 5251              	.L363:
 5252              	.LBE112:
 5253              	.LBE155:
 5254              	.LBB156:
 5255              	.LBB124:
2829:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5256              		.loc 1 2829 0
 5257 2e54 2100A0E3 		mov	r0, #33
 5258 2e58 FEFFFFEB 		bl	ControlHandle
 5259              	.LVL433:
 5260 2e5c 30309DE5 		ldr	r3, [sp, #48]
 5261 2e60 A8FDFFEA 		b	.L308
 5262              	.L453:
 5263              		.align	2
 5264              	.L452:
 5265 2e64 00000000 		.word	.LANCHOR0
 5266 2e68 00000000 		.word	.LANCHOR1
 5267 2e6c 00000000 		.word	bRequest
 5268 2e70 00000000 		.word	wValue
 5269 2e74 00000000 		.word	wIndex
 5270 2e78 00000000 		.word	glInterStaBuffer
 5271 2e7c E8040000 		.word	.LC26
 5272 2e80 00000000 		.word	glChHandleInterStat
 5273 2e84 00000000 		.word	bmReqType
 5274 2e88 00000000 		.word	wLength
 5275 2e8c 6C040000 		.word	.LC25
 5276 2e90 7C000000 		.word	.LANCHOR0+124
 5277 2e94 14050000 		.word	.LC27
 5278 2e98 3C050000 		.word	.LC28
 5279 2e9c 64060000 		.word	.LANCHOR1+1636
 5280 2ea0 70060000 		.word	.LANCHOR1+1648
 5281 2ea4 2C060000 		.word	.LANCHOR1+1580
 5282 2ea8 58000000 		.word	.LANCHOR0+88
 5283 2eac 8C050000 		.word	.LC30
 5284 2eb0 D8010000 		.word	.LC12
 5285 2eb4 10060000 		.word	.LANCHOR1+1552
 5286 2eb8 64050000 		.word	.LC29
 5287 2ebc 48060000 		.word	.LANCHOR1+1608
 5288              	.LBE124:
 5289              	.LBE156:
 5290              		.cfi_endproc
 5291              	.LFE24:
 5293              		.align	2
 5294              		.global	CamDefSet
 5296              	CamDefSet:
 5297              	.LFB4:
1143:../uvc.c      **** {
 5298              		.loc 1 1143 0
 5299              		.cfi_startproc
 5300              		@ args = 0, pretend = 0, frame = 24
 5301              		@ frame_needed = 0, uses_anonymous_args = 0
 5302              	.LVL434:
 5303 2ec0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5304              	.LCFI19:
 5305              		.cfi_def_cfa_offset 36
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5306              		.loc 1 1149 0
 5307 2ec4 AC429FE5 		ldr	r4, .L457
 5308              		.cfi_offset 14, -4
 5309              		.cfi_offset 11, -8
 5310              		.cfi_offset 10, -12
 5311              		.cfi_offset 9, -16
 5312              		.cfi_offset 8, -20
 5313              		.cfi_offset 7, -24
 5314              		.cfi_offset 6, -28
 5315              		.cfi_offset 5, -32
 5316              		.cfi_offset 4, -36
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5317              		.loc 1 1154 0
 5318 2ec8 AC229FE5 		ldr	r2, .L457+4
1151:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5319              		.loc 1 1151 0
 5320 2ecc A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1143:../uvc.c      **** {
 5321              		.loc 1 1143 0
 5322 2ed0 2CD04DE2 		sub	sp, sp, #44
 5323              	.LCFI20:
 5324              		.cfi_def_cfa_offset 80
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5325              		.loc 1 1154 0
 5326 2ed4 1C0092E5 		ldr	r0, [r2, #28]
 5327 2ed8 0010E0E3 		mvn	r1, #0
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5328              		.loc 1 1156 0
 5329 2edc 2963A0E1 		mov	r6, r9, lsr #6
1150:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5330              		.loc 1 1150 0
 5331 2ee0 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1149:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5332              		.loc 1 1149 0
 5333 2ee4 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5334              	.LVL435:
1154:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5335              		.loc 1 1154 0
 5336 2ee8 FEFFFFEB 		bl	_txe_mutex_get
1155:../uvc.c      ****     if(Data1&0x80){
 5337              		.loc 1 1155 0
 5338 2eec 800019E3 		tst	r9, #128
1156:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5339              		.loc 1 1156 0
 5340 2ef0 01600612 		andne	r6, r6, #1
 5341 2ef4 0660E011 		mvnne	r6, r6
 5342 2ef8 3B600612 		andne	r6, r6, #59
 5343 2efc 0660E011 		mvnne	r6, r6
 5344 2f00 FF600612 		andne	r6, r6, #255
 5345              	.LVL436:
1158:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5346              		.loc 1 1158 0
 5347 2f04 C6608603 		orreq	r6, r6, #198
 5348              	.LVL437:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5349              		.loc 1 1162 0
 5350 2f08 0080A0E3 		mov	r8, #0
 5351 2f0c 0A20A0E1 		mov	r2, sl
 5352 2f10 0730A0E1 		mov	r3, r7
 5353 2f14 0110A0E3 		mov	r1, #1
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5354              		.loc 1 1160 0
 5355 2f18 0951A0E1 		mov	r5, r9, asl #2
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5356              		.loc 1 1162 0
 5357 2f1c 58029FE5 		ldr	r0, .L457+4
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5358              		.loc 1 1165 0
 5359 2f20 0190A0E3 		mov	r9, #1
 5360              	.LVL438:
1160:../uvc.c      ****     Data0 = (Data0 << 2);
 5361              		.loc 1 1160 0
 5362 2f24 FF5005E2 		and	r5, r5, #255
 5363              	.LVL439:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5364              		.loc 1 1162 0
 5365 2f28 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5366 2f2c FEFFFFEB 		bl	cmdSet
 5367              	.LVL440:
1165:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5368              		.loc 1 1165 0
 5369 2f30 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5370 2f34 0910A0E1 		mov	r1, r9
 5371 2f38 0730A0E1 		mov	r3, r7
 5372 2f3c 38029FE5 		ldr	r0, .L457+4
 5373 2f40 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5374 2f44 FEFFFFEB 		bl	cmdSet
 5375              	.LVL441:
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5376              		.loc 1 1168 0
 5377 2f48 0620A0E1 		mov	r2, r6
 5378 2f4c 0530A0E1 		mov	r3, r5
 5379 2f50 28129FE5 		ldr	r1, .L457+8
 5380 2f54 0400A0E3 		mov	r0, #4
1167:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5381              		.loc 1 1167 0
 5382 2f58 A661C4E5 		strb	r6, [r4, #422]
1166:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5383              		.loc 1 1166 0
 5384 2f5c A551C4E5 		strb	r5, [r4, #421]
1168:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5385              		.loc 1 1168 0
 5386 2f60 FEFFFFEB 		bl	CyU3PDebugPrint
 5387              	.LVL442:
1173:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5388              		.loc 1 1173 0
 5389 2f64 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5390              	.LVL443:
1174:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5391              		.loc 1 1174 0
 5392 2f68 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5393 2f6c BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5394 2f70 0210A0E3 		mov	r1, #2
 5395 2f74 00029FE5 		ldr	r0, .L457+4
 5396 2f78 00B08DE5 		str	fp, [sp, #0]
 5397 2f7c 04808DE5 		str	r8, [sp, #4]
 5398 2f80 FEFFFFEB 		bl	cmdSet
 5399              	.LVL444:
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5400              		.loc 1 1176 0
 5401 2f84 0B20A0E1 		mov	r2, fp
 5402 2f88 0530A0E1 		mov	r3, r5
 5403 2f8c EC119FE5 		ldr	r1, .L457+8
 5404 2f90 0400A0E3 		mov	r0, #4
1175:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5405              		.loc 1 1175 0
 5406 2f94 BD51C4E5 		strb	r5, [r4, #445]
1176:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5407              		.loc 1 1176 0
 5408 2f98 FEFFFFEB 		bl	CyU3PDebugPrint
 5409              	.LVL445:
1181:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5410              		.loc 1 1181 0
 5411 2f9c 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1180:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5412              		.loc 1 1180 0
 5413 2fa0 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5414              	.LVL446:
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5415              		.loc 1 1182 0
 5416 2fa4 80B047E2 		sub	fp, r7, #128
 5417 2fa8 FF100BE2 		and	r1, fp, #255
 5418 2fac 14108DE5 		str	r1, [sp, #20]
 5419 2fb0 14C09DE5 		ldr	ip, [sp, #20]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5420              		.loc 1 1183 0
 5421 2fb4 760047E2 		sub	r0, r7, #118
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5422              		.loc 1 1184 0
 5423 2fb8 7EE087E2 		add	lr, r7, #126
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5424              		.loc 1 1182 0
 5425 2fbc 0630A0E1 		mov	r3, r6
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5426              		.loc 1 1183 0
 5427 2fc0 18008DE5 		str	r0, [sp, #24]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5428              		.loc 1 1182 0
 5429 2fc4 0510A0E3 		mov	r1, #5
 5430 2fc8 DF20A0E3 		mov	r2, #223
 5431 2fcc A8019FE5 		ldr	r0, .L457+4
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5432              		.loc 1 1184 0
 5433 2fd0 1CE08DE5 		str	lr, [sp, #28]
1182:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5434              		.loc 1 1182 0
 5435 2fd4 00C08DE5 		str	ip, [sp, #0]
 5436 2fd8 04808DE5 		str	r8, [sp, #4]
 5437 2fdc FEFFFFEB 		bl	cmdSet
 5438              	.LVL447:
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5439              		.loc 1 1183 0
 5440 2fe0 18A09DE5 		ldr	sl, [sp, #24]
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5441              		.loc 1 1185 0
 5442 2fe4 72E087E2 		add	lr, r7, #114
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5443              		.loc 1 1183 0
 5444 2fe8 FFC00AE2 		and	ip, sl, #255
 5445 2fec 0630A0E1 		mov	r3, r6
 5446 2ff0 0510A0E3 		mov	r1, #5
 5447 2ff4 DC20A0E3 		mov	r2, #220
 5448 2ff8 7C019FE5 		ldr	r0, .L457+4
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5449              		.loc 1 1185 0
 5450 2ffc 20E08DE5 		str	lr, [sp, #32]
1183:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5451              		.loc 1 1183 0
 5452 3000 00C08DE5 		str	ip, [sp, #0]
 5453 3004 04908DE5 		str	r9, [sp, #4]
 5454 3008 FEFFFFEB 		bl	cmdSet
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5455              		.loc 1 1184 0
 5456 300c 1C009DE5 		ldr	r0, [sp, #28]
 5457 3010 02E0A0E3 		mov	lr, #2
 5458 3014 FFC000E2 		and	ip, r0, #255
 5459 3018 0630A0E1 		mov	r3, r6
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5460              		.loc 1 1186 0
 5461 301c 6FA047E2 		sub	sl, r7, #111
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5462              		.loc 1 1184 0
 5463 3020 0510A0E3 		mov	r1, #5
 5464 3024 DE20A0E3 		mov	r2, #222
 5465 3028 4C019FE5 		ldr	r0, .L457+4
 5466 302c 04E08DE5 		str	lr, [sp, #4]
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5467              		.loc 1 1186 0
 5468 3030 24A08DE5 		str	sl, [sp, #36]
1184:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5469              		.loc 1 1184 0
 5470 3034 00C08DE5 		str	ip, [sp, #0]
 5471 3038 FEFFFFEB 		bl	cmdSet
1185:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5472              		.loc 1 1185 0
 5473 303c 20A09DE5 		ldr	sl, [sp, #32]
 5474 3040 0630A0E1 		mov	r3, r6
 5475 3044 FFC00AE2 		and	ip, sl, #255
 5476 3048 00C08DE5 		str	ip, [sp, #0]
 5477 304c 0510A0E3 		mov	r1, #5
 5478 3050 03C0A0E3 		mov	ip, #3
 5479 3054 E020A0E3 		mov	r2, #224
 5480 3058 1C019FE5 		ldr	r0, .L457+4
 5481 305c 04C08DE5 		str	ip, [sp, #4]
 5482 3060 FEFFFFEB 		bl	cmdSet
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5483              		.loc 1 1186 0
 5484 3064 24009DE5 		ldr	r0, [sp, #36]
 5485 3068 04A0A0E3 		mov	sl, #4
 5486 306c FFC000E2 		and	ip, r0, #255
 5487 3070 0630A0E1 		mov	r3, r6
 5488 3074 0510A0E3 		mov	r1, #5
 5489 3078 DD20A0E3 		mov	r2, #221
 5490 307c F8009FE5 		ldr	r0, .L457+4
 5491 3080 00C08DE5 		str	ip, [sp, #0]
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5492              		.loc 1 1187 0
 5493 3084 7F7087E2 		add	r7, r7, #127
 5494              	.LVL448:
1186:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5495              		.loc 1 1186 0
 5496 3088 04A08DE5 		str	sl, [sp, #4]
 5497 308c FEFFFFEB 		bl	cmdSet
1187:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5498              		.loc 1 1187 0
 5499 3090 05E0A0E3 		mov	lr, #5
 5500 3094 0E10A0E1 		mov	r1, lr
 5501 3098 0630A0E1 		mov	r3, r6
 5502 309c E120A0E3 		mov	r2, #225
 5503 30a0 FF6007E2 		and	r6, r7, #255
 5504              	.LVL449:
 5505 30a4 D0009FE5 		ldr	r0, .L457+4
 5506 30a8 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5507 30ac FEFFFFEB 		bl	cmdSet
 5508              	.LVL450:
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5509              		.loc 1 1188 0
 5510 30b0 14C09DE5 		ldr	ip, [sp, #20]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5511              		.loc 1 1189 0
 5512 30b4 24E09DE5 		ldr	lr, [sp, #36]
 5513 30b8 1C609DE5 		ldr	r6, [sp, #28]
1188:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5514              		.loc 1 1188 0
 5515 30bc 05C2C4E5 		strb	ip, [r4, #517]
1189:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5516              		.loc 1 1189 0
 5517 30c0 20C09DE5 		ldr	ip, [sp, #32]
 5518 30c4 0B20A0E1 		mov	r2, fp
 5519 30c8 18309DE5 		ldr	r3, [sp, #24]
 5520 30cc B0109FE5 		ldr	r1, .L457+12
 5521 30d0 0A00A0E1 		mov	r0, sl
 5522 30d4 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5523 30d8 0C708DE5 		str	r7, [sp, #12]
 5524 30dc FEFFFFEB 		bl	CyU3PDebugPrint
 5525              	.LVL451:
1193:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5526              		.loc 1 1193 0
 5527 30e0 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5528              	.LVL452:
1194:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5529              		.loc 1 1194 0
 5530 30e4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5531              	.LVL453:
1195:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5532              		.loc 1 1195 0
 5533 30e8 0730A0E1 		mov	r3, r7
 5534 30ec 0610A0E3 		mov	r1, #6
 5535 30f0 8520A0E3 		mov	r2, #133
 5536 30f4 80009FE5 		ldr	r0, .L457+4
 5537 30f8 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5538 30fc FEFFFFEB 		bl	cmdSet
1196:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5539              		.loc 1 1196 0
 5540 3100 0730A0E1 		mov	r3, r7
 5541 3104 0610A0E3 		mov	r1, #6
 5542 3108 8620A0E3 		mov	r2, #134
 5543 310c 68009FE5 		ldr	r0, .L457+4
 5544 3110 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5545 3114 FEFFFFEB 		bl	cmdSet
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5546              		.loc 1 1198 0
 5547 3118 0620A0E1 		mov	r2, r6
 5548 311c 0530A0E1 		mov	r3, r5
 5549 3120 58109FE5 		ldr	r1, .L457+8
 5550 3124 0A00A0E1 		mov	r0, sl
1197:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5551              		.loc 1 1197 0
 5552 3128 1D62C4E5 		strb	r6, [r4, #541]
1198:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5553              		.loc 1 1198 0
 5554 312c FEFFFFEB 		bl	CyU3PDebugPrint
 5555              	.LVL454:
1203:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5556              		.loc 1 1203 0
 5557 3130 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5558              	.LVL455:
1204:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5559              		.loc 1 1204 0
 5560 3134 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5561 3138 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5562 313c 0710A0E3 		mov	r1, #7
 5563 3140 34009FE5 		ldr	r0, .L457+4
 5564 3144 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5565 3148 FEFFFFEB 		bl	cmdSet
 5566              	.LVL456:
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5567              		.loc 1 1206 0
 5568 314c 0530A0E1 		mov	r3, r5
 5569 3150 0A00A0E1 		mov	r0, sl
 5570 3154 24109FE5 		ldr	r1, .L457+8
 5571 3158 0620A0E1 		mov	r2, r6
1205:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5572              		.loc 1 1205 0
 5573 315c 3552C4E5 		strb	r5, [r4, #565]
1206:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5574              		.loc 1 1206 0
 5575 3160 FEFFFFEB 		bl	CyU3PDebugPrint
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5576              		.loc 1 1208 0
 5577 3164 10309FE5 		ldr	r3, .L457+4
 5578 3168 1C0093E5 		ldr	r0, [r3, #28]
1211:../uvc.c      **** }
 5579              		.loc 1 1211 0
 5580 316c 2CD08DE2 		add	sp, sp, #44
 5581 3170 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1208:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5582              		.loc 1 1208 0
 5583 3174 FEFFFFEA 		b	_txe_mutex_put
 5584              	.L458:
 5585              		.align	2
 5586              	.L457:
 5587 3178 00000000 		.word	.LANCHOR1
 5588 317c 00000000 		.word	cmdQu
 5589 3180 C0050000 		.word	.LC31
 5590 3184 E0050000 		.word	.LC32
 5591              		.cfi_endproc
 5592              	.LFE4:
 5594              		.align	2
 5595              		.global	CyFxUVCAddHeader
 5597              	CyFxUVCAddHeader:
 5598              	.LFB5:
1219:../uvc.c      **** {
 5599              		.loc 1 1219 0
 5600              		.cfi_startproc
 5601              		@ args = 0, pretend = 0, frame = 0
 5602              		@ frame_needed = 0, uses_anonymous_args = 0
 5603              	.LVL457:
 5604 3188 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5605              	.LCFI21:
 5606              		.cfi_def_cfa_offset 16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5607              		.loc 1 1221 0
 5608 318c 0C20A0E3 		mov	r2, #12
1219:../uvc.c      **** {
 5609              		.loc 1 1219 0
 5610 3190 0150A0E1 		mov	r5, r1
 5611              		.cfi_offset 14, -4
 5612              		.cfi_offset 5, -8
 5613              		.cfi_offset 4, -12
 5614              		.cfi_offset 3, -16
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5615              		.loc 1 1221 0
 5616 3194 18109FE5 		ldr	r1, .L461
 5617              	.LVL458:
1219:../uvc.c      **** {
 5618              		.loc 1 1219 0
 5619 3198 0040A0E1 		mov	r4, r0
1221:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5620              		.loc 1 1221 0
 5621 319c FEFFFFEB 		bl	CyU3PMemCopy
 5622              	.LVL459:
1224:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5623              		.loc 1 1224 0
 5624 31a0 020015E3 		tst	r5, #2
1226:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5625              		.loc 1 1226 0
 5626 31a4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5627 31a8 02308313 		orrne	r3, r3, #2
 5628 31ac 0130C415 		strneb	r3, [r4, #1]
 5629 31b0 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5630              	.L462:
 5631              		.align	2
 5632              	.L461:
 5633 31b4 80040000 		.word	.LANCHOR1+1152
 5634              		.cfi_endproc
 5635              	.LFE5:
 5637              		.align	2
 5638              		.global	CyFxAppErrorHandler
 5640              	CyFxAppErrorHandler:
 5641              	.LFB6:
1236:../uvc.c      **** {
 5642              		.loc 1 1236 0
 5643              		.cfi_startproc
 5644              		@ args = 0, pretend = 0, frame = 0
 5645              		@ frame_needed = 0, uses_anonymous_args = 0
 5646              	.LVL460:
 5647 31b8 08402DE9 		stmfd	sp!, {r3, lr}
 5648              	.LCFI22:
 5649              		.cfi_def_cfa_offset 8
 5650              	.LVL461:
 5651              	.L464:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5652              		.loc 1 1246 0 discriminator 1
 5653 31bc 10109FE5 		ldr	r1, .L465
 5654 31c0 0400A0E3 		mov	r0, #4
 5655              		.cfi_offset 14, -4
 5656              		.cfi_offset 3, -8
 5657 31c4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 5658              		.loc 1 1247 0 discriminator 1
 5659 31c8 FA0FA0E3 		mov	r0, #1000
 5660 31cc FEFFFFEB 		bl	_tx_thread_sleep
 5661 31d0 F9FFFFEA 		b	.L464
 5662              	.L466:
 5663              		.align	2
 5664              	.L465:
 5665 31d4 D8010000 		.word	.LC12
 5666              		.cfi_endproc
 5667              	.LFE6:
 5669              		.align	2
 5670              		.global	UVCAppThread_Entry
 5672              	UVCAppThread_Entry:
 5673              	.LFB18:
2202:../uvc.c      **** {
 5674              		.loc 1 2202 0
 5675              		.cfi_startproc
 5676              		@ args = 0, pretend = 0, frame = 176
 5677              		@ frame_needed = 0, uses_anonymous_args = 0
 5678              	.LVL462:
 5679 31d8 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5680              	.LCFI23:
 5681              		.cfi_def_cfa_offset 28
 5682 31dc BCD04DE2 		sub	sp, sp, #188
 5683              	.LCFI24:
 5684              		.cfi_def_cfa_offset 216
 5685              	.LBB209:
 5686              	.LBB210:
1659:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5687              		.loc 1 1659 0
 5688              		.cfi_offset 14, -4
 5689              		.cfi_offset 10, -8
 5690              		.cfi_offset 8, -12
 5691              		.cfi_offset 7, -16
 5692              		.cfi_offset 6, -20
 5693              		.cfi_offset 5, -24
 5694              		.cfi_offset 4, -28
 5695 31e0 FEFFFFEB 		bl	CyU3PUartInit
 5696              	.LVL463:
1660:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5697              		.loc 1 1660 0
 5698 31e4 004050E2 		subs	r4, r0, #0
 5699 31e8 0400000A 		beq	.L468
1662:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5700              		.loc 1 1662 0
 5701 31ec 0400A0E3 		mov	r0, #4
 5702              	.LVL464:
 5703 31f0 4C1A9FE5 		ldr	r1, .L558
 5704 31f4 FEFFFFEB 		bl	CyU3PDebugPrint
1663:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5705              		.loc 1 1663 0
 5706 31f8 0400A0E1 		mov	r0, r4
 5707 31fc FEFFFFEB 		bl	CyFxAppErrorHandler
 5708              	.L468:
1667:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5709              		.loc 1 1667 0
 5710 3200 40CA9FE5 		ldr	ip, .L558+4
1669:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5711              		.loc 1 1669 0
 5712 3204 0030A0E3 		mov	r3, #0
1668:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5713              		.loc 1 1668 0
 5714 3208 0120A0E3 		mov	r2, #1
1676:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5715              		.loc 1 1676 0
 5716 320c 50008DE2 		add	r0, sp, #80
 5717 3210 0310A0E1 		mov	r1, r3
1667:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5718              		.loc 1 1667 0
 5719 3214 60C08DE5 		str	ip, [sp, #96]
1668:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5720              		.loc 1 1668 0
 5721 3218 6420CDE5 		strb	r2, [sp, #100]
1669:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5722              		.loc 1 1669 0
 5723 321c 6530CDE5 		strb	r3, [sp, #101]
1670:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5724              		.loc 1 1670 0
 5725 3220 50208DE5 		str	r2, [sp, #80]
1671:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5726              		.loc 1 1671 0
 5727 3224 54308DE5 		str	r3, [sp, #84]
1672:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5728              		.loc 1 1672 0
 5729 3228 58308DE5 		str	r3, [sp, #88]
1673:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5730              		.loc 1 1673 0
 5731 322c 5C208DE5 		str	r2, [sp, #92]
1676:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5732              		.loc 1 1676 0
 5733 3230 FEFFFFEB 		bl	CyU3PUartSetConfig
 5734              	.LVL465:
1677:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5735              		.loc 1 1677 0
 5736 3234 000050E3 		cmp	r0, #0
 5737 3238 0000000A 		beq	.L469
1679:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5738              		.loc 1 1679 0
 5739 323c FEFFFFEB 		bl	CyFxAppErrorHandler
 5740              	.LVL466:
 5741              	.L469:
1683:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5742              		.loc 1 1683 0
 5743 3240 0000E0E3 		mvn	r0, #0
 5744 3244 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5745              	.LVL467:
1684:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5746              		.loc 1 1684 0
 5747 3248 000050E3 		cmp	r0, #0
 5748 324c 0000000A 		beq	.L470
1686:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5749              		.loc 1 1686 0
 5750 3250 FEFFFFEB 		bl	CyFxAppErrorHandler
 5751              	.LVL468:
 5752              	.L470:
1690:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5753              		.loc 1 1690 0
 5754 3254 0300A0E3 		mov	r0, #3
 5755 3258 0410A0E3 		mov	r1, #4
 5756 325c FEFFFFEB 		bl	CyU3PDebugInit
 5757              	.LVL469:
1691:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5758              		.loc 1 1691 0
 5759 3260 000050E3 		cmp	r0, #0
 5760 3264 0000000A 		beq	.L471
1693:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5761              		.loc 1 1693 0
 5762 3268 FEFFFFEB 		bl	CyFxAppErrorHandler
 5763              	.LVL470:
 5764              	.L471:
1697:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5765              		.loc 1 1697 0
 5766 326c 0000A0E3 		mov	r0, #0
 5767 3270 FEFFFFEB 		bl	CyU3PDebugPreamble
 5768              	.LVL471:
 5769              	.LBE210:
 5770              	.LBE209:
2218:../uvc.c      **** 		CyU3PThreadSleep(500);
 5771              		.loc 1 2218 0
 5772 3274 7D0FA0E3 		mov	r0, #500
 5773 3278 FEFFFFEB 		bl	_tx_thread_sleep
 5774              	.LVL472:
 5775 327c 7D0FA0E3 		mov	r0, #500
 5776 3280 FEFFFFEB 		bl	_tx_thread_sleep
 5777 3284 7D0FA0E3 		mov	r0, #500
 5778 3288 FEFFFFEB 		bl	_tx_thread_sleep
 5779 328c 7D0FA0E3 		mov	r0, #500
 5780 3290 FEFFFFEB 		bl	_tx_thread_sleep
 5781 3294 7D0FA0E3 		mov	r0, #500
 5782 3298 FEFFFFEB 		bl	_tx_thread_sleep
 5783 329c 7D0FA0E3 		mov	r0, #500
 5784 32a0 FEFFFFEB 		bl	_tx_thread_sleep
 5785              	.LBB211:
 5786              	.LBB212:
1707:../uvc.c      ****     status = CyU3PI2cInit ();
 5787              		.loc 1 1707 0
 5788 32a4 FEFFFFEB 		bl	CyU3PI2cInit
 5789              	.LVL473:
1708:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5790              		.loc 1 1708 0
 5791 32a8 004050E2 		subs	r4, r0, #0
 5792 32ac 0400000A 		beq	.L472
1710:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5793              		.loc 1 1710 0
 5794 32b0 0400A0E3 		mov	r0, #4
 5795              	.LVL474:
 5796 32b4 90199FE5 		ldr	r1, .L558+8
 5797 32b8 FEFFFFEB 		bl	CyU3PDebugPrint
1711:../uvc.c      ****         CyFxAppErrorHandler (status);
 5798              		.loc 1 1711 0
 5799 32bc 0400A0E1 		mov	r0, r4
 5800 32c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5801              	.L472:
1715:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5802              		.loc 1 1715 0
 5803 32c4 84699FE5 		ldr	r6, .L558+12
1716:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5804              		.loc 1 1716 0
 5805 32c8 0050A0E3 		mov	r5, #0
1717:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5806              		.loc 1 1717 0
 5807 32cc 0040E0E3 		mvn	r4, #0
 5808              	.LVL475:
1720:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5809              		.loc 1 1720 0
 5810 32d0 8C008DE2 		add	r0, sp, #140
 5811 32d4 0510A0E1 		mov	r1, r5
1717:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5812              		.loc 1 1717 0
 5813 32d8 94408DE5 		str	r4, [sp, #148]
1718:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5814              		.loc 1 1718 0
 5815 32dc B849CDE1 		strh	r4, [sp, #152]	@ movhi
1715:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5816              		.loc 1 1715 0
 5817 32e0 8C608DE5 		str	r6, [sp, #140]
1716:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5818              		.loc 1 1716 0
 5819 32e4 90508DE5 		str	r5, [sp, #144]
1720:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5820              		.loc 1 1720 0
 5821 32e8 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5822              	.LVL476:
1721:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5823              		.loc 1 1721 0
 5824 32ec 004050E2 		subs	r4, r0, #0
 5825 32f0 0400000A 		beq	.L473
1723:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 5826              		.loc 1 1723 0
 5827 32f4 0400A0E3 		mov	r0, #4
 5828              	.LVL477:
 5829 32f8 54199FE5 		ldr	r1, .L558+16
 5830 32fc FEFFFFEB 		bl	CyU3PDebugPrint
1724:../uvc.c      ****         CyFxAppErrorHandler (status);
 5831              		.loc 1 1724 0
 5832 3300 0400A0E1 		mov	r0, r4
 5833 3304 FEFFFFEB 		bl	CyFxAppErrorHandler
 5834              	.L473:
 5835              	.LBE212:
 5836              	.LBE211:
 5837              	.LBB213:
 5838              	.LBB216:
1794:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5839              		.loc 1 1794 0
 5840 3308 48699FE5 		ldr	r6, .L558+20
 5841 330c 2820A0E3 		mov	r2, #40
 5842 3310 0010A0E3 		mov	r1, #0
 5843 3314 0600A0E1 		mov	r0, r6
 5844 3318 FEFFFFEB 		bl	_txe_event_flags_create
 5845              	.LVL478:
1795:../uvc.c      ****     if (apiRetStatus != 0)
 5846              		.loc 1 1795 0
 5847 331c 002050E2 		subs	r2, r0, #0
 5848 3320 F300001A 		bne	.L535
1809:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5849              		.loc 1 1809 0
 5850 3324 0250A0E3 		mov	r5, #2
1816:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5851              		.loc 1 1816 0
 5852 3328 0210A0E1 		mov	r1, r2
1805:../uvc.c      ****     isUsbConnected = CyFalse;
 5853              		.loc 1 1805 0
 5854 332c 402086E5 		str	r2, [r6, #64]
1806:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5855              		.loc 1 1806 0
 5856 3330 442086E5 		str	r2, [r6, #68]
1812:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5857              		.loc 1 1812 0
 5858 3334 0370A0E3 		mov	r7, #3
1816:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5859              		.loc 1 1816 0
 5860 3338 9C008DE2 		add	r0, sp, #156
 5861              	.LVL479:
1811:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5862              		.loc 1 1811 0
 5863 333c A420CDE5 		strb	r2, [sp, #164]
1813:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5864              		.loc 1 1813 0
 5865 3340 A0208DE5 		str	r2, [sp, #160]
1809:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5866              		.loc 1 1809 0
 5867 3344 9C50CDE5 		strb	r5, [sp, #156]
1810:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5868              		.loc 1 1810 0
 5869 3348 9D50CDE5 		strb	r5, [sp, #157]
1812:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5870              		.loc 1 1812 0
 5871 334c A570CDE5 		strb	r7, [sp, #165]
1816:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5872              		.loc 1 1816 0
 5873 3350 FEFFFFEB 		bl	CyU3PGpioInit
 5874              	.LVL480:
1817:../uvc.c      ****     if (apiRetStatus != 0)
 5875              		.loc 1 1817 0
 5876 3354 002050E2 		subs	r2, r0, #0
 5877 3358 F700001A 		bne	.L536
1825:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5878              		.loc 1 1825 0
 5879 335c 1600A0E3 		mov	r0, #22
 5880              	.LVL481:
 5881 3360 0110A0E3 		mov	r1, #1
 5882 3364 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5883              	.LVL482:
1826:../uvc.c      ****     if (apiRetStatus != 0)
 5884              		.loc 1 1826 0
 5885 3368 002050E2 		subs	r2, r0, #0
 5886 336c E900001A 		bne	.L537
1831:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5887              		.loc 1 1831 0
 5888 3370 1400A0E3 		mov	r0, #20
 5889              	.LVL483:
 5890 3374 0110A0E3 		mov	r1, #1
 5891 3378 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5892              	.LVL484:
1832:../uvc.c      ****     if (apiRetStatus != 0)
 5893              		.loc 1 1832 0
 5894 337c 002050E2 		subs	r2, r0, #0
 5895 3380 F600001A 		bne	.L538
1837:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5896              		.loc 1 1837 0
 5897 3384 1800A0E3 		mov	r0, #24
 5898              	.LVL485:
 5899 3388 0110A0E3 		mov	r1, #1
 5900 338c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5901              	.LVL486:
1838:../uvc.c      ****     if (apiRetStatus != 0)
 5902              		.loc 1 1838 0
 5903 3390 002050E2 		subs	r2, r0, #0
 5904 3394 DB01001A 		bne	.L539
1845:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5905              		.loc 1 1845 0
 5906 3398 0140A0E3 		mov	r4, #1
 5907              	.LVL487:
1850:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5908              		.loc 1 1850 0
 5909 339c 1600A0E3 		mov	r0, #22
 5910              	.LVL488:
 5911 33a0 68108DE2 		add	r1, sp, #104
1848:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5912              		.loc 1 1848 0
 5913 33a4 74208DE5 		str	r2, [sp, #116]
1849:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5914              		.loc 1 1849 0
 5915 33a8 7820CDE5 		strb	r2, [sp, #120]
1845:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5916              		.loc 1 1845 0
 5917 33ac 68408DE5 		str	r4, [sp, #104]
1846:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5918              		.loc 1 1846 0
 5919 33b0 6C408DE5 		str	r4, [sp, #108]
1847:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5920              		.loc 1 1847 0
 5921 33b4 70408DE5 		str	r4, [sp, #112]
1850:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5922              		.loc 1 1850 0
 5923 33b8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5924              	.LVL489:
1851:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5925              		.loc 1 1851 0
 5926 33bc 002050E2 		subs	r2, r0, #0
 5927 33c0 C701001A 		bne	.L540
1864:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5928              		.loc 1 1864 0
 5929 33c4 1400A0E3 		mov	r0, #20
 5930              	.LVL490:
 5931 33c8 68108DE2 		add	r1, sp, #104
1862:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5932              		.loc 1 1862 0
 5933 33cc 74208DE5 		str	r2, [sp, #116]
1863:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5934              		.loc 1 1863 0
 5935 33d0 7820CDE5 		strb	r2, [sp, #120]
1859:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5936              		.loc 1 1859 0
 5937 33d4 68408DE5 		str	r4, [sp, #104]
1860:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5938              		.loc 1 1860 0
 5939 33d8 6C408DE5 		str	r4, [sp, #108]
1861:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5940              		.loc 1 1861 0
 5941 33dc 70408DE5 		str	r4, [sp, #112]
1864:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5942              		.loc 1 1864 0
 5943 33e0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5944              	.LVL491:
1865:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5945              		.loc 1 1865 0
 5946 33e4 002050E2 		subs	r2, r0, #0
 5947 33e8 CF01001A 		bne	.L541
1878:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5948              		.loc 1 1878 0
 5949 33ec 1800A0E3 		mov	r0, #24
 5950              	.LVL492:
 5951 33f0 68108DE2 		add	r1, sp, #104
1873:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5952              		.loc 1 1873 0
 5953 33f4 68208DE5 		str	r2, [sp, #104]
1874:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5954              		.loc 1 1874 0
 5955 33f8 6C208DE5 		str	r2, [sp, #108]
1875:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5956              		.loc 1 1875 0
 5957 33fc 70208DE5 		str	r2, [sp, #112]
1877:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5958              		.loc 1 1877 0
 5959 3400 7820CDE5 		strb	r2, [sp, #120]
1876:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5960              		.loc 1 1876 0
 5961 3404 74408DE5 		str	r4, [sp, #116]
1878:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5962              		.loc 1 1878 0
 5963 3408 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5964              	.LVL493:
1879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5965              		.loc 1 1879 0
 5966 340c 002050E2 		subs	r2, r0, #0
 5967 3410 AA01001A 		bne	.L542
1891:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5968              		.loc 1 1891 0
 5969 3414 0400A0E1 		mov	r0, r4
 5970              	.LVL494:
 5971 3418 7C108DE2 		add	r1, sp, #124
1888:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5972              		.loc 1 1888 0
 5973 341c 84208DE5 		str	r2, [sp, #132]
1889:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5974              		.loc 1 1889 0
 5975 3420 80208DE5 		str	r2, [sp, #128]
1886:../uvc.c      ****     pibclock.clkDiv      = 2;
 5976              		.loc 1 1886 0
 5977 3424 BC57CDE1 		strh	r5, [sp, #124]	@ movhi
1887:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5978              		.loc 1 1887 0
 5979 3428 8870CDE5 		strb	r7, [sp, #136]
1891:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5980              		.loc 1 1891 0
 5981 342c FEFFFFEB 		bl	CyU3PPibInit
 5982              	.LVL495:
1892:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5983              		.loc 1 1892 0
 5984 3430 002050E2 		subs	r2, r0, #0
 5985 3434 9801001A 		bne	.L543
1899:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5986              		.loc 1 1899 0
 5987 3438 1C089FE5 		ldr	r0, .L558+24
 5988              	.LVL496:
 5989 343c FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5990              	.LVL497:
1907:../uvc.c      ****     SensorReset ();
 5991              		.loc 1 1907 0
 5992 3440 FEFFFFEB 		bl	SensorReset
1908:../uvc.c      ****     CyU3PThreadSleep(5000);
 5993              		.loc 1 1908 0
 5994 3444 14089FE5 		ldr	r0, .L558+28
 5995 3448 FEFFFFEB 		bl	_tx_thread_sleep
1912:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5996              		.loc 1 1912 0
 5997 344c FEFFFFEB 		bl	CyU3PUsbStart
 5998              	.LVL498:
1913:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5999              		.loc 1 1913 0
 6000 3450 002050E2 		subs	r2, r0, #0
 6001 3454 8701001A 		bne	.L544
1919:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6002              		.loc 1 1919 0
 6003 3458 0010A0E3 		mov	r1, #0
 6004 345c 00089FE5 		ldr	r0, .L558+32
 6005              	.LVL499:
 6006 3460 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6007              	.LVL500:
1922:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6008              		.loc 1 1922 0
 6009 3464 FC079FE5 		ldr	r0, .L558+36
 6010 3468 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1928:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6011              		.loc 1 1928 0
 6012 346c 0010A0E3 		mov	r1, #0
 6013 3470 F4279FE5 		ldr	r2, .L558+40
 6014 3474 0100A0E3 		mov	r0, #1
 6015 3478 FEFFFFEB 		bl	CyU3PUsbSetDesc
1929:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6016              		.loc 1 1929 0
 6017 347c 0000A0E3 		mov	r0, #0
 6018 3480 0010A0E1 		mov	r1, r0
 6019 3484 E4279FE5 		ldr	r2, .L558+44
 6020 3488 FEFFFFEB 		bl	CyU3PUsbSetDesc
1932:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6021              		.loc 1 1932 0
 6022 348c 0010A0E3 		mov	r1, #0
 6023 3490 DC279FE5 		ldr	r2, .L558+48
 6024 3494 0200A0E3 		mov	r0, #2
 6025 3498 FEFFFFEB 		bl	CyU3PUsbSetDesc
1933:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6026              		.loc 1 1933 0
 6027 349c 0010A0E3 		mov	r1, #0
 6028 34a0 D0279FE5 		ldr	r2, .L558+52
 6029 34a4 0700A0E3 		mov	r0, #7
 6030 34a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1936:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6031              		.loc 1 1936 0
 6032 34ac 0010A0E3 		mov	r1, #0
 6033 34b0 C4279FE5 		ldr	r2, .L558+56
 6034 34b4 0400A0E3 		mov	r0, #4
 6035 34b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1937:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6036              		.loc 1 1937 0
 6037 34bc 0010A0E3 		mov	r1, #0
 6038 34c0 B8279FE5 		ldr	r2, .L558+60
 6039 34c4 0300A0E3 		mov	r0, #3
 6040 34c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1938:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6041              		.loc 1 1938 0
 6042 34cc 0010A0E3 		mov	r1, #0
 6043 34d0 AC279FE5 		ldr	r2, .L558+64
 6044 34d4 0600A0E3 		mov	r0, #6
 6045 34d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1941:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6046              		.loc 1 1941 0
 6047 34dc 0010A0E3 		mov	r1, #0
 6048 34e0 A0279FE5 		ldr	r2, .L558+68
 6049 34e4 0500A0E3 		mov	r0, #5
 6050 34e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1942:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6051              		.loc 1 1942 0
 6052 34ec 0110A0E3 		mov	r1, #1
 6053 34f0 94279FE5 		ldr	r2, .L558+72
 6054 34f4 0500A0E3 		mov	r0, #5
 6055 34f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1943:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6056              		.loc 1 1943 0
 6057 34fc 0210A0E3 		mov	r1, #2
 6058 3500 88279FE5 		ldr	r2, .L558+76
 6059 3504 0500A0E3 		mov	r0, #5
 6060 3508 FEFFFFEB 		bl	CyU3PUsbSetDesc
1953:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6061              		.loc 1 1953 0
 6062 350c 0070A0E3 		mov	r7, #0
1950:../uvc.c      ****     endPointConfig.enable   = 1;
 6063              		.loc 1 1950 0
 6064 3510 0140A0E3 		mov	r4, #1
1951:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6065              		.loc 1 1951 0
 6066 3514 03A0A0E3 		mov	sl, #3
1956:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6067              		.loc 1 1956 0
 6068 3518 8200A0E3 		mov	r0, #130
 6069 351c A8108DE2 		add	r1, sp, #168
1952:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6070              		.loc 1 1952 0
 6071 3520 4080A0E3 		mov	r8, #64	@ movhi
1951:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6072              		.loc 1 1951 0
 6073 3524 ACA0CDE5 		strb	sl, [sp, #172]
1950:../uvc.c      ****     endPointConfig.enable   = 1;
 6074              		.loc 1 1950 0
 6075 3528 A8408DE5 		str	r4, [sp, #168]
1952:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6076              		.loc 1 1952 0
 6077 352c B08BCDE1 		strh	r8, [sp, #176]	@ movhi
1953:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6078              		.loc 1 1953 0
 6079 3530 B370CDE5 		strb	r7, [sp, #179]
1954:../uvc.c      ****     endPointConfig.streams  = 0;
 6080              		.loc 1 1954 0
 6081 3534 BE7ACDE1 		strh	r7, [sp, #174]	@ movhi
1955:../uvc.c      ****     endPointConfig.burstLen = 1;
 6082              		.loc 1 1955 0
 6083 3538 B240CDE5 		strb	r4, [sp, #178]
1956:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6084              		.loc 1 1956 0
 6085 353c FEFFFFEB 		bl	CyU3PSetEpConfig
 6086              	.LVL501:
1954:../uvc.c      ****     endPointConfig.streams  = 0;
 6087              		.loc 1 1954 0
 6088 3540 07A0A0E1 		mov	sl, r7	@ movhi
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6089              		.loc 1 1957 0
 6090 3544 003050E2 		subs	r3, r0, #0
 6091 3548 4001001A 		bne	.L545
1967:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6092              		.loc 1 1967 0
 6093 354c 40C79FE5 		ldr	ip, .L558+80
1968:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6094              		.loc 1 1968 0
 6095 3550 40E79FE5 		ldr	lr, .L558+84
1965:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6096              		.loc 1 1965 0
 6097 3554 015BA0E3 		mov	r5, #1024	@ movhi
1974:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6098              		.loc 1 1974 0
 6099 3558 1070A0E3 		mov	r7, #16
1976:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6100              		.loc 1 1976 0
 6101 355c 38079FE5 		ldr	r0, .L558+88
 6102              	.LVL502:
 6103 3560 0410A0E3 		mov	r1, #4
 6104 3564 34208DE2 		add	r2, sp, #52
1965:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6105              		.loc 1 1965 0
 6106 3568 B453CDE1 		strh	r5, [sp, #52]	@ movhi
1966:../uvc.c      ****     dmaInterConfig.count          = 1;
 6107              		.loc 1 1966 0
 6108 356c B643CDE1 		strh	r4, [sp, #54]	@ movhi
1967:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6109              		.loc 1 1967 0
 6110 3570 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1968:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6111              		.loc 1 1968 0
 6112 3574 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1969:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6113              		.loc 1 1969 0
 6114 3578 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1970:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6115              		.loc 1 1970 0
 6116 357c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1971:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6117              		.loc 1 1971 0
 6118 3580 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1972:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6119              		.loc 1 1972 0
 6120 3584 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1973:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6121              		.loc 1 1973 0
 6122 3588 44A0CDE5 		strb	sl, [sp, #68]
1974:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6123              		.loc 1 1974 0
 6124 358c 48708DE5 		str	r7, [sp, #72]
1975:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6125              		.loc 1 1975 0
 6126 3590 4C308DE5 		str	r3, [sp, #76]
1976:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6127              		.loc 1 1976 0
 6128 3594 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6129              	.LVL503:
1978:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6130              		.loc 1 1978 0
 6131 3598 005050E2 		subs	r5, r0, #0
 6132 359c E400001A 		bne	.L546
1985:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6133              		.loc 1 1985 0
 6134 35a0 010BA0E3 		mov	r0, #1024
 6135              	.LVL504:
 6136 35a4 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6137 35a8 F0169FE5 		ldr	r1, .L558+92
1986:../uvc.c      ****     if (glInterStaBuffer == 0)
 6138              		.loc 1 1986 0
 6139 35ac 000050E3 		cmp	r0, #0
1985:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6140              		.loc 1 1985 0
 6141 35b0 000081E5 		str	r0, [r1, #0]
1986:../uvc.c      ****     if (glInterStaBuffer == 0)
 6142              		.loc 1 1986 0
 6143 35b4 D500000A 		beq	.L547
1994:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6144              		.loc 1 1994 0
 6145 35b8 0430A0E3 		mov	r3, #4	@ movhi
 6146 35bc BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1998:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6147              		.loc 1 1998 0
 6148 35c0 DC369FE5 		ldr	r3, .L558+96
1993:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6149              		.loc 1 1993 0
 6150 35c4 01E9A0E3 		mov	lr, #16384	@ movhi
 6151 35c8 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1997:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6152              		.loc 1 1997 0
 6153 35cc D4E69FE5 		ldr	lr, .L558+100
1998:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6154              		.loc 1 1998 0
 6155 35d0 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
2005:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6156              		.loc 1 2005 0
 6157 35d4 D0369FE5 		ldr	r3, .L558+104
1996:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6158              		.loc 1 1996 0
 6159 35d8 01CCA0E3 		mov	ip, #256	@ movhi
2006:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6160              		.loc 1 2006 0
 6161 35dc 0C208DE2 		add	r2, sp, #12
1996:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6162              		.loc 1 1996 0
 6163 35e0 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1997:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6164              		.loc 1 1997 0
 6165 35e4 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
2000:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6166              		.loc 1 2000 0
 6167 35e8 0CC0A0E3 		mov	ip, #12	@ movhi
2001:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6168              		.loc 1 2001 0
 6169 35ec 04E0A0E3 		mov	lr, #4	@ movhi
2003:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6170              		.loc 1 2003 0
 6171 35f0 2AA0CDE5 		strb	sl, [sp, #42]
1995:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6172              		.loc 1 1995 0
 6173 35f4 0280A0E3 		mov	r8, #2	@ movhi
2006:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6174              		.loc 1 2006 0
 6175 35f8 B0069FE5 		ldr	r0, .L558+108
 6176 35fc 0710A0E3 		mov	r1, #7
2004:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6177              		.loc 1 2004 0
 6178 3600 18A0A0E3 		mov	sl, #24
1995:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6179              		.loc 1 1995 0
 6180 3604 B081CDE1 		strh	r8, [sp, #16]	@ movhi
1999:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6181              		.loc 1 1999 0
 6182 3608 B252CDE1 		strh	r5, [sp, #34]	@ movhi
2000:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6183              		.loc 1 2000 0
 6184 360c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
2001:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6185              		.loc 1 2001 0
 6186 3610 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
2002:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6187              		.loc 1 2002 0
 6188 3614 B852CDE1 		strh	r5, [sp, #40]	@ movhi
2004:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6189              		.loc 1 2004 0
 6190 3618 2CA08DE5 		str	sl, [sp, #44]
2005:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6191              		.loc 1 2005 0
 6192 361c 30308DE5 		str	r3, [sp, #48]
2006:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6193              		.loc 1 2006 0
 6194 3620 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6195              	.LVL505:
2008:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6196              		.loc 1 2008 0
 6197 3624 002050E2 		subs	r2, r0, #0
 6198 3628 AF00001A 		bne	.L548
2099:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6199              		.loc 1 2099 0
 6200 362c 0400A0E1 		mov	r0, r4
 6201              	.LVL506:
 6202 3630 0410A0E1 		mov	r1, r4
 6203 3634 FEFFFFEB 		bl	CyU3PConnectState
 6204              	.LVL507:
2100:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6205              		.loc 1 2100 0
 6206 3638 002050E2 		subs	r2, r0, #0
 6207 363c A100001A 		bne	.L549
2106:../uvc.c      ****     CyU3PBusyWait(100);
 6208              		.loc 1 2106 0
 6209 3640 6400A0E3 		mov	r0, #100
 6210              	.LVL508:
 6211 3644 FEFFFFEB 		bl	CyU3PBusyWait
 6212              	.LVL509:
2108:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6213              		.loc 1 2108 0
 6214 3648 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2122:../uvc.c      ****     endPointConfig.streams  = 0;
 6215              		.loc 1 2122 0
 6216 364c 0020A0E3 		mov	r2, #0	@ movhi
2111:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6217              		.loc 1 2111 0
 6218 3650 AC80CDE5 		strb	r8, [sp, #172]
2123:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6219              		.loc 1 2123 0
 6220 3654 A8108DE2 		add	r1, sp, #168
2122:../uvc.c      ****     endPointConfig.streams  = 0;
 6221              		.loc 1 2122 0
 6222 3658 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2110:../uvc.c      ****     endPointConfig.enable   = 1;
 6223              		.loc 1 2110 0
 6224 365c A8408DE5 		str	r4, [sp, #168]
2112:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6225              		.loc 1 2112 0
 6226 3660 030050E3 		cmp	r0, #3
2108:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6227              		.loc 1 2108 0
 6228 3664 4800C6E5 		strb	r0, [r6, #72]
2119:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6229              		.loc 1 2119 0
 6230 3668 020CA013 		movne	r0, #512	@ movhi
2114:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6231              		.loc 1 2114 0
 6232 366c 018BA003 		moveq	r8, #1024	@ movhi
2119:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6233              		.loc 1 2119 0
 6234 3670 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2123:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6235              		.loc 1 2123 0
 6236 3674 8300A0E3 		mov	r0, #131
2114:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6237              		.loc 1 2114 0
 6238 3678 B08BCD01 		streqh	r8, [sp, #176]	@ movhi
2115:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6239              		.loc 1 2115 0
 6240 367c B270CD05 		streqb	r7, [sp, #178]
2120:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6241              		.loc 1 2120 0
 6242 3680 B240CD15 		strneb	r4, [sp, #178]
2123:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6243              		.loc 1 2123 0
 6244 3684 FEFFFFEB 		bl	CyU3PSetEpConfig
 6245              	.LVL510:
2124:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6246              		.loc 1 2124 0
 6247 3688 002050E2 		subs	r2, r0, #0
 6248 368c 4F00001A 		bne	.L532
 6249 3690 1C869FE5 		ldr	r8, .L558+112
 6250              	.LBE216:
 6251              	.LBE213:
2244:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6252              		.loc 1 2244 0
 6253 3694 BC559FE5 		ldr	r5, .L558+20
 6254 3698 0240A0E1 		mov	r4, r2
2315:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6255              		.loc 1 2315 0
 6256 369c 0870A0E1 		mov	r7, r8
 6257              	.LVL511:
 6258              	.L506:
2244:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6259              		.loc 1 2244 0
 6260 36a0 B0059FE5 		ldr	r0, .L558+20
 6261 36a4 0110A0E3 		mov	r1, #1
 6262 36a8 0220A0E3 		mov	r2, #2
 6263 36ac B4308DE2 		add	r3, sp, #180
 6264 36b0 00408DE5 		str	r4, [sp, #0]
 6265 36b4 FEFFFFEB 		bl	_txe_event_flags_get
 6266 36b8 000050E3 		cmp	r0, #0
 6267 36bc 3000001A 		bne	.L508
2290:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6268              		.loc 1 2290 0
 6269 36c0 301095E5 		ldr	r1, [r5, #48]
 6270 36c4 000051E3 		cmp	r1, #0
 6271 36c8 0300000A 		beq	.L509
2290:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6272              		.loc 1 2290 0 is_stmt 0 discriminator 1
 6273 36cc B4A3D5E1 		ldrh	sl, [r5, #52]
 6274 36d0 B6C3D5E1 		ldrh	ip, [r5, #54]
 6275 36d4 0C005AE1 		cmp	sl, ip
 6276 36d8 1C01000A 		beq	.L550
 6277              	.L509:
2439:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6278              		.loc 1 2439 0 is_stmt 1
 6279 36dc 4010A0E3 		mov	r1, #64
 6280 36e0 0020A0E3 		mov	r2, #0
 6281 36e4 6C059FE5 		ldr	r0, .L558+20
 6282 36e8 FEFFFFEB 		bl	_txe_event_flags_set
2442:../uvc.c      ****         CyU3PThreadRelinquish ();
 6283              		.loc 1 2442 0
 6284 36ec FEFFFFEB 		bl	_txe_thread_relinquish
2443:../uvc.c      ****     }
 6285              		.loc 1 2443 0
 6286 36f0 EAFFFFEA 		b	.L506
 6287              	.LVL512:
 6288              	.L535:
 6289              	.LBB251:
 6290              	.LBB215:
1797:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6291              		.loc 1 1797 0
 6292 36f4 0400A0E3 		mov	r0, #4
 6293              	.LVL513:
 6294 36f8 B8159FE5 		ldr	r1, .L558+116
 6295 36fc FEFFFFEB 		bl	CyU3PDebugPrint
 6296              	.LVL514:
 6297              	.L475:
 6298              	.LBB231:
 6299              	.LBB232:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6300              		.loc 1 1246 0
 6301 3700 B4159FE5 		ldr	r1, .L558+120
 6302 3704 0400A0E3 		mov	r0, #4
 6303 3708 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6304              		.loc 1 1247 0
 6305 370c FA0FA0E3 		mov	r0, #1000
 6306 3710 FEFFFFEB 		bl	_tx_thread_sleep
 6307 3714 F9FFFFEA 		b	.L475
 6308              	.LVL515:
 6309              	.L537:
 6310              	.LBE232:
 6311              	.LBE231:
1828:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6312              		.loc 1 1828 0
 6313 3718 0400A0E3 		mov	r0, #4
 6314              	.LVL516:
 6315 371c 9C159FE5 		ldr	r1, .L558+124
 6316 3720 FEFFFFEB 		bl	CyU3PDebugPrint
 6317              	.LVL517:
 6318              	.L479:
 6319              	.LBB229:
 6320              	.LBB230:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6321              		.loc 1 1246 0
 6322 3724 90159FE5 		ldr	r1, .L558+120
 6323 3728 0400A0E3 		mov	r0, #4
 6324 372c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6325              		.loc 1 1247 0
 6326 3730 FA0FA0E3 		mov	r0, #1000
 6327 3734 FEFFFFEB 		bl	_tx_thread_sleep
 6328 3738 F9FFFFEA 		b	.L479
 6329              	.LVL518:
 6330              	.L536:
 6331              	.LBE230:
 6332              	.LBE229:
1819:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6333              		.loc 1 1819 0
 6334 373c 0400A0E3 		mov	r0, #4
 6335              	.LVL519:
 6336 3740 7C159FE5 		ldr	r1, .L558+128
 6337 3744 FEFFFFEB 		bl	CyU3PDebugPrint
 6338              	.LVL520:
 6339              	.L477:
 6340              	.LBB227:
 6341              	.LBB228:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6342              		.loc 1 1246 0
 6343 3748 6C159FE5 		ldr	r1, .L558+120
 6344 374c 0400A0E3 		mov	r0, #4
 6345 3750 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6346              		.loc 1 1247 0
 6347 3754 FA0FA0E3 		mov	r0, #1000
 6348 3758 FEFFFFEB 		bl	_tx_thread_sleep
 6349 375c F9FFFFEA 		b	.L477
 6350              	.LVL521:
 6351              	.L538:
 6352              	.LBE228:
 6353              	.LBE227:
1834:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6354              		.loc 1 1834 0
 6355 3760 0400A0E3 		mov	r0, #4
 6356              	.LVL522:
 6357 3764 5C159FE5 		ldr	r1, .L558+132
 6358 3768 FEFFFFEB 		bl	CyU3PDebugPrint
 6359              	.LVL523:
 6360              	.L481:
 6361              	.LBB225:
 6362              	.LBB226:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6363              		.loc 1 1246 0
 6364 376c 48159FE5 		ldr	r1, .L558+120
 6365 3770 0400A0E3 		mov	r0, #4
 6366 3774 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6367              		.loc 1 1247 0
 6368 3778 FA0FA0E3 		mov	r0, #1000
 6369 377c FEFFFFEB 		bl	_tx_thread_sleep
 6370 3780 F9FFFFEA 		b	.L481
 6371              	.LVL524:
 6372              	.L508:
 6373              	.LBE226:
 6374              	.LBE225:
 6375              	.LBE215:
 6376              	.LBE251:
2349:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6377              		.loc 1 2349 0
 6378 3784 CC049FE5 		ldr	r0, .L558+20
 6379 3788 0210A0E3 		mov	r1, #2
 6380 378c 0320A0E3 		mov	r2, #3
 6381 3790 B4308DE2 		add	r3, sp, #180
 6382 3794 00408DE5 		str	r4, [sp, #0]
 6383 3798 FEFFFFEB 		bl	_txe_event_flags_get
 6384 379c 000050E3 		cmp	r0, #0
 6385 37a0 2500001A 		bne	.L516
2364:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6386              		.loc 1 2364 0
 6387 37a4 441095E5 		ldr	r1, [r5, #68]
2352:../uvc.c      ****                 hitFV     = CyFalse;
 6388              		.loc 1 2352 0
 6389 37a8 304085E5 		str	r4, [r5, #48]
2364:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6390              		.loc 1 2364 0
 6391 37ac 000051E3 		cmp	r1, #0
2353:../uvc.c      ****                 prodCount = 0;
 6392              		.loc 1 2353 0
 6393 37b0 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2360:../uvc.c      ****                 fb=0;
 6394              		.loc 1 2360 0
 6395 37b4 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2354:../uvc.c      ****                 consCount = 0;
 6396              		.loc 1 2354 0
 6397 37b8 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2361:../uvc.c      ****                 pb=0;
 6398              		.loc 1 2361 0
 6399 37bc BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2362:../uvc.c      ****                 pbc=0;
 6400              		.loc 1 2362 0
 6401 37c0 BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2364:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6402              		.loc 1 2364 0
 6403 37c4 0A00000A 		beq	.L551
 6404              	.L517:
2376:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6405              		.loc 1 2376 0
 6406 37c8 444086E5 		str	r4, [r6, #68]
 6407 37cc C2FFFFEA 		b	.L509
 6408              	.LVL525:
 6409              	.L532:
 6410              	.LBB252:
 6411              	.LBB249:
2127:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6412              		.loc 1 2127 0
 6413 37d0 0400A0E3 		mov	r0, #4
 6414              	.LVL526:
 6415 37d4 F0149FE5 		ldr	r1, .L558+136
 6416 37d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6417              	.LVL527:
 6418              	.L507:
 6419              	.LBB233:
 6420              	.LBB234:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6421              		.loc 1 1246 0
 6422 37dc D8149FE5 		ldr	r1, .L558+120
 6423 37e0 0400A0E3 		mov	r0, #4
 6424 37e4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6425              		.loc 1 1247 0
 6426 37e8 FA0FA0E3 		mov	r0, #1000
 6427 37ec FEFFFFEB 		bl	_tx_thread_sleep
 6428 37f0 F9FFFFEA 		b	.L507
 6429              	.LVL528:
 6430              	.L551:
 6431              	.LBE234:
 6432              	.LBE233:
 6433              	.LBE249:
 6434              	.LBE252:
2366:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6435              		.loc 1 2366 0
 6436 37f4 B4049FE5 		ldr	r0, .L558+108
 6437 37f8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6438              	.LVL529:
2367:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6439              		.loc 1 2367 0
 6440 37fc 000050E3 		cmp	r0, #0
 6441 3800 0200001A 		bne	.L533
2373:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6442              		.loc 1 2373 0
 6443 3804 8300A0E3 		mov	r0, #131
 6444              	.LVL530:
 6445 3808 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6446 380c EDFFFFEA 		b	.L517
 6447              	.L533:
 6448              	.LBB253:
 6449              	.LBB254:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6450              		.loc 1 1246 0
 6451 3810 A4149FE5 		ldr	r1, .L558+120
 6452 3814 0400A0E3 		mov	r0, #4
 6453 3818 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6454              		.loc 1 1247 0
 6455 381c FA0FA0E3 		mov	r0, #1000
 6456 3820 FEFFFFEB 		bl	_tx_thread_sleep
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6457              		.loc 1 1246 0
 6458 3824 90149FE5 		ldr	r1, .L558+120
 6459 3828 0400A0E3 		mov	r0, #4
 6460 382c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6461              		.loc 1 1247 0
 6462 3830 FA0FA0E3 		mov	r0, #1000
 6463 3834 FEFFFFEB 		bl	_tx_thread_sleep
 6464 3838 F4FFFFEA 		b	.L533
 6465              	.L516:
 6466              	.LBE254:
 6467              	.LBE253:
2381:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6468              		.loc 1 2381 0
 6469 383c 00C0E0E3 		mvn	ip, #0
 6470 3840 0110A0E3 		mov	r1, #1
 6471 3844 0220A0E3 		mov	r2, #2
 6472 3848 B4308DE2 		add	r3, sp, #180
 6473 384c 04049FE5 		ldr	r0, .L558+20
 6474 3850 00C08DE5 		str	ip, [sp, #0]
 6475 3854 FEFFFFEB 		bl	_txe_event_flags_get
2385:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6476              		.loc 1 2385 0
 6477 3858 0420A0E1 		mov	r2, r4
 6478 385c 4C049FE5 		ldr	r0, .L558+108
 6479 3860 0410A0E1 		mov	r1, r4
 6480 3864 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6481              	.LVL531:
2386:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6482              		.loc 1 2386 0
 6483 3868 002050E2 		subs	r2, r0, #0
 6484 386c 6E00001A 		bne	.L552
2394:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6485              		.loc 1 2394 0
 6486 3870 3C3095E5 		ldr	r3, [r5, #60]
 6487 3874 000053E3 		cmp	r3, #0
 6488 3878 6300001A 		bne	.L522
2423:../uvc.c      ****                     CyU3PThreadSleep(1000);
 6489              		.loc 1 2423 0
 6490 387c FA0FA0E3 		mov	r0, #1000
 6491              	.LVL532:
 6492 3880 FEFFFFEB 		bl	_tx_thread_sleep
 6493              	.LVL533:
2424:../uvc.c      ****                     SensorSetIrisControl(0x1, 0x30, 0x20, I2C_DSPBOARD_ADDR_WR/*boardID*/);//start 
 6494              		.loc 1 2424 0
 6495 3884 5230A0E3 		mov	r3, #82
 6496 3888 3010A0E3 		mov	r1, #48
 6497 388c 2020A0E3 		mov	r2, #32
 6498 3890 0100A0E3 		mov	r0, #1
 6499 3894 FEFFFFEB 		bl	SensorSetIrisControl
2425:../uvc.c      ****                     CyU3PThreadSleep(1000);
 6500              		.loc 1 2425 0
 6501 3898 FA0FA0E3 		mov	r0, #1000
 6502 389c FEFFFFEB 		bl	_tx_thread_sleep
 6503              	.LVL534:
 6504              	.LBB255:
 6505              	.LBB256:
2152:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6506              		.loc 1 2152 0
 6507 38a0 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6508 38a4 030053E3 		cmp	r3, #3
 6509 38a8 4700000A 		beq	.L553
2157:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6510              		.loc 1 2157 0
 6511 38ac 020053E3 		cmp	r3, #2
 6512 38b0 2900000A 		beq	.L554
 6513              	.LVL535:
 6514              	.L525:
 6515              	.LBE256:
 6516              	.LBE255:
2427:../uvc.c      ****                     gpif_initialized = CyTrue;
 6517              		.loc 1 2427 0
 6518 38b4 01E0A0E3 		mov	lr, #1
 6519 38b8 3CE086E5 		str	lr, [r6, #60]
2428:../uvc.c      ****                     CyU3PThreadSleep(200);
 6520              		.loc 1 2428 0
 6521 38bc C800A0E3 		mov	r0, #200
 6522 38c0 FEFFFFEB 		bl	_tx_thread_sleep
 6523 38c4 84FFFFEA 		b	.L509
 6524              	.LVL536:
 6525              	.L549:
 6526              	.LBB262:
 6527              	.LBB214:
2102:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6528              		.loc 1 2102 0
 6529 38c8 0400A0E3 		mov	r0, #4
 6530              	.LVL537:
 6531 38cc FC139FE5 		ldr	r1, .L558+140
 6532 38d0 FEFFFFEB 		bl	CyU3PDebugPrint
 6533              	.LVL538:
 6534              	.L503:
 6535              	.LBB223:
 6536              	.LBB224:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6537              		.loc 1 1246 0
 6538 38d4 E0139FE5 		ldr	r1, .L558+120
 6539 38d8 0400A0E3 		mov	r0, #4
 6540 38dc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6541              		.loc 1 1247 0
 6542 38e0 FA0FA0E3 		mov	r0, #1000
 6543 38e4 FEFFFFEB 		bl	_tx_thread_sleep
 6544 38e8 F9FFFFEA 		b	.L503
 6545              	.LVL539:
 6546              	.L548:
 6547              	.LBE224:
 6548              	.LBE223:
2011:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6549              		.loc 1 2011 0
 6550 38ec 0400A0E3 		mov	r0, #4
 6551              	.LVL540:
 6552 38f0 DC139FE5 		ldr	r1, .L558+144
 6553 38f4 FEFFFFEB 		bl	CyU3PDebugPrint
 6554              	.LVL541:
 6555              	.L501:
 6556              	.LBB221:
 6557              	.LBB222:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6558              		.loc 1 1246 0
 6559 38f8 BC139FE5 		ldr	r1, .L558+120
 6560 38fc 0400A0E3 		mov	r0, #4
 6561 3900 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6562              		.loc 1 1247 0
 6563 3904 FA0FA0E3 		mov	r0, #1000
 6564 3908 FEFFFFEB 		bl	_tx_thread_sleep
 6565 390c F9FFFFEA 		b	.L501
 6566              	.LVL542:
 6567              	.L547:
 6568              	.LBE222:
 6569              	.LBE221:
1988:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6570              		.loc 1 1988 0
 6571 3910 040080E2 		add	r0, r0, #4
 6572 3914 BC139FE5 		ldr	r1, .L558+148
 6573 3918 FEFFFFEB 		bl	CyU3PDebugPrint
 6574              	.LVL543:
 6575              	.L499:
 6576              	.LBB219:
 6577              	.LBB220:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6578              		.loc 1 1246 0
 6579 391c 98139FE5 		ldr	r1, .L558+120
 6580 3920 0400A0E3 		mov	r0, #4
 6581 3924 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6582              		.loc 1 1247 0
 6583 3928 FA0FA0E3 		mov	r0, #1000
 6584 392c FEFFFFEB 		bl	_tx_thread_sleep
 6585 3930 F9FFFFEA 		b	.L499
 6586              	.LVL544:
 6587              	.L546:
 6588              	.LBE220:
 6589              	.LBE219:
1981:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6590              		.loc 1 1981 0
 6591 3934 0400A0E3 		mov	r0, #4
 6592 3938 9C139FE5 		ldr	r1, .L558+152
 6593 393c 0520A0E1 		mov	r2, r5
 6594 3940 FEFFFFEB 		bl	CyU3PDebugPrint
 6595              	.L497:
 6596              	.LBB217:
 6597              	.LBB218:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6598              		.loc 1 1246 0
 6599 3944 70139FE5 		ldr	r1, .L558+120
 6600 3948 0400A0E3 		mov	r0, #4
 6601 394c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6602              		.loc 1 1247 0
 6603 3950 FA0FA0E3 		mov	r0, #1000
 6604 3954 FEFFFFEB 		bl	_tx_thread_sleep
 6605 3958 F9FFFFEA 		b	.L497
 6606              	.LVL545:
 6607              	.L554:
 6608              	.LBE218:
 6609              	.LBE217:
 6610              	.LBE214:
 6611              	.LBE262:
 6612              	.LBB263:
 6613              	.LBB261:
2159:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6614              		.loc 1 2159 0
 6615 395c 7C139FE5 		ldr	r1, .L558+156
 6616 3960 0100A0E3 		mov	r0, #1
 6617 3964 FEFFFFEB 		bl	CyU3PDebugPrint
2160:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6618              		.loc 1 2160 0
 6619 3968 74039FE5 		ldr	r0, .L558+160
 6620 396c FEFFFFEB 		bl	CyU3PGpifLoad
 6621 3970 0020A0E1 		mov	r2, r0
 6622              	.LVL546:
 6623              	.L524:
2162:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6624              		.loc 1 2162 0
 6625 3974 000052E3 		cmp	r2, #0
 6626 3978 1A00001A 		bne	.L555
2170:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6627              		.loc 1 2170 0
 6628 397c 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6629 3980 030053E3 		cmp	r3, #3
 6630 3984 0100000A 		beq	.L534
2174:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6631              		.loc 1 2174 0
 6632 3988 020053E3 		cmp	r3, #2
 6633 398c C8FFFF1A 		bne	.L525
 6634              	.L534:
2176:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6635              		.loc 1 2176 0
 6636 3990 0200A0E1 		mov	r0, r2
 6637              	.LVL547:
 6638 3994 0210A0E1 		mov	r1, r2
 6639 3998 FEFFFFEB 		bl	CyU3PGpifSMStart
 6640              	.LVL548:
2178:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6641              		.loc 1 2178 0
 6642 399c 000050E3 		cmp	r0, #0
2176:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6643              		.loc 1 2176 0
 6644 39a0 0020A0E1 		mov	r2, r0
 6645              	.LVL549:
2178:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6646              		.loc 1 2178 0
 6647 39a4 C2FFFF0A 		beq	.L525
2181:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6648              		.loc 1 2181 0
 6649 39a8 0400A0E3 		mov	r0, #4
 6650              	.LVL550:
 6651 39ac 34139FE5 		ldr	r1, .L558+164
 6652 39b0 FEFFFFEB 		bl	CyU3PDebugPrint
 6653              	.LVL551:
 6654              	.L530:
 6655              	.LBB257:
 6656              	.LBB258:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6657              		.loc 1 1246 0
 6658 39b4 00139FE5 		ldr	r1, .L558+120
 6659 39b8 0400A0E3 		mov	r0, #4
 6660 39bc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6661              		.loc 1 1247 0
 6662 39c0 FA0FA0E3 		mov	r0, #1000
 6663 39c4 FEFFFFEB 		bl	_tx_thread_sleep
 6664 39c8 F9FFFFEA 		b	.L530
 6665              	.LVL552:
 6666              	.L553:
 6667              	.LBE258:
 6668              	.LBE257:
2154:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6669              		.loc 1 2154 0
 6670 39cc 18139FE5 		ldr	r1, .L558+168
 6671 39d0 0100A0E3 		mov	r0, #1
 6672 39d4 FEFFFFEB 		bl	CyU3PDebugPrint
2155:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6673              		.loc 1 2155 0
 6674 39d8 10039FE5 		ldr	r0, .L558+172
 6675 39dc FEFFFFEB 		bl	CyU3PGpifLoad
 6676 39e0 0020A0E1 		mov	r2, r0
 6677              	.LVL553:
 6678 39e4 E2FFFFEA 		b	.L524
 6679              	.L555:
2165:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6680              		.loc 1 2165 0
 6681 39e8 0400A0E3 		mov	r0, #4
 6682              	.LVL554:
 6683 39ec 00139FE5 		ldr	r1, .L558+176
 6684 39f0 FEFFFFEB 		bl	CyU3PDebugPrint
 6685              	.LVL555:
 6686              	.L527:
 6687              	.LBB259:
 6688              	.LBB260:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6689              		.loc 1 1246 0
 6690 39f4 C0129FE5 		ldr	r1, .L558+120
 6691 39f8 0400A0E3 		mov	r0, #4
 6692 39fc FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6693              		.loc 1 1247 0
 6694 3a00 FA0FA0E3 		mov	r0, #1000
 6695 3a04 FEFFFFEB 		bl	_tx_thread_sleep
 6696 3a08 F9FFFFEA 		b	.L527
 6697              	.LVL556:
 6698              	.L522:
 6699              	.LBE260:
 6700              	.LBE259:
 6701              	.LBE261:
 6702              	.LBE263:
2435:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6703              		.loc 1 2435 0
 6704 3a0c 94029FE5 		ldr	r0, .L558+100
 6705              	.LVL557:
 6706 3a10 02A0A0E3 		mov	sl, #2
 6707 3a14 0410A0E1 		mov	r1, r4
 6708 3a18 0020A0E1 		mov	r2, r0
 6709              	.LVL558:
 6710 3a1c 0430A0E1 		mov	r3, r4
 6711 3a20 00A08DE5 		str	sl, [sp, #0]
 6712 3a24 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6713 3a28 2BFFFFEA 		b	.L509
 6714              	.LVL559:
 6715              	.L552:
2389:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6716              		.loc 1 2389 0
 6717 3a2c 0400A0E3 		mov	r0, #4
 6718              	.LVL560:
 6719 3a30 C0129FE5 		ldr	r1, .L558+180
 6720 3a34 FEFFFFEB 		bl	CyU3PDebugPrint
 6721              	.LVL561:
 6722              	.L521:
 6723              	.LBB264:
 6724              	.LBB265:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6725              		.loc 1 1246 0
 6726 3a38 7C129FE5 		ldr	r1, .L558+120
 6727 3a3c 0400A0E3 		mov	r0, #4
 6728 3a40 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6729              		.loc 1 1247 0
 6730 3a44 FA0FA0E3 		mov	r0, #1000
 6731 3a48 FEFFFFEB 		bl	_tx_thread_sleep
 6732 3a4c F9FFFFEA 		b	.L521
 6733              	.LVL562:
 6734              	.L545:
 6735              	.LBE265:
 6736              	.LBE264:
 6737              	.LBB266:
 6738              	.LBB250:
1960:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6739              		.loc 1 1960 0
 6740 3a50 0400A0E3 		mov	r0, #4
 6741              	.LVL563:
 6742 3a54 70129FE5 		ldr	r1, .L558+136
 6743 3a58 0320A0E1 		mov	r2, r3
 6744 3a5c FEFFFFEB 		bl	CyU3PDebugPrint
 6745              	.LVL564:
 6746              	.L495:
 6747              	.LBB235:
 6748              	.LBB236:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6749              		.loc 1 1246 0
 6750 3a60 54129FE5 		ldr	r1, .L558+120
 6751 3a64 0400A0E3 		mov	r0, #4
 6752 3a68 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6753              		.loc 1 1247 0
 6754 3a6c FA0FA0E3 		mov	r0, #1000
 6755 3a70 FEFFFFEB 		bl	_tx_thread_sleep
 6756 3a74 F9FFFFEA 		b	.L495
 6757              	.LVL565:
 6758              	.L544:
 6759              	.LBE236:
 6760              	.LBE235:
1915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6761              		.loc 1 1915 0
 6762 3a78 0400A0E3 		mov	r0, #4
 6763              	.LVL566:
 6764 3a7c 78129FE5 		ldr	r1, .L558+184
 6765 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
 6766              	.LVL567:
 6767              	.L493:
 6768              	.LBB237:
 6769              	.LBB238:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6770              		.loc 1 1246 0
 6771 3a84 30129FE5 		ldr	r1, .L558+120
 6772 3a88 0400A0E3 		mov	r0, #4
 6773 3a8c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6774              		.loc 1 1247 0
 6775 3a90 FA0FA0E3 		mov	r0, #1000
 6776 3a94 FEFFFFEB 		bl	_tx_thread_sleep
 6777 3a98 F9FFFFEA 		b	.L493
 6778              	.LVL568:
 6779              	.L543:
 6780              	.LBE238:
 6781              	.LBE237:
1894:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6782              		.loc 1 1894 0
 6783 3a9c 0400A0E3 		mov	r0, #4
 6784              	.LVL569:
 6785 3aa0 58129FE5 		ldr	r1, .L558+188
 6786 3aa4 FEFFFFEB 		bl	CyU3PDebugPrint
 6787              	.LVL570:
 6788              	.L491:
 6789              	.LBB239:
 6790              	.LBB240:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6791              		.loc 1 1246 0
 6792 3aa8 0C129FE5 		ldr	r1, .L558+120
 6793 3aac 0400A0E3 		mov	r0, #4
 6794 3ab0 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6795              		.loc 1 1247 0
 6796 3ab4 FA0FA0E3 		mov	r0, #1000
 6797 3ab8 FEFFFFEB 		bl	_tx_thread_sleep
 6798 3abc F9FFFFEA 		b	.L491
 6799              	.LVL571:
 6800              	.L542:
 6801              	.LBE240:
 6802              	.LBE239:
1881:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6803              		.loc 1 1881 0
 6804 3ac0 0400A0E3 		mov	r0, #4
 6805              	.LVL572:
 6806 3ac4 38129FE5 		ldr	r1, .L558+192
 6807 3ac8 FEFFFFEB 		bl	CyU3PDebugPrint
 6808              	.LVL573:
 6809              	.L489:
 6810              	.LBB241:
 6811              	.LBB242:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6812              		.loc 1 1246 0
 6813 3acc E8119FE5 		ldr	r1, .L558+120
 6814 3ad0 0400A0E3 		mov	r0, #4
 6815 3ad4 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6816              		.loc 1 1247 0
 6817 3ad8 FA0FA0E3 		mov	r0, #1000
 6818 3adc FEFFFFEB 		bl	_tx_thread_sleep
 6819 3ae0 F9FFFFEA 		b	.L489
 6820              	.LVL574:
 6821              	.L540:
 6822              	.LBE242:
 6823              	.LBE241:
1853:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6824              		.loc 1 1853 0
 6825 3ae4 0400A0E3 		mov	r0, #4
 6826              	.LVL575:
 6827 3ae8 18129FE5 		ldr	r1, .L558+196
 6828 3aec FEFFFFEB 		bl	CyU3PDebugPrint
 6829              	.LVL576:
 6830              	.L485:
 6831              	.LBB243:
 6832              	.LBB244:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6833              		.loc 1 1246 0
 6834 3af0 C4119FE5 		ldr	r1, .L558+120
 6835 3af4 0400A0E3 		mov	r0, #4
 6836 3af8 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6837              		.loc 1 1247 0
 6838 3afc FA0FA0E3 		mov	r0, #1000
 6839 3b00 FEFFFFEB 		bl	_tx_thread_sleep
 6840 3b04 F9FFFFEA 		b	.L485
 6841              	.LVL577:
 6842              	.L539:
 6843              	.LBE244:
 6844              	.LBE243:
1840:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6845              		.loc 1 1840 0
 6846 3b08 0400A0E3 		mov	r0, #4
 6847              	.LVL578:
 6848 3b0c F8119FE5 		ldr	r1, .L558+200
 6849 3b10 FEFFFFEB 		bl	CyU3PDebugPrint
 6850              	.LVL579:
 6851              	.L483:
 6852              	.LBB245:
 6853              	.LBB246:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6854              		.loc 1 1246 0
 6855 3b14 A0119FE5 		ldr	r1, .L558+120
 6856 3b18 0400A0E3 		mov	r0, #4
 6857 3b1c FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6858              		.loc 1 1247 0
 6859 3b20 FA0FA0E3 		mov	r0, #1000
 6860 3b24 FEFFFFEB 		bl	_tx_thread_sleep
 6861 3b28 F9FFFFEA 		b	.L483
 6862              	.LVL580:
 6863              	.L541:
 6864              	.LBE246:
 6865              	.LBE245:
1867:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6866              		.loc 1 1867 0
 6867 3b2c 0400A0E3 		mov	r0, #4
 6868              	.LVL581:
 6869 3b30 D8119FE5 		ldr	r1, .L558+204
 6870 3b34 FEFFFFEB 		bl	CyU3PDebugPrint
 6871              	.LVL582:
 6872              	.L487:
 6873              	.LBB247:
 6874              	.LBB248:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6875              		.loc 1 1246 0
 6876 3b38 7C119FE5 		ldr	r1, .L558+120
 6877 3b3c 0400A0E3 		mov	r0, #4
 6878 3b40 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6879              		.loc 1 1247 0
 6880 3b44 FA0FA0E3 		mov	r0, #1000
 6881 3b48 FEFFFFEB 		bl	_tx_thread_sleep
 6882 3b4c F9FFFFEA 		b	.L487
 6883              	.LVL583:
 6884              	.L550:
 6885              	.LBE248:
 6886              	.LBE247:
 6887              	.LBE250:
 6888              	.LBE266:
2300:../uvc.c      ****                 prodCount = 0;
 6889              		.loc 1 2300 0
 6890 3b50 B443C5E1 		strh	r4, [r5, #52]	@ movhi
2301:../uvc.c      ****                 consCount = 0;
 6891              		.loc 1 2301 0
 6892 3b54 B643C5E1 		strh	r4, [r5, #54]	@ movhi
2302:../uvc.c      ****                 hitFV     = CyFalse;
 6893              		.loc 1 2302 0
 6894 3b58 304085E5 		str	r4, [r5, #48]
2315:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6895              		.loc 1 2315 0
 6896 3b5c 8124D8E5 		ldrb	r2, [r8, #1153]	@ zero_extendqisi2
2297:../uvc.c      ****             	fb=0;
 6897              		.loc 1 2297 0
 6898 3b60 B842C5E1 		strh	r4, [r5, #40]	@ movhi
2315:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6899              		.loc 1 2315 0
 6900 3b64 01E022E2 		eor	lr, r2, #1
 6901 3b68 81E4C8E5 		strb	lr, [r8, #1153]
2316:../uvc.c      ****                 if(stiflag){
 6902              		.loc 1 2316 0
 6903 3b6c 9C3095E5 		ldr	r3, [r5, #156]
2298:../uvc.c      ****             	pb=0;
 6904              		.loc 1 2298 0
 6905 3b70 BA42C5E1 		strh	r4, [r5, #42]	@ movhi
2316:../uvc.c      ****                 if(stiflag){
 6906              		.loc 1 2316 0
 6907 3b74 000053E3 		cmp	r3, #0
2323:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6908              		.loc 1 2323 0
 6909 3b78 8134D705 		ldreqb	r3, [r7, #1153]	@ zero_extendqisi2
2299:../uvc.c      ****             	pbc=0;
 6910              		.loc 1 2299 0
 6911 3b7c BC42C5E1 		strh	r4, [r5, #44]	@ movhi
2323:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6912              		.loc 1 2323 0
 6913 3b80 DF300302 		andeq	r3, r3, #223
 6914 3b84 8134C705 		streqb	r3, [r7, #1153]
2316:../uvc.c      ****                 if(stiflag){
 6915              		.loc 1 2316 0
 6916 3b88 0A00000A 		beq	.L511
2317:../uvc.c      ****                 	if (CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3P_EVENT_AND_CLEAR, &fl
 6917              		.loc 1 2317 0
 6918 3b8c C4009FE5 		ldr	r0, .L558+20
 6919 3b90 8010A0E3 		mov	r1, #128
 6920 3b94 0320A0E3 		mov	r2, #3
 6921 3b98 B4308DE2 		add	r3, sp, #180
 6922 3b9c 00408DE5 		str	r4, [sp, #0]
 6923 3ba0 FEFFFFEB 		bl	_txe_event_flags_get
 6924 3ba4 000050E3 		cmp	r0, #0
2319:../uvc.c      ****                 		glUVCHeader[1] |= (1<<5);    //set still image flag
 6925              		.loc 1 2319 0
 6926 3ba8 8104D705 		ldreqb	r0, [r7, #1153]	@ zero_extendqisi2
 6927 3bac 20008003 		orreq	r0, r0, #32
 6928 3bb0 8104C705 		streqb	r0, [r7, #1153]
2320:../uvc.c      ****                 		stiflag = CyFalse;
 6929              		.loc 1 2320 0
 6930 3bb4 9C408505 		streq	r4, [r5, #156]
 6931              	.L511:
2326:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6932              		.loc 1 2326 0
 6933 3bb8 F0009FE5 		ldr	r0, .L558+108
 6934 3bbc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6935              	.LVL584:
2327:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6936              		.loc 1 2327 0
 6937 3bc0 002050E2 		subs	r2, r0, #0
 6938 3bc4 0C00001A 		bne	.L556
2334:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6939              		.loc 1 2334 0
 6940 3bc8 0210A0E1 		mov	r1, r2
 6941 3bcc DC009FE5 		ldr	r0, .L558+108
 6942              	.LVL585:
 6943 3bd0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6944              	.LVL586:
2335:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6945              		.loc 1 2335 0
 6946 3bd4 002050E2 		subs	r2, r0, #0
 6947 3bd8 1000001A 		bne	.L557
2343:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6948              		.loc 1 2343 0
 6949 3bdc C4009FE5 		ldr	r0, .L558+100
 6950              	.LVL587:
 6951 3be0 0210A0E1 		mov	r1, r2
 6952 3be4 02A0A0E3 		mov	sl, #2
 6953 3be8 0020A0E1 		mov	r2, r0
 6954              	.LVL588:
 6955 3bec 0130A0E1 		mov	r3, r1
 6956 3bf0 00A08DE5 		str	sl, [sp, #0]
 6957 3bf4 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6958              	.LVL589:
 6959 3bf8 B7FEFFEA 		b	.L509
 6960              	.LVL590:
 6961              	.L556:
2329:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6962              		.loc 1 2329 0
 6963 3bfc 0400A0E3 		mov	r0, #4
 6964              	.LVL591:
 6965 3c00 0C119FE5 		ldr	r1, .L558+208
 6966 3c04 FEFFFFEB 		bl	CyU3PDebugPrint
 6967              	.LVL592:
 6968              	.L513:
 6969              	.LBB267:
 6970              	.LBB268:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6971              		.loc 1 1246 0
 6972 3c08 AC109FE5 		ldr	r1, .L558+120
 6973 3c0c 0400A0E3 		mov	r0, #4
 6974 3c10 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6975              		.loc 1 1247 0
 6976 3c14 FA0FA0E3 		mov	r0, #1000
 6977 3c18 FEFFFFEB 		bl	_tx_thread_sleep
 6978 3c1c F9FFFFEA 		b	.L513
 6979              	.LVL593:
 6980              	.L557:
 6981              	.LBE268:
 6982              	.LBE267:
2337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6983              		.loc 1 2337 0
 6984 3c20 0400A0E3 		mov	r0, #4
 6985              	.LVL594:
 6986 3c24 EC109FE5 		ldr	r1, .L558+212
 6987 3c28 FEFFFFEB 		bl	CyU3PDebugPrint
 6988              	.LVL595:
 6989              	.L515:
 6990              	.LBB269:
 6991              	.LBB270:
1246:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6992              		.loc 1 1246 0
 6993 3c2c 88109FE5 		ldr	r1, .L558+120
 6994 3c30 0400A0E3 		mov	r0, #4
 6995 3c34 FEFFFFEB 		bl	CyU3PDebugPrint
1247:../uvc.c      ****         CyU3PThreadSleep (1000);
 6996              		.loc 1 1247 0
 6997 3c38 FA0FA0E3 		mov	r0, #1000
 6998 3c3c FEFFFFEB 		bl	_tx_thread_sleep
 6999 3c40 F9FFFFEA 		b	.L515
 7000              	.L559:
 7001              		.align	2
 7002              	.L558:
 7003 3c44 18060000 		.word	.LC33
 7004 3c48 00C20100 		.word	115200
 7005 3c4c 38060000 		.word	.LC34
 7006 3c50 A0860100 		.word	100000
 7007 3c54 54060000 		.word	.LC35
 7008 3c58 00000000 		.word	.LANCHOR0
 7009 3c5c 00000000 		.word	CyFxGpifCB
 7010 3c60 88130000 		.word	5000
 7011 3c64 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7012 3c68 00000000 		.word	CyFxUVCApplnUSBEventCB
 7013 3c6c 00000000 		.word	CyFxUSBDeviceDscr
 7014 3c70 00000000 		.word	CyFxUSBDeviceDscrSS
 7015 3c74 00000000 		.word	CyFxUSBDeviceQualDscr
 7016 3c78 00000000 		.word	CyFxUSBBOSDscr
 7017 3c7c 00000000 		.word	CyFxUSBHSConfigDscr
 7018 3c80 00000000 		.word	CyFxUSBFSConfigDscr
 7019 3c84 00000000 		.word	CyFxUSBSSConfigDscr
 7020 3c88 00000000 		.word	CyFxUSBStringLangIDDscr
 7021 3c8c 00000000 		.word	CyFxUSBManufactureDscr
 7022 3c90 00000000 		.word	CyFxUSBProductDscr
 7023 3c94 013F0000 		.word	16129
 7024 3c98 02030000 		.word	770
 7025 3c9c 00000000 		.word	glChHandleInterStat
 7026 3ca0 00000000 		.word	glInterStaBuffer
 7027 3ca4 03030000 		.word	771
 7028 3ca8 01010000 		.word	257
 7029 3cac 00000000 		.word	CyFxUvcApplnDmaCallback
 7030 3cb0 00000000 		.word	glChHandleUVCStream
 7031 3cb4 00000000 		.word	.LANCHOR1
 7032 3cb8 70060000 		.word	.LC36
 7033 3cbc D8010000 		.word	.LC12
 7034 3cc0 C0060000 		.word	.LC38
 7035 3cc4 9C060000 		.word	.LC37
 7036 3cc8 E8060000 		.word	.LC39
 7037 3ccc 40080000 		.word	.LC46
 7038 3cd0 1C090000 		.word	.LC50
 7039 3cd4 EC080000 		.word	.LC49
 7040 3cd8 B4080000 		.word	.LC48
 7041 3cdc 74080000 		.word	.LC47
 7042 3ce0 E8090000 		.word	.LC55
 7043 3ce4 2C000000 		.word	.LANCHOR2+44
 7044 3ce8 300A0000 		.word	.LC57
 7045 3cec D8090000 		.word	.LC54
 7046 3cf0 10000000 		.word	.LANCHOR2+16
 7047 3cf4 F8090000 		.word	.LC56
 7048 3cf8 A4090000 		.word	.LC53
 7049 3cfc 10080000 		.word	.LC45
 7050 3d00 E0070000 		.word	.LC44
 7051 3d04 A8070000 		.word	.LC43
 7052 3d08 40070000 		.word	.LC41
 7053 3d0c 14070000 		.word	.LC40
 7054 3d10 74070000 		.word	.LC42
 7055 3d14 44090000 		.word	.LC51
 7056 3d18 70090000 		.word	.LC52
 7057              	.LBE270:
 7058              	.LBE269:
 7059              		.cfi_endproc
 7060              	.LFE18:
 7062              		.align	2
 7063              		.global	CyFxApplicationDefine
 7065              	CyFxApplicationDefine:
 7066              	.LFB26:
3673:../uvc.c      **** }
3674:../uvc.c      **** 
3675:../uvc.c      **** 
3676:../uvc.c      **** /*
3677:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3678:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3679:../uvc.c      ****  */
3680:../uvc.c      **** void
3681:../uvc.c      **** CyFxApplicationDefine (
3682:../uvc.c      ****         void)
3683:../uvc.c      **** {
 7067              		.loc 1 3683 0
 7068              		.cfi_startproc
 7069              		@ args = 0, pretend = 0, frame = 40
 7070              		@ frame_needed = 0, uses_anonymous_args = 0
 7071              	.LVL596:
 7072 3d1c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7073              	.LCFI25:
 7074              		.cfi_def_cfa_offset 36
3684:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3685:../uvc.c      ****     uint32_t retThrdCreate;
3686:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3687:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3688:../uvc.c      **** 
3689:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3690:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7075              		.loc 1 3690 0
 7076 3d20 010AA0E3 		mov	r0, #4096
3683:../uvc.c      **** {
 7077              		.loc 1 3683 0
 7078 3d24 4CD04DE2 		sub	sp, sp, #76
 7079              	.LCFI26:
 7080              		.cfi_def_cfa_offset 112
 7081              		.loc 1 3690 0
 7082              		.cfi_offset 14, -4
 7083              		.cfi_offset 11, -8
 7084              		.cfi_offset 10, -12
 7085              		.cfi_offset 9, -16
 7086              		.cfi_offset 8, -20
 7087              		.cfi_offset 7, -24
 7088              		.cfi_offset 6, -28
 7089              		.cfi_offset 5, -32
 7090              		.cfi_offset 4, -36
 7091 3d28 FEFFFFEB 		bl	CyU3PMemAlloc
 7092 3d2c 00A0A0E1 		mov	sl, r0
 7093              	.LVL597:
3691:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7094              		.loc 1 3691 0
 7095 3d30 010AA0E3 		mov	r0, #4096
 7096              	.LVL598:
 7097 3d34 FEFFFFEB 		bl	CyU3PMemAlloc
 7098 3d38 00B0A0E1 		mov	fp, r0
 7099              	.LVL599:
3692:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7100              		.loc 1 3692 0
 7101 3d3c 010AA0E3 		mov	r0, #4096
 7102              	.LVL600:
 7103 3d40 FEFFFFEB 		bl	CyU3PMemAlloc
3693:../uvc.c      **** 
3694:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7104              		.loc 1 3694 0
 7105 3d44 00005AE3 		cmp	sl, #0
 7106 3d48 00005B13 		cmpne	fp, #0
 7107 3d4c 0090A013 		movne	r9, #0
 7108 3d50 0190A003 		moveq	r9, #1
3692:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7109              		.loc 1 3692 0
 7110 3d54 24008DE5 		str	r0, [sp, #36]
 7111              	.LVL601:
 7112              		.loc 1 3694 0
 7113 3d58 0000001A 		bne	.L564
 7114              	.LVL602:
 7115              	.L561:
 7116              	.L563:
 7117 3d5c FEFFFFEA 		b	.L563
 7118              	.L564:
 7119              		.loc 1 3694 0 is_stmt 0 discriminator 1
 7120 3d60 000050E3 		cmp	r0, #0
 7121 3d64 FCFFFF0A 		beq	.L561
3695:../uvc.c      ****         goto fatalErrorHandler;
3696:../uvc.c      **** 
3697:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3698:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7122              		.loc 1 3698 0 is_stmt 1
 7123 3d68 28408DE2 		add	r4, sp, #40
 7124 3d6c 0400A0E1 		mov	r0, r4
 7125 3d70 4010A0E3 		mov	r1, #64
 7126 3d74 18219FE5 		ldr	r2, .L565
 7127 3d78 FEFFFFEB 		bl	cmdbufCreate
 7128 3d7c 0450A0E1 		mov	r5, r4
 7129 3d80 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7130 3d84 0C719FE5 		ldr	r7, .L565+4
3699:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7131              		.loc 1 3699 0
 7132 3d88 0C819FE5 		ldr	r8, .L565+8
3698:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7133              		.loc 1 3698 0
 7134 3d8c 07C0A0E1 		mov	ip, r7
 7135 3d90 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7136 3d94 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3700:../uvc.c      **** 
3701:../uvc.c      **** 	/****** initialize command descriptor ***********/
3702:../uvc.c      **** 	cmdquInit(cmdQuptr);
3703:../uvc.c      **** 	cmdquInit(statQuptr);
3704:../uvc.c      **** 
3705:../uvc.c      ****     /* Create the UVC application thread. */
3706:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7137              		.loc 1 3706 0
 7138 3d98 0860A0E3 		mov	r6, #8
3698:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7139              		.loc 1 3698 0
 7140 3d9c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3699:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7141              		.loc 1 3699 0
 7142 3da0 F8209FE5 		ldr	r2, .L565+12
 7143 3da4 0400A0E1 		mov	r0, r4
 7144 3da8 2010A0E3 		mov	r1, #32
 7145 3dac FEFFFFEB 		bl	cmdbufCreate
 7146 3db0 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7147 3db4 08C0A0E1 		mov	ip, r8
 7148 3db8 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7149 3dbc 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7150              		.loc 1 3706 0
 7151 3dc0 0140A0E3 		mov	r4, #1
3699:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7152              		.loc 1 3699 0
 7153 3dc4 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3702:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7154              		.loc 1 3702 0
 7155 3dc8 0700A0E1 		mov	r0, r7
 7156 3dcc FEFFFFEB 		bl	cmdquInit
3703:../uvc.c      **** 	cmdquInit(statQuptr);
 7157              		.loc 1 3703 0
 7158 3dd0 0800A0E1 		mov	r0, r8
 7159 3dd4 FEFFFFEB 		bl	cmdquInit
 7160              		.loc 1 3706 0
 7161 3dd8 A850A0E3 		mov	r5, #168
 7162 3ddc 01CAA0E3 		mov	ip, #4096
 7163 3de0 BC009FE5 		ldr	r0, .L565+16
 7164 3de4 BC109FE5 		ldr	r1, .L565+20
 7165 3de8 BC209FE5 		ldr	r2, .L565+24
 7166 3dec 0930A0E1 		mov	r3, r9
 7167 3df0 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7168 3df4 08608DE5 		str	r6, [sp, #8]
 7169 3df8 0C608DE5 		str	r6, [sp, #12]
 7170 3dfc 10908DE5 		str	r9, [sp, #16]
 7171 3e00 14408DE5 		str	r4, [sp, #20]
 7172 3e04 18508DE5 		str	r5, [sp, #24]
 7173 3e08 FEFFFFEB 		bl	_txe_thread_create
 7174              	.LVL603:
3707:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3708:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3709:../uvc.c      ****             0,                                          /* No input parameter to thread */
3710:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3711:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3712:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3713:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3714:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3715:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3716:../uvc.c      ****             );
3717:../uvc.c      ****     if (retThrdCreate != 0)
 7175              		.loc 1 3717 0
 7176 3e0c 00C050E2 		subs	ip, r0, #0
 7177 3e10 D1FFFF1A 		bne	.L561
3718:../uvc.c      ****     {
3719:../uvc.c      ****         goto fatalErrorHandler;
3720:../uvc.c      ****     }
3721:../uvc.c      **** 
3722:../uvc.c      ****     /* Create the control request handling thread. */
3723:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7178              		.loc 1 3723 0
 7179 3e14 0C30A0E1 		mov	r3, ip
 7180 3e18 027BA0E3 		mov	r7, #2048
 7181 3e1c 8C009FE5 		ldr	r0, .L565+28
 7182              	.LVL604:
 7183 3e20 8C109FE5 		ldr	r1, .L565+32
 7184 3e24 8C209FE5 		ldr	r2, .L565+36
 7185 3e28 10C08DE5 		str	ip, [sp, #16]
 7186 3e2c 00B08DE5 		str	fp, [sp, #0]
 7187 3e30 04708DE5 		str	r7, [sp, #4]
 7188 3e34 08608DE5 		str	r6, [sp, #8]
 7189 3e38 0C608DE5 		str	r6, [sp, #12]
 7190 3e3c 14408DE5 		str	r4, [sp, #20]
 7191 3e40 18508DE5 		str	r5, [sp, #24]
 7192 3e44 FEFFFFEB 		bl	_txe_thread_create
 7193              	.LVL605:
3724:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3725:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3726:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3727:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3728:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3729:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3730:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3731:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3732:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3733:../uvc.c      ****             );
3734:../uvc.c      ****     if (retThrdCreate != 0)
 7194              		.loc 1 3734 0
 7195 3e48 00C050E2 		subs	ip, r0, #0
 7196 3e4c C2FFFF1A 		bne	.L561
3735:../uvc.c      ****     {
3736:../uvc.c      ****         goto fatalErrorHandler;
3737:../uvc.c      ****     }
3738:../uvc.c      **** #if 1
3739:../uvc.c      ****     /* Create the I2C control command handling thread. */
3740:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7197              		.loc 1 3740 0
 7198 3e50 24E09DE5 		ldr	lr, [sp, #36]
 7199 3e54 60009FE5 		ldr	r0, .L565+40
 7200              	.LVL606:
 7201 3e58 60109FE5 		ldr	r1, .L565+44
 7202 3e5c 60209FE5 		ldr	r2, .L565+48
 7203 3e60 0C30A0E1 		mov	r3, ip
 7204 3e64 00E08DE5 		str	lr, [sp, #0]
 7205 3e68 04708DE5 		str	r7, [sp, #4]
 7206 3e6c 08608DE5 		str	r6, [sp, #8]
 7207 3e70 0C608DE5 		str	r6, [sp, #12]
 7208 3e74 10C08DE5 		str	ip, [sp, #16]
 7209 3e78 14408DE5 		str	r4, [sp, #20]
 7210 3e7c 18508DE5 		str	r5, [sp, #24]
 7211 3e80 FEFFFFEB 		bl	_txe_thread_create
 7212              	.LVL607:
3741:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3742:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3743:../uvc.c      ****             0,                                          /* No input parameter to thread */
3744:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3745:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3746:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3747:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3748:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3749:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3750:../uvc.c      ****             );
3751:../uvc.c      ****     if (retThrdCreate != 0)
 7213              		.loc 1 3751 0
 7214 3e84 000050E3 		cmp	r0, #0
 7215 3e88 B3FFFF1A 		bne	.L561
3752:../uvc.c      ****     {
3753:../uvc.c      ****         goto fatalErrorHandler;
3754:../uvc.c      ****     }
3755:../uvc.c      **** #endif
3756:../uvc.c      **** 
3757:../uvc.c      ****     return;
3758:../uvc.c      **** 
3759:../uvc.c      **** fatalErrorHandler:
3760:../uvc.c      ****     /* Add custom recovery or debug actions here */
3761:../uvc.c      ****     /* Loop indefinitely */
3762:../uvc.c      ****     while (1);
3763:../uvc.c      **** }
 7216              		.loc 1 3763 0
 7217 3e8c 4CD08DE2 		add	sp, sp, #76
 7218 3e90 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7219              	.L566:
 7220              		.align	2
 7221              	.L565:
 7222 3e94 00000000 		.word	cmdQuMux
 7223 3e98 00000000 		.word	cmdQu
 7224 3e9c 00000000 		.word	statQu
 7225 3ea0 00000000 		.word	staQuMux
 7226 3ea4 A0000000 		.word	.LANCHOR0+160
 7227 3ea8 680A0000 		.word	.LC58
 7228 3eac 00000000 		.word	UVCAppThread_Entry
 7229 3eb0 48010000 		.word	.LANCHOR0+328
 7230 3eb4 7C0A0000 		.word	.LC59
 7231 3eb8 00000000 		.word	UVCAppEP0Thread_Entry
 7232 3ebc F0010000 		.word	.LANCHOR0+496
 7233 3ec0 940A0000 		.word	.LC60
 7234 3ec4 00000000 		.word	I2cAppThread_Entry
 7235              		.cfi_endproc
 7236              	.LFE26:
 7238              		.align	2
 7239              		.global	main
 7241              	main:
 7242              	.LFB27:
3764:../uvc.c      **** 
3765:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3766:../uvc.c      ****  * the ThreadX RTOS here.
3767:../uvc.c      ****  */
3768:../uvc.c      **** int
3769:../uvc.c      **** main (
3770:../uvc.c      ****         void)
3771:../uvc.c      **** {
 7243              		.loc 1 3771 0
 7244              		.cfi_startproc
 7245              		@ args = 0, pretend = 0, frame = 56
 7246              		@ frame_needed = 0, uses_anonymous_args = 0
 7247 3ec8 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7248              	.LCFI27:
 7249              		.cfi_def_cfa_offset 12
3772:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3773:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3774:../uvc.c      **** 
3775:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3776:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3777:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3778:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3779:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3780:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7250              		.loc 1 3780 0
 7251 3ecc 0010A0E3 		mov	r1, #0
3771:../uvc.c      **** {
 7252              		.loc 1 3771 0
 7253 3ed0 3CD04DE2 		sub	sp, sp, #60
 7254              	.LCFI28:
 7255              		.cfi_def_cfa_offset 72
3777:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7256              		.loc 1 3777 0
 7257 3ed4 0220A0E3 		mov	r2, #2
3781:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7258              		.loc 1 3781 0
 7259 3ed8 033081E2 		add	r3, r1, #3
3776:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7260              		.loc 1 3776 0
 7261 3edc 0150A0E3 		mov	r5, #1
 7262              		.cfi_offset 14, -4
 7263              		.cfi_offset 5, -8
 7264              		.cfi_offset 4, -12
3782:../uvc.c      **** 
3783:../uvc.c      ****     /* Initialize the device */
3784:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7265              		.loc 1 3784 0
 7266 3ee0 28008DE2 		add	r0, sp, #40
3776:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7267              		.loc 1 3776 0
 7268 3ee4 28508DE5 		str	r5, [sp, #40]
3777:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7269              		.loc 1 3777 0
 7270 3ee8 2C20CDE5 		strb	r2, [sp, #44]
3778:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7271              		.loc 1 3778 0
 7272 3eec 2D20CDE5 		strb	r2, [sp, #45]
3779:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7273              		.loc 1 3779 0
 7274 3ef0 2E20CDE5 		strb	r2, [sp, #46]
3780:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7275              		.loc 1 3780 0
 7276 3ef4 30108DE5 		str	r1, [sp, #48]
3781:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7277              		.loc 1 3781 0
 7278 3ef8 3430CDE5 		strb	r3, [sp, #52]
 7279              		.loc 1 3784 0
 7280 3efc FEFFFFEB 		bl	CyU3PDeviceInit
 7281              	.LVL608:
3785:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7282              		.loc 1 3785 0
 7283 3f00 004050E2 		subs	r4, r0, #0
 7284 3f04 0000000A 		beq	.L570
 7285              	.L568:
 7286              	.L569:
 7287 3f08 FEFFFFEA 		b	.L569
 7288              	.L570:
3786:../uvc.c      ****     {
3787:../uvc.c      ****         goto handle_fatal_error;
3788:../uvc.c      ****     }
3789:../uvc.c      **** 
3790:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3791:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7289              		.loc 1 3791 0
 7290 3f0c 0410A0E1 		mov	r1, r4
 7291 3f10 0420A0E1 		mov	r2, r4
 7292 3f14 0500A0E1 		mov	r0, r5
 7293              	.LVL609:
 7294 3f18 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7295              	.LVL610:
3792:../uvc.c      **** 
3793:../uvc.c      ****     /* Configure the IO matrix for the device. */
3794:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3795:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3796:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3797:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3798:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3799:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3800:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3801:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3802:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3803:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3804:../uvc.c      **** 
3805:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7296              		.loc 1 3805 0
 7297 3f1c 0D00A0E1 		mov	r0, sp
3795:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7298              		.loc 1 3795 0
 7299 3f20 1640CDE5 		strb	r4, [sp, #22]
3796:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7300              		.loc 1 3796 0
 7301 3f24 18408DE5 		str	r4, [sp, #24]
3797:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7302              		.loc 1 3797 0
 7303 3f28 1C408DE5 		str	r4, [sp, #28]
3798:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7304              		.loc 1 3798 0
 7305 3f2c 20408DE5 		str	r4, [sp, #32]
3799:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7306              		.loc 1 3799 0
 7307 3f30 24408DE5 		str	r4, [sp, #36]
3802:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7308              		.loc 1 3802 0
 7309 3f34 0C408DE5 		str	r4, [sp, #12]
3803:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7310              		.loc 1 3803 0
 7311 3f38 10408DE5 		str	r4, [sp, #16]
3794:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7312              		.loc 1 3794 0
 7313 3f3c 00508DE5 		str	r5, [sp, #0]
3800:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7314              		.loc 1 3800 0
 7315 3f40 04508DE5 		str	r5, [sp, #4]
3801:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7316              		.loc 1 3801 0
 7317 3f44 08508DE5 		str	r5, [sp, #8]
 7318              		.loc 1 3805 0
 7319 3f48 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7320              	.LVL611:
3806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7321              		.loc 1 3806 0
 7322 3f4c 004050E2 		subs	r4, r0, #0
 7323 3f50 ECFFFF1A 		bne	.L568
3807:../uvc.c      ****     {
3808:../uvc.c      ****         goto handle_fatal_error;
3809:../uvc.c      ****     }
3810:../uvc.c      **** 
3811:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3812:../uvc.c      ****     CyU3PKernelEntry ();
 7324              		.loc 1 3812 0
 7325 3f54 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7326              	.LVL612:
3813:../uvc.c      **** 
3814:../uvc.c      ****     /* Dummy return to make the compiler happy */
3815:../uvc.c      ****     return 0;
3816:../uvc.c      **** 
3817:../uvc.c      **** handle_fatal_error:
3818:../uvc.c      ****     /* Cannot recover from this error. */
3819:../uvc.c      ****     while (1);
3820:../uvc.c      **** }
 7327              		.loc 1 3820 0
 7328 3f58 0400A0E1 		mov	r0, r4
 7329 3f5c 3CD08DE2 		add	sp, sp, #60
 7330 3f60 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7331              		.cfi_endproc
 7332              	.LFE27:
 7334              		.global	CyFxGpifTransition
 7335              		.global	CyFxGpifWavedata
 7336              		.global	CyFxGpifWavedataPosition
 7337              		.global	CyFxGpifRegValue
 7338              		.global	CyFxGpifConfig
 7339              		.global	CyFxGpifTransition_usb2
 7340              		.global	CyFxGpifWavedata_usb2
 7341              		.global	CyFxGpifWavedataPosition_usb2
 7342              		.global	CyFxGpifRegValue_usb2
 7343              		.global	CyFxGpifConfig_usb2
 7344              		.global	snapButFlag
 7345              		.global	testSnap
 7346              		.global	fb
 7347              		.global	pb
 7348              		.global	pbc
 7349              		.global	fbbak
 7350              		.global	pbbak
 7351              		.global	pbcbak
 7352              		.global	pbcpbak
 7353              		.global	isUsbConnected
 7354              		.global	usbSpeed
 7355              		.global	clearFeatureRqtReceived
 7356              		.global	streamingStarted
 7357              		.global	glProbeCtrl
 7358              		.global	glProbeCtrlFull
 7359              		.global	glProbeStilCtrl
 7360              		.global	glProbeCtrl20
 7361              		.global	glProbeStilCtrl20
 7362              		.global	glUVCHeader
 7363              		.comm	glChHandleUVCStream,220,4
 7364              		.comm	glChHandleStillStream,220,4
 7365              		.comm	glChHandleInterStat,160,4
 7366              		.comm	glInterStaBuffer,4,4
 7367              		.comm	cmdQu,32,4
 7368              		.comm	statQu,32,4
 7369              		.comm	cmdQuMux,56,4
 7370              		.comm	staQuMux,56,4
 7371              		.comm	timMux,56,4
 7372              		.comm	bmReqType,1,1
 7373              		.comm	bRequest,1,1
 7374              		.comm	wValue,2,2
 7375              		.comm	wIndex,2,2
 7376              		.comm	wLength,2,2
 7377              		.comm	posTick,4,4
 7378              		.comm	I2CCmdTimer,44,4
 7379              		.section	.rodata
 7380              		.align	2
 7381              		.set	.LANCHOR2,. + 0
 7384              	ExTime:
 7385 0000 9C       		.byte	-100
 7386 0001 00       		.byte	0
 7387 0002 4E       		.byte	78
 7388 0003 00       		.byte	0
 7389 0004 27       		.byte	39
 7390 0005 00       		.byte	0
 7391 0006 14       		.byte	20
 7392 0007 00       		.byte	0
 7393 0008 0A       		.byte	10
 7394 0009 00       		.byte	0
 7395 000a 05       		.byte	5
 7396 000b 00       		.byte	0
 7397 000c 02       		.byte	2
 7398 000d 00       		.byte	0
 7399 000e 01       		.byte	1
 7400 000f 00       		.byte	0
 7403              	CyFxGpifConfig:
 7404 0010 0F00     		.short	15
 7405 0012 0000     		.space	2
 7406 0014 00000000 		.word	CyFxGpifWavedata
 7407 0018 00000000 		.word	CyFxGpifWavedataPosition
 7408 001c 0500     		.short	5
 7409 001e 0000     		.space	2
 7410 0020 00000000 		.word	CyFxGpifTransition
 7411 0024 4C00     		.short	76
 7412 0026 0000     		.space	2
 7413 0028 00000000 		.word	CyFxGpifRegValue
 7416              	CyFxGpifConfig_usb2:
 7417 002c 9300     		.short	147
 7418 002e 0000     		.space	2
 7419 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7420 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7421 0038 0800     		.short	8
 7422 003a 0000     		.space	2
 7423 003c 00000000 		.word	CyFxGpifTransition_usb2
 7424 0040 4C00     		.short	76
 7425 0042 0000     		.space	2
 7426 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7427              		.data
 7428              		.align	2
 7429              		.set	.LANCHOR1,. + 0
 7432              	ExUCtrlParArry:
 7433 0000 13       		.byte	19
 7434 0001 14       		.byte	20
 7435 0002 02       		.byte	2
 7436 0003 01       		.byte	1
 7437 0004 00       		.byte	0
 7438 0005 03       		.byte	3
 7439 0006 00       		.byte	0
 7440 0007 01       		.byte	1
 7441 0008 00       		.byte	0
 7442 0009 03       		.byte	3
 7443 000a 00       		.byte	0
 7444 000b 23       		.byte	35
 7445 000c 37       		.byte	55
 7446 000d 23       		.byte	35
 7447 000e 37       		.byte	55
 7448 000f 30       		.byte	48
 7449 0010 01       		.byte	1
 7450 0011 00       		.byte	0
 7451 0012 00       		.byte	0
 7452 0013 00000000 		.space	5
 7452      00
 7453 0018 11       		.byte	17
 7454 0019 00       		.byte	0
 7455 001a 02       		.byte	2
 7456 001b 01       		.byte	1
 7457 001c 00       		.byte	0
 7458 001d 03       		.byte	3
 7459 001e 00       		.byte	0
 7460 001f 01       		.byte	1
 7461 0020 00       		.byte	0
 7462 0021 03       		.byte	3
 7463 0022 00       		.byte	0
 7464 0023 01       		.byte	1
 7465 0024 00       		.byte	0
 7466 0025 01       		.byte	1
 7467 0026 00       		.byte	0
 7468 0027 30       		.byte	48
 7469 0028 01       		.byte	1
 7470 0029 01       		.byte	1
 7471 002a 00       		.byte	0
 7472 002b 00000000 		.space	5
 7472      00
 7473 0030 17       		.byte	23
 7474 0031 00       		.byte	0
 7475 0032 01       		.byte	1
 7476 0033 01       		.byte	1
 7477 0034 00       		.byte	0
 7478 0035 02       		.byte	2
 7479 0036 00       		.byte	0
 7480 0037 01       		.byte	1
 7481 0038 00       		.byte	0
 7482 0039 03       		.byte	3
 7483 003a 00       		.byte	0
 7484 003b 00       		.byte	0
 7485 003c 00       		.byte	0
 7486 003d 00       		.byte	0
 7487 003e 00       		.byte	0
 7488 003f 30       		.byte	48
 7489 0040 01       		.byte	1
 7490 0041 01       		.byte	1
 7491 0042 00       		.byte	0
 7492 0043 00000000 		.space	5
 7492      00
 7493 0048 00       		.byte	0
 7494 0049 00       		.byte	0
 7495 004a 04       		.byte	4
 7496 004b 01       		.byte	1
 7497 004c 00       		.byte	0
 7498 004d 38       		.byte	56
 7499 004e 01       		.byte	1
 7500 004f 01       		.byte	1
 7501 0050 00       		.byte	0
 7502 0051 03       		.byte	3
 7503 0052 00       		.byte	0
 7504 0053 4E       		.byte	78
 7505 0054 00       		.byte	0
 7506 0055 4E       		.byte	78
 7507 0056 00       		.byte	0
 7508 0057 30       		.byte	48
 7509 0058 01       		.byte	1
 7510 0059 00       		.byte	0
 7511 005a 00       		.byte	0
 7512 005b 00000000 		.space	5
 7512      00
 7513 0060 00       		.byte	0
 7514 0061 00       		.byte	0
 7515 0062 01       		.byte	1
 7516 0063 00       		.byte	0
 7517 0064 00       		.byte	0
 7518 0065 00       		.byte	0
 7519 0066 00       		.byte	0
 7520 0067 01       		.byte	1
 7521 0068 00       		.byte	0
 7522 0069 03       		.byte	3
 7523 006a 00       		.byte	0
 7524 006b 00       		.byte	0
 7525 006c 00       		.byte	0
 7526 006d 00       		.byte	0
 7527 006e 00       		.byte	0
 7528 006f 30       		.byte	48
 7529 0070 01       		.byte	1
 7530 0071 00       		.byte	0
 7531 0072 00       		.byte	0
 7532 0073 00000000 		.space	5
 7532      00
 7533 0078 00       		.byte	0
 7534 0079 00       		.byte	0
 7535 007a 02       		.byte	2
 7536 007b 00       		.byte	0
 7537 007c 00       		.byte	0
 7538 007d FF       		.byte	-1
 7539 007e 00       		.byte	0
 7540 007f 01       		.byte	1
 7541 0080 00       		.byte	0
 7542 0081 03       		.byte	3
 7543 0082 00       		.byte	0
 7544 0083 01       		.byte	1
 7545 0084 00       		.byte	0
 7546 0085 00       		.byte	0
 7547 0086 00       		.byte	0
 7548 0087 30       		.byte	48
 7549 0088 01       		.byte	1
 7550 0089 01       		.byte	1
 7551 008a 00       		.byte	0
 7552 008b 00000000 		.space	5
 7552      00
 7553 0090 00       		.byte	0
 7554 0091 00       		.byte	0
 7555 0092 02       		.byte	2
 7556 0093 00       		.byte	0
 7557 0094 00       		.byte	0
 7558 0095 00       		.byte	0
 7559 0096 00       		.byte	0
 7560 0097 00       		.byte	0
 7561 0098 00       		.byte	0
 7562 0099 03       		.byte	3
 7563 009a 00       		.byte	0
 7564 009b 00       		.byte	0
 7565 009c 00       		.byte	0
 7566 009d 00       		.byte	0
 7567 009e 00       		.byte	0
 7568 009f 30       		.byte	48
 7569 00a0 01       		.byte	1
 7570 00a1 01       		.byte	1
 7571 00a2 00       		.byte	0
 7572 00a3 00000000 		.space	5
 7572      00
 7573 00a8 00       		.byte	0
 7574 00a9 00       		.byte	0
 7575 00aa 02       		.byte	2
 7576 00ab 00       		.byte	0
 7577 00ac 00       		.byte	0
 7578 00ad 30       		.byte	48
 7579 00ae 00       		.byte	0
 7580 00af 01       		.byte	1
 7581 00b0 00       		.byte	0
 7582 00b1 03       		.byte	3
 7583 00b2 0A       		.byte	10
 7584 00b3 00       		.byte	0
 7585 00b4 00       		.byte	0
 7586 00b5 0A       		.byte	10
 7587 00b6 00       		.byte	0
 7588 00b7 30       		.byte	48
 7589 00b8 01       		.byte	1
 7590 00b9 01       		.byte	1
 7591 00ba 00       		.byte	0
 7592 00bb 00000000 		.space	5
 7592      00
 7593 00c0 00       		.byte	0
 7594 00c1 00       		.byte	0
 7595 00c2 01       		.byte	1
 7596 00c3 00       		.byte	0
 7597 00c4 00       		.byte	0
 7598 00c5 7F       		.byte	127
 7599 00c6 00       		.byte	0
 7600 00c7 01       		.byte	1
 7601 00c8 00       		.byte	0
 7602 00c9 03       		.byte	3
 7603 00ca 00       		.byte	0
 7604 00cb 00       		.byte	0
 7605 00cc 00       		.byte	0
 7606 00cd 00       		.byte	0
 7607 00ce 00       		.byte	0
 7608 00cf 30       		.byte	48
 7609 00d0 01       		.byte	1
 7610 00d1 00       		.byte	0
 7611 00d2 00       		.byte	0
 7612 00d3 00000000 		.space	5
 7612      00
 7613 00d8 00       		.byte	0
 7614 00d9 00       		.byte	0
 7615 00da 02       		.byte	2
 7616 00db 00       		.byte	0
 7617 00dc 00       		.byte	0
 7618 00dd 05       		.byte	5
 7619 00de 00       		.byte	0
 7620 00df 01       		.byte	1
 7621 00e0 00       		.byte	0
 7622 00e1 03       		.byte	3
 7623 00e2 00       		.byte	0
 7624 00e3 00       		.byte	0
 7625 00e4 00       		.byte	0
 7626 00e5 00       		.byte	0
 7627 00e6 00       		.byte	0
 7628 00e7 30       		.byte	48
 7629 00e8 01       		.byte	1
 7630 00e9 00       		.byte	0
 7631 00ea 00       		.byte	0
 7632 00eb 00000000 		.space	5
 7632      00
 7633 00f0 00       		.byte	0
 7634 00f1 00       		.byte	0
 7635 00f2 03       		.byte	3
 7636 00f3 00       		.byte	0
 7637 00f4 00       		.byte	0
 7638 00f5 0A       		.byte	10
 7639 00f6 00       		.byte	0
 7640 00f7 01       		.byte	1
 7641 00f8 00       		.byte	0
 7642 00f9 03       		.byte	3
 7643 00fa 00       		.byte	0
 7644 00fb 00       		.byte	0
 7645 00fc 00       		.byte	0
 7646 00fd 00       		.byte	0
 7647 00fe 00       		.byte	0
 7648 00ff 30       		.byte	48
 7649 0100 01       		.byte	1
 7650 0101 00       		.byte	0
 7651 0102 00       		.byte	0
 7652 0103 00000000 		.space	5
 7652      00
 7653 0108 00       		.byte	0
 7654 0109 00       		.byte	0
 7655 010a 02       		.byte	2
 7656 010b 00       		.byte	0
 7657 010c 00       		.byte	0
 7658 010d 40       		.byte	64
 7659 010e 00       		.byte	0
 7660 010f 01       		.byte	1
 7661 0110 00       		.byte	0
 7662 0111 03       		.byte	3
 7663 0112 00       		.byte	0
 7664 0113 0F       		.byte	15
 7665 0114 11       		.byte	17
 7666 0115 00       		.byte	0
 7667 0116 00       		.byte	0
 7668 0117 30       		.byte	48
 7669 0118 01       		.byte	1
 7670 0119 00       		.byte	0
 7671 011a 00       		.byte	0
 7672 011b 00000000 		.space	5
 7672      00
 7673 0120 00       		.byte	0
 7674 0121 00       		.byte	0
 7675 0122 02       		.byte	2
 7676 0123 00       		.byte	0
 7677 0124 00       		.byte	0
 7678 0125 64       		.byte	100
 7679 0126 00       		.byte	0
 7680 0127 01       		.byte	1
 7681 0128 00       		.byte	0
 7682 0129 03       		.byte	3
 7683 012a 00       		.byte	0
 7684 012b 00       		.byte	0
 7685 012c 00       		.byte	0
 7686 012d 00       		.byte	0
 7687 012e 00       		.byte	0
 7688 012f 30       		.byte	48
 7689 0130 01       		.byte	1
 7690 0131 00       		.byte	0
 7691 0132 00       		.byte	0
 7692 0133 00000000 		.space	5
 7692      00
 7693 0138 00       		.byte	0
 7694 0139 00       		.byte	0
 7695 013a 02       		.byte	2
 7696 013b 00       		.byte	0
 7697 013c 00       		.byte	0
 7698 013d 64       		.byte	100
 7699 013e 00       		.byte	0
 7700 013f 01       		.byte	1
 7701 0140 00       		.byte	0
 7702 0141 03       		.byte	3
 7703 0142 00       		.byte	0
 7704 0143 00       		.byte	0
 7705 0144 00       		.byte	0
 7706 0145 00       		.byte	0
 7707 0146 00       		.byte	0
 7708 0147 30       		.byte	48
 7709 0148 01       		.byte	1
 7710 0149 00       		.byte	0
 7711 014a 00       		.byte	0
 7712 014b 00000000 		.space	5
 7712      00
 7713 0150 00       		.byte	0
 7714 0151 00       		.byte	0
 7715 0152 02       		.byte	2
 7716 0153 00       		.byte	0
 7717 0154 00       		.byte	0
 7718 0155 64       		.byte	100
 7719 0156 00       		.byte	0
 7720 0157 01       		.byte	1
 7721 0158 00       		.byte	0
 7722 0159 03       		.byte	3
 7723 015a 00       		.byte	0
 7724 015b 00       		.byte	0
 7725 015c 00       		.byte	0
 7726 015d 00       		.byte	0
 7727 015e 00       		.byte	0
 7728 015f 30       		.byte	48
 7729 0160 01       		.byte	1
 7730 0161 00       		.byte	0
 7731 0162 00       		.byte	0
 7732 0163 00000000 		.space	5
 7732      00
 7733 0168 00       		.byte	0
 7734 0169 00       		.byte	0
 7735 016a 02       		.byte	2
 7736 016b 00       		.byte	0
 7737 016c 00       		.byte	0
 7738 016d 64       		.byte	100
 7739 016e 00       		.byte	0
 7740 016f 01       		.byte	1
 7741 0170 00       		.byte	0
 7742 0171 03       		.byte	3
 7743 0172 00       		.byte	0
 7744 0173 00       		.byte	0
 7745 0174 00       		.byte	0
 7746 0175 00       		.byte	0
 7747 0176 00       		.byte	0
 7748 0177 30       		.byte	48
 7749 0178 01       		.byte	1
 7750 0179 00       		.byte	0
 7751 017a 00       		.byte	0
 7752 017b 00000000 		.space	5
 7752      00
 7755              	CtrlParArry:
 7756 0180 10       		.byte	16
 7757 0181 10       		.byte	16
 7758 0182 02       		.byte	2
 7759 0183 00       		.byte	0
 7760 0184 00       		.byte	0
 7761 0185 03       		.byte	3
 7762 0186 00       		.byte	0
 7763 0187 01       		.byte	1
 7764 0188 00       		.byte	0
 7765 0189 03       		.byte	3
 7766 018a 00       		.byte	0
 7767 018b 03       		.byte	3
 7768 018c 00       		.byte	0
 7769 018d 03       		.byte	3
 7770 018e 00       		.byte	0
 7771 018f 30       		.byte	48
 7772 0190 01       		.byte	1
 7773 0191 00       		.byte	0
 7774 0192 00       		.byte	0
 7775 0193 00000000 		.space	5
 7775      00
 7776 0198 01       		.byte	1
 7777 0199 00       		.byte	0
 7778 019a 02       		.byte	2
 7779 019b 00       		.byte	0
 7780 019c 00       		.byte	0
 7781 019d FF       		.byte	-1
 7782 019e 00       		.byte	0
 7783 019f 01       		.byte	1
 7784 01a0 00       		.byte	0
 7785 01a1 03       		.byte	3
 7786 01a2 00       		.byte	0
 7787 01a3 76       		.byte	118
 7788 01a4 00       		.byte	0
 7789 01a5 76       		.byte	118
 7790 01a6 C7       		.byte	-57
 7791 01a7 C6       		.byte	-58
 7792 01a8 01       		.byte	1
 7793 01a9 01       		.byte	1
 7794 01aa 00       		.byte	0
 7795 01ab 00000000 		.space	5
 7795      00
 7796 01b0 02       		.byte	2
 7797 01b1 02       		.byte	2
 7798 01b2 02       		.byte	2
 7799 01b3 00       		.byte	0
 7800 01b4 00       		.byte	0
 7801 01b5 FF       		.byte	-1
 7802 01b6 00       		.byte	0
 7803 01b7 01       		.byte	1
 7804 01b8 00       		.byte	0
 7805 01b9 03       		.byte	3
 7806 01ba 00       		.byte	0
 7807 01bb 70       		.byte	112
 7808 01bc 00       		.byte	0
 7809 01bd 70       		.byte	112
 7810 01be 00       		.byte	0
 7811 01bf C6       		.byte	-58
 7812 01c0 01       		.byte	1
 7813 01c1 01       		.byte	1
 7814 01c2 00       		.byte	0
 7815 01c3 00000000 		.space	5
 7815      00
 7816 01c8 00       		.byte	0
 7817 01c9 00       		.byte	0
 7818 01ca 02       		.byte	2
 7819 01cb 00       		.byte	0
 7820 01cc 00       		.byte	0
 7821 01cd 64       		.byte	100
 7822 01ce 00       		.byte	0
 7823 01cf 01       		.byte	1
 7824 01d0 00       		.byte	0
 7825 01d1 03       		.byte	3
 7826 01d2 00       		.byte	0
 7827 01d3 00       		.byte	0
 7828 01d4 00       		.byte	0
 7829 01d5 00       		.byte	0
 7830 01d6 00       		.byte	0
 7831 01d7 30       		.byte	48
 7832 01d8 01       		.byte	1
 7833 01d9 00       		.byte	0
 7834 01da 00       		.byte	0
 7835 01db 00000000 		.space	5
 7835      00
 7836 01e0 07       		.byte	7
 7837 01e1 07       		.byte	7
 7838 01e2 02       		.byte	2
 7839 01e3 00       		.byte	0
 7840 01e4 00       		.byte	0
 7841 01e5 01       		.byte	1
 7842 01e6 00       		.byte	0
 7843 01e7 01       		.byte	1
 7844 01e8 00       		.byte	0
 7845 01e9 03       		.byte	3
 7846 01ea 00       		.byte	0
 7847 01eb 01       		.byte	1
 7848 01ec 00       		.byte	0
 7849 01ed 01       		.byte	1
 7850 01ee 00       		.byte	0
 7851 01ef 30       		.byte	48
 7852 01f0 01       		.byte	1
 7853 01f1 00       		.byte	0
 7854 01f2 00       		.byte	0
 7855 01f3 00000000 		.space	5
 7855      00
 7856 01f8 DF       		.byte	-33
 7857 01f9 E1       		.byte	-31
 7858 01fa 02       		.byte	2
 7859 01fb 00       		.byte	0
 7860 01fc 00       		.byte	0
 7861 01fd FF       		.byte	-1
 7862 01fe 00       		.byte	0
 7863 01ff 01       		.byte	1
 7864 0200 00       		.byte	0
 7865 0201 03       		.byte	3
 7866 0202 00       		.byte	0
 7867 0203 80       		.byte	-128
 7868 0204 00       		.byte	0
 7869 0205 00       		.byte	0
 7870 0206 00       		.byte	0
 7871 0207 C6       		.byte	-58
 7872 0208 01       		.byte	1
 7873 0209 01       		.byte	1
 7874 020a 00       		.byte	0
 7875 020b 00000000 		.space	5
 7875      00
 7876 0210 85       		.byte	-123
 7877 0211 86       		.byte	-122
 7878 0212 02       		.byte	2
 7879 0213 00       		.byte	0
 7880 0214 00       		.byte	0
 7881 0215 64       		.byte	100
 7882 0216 00       		.byte	0
 7883 0217 01       		.byte	1
 7884 0218 00       		.byte	0
 7885 0219 03       		.byte	3
 7886 021a 00       		.byte	0
 7887 021b 32       		.byte	50
 7888 021c 00       		.byte	0
 7889 021d 32       		.byte	50
 7890 021e 00       		.byte	0
 7891 021f F2       		.byte	-14
 7892 0220 01       		.byte	1
 7893 0221 01       		.byte	1
 7894 0222 00       		.byte	0
 7895 0223 00000000 		.space	5
 7895      00
 7896 0228 06       		.byte	6
 7897 0229 06       		.byte	6
 7898 022a 02       		.byte	2
 7899 022b 00       		.byte	0
 7900 022c 00       		.byte	0
 7901 022d 40       		.byte	64
 7902 022e 00       		.byte	0
 7903 022f 01       		.byte	1
 7904 0230 00       		.byte	0
 7905 0231 03       		.byte	3
 7906 0232 00       		.byte	0
 7907 0233 20       		.byte	32
 7908 0234 00       		.byte	0
 7909 0235 20       		.byte	32
 7910 0236 00       		.byte	0
 7911 0237 30       		.byte	48
 7912 0238 01       		.byte	1
 7913 0239 01       		.byte	1
 7914 023a 00       		.byte	0
 7915 023b 00000000 		.space	5
 7915      00
 7916 0240 00       		.byte	0
 7917 0241 00       		.byte	0
 7918 0242 02       		.byte	2
 7919 0243 00       		.byte	0
 7920 0244 00       		.byte	0
 7921 0245 64       		.byte	100
 7922 0246 00       		.byte	0
 7923 0247 01       		.byte	1
 7924 0248 00       		.byte	0
 7925 0249 03       		.byte	3
 7926 024a 00       		.byte	0
 7927 024b 00       		.byte	0
 7928 024c 00       		.byte	0
 7929 024d 00       		.byte	0
 7930 024e 00       		.byte	0
 7931 024f 30       		.byte	48
 7932 0250 01       		.byte	1
 7933 0251 00       		.byte	0
 7934 0252 00       		.byte	0
 7935 0253 00000000 		.space	5
 7935      00
 7936 0258 08       		.byte	8
 7937 0259 08       		.byte	8
 7938 025a 02       		.byte	2
 7939 025b 00       		.byte	0
 7940 025c 00       		.byte	0
 7941 025d 05       		.byte	5
 7942 025e 00       		.byte	0
 7943 025f 01       		.byte	1
 7944 0260 00       		.byte	0
 7945 0261 03       		.byte	3
 7946 0262 00       		.byte	0
 7947 0263 00       		.byte	0
 7948 0264 00       		.byte	0
 7949 0265 00       		.byte	0
 7950 0266 00       		.byte	0
 7951 0267 30       		.byte	48
 7952 0268 01       		.byte	1
 7953 0269 00       		.byte	0
 7954 026a 00       		.byte	0
 7955 026b 00000000 		.space	5
 7955      00
 7956 0270 00       		.byte	0
 7957 0271 00       		.byte	0
 7958 0272 02       		.byte	2
 7959 0273 00       		.byte	0
 7960 0274 00       		.byte	0
 7961 0275 40       		.byte	64
 7962 0276 00       		.byte	0
 7963 0277 01       		.byte	1
 7964 0278 00       		.byte	0
 7965 0279 03       		.byte	3
 7966 027a 00       		.byte	0
 7967 027b 00       		.byte	0
 7968 027c 00       		.byte	0
 7969 027d 00       		.byte	0
 7970 027e 00       		.byte	0
 7971 027f 30       		.byte	48
 7972 0280 01       		.byte	1
 7973 0281 00       		.byte	0
 7974 0282 00       		.byte	0
 7975 0283 00000000 		.space	5
 7975      00
 7976 0288 09       		.byte	9
 7977 0289 0A       		.byte	10
 7978 028a 04       		.byte	4
 7979 028b 00       		.byte	0
 7980 028c 00       		.byte	0
 7981 028d 40       		.byte	64
 7982 028e 00       		.byte	0
 7983 028f 01       		.byte	1
 7984 0290 00       		.byte	0
 7985 0291 03       		.byte	3
 7986 0292 00       		.byte	0
 7987 0293 20       		.byte	32
 7988 0294 38       		.byte	56
 7989 0295 20       		.byte	32
 7990 0296 38       		.byte	56
 7991 0297 30       		.byte	48
 7992 0298 01       		.byte	1
 7993 0299 00       		.byte	0
 7994 029a 00       		.byte	0
 7995 029b 00000000 		.space	5
 7995      00
 7996 02a0 00       		.byte	0
 7997 02a1 00       		.byte	0
 7998 02a2 02       		.byte	2
 7999 02a3 00       		.byte	0
 8000 02a4 00       		.byte	0
 8001 02a5 64       		.byte	100
 8002 02a6 00       		.byte	0
 8003 02a7 01       		.byte	1
 8004 02a8 00       		.byte	0
 8005 02a9 03       		.byte	3
 8006 02aa 00       		.byte	0
 8007 02ab 00       		.byte	0
 8008 02ac 00       		.byte	0
 8009 02ad 00       		.byte	0
 8010 02ae 00       		.byte	0
 8011 02af 30       		.byte	48
 8012 02b0 01       		.byte	1
 8013 02b1 00       		.byte	0
 8014 02b2 00       		.byte	0
 8015 02b3 00000000 		.space	5
 8015      00
 8016 02b8 00       		.byte	0
 8017 02b9 00       		.byte	0
 8018 02ba 02       		.byte	2
 8019 02bb 00       		.byte	0
 8020 02bc 00       		.byte	0
 8021 02bd 64       		.byte	100
 8022 02be 00       		.byte	0
 8023 02bf 01       		.byte	1
 8024 02c0 00       		.byte	0
 8025 02c1 03       		.byte	3
 8026 02c2 00       		.byte	0
 8027 02c3 00       		.byte	0
 8028 02c4 00       		.byte	0
 8029 02c5 00       		.byte	0
 8030 02c6 00       		.byte	0
 8031 02c7 30       		.byte	48
 8032 02c8 01       		.byte	1
 8033 02c9 00       		.byte	0
 8034 02ca 00       		.byte	0
 8035 02cb 00000000 		.space	5
 8035      00
 8036 02d0 2A       		.byte	42
 8037 02d1 2A       		.byte	42
 8038 02d2 02       		.byte	2
 8039 02d3 00       		.byte	0
 8040 02d4 00       		.byte	0
 8041 02d5 1B       		.byte	27
 8042 02d6 00       		.byte	0
 8043 02d7 01       		.byte	1
 8044 02d8 00       		.byte	0
 8045 02d9 03       		.byte	3
 8046 02da 00       		.byte	0
 8047 02db 00       		.byte	0
 8048 02dc 00       		.byte	0
 8049 02dd 00       		.byte	0
 8050 02de 00       		.byte	0
 8051 02df 30       		.byte	48
 8052 02e0 01       		.byte	1
 8053 02e1 00       		.byte	0
 8054 02e2 00       		.byte	0
 8055 02e3 00000000 		.space	5
 8055      00
 8056 02e8 00       		.byte	0
 8057 02e9 00       		.byte	0
 8058 02ea 02       		.byte	2
 8059 02eb 00       		.byte	0
 8060 02ec 00       		.byte	0
 8061 02ed 64       		.byte	100
 8062 02ee 00       		.byte	0
 8063 02ef 01       		.byte	1
 8064 02f0 00       		.byte	0
 8065 02f1 03       		.byte	3
 8066 02f2 00       		.byte	0
 8067 02f3 00       		.byte	0
 8068 02f4 00       		.byte	0
 8069 02f5 00       		.byte	0
 8070 02f6 00       		.byte	0
 8071 02f7 30       		.byte	48
 8072 02f8 01       		.byte	1
 8073 02f9 00       		.byte	0
 8074 02fa 00       		.byte	0
 8075 02fb 00000000 		.space	5
 8075      00
 8076 0300 00       		.byte	0
 8077 0301 00       		.byte	0
 8078 0302 02       		.byte	2
 8079 0303 00       		.byte	0
 8080 0304 00       		.byte	0
 8081 0305 12       		.byte	18
 8082 0306 00       		.byte	0
 8083 0307 01       		.byte	1
 8084 0308 00       		.byte	0
 8085 0309 03       		.byte	3
 8086 030a 00       		.byte	0
 8087 030b 00       		.byte	0
 8088 030c 00       		.byte	0
 8089 030d 00       		.byte	0
 8090 030e 00       		.byte	0
 8091 030f 30       		.byte	48
 8092 0310 01       		.byte	1
 8093 0311 00       		.byte	0
 8094 0312 00       		.byte	0
 8095 0313 00000000 		.space	5
 8095      00
 8096 0318 01       		.byte	1
 8097 0319 01       		.byte	1
 8098 031a 02       		.byte	2
 8099 031b 00       		.byte	0
 8100 031c 00       		.byte	0
 8101 031d 09       		.byte	9
 8102 031e 00       		.byte	0
 8103 031f 01       		.byte	1
 8104 0320 00       		.byte	0
 8105 0321 03       		.byte	3
 8106 0322 00       		.byte	0
 8107 0323 00       		.byte	0
 8108 0324 00       		.byte	0
 8109 0325 01       		.byte	1
 8110 0326 00       		.byte	0
 8111 0327 30       		.byte	48
 8112 0328 01       		.byte	1
 8113 0329 00       		.byte	0
 8114 032a 00       		.byte	0
 8115 032b 00000000 		.space	5
 8115      00
 8116 0330 05       		.byte	5
 8117 0331 05       		.byte	5
 8118 0332 02       		.byte	2
 8119 0333 00       		.byte	0
 8120 0334 00       		.byte	0
 8121 0335 03       		.byte	3
 8122 0336 00       		.byte	0
 8123 0337 01       		.byte	1
 8124 0338 00       		.byte	0
 8125 0339 03       		.byte	3
 8126 033a 00       		.byte	0
 8127 033b 00       		.byte	0
 8128 033c 00       		.byte	0
 8129 033d 02       		.byte	2
 8130 033e 00       		.byte	0
 8131 033f 30       		.byte	48
 8132 0340 01       		.byte	1
 8133 0341 00       		.byte	0
 8134 0342 00       		.byte	0
 8135 0343 00000000 		.space	5
 8135      00
 8136 0348 18       		.byte	24
 8137 0349 18       		.byte	24
 8138 034a 02       		.byte	2
 8139 034b 00       		.byte	0
 8140 034c 00       		.byte	0
 8141 034d 01       		.byte	1
 8142 034e 00       		.byte	0
 8143 034f 01       		.byte	1
 8144 0350 00       		.byte	0
 8145 0351 03       		.byte	3
 8146 0352 00       		.byte	0
 8147 0353 00       		.byte	0
 8148 0354 00       		.byte	0
 8149 0355 00       		.byte	0
 8150 0356 00       		.byte	0
 8151 0357 30       		.byte	48
 8152 0358 01       		.byte	1
 8153 0359 00       		.byte	0
 8154 035a 00       		.byte	0
 8155 035b 00000000 		.space	5
 8155      00
 8156 0360 19       		.byte	25
 8157 0361 19       		.byte	25
 8158 0362 01       		.byte	1
 8159 0363 00       		.byte	0
 8160 0364 00       		.byte	0
 8161 0365 40       		.byte	64
 8162 0366 00       		.byte	0
 8163 0367 01       		.byte	1
 8164 0368 00       		.byte	0
 8165 0369 03       		.byte	3
 8166 036a 00       		.byte	0
 8167 036b 20       		.byte	32
 8168 036c 00       		.byte	0
 8169 036d 20       		.byte	32
 8170 036e 00       		.byte	0
 8171 036f 30       		.byte	48
 8172 0370 01       		.byte	1
 8173 0371 00       		.byte	0
 8174 0372 00       		.byte	0
 8175 0373 00000000 		.space	5
 8175      00
 8176 0378 20       		.byte	32
 8177 0379 20       		.byte	32
 8178 037a 02       		.byte	2
 8179 037b 00       		.byte	0
 8180 037c 00       		.byte	0
 8181 037d 02       		.byte	2
 8182 037e 00       		.byte	0
 8183 037f 01       		.byte	1
 8184 0380 00       		.byte	0
 8185 0381 03       		.byte	3
 8186 0382 00       		.byte	0
 8187 0383 00       		.byte	0
 8188 0384 00       		.byte	0
 8189 0385 00       		.byte	0
 8190 0386 00       		.byte	0
 8191 0387 30       		.byte	48
 8192 0388 01       		.byte	1
 8193 0389 00       		.byte	0
 8194 038a 00       		.byte	0
 8195 038b 00000000 		.space	5
 8195      00
 8196 0390 22       		.byte	34
 8197 0391 22       		.byte	34
 8198 0392 02       		.byte	2
 8199 0393 00       		.byte	0
 8200 0394 00       		.byte	0
 8201 0395 3F       		.byte	63
 8202 0396 00       		.byte	0
 8203 0397 01       		.byte	1
 8204 0398 00       		.byte	0
 8205 0399 03       		.byte	3
 8206 039a 00       		.byte	0
 8207 039b 00       		.byte	0
 8208 039c 00       		.byte	0
 8209 039d 00       		.byte	0
 8210 039e 00       		.byte	0
 8211 039f 30       		.byte	48
 8212 03a0 01       		.byte	1
 8213 03a1 00       		.byte	0
 8214 03a2 00       		.byte	0
 8215 03a3 00000000 		.space	5
 8215      00
 8216 03a8 23       		.byte	35
 8217 03a9 23       		.byte	35
 8218 03aa 02       		.byte	2
 8219 03ab 00       		.byte	0
 8220 03ac 00       		.byte	0
 8221 03ad 64       		.byte	100
 8222 03ae 00       		.byte	0
 8223 03af 01       		.byte	1
 8224 03b0 00       		.byte	0
 8225 03b1 03       		.byte	3
 8226 03b2 00       		.byte	0
 8227 03b3 10       		.byte	16
 8228 03b4 00       		.byte	0
 8229 03b5 10       		.byte	16
 8230 03b6 00       		.byte	0
 8231 03b7 30       		.byte	48
 8232 03b8 01       		.byte	1
 8233 03b9 00       		.byte	0
 8234 03ba 00       		.byte	0
 8235 03bb 00000000 		.space	5
 8235      00
 8236 03c0 24       		.byte	36
 8237 03c1 24       		.byte	36
 8238 03c2 02       		.byte	2
 8239 03c3 00       		.byte	0
 8240 03c4 00       		.byte	0
 8241 03c5 64       		.byte	100
 8242 03c6 00       		.byte	0
 8243 03c7 01       		.byte	1
 8244 03c8 00       		.byte	0
 8245 03c9 03       		.byte	3
 8246 03ca 00       		.byte	0
 8247 03cb 10       		.byte	16
 8248 03cc 00       		.byte	0
 8249 03cd 10       		.byte	16
 8250 03ce 00       		.byte	0
 8251 03cf 30       		.byte	48
 8252 03d0 01       		.byte	1
 8253 03d1 00       		.byte	0
 8254 03d2 00       		.byte	0
 8255 03d3 00000000 		.space	5
 8255      00
 8256 03d8 02       		.byte	2
 8257 03d9 03       		.byte	3
 8258 03da 04       		.byte	4
 8259 03db 00       		.byte	0
 8260 03dc 00       		.byte	0
 8261 03dd 7F       		.byte	127
 8262 03de 00       		.byte	0
 8263 03df 01       		.byte	1
 8264 03e0 00       		.byte	0
 8265 03e1 03       		.byte	3
 8266 03e2 00       		.byte	0
 8267 03e3 00       		.byte	0
 8268 03e4 20       		.byte	32
 8269 03e5 00       		.byte	0
 8270 03e6 20       		.byte	32
 8271 03e7 30       		.byte	48
 8272 03e8 01       		.byte	1
 8273 03e9 00       		.byte	0
 8274 03ea 00       		.byte	0
 8275 03eb 00000000 		.space	5
 8275      00
 8276 03f0 04       		.byte	4
 8277 03f1 04       		.byte	4
 8278 03f2 02       		.byte	2
 8279 03f3 00       		.byte	0
 8280 03f4 00       		.byte	0
 8281 03f5 40       		.byte	64
 8282 03f6 00       		.byte	0
 8283 03f7 01       		.byte	1
 8284 03f8 00       		.byte	0
 8285 03f9 03       		.byte	3
 8286 03fa 00       		.byte	0
 8287 03fb 20       		.byte	32
 8288 03fc 00       		.byte	0
 8289 03fd 20       		.byte	32
 8290 03fe 00       		.byte	0
 8291 03ff 30       		.byte	48
 8292 0400 01       		.byte	1
 8293 0401 00       		.byte	0
 8294 0402 00       		.byte	0
 8295 0403 00000000 		.space	5
 8295      00
 8296 0408 00       		.byte	0
 8297 0409 00       		.byte	0
 8298 040a 02       		.byte	2
 8299 040b 00       		.byte	0
 8300 040c 00       		.byte	0
 8301 040d 19       		.byte	25
 8302 040e 00       		.byte	0
 8303 040f 01       		.byte	1
 8304 0410 00       		.byte	0
 8305 0411 03       		.byte	3
 8306 0412 00       		.byte	0
 8307 0413 00       		.byte	0
 8308 0414 00       		.byte	0
 8309 0415 00       		.byte	0
 8310 0416 00       		.byte	0
 8311 0417 30       		.byte	48
 8312 0418 01       		.byte	1
 8313 0419 00       		.byte	0
 8314 041a 00       		.byte	0
 8315 041b 00000000 		.space	5
 8315      00
 8316 0420 10       		.byte	16
 8317 0421 10       		.byte	16
 8318 0422 02       		.byte	2
 8319 0423 00       		.byte	0
 8320 0424 00       		.byte	0
 8321 0425 06       		.byte	6
 8322 0426 00       		.byte	0
 8323 0427 01       		.byte	1
 8324 0428 00       		.byte	0
 8325 0429 03       		.byte	3
 8326 042a 00       		.byte	0
 8327 042b 03       		.byte	3
 8328 042c 00       		.byte	0
 8329 042d 03       		.byte	3
 8330 042e 00       		.byte	0
 8331 042f 30       		.byte	48
 8332 0430 01       		.byte	1
 8333 0431 00       		.byte	0
 8334 0432 00       		.byte	0
 8335 0433 00000000 		.space	5
 8335      00
 8336 0438 00       		.byte	0
 8337 0439 00       		.byte	0
 8338 043a 02       		.byte	2
 8339 043b 00       		.byte	0
 8340 043c 00       		.byte	0
 8341 043d 03       		.byte	3
 8342 043e 00       		.byte	0
 8343 043f 01       		.byte	1
 8344 0440 00       		.byte	0
 8345 0441 03       		.byte	3
 8346 0442 00       		.byte	0
 8347 0443 00       		.byte	0
 8348 0444 00       		.byte	0
 8349 0445 00       		.byte	0
 8350 0446 00       		.byte	0
 8351 0447 30       		.byte	48
 8352 0448 01       		.byte	1
 8353 0449 00       		.byte	0
 8354 044a 00       		.byte	0
 8355 044b 00000000 		.space	5
 8355      00
 8356 0450 50       		.byte	80
 8357 0451 50       		.byte	80
 8358 0452 01       		.byte	1
 8359 0453 00       		.byte	0
 8360 0454 00       		.byte	0
 8361 0455 03       		.byte	3
 8362 0456 00       		.byte	0
 8363 0457 01       		.byte	1
 8364 0458 00       		.byte	0
 8365 0459 03       		.byte	3
 8366 045a 00       		.byte	0
 8367 045b 00       		.byte	0
 8368 045c 00       		.byte	0
 8369 045d 00       		.byte	0
 8370 045e 00       		.byte	0
 8371 045f 30       		.byte	48
 8372 0460 01       		.byte	1
 8373 0461 00       		.byte	0
 8374 0462 00       		.byte	0
 8375 0463 00000000 		.space	5
 8375      00
 8376 0468 00       		.byte	0
 8377 0469 00       		.byte	0
 8378 046a 0B       		.byte	11
 8379 046b 00       		.byte	0
 8380 046c 00       		.byte	0
 8381 046d FF       		.byte	-1
 8382 046e FF       		.byte	-1
 8383 046f 01       		.byte	1
 8384 0470 00       		.byte	0
 8385 0471 03       		.byte	3
 8386 0472 00       		.byte	0
 8387 0473 00       		.byte	0
 8388 0474 00       		.byte	0
 8389 0475 00       		.byte	0
 8390 0476 00       		.byte	0
 8391 0477 00       		.byte	0
 8392 0478 01       		.byte	1
 8393 0479 00       		.byte	0
 8394 047a 00       		.byte	0
 8395 047b 00000000 		.space	5
 8395      00
 8398              	glUVCHeader:
 8399 0480 0C       		.byte	12
 8400 0481 8C       		.byte	-116
 8401 0482 00       		.byte	0
 8402 0483 00       		.byte	0
 8403 0484 00       		.byte	0
 8404 0485 00       		.byte	0
 8405 0486 00       		.byte	0
 8406 0487 00       		.byte	0
 8407 0488 00       		.byte	0
 8408 0489 00       		.byte	0
 8409 048a 00       		.byte	0
 8410 048b 00       		.byte	0
 8413              	WBMenuCmpArry:
 8414 048c 20       		.byte	32
 8415 048d 0F       		.byte	15
 8416 048e 38       		.byte	56
 8417 048f F0       		.byte	-16
 8420              	CTCtrlParArry:
 8421 0490 00       		.byte	0
 8422 0491 00       		.byte	0
 8423 0492 01       		.byte	1
 8424 0493 00       		.byte	0
 8425 0494 00       		.byte	0
 8426 0495 03       		.byte	3
 8427 0496 00       		.byte	0
 8428 0497 01       		.byte	1
 8429 0498 00       		.byte	0
 8430 0499 03       		.byte	3
 8431 049a 00       		.byte	0
 8432 049b 03       		.byte	3
 8433 049c 00       		.byte	0
 8434 049d 03       		.byte	3
 8435 049e 00       		.byte	0
 8436 049f 30       		.byte	48
 8437 04a0 01       		.byte	1
 8438 04a1 00       		.byte	0
 8439 04a2 00       		.byte	0
 8440 04a3 00000000 		.space	5
 8440      00
 8441 04a8 00       		.byte	0
 8442 04a9 00       		.byte	0
 8443 04aa 01       		.byte	1
 8444 04ab 01       		.byte	1
 8445 04ac 00       		.byte	0
 8446 04ad 0F       		.byte	15
 8447 04ae 00       		.byte	0
 8448 04af 0F       		.byte	15
 8449 04b0 00       		.byte	0
 8450 04b1 03       		.byte	3
 8451 04b2 00       		.byte	0
 8452 04b3 02       		.byte	2
 8453 04b4 00       		.byte	0
 8454 04b5 02       		.byte	2
 8455 04b6 00       		.byte	0
 8456 04b7 30       		.byte	48
 8457 04b8 01       		.byte	1
 8458 04b9 01       		.byte	1
 8459 04ba 00       		.byte	0
 8460 04bb 00000000 		.space	5
 8460      00
 8461 04c0 02       		.byte	2
 8462 04c1 00       		.byte	0
 8463 04c2 01       		.byte	1
 8464 04c3 00       		.byte	0
 8465 04c4 00       		.byte	0
 8466 04c5 01       		.byte	1
 8467 04c6 00       		.byte	0
 8468 04c7 01       		.byte	1
 8469 04c8 00       		.byte	0
 8470 04c9 03       		.byte	3
 8471 04ca 00       		.byte	0
 8472 04cb 00       		.byte	0
 8473 04cc 00       		.byte	0
 8474 04cd 00       		.byte	0
 8475 04ce 00       		.byte	0
 8476 04cf 30       		.byte	48
 8477 04d0 01       		.byte	1
 8478 04d1 01       		.byte	1
 8479 04d2 00       		.byte	0
 8480 04d3 00000000 		.space	5
 8480      00
 8481 04d8 00       		.byte	0
 8482 04d9 00       		.byte	0
 8483 04da 04       		.byte	4
 8484 04db 01       		.byte	1
 8485 04dc 00       		.byte	0
 8486 04dd 38       		.byte	56
 8487 04de 01       		.byte	1
 8488 04df 01       		.byte	1
 8489 04e0 00       		.byte	0
 8490 04e1 03       		.byte	3
 8491 04e2 00       		.byte	0
 8492 04e3 4E       		.byte	78
 8493 04e4 00       		.byte	0
 8494 04e5 4E       		.byte	78
 8495 04e6 00       		.byte	0
 8496 04e7 30       		.byte	48
 8497 04e8 01       		.byte	1
 8498 04e9 00       		.byte	0
 8499 04ea 00       		.byte	0
 8500 04eb 00000000 		.space	5
 8500      00
 8501 04f0 04       		.byte	4
 8502 04f1 00       		.byte	0
 8503 04f2 01       		.byte	1
 8504 04f3 00       		.byte	0
 8505 04f4 00       		.byte	0
 8506 04f5 00       		.byte	0
 8507 04f6 00       		.byte	0
 8508 04f7 01       		.byte	1
 8509 04f8 00       		.byte	0
 8510 04f9 03       		.byte	3
 8511 04fa 00       		.byte	0
 8512 04fb 00       		.byte	0
 8513 04fc 00       		.byte	0
 8514 04fd 00       		.byte	0
 8515 04fe 00       		.byte	0
 8516 04ff 30       		.byte	48
 8517 0500 01       		.byte	1
 8518 0501 00       		.byte	0
 8519 0502 00       		.byte	0
 8520 0503 00000000 		.space	5
 8520      00
 8521 0508 05       		.byte	5
 8522 0509 00       		.byte	0
 8523 050a 02       		.byte	2
 8524 050b 00       		.byte	0
 8525 050c 00       		.byte	0
 8526 050d FF       		.byte	-1
 8527 050e 00       		.byte	0
 8528 050f 01       		.byte	1
 8529 0510 00       		.byte	0
 8530 0511 03       		.byte	3
 8531 0512 00       		.byte	0
 8532 0513 01       		.byte	1
 8533 0514 00       		.byte	0
 8534 0515 00       		.byte	0
 8535 0516 00       		.byte	0
 8536 0517 30       		.byte	48
 8537 0518 01       		.byte	1
 8538 0519 01       		.byte	1
 8539 051a 00       		.byte	0
 8540 051b 00000000 		.space	5
 8540      00
 8541 0520 06       		.byte	6
 8542 0521 00       		.byte	0
 8543 0522 02       		.byte	2
 8544 0523 00       		.byte	0
 8545 0524 00       		.byte	0
 8546 0525 00       		.byte	0
 8547 0526 00       		.byte	0
 8548 0527 00       		.byte	0
 8549 0528 00       		.byte	0
 8550 0529 03       		.byte	3
 8551 052a 00       		.byte	0
 8552 052b 00       		.byte	0
 8553 052c 00       		.byte	0
 8554 052d 00       		.byte	0
 8555 052e 00       		.byte	0
 8556 052f 30       		.byte	48
 8557 0530 01       		.byte	1
 8558 0531 01       		.byte	1
 8559 0532 00       		.byte	0
 8560 0533 00000000 		.space	5
 8560      00
 8561 0538 23       		.byte	35
 8562 0539 00       		.byte	0
 8563 053a 02       		.byte	2
 8564 053b 00       		.byte	0
 8565 053c 00       		.byte	0
 8566 053d 30       		.byte	48
 8567 053e 00       		.byte	0
 8568 053f 01       		.byte	1
 8569 0540 00       		.byte	0
 8570 0541 03       		.byte	3
 8571 0542 0A       		.byte	10
 8572 0543 00       		.byte	0
 8573 0544 00       		.byte	0
 8574 0545 0A       		.byte	10
 8575 0546 00       		.byte	0
 8576 0547 30       		.byte	48
 8577 0548 01       		.byte	1
 8578 0549 01       		.byte	1
 8579 054a 00       		.byte	0
 8580 054b 00000000 		.space	5
 8580      00
 8581 0550 08       		.byte	8
 8582 0551 00       		.byte	0
 8583 0552 01       		.byte	1
 8584 0553 00       		.byte	0
 8585 0554 00       		.byte	0
 8586 0555 7F       		.byte	127
 8587 0556 00       		.byte	0
 8588 0557 01       		.byte	1
 8589 0558 00       		.byte	0
 8590 0559 03       		.byte	3
 8591 055a 00       		.byte	0
 8592 055b 00       		.byte	0
 8593 055c 00       		.byte	0
 8594 055d 00       		.byte	0
 8595 055e 00       		.byte	0
 8596 055f 30       		.byte	48
 8597 0560 01       		.byte	1
 8598 0561 00       		.byte	0
 8599 0562 00       		.byte	0
 8600 0563 00000000 		.space	5
 8600      00
 8601 0568 09       		.byte	9
 8602 0569 00       		.byte	0
 8603 056a 02       		.byte	2
 8604 056b 00       		.byte	0
 8605 056c 00       		.byte	0
 8606 056d 05       		.byte	5
 8607 056e 00       		.byte	0
 8608 056f 01       		.byte	1
 8609 0570 00       		.byte	0
 8610 0571 03       		.byte	3
 8611 0572 00       		.byte	0
 8612 0573 00       		.byte	0
 8613 0574 00       		.byte	0
 8614 0575 00       		.byte	0
 8615 0576 00       		.byte	0
 8616 0577 30       		.byte	48
 8617 0578 01       		.byte	1
 8618 0579 00       		.byte	0
 8619 057a 00       		.byte	0
 8620 057b 00000000 		.space	5
 8620      00
 8621 0580 10       		.byte	16
 8622 0581 00       		.byte	0
 8623 0582 03       		.byte	3
 8624 0583 00       		.byte	0
 8625 0584 00       		.byte	0
 8626 0585 00       		.byte	0
 8627 0586 00       		.byte	0
 8628 0587 00       		.byte	0
 8629 0588 00       		.byte	0
 8630 0589 03       		.byte	3
 8631 058a 00       		.byte	0
 8632 058b 00       		.byte	0
 8633 058c 00       		.byte	0
 8634 058d 00       		.byte	0
 8635 058e 00       		.byte	0
 8636 058f 30       		.byte	48
 8637 0590 01       		.byte	1
 8638 0591 00       		.byte	0
 8639 0592 00       		.byte	0
 8640 0593 00000000 		.space	5
 8640      00
 8641 0598 00       		.byte	0
 8642 0599 00       		.byte	0
 8643 059a 02       		.byte	2
 8644 059b 00       		.byte	0
 8645 059c 00       		.byte	0
 8646 059d 40       		.byte	64
 8647 059e 00       		.byte	0
 8648 059f 01       		.byte	1
 8649 05a0 00       		.byte	0
 8650 05a1 03       		.byte	3
 8651 05a2 00       		.byte	0
 8652 05a3 0F       		.byte	15
 8653 05a4 11       		.byte	17
 8654 05a5 00       		.byte	0
 8655 05a6 00       		.byte	0
 8656 05a7 30       		.byte	48
 8657 05a8 01       		.byte	1
 8658 05a9 00       		.byte	0
 8659 05aa 00       		.byte	0
 8660 05ab 00000000 		.space	5
 8660      00
 8661 05b0 00       		.byte	0
 8662 05b1 00       		.byte	0
 8663 05b2 02       		.byte	2
 8664 05b3 00       		.byte	0
 8665 05b4 00       		.byte	0
 8666 05b5 64       		.byte	100
 8667 05b6 00       		.byte	0
 8668 05b7 01       		.byte	1
 8669 05b8 00       		.byte	0
 8670 05b9 03       		.byte	3
 8671 05ba 00       		.byte	0
 8672 05bb 00       		.byte	0
 8673 05bc 00       		.byte	0
 8674 05bd 00       		.byte	0
 8675 05be 00       		.byte	0
 8676 05bf 30       		.byte	48
 8677 05c0 01       		.byte	1
 8678 05c1 00       		.byte	0
 8679 05c2 00       		.byte	0
 8680 05c3 00000000 		.space	5
 8680      00
 8681 05c8 00       		.byte	0
 8682 05c9 00       		.byte	0
 8683 05ca 02       		.byte	2
 8684 05cb 00       		.byte	0
 8685 05cc 00       		.byte	0
 8686 05cd 64       		.byte	100
 8687 05ce 00       		.byte	0
 8688 05cf 01       		.byte	1
 8689 05d0 00       		.byte	0
 8690 05d1 03       		.byte	3
 8691 05d2 00       		.byte	0
 8692 05d3 00       		.byte	0
 8693 05d4 00       		.byte	0
 8694 05d5 00       		.byte	0
 8695 05d6 00       		.byte	0
 8696 05d7 30       		.byte	48
 8697 05d8 01       		.byte	1
 8698 05d9 00       		.byte	0
 8699 05da 00       		.byte	0
 8700 05db 00000000 		.space	5
 8700      00
 8701 05e0 00       		.byte	0
 8702 05e1 00       		.byte	0
 8703 05e2 02       		.byte	2
 8704 05e3 00       		.byte	0
 8705 05e4 00       		.byte	0
 8706 05e5 64       		.byte	100
 8707 05e6 00       		.byte	0
 8708 05e7 01       		.byte	1
 8709 05e8 00       		.byte	0
 8710 05e9 03       		.byte	3
 8711 05ea 00       		.byte	0
 8712 05eb 00       		.byte	0
 8713 05ec 00       		.byte	0
 8714 05ed 00       		.byte	0
 8715 05ee 00       		.byte	0
 8716 05ef 30       		.byte	48
 8717 05f0 01       		.byte	1
 8718 05f1 00       		.byte	0
 8719 05f2 00       		.byte	0
 8720 05f3 00000000 		.space	5
 8720      00
 8721 05f8 00       		.byte	0
 8722 05f9 00       		.byte	0
 8723 05fa 02       		.byte	2
 8724 05fb 00       		.byte	0
 8725 05fc 00       		.byte	0
 8726 05fd 64       		.byte	100
 8727 05fe 00       		.byte	0
 8728 05ff 01       		.byte	1
 8729 0600 00       		.byte	0
 8730 0601 03       		.byte	3
 8731 0602 00       		.byte	0
 8732 0603 00       		.byte	0
 8733 0604 00       		.byte	0
 8734 0605 00       		.byte	0
 8735 0606 00       		.byte	0
 8736 0607 30       		.byte	48
 8737 0608 01       		.byte	1
 8738 0609 00       		.byte	0
 8739 060a 00       		.byte	0
 8740 060b 00000000 		.space	5
 8740      00
 8743              	glProbeCtrlFull:
 8744 0610 00       		.byte	0
 8745 0611 00       		.byte	0
 8746 0612 01       		.byte	1
 8747 0613 01       		.byte	1
 8748 0614 15       		.byte	21
 8749 0615 16       		.byte	22
 8750 0616 05       		.byte	5
 8751 0617 00       		.byte	0
 8752 0618 00       		.byte	0
 8753 0619 00       		.byte	0
 8754 061a 00       		.byte	0
 8755 061b 00       		.byte	0
 8756 061c 00       		.byte	0
 8757 061d 00       		.byte	0
 8758 061e 00       		.byte	0
 8759 061f 00       		.byte	0
 8760 0620 00       		.byte	0
 8761 0621 00       		.byte	0
 8762 0622 00       		.byte	0
 8763 0623 C6       		.byte	-58
 8764 0624 99       		.byte	-103
 8765 0625 00       		.byte	0
 8766 0626 00       		.byte	0
 8767 0627 40       		.byte	64
 8768 0628 00       		.byte	0
 8769 0629 00       		.byte	0
 8770 062a 0000     		.space	2
 8773              	glProbeCtrl20:
 8774 062c 00       		.byte	0
 8775 062d 00       		.byte	0
 8776 062e 01       		.byte	1
 8777 062f 01       		.byte	1
 8778 0630 80       		.byte	-128
 8779 0631 1A       		.byte	26
 8780 0632 06       		.byte	6
 8781 0633 00       		.byte	0
 8782 0634 00       		.byte	0
 8783 0635 00       		.byte	0
 8784 0636 00       		.byte	0
 8785 0637 00       		.byte	0
 8786 0638 00       		.byte	0
 8787 0639 00       		.byte	0
 8788 063a 00       		.byte	0
 8789 063b 00       		.byte	0
 8790 063c 00       		.byte	0
 8791 063d 00       		.byte	0
 8792 063e 00       		.byte	0
 8793 063f D2       		.byte	-46
 8794 0640 0F       		.byte	15
 8795 0641 00       		.byte	0
 8796 0642 00       		.byte	0
 8797 0643 40       		.byte	64
 8798 0644 00       		.byte	0
 8799 0645 00       		.byte	0
 8800 0646 0000     		.space	2
 8803              	glProbeCtrl:
 8804 0648 00       		.byte	0
 8805 0649 00       		.byte	0
 8806 064a 01       		.byte	1
 8807 064b 01       		.byte	1
 8808 064c 15       		.byte	21
 8809 064d 16       		.byte	22
 8810 064e 05       		.byte	5
 8811 064f 00       		.byte	0
 8812 0650 00       		.byte	0
 8813 0651 00       		.byte	0
 8814 0652 00       		.byte	0
 8815 0653 00       		.byte	0
 8816 0654 00       		.byte	0
 8817 0655 00       		.byte	0
 8818 0656 00       		.byte	0
 8819 0657 00       		.byte	0
 8820 0658 00       		.byte	0
 8821 0659 00       		.byte	0
 8822 065a 00       		.byte	0
 8823 065b 48       		.byte	72
 8824 065c 3F       		.byte	63
 8825 065d 00       		.byte	0
 8826 065e 00       		.byte	0
 8827 065f 40       		.byte	64
 8828 0660 00       		.byte	0
 8829 0661 00       		.byte	0
 8830 0662 0000     		.space	2
 8833              	glProbeStilCtrl:
 8834 0664 01       		.byte	1
 8835 0665 02       		.byte	2
 8836 0666 00       		.byte	0
 8837 0667 00       		.byte	0
 8838 0668 C6       		.byte	-58
 8839 0669 99       		.byte	-103
 8840 066a 00       		.byte	0
 8841 066b 00       		.byte	0
 8842 066c 40       		.byte	64
 8843 066d 00       		.byte	0
 8844 066e 00       		.byte	0
 8845 066f 00       		.space	1
 8848              	glProbeStilCtrl20:
 8849 0670 01       		.byte	1
 8850 0671 01       		.byte	1
 8851 0672 00       		.byte	0
 8852 0673 00       		.byte	0
 8853 0674 D2       		.byte	-46
 8854 0675 0F       		.byte	15
 8855 0676 00       		.byte	0
 8856 0677 00       		.byte	0
 8857 0678 40       		.byte	64
 8858 0679 00       		.byte	0
 8859 067a 00       		.byte	0
 8862              	snapButFlag:
 8863 067b 01       		.byte	1
 8866              	CyFxGpifTransition:
 8867 067c 0000     		.short	0
 8868 067e 5555     		.short	21845
 8869 0680 8888     		.short	-30584
 8870 0682 AAAA     		.short	-21846
 8871 0684 3333     		.short	13107
 8872 0686 0000     		.space	2
 8875              	CyFxGpifWavedata:
 8876 0688 0181731E 		.word	510886145
 8877 068c 00000000 		.word	0
 8878 0690 00000080 		.word	-2147483648
 8879 0694 00000000 		.word	0
 8880 0698 00000000 		.word	0
 8881 069c 00000000 		.word	0
 8882 06a0 0201702E 		.word	779092226
 8883 06a4 00010000 		.word	256
 8884 06a8 A0000080 		.word	-2147483488
 8885 06ac 00000000 		.word	0
 8886 06b0 00000000 		.word	0
 8887 06b4 00000000 		.word	0
 8888 06b8 0380722E 		.word	779255811
 8889 06bc 02010020 		.word	536871170
 8890 06c0 60000080 		.word	-2147483552
 8891 06c4 00000000 		.word	0
 8892 06c8 00000000 		.word	0
 8893 06cc 00000000 		.word	0
 8894 06d0 0460722E 		.word	779247620
 8895 06d4 02010024 		.word	603980034
 8896 06d8 90000080 		.word	-2147483504
 8897 06dc 0594731E 		.word	510891013
 8898 06e0 06000000 		.word	6
 8899 06e4 00000080 		.word	-2147483648
 8900 06e8 0380722E 		.word	779255811
 8901 06ec 02010020 		.word	536871170
 8902 06f0 60000080 		.word	-2147483552
 8903 06f4 0693731E 		.word	510890758
 8904 06f8 06000000 		.word	6
 8905 06fc 00000080 		.word	-2147483648
 8906 0700 0720703E 		.word	1047535623
 8907 0704 08010000 		.word	264
 8908 0708 00000080 		.word	-2147483648
 8909 070c 0820703E 		.word	1047535624
 8910 0710 08010000 		.word	264
 8911 0714 00000080 		.word	-2147483648
 8912 0718 0920703E 		.word	1047535625
 8913 071c 08010000 		.word	264
 8914 0720 00000080 		.word	-2147483648
 8915 0724 0A20703E 		.word	1047535626
 8916 0728 08010000 		.word	264
 8917 072c 00000080 		.word	-2147483648
 8918 0730 0380722E 		.word	779255811
 8919 0734 02010020 		.word	536871170
 8920 0738 60000080 		.word	-2147483552
 8921 073c 0B000000 		.word	11
 8922 0740 00000000 		.word	0
 8923 0744 00010080 		.word	-2147483392
 8924 0748 0460722E 		.word	779247620
 8925 074c 02010024 		.word	603980034
 8926 0750 90000080 		.word	-2147483504
 8927 0754 0D000000 		.word	13
 8928 0758 00000000 		.word	0
 8929 075c 00010080 		.word	-2147483392
 8930 0760 0460722E 		.word	779247620
 8931 0764 02010024 		.word	603980034
 8932 0768 90000080 		.word	-2147483504
 8933 076c 0C000000 		.word	12
 8934 0770 00000000 		.word	0
 8935 0774 00010080 		.word	-2147483392
 8936 0778 0380722E 		.word	779255811
 8937 077c 02010020 		.word	536871170
 8938 0780 60000080 		.word	-2147483552
 8939 0784 0E000000 		.word	14
 8940 0788 00000000 		.word	0
 8941 078c 00010080 		.word	-2147483392
 8942 0790 00000000 		.word	0
 8943 0794 00000000 		.word	0
 8944 0798 00000000 		.word	0
 8945 079c 00000000 		.word	0
 8946 07a0 00000000 		.word	0
 8947 07a4 00000000 		.word	0
 8950              	CyFxGpifWavedataPosition:
 8951 07a8 00       		.byte	0
 8952 07a9 01       		.byte	1
 8953 07aa 02       		.byte	2
 8954 07ab 03       		.byte	3
 8955 07ac 04       		.byte	4
 8956 07ad 05       		.byte	5
 8957 07ae 06       		.byte	6
 8958 07af 07       		.byte	7
 8959 07b0 08       		.byte	8
 8960 07b1 09       		.byte	9
 8961 07b2 0A       		.byte	10
 8962 07b3 0B       		.byte	11
 8963 07b4 0B       		.byte	11
 8964 07b5 0B       		.byte	11
 8965 07b6 0B       		.byte	11
 8966 07b7 00       		.space	1
 8969              	CyFxGpifRegValue:
 8970 07b8 08830080 		.word	-2147450104
 8971 07bc 67000000 		.word	103
 8972 07c0 00000000 		.word	0
 8973 07c4 46000000 		.word	70
 8974 07c8 00000000 		.word	0
 8975 07cc 00000000 		.word	0
 8976 07d0 02000000 		.word	2
 8977 07d4 82000000 		.word	130
 8978 07d8 82070000 		.word	1922
 8979 07dc 40040000 		.word	1088
 8980 07e0 FCFF0000 		.word	65532
 8981 07e4 28000000 		.word	40
 8982 07e8 00000000 		.word	0
 8983 07ec 00000000 		.word	0
 8984 07f0 00000000 		.word	0
 8985 07f4 00000000 		.word	0
 8986 07f8 01000000 		.word	1
 8987 07fc 00000000 		.word	0
 8988 0800 00000000 		.word	0
 8989 0804 00000000 		.word	0
 8990 0808 00000000 		.word	0
 8991 080c 00000000 		.word	0
 8992 0810 00000000 		.word	0
 8993 0814 00000000 		.word	0
 8994 0818 00000000 		.word	0
 8995 081c 00000000 		.word	0
 8996 0820 00000000 		.word	0
 8997 0824 00000000 		.word	0
 8998 0828 00000000 		.word	0
 8999 082c 06000000 		.word	6
 9000 0830 00000000 		.word	0
 9001 0834 FFFF0000 		.word	65535
 9002 0838 09010000 		.word	265
 9003 083c 00000000 		.word	0
 9004 0840 F71F0000 		.word	8183
 9005 0844 00000000 		.word	0
 9006 0848 FFFF0000 		.word	65535
 9007 084c 09010000 		.word	265
 9008 0850 00000000 		.word	0
 9009 0854 F71F0000 		.word	8183
 9010 0858 00000000 		.word	0
 9011 085c 00000000 		.word	0
 9012 0860 00000000 		.word	0
 9013 0864 00000000 		.word	0
 9014 0868 00000000 		.word	0
 9015 086c 00000000 		.word	0
 9016 0870 00000000 		.word	0
 9017 0874 00000000 		.word	0
 9018 0878 00000000 		.word	0
 9019 087c 00000000 		.word	0
 9020 0880 00000000 		.word	0
 9021 0884 00000000 		.word	0
 9022 0888 00000000 		.word	0
 9023 088c 00000000 		.word	0
 9024 0890 00000000 		.word	0
 9025 0894 00000000 		.word	0
 9026 0898 00000000 		.word	0
 9027 089c 00000000 		.word	0
 9028 08a0 00000000 		.word	0
 9029 08a4 00000000 		.word	0
 9030 08a8 00000000 		.word	0
 9031 08ac 00000000 		.word	0
 9032 08b0 00000000 		.word	0
 9033 08b4 00040180 		.word	-2147417088
 9034 08b8 01040180 		.word	-2147417087
 9035 08bc 02040180 		.word	-2147417086
 9036 08c0 03040180 		.word	-2147417085
 9037 08c4 00000000 		.word	0
 9038 08c8 00000000 		.word	0
 9039 08cc 00000000 		.word	0
 9040 08d0 00000000 		.word	0
 9041 08d4 00000000 		.word	0
 9042 08d8 00000000 		.word	0
 9043 08dc 00000000 		.word	0
 9044 08e0 00000000 		.word	0
 9045 08e4 C1FFFFFF 		.word	-63
 9048              	CyFxGpifTransition_usb2:
 9049 08e8 0000     		.short	0
 9050 08ea 5555     		.short	21845
 9051 08ec AAAA     		.short	-21846
 9052 08ee 8888     		.short	-30584
 9053 08f0 1111     		.short	4369
 9054 08f2 4444     		.short	17476
 9055 08f4 3333     		.short	13107
 9056 08f6 CCCC     		.short	-13108
 9059              	CyFxGpifWavedata_usb2:
 9060 08f8 0181731E 		.word	510886145
 9061 08fc 00000000 		.word	0
 9062 0900 00000080 		.word	-2147483648
 9063 0904 00000000 		.word	0
 9064 0908 00000000 		.word	0
 9065 090c 00000000 		.word	0
 9066 0910 0201703E 		.word	1047527682
 9067 0914 00010000 		.word	256
 9068 0918 A00000C0 		.word	-1073741664
 9069 091c 00000000 		.word	0
 9070 0920 00000000 		.word	0
 9071 0924 00000000 		.word	0
 9072 0928 0394731E 		.word	510891011
 9073 092c 04000020 		.word	536870916
 9074 0930 60004080 		.word	-2143289248
 9075 0934 00000000 		.word	0
 9076 0938 00000000 		.word	0
 9077 093c 00000000 		.word	0
 9078 0940 0620702E 		.word	779100166
 9079 0944 0C000000 		.word	12
 9080 0948 00000080 		.word	-2147483648
 9081 094c 0620702E 		.word	779100166
 9082 0950 0C000000 		.word	12
 9083 0954 00000080 		.word	-2147483648
 9084 0958 0394731E 		.word	510891011
 9085 095c 04000020 		.word	536870916
 9086 0960 60004080 		.word	-2143289248
 9087 0964 0620702E 		.word	779100166
 9088 0968 0C000000 		.word	12
 9089 096c 00000080 		.word	-2147483648
 9090 0970 0C93731E 		.word	510890764
 9091 0974 04000024 		.word	603979780
 9092 0978 90004080 		.word	-2143289200
 9093 097c 0D20702E 		.word	779100173
 9094 0980 0C000000 		.word	12
 9095 0984 00000080 		.word	-2147483648
 9096 0988 0780724E 		.word	1316126727
 9097 098c 0A000000 		.word	10
 9098 0990 00000080 		.word	-2147483648
 9099 0994 08000000 		.word	8
 9100 0998 00000000 		.word	0
 9101 099c 00010080 		.word	-2147483392
 9102 09a0 0920702E 		.word	779100169
 9103 09a4 0C010000 		.word	268
 9104 09a8 00000080 		.word	-2147483648
 9105 09ac 0A01701E 		.word	510656778
 9106 09b0 0E000100 		.word	65550
 9107 09b4 00000080 		.word	-2147483648
 9108 09b8 00000000 		.word	0
 9109 09bc 00000000 		.word	0
 9110 09c0 00000000 		.word	0
 9111 09c4 00000000 		.word	0
 9112 09c8 00000000 		.word	0
 9113 09cc 00000000 		.word	0
 9114 09d0 0394731E 		.word	510891011
 9115 09d4 04000020 		.word	536870916
 9116 09d8 60004080 		.word	-2143289248
 9117 09dc 08000000 		.word	8
 9118 09e0 00000000 		.word	0
 9119 09e4 00010080 		.word	-2147483392
 9120 09e8 0B000000 		.word	11
 9121 09ec 00000000 		.word	0
 9122 09f0 00010080 		.word	-2147483392
 9123 09f4 0C93731E 		.word	510890764
 9124 09f8 04000024 		.word	603979780
 9125 09fc 90004080 		.word	-2143289200
 9126 0a00 0D20702E 		.word	779100173
 9127 0a04 0C000000 		.word	12
 9128 0a08 00000080 		.word	-2147483648
 9129 0a0c 0D20702E 		.word	779100173
 9130 0a10 0C000000 		.word	12
 9131 0a14 00000080 		.word	-2147483648
 9132 0a18 0E60724E 		.word	1316118542
 9133 0a1c 0A000000 		.word	10
 9134 0a20 00000080 		.word	-2147483648
 9135 0a24 0F000000 		.word	15
 9136 0a28 00000000 		.word	0
 9137 0a2c 00010080 		.word	-2147483392
 9138 0a30 1020702E 		.word	779100176
 9139 0a34 0C010000 		.word	268
 9140 0a38 00000080 		.word	-2147483648
 9141 0a3c 1101701E 		.word	510656785
 9142 0a40 0E000100 		.word	65550
 9143 0a44 00000080 		.word	-2147483648
 9144 0a48 0C93731E 		.word	510890764
 9145 0a4c 04000024 		.word	603979780
 9146 0a50 90004080 		.word	-2143289200
 9147 0a54 0F000000 		.word	15
 9148 0a58 00000000 		.word	0
 9149 0a5c 00010080 		.word	-2147483392
 9150 0a60 12000000 		.word	18
 9151 0a64 00000000 		.word	0
 9152 0a68 00010080 		.word	-2147483392
 9153 0a6c 0394731E 		.word	510891011
 9154 0a70 04000020 		.word	536870916
 9155 0a74 60004080 		.word	-2143289248
 9156 0a78 0480732E 		.word	779321348
 9157 0a7c 02010000 		.word	258
 9158 0a80 0000C0C0 		.word	-1061158912
 9159 0a84 0580732E 		.word	779321349
 9160 0a88 02010000 		.word	258
 9161 0a8c 0000C0C0 		.word	-1061158912
 9162 0a90 0580732E 		.word	779321349
 9163 0a94 02010000 		.word	258
 9164 0a98 0000C0C0 		.word	-1061158912
 9165 0a9c 0480732E 		.word	779321348
 9166 0aa0 02010000 		.word	258
 9167 0aa4 0000C0C0 		.word	-1061158912
 9170              	CyFxGpifWavedataPosition_usb2:
 9171 0aa8 00       		.byte	0
 9172 0aa9 01       		.byte	1
 9173 0aaa 02       		.byte	2
 9174 0aab 03       		.byte	3
 9175 0aac 04       		.byte	4
 9176 0aad 05       		.byte	5
 9177 0aae 06       		.byte	6
 9178 0aaf 07       		.byte	7
 9179 0ab0 08       		.byte	8
 9180 0ab1 09       		.byte	9
 9181 0ab2 0A       		.byte	10
 9182 0ab3 08       		.byte	8
 9183 0ab4 0B       		.byte	11
 9184 0ab5 0C       		.byte	12
 9185 0ab6 0D       		.byte	13
 9186 0ab7 08       		.byte	8
 9187 0ab8 0E       		.byte	14
 9188 0ab9 0F       		.byte	15
 9189 0aba 08       		.byte	8
 9190 0abb 08       		.byte	8
 9191 0abc 08       		.byte	8
 9192 0abd 08       		.byte	8
 9193 0abe 08       		.byte	8
 9194 0abf 08       		.byte	8
 9195 0ac0 08       		.byte	8
 9196 0ac1 08       		.byte	8
 9197 0ac2 08       		.byte	8
 9198 0ac3 08       		.byte	8
 9199 0ac4 08       		.byte	8
 9200 0ac5 08       		.byte	8
 9201 0ac6 08       		.byte	8
 9202 0ac7 08       		.byte	8
 9203 0ac8 08       		.byte	8
 9204 0ac9 08       		.byte	8
 9205 0aca 08       		.byte	8
 9206 0acb 08       		.byte	8
 9207 0acc 08       		.byte	8
 9208 0acd 08       		.byte	8
 9209 0ace 08       		.byte	8
 9210 0acf 08       		.byte	8
 9211 0ad0 08       		.byte	8
 9212 0ad1 08       		.byte	8
 9213 0ad2 08       		.byte	8
 9214 0ad3 08       		.byte	8
 9215 0ad4 08       		.byte	8
 9216 0ad5 08       		.byte	8
 9217 0ad6 08       		.byte	8
 9218 0ad7 08       		.byte	8
 9219 0ad8 08       		.byte	8
 9220 0ad9 08       		.byte	8
 9221 0ada 08       		.byte	8
 9222 0adb 08       		.byte	8
 9223 0adc 08       		.byte	8
 9224 0add 08       		.byte	8
 9225 0ade 08       		.byte	8
 9226 0adf 08       		.byte	8
 9227 0ae0 08       		.byte	8
 9228 0ae1 08       		.byte	8
 9229 0ae2 08       		.byte	8
 9230 0ae3 08       		.byte	8
 9231 0ae4 08       		.byte	8
 9232 0ae5 08       		.byte	8
 9233 0ae6 08       		.byte	8
 9234 0ae7 08       		.byte	8
 9235 0ae8 08       		.byte	8
 9236 0ae9 08       		.byte	8
 9237 0aea 08       		.byte	8
 9238 0aeb 08       		.byte	8
 9239 0aec 08       		.byte	8
 9240 0aed 08       		.byte	8
 9241 0aee 08       		.byte	8
 9242 0aef 08       		.byte	8
 9243 0af0 08       		.byte	8
 9244 0af1 08       		.byte	8
 9245 0af2 08       		.byte	8
 9246 0af3 08       		.byte	8
 9247 0af4 08       		.byte	8
 9248 0af5 08       		.byte	8
 9249 0af6 08       		.byte	8
 9250 0af7 08       		.byte	8
 9251 0af8 08       		.byte	8
 9252 0af9 08       		.byte	8
 9253 0afa 08       		.byte	8
 9254 0afb 08       		.byte	8
 9255 0afc 08       		.byte	8
 9256 0afd 08       		.byte	8
 9257 0afe 08       		.byte	8
 9258 0aff 08       		.byte	8
 9259 0b00 08       		.byte	8
 9260 0b01 08       		.byte	8
 9261 0b02 08       		.byte	8
 9262 0b03 08       		.byte	8
 9263 0b04 08       		.byte	8
 9264 0b05 08       		.byte	8
 9265 0b06 08       		.byte	8
 9266 0b07 08       		.byte	8
 9267 0b08 08       		.byte	8
 9268 0b09 08       		.byte	8
 9269 0b0a 08       		.byte	8
 9270 0b0b 08       		.byte	8
 9271 0b0c 08       		.byte	8
 9272 0b0d 08       		.byte	8
 9273 0b0e 08       		.byte	8
 9274 0b0f 08       		.byte	8
 9275 0b10 08       		.byte	8
 9276 0b11 08       		.byte	8
 9277 0b12 08       		.byte	8
 9278 0b13 08       		.byte	8
 9279 0b14 08       		.byte	8
 9280 0b15 08       		.byte	8
 9281 0b16 08       		.byte	8
 9282 0b17 08       		.byte	8
 9283 0b18 08       		.byte	8
 9284 0b19 08       		.byte	8
 9285 0b1a 08       		.byte	8
 9286 0b1b 08       		.byte	8
 9287 0b1c 08       		.byte	8
 9288 0b1d 08       		.byte	8
 9289 0b1e 08       		.byte	8
 9290 0b1f 08       		.byte	8
 9291 0b20 08       		.byte	8
 9292 0b21 08       		.byte	8
 9293 0b22 08       		.byte	8
 9294 0b23 08       		.byte	8
 9295 0b24 08       		.byte	8
 9296 0b25 08       		.byte	8
 9297 0b26 08       		.byte	8
 9298 0b27 08       		.byte	8
 9299 0b28 00       		.byte	0
 9300 0b29 01       		.byte	1
 9301 0b2a 02       		.byte	2
 9302 0b2b 10       		.byte	16
 9303 0b2c 04       		.byte	4
 9304 0b2d 05       		.byte	5
 9305 0b2e 06       		.byte	6
 9306 0b2f 07       		.byte	7
 9307 0b30 08       		.byte	8
 9308 0b31 09       		.byte	9
 9309 0b32 0A       		.byte	10
 9310 0b33 08       		.byte	8
 9311 0b34 11       		.byte	17
 9312 0b35 0C       		.byte	12
 9313 0b36 0D       		.byte	13
 9314 0b37 08       		.byte	8
 9315 0b38 0E       		.byte	14
 9316 0b39 0F       		.byte	15
 9317 0b3a 08       		.byte	8
 9318 0b3b 00       		.space	1
 9321              	CyFxGpifRegValue_usb2:
 9322 0b3c 08830080 		.word	-2147450104
 9323 0b40 67000000 		.word	103
 9324 0b44 01000000 		.word	1
 9325 0b48 46000000 		.word	70
 9326 0b4c 00000000 		.word	0
 9327 0b50 00000000 		.word	0
 9328 0b54 02000000 		.word	2
 9329 0b58 82000000 		.word	130
 9330 0b5c 82070000 		.word	1922
 9331 0b60 40040000 		.word	1088
 9332 0b64 FCFF0000 		.word	65532
 9333 0b68 28000000 		.word	40
 9334 0b6c 00000000 		.word	0
 9335 0b70 00000000 		.word	0
 9336 0b74 00000000 		.word	0
 9337 0b78 00000000 		.word	0
 9338 0b7c 01000000 		.word	1
 9339 0b80 00000000 		.word	0
 9340 0b84 00000000 		.word	0
 9341 0b88 00000000 		.word	0
 9342 0b8c 00000000 		.word	0
 9343 0b90 00000000 		.word	0
 9344 0b94 00000000 		.word	0
 9345 0b98 00000000 		.word	0
 9346 0b9c 00000000 		.word	0
 9347 0ba0 00000000 		.word	0
 9348 0ba4 00000000 		.word	0
 9349 0ba8 00000000 		.word	0
 9350 0bac 00000000 		.word	0
 9351 0bb0 06000000 		.word	6
 9352 0bb4 00000000 		.word	0
 9353 0bb8 FFFF0000 		.word	65535
 9354 0bbc 09010000 		.word	265
 9355 0bc0 00000000 		.word	0
 9356 0bc4 F71F0000 		.word	8183
 9357 0bc8 00000000 		.word	0
 9358 0bcc FFFF0000 		.word	65535
 9359 0bd0 09010000 		.word	265
 9360 0bd4 00000000 		.word	0
 9361 0bd8 F71F0000 		.word	8183
 9362 0bdc 00000000 		.word	0
 9363 0be0 00000000 		.word	0
 9364 0be4 00000000 		.word	0
 9365 0be8 00000000 		.word	0
 9366 0bec 00000000 		.word	0
 9367 0bf0 00000000 		.word	0
 9368 0bf4 00000000 		.word	0
 9369 0bf8 00000000 		.word	0
 9370 0bfc 00000000 		.word	0
 9371 0c00 00000000 		.word	0
 9372 0c04 00000000 		.word	0
 9373 0c08 00000000 		.word	0
 9374 0c0c 00000000 		.word	0
 9375 0c10 00000000 		.word	0
 9376 0c14 00000000 		.word	0
 9377 0c18 00000000 		.word	0
 9378 0c1c 00000000 		.word	0
 9379 0c20 00000000 		.word	0
 9380 0c24 00000000 		.word	0
 9381 0c28 00000000 		.word	0
 9382 0c2c 00000000 		.word	0
 9383 0c30 00000000 		.word	0
 9384 0c34 00000000 		.word	0
 9385 0c38 00040180 		.word	-2147417088
 9386 0c3c 01040180 		.word	-2147417087
 9387 0c40 02040180 		.word	-2147417086
 9388 0c44 03040180 		.word	-2147417085
 9389 0c48 00000000 		.word	0
 9390 0c4c 00000000 		.word	0
 9391 0c50 00000000 		.word	0
 9392 0c54 00000000 		.word	0
 9393 0c58 00000000 		.word	0
 9394 0c5c 00000000 		.word	0
 9395 0c60 00000000 		.word	0
 9396 0c64 00000000 		.word	0
 9397 0c68 C1FFFFFF 		.word	-63
 9398              		.section	.rodata.str1.4,"aMS",%progbits,1
 9399              		.align	2
 9400              	.LC0:
 9401 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9401      7065722D 
 9401      74696D65 
 9401      72202564 
 9401      0D0A00
 9402 0013 00       		.space	1
 9403              	.LC1:
 9404 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9404      636F6D6D 
 9404      616E6420 
 9404      71756575 
 9404      65206973 
 9405 0037 00       		.space	1
 9406              	.LC2:
 9407 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9407      7220696E 
 9407      206D756C 
 9407      74696368 
 9407      616E6E65 
 9408 006b 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9408      2025782C 
 9408      20646D61 
 9408      446F6E65 
 9408      20256420 
 9409              	.LC3:
 9410 0084 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9410      5420656E 
 9410      636F756E 
 9410      74657265 
 9410      642E2E2E 
 9411              	.LC4:
 9412 00a4 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9412      454E4420 
 9412      656E636F 
 9412      756E7465 
 9412      7265642E 
 9413 00c6 0000     		.space	2
 9414              	.LC5:
 9415 00c8 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9415      64697363 
 9415      6F6E6E65 
 9415      63746564 
 9415      2E2E2E30 
 9416 00e7 00       		.space	1
 9417              	.LC6:
 9418 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9418      43595F46 
 9418      585F5556 
 9418      435F5649 
 9418      44454F5F 
 9419 011b 0A00     		.ascii	"\012\000"
 9420 011d 000000   		.space	3
 9421              	.LC7:
 9422 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9422      43595F46 
 9422      585F5556 
 9422      435F5649 
 9422      44454F5F 
 9423 0153 00       		.ascii	"\000"
 9424              	.LC8:
 9425 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9425      726E6174 
 9425      65207365 
 9425      7474696E 
 9425      6720302E 
 9426              	.LC9:
 9427 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9427      72206665 
 9427      61747572 
 9427      65207265 
 9427      71756573 
 9428 018f 00       		.space	1
 9429              	.LC10:
 9430 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9430      6F6D6D69 
 9430      74656F66 
 9430      20737461 
 9430      7465203D 
 9431              	.LC11:
 9432 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9432      6E656C20 
 9432      53657420 
 9432      57726170 
 9432      55702066 
 9433 01d5 000000   		.space	3
 9434              	.LC12:
 9435 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9435      72206861 
 9435      6E646C65 
 9435      722E2E2E 
 9435      0D0A00
 9436 01eb 00       		.space	1
 9437              	.LC13:
 9438 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9438      69742045 
 9438      4F462066 
 9438      61696C65 
 9438      64210D0A 
 9439 0201 000000   		.space	3
 9440              	.LC14:
 9441 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9441      49324320 
 9441      636F6D6D 
 9441      616E6420 
 9441      69732030 
 9442 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9442      78257820 
 9442      30782578 
 9442      20307825 
 9442      78203078 
 9443              	.LC15:
 9444 0250 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9444      206C6967 
 9444      68742063 
 9444      6F6D7065 
 9444      6E736174 
 9445 0283 25640D0A 		.ascii	"%d\015\012\000"
 9445      00
 9446              	.LC16:
 9447 0288 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9447      49324320 
 9447      63757272 
 9447      656E7420 
 9447      64617461 
 9448 02bb 64202564 		.ascii	"d %d\015\012\000"
 9448      0D0A00
 9449 02c2 0000     		.space	2
 9450              	.LC17:
 9451 02c4 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9451      26414743 
 9451      2073656E 
 9451      7420746F 
 9451      20686F73 
 9452 02ea 0000     		.space	2
 9453              	.LC18:
 9454 02ec 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9454      26414743 
 9454      20676F74 
 9454      74656E20 
 9454      66726F6D 
 9455 0316 0000     		.space	2
 9456              	.LC19:
 9457 0318 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9457      67657420 
 9457      64617461 
 9457      2066726F 
 9457      6D20686F 
 9458 0345 000000   		.space	3
 9459              	.LC20:
 9460 0348 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9460      52657175 
 9460      65737420 
 9460      30782578 
 9460      20706172 
 9461 037b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9461      6E642074 
 9461      6F20686F 
 9461      73742030 
 9461      78257820 
 9462 0396 0000     		.space	2
 9463              	.LC21:
 9464 0398 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9464      204F7020 
 9464      72656365 
 9464      69766573 
 9464      20284354 
 9465 03bf 00       		.space	1
 9466              	.LC22:
 9467 03c0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9467      756C7420 
 9467      73656C65 
 9467      63746F72 
 9467      20284354 
 9468 03e2 0000     		.space	2
 9469              	.LC23:
 9470 03e4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9470      756C7420 
 9470      72657175 
 9470      65737420 
 9470      28435429 
 9471 0405 000000   		.space	3
 9472              	.LC24:
 9473 0408 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9473      52657175 
 9473      65737420 
 9473      30782578 
 9473      20706172 
 9474 043b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9474      20307825 
 9474      78202F20 
 9474      73656E64 
 9474      20746F20 
 9475 0468 00       		.ascii	"\000"
 9476 0469 000000   		.space	3
 9477              	.LC25:
 9478 046c 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9478      73706565 
 9478      64203D20 
 9478      25642065 
 9478      76656E66 
 9479 049c 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9479      71756573 
 9479      74203D20 
 9479      30782578 
 9479      20775661 
 9480 04cc 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9480      203D2030 
 9480      78257820 
 9480      6973666C 
 9480      61672030 
 9481 04e6 0000     		.space	2
 9482              	.LC26:
 9483 04e8 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9483      64656661 
 9483      756C7420 
 9483      73657475 
 9483      70207265 
 9484              	.LC27:
 9485 0514 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9485      43595F46 
 9485      585F5556 
 9485      435F5354 
 9485      5245414D 
 9486 053a 0000     		.space	2
 9487              	.LC28:
 9488 053c 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9488      55564320 
 9488      7374696C 
 9488      6C207472 
 9488      69676765 
 9489 0562 0000     		.space	2
 9490              	.LC29:
 9491 0564 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9491      7374696C 
 9491      6C207472 
 9491      69676765 
 9491      7220636F 
 9492 058b 00       		.space	1
 9493              	.LC30:
 9494 058c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9494      65642074 
 9494      6F207365 
 9494      6E642069 
 9494      6E746572 
 9495 05bd 0A00     		.ascii	"\012\000"
 9496 05bf 00       		.space	1
 9497              	.LC31:
 9498 05c0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9498      73657420 
 9498      64656620 
 9498      64617461 
 9498      20307825 
 9499 05df 00       		.space	1
 9500              	.LC32:
 9501 05e0 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9501      73657420 
 9501      64656620 
 9501      64617461 
 9501      20307825 
 9502 0613 2E0D0A00 		.ascii	".\015\012\000"
 9503 0617 00       		.space	1
 9504              	.LC33:
 9505 0618 55415254 		.ascii	"UART initialization failed!\012\000"
 9505      20696E69 
 9505      7469616C 
 9505      697A6174 
 9505      696F6E20 
 9506 0635 000000   		.space	3
 9507              	.LC34:
 9508 0638 49324320 		.ascii	"I2C initialization failed!\012\000"
 9508      696E6974 
 9508      69616C69 
 9508      7A617469 
 9508      6F6E2066 
 9509              	.LC35:
 9510 0654 49324320 		.ascii	"I2C configuration failed!\012\000"
 9510      636F6E66 
 9510      69677572 
 9510      6174696F 
 9510      6E206661 
 9511 066f 00       		.space	1
 9512              	.LC36:
 9513 0670 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9513      43726561 
 9513      74652045 
 9513      76656E74 
 9513      20666169 
 9514 069a 0000     		.space	2
 9515              	.LC37:
 9516 069c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9516      20496E69 
 9516      74206661 
 9516      696C6564 
 9516      2C204572 
 9517 06bf 00       		.space	1
 9518              	.LC38:
 9519 06c0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9519      204F7665 
 9519      72726964 
 9519      65206661 
 9519      696C6564 
 9520 06e7 00       		.space	1
 9521              	.LC39:
 9522 06e8 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9522      28323029 
 9522      204F7665 
 9522      72726964 
 9522      65206661 
 9523 0713 00       		.space	1
 9524              	.LC40:
 9525 0714 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9525      28323429 
 9525      204F7665 
 9525      72726964 
 9525      65206661 
 9526 073f 00       		.space	1
 9527              	.LC41:
 9528 0740 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9528      20536574 
 9528      20287265 
 9528      73657420 
 9528      32322920 
 9529 0772 00       		.ascii	"\000"
 9530 0773 00       		.space	1
 9531              	.LC42:
 9532 0774 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9532      20536574 
 9532      2028706F 
 9532      77657220 
 9532      32302920 
 9533 07a6 00       		.ascii	"\000"
 9534 07a7 00       		.space	1
 9535              	.LC43:
 9536 07a8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9536      20536574 
 9536      2028736E 
 9536      61702073 
 9536      686F7420 
 9537 07db 25640A00 		.ascii	"%d\012\000"
 9538 07df 00       		.space	1
 9539              	.LC44:
 9540 07e0 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9540      46756E63 
 9540      74696F6E 
 9540      20466169 
 9540      6C656420 
 9541 080f 00       		.space	1
 9542              	.LC45:
 9543 0810 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9543      46756E63 
 9543      74696F6E 
 9543      20466169 
 9543      6C656420 
 9544 083f 00       		.space	1
 9545              	.LC46:
 9546 0840 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9546      53657420 
 9546      456E6470 
 9546      6F696E74 
 9546      20636F6E 
 9547 0870 00       		.ascii	"\000"
 9548 0871 000000   		.space	3
 9549              	.LC47:
 9550 0874 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9550      496E7465 
 9550      72727570 
 9550      74205374 
 9550      61747573 
 9551 08a7 20436F64 		.ascii	" Code = %d\012\000"
 9551      65203D20 
 9551      25640A00 
 9552 08b3 00       		.space	1
 9553              	.LC48:
 9554 08b4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9554      65642074 
 9554      6F20616C 
 9554      6C6F6361 
 9554      7465206D 
 9555 08e7 65720D0A 		.ascii	"er\015\012\000"
 9555      00
 9556              	.LC49:
 9557 08ec 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9557      4368616E 
 9557      6E656C20 
 9557      43726561 
 9557      74696F6E 
 9558 091a 0000     		.space	2
 9559              	.LC50:
 9560 091c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9560      436F6E6E 
 9560      65637420 
 9560      6661696C 
 9560      65642C20 
 9561 0941 000000   		.space	3
 9562              	.LC51:
 9563 0944 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9563      4368616E 
 9563      6E656C20 
 9563      52657365 
 9563      74204661 
 9564 096f 00       		.space	1
 9565              	.LC52:
 9566 0970 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9566      4368616E 
 9566      6E656C20 
 9566      53657420 
 9566      5472616E 
 9567 09a1 00       		.ascii	"\000"
 9568 09a2 0000     		.space	2
 9569              	.LC53:
 9570 09a4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9570      4368616E 
 9570      6E656C20 
 9570      53657420 
 9570      5472616E 
 9571 09d5 0A00     		.ascii	"\012\000"
 9572 09d7 00       		.space	1
 9573              	.LC54:
 9574 09d8 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9574      75706572 
 9574      20677069 
 9574      6600
 9575 09e6 0000     		.space	2
 9576              	.LC55:
 9577 09e8 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9577      69676820 
 9577      67706966 
 9577      00
 9578 09f5 000000   		.space	3
 9579              	.LC56:
 9580 09f8 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9580      696E6720 
 9580      47504946 
 9580      20436F6E 
 9580      66696775 
 9581 0a2b 0A00     		.ascii	"\012\000"
 9582 0a2d 000000   		.space	3
 9583              	.LC57:
 9584 0a30 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9584      74696E67 
 9584      20475049 
 9584      46207374 
 9584      61746520 
 9585 0a63 0D0A00   		.ascii	"\015\012\000"
 9586 0a66 0000     		.space	2
 9587              	.LC58:
 9588 0a68 33303A55 		.ascii	"30:UVC App Thread\000"
 9588      56432041 
 9588      70702054 
 9588      68726561 
 9588      6400
 9589 0a7a 0000     		.space	2
 9590              	.LC59:
 9591 0a7c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9591      56432041 
 9591      70702045 
 9591      50302054 
 9591      68726561 
 9592 0a92 0000     		.space	2
 9593              	.LC60:
 9594 0a94 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9594      32432041 
 9594      70702043 
 9594      54524C20 
 9594      54687265 
 9595 0aab 00       		.bss
 9596              		.align	2
 9597              		.set	.LANCHOR0,. + 0
 9600              	glFxUVCEvent:
 9601 0000 00000000 		.space	40
 9601      00000000 
 9601      00000000 
 9601      00000000 
 9601      00000000 
 9604              	fb:
 9605 0028 0000     		.space	2
 9608              	pb:
 9609 002a 0000     		.space	2
 9612              	pbc:
 9613 002c 0000     		.space	2
 9614 002e 0000     		.space	2
 9617              	hitFV:
 9618 0030 00000000 		.space	4
 9621              	prodCount:
 9622 0034 0000     		.space	2
 9625              	consCount:
 9626 0036 0000     		.space	2
 9629              	streamingStarted:
 9630 0038 00000000 		.space	4
 9633              	gpif_initialized:
 9634 003c 00000000 		.space	4
 9637              	isUsbConnected:
 9638 0040 00000000 		.space	4
 9641              	clearFeatureRqtReceived:
 9642 0044 00000000 		.space	4
 9645              	usbSpeed:
 9646 0048 00       		.space	1
 9647 0049 000000   		.space	3
 9650              	I2CCMDArry:
 9651 004c 00000000 		.space	12
 9651      00000000 
 9651      00000000 
 9654              	glEp0Buffer:
 9655 0058 00000000 		.space	32
 9655      00000000 
 9655      00000000 
 9655      00000000 
 9655      00000000 
 9658              	CamMode:
 9659 0078 00       		.space	1
 9660 0079 000000   		.space	3
 9663              	glCommitCtrl:
 9664 007c 00000000 		.space	32
 9664      00000000 
 9664      00000000 
 9664      00000000 
 9664      00000000 
 9667              	stiflag:
 9668 009c 00000000 		.space	4
 9671              	uvcAppThread:
 9672 00a0 00000000 		.space	168
 9672      00000000 
 9672      00000000 
 9672      00000000 
 9672      00000000 
 9675              	uvcAppEP0Thread:
 9676 0148 00000000 		.space	168
 9676      00000000 
 9676      00000000 
 9676      00000000 
 9676      00000000 
 9679              	i2cAppThread:
 9680 01f0 00000000 		.space	168
 9680      00000000 
 9680      00000000 
 9680      00000000 
 9680      00000000 
 9683              	testSnap:
 9684 0298 00       		.space	1
 9685 0299 00       		.space	1
 9688              	fbbak:
 9689 029a 0000     		.space	2
 9692              	pbbak:
 9693 029c 0000     		.space	2
 9696              	pbcbak:
 9697 029e 0000     		.space	2
 9700              	pbcpbak:
 9701 02a0 0000     		.space	2
 9702 02a2 0000     		.text
 9703              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:331    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:494    .text:00000380 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:502    .text:00000394 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:504    .text:00000394 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:683    .text:000004f4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:692    .text:00000504 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:694    .text:00000504 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1019   .text:000007cc $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1035   .text:000007f8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1038   .text:000007f8 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1075   .text:00000830 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1088   .text:0000085c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1135   .text:000008b0 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1142   .text:000008c0 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1160   .text:000008dc $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1169   .text:000008f4 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1172   .text:000008f4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1379   .text:00000b08 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1385   .text:00000b14 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1388   .text:00000b14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1451   .text:00000b94 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1658   .text:00000d30 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1696   .text:00000dbc $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1760   .text:00000e40 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:1796   .text:00000ec8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3050   .text:00001a5c $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3068   .text:00001a98 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3071   .text:00001a98 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3239   .text:00001bf4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3252   .text:00001c1c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3747   .text:0000212c $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:3758   .text:0000214c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:4013   .text:00002404 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:4026   .text:0000242c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:4029   .text:0000242c UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:4091   .text:000024a8 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:4099   .text:000024b8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5265   .text:00002e64 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5293   .text:00002ec0 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5296   .text:00002ec0 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5587   .text:00003178 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5594   .text:00003188 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5597   .text:00003188 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5633   .text:000031b4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5637   .text:000031b8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5640   .text:000031b8 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5665   .text:000031d4 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5669   .text:000031d8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:5672   .text:000031d8 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7003   .text:00003c44 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7062   .text:00003d1c $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7065   .text:00003d1c CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7222   .text:00003e94 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7238   .text:00003ec8 $a
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7241   .text:00003ec8 main
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8866   .data:0000067c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8875   .data:00000688 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8950   .data:000007a8 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8969   .data:000007b8 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7403   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9048   .data:000008e8 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9059   .data:000008f8 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9170   .data:00000aa8 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9321   .data:00000b3c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7416   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8862   .data:0000067b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9683   .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9604   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9608   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9612   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9688   .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9692   .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9696   .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9700   .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9637   .bss:00000040 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9645   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9641   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9629   .bss:00000038 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8803   .data:00000648 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8743   .data:00000610 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8833   .data:00000664 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8773   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8848   .data:00000670 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8398   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7380   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7384   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7428   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7432   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:7755   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8413   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:8420   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9399   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9596   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9600   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9617   .bss:00000030 hitFV
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9621   .bss:00000034 prodCount
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9625   .bss:00000036 consCount
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9633   .bss:0000003c gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9650   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9654   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9658   .bss:00000078 CamMode
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9663   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9667   .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9671   .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9675   .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cc6kmgKs.s:9679   .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
SensorRead2B2
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
