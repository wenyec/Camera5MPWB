   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 233:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 234:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 237:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 238:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 239:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 250:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 251:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 253:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 254:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 255:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 256:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 257:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 258:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 259:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 261:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //volatile static SensorCtrl PUCBLC;
 277:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 278:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 279:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 280:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 281:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 282:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 283:../uvc.c      **** //volatile static SensorCtrl PUCSharp;
 284:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 285:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 286:../uvc.c      **** /* the Camera terminal control request */
 287:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 288:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 289:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 290:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 291:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 292:../uvc.c      **** /* the Extentsion control request */
 293:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 294:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 295:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 296:../uvc.c      **** 		 2,					//UVCLn: the command length
 297:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 298:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 299:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 300:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 301:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 302:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 303:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 304:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 305:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 306:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 307:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 308:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 309:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 310:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 311:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 312:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 313:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 314:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 315:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 316:../uvc.c      **** 		 2,					//UVCLn: the command length
 317:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 318:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 319:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 320:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 321:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 322:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 323:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 324:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 325:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 326:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 327:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 328:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 329:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 330:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 331:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 332:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 333:../uvc.c      **** */
 334:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 335:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 336:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 337:../uvc.c      **** 		 2,					//UVCLn: the command length
 338:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 339:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 340:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 341:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 342:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 343:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 344:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 345:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 346:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 347:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 348:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 349:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 350:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 351:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 352:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 353:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 354:../uvc.c      **** */
 355:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 356:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 357:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 358:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 359:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 360:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 361:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 362:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 363:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 364:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 365:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 366:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 367:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 368:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 369:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 370:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 371:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 372:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 373:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 374:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 375:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 376:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 377:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 378:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 379:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 380:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 381:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 382:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 383:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 384:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 385:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 386:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 387:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 388:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 389:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 390:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 391:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 392:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 393:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 394:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 395:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 396:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 397:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 398:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 399:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 400:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 401:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 402:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 403:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 404:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 405:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 406:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 407:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 408:../uvc.c      **** 
 409:../uvc.c      **** volatile static SensorCtrl *pSensorCtrl[0x20] = {
 410:../uvc.c      **** 		&EXTShutter,
 411:../uvc.c      **** 		0,//&EXTSensUp,
 412:../uvc.c      **** 		0,//&EXTMirror,
 413:../uvc.c      **** 		0,//&EXT3DnoiseReduceMode,
 414:../uvc.c      **** 		0,//&EXT3DNoiseLev,
 415:../uvc.c      **** 		0,//&EXTDayNightMode,
 416:../uvc.c      **** 		0,//&EXTDayNightdely,
 417:../uvc.c      **** 		0,//&EXTDayNightlev,
 418:../uvc.c      **** 		0,//&EXTNightDaylev,
 419:../uvc.c      **** 		&EXTAexModGainlev,
 420:../uvc.c      **** 		0,//&EXTExpReflev,
 421:../uvc.c      **** 		&EXTShutlev,
 422:../uvc.c      **** 		0,//&EXTCamMode,
 423:../uvc.c      **** 		0,//&EXTSnapshot,
 424:../uvc.c      **** 		0,//&EXTSensorPare,
 425:../uvc.c      **** 		0,//&EXTI2Ccmd
 426:../uvc.c      **** 		0
 427:../uvc.c      **** };
 428:../uvc.c      **** #endif
 429:../uvc.c      **** 
 430:../uvc.c      **** #ifndef CAM720
 431:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 432:../uvc.c      **** #else
 433:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 434:../uvc.c      **** #endif
 435:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 436:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 437:../uvc.c      **** 
 438:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 439:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 440:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 441:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 442:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 443:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 444:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 445:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 446:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 447:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 448:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 449:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 450:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 451:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 452:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 453:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 454:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 455:../uvc.c      **** };
 456:../uvc.c      **** 
 457:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 458:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 459:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 460:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 461:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 462:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 463:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 464:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 465:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 466:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 467:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 468:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 469:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 470:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 471:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 472:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 473:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 474:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 475:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 476:../uvc.c      **** };
 477:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 478:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 479:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 480:../uvc.c      **** /*
 481:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 482:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 483:../uvc.c      ****  */
 484:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 485:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 486:../uvc.c      **** };
 487:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 488:../uvc.c      **** 		0
 489:../uvc.c      **** };
 490:../uvc.c      **** 
 491:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 492:../uvc.c      **** 
 493:../uvc.c      **** void I2CCmdHandler(){
 494:../uvc.c      **** 	uint8_t buf[2];
 495:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 496:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 497:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 498:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 499:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 500:../uvc.c      **** 	uint8_t i;
 501:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 502:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 503:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 504:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 505:../uvc.c      **** 	{
 506:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 507:../uvc.c      **** 		if(is60Hz==CyFalse)
 508:../uvc.c      **** 			{
 509:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 510:../uvc.c      **** 			}
 511:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 512:../uvc.c      **** 
 513:../uvc.c      **** 	}
 514:../uvc.c      **** 	if(CmdType == 0)//I2C read
 515:../uvc.c      **** 	{
 516:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 517:../uvc.c      **** #if 0 //for debugging
 518:../uvc.c      **** 		/* test still image operation */
 519:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 520:../uvc.c      **** 			snapButFlag = 0; //press
 521:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 522:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 523:../uvc.c      **** 			snapButFlag = 0xf; //release
 524:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 525:../uvc.c      **** 		}
 526:../uvc.c      **** 
 527:../uvc.c      **** 		/* end of the test */
 528:../uvc.c      **** #endif
 529:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 530:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 531:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 532:../uvc.c      **** 				if(CmdDataLen == 2){
 533:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 534:../uvc.c      **** 				}
 535:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 536:../uvc.c      **** 		}else{//not support currently
 537:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 538:../uvc.c      **** 		}
 539:../uvc.c      **** 	}else if(CmdType == 1){
 540:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 541:../uvc.c      **** 			if(CmdRegLen == 2){
 542:../uvc.c      **** 				for(i = 0; i<4; i++)
 543:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 544:../uvc.c      **** 			}
 545:../uvc.c      **** 			else{
 546:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 547:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 548:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 549:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 550:../uvc.c      **** 				}
 551:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 552:../uvc.c      **** 			}
 553:../uvc.c      **** 		}else{//not support currently
 554:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 555:../uvc.c      **** 		}
 556:../uvc.c      **** 
 557:../uvc.c      **** 	}
 558:../uvc.c      **** }
 559:../uvc.c      **** 
 560:../uvc.c      **** /************************************
 561:../uvc.c      ****  * set Iris mode
 562:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 563:../uvc.c      ****  */
 564:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 565:../uvc.c      **** 	uint8_t dataIdx = 0;
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 570:../uvc.c      **** }
 571:../uvc.c      **** 
 572:../uvc.c      **** 
 573:../uvc.c      **** 
 574:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 575:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 576:../uvc.c      **** 	uint16_t NumLn;
 577:../uvc.c      **** 	uint16_t fRate, shutTm;
 578:../uvc.c      **** 	uint8_t LnVal;
 579:../uvc.c      **** 	switch (Data){
 580:../uvc.c      **** 	case 1:
 581:../uvc.c      **** 	case 2:
 582:../uvc.c      **** 	case 3:
 583:../uvc.c      **** 	case 4:
 584:../uvc.c      **** 	case 5:
 585:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 586:../uvc.c      **** 		fRate = 30;
 587:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 588:../uvc.c      **** 		if(NumLn > 1944)
 589:../uvc.c      **** 			NumLn =1944;
 590:../uvc.c      **** 		else if(NumLn < 8)
 591:../uvc.c      **** 			NumLn = 8;
 592:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 593:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 594:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 595:../uvc.c      **** 		break;
 596:../uvc.c      **** 	case 6:
 597:../uvc.c      **** 	case 7:
 598:../uvc.c      **** 	case 8:
 599:../uvc.c      **** 	case 9:
 600:../uvc.c      **** 	case 10:
 601:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 602:../uvc.c      **** 		fRate = 30;
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 604:../uvc.c      **** 		if(NumLn > 1944)
 605:../uvc.c      **** 			NumLn =1944;
 606:../uvc.c      **** 		else if(NumLn < 8)
 607:../uvc.c      **** 			NumLn = 8;
 608:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 609:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 610:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 611:../uvc.c      **** 		break;
 612:../uvc.c      **** 	case 0: //auto
 613:../uvc.c      **** 	default:
 614:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 615:../uvc.c      **** 		LnVal = 1;
 616:../uvc.c      **** 		break;
 617:../uvc.c      **** 	}
 618:../uvc.c      **** 	return LnVal;
 619:../uvc.c      **** }
 620:../uvc.c      **** 
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 622:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 623:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 624:../uvc.c      ****     uint16_t readCount;
 625:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 626:../uvc.c      ****     uint8_t devAdd;
 627:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 628:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 629:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 630:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 631:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 632:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 633:../uvc.c      ****     }else{
 634:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 635:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 636:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 637:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 638:../uvc.c      ****     }
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 640:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 641:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 642:../uvc.c      **** #endif
 643:../uvc.c      ****     reqData = bRequest;
 644:../uvc.c      ****     /*
 645:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 646:../uvc.c      ****      */
 647:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 648:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 649:../uvc.c      ****     	goto EndofSet;
 650:../uvc.c      ****     }
 651:../uvc.c      ****     switch (bRequest)
 652:../uvc.c      **** 		 {
 653:../uvc.c      **** 
 654:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 655:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 656:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 657:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 658:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 659:../uvc.c      **** 			  break;
 660:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 661:../uvc.c      **** 
 662:../uvc.c      **** 			 switch(CtrlID)
 663:../uvc.c      **** 			 {
 664:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 665:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 666:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 667:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 668:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 669:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 670:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 671:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 672:../uvc.c      **** 			 	 		 break;
 673:../uvc.c      **** 			 	 }
 674:../uvc.c      **** 			 	 case ExtShutCtlID0:
 675:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 676:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 677:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 678:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 679:../uvc.c      **** 			 		 break;
 680:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 681:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 682:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 683:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 684:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 685:../uvc.c      **** 			 		 break;
 686:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 687:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 688:../uvc.c      **** 					 if(CamMode == 1){//720p
 689:../uvc.c      **** 						if(sendData >= 3){
 690:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 691:../uvc.c      **** 							sendData = 0; //set back to default
 692:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 693:../uvc.c      **** 						}
 694:../uvc.c      **** 						sendData += 4;
 695:../uvc.c      **** 					 }
 696:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 697:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 699:../uvc.c      **** 					 break;
 700:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 701:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 702:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 703:../uvc.c      **** 			 		 }
 704:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 705:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 706:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 707:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 708:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 709:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 710:../uvc.c      **** #endif
 711:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 712:../uvc.c      **** 			 		 {
 713:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 714:../uvc.c      **** 			 		 }
 715:../uvc.c      **** 			 		 break;
 716:../uvc.c      **** 				 case ExtAexModCtlID9:
 717:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 718:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 719:../uvc.c      **** 
 720:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 722:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 723:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 724:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 725:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 726:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 727:../uvc.c      **** 					 break;
 728:../uvc.c      **** 
 729:../uvc.c      **** 			 	 case BrgtCtlID1:
 730:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 731:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 732:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 733:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 734:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 735:../uvc.c      **** 					 }else{
 736:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 737:../uvc.c      **** 					 }
 738:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 739:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 740:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 741:../uvc.c      **** 					 */
 742:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 743:../uvc.c      **** 					  if(Data0&0x80){
 744:../uvc.c      **** 						  Data0 = ~Data0;
 745:../uvc.c      **** 					  }else{
 746:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 747:../uvc.c      **** 					  }
 748:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 749:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 750:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 751:../uvc.c      **** 			 		 break;
 752:../uvc.c      **** 				 case HueCtlID5:
 753:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 754:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 755:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 756:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 757:../uvc.c      **** 					 break;
 758:../uvc.c      **** 				 case WBTLevCtlID11:
 759:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 760:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 761:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 762:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 763:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 764:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 765:../uvc.c      **** 					 break;
 766:../uvc.c      **** 				 case SaturCtlID6:
 767:../uvc.c      **** 				 default:
 768:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 769:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 770:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 771:../uvc.c      **** 					 break;
 772:../uvc.c      **** 			 }
 773:../uvc.c      **** 
 774:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 775:../uvc.c      **** 
 776:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 777:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 778:../uvc.c      **** #endif
 779:../uvc.c      **** 			  break;
 780:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 781:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 782:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 783:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 784:../uvc.c      **** 		 	 }
 785:../uvc.c      **** 
 786:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 787:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 788:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 789:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 790:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 791:../uvc.c      **** 			 }else
 792:../uvc.c      **** 			 {
 793:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 794:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 795:../uvc.c      **** 			 }
 796:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 797:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 798:../uvc.c      **** 			  break;
 799:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 800:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 801:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 802:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 803:../uvc.c      **** 		 	 }
 804:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 805:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 806:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 807:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 808:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 809:../uvc.c      **** 			 }else
 810:../uvc.c      **** 			 {
 811:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 812:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 813:../uvc.c      **** 			 }
 814:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 815:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 816:../uvc.c      **** 			  break;
 817:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 818:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 819:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 820:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 821:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 822:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 823:../uvc.c      **** 		 	 }
 824:../uvc.c      **** 		 	 else{
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 826:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 827:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 828:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 829:../uvc.c      **** 		 	 }
 830:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 831:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 832:../uvc.c      **** 			  break;
 833:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 834:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 835:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 836:../uvc.c      **** 		 	 }
 837:../uvc.c      **** 		 	 else{
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 839:../uvc.c      **** 		 	 }
 840:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 841:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 842:../uvc.c      **** 			  Len = 1;
 843:../uvc.c      **** 			  break;
 844:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 845:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 846:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 847:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 848:../uvc.c      **** 		 	 }
 849:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 850:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 851:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 852:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 853:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 854:../uvc.c      **** 			 }else{
 855:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 856:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 857:../uvc.c      **** 			 }
 858:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 859:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 860:../uvc.c      **** 			  break;
 861:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 862:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 863:../uvc.c      **** 				  glEp0Buffer, &readCount);
 864:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 865:../uvc.c      **** 			   {
 866:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 867:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 868:../uvc.c      **** 				  getData = glEp0Buffer[0];
 869:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 870:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 871:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 872:../uvc.c      **** #endif
 873:../uvc.c      **** 				  switch(CtrlID)
 874:../uvc.c      **** 					 {
 875:../uvc.c      **** 						 case ExtShutCtlID0:
 876:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 877:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 878:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 879:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 880:../uvc.c      **** #if 0	// register setting directly
 881:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 882:../uvc.c      **** 						     {
 883:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 884:../uvc.c      **** 						    	 dataIdx = 0;
 885:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 886:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 887:../uvc.c      **** 								 dataIdx++;
 888:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 889:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 890:../uvc.c      **** 						     }
 891:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 892:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 893:../uvc.c      **** 						     break;
 894:../uvc.c      **** #else	// old fashion
 895:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 896:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 897:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 898:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 899:../uvc.c      **** 									 }else{
 900:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 901:../uvc.c      **** 									 }
 902:../uvc.c      **** 								 }
 903:../uvc.c      **** 							 }else{
 904:../uvc.c      **** 								 Data1 = Data0 - 1;
 905:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 906:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 907:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 908:../uvc.c      **** 									 }else{
 909:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 910:../uvc.c      **** 									 }
 911:../uvc.c      **** 								 }
 912:../uvc.c      **** 								 if(Data1 < 8){
 913:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 914:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 915:../uvc.c      **** 								 }else{
 916:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 917:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 918:../uvc.c      **** 								 }
 919:../uvc.c      **** 							 }
 920:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
 921:../uvc.c      **** 							 dataIdx = 0;
 922:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
 923:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 924:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
 925:../uvc.c      **** 							 if(AxMode){
 926:../uvc.c      **** 								 dataIdx++;
 927:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
 928:../uvc.c      **** 								 dataIdx++;
 929:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
 930:../uvc.c      **** 							 }
 931:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 932:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 933:../uvc.c      **** 							 break;
 934:../uvc.c      **** #endif
 935:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 936:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 937:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 938:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 939:../uvc.c      **** 						     dataIdx = 0;
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 941:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 942:../uvc.c      **** 							 {
 943:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 944:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 945:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 946:../uvc.c      **** 								 /*
 947:../uvc.c      **** 								 dataIdx++;
 948:../uvc.c      **** 								 if(getData == 1 || getData == 3){
 949:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
 950:../uvc.c      **** 									 dataIdx++;
 951:../uvc.c      **** 								 }else{
 952:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
 953:../uvc.c      **** 									 dataIdx++;
 954:../uvc.c      **** 								 }
 955:../uvc.c      **** 								 */
 956:../uvc.c      **** 							 }
 957:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 958:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 959:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 960:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 961:../uvc.c      **** 								 }
 962:../uvc.c      **** 							 }
 963:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
 964:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 965:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 966:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 967:../uvc.c      **** 							 break;
 968:../uvc.c      **** 
 969:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
 970:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 971:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 972:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 973:../uvc.c      **** 						     dataIdx = 0;
 974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 975:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 976:../uvc.c      **** 							 {
 977:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
 978:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 979:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 980:../uvc.c      **** 								 dataIdx++;
 981:../uvc.c      **** 							 }
 982:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 983:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 984:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 985:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 986:../uvc.c      **** 									 dataIdx++;
 987:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 988:../uvc.c      **** 								 }
 989:../uvc.c      **** 							 }
 990:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
 991:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 992:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 993:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 994:../uvc.c      **** 							 break;
 995:../uvc.c      **** 						 case ExtCamMCtlID12:
 996:../uvc.c      **** 							 dataIdx = 0;
 997:../uvc.c      **** 							 if(Data0 <= 3){
 998:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 999:../uvc.c      **** 								 Data1 = Data0;
1000:../uvc.c      **** 							 }else{
1001:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1002:../uvc.c      **** 								 Data1 = Data0-4;
1003:../uvc.c      **** 							 }
1004:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1005:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1006:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1007:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1008:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1009:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1010:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1011:../uvc.c      **** 							 break;
1012:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1013:../uvc.c      **** 							 dataIdx = 0;
1014:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1015:../uvc.c      **** 								 Data0 = 1;
1016:../uvc.c      **** 							 }else{ //save current sensor parameters.
1017:../uvc.c      **** 								 Data0 = 0;
1018:../uvc.c      **** 							 }
1019:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1020:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1021:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1022:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1023:../uvc.c      **** 							 break;
1024:../uvc.c      **** 						 case ExtI2CCtlID15:
1025:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1026:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1027:../uvc.c      **** 					 		 }
1028:../uvc.c      **** 					 		I2CCmdHandler();
1029:../uvc.c      **** 							 break;
1030:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
1031:../uvc.c      **** 							 dataIdx = 0;
1032:../uvc.c      **** #if 0 //seperate version
1033:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1034:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1035:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1036:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1037:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1038:../uvc.c      **** 							 }else{ //disable BLD window
1039:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1040:../uvc.c      **** 							 }
1041:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1042:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1043:../uvc.c      **** 							 dataIdx++;
1044:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1045:../uvc.c      **** 							 dataIdx++;
1046:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1047:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1048:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1049:../uvc.c      **** 							 dataIdx++;
1050:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1051:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1052:../uvc.c      **** #else //combination version
1053:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
1054:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1055:../uvc.c      **** 						     /* end test */
1056:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1057:../uvc.c      **** 							 dataIdx++;
1058:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1059:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1060:../uvc.c      **** 							 getData1 = Data1;
1061:../uvc.c      **** #endif
1062:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
1063:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
1064:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1065:../uvc.c      **** 							 break;
1066:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
1067:../uvc.c      **** 							 dataIdx = 0;
1068:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1069:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1070:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1071:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1072:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1073:../uvc.c      **** 							 break;
1074:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
1075:../uvc.c      **** 							 dataIdx = 0;
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1077:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1078:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1079:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1080:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1081:../uvc.c      **** 							 break;
1082:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1083:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1084:../uvc.c      **** 							 dataIdx = 0;
1085:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1086:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1087:../uvc.c      **** 							  if(Data0&0x80){
1088:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1089:../uvc.c      **** 							  }else{
1090:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1091:../uvc.c      **** 							  }
1092:../uvc.c      **** 							 Data1 |= ~0x03;
1093:../uvc.c      **** 							 Data1 &= 0xC7;
1094:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1095:../uvc.c      **** 						  	 dataIdx++;
1096:../uvc.c      **** 
1097:../uvc.c      **** 							 Data0 = (Data0 << 2);
1098:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1099:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1100:../uvc.c      **** 
1101:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1102:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1103:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1104:../uvc.c      **** #endif
1105:../uvc.c      **** 							 dataIdx = 0;
1106:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1107:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1108:../uvc.c      **** 							  if(Data0&0x80){
1109:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1110:../uvc.c      **** 							  }else{
1111:../uvc.c      **** 								  Data0 = ~Data0;
1112:../uvc.c      **** 							  }
1113:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1114:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1115:../uvc.c      **** 
1116:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1117:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1118:../uvc.c      **** 
1119:../uvc.c      **** 
1120:../uvc.c      **** 							 break;
1121:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1122:../uvc.c      **** 							 dataIdx = 0;
1123:../uvc.c      **** 
1124:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1125:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1126:../uvc.c      **** 							 dataIdx++;
1127:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1128:../uvc.c      **** 							 dataIdx++;
1129:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1130:../uvc.c      **** 							 dataIdx++;
1131:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1132:../uvc.c      **** 							 dataIdx++;
1133:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1134:../uvc.c      **** 							 dataIdx++;
1135:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1136:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1137:../uvc.c      **** 
1138:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1139:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1140:../uvc.c      **** 							 break;
1141:../uvc.c      **** 						 case SaturCtlID6:
1142:../uvc.c      **** 							 dataIdx = 0;
1143:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1144:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1145:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1146:../uvc.c      **** 							 dataIdx++;
1147:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1148:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1149:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1150:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1151:../uvc.c      **** 							 break;
1152:../uvc.c      **** 
1153:../uvc.c      **** 						 case WBTLevCtlID11:
1154:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1155:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1156:../uvc.c      **** 							 dataIdx = 0;
1157:../uvc.c      **** 
1158:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1159:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1160:../uvc.c      **** 							 dataIdx++;
1161:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1162:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1163:../uvc.c      **** 
1164:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1165:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1166:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1167:../uvc.c      **** 							 break;
1168:../uvc.c      **** 						 case MFreqCtlID4:
1169:../uvc.c      **** 							 dataIdx = 0;
1170:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1171:../uvc.c      **** 							 Data0 = Data0 - 1;
1172:../uvc.c      **** 							 is60Hz = Data0;
1173:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1174:../uvc.c      **** 							 {
1175:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1176:../uvc.c      **** 								 is60Hz = CyFalse;
1177:../uvc.c      **** 							 }
1178:../uvc.c      **** 							 else if(Data0 >2)
1179:../uvc.c      **** 							 {
1180:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1181:../uvc.c      **** 								 is60Hz = CyTrue;
1182:../uvc.c      **** 							 }
1183:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1184:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1185:../uvc.c      **** 							 {
1186:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1187:../uvc.c      **** 			                       switch (setRes)
1188:../uvc.c      **** 			                         {
1189:../uvc.c      **** 			                         	case 1: //1944
1190:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1191:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1192:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
1193:../uvc.c      **** 			                         		break;
1194:../uvc.c      **** 			                         	case 2: //1080
1195:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1196:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1197:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
1198:../uvc.c      **** 			                         		break;
1199:../uvc.c      **** 			                         	case 3: //720
1200:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1201:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1202:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is
1203:../uvc.c      **** 			                         		break;
1204:../uvc.c      **** 			                         	default:
1205:../uvc.c      **** 			                         		break;
1206:../uvc.c      **** 			                         }
1207:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1208:../uvc.c      **** 							 }
1209:../uvc.c      **** 
1210:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1211:../uvc.c      **** 							 break;
1212:../uvc.c      **** 					 	 case BLCCtlID0:
1213:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1214:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1215:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1216:../uvc.c      **** 							 {
1217:../uvc.c      **** 								 if(Data0 < 3){
1218:../uvc.c      **** 					 				 Data0 += 4;
1219:../uvc.c      **** 					 			 }else{
1220:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1221:../uvc.c      **** 									Data0 = 4; //set to default.
1222:../uvc.c      **** 					 			 }
1223:../uvc.c      **** 					 		 }
1224:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
1225:../uvc.c      **** 							 dataIdx = 0;
1226:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1227:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1228:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1229:../uvc.c      **** 
1230:../uvc.c      **** 					 		 break;
1231:../uvc.c      **** 						 default:
1232:../uvc.c      **** 							 dataIdx = 0;
1233:../uvc.c      **** 
1234:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1235:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1236:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1237:../uvc.c      **** 
1238:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1239:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1240:../uvc.c      **** 							 break;
1241:../uvc.c      **** 					 }
1242:../uvc.c      **** 			   }else{
1243:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1244:../uvc.c      **** 			   }
1245:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1246:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1247:../uvc.c      **** #endif
1248:../uvc.c      **** 
1249:../uvc.c      **** 			  break;
1250:../uvc.c      **** 		  default:
1251:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1252:../uvc.c      **** 			  break;
1253:../uvc.c      **** 		 }
1254:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1255:../uvc.c      **** }
1256:../uvc.c      **** /************** CT control requests handler *************************/
1257:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1258:../uvc.c      **** 
1259:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1260:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1261:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1262:../uvc.c      ****     uint16_t readCount;
1263:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1264:../uvc.c      ****     uint16_t diff, value, diffRd;
1265:../uvc.c      ****     uint8_t i, shutter, index;
1266:../uvc.c      ****     diff = 0xffff;
1267:../uvc.c      ****     shutter = 1;
1268:../uvc.c      ****     index = 1;
1269:../uvc.c      **** 
1270:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1271:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1272:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1273:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1274:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1275:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1276:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1277:../uvc.c      **** #endif
1278:../uvc.c      ****     reqData = bRequest;
1279:../uvc.c      **** 
1280:../uvc.c      ****     switch (bRequest)
1281:../uvc.c      **** 		 {
1282:../uvc.c      **** 
1283:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1284:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1285:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1286:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1287:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1288:../uvc.c      **** 			  break;
1289:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1290:../uvc.c      **** 
1291:../uvc.c      **** 			 switch(CtrlID)
1292:../uvc.c      **** 			 {
1293:../uvc.c      **** 				 default:
1294:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1295:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1296:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1297:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1298:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1299:../uvc.c      **** 					 break;
1300:../uvc.c      **** 			 }
1301:../uvc.c      **** 
1302:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1303:../uvc.c      **** 
1304:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1305:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1306:../uvc.c      **** #endif
1307:../uvc.c      **** 			  break;
1308:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1309:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1310:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1311:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1312:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1313:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1314:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1315:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1316:../uvc.c      **** 			  break;
1317:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1318:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1319:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1320:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1321:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1322:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1323:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1324:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1325:../uvc.c      **** 			  break;
1326:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1327:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1328:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1329:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1330:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1331:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1332:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1333:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1334:../uvc.c      **** 			  break;
1335:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1336:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1338:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1339:../uvc.c      **** 			  Len = 1;
1340:../uvc.c      **** 			  break;
1341:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1342:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1343:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1345:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1346:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1347:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1348:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1349:../uvc.c      **** 			  break;
1350:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1351:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1352:../uvc.c      **** 			  glEp0Buffer, &readCount);
1353:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1354:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1355:../uvc.c      **** 			  value = Data1;
1356:../uvc.c      **** 
1357:../uvc.c      **** 			  switch(CtrlID)
1358:../uvc.c      **** 			  {
1359:../uvc.c      **** 		  	      case AutoExMCtlID1:
1360:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1361:../uvc.c      **** 
1362:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1363:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1364:../uvc.c      **** 				    getData = glEp0Buffer[0];
1365:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1366:../uvc.c      **** 		  		    switch (getData){
1367:../uvc.c      **** 						case 1:
1368:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1369:../uvc.c      **** 							break;
1370:../uvc.c      **** 						case 2:
1371:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1372:../uvc.c      **** 							dataIdx = 0;
1373:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1374:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1375:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1376:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1377:../uvc.c      **** 
1378:../uvc.c      **** 							break;
1379:../uvc.c      **** 						case 4:
1380:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1381:../uvc.c      **** 							break;
1382:../uvc.c      **** 						case 8:
1383:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1384:../uvc.c      **** 			  		    	dataIdx = 0;
1385:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1386:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1387:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1388:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1389:../uvc.c      **** 							break;
1390:../uvc.c      **** 		  		    }
1391:../uvc.c      **** #if 0
1392:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1393:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1394:../uvc.c      **** 						  dataIdx = 0;
1395:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1396:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1397:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1398:../uvc.c      **** 		  		    }
1399:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1400:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1401:../uvc.c      **** 		  		    }
1402:../uvc.c      **** #endif
1403:../uvc.c      **** 				    break;
1404:../uvc.c      **** 
1405:../uvc.c      **** 			  	  case ExTmACtlID3:
1406:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1407:../uvc.c      **** 
1408:../uvc.c      **** 					  value = (value << 8)|Data0;
1409:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1410:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1411:../uvc.c      **** 					  {
1412:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1413:../uvc.c      **** 						  {
1414:../uvc.c      **** 							if(value > ShutValueArry[i]){
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1416:../uvc.c      **** 							}else{
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1418:../uvc.c      **** 							}
1419:../uvc.c      **** 							  if(diff > diffRd){
1420:../uvc.c      **** 								  diff = diffRd;
1421:../uvc.c      **** 								  index = i;
1422:../uvc.c      **** 							  }
1423:../uvc.c      **** 						  }
1424:../uvc.c      **** 						  shutter = shutter+index;
1425:../uvc.c      **** 
1426:../uvc.c      **** 						  dataIdx = 0;
1427:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1428:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1429:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1430:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1431:../uvc.c      **** 
1432:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1433:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1434:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1435:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1436:../uvc.c      **** 					  }else{
1437:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1438:../uvc.c      **** 					  }
1439:../uvc.c      **** 					  getData = glEp0Buffer[0];
1440:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1441:../uvc.c      **** 					  break;
1442:../uvc.c      **** 			  	  case IriACtlID7:
1443:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1444:../uvc.c      **** 					  {
1445:../uvc.c      **** 							 dataIdx = 0;
1446:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1447:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1448:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1449:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1450:../uvc.c      **** 
1451:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1452:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1453:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1454:../uvc.c      **** 					  }else{
1455:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1456:../uvc.c      **** 					  }
1457:../uvc.c      **** 					  getData = glEp0Buffer[0];
1458:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1459:../uvc.c      **** 
1460:../uvc.c      **** 					  break;
1461:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1462:../uvc.c      **** 					  getData = glEp0Buffer[0];
1463:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1464:../uvc.c      **** #if 1
1465:../uvc.c      **** 					  dataIdx = 0;
1466:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1467:../uvc.c      **** 					  if(getData == 1)
1468:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1469:../uvc.c      **** 					  else if(getData == 0xff)
1470:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1471:../uvc.c      **** 					  else
1472:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1473:../uvc.c      **** 					  //dataIdx++;
1474:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1475:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1476:../uvc.c      **** #endif
1477:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1478:../uvc.c      **** 					  break;
1479:../uvc.c      **** 
1480:../uvc.c      **** 			  	  default:
1481:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1482:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1483:../uvc.c      **** 			  		 break;
1484:../uvc.c      **** 			  }
1485:../uvc.c      **** 			  break;
1486:../uvc.c      **** 		  default:
1487:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1488:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1489:../uvc.c      **** 			  break;
1490:../uvc.c      **** 		 }
1491:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1492:../uvc.c      **** 
1493:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1494:../uvc.c      **** }
1495:../uvc.c      **** 
1496:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1497:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1498:../uvc.c      **** {
1499:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1500:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1501:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1502:../uvc.c      **** 
1503:../uvc.c      ****     CtrlID = BrgtCtlID1;
1504:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1505:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1506:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1507:../uvc.c      ****     Data1 = Data0;
1508:../uvc.c      **** 
1509:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1510:../uvc.c      ****     if(Data1&0x80){
1511:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1512:../uvc.c      ****     }else{
1513:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1514:../uvc.c      ****     }
1515:../uvc.c      ****     Data0 = (Data0 << 2);
1516:../uvc.c      **** 
1517:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1518:../uvc.c      **** 
1519:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1520:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1521:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1522:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1523:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1524:../uvc.c      **** 
1525:../uvc.c      ****     CtrlID = ConsCtlID2;
1526:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1527:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1528:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1529:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1530:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1531:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1532:../uvc.c      **** 
1533:../uvc.c      ****     CtrlID = HueCtlID5;
1534:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1535:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1536:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1537:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1540:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1541:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1542:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1543:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1544:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1545:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1546:../uvc.c      **** 
1547:../uvc.c      ****     CtrlID = SaturCtlID6;
1548:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1549:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1550:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1551:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1552:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1553:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1554:../uvc.c      **** 
1555:../uvc.c      ****     CtrlID = ShapCtlID7;
1556:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1557:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1558:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1559:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1560:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1561:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1562:../uvc.c      **** 
1563:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1564:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1565:../uvc.c      **** 	return;
1566:../uvc.c      **** }
1567:../uvc.c      **** 
1568:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1569:../uvc.c      **** void
1570:../uvc.c      **** CyFxUVCAddHeader (
1571:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1572:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1573:../uvc.c      ****         )
1574:../uvc.c      **** {
1575:../uvc.c      ****     /* Copy header to buffer */
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1577:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1578:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1579:../uvc.c      **** 
1580:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1581:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1582:../uvc.c      ****     {
1583:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1584:../uvc.c      ****     }
1585:../uvc.c      **** }
1586:../uvc.c      **** 
1587:../uvc.c      **** 
1588:../uvc.c      **** /* Application Error Handler */
1589:../uvc.c      **** void
1590:../uvc.c      **** CyFxAppErrorHandler (
1591:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1592:../uvc.c      ****         )
1593:../uvc.c      **** {
1594:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1595:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1596:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1597:../uvc.c      **** 
1598:../uvc.c      ****        This function can be modified to take additional error handling actions such
1599:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1600:../uvc.c      ****      */
1601:../uvc.c      ****     for (;;)
1602:../uvc.c      ****     {
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
1605:../uvc.c      ****     }
1606:../uvc.c      **** }
1607:../uvc.c      **** 
1608:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1609:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1610:../uvc.c      ****  */
1611:../uvc.c      **** static void
1612:../uvc.c      **** CyFxUVCApplnAbortHandler (
1613:../uvc.c      ****         void)
1614:../uvc.c      **** {
1615:../uvc.c      **** 	uint32_t flag;
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1617:../uvc.c      **** 	{
1618:../uvc.c      ****         /* Clear the Video Stream Request Event */
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1620:../uvc.c      **** 
1621:../uvc.c      ****         /* Set Video Stream Abort Event */
1622:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1623:../uvc.c      **** 	}
1624:../uvc.c      **** }
1625:../uvc.c      **** 
1626:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1627:../uvc.c      **** static void
1628:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1629:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1630:../uvc.c      ****         uint16_t             evdata  /* Event data */
1631:../uvc.c      ****         )
1632:../uvc.c      **** {
1633:../uvc.c      ****     switch (evtype)
1634:../uvc.c      ****     {
1635:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1636:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1637:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1638:../uvc.c      ****             gpif_initialized = 0;
1639:../uvc.c      ****             streamingStarted = CyFalse;
1640:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1641:../uvc.c      ****             break;
1642:../uvc.c      **** 
1643:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1644:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1645:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1646:../uvc.c      ****             gpif_initialized = 0;
1647:../uvc.c      ****             streamingStarted = CyFalse;
1648:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1649:../uvc.c      ****             break;
1650:../uvc.c      **** 
1651:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1652:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1653:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1654:../uvc.c      ****             gpif_initialized = 0;
1655:../uvc.c      ****             isUsbConnected = CyFalse;
1656:../uvc.c      ****             streamingStarted = CyFalse;
1657:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1658:../uvc.c      ****             break;
1659:../uvc.c      **** 
1660:../uvc.c      **** #ifdef BACKFLOW_DETECT
1661:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1662:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1663:../uvc.c      ****             break;
1664:../uvc.c      **** #endif
1665:../uvc.c      **** 
1666:../uvc.c      ****         default:
1667:../uvc.c      ****             break;
1668:../uvc.c      ****     }
1669:../uvc.c      **** }
1670:../uvc.c      **** 
1671:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1672:../uvc.c      **** static CyBool_t
1673:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1674:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1675:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1676:../uvc.c      ****         )
1677:../uvc.c      **** {
1678:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1679:../uvc.c      ****     uint32_t status;
1680:../uvc.c      **** 
1681:../uvc.c      ****     /* Obtain Request Type and Request */
1682:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1683:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1684:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1685:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1686:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1687:../uvc.c      **** 
1688:../uvc.c      ****     /* Check for UVC Class Requests */
1689:../uvc.c      ****     switch (bmReqType)
1690:../uvc.c      ****     {
1691:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1692:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1693:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1694:../uvc.c      ****             switch (wIndex & 0xFF)
1695:../uvc.c      ****             {
1696:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1697:../uvc.c      ****                     {
1698:../uvc.c      ****                         uvcHandleReq = CyTrue;
1699:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1700:../uvc.c      ****                                 CYU3P_EVENT_OR);
1701:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1702:../uvc.c      ****                         {
1703:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1704:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1705:../uvc.c      ****                         }
1706:../uvc.c      ****                     }
1707:../uvc.c      ****                     break;
1708:../uvc.c      **** 
1709:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1710:../uvc.c      ****                     {
1711:../uvc.c      ****                         uvcHandleReq = CyTrue;
1712:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1713:../uvc.c      ****                                 CYU3P_EVENT_OR);
1714:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1715:../uvc.c      ****                         {
1716:../uvc.c      ****                             /* Error handling */
1717:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1718:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1719:../uvc.c      ****                         }
1720:../uvc.c      ****                     }
1721:../uvc.c      ****                     break;
1722:../uvc.c      **** 
1723:../uvc.c      ****                 default:
1724:../uvc.c      ****                     break;
1725:../uvc.c      ****             }
1726:../uvc.c      ****             break;
1727:../uvc.c      **** 
1728:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1729:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1730:../uvc.c      ****             {
1731:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1732:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1733:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1734:../uvc.c      ****                 {
1735:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1736:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1737:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1738:../uvc.c      ****                     gpif_initialized = 0;
1739:../uvc.c      ****                     streamingStarted = CyFalse;
1740:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1741:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1742:../uvc.c      ****                     CyU3PBusyWait (100);
1743:../uvc.c      **** 
1744:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1745:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1746:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1747:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1748:../uvc.c      ****                     CyU3PBusyWait (100);
1749:../uvc.c      **** 
1750:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1751:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1752:../uvc.c      ****                     uvcHandleReq = CyTrue;
1753:../uvc.c      ****                     /* Complete Control request handshake */
1754:../uvc.c      ****                     CyU3PUsbAckSetup ();
1755:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1756:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1757:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1758:../uvc.c      **** 
1759:../uvc.c      ****                 }
1760:../uvc.c      ****             }
1761:../uvc.c      ****             break;
1762:../uvc.c      **** 
1763:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1764:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1765:../uvc.c      ****             {
1766:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1767:../uvc.c      ****                 {
1768:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1769:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1770:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1771:../uvc.c      ****                 	 * has started. */
1772:../uvc.c      ****                     if (streamingStarted == CyTrue)
1773:../uvc.c      ****                     {
1774:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1775:../uvc.c      **** 
1776:../uvc.c      ****                         /* Disable the GPIF state machine. */
1777:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1778:../uvc.c      ****                         gpif_initialized = 0;
1779:../uvc.c      ****                         streamingStarted = CyFalse;
1780:../uvc.c      **** 
1781:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1782:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1783:../uvc.c      ****                         CyU3PBusyWait (100);
1784:../uvc.c      **** 
1785:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1786:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1787:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1788:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1789:../uvc.c      ****                         CyU3PBusyWait (100);
1790:../uvc.c      **** 
1791:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1792:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1793:../uvc.c      **** 
1794:../uvc.c      ****                         uvcHandleReq = CyTrue;
1795:../uvc.c      ****                         /* Complete Control request handshake */
1796:../uvc.c      ****                         CyU3PUsbAckSetup ();
1797:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1798:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1799:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1800:../uvc.c      ****                     }
1801:../uvc.c      ****                     else
1802:../uvc.c      ****                     {
1803:../uvc.c      ****                         uvcHandleReq = CyTrue;
1804:../uvc.c      ****                         CyU3PUsbAckSetup ();
1805:../uvc.c      ****                     }
1806:../uvc.c      ****                 }
1807:../uvc.c      ****             }
1808:../uvc.c      ****             break;
1809:../uvc.c      **** 
1810:../uvc.c      ****         default:
1811:../uvc.c      ****             break;
1812:../uvc.c      ****     }
1813:../uvc.c      **** 
1814:../uvc.c      ****     /* Return status of request handling to the USB driver */
1815:../uvc.c      ****     return uvcHandleReq;
1816:../uvc.c      **** }
1817:../uvc.c      **** 
1818:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1819:../uvc.c      **** 
1820:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1821:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1822:../uvc.c      ****  */
1823:../uvc.c      **** void
1824:../uvc.c      **** CyFxUvcApplnDmaCallback (
1825:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1826:../uvc.c      ****         CyU3PDmaCbType_t      type,
1827:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1828:../uvc.c      ****         )
1829:../uvc.c      **** {
1830:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1831:../uvc.c      **** #if 1
1832:../uvc.c      ****     CyU3PReturnStatus_t status;
1833:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1834:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1835:../uvc.c      **** 
1836:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1837:../uvc.c      ****     {
1838:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1839:../uvc.c      ****             {
1840:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
1841:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
1842:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1843:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
1844:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1845:../uvc.c      ****                 	stiflag = 0x03;
1846:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
1847:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1848:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1849:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1850:../uvc.c      ****                 }
1851:../uvc.c      **** #endif
1852:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
1853:../uvc.c      ****                 fb++;
1854:../uvc.c      ****             }
1855:../uvc.c      ****             else
1856:../uvc.c      ****             {
1857:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1858:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1859:../uvc.c      ****                 pb++;
1860:../uvc.c      ****                 pbc = input->buffer_p.count;
1861:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1862:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1863:../uvc.c      ****                 //lineCount = 0; //res test
1864:../uvc.c      **** #if 1   //remove the still flag clearing here
1865:../uvc.c      ****                 if(stiflag == 0x0F){
1866:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1867:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1868:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1869:../uvc.c      ****                 	stiflag = 0xAA;
1870:../uvc.c      ****                 }
1871:../uvc.c      **** #endif
1872:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1873:../uvc.c      ****             }
1874:../uvc.c      **** 
1875:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1876:../uvc.c      ****             prodCount++;
1877:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1878:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1879:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1880:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1881:../uvc.c      ****             {
1882:../uvc.c      ****                 prodCount--;
1883:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1884:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1885:../uvc.c      ****             }
1886:../uvc.c      ****     }
1887:../uvc.c      **** #endif
1888:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1889:../uvc.c      ****     {
1890:../uvc.c      ****         consCount++;
1891:../uvc.c      ****         streamingStarted = CyTrue;
1892:../uvc.c      ****     }
1893:../uvc.c      **** }
1894:../uvc.c      **** 
1895:../uvc.c      **** /*
1896:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1897:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1898:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1899:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1900:../uvc.c      ****  * to commit the buffer.
1901:../uvc.c      ****  */
1902:../uvc.c      **** static uint8_t
1903:../uvc.c      **** CyFxUvcAppCommitEOF (
1904:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1905:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1906:../uvc.c      ****         )
1907:../uvc.c      **** {
1908:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1909:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1910:../uvc.c      **** 
1911:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1912:../uvc.c      **** 
1913:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1914:../uvc.c      ****     {
1915:../uvc.c      ****         switch (stateId)
1916:../uvc.c      ****         {
1917:../uvc.c      **** 
1918:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1919:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1920:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1921:../uvc.c      ****                 break;
1922:../uvc.c      **** 
1923:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1924:../uvc.c      ****                 socket = 0;
1925:../uvc.c      ****                 break;
1926:../uvc.c      **** 
1927:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1928:../uvc.c      ****                 socket = 1;
1929:../uvc.c      ****                 break;
1930:../uvc.c      **** 
1931:../uvc.c      ****             default:
1932:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1933:../uvc.c      ****                 /* Unexpected current state. Return error. */
1934:../uvc.c      ****             	//lineCount++;
1935:../uvc.c      ****             	return 1;
1936:../uvc.c      ****         }
1937:../uvc.c      ****     }
1938:../uvc.c      **** 
1939:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1940:../uvc.c      ****     {
1941:../uvc.c      ****         switch (stateId)
1942:../uvc.c      ****         {
1943:../uvc.c      **** #ifndef CAM720
1944:../uvc.c      **** #ifdef GPIFIIM
1945:../uvc.c      ****             case 13:
1946:../uvc.c      ****             case 24:
1947:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1948:../uvc.c      ****                 break;
1949:../uvc.c      **** 
1950:../uvc.c      ****             case 8:
1951:../uvc.c      ****                 socket = 0;
1952:../uvc.c      ****                 break;
1953:../uvc.c      **** 
1954:../uvc.c      ****             case 20:
1955:../uvc.c      ****                 socket = 1;
1956:../uvc.c      ****                 break;
1957:../uvc.c      **** #else
1958:../uvc.c      ****             case 11:
1959:../uvc.c      ****             case 18:
1960:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1961:../uvc.c      ****                 break;
1962:../uvc.c      **** 
1963:../uvc.c      ****             case 8:
1964:../uvc.c      ****                 socket = 0;
1965:../uvc.c      ****                 break;
1966:../uvc.c      **** 
1967:../uvc.c      ****             case 15:
1968:../uvc.c      ****                 socket = 1;
1969:../uvc.c      ****                 break;
1970:../uvc.c      **** #endif
1971:../uvc.c      **** #else
1972:../uvc.c      ****             case 11:
1973:../uvc.c      ****             case 18:
1974:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1975:../uvc.c      ****                 break;
1976:../uvc.c      **** 
1977:../uvc.c      ****             case 8:
1978:../uvc.c      ****                 socket = 0;
1979:../uvc.c      ****                 break;
1980:../uvc.c      **** 
1981:../uvc.c      ****             case 15:
1982:../uvc.c      ****                 socket = 1;
1983:../uvc.c      ****                 break;
1984:../uvc.c      **** 
1985:../uvc.c      **** #endif
1986:../uvc.c      ****              default:
1987:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1988:../uvc.c      ****                 /* Unexpected current state. Return error. */
1989:../uvc.c      ****                return 1;
1990:../uvc.c      ****         }
1991:../uvc.c      ****     }
1992:../uvc.c      **** 
1993:../uvc.c      ****     if (socket != 0xFF)
1994:../uvc.c      ****     {
1995:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1996:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1997:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1998:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1999:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2000:../uvc.c      ****         {
2001:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2002:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2003:../uvc.c      ****         }
2004:../uvc.c      ****     }
2005:../uvc.c      **** 
2006:../uvc.c      ****     return 0;
2007:../uvc.c      **** }
2008:../uvc.c      **** 
2009:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2010:../uvc.c      **** void
2011:../uvc.c      **** CyFxGpifCB (
2012:../uvc.c      ****         CyU3PGpifEventType event,
2013:../uvc.c      ****         uint8_t currentState
2014:../uvc.c      ****         )
2015:../uvc.c      **** {
2016:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2017:../uvc.c      ****     {
2018:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2019:../uvc.c      ****     	           in the UVC implementation. */
2020:../uvc.c      ****     	//hitFV = CyTrue;
2021:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2022:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2023:../uvc.c      ****     }
2024:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2025:../uvc.c      **** }
2026:../uvc.c      **** 
2027:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2028:../uvc.c      **** static void
2029:../uvc.c      **** CyFxUVCApplnDebugInit (
2030:../uvc.c      ****         void)
2031:../uvc.c      **** {
2032:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2033:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2034:../uvc.c      **** 
2035:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2036:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2037:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2038:../uvc.c      ****     {
2039:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2040:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2041:../uvc.c      ****     }
2042:../uvc.c      **** 
2043:../uvc.c      ****     /* Set UART Configuration */
2044:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2045:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2046:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2047:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2048:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2049:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2050:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2051:../uvc.c      **** 
2052:../uvc.c      ****     /* Set the UART configuration */
2053:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2054:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2055:../uvc.c      ****     {
2056:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2057:../uvc.c      ****     }
2058:../uvc.c      **** 
2059:../uvc.c      ****     /* Set the UART transfer */
2060:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2061:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2062:../uvc.c      ****     {
2063:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2064:../uvc.c      ****     }
2065:../uvc.c      **** 
2066:../uvc.c      ****     /* Initialize the Debug logger module. */
2067:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2068:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2069:../uvc.c      ****     {
2070:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2071:../uvc.c      ****     }
2072:../uvc.c      **** 
2073:../uvc.c      ****     /* Disable log message headers. */
2074:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2075:../uvc.c      **** }
2076:../uvc.c      **** 
2077:../uvc.c      **** /* I2C initialization. */
2078:../uvc.c      **** static void
2079:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2080:../uvc.c      **** {
2081:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2082:../uvc.c      ****     CyU3PReturnStatus_t status;
2083:../uvc.c      **** 
2084:../uvc.c      ****     status = CyU3PI2cInit ();
2085:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2086:../uvc.c      ****     {
2087:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2088:../uvc.c      ****         CyFxAppErrorHandler (status);
2089:../uvc.c      ****     }
2090:../uvc.c      **** 
2091:../uvc.c      ****     /*  Set I2C Configuration */
2092:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2093:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2094:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2095:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2096:../uvc.c      **** 
2097:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2098:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2099:../uvc.c      ****     {
2100:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2101:../uvc.c      ****         CyFxAppErrorHandler (status);
2102:../uvc.c      ****     }
2103:../uvc.c      **** }
2104:../uvc.c      **** 
2105:../uvc.c      **** #ifdef BACKFLOW_DETECT
2106:../uvc.c      **** static void CyFxUvcAppPibCallback (
2107:../uvc.c      ****         CyU3PPibIntrType cbType,
2108:../uvc.c      ****         uint16_t cbArg)
2109:../uvc.c      **** {
2110:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2111:../uvc.c      ****     {
2112:../uvc.c      ****         if (!back_flow_detected)
2113:../uvc.c      ****         {
2114:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2115:../uvc.c      ****             back_flow_detected = 1;
2116:../uvc.c      ****         }
2117:../uvc.c      ****     }
2118:../uvc.c      **** }
2119:../uvc.c      **** #endif
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2122:../uvc.c      **** static void
2123:../uvc.c      **** CyFxUvcAppDebugCallback (
2124:../uvc.c      ****         CyU3PDmaChannel   *handle,
2125:../uvc.c      ****         CyU3PDmaCbType_t   type,
2126:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2127:../uvc.c      **** {
2128:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2129:../uvc.c      ****     {
2130:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2131:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2132:../uvc.c      ****     }
2133:../uvc.c      **** }
2134:../uvc.c      **** #endif
2135:../uvc.c      **** 
2136:../uvc.c      **** #if 0
2137:../uvc.c      **** static void CyFxAppIntEpCb(
2138:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2139:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2140:../uvc.c      **** 		uint8_t  ebNum)
2141:../uvc.c      **** 		{
2142:../uvc.c      **** 			//CyBool_t value;
2143:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2144:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2145:../uvc.c      **** 
2146:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2147:../uvc.c      **** 		}
2148:../uvc.c      **** #endif
2149:../uvc.c      **** 
2150:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2151:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2152:../uvc.c      ****    configures the DMA module for the UVC Application */
2153:../uvc.c      **** static void
2154:../uvc.c      **** CyFxUVCApplnInit (void)
2155:../uvc.c      **** {
2156:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2157:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2158:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2159:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2160:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2161:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2162:../uvc.c      **** 
2163:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2164:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2165:../uvc.c      **** 
2166:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2167:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2168:../uvc.c      **** #endif
2169:../uvc.c      **** 
2170:../uvc.c      ****     /* Create UVC event group */
2171:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2172:../uvc.c      ****     if (apiRetStatus != 0)
2173:../uvc.c      ****     {
2174:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2175:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2176:../uvc.c      ****     }
2177:../uvc.c      **** 
2178:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2179:../uvc.c      ****     CyFxUvcAppPTZInit ();
2180:../uvc.c      **** #endif
2181:../uvc.c      **** 
2182:../uvc.c      ****     isUsbConnected = CyFalse;
2183:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2184:../uvc.c      **** 
2185:../uvc.c      ****     /* Init the GPIO module */
2186:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2187:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2188:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2189:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2190:../uvc.c      ****     gpioClock.halfDiv    = 0;
2191:../uvc.c      **** 
2192:../uvc.c      ****     /* Initialize Gpio interface */
2193:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2194:../uvc.c      ****     if (apiRetStatus != 0)
2195:../uvc.c      ****     {
2196:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2197:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2198:../uvc.c      ****     }
2199:../uvc.c      **** 
2200:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2201:../uvc.c      ****      * must use GpioOverride to configure it */
2202:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2203:../uvc.c      ****     if (apiRetStatus != 0)
2204:../uvc.c      ****     {
2205:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2206:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2207:../uvc.c      ****     }
2208:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2209:../uvc.c      ****     if (apiRetStatus != 0)
2210:../uvc.c      ****     {
2211:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2212:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2213:../uvc.c      ****     }
2214:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2215:../uvc.c      ****     if (apiRetStatus != 0)
2216:../uvc.c      ****     {
2217:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2218:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2219:../uvc.c      ****     }
2220:../uvc.c      **** 
2221:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2222:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2223:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2224:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2225:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2226:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2227:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2228:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2229:../uvc.c      ****     {
2230:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2231:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2232:../uvc.c      ****     }
2233:../uvc.c      **** 
2234:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2235:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2236:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2237:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2238:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2239:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2240:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2241:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2242:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2243:../uvc.c      ****     {
2244:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2245:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2246:../uvc.c      ****     }
2247:../uvc.c      **** 
2248:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2249:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2250:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2251:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2252:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2253:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2254:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2255:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2256:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2257:../uvc.c      ****     {
2258:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2259:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2260:../uvc.c      ****     }
2261:../uvc.c      **** 
2262:../uvc.c      ****     /* Initialize the P-port. */
2263:../uvc.c      ****     pibclock.clkDiv      = 2;
2264:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2265:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2266:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2267:../uvc.c      **** 
2268:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2269:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2270:../uvc.c      ****     {
2271:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2272:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2273:../uvc.c      ****     }
2274:../uvc.c      **** 
2275:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2276:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2277:../uvc.c      **** 
2278:../uvc.c      **** #ifdef BACKFLOW_DETECT
2279:../uvc.c      ****     back_flow_detected = 0;
2280:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2281:../uvc.c      **** #endif
2282:../uvc.c      **** 
2283:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2284:../uvc.c      ****     SensorReset ();
2285:../uvc.c      ****     CyU3PThreadSleep(5000);
2286:../uvc.c      ****     //SensorInit ();
2287:../uvc.c      **** 
2288:../uvc.c      ****     /* USB initialization. */
2289:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2290:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2291:../uvc.c      ****     {
2292:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2293:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2294:../uvc.c      ****     }
2295:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2296:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2297:../uvc.c      **** 
2298:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2299:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2300:../uvc.c      **** 
2301:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2302:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2303:../uvc.c      **** 
2304:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2305:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2306:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2307:../uvc.c      **** 
2308:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2309:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2310:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2311:../uvc.c      **** 
2312:../uvc.c      ****     /* Configuration descriptors. */
2313:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2314:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2315:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2316:../uvc.c      **** 
2317:../uvc.c      ****     /* String Descriptors */
2318:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2319:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2320:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2321:../uvc.c      **** 
2322:../uvc.c      ****     /* Configure the status interrupt endpoint.
2323:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2324:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2325:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2326:../uvc.c      ****      */
2327:../uvc.c      ****     endPointConfig.enable   = 1;
2328:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2329:../uvc.c      ****     endPointConfig.pcktSize = 64;
2330:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2331:../uvc.c      ****     endPointConfig.streams  = 0;
2332:../uvc.c      ****     endPointConfig.burstLen = 1;
2333:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2334:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2335:../uvc.c      ****     {
2336:../uvc.c      ****         /* Error Handling */
2337:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2338:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2339:../uvc.c      ****     }
2340:../uvc.c      **** 
2341:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2342:../uvc.c      ****     dmaInterConfig.size           = 1024;
2343:../uvc.c      ****     dmaInterConfig.count          = 1;
2344:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2345:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2346:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2347:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2348:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2349:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2350:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2351:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2352:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2353:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2354:../uvc.c      ****             &dmaInterConfig);
2355:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2356:../uvc.c      ****     {
2357:../uvc.c      ****         /* Error handling */
2358:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2359:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2360:../uvc.c      ****     }
2361:../uvc.c      **** 
2362:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2363:../uvc.c      ****     if (glInterStaBuffer == 0)
2364:../uvc.c      ****     {
2365:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2366:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2367:../uvc.c      ****     }
2368:../uvc.c      **** 
2369:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2370:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2371:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2372:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2373:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2374:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2375:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2376:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2377:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2378:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2379:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2380:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2381:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2382:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2383:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2384:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2385:../uvc.c      ****             &dmaMultiConfig);
2386:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2387:../uvc.c      ****     {
2388:../uvc.c      ****         /* Error handling */
2389:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2390:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2391:../uvc.c      ****     }
2392:../uvc.c      **** 
2393:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2394:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2395:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2396:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2397:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2398:../uvc.c      ****      */
2399:../uvc.c      **** 
2400:../uvc.c      ****     endPointConfig.enable   = 1;
2401:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2402:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2403:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2404:../uvc.c      ****     endPointConfig.streams  = 0;
2405:../uvc.c      ****     endPointConfig.burstLen = 1;
2406:../uvc.c      **** 
2407:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2408:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2409:../uvc.c      ****     {
2410:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2411:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2412:../uvc.c      ****     }
2413:../uvc.c      **** 
2414:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2415:../uvc.c      **** 
2416:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2417:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2418:../uvc.c      ****     {
2419:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2420:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2421:../uvc.c      ****     }
2422:../uvc.c      **** 
2423:../uvc.c      ****     channelConfig.size           = 1024;
2424:../uvc.c      ****     channelConfig.count          = 1;
2425:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2426:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2427:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2428:../uvc.c      ****     channelConfig.prodHeader     = 0;
2429:../uvc.c      ****     channelConfig.prodFooter     = 0;
2430:../uvc.c      ****     channelConfig.consHeader     = 0;
2431:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2432:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2433:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2434:../uvc.c      **** 
2435:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2436:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2437:../uvc.c      ****     {
2438:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2439:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2440:../uvc.c      ****     }
2441:../uvc.c      **** 
2442:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2443:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2444:../uvc.c      ****     {
2445:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2446:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2447:../uvc.c      ****     }
2448:../uvc.c      **** 
2449:../uvc.c      ****     channelConfig.size           = 1024;
2450:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2451:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2452:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2453:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2454:../uvc.c      ****     channelConfig.prodHeader     = 0;
2455:../uvc.c      ****     channelConfig.prodFooter     = 0;
2456:../uvc.c      ****     channelConfig.consHeader     = 0;
2457:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2458:../uvc.c      ****     channelConfig.notification   = 0;
2459:../uvc.c      ****     channelConfig.cb             = 0;
2460:../uvc.c      **** 
2461:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2463:../uvc.c      ****     {
2464:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2465:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2466:../uvc.c      ****     }
2467:../uvc.c      **** 
2468:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2469:../uvc.c      ****     if (glDebugRspBuffer == 0)
2470:../uvc.c      ****     {
2471:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2472:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2473:../uvc.c      ****     }
2474:../uvc.c      **** #endif
2475:../uvc.c      **** 
2476:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2477:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2478:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2479:../uvc.c      ****     {
2480:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2481:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2482:../uvc.c      ****     }
2483:../uvc.c      **** 
2484:../uvc.c      ****     CyU3PBusyWait(100);
2485:../uvc.c      **** 
2486:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2487:../uvc.c      **** 
2488:../uvc.c      ****     endPointConfig.enable   = 1;
2489:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2490:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2491:../uvc.c      ****     {
2492:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2493:../uvc.c      ****     	endPointConfig.burstLen = 16;
2494:../uvc.c      ****     }
2495:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2496:../uvc.c      ****     {
2497:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2498:../uvc.c      ****     	endPointConfig.burstLen = 1;
2499:../uvc.c      ****     }
2500:../uvc.c      ****     endPointConfig.streams  = 0;
2501:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2502:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2503:../uvc.c      ****     {
2504:../uvc.c      ****         /* Error Handling */
2505:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2506:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2507:../uvc.c      ****     }
2508:../uvc.c      **** #if 0    //for still image method 3 using
2509:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2510:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2511:../uvc.c      ****     {
2512:../uvc.c      ****         /* Error Handling */
2513:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2514:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2515:../uvc.c      ****     }
2516:../uvc.c      **** #endif
2517:../uvc.c      **** 
2518:../uvc.c      **** }
2519:../uvc.c      **** 
2520:../uvc.c      **** /*
2521:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2522:../uvc.c      ****  * streaming session is started.
2523:../uvc.c      ****  */
2524:../uvc.c      **** static void
2525:../uvc.c      **** CyFxUvcAppGpifInit (
2526:../uvc.c      ****         void)
2527:../uvc.c      **** {
2528:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2529:../uvc.c      **** 
2530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2531:../uvc.c      ****     {
2532:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2533:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2534:../uvc.c      ****     }
2535:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2536:../uvc.c      ****     {
2537:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2538:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2539:../uvc.c      ****     }
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         /* Error Handling */
2543:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2544:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2545:../uvc.c      ****     }
2546:../uvc.c      **** 
2547:../uvc.c      ****     /* Start the state machine from the designated start state. */
2548:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2549:../uvc.c      ****     {
2550:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2551:../uvc.c      ****     }
2552:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2553:../uvc.c      ****     {
2554:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2555:../uvc.c      ****     }
2556:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2557:../uvc.c      ****     {
2558:../uvc.c      ****         /* Error Handling */
2559:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2560:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2561:../uvc.c      ****     }
2562:../uvc.c      **** }
2563:../uvc.c      **** 
2564:../uvc.c      **** /*
2565:../uvc.c      ****  * Entry function for the UVC Application Thread
2566:../uvc.c      ****  */
2567:../uvc.c      **** 
2568:../uvc.c      **** uint32_t posTick;
2569:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2570:../uvc.c      **** 
2571:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2572:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2573:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2574:../uvc.c      **** }
2575:../uvc.c      **** 
2576:../uvc.c      **** 
2577:../uvc.c      **** void
2578:../uvc.c      **** UVCAppThread_Entry (
2579:../uvc.c      ****         uint32_t input)
2580:../uvc.c      **** {
2581:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2582:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2583:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2584:../uvc.c      ****     uint8_t i = 0;
2585:../uvc.c      ****     uint32_t flag;
2586:../uvc.c      ****     uint32_t prinflag = 0;
2587:../uvc.c      **** static uint8_t IMcount = 0;
2588:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2589:../uvc.c      ****     uint32_t frameCnt = 0;
2590:../uvc.c      **** #endif
2591:../uvc.c      ****     /* Initialize the Uart Debug Module */
2592:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2593:../uvc.c      **** 
2594:../uvc.c      ****     /* Initialize the I2C interface */
2595:../uvc.c      **** 	while (i++ < 6){
2596:../uvc.c      **** 		CyU3PThreadSleep(500);
2597:../uvc.c      **** 	}
2598:../uvc.c      **** 
2599:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2600:../uvc.c      **** 
2601:../uvc.c      ****     /* Initialize the UVC Application */
2602:../uvc.c      ****     CyFxUVCApplnInit ();
2603:../uvc.c      ****     /*
2604:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2605:../uvc.c      **** 
2606:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2607:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2608:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2609:../uvc.c      **** 
2610:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2611:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2612:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2613:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2614:../uvc.c      **** 
2615:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2616:../uvc.c      ****        of handling the abort request.
2617:../uvc.c      ****      */
2618:../uvc.c      **** 
2619:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2620:../uvc.c      ****     //CyU3PThreadSleep(1000);
2621:../uvc.c      **** 
2622:../uvc.c      ****     for (;;)
2623:../uvc.c      ****     {
2624:../uvc.c      ****         /* Waiting for the Video Stream Event */
2625:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2626:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2627:../uvc.c      ****         {
2628:../uvc.c      **** #if 0 //test for new firmware no video bring up
2629:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2630:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2631:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2632:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2633:../uvc.c      ****             {
2634:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2635:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2636:../uvc.c      ****                 {
2637:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2638:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2639:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2640:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2641:../uvc.c      **** #endif
2642:../uvc.c      **** #endif
2643:../uvc.c      ****                     }
2644:../uvc.c      ****                 else
2645:../uvc.c      ****                 {
2646:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2647:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2648:../uvc.c      **** #ifdef USB_LOWRES_IMG
2649:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2650:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2651:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2652:../uvc.c      **** #endif
2653:../uvc.c      **** #endif
2654:../uvc.c      ****                 }
2655:../uvc.c      **** 
2656:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2657:../uvc.c      ****                 prodCount++;
2658:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2659:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2660:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2661:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2662:../uvc.c      ****                 {
2663:../uvc.c      ****                     prodCount--;
2664:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2665:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2666:../uvc.c      ****                 }
2667:../uvc.c      ****             }
2668:../uvc.c      **** #endif
2669:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2670:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2671:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2672:../uvc.c      ****             {
2673:../uvc.c      ****             	if(0&&(prinflag == 0)){
2674:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2675:../uvc.c      ****             		prinflag = 1;
2676:../uvc.c      ****             	}
2677:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2678:../uvc.c      ****             	fb=0;
2679:../uvc.c      ****             	pb=0;
2680:../uvc.c      ****             	pbc=0;
2681:../uvc.c      ****                 prodCount = 0;
2682:../uvc.c      ****                 consCount = 0;
2683:../uvc.c      ****                 hitFV     = CyFalse;
2684:../uvc.c      **** 
2685:../uvc.c      **** #ifdef BACKFLOW_DETECT
2686:../uvc.c      ****                 back_flow_detected = 0;
2687:../uvc.c      **** #endif
2688:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2689:../uvc.c      ****                 frameCnt++;
2690:../uvc.c      **** #endif
2691:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2692:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2693:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2694:../uvc.c      ****                 //}
2695:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2696:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2697:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2698:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2699:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2700:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2701:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2702:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2703:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2704:../uvc.c      ****                 		stiflag = 0xFF;
2705:../uvc.c      ****                 		IMcount = 0;
2706:../uvc.c      ****                 	}
2707:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2708:../uvc.c      **** 
2709:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2710:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2711:../uvc.c      ****                 		stiflag = 0x0F;
2712:../uvc.c      ****                 		IMcount = 0;
2713:../uvc.c      ****                 		}
2714:../uvc.c      ****                  		/*if(IMcount > 0x4){
2715:../uvc.c      ****                 			stiflag = 0x0F;
2716:../uvc.c      ****                 			IMcount = 0;
2717:../uvc.c      ****                 		}*/
2718:../uvc.c      **** 
2719:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2720:../uvc.c      ****                     //CyU3PThreadSleep(400);
2721:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2722:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2723:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2724:../uvc.c      **** 
2725:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2726:../uvc.c      ****                 	{
2727:../uvc.c      ****                     switch (setRes)
2728:../uvc.c      ****                      {
2729:../uvc.c      ****                  	case 1: //1944
2730:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2731:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2732:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x64:0xE
2733:../uvc.c      ****                  		break;
2734:../uvc.c      ****                  	case 2: //1080
2735:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2736:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2737:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x54:0xD
2738:../uvc.c      ****                  		break;
2739:../uvc.c      ****                  	case 3: //720
2740:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2741:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2742:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 0x45:0
2743:../uvc.c      ****                  		break;
2744:../uvc.c      ****                  	default:
2745:../uvc.c      ****                  		break;
2746:../uvc.c      ****                      }
2747:../uvc.c      ****                     IMcount = 0;
2748:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2749:../uvc.c      ****                 	stiflag = 0x0;
2750:../uvc.c      ****                 	}
2751:../uvc.c      ****                 }
2752:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2753:../uvc.c      ****                 /* Reset the DMA channel. */
2754:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2755:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2756:../uvc.c      ****                 {
2757:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2758:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2759:../uvc.c      ****                 }
2760:../uvc.c      **** 
2761:../uvc.c      ****                 /* Start Channel Immediately */
2762:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2763:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2764:../uvc.c      ****                 {
2765:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2766:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2767:../uvc.c      ****                 }
2768:../uvc.c      **** 
2769:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2770:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2771:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2772:../uvc.c      ****                 }
2773:../uvc.c      ****         }
2774:../uvc.c      ****         else
2775:../uvc.c      ****         {
2776:../uvc.c      ****             /* If we have a stream abort request pending. */
2777:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2778:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2779:../uvc.c      ****             {
2780:../uvc.c      ****                 hitFV     = CyFalse;
2781:../uvc.c      ****                 prodCount = 0;
2782:../uvc.c      ****                 consCount = 0;
2783:../uvc.c      ****                 if(0&&(prinflag == 0)){
2784:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2785:../uvc.c      ****                 	prinflag = 1;
2786:../uvc.c      ****                 }
2787:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2788:../uvc.c      ****                 fb=0;
2789:../uvc.c      ****                 pb=0;
2790:../uvc.c      ****                 pbc=0;
2791:../uvc.c      **** 
2792:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2793:../uvc.c      ****                 {
2794:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2795:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2796:../uvc.c      ****                     {
2797:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2798:../uvc.c      ****                     }
2799:../uvc.c      **** 
2800:../uvc.c      ****                     /* Flush the Endpoint memory */
2801:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2802:../uvc.c      ****                 }
2803:../uvc.c      **** 
2804:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2805:../uvc.c      ****             }
2806:../uvc.c      ****             else
2807:../uvc.c      ****             {
2808:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2809:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2810:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2811:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2812:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2813:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2814:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2815:../uvc.c      ****                 {
2816:../uvc.c      ****                     /* Error handling */
2817:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2818:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2819:../uvc.c      ****                 }
2820:../uvc.c      **** 
2821:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2822:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2823:../uvc.c      ****                 {
2824:../uvc.c      **** #if 0
2825:../uvc.c      ****                 	//for start up of the AF Lens
2826:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2827:../uvc.c      ****                     CyU3PThreadSleep(500);
2828:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2829:../uvc.c      ****                     CyU3PThreadSleep(500);
2830:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2831:../uvc.c      ****                    	CyU3PThreadSleep(300);
2832:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2833:../uvc.c      ****                     CyU3PThreadSleep(500);
2834:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2835:../uvc.c      ****                     CyU3PThreadSleep(500);
2836:../uvc.c      **** #endif
2837:../uvc.c      **** #if 0
2838:../uvc.c      ****                     switch (setRes)
2839:../uvc.c      ****                     {
2840:../uvc.c      ****                     	case 1: //1944
2841:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2842:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2843:../uvc.c      ****                     		break;
2844:../uvc.c      ****                     	case 2: //1080
2845:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2846:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2847:../uvc.c      ****                     		break;
2848:../uvc.c      ****                     	case 3: //720
2849:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2850:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2851:../uvc.c      ****                     		break;
2852:../uvc.c      ****                     	default:
2853:../uvc.c      ****                     		break;
2854:../uvc.c      ****                     }
2855:../uvc.c      **** #endif
2856:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2857:../uvc.c      **** 
2858:../uvc.c      ****                     gpif_initialized = CyTrue;
2859:../uvc.c      ****                     CyU3PThreadSleep(200);
2860:../uvc.c      ****                     
2861:../uvc.c      ****                 }
2862:../uvc.c      ****                 else
2863:../uvc.c      ****                 {
2864:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2865:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2866:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2867:../uvc.c      ****                 }
2868:../uvc.c      ****             }
2869:../uvc.c      ****         }
2870:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2871:../uvc.c      **** 
2872:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2873:../uvc.c      ****         CyU3PThreadRelinquish ();
2874:../uvc.c      ****     }
2875:../uvc.c      **** }
2876:../uvc.c      **** 
2877:../uvc.c      **** /*
2878:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2879:../uvc.c      ****  */
2880:../uvc.c      **** 
2881:../uvc.c      **** static void
2882:../uvc.c      **** UVCHandleProcessingUnitRqts (
2883:../uvc.c      ****         void)
2884:../uvc.c      **** {
2885:../uvc.c      ****     uint8_t CtrlAdd;
2886:../uvc.c      **** #ifdef DbgInfo
2887:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2888:../uvc.c      **** #endif
2889:../uvc.c      ****     switch (wValue)
2890:../uvc.c      ****     {
2891:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2892:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2893:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2894:../uvc.c      ****     		break;
2895:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2896:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2897:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2898:../uvc.c      ****     		break;
2899:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2900:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2901:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2902:../uvc.c      **** 			break;
2903:../uvc.c      **** 
2904:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2905:../uvc.c      **** 
2906:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2907:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2908:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2909:../uvc.c      ****       		break;
2910:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2911:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2912:../uvc.c      ****      		ControlHandle(HueCtlID5);
2913:../uvc.c      ****      		break;
2914:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2915:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2916:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2917:../uvc.c      ****           		break;
2918:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2919:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2920:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2921:../uvc.c      ****           		break;
2922:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2923:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2924:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2925:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2926:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2927:../uvc.c      ****     		break;
2928:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2929:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2930:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2931:../uvc.c      ****     		break;
2932:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2933:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2934:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2935:../uvc.c      ****     		break;
2936:../uvc.c      **** 
2937:../uvc.c      ****         default:
2938:../uvc.c      ****             /*
2939:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2940:../uvc.c      ****              * other controls.
2941:../uvc.c      ****              */
2942:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2943:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2944:../uvc.c      ****             break;
2945:../uvc.c      ****     }
2946:../uvc.c      **** }
2947:../uvc.c      **** 
2948:../uvc.c      **** /*
2949:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2950:../uvc.c      ****  */
2951:../uvc.c      **** static void
2952:../uvc.c      **** UVCHandleCameraTerminalRqts (
2953:../uvc.c      ****         void)
2954:../uvc.c      **** {
2955:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2956:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2957:../uvc.c      ****     uint16_t readCount;
2958:../uvc.c      ****     uint16_t zoomVal;
2959:../uvc.c      ****     int32_t  panVal, tiltVal;
2960:../uvc.c      ****     CyBool_t sendData = CyFalse;
2961:../uvc.c      **** #endif
2962:../uvc.c      ****     uint8_t CtrlAdd;
2963:../uvc.c      **** 
2964:../uvc.c      ****     switch (wValue)
2965:../uvc.c      ****     {
2966:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2967:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2968:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2969:../uvc.c      ****     		break;
2970:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2971:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2972:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2973:../uvc.c      ****     		break;
2974:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2975:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2976:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2977:../uvc.c      **** 			break;
2978:../uvc.c      **** 
2979:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2980:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2981:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2982:../uvc.c      **** 			break;
2983:../uvc.c      **** 
2984:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2985:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2986:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2987:../uvc.c      ****       		break;
2988:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2989:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2990:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2991:../uvc.c      ****      		break;
2992:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2993:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2994:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2995:../uvc.c      ****           		break;
2996:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2997:../uvc.c      ****           		break;
2998:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2999:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3000:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3001:../uvc.c      ****      		break;
3002:../uvc.c      **** 
3003:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3004:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3005:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3006:../uvc.c      ****     		break;
3007:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3008:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3009:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3010:../uvc.c      ****     		break;
3011:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3012:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3013:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3014:../uvc.c      ****     		break;
3015:../uvc.c      **** 
3016:../uvc.c      ****         default:
3017:../uvc.c      ****             /*
3018:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3019:../uvc.c      ****              * other controls.
3020:../uvc.c      ****              */
3021:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3022:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3023:../uvc.c      ****             break;
3024:../uvc.c      ****     }
3025:../uvc.c      **** 
3026:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3027:../uvc.c      ****     switch (wValue)
3028:../uvc.c      ****     {
3029:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3030:../uvc.c      ****             switch (bRequest)
3031:../uvc.c      ****             {
3032:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3033:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3034:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3035:../uvc.c      ****                     break;
3036:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3037:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3038:../uvc.c      ****                     sendData = CyTrue;
3039:../uvc.c      ****                     break;
3040:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3041:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3042:../uvc.c      ****                     sendData = CyTrue;
3043:../uvc.c      ****                     break;
3044:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3045:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3046:../uvc.c      ****                     sendData = CyTrue;
3047:../uvc.c      ****                     break;
3048:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3049:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3050:../uvc.c      ****                     sendData = CyTrue;
3051:../uvc.c      ****                     break;
3052:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3053:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3054:../uvc.c      ****                     sendData = CyTrue;
3055:../uvc.c      ****                     break;
3056:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3057:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3058:../uvc.c      ****                             glEp0Buffer, &readCount);
3059:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3060:../uvc.c      ****                     {
3061:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3062:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3063:../uvc.c      ****                     }
3064:../uvc.c      ****                     break;
3065:../uvc.c      ****                 default:
3066:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3067:../uvc.c      ****                     break;
3068:../uvc.c      ****             }
3069:../uvc.c      **** 
3070:../uvc.c      ****             if (sendData)
3071:../uvc.c      ****             {
3072:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3073:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3074:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3075:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3076:../uvc.c      ****             }
3077:../uvc.c      ****             break;
3078:../uvc.c      **** 
3079:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3080:../uvc.c      ****             switch (bRequest)
3081:../uvc.c      ****             {
3082:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3083:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3084:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3085:../uvc.c      ****                     break;
3086:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3087:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3088:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3089:../uvc.c      ****                     sendData = CyTrue;
3090:../uvc.c      ****                     break;
3091:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3092:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3093:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3094:../uvc.c      ****                     sendData = CyTrue;
3095:../uvc.c      ****                     break;
3096:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3097:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3098:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3099:../uvc.c      ****                     sendData = CyTrue;
3100:../uvc.c      ****                     break;
3101:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3102:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3103:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3104:../uvc.c      ****                     sendData = CyTrue;
3105:../uvc.c      ****                     break;
3106:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3107:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3108:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3109:../uvc.c      ****                     sendData = CyTrue;
3110:../uvc.c      ****                     break;
3111:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3112:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3113:../uvc.c      ****                             glEp0Buffer, &readCount);
3114:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3115:../uvc.c      ****                     {
3116:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3117:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3118:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3119:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3120:../uvc.c      **** 
3121:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3122:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3123:../uvc.c      ****                     }
3124:../uvc.c      ****                     break;
3125:../uvc.c      ****                 default:
3126:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3127:../uvc.c      ****                     break;
3128:../uvc.c      ****             }
3129:../uvc.c      **** 
3130:../uvc.c      ****             if (sendData)
3131:../uvc.c      ****             {
3132:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3133:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3134:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3135:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3136:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3137:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3138:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3139:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3140:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3141:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3142:../uvc.c      ****             }
3143:../uvc.c      ****             break;
3144:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3145:../uvc.c      ****         default:
3146:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3147:../uvc.c      ****             break;
3148:../uvc.c      ****     }
3149:../uvc.c      **** #endif
3150:../uvc.c      **** }
3151:../uvc.c      **** 
3152:../uvc.c      **** /*
3153:../uvc.c      ****  * Handler for UVC Interface control requests.
3154:../uvc.c      ****  */
3155:../uvc.c      **** static void
3156:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3157:../uvc.c      ****         void)
3158:../uvc.c      **** {
3159:../uvc.c      **** 
3160:../uvc.c      ****     switch (wValue)
3161:../uvc.c      ****     {
3162:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3163:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3164:../uvc.c      ****     		break;
3165:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3166:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3167:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3168:../uvc.c      ****     		break;
3169:../uvc.c      ****     	default:
3170:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3171:../uvc.c      ****      		break;
3172:../uvc.c      ****     }
3173:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3174:../uvc.c      **** 
3175:../uvc.c      **** }
3176:../uvc.c      **** 
3177:../uvc.c      **** /*
3178:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3179:../uvc.c      ****  */
3180:../uvc.c      **** static void
3181:../uvc.c      **** UVCHandleExtensionUnitRqts (
3182:../uvc.c      ****         void)
3183:../uvc.c      **** {
3184:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3185:../uvc.c      **** 
3186:../uvc.c      **** #ifdef DbgInfo
3187:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3188:../uvc.c      **** #endif
3189:../uvc.c      ****     switch (wValue)
3190:../uvc.c      ****     {
3191:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3192:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3193:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3194:../uvc.c      ****     		break;
3195:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3196:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3197:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3198:../uvc.c      ****     		break;
3199:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3200:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3201:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3202:../uvc.c      ****      		break;
3203:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3204:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3205:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3206:../uvc.c      ****     		break;
3207:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3208:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3209:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3210:../uvc.c      ****     		break;
3211:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3212:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3213:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3214:../uvc.c      ****      		break;
3215:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3216:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3217:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3218:../uvc.c      ****     		break;
3219:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3220:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3221:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3222:../uvc.c      ****     		break;
3223:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3224:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3225:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3226:../uvc.c      ****      		break;
3227:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3228:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3229:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3230:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3231:../uvc.c      ****     		}else/* no support for 1080p camera */
3232:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3233:../uvc.c      ****     		break;
3234:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3235:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3236:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3237:../uvc.c      ****     		break;
3238:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3239:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3240:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3241:../uvc.c      ****     		break;
3242:../uvc.c      **** 
3243:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3244:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3245:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3246:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3247:../uvc.c      ****     		break;
3248:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3249:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3250:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3251:../uvc.c      ****     		//break;
3252:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3253:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3254:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3255:../uvc.c      ****     		break;
3256:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3257:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3258:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3259:../uvc.c      ****     		break;
3260:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3261:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
3262:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
3263:../uvc.c      ****     		break;
3264:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3265:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
3266:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
3267:../uvc.c      ****     		break;
3268:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3269:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
3270:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
3271:../uvc.c      ****     		break;
3272:../uvc.c      ****    	default:
3273:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3274:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3275:../uvc.c      ****     		break;
3276:../uvc.c      ****     }
3277:../uvc.c      **** 
3278:../uvc.c      **** }
3279:../uvc.c      **** 
3280:../uvc.c      **** /*
3281:../uvc.c      ****  * Handler for the video streaming control requests.
3282:../uvc.c      ****  */
3283:../uvc.c      **** static void
3284:../uvc.c      **** UVCHandleVideoStreamingRqts (
3285:../uvc.c      ****         void)
3286:../uvc.c      **** {
3287:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3288:../uvc.c      ****     uint16_t readCount;
3289:../uvc.c      **** 
3290:../uvc.c      ****     switch (wValue)
3291:../uvc.c      ****     {
3292:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3293:../uvc.c      ****             switch (bRequest)
3294:../uvc.c      ****             {
3295:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3296:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3297:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3298:../uvc.c      ****                     break;
3299:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3300:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3301:../uvc.c      ****                     glEp0Buffer[1] = 0;
3302:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3303:../uvc.c      ****                     break;
3304:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3305:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3306:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3307:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3308:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3309:../uvc.c      ****                     {
3310:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3311:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3312:../uvc.c      **** 
3313:../uvc.c      ****                     }
3314:../uvc.c      ****                     else
3315:../uvc.c      ****                     {
3316:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3317:../uvc.c      ****                     }
3318:../uvc.c      ****                     break;
3319:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3320:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3321:../uvc.c      ****                             glCommitCtrl, &readCount);
3322:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3323:../uvc.c      ****                     {
3324:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3325:../uvc.c      ****                         {
3326:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3327:../uvc.c      ****                                active data structure. */
3328:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3329:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3330:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3331:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3332:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3333:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3334:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3335:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3336:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3337:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3338:../uvc.c      **** #if 0
3339:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3340:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3341:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3342:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3343:../uvc.c      **** #endif
3344:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3345:../uvc.c      ****                        }
3346:../uvc.c      ****                     }
3347:../uvc.c      ****                     break;
3348:../uvc.c      ****                 default:
3349:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3350:../uvc.c      ****                     break;
3351:../uvc.c      ****             }
3352:../uvc.c      ****             break;
3353:../uvc.c      **** 
3354:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3355:../uvc.c      ****             switch (bRequest)
3356:../uvc.c      ****             {
3357:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3358:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3359:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3360:../uvc.c      ****                     break;
3361:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3362:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3363:../uvc.c      ****                     glEp0Buffer[1] = 0;
3364:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3365:../uvc.c      ****                     break;
3366:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3367:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3368:../uvc.c      ****                     {
3369:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3370:../uvc.c      ****                     }
3371:../uvc.c      ****                     else
3372:../uvc.c      ****                     {
3373:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3374:../uvc.c      ****                     }
3375:../uvc.c      ****                     break;
3376:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3377:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3378:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3379:../uvc.c      ****                        */
3380:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3381:../uvc.c      ****                             glCommitCtrl, &readCount);
3382:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3383:../uvc.c      ****                     {
3384:../uvc.c      ****                         switch (glCommitCtrl[3])
3385:../uvc.c      ****                          {
3386:../uvc.c      ****                          	case 1: //1944
3387:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3388:../uvc.c      ****                          		CyU3PThreadSleep(500);
3389:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3390:../uvc.c      ****                          		break;
3391:../uvc.c      ****                          	case 2: //1080
3392:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3393:../uvc.c      ****                          		CyU3PThreadSleep(500);
3394:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3395:../uvc.c      ****                          		break;
3396:../uvc.c      ****                          	case 3: //720
3397:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3398:../uvc.c      ****                          		CyU3PThreadSleep(500);
3399:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz
3400:../uvc.c      ****                          		break;
3401:../uvc.c      ****                          	default:
3402:../uvc.c      ****                          		break;
3403:../uvc.c      ****                          }
3404:../uvc.c      ****                         setRes = glCommitCtrl[3];
3405:../uvc.c      **** #if 0
3406:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3407:../uvc.c      ****                         {
3408:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3409:../uvc.c      ****                         }
3410:../uvc.c      ****                         else
3411:../uvc.c      ****                         {
3412:../uvc.c      ****                             SensorScaling_VGA ();
3413:../uvc.c      ****                         }
3414:../uvc.c      **** #endif
3415:../uvc.c      ****                         /* We can start streaming video now. */
3416:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3417:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3418:../uvc.c      ****                         {
3419:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3420:../uvc.c      ****                         }
3421:../uvc.c      ****                     }
3422:../uvc.c      ****                     break;
3423:../uvc.c      **** 
3424:../uvc.c      ****                 default:
3425:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3426:../uvc.c      ****                     break;
3427:../uvc.c      ****             }
3428:../uvc.c      ****             break;
3429:../uvc.c      **** 
3430:../uvc.c      **** /* still image streaming handler */
3431:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3432:../uvc.c      ****                 switch (bRequest)
3433:../uvc.c      ****                 {
3434:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3435:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3436:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3437:../uvc.c      ****                         break;
3438:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3439:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3440:../uvc.c      ****                         glEp0Buffer[1] = 0;
3441:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3442:../uvc.c      ****                         break;
3443:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3444:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3445:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3446:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3447:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3448:../uvc.c      ****                         {
3449:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3450:../uvc.c      ****                         }
3451:../uvc.c      ****                         else
3452:../uvc.c      ****                         {
3453:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3454:../uvc.c      ****                         }
3455:../uvc.c      ****                         break;
3456:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3457:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3458:../uvc.c      ****                                 glCommitCtrl, &readCount);
3459:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3460:../uvc.c      ****                         {
3461:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3462:../uvc.c      ****                             {
3463:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3464:../uvc.c      ****                                    active data structure. */
3465:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3466:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3467:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3468:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3469:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3470:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3471:../uvc.c      ****                             }
3472:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3473:../uvc.c      ****                         }
3474:../uvc.c      ****                         break;
3475:../uvc.c      ****                     default:
3476:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3477:../uvc.c      ****                         break;
3478:../uvc.c      ****                 }
3479:../uvc.c      ****                 break;
3480:../uvc.c      **** 
3481:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3482:../uvc.c      ****                 switch (bRequest)
3483:../uvc.c      ****                 {
3484:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3485:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3486:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3487:../uvc.c      ****                         break;
3488:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3489:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3490:../uvc.c      ****                         glEp0Buffer[1] = 0;
3491:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3492:../uvc.c      ****                         break;
3493:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3494:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3495:../uvc.c      ****                         {
3496:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3497:../uvc.c      ****                         }
3498:../uvc.c      ****                         else
3499:../uvc.c      ****                         {
3500:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3501:../uvc.c      ****                         }
3502:../uvc.c      ****                         break;
3503:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3504:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3505:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3506:../uvc.c      ****                            */
3507:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3508:../uvc.c      ****                                 glCommitCtrl, &readCount);
3509:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3510:../uvc.c      ****                         {
3511:../uvc.c      ****     #if 0
3512:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3513:../uvc.c      ****                             {
3514:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3515:../uvc.c      ****                             }
3516:../uvc.c      ****                             else
3517:../uvc.c      ****                             {
3518:../uvc.c      ****                                 SensorScaling_VGA ();
3519:../uvc.c      ****                             }
3520:../uvc.c      ****                             /* We can start streaming video now. */
3521:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3522:../uvc.c      **** 
3523:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3524:../uvc.c      ****                             {
3525:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3526:../uvc.c      ****                             }
3527:../uvc.c      **** 	#endif
3528:../uvc.c      ****                            switch (glCommitCtrl[1])
3529:../uvc.c      ****                              {
3530:../uvc.c      ****                              	case 3: //1944
3531:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3532:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3533:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3534:../uvc.c      ****                              		break;
3535:../uvc.c      ****                              	case 2: //1080
3536:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3537:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3538:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60
3539:../uvc.c      ****                              		break;
3540:../uvc.c      ****                              	case 1: //720
3541:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3542:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3543:../uvc.c      ****                                     //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is
3544:../uvc.c      ****                              		break;
3545:../uvc.c      ****                              	default:
3546:../uvc.c      ****                              		break;
3547:../uvc.c      ****                              }
3548:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3549:../uvc.c      **** 
3550:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3551:../uvc.c      **** 
3552:../uvc.c      ****                         }
3553:../uvc.c      ****                         break;
3554:../uvc.c      **** 
3555:../uvc.c      ****                     default:
3556:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3557:../uvc.c      ****                         break;
3558:../uvc.c      ****                 }
3559:../uvc.c      ****                 break;
3560:../uvc.c      **** 
3561:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3562:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3563:../uvc.c      ****             	switch (bRequest)
3564:../uvc.c      ****                 {
3565:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3566:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3567:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3568:../uvc.c      ****                         break;
3569:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3570:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3571:../uvc.c      ****                         glEp0Buffer[1] = 0;
3572:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3573:../uvc.c      ****                         break;
3574:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3575:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3576:../uvc.c      ****                         {
3577:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3578:../uvc.c      ****                         }
3579:../uvc.c      ****                         else
3580:../uvc.c      ****                         {
3581:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3582:../uvc.c      ****                         }
3583:../uvc.c      ****                         break;
3584:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3585:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3586:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3587:../uvc.c      ****                            */
3588:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3589:../uvc.c      ****                                 glCommitCtrl, &readCount);
3590:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3591:../uvc.c      ****                         {
3592:../uvc.c      ****     #if 1
3593:../uvc.c      ****                             /* We can start still streaming video now. */
3594:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3595:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3596:../uvc.c      ****                             {
3597:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3598:../uvc.c      ****                             }
3599:../uvc.c      ****     #endif
3600:../uvc.c      ****                             else{
3601:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3602:../uvc.c      ****                             //stillcont = 0;
3603:../uvc.c      ****                             }
3604:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3605:../uvc.c      ****                         }else{
3606:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3607:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3608:../uvc.c      ****                         }
3609:../uvc.c      ****                         break;
3610:../uvc.c      **** 
3611:../uvc.c      ****                     default:
3612:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3613:../uvc.c      ****                         break;
3614:../uvc.c      ****                 }
3615:../uvc.c      ****                 break;
3616:../uvc.c      **** 
3617:../uvc.c      ****         default:
3618:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3619:../uvc.c      ****             break;
3620:../uvc.c      ****     }
3621:../uvc.c      **** }
3622:../uvc.c      **** 
3623:../uvc.c      **** /*
3624:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3625:../uvc.c      ****  */
3626:../uvc.c      **** void
3627:../uvc.c      **** UVCAppEP0Thread_Entry (
3628:../uvc.c      ****         uint32_t input)
3629:../uvc.c      **** {
3630:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3631:../uvc.c      ****     uint32_t eventFlag;
3632:../uvc.c      **** 	CyBool_t value;
3633:../uvc.c      **** 	CyBool_t *valueptr = &value;
3634:../uvc.c      **** 
3635:../uvc.c      **** 
3636:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3637:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3638:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3639:../uvc.c      **** 
3640:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3641:../uvc.c      **** #endif
3642:../uvc.c      **** 
3643:../uvc.c      ****     /* for interrupt status test */
3644:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3645:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3646:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3647:../uvc.c      **** 
3648:../uvc.c      ****     for (;;)
3649:../uvc.c      ****     {
3650:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3651:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3652:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3653:../uvc.c      ****         {
3654:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3655:../uvc.c      ****             if (!isUsbConnected)
3656:../uvc.c      ****             {
3657:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3658:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3659:../uvc.c      ****                 {
3660:../uvc.c      ****                     isUsbConnected = CyTrue;
3661:../uvc.c      ****                 }
3662:../uvc.c      ****             }
3663:../uvc.c      **** //#ifdef DbgInfo
3664:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3665:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3666:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3667:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3668:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3669:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3670:../uvc.c      **** //#endif
3671:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3672:../uvc.c      ****             {
3673:../uvc.c      ****             	switch ((wIndex >> 8))
3674:../uvc.c      ****                 {
3675:../uvc.c      **** 
3676:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3677:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3678:../uvc.c      ****                         break;
3679:../uvc.c      **** 
3680:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3681:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3682:../uvc.c      ****                         break;
3683:../uvc.c      **** 
3684:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3685:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3686:../uvc.c      ****                         break;
3687:../uvc.c      **** 
3688:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3689:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3690:../uvc.c      ****                         break;
3691:../uvc.c      **** 
3692:../uvc.c      ****                     default:
3693:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3694:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3695:../uvc.c      ****                         break;
3696:../uvc.c      ****                 }
3697:../uvc.c      ****             }
3698:../uvc.c      **** 
3699:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3700:../uvc.c      ****             {
3701:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3702:../uvc.c      **** 
3703:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3704:../uvc.c      ****                 {
3705:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3706:../uvc.c      ****                 }
3707:../uvc.c      ****                 else
3708:../uvc.c      ****                 {
3709:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3710:../uvc.c      ****                 }
3711:../uvc.c      ****             }
3712:../uvc.c      **** 
3713:../uvc.c      ****             /* handle interrupt status event */
3714:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3715:../uvc.c      ****             {
3716:../uvc.c      **** 
3717:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3718:../uvc.c      ****             	/** preparing interrupt status data **/
3719:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3720:../uvc.c      **** 
3721:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3722:../uvc.c      **** 
3723:../uvc.c      **** #if 0 //for real button
3724:../uvc.c      **** 				if(value&&(!snapButFlag)){
3725:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3726:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3727:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3728:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3729:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3730:../uvc.c      **** 
3731:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3732:../uvc.c      **** 					interStabuf.size   = 1024;
3733:../uvc.c      **** 					interStabuf.status = 0;
3734:../uvc.c      **** 
3735:../uvc.c      **** 					interStabuf.count = 4;
3736:../uvc.c      **** 
3737:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3738:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3739:../uvc.c      **** 
3740:../uvc.c      **** 					/** send a interrupt status data **/
3741:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3742:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3743:../uvc.c      **** 					{
3744:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3745:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3746:../uvc.c      **** 					}
3747:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3748:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3749:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3750:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3751:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3752:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3753:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3754:../uvc.c      **** 
3755:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3756:../uvc.c      **** 					interStabuf.size   = 1024;
3757:../uvc.c      **** 					interStabuf.status = 0;
3758:../uvc.c      **** 
3759:../uvc.c      **** 					interStabuf.count = 4;
3760:../uvc.c      **** 
3761:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3762:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3763:../uvc.c      **** 
3764:../uvc.c      **** 					/** send a interrupt status data **/
3765:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3766:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3767:../uvc.c      **** 					{
3768:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3769:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3770:../uvc.c      **** 					}
3771:../uvc.c      **** 
3772:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3773:../uvc.c      **** 					stiflag = 0xFF;
3774:../uvc.c      **** 				}
3775:../uvc.c      **** #else			//for botton simulation
3776:../uvc.c      **** 				if(snapButFlag == 0x0f){
3777:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3778:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3779:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3780:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3781:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3782:../uvc.c      **** 
3783:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3784:../uvc.c      **** 					interStabuf.size   = 1024;
3785:../uvc.c      **** 					interStabuf.status = 0;
3786:../uvc.c      **** 
3787:../uvc.c      **** 					interStabuf.count = 4;
3788:../uvc.c      **** 
3789:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3790:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3791:../uvc.c      **** 
3792:../uvc.c      **** 					/** send a interrupt status data **/
3793:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3794:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3795:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3796:../uvc.c      **** 					{
3797:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3798:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3799:../uvc.c      **** 					}
3800:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3801:../uvc.c      **** 
3802:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3803:../uvc.c      **** 				}else if(!snapButFlag){
3804:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3805:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3806:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3807:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3808:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3809:../uvc.c      **** 
3810:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3811:../uvc.c      **** 					interStabuf.size   = 1024;
3812:../uvc.c      **** 					interStabuf.status = 0;
3813:../uvc.c      **** 
3814:../uvc.c      **** 					interStabuf.count = 4;
3815:../uvc.c      **** 
3816:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3817:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3818:../uvc.c      **** 
3819:../uvc.c      **** 					/** send a interrupt status data **/
3820:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3821:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3822:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3823:../uvc.c      **** 					{
3824:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3825:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3826:../uvc.c      **** 					}
3827:../uvc.c      **** 
3828:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3829:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3830:../uvc.c      **** 				}
3831:../uvc.c      **** #endif
3832:../uvc.c      **** 
3833:../uvc.c      ****             }
3834:../uvc.c      **** 
3835:../uvc.c      **** 
3836:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3837:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3838:../uvc.c      ****             {
3839:../uvc.c      ****                 /* Get the command buffer */
3840:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3841:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3842:../uvc.c      ****                 {
3843:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3844:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3845:../uvc.c      ****                 }
3846:../uvc.c      **** 
3847:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3848:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3849:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3850:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3851:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3852:../uvc.c      ****                  * register value high byte and register value low byte.
3853:../uvc.c      ****                  */
3854:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3855:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3856:../uvc.c      ****                 {
3857:../uvc.c      ****                     if (dmaInfo.count == 3)
3858:../uvc.c      ****                     {
3859:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3860:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3861:../uvc.c      ****                         dmaInfo.count = 3;
3862:../uvc.c      ****                     }
3863:../uvc.c      ****                     else if (dmaInfo.count == 4)
3864:../uvc.c      ****                     {
3865:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3866:../uvc.c      ****                         {
3867:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3868:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3869:../uvc.c      ****                         }
3870:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3871:../uvc.c      ****                     }
3872:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3873:../uvc.c      ****                 }
3874:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3875:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3876:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3877:../uvc.c      ****                  */
3878:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3879:../uvc.c      ****                 {
3880:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3881:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3882:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3883:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3884:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3885:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3886:../uvc.c      ****                         	break;
3887:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3888:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3889:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3890:../uvc.c      ****                         	break;*/
3891:../uvc.c      ****                     dmaInfo.count -= 2;
3892:../uvc.c      ****                 }
3893:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3894:../uvc.c      ****                 else
3895:../uvc.c      ****                 {
3896:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3897:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3898:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3899:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3900:../uvc.c      ****                 }
3901:../uvc.c      **** 
3902:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3903:../uvc.c      ****                 dmaInfo.size   = 1024;
3904:../uvc.c      ****                 dmaInfo.status = 0;
3905:../uvc.c      **** 
3906:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3907:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3908:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3909:../uvc.c      ****                 {
3910:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3911:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3912:../uvc.c      ****                 }
3913:../uvc.c      **** 
3914:../uvc.c      ****                 /* Wait until the response has gone out. */
3915:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3916:../uvc.c      **** 
3917:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3918:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3919:../uvc.c      ****                 {
3920:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3921:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3922:../uvc.c      ****                 }
3923:../uvc.c      ****             }
3924:../uvc.c      **** #endif
3925:../uvc.c      ****         }
3926:../uvc.c      ****         /* Allow other ready threads to run. */
3927:../uvc.c      ****         CyU3PThreadRelinquish ();
3928:../uvc.c      ****     }
3929:../uvc.c      **** }
3930:../uvc.c      **** 
3931:../uvc.c      **** /*
3932:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3933:../uvc.c      ****  * added 10/2013
3934:../uvc.c      ****  */
3935:../uvc.c      **** /*
3936:../uvc.c      **** static uint8_t timeDelay[64] = {
3937:../uvc.c      **** 
3938:../uvc.c      **** };
3939:../uvc.c      **** */
3940:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3940 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3941:../uvc.c      **** 
3942:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3943:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3944:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3945:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3946:../uvc.c      **** 	VdstateDes *lcStaDes;
3947:../uvc.c      **** 	uint32_t flag = 0;
3948:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3949:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3950:../uvc.c      **** 	uint8_t i;
3951:../uvc.c      **** 	uint16_t delaytime;
3952:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3953:../uvc.c      **** 
3954:../uvc.c      **** #if 0 //for test the command queue
3955:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3956:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3957:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3958:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3959:../uvc.c      **** 		lcCmdDes += 1;
3960:../uvc.c      **** 	}
3961:../uvc.c      **** #endif
3962:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3963:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3963 0
  36 0004 10229FE5 		ldr	r2, .L22
3947:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3947 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3940:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3940 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3963 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3947:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3947 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3963 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3964:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3964 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3965:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3965 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3966:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3966 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3967:../uvc.c      **** 
3968:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3968 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3969:../uvc.c      ****         /* Allow other ready threads to run. */
3970:../uvc.c      **** 
3971:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3971 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3968:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3968 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3972:../uvc.c      **** 	}
3973:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3973 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3974:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3975:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3976:../uvc.c      **** 	//CyU3PThreadSleep(100);
3977:../uvc.c      **** 	//SetCurCmd();
3978:../uvc.c      **** 	/*********** the loop of the thread ***********/
3979:../uvc.c      **** 	for(;;){
3980:../uvc.c      **** 
3981:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3981 0
 101 0098 0060E0E3 		mvn	r6, #0
3982:../uvc.c      **** /*  // for test GPIO output
3983:../uvc.c      **** 		if(trigger)
3984:../uvc.c      **** 		{
3985:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3986:../uvc.c      **** 			{
3987:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3988:../uvc.c      **** 			}
3989:../uvc.c      **** 
3990:../uvc.c      **** 		}else{
3991:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3992:../uvc.c      **** 			{
3993:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3994:../uvc.c      **** 			}
3995:../uvc.c      **** 
3996:../uvc.c      **** 		}
3997:../uvc.c      **** */
3998:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3999:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4000:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
4001:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
4002:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
4003:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
4004:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
4005:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4006:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4007:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4008:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4009:../uvc.c      **** #endif
4010:../uvc.c      **** 				}
4011:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
4012:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
4013:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4014:../uvc.c      **** 			}
4015:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4016:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4017:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4018:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4019:../uvc.c      **** 
4020:../uvc.c      **** 				/*
4021:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4022:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4023:../uvc.c      **** 				*/
4024:../uvc.c      **** 
4025:../uvc.c      **** 				/* find a available command */
4026:../uvc.c      **** 				i = 0;
4027:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4027 0
 103 009c 0090A0E3 		mov	r9, #0
4028:../uvc.c      **** 					i++;
4029:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4030:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4031:../uvc.c      **** 				}
4032:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4033:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4034:../uvc.c      **** 					i = lcCmdDes->curNum;
4035:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4036:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4037:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4038:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4039:../uvc.c      **** #if 1
4040:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4041:../uvc.c      **** 						case 20:
4042:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4043:../uvc.c      **** 							delaytime = 500;
4044:../uvc.c      **** 							break;
4045:../uvc.c      **** 						case 21:
4046:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4047:../uvc.c      **** 							delaytime = 500;
4048:../uvc.c      **** 							break;
4049:../uvc.c      **** 						case 22:
4050:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4051:../uvc.c      **** 							delaytime = 300;
4052:../uvc.c      **** 							break;
4053:../uvc.c      **** 						case 23:
4054:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4055:../uvc.c      **** 							delaytime = 300;
4056:../uvc.c      **** 							break;
4057:../uvc.c      **** 						default:
4058:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4059:../uvc.c      **** 							break;
4060:../uvc.c      **** 					}
4061:../uvc.c      **** #endif
4062:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4063:../uvc.c      **** 					/** timer's ticket modify **/
4064:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4065:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4066:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4067:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4068:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4069:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4070:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4071:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4072:../uvc.c      **** #endif
4073:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4074:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4075:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4076:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4077:../uvc.c      **** 						}else{
4078:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4079:../uvc.c      **** 						}
4080:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4081:../uvc.c      **** 					}else{
4082:../uvc.c      **** 						lcCmdDes->curNum ++;
4083:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4083 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3981:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3981 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3998:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3998 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4015:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 4015 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
4017:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 4017 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
4018:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 4018 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
4027:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4027 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
4029:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 4029 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
4028:../uvc.c      **** 					i++;
 140              		.loc 1 4028 0
 141 00f4 011083E2 		add	r1, r3, #1
4027:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 4027 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
4028:../uvc.c      **** 					i++;
 144              		.loc 1 4028 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
4027:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 4027 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
4033:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 4033 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
4035:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 4035 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4040:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 4040 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
4035:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 4035 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
4040:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 4040 0
 166 0128 14C042E2 		sub	ip, r2, #20
4035:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 4035 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
4036:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 4036 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
4037:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 4037 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
4038:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 4038 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
4040:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 4040 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.LVL15:
 189              	.L11:
4054:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 190              		.loc 1 4054 0
 191 0158 8230A0E3 		mov	r3, #130
 192 015c FEFFFFEB 		bl	SensorSetIrisControl
 193              	.LVL16:
4056:../uvc.c      **** 							break;
 194              		.loc 1 4056 0
 195 0160 4B1FA0E3 		mov	r1, #300
 196              	.LVL17:
 197              	.L13:
4065:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 198              		.loc 1 4065 0
 199 0164 0020A0E3 		mov	r2, #0
 200 0168 B0009FE5 		ldr	r0, .L22+4
 201 016c FEFFFFEB 		bl	_txe_timer_change
4066:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 202              		.loc 1 4066 0
 203 0170 A8009FE5 		ldr	r0, .L22+4
 204 0174 FEFFFFEB 		bl	_txe_timer_activate
 205              	.LVL18:
4073:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 206              		.loc 1 4073 0
 207 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 208 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 209 0180 000051E1 		cmp	r1, r0
4082:../uvc.c      **** 						lcCmdDes->curNum ++;
 210              		.loc 1 4082 0
 211 0184 01008012 		addne	r0, r0, #1
 212 0188 0100C415 		strneb	r0, [r4, #1]
 213              		.loc 1 4083 0
 214 018c 3C808415 		strne	r8, [r4, #60]
4073:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 215              		.loc 1 4073 0
 216 0190 1400000A 		beq	.L21
 217              	.LVL19:
 218              	.L17:
4084:../uvc.c      **** 					}
4085:../uvc.c      **** 				}else{
4086:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4087:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4088:../uvc.c      **** 				}
4089:../uvc.c      **** 			}
4090:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 219              		.loc 1 4090 0
 220 0194 1C0095E5 		ldr	r0, [r5, #28]
 221 0198 FEFFFFEB 		bl	_txe_mutex_put
 222              	.LVL20:
4091:../uvc.c      **** /*
4092:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4093:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4094:../uvc.c      **** */
4095:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4096:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4097:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4098:../uvc.c      **** #endif
4099:../uvc.c      **** 
4100:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4101:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4102:../uvc.c      **** #if 0
4103:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4104:../uvc.c      **** 
4105:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4106:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4107:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4108:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4109:../uvc.c      **** 			    i = 0;
4110:../uvc.c      **** 				 switch(cmdCopyIdx)
4111:../uvc.c      **** 				 {
4112:../uvc.c      **** 					 case BrgtCtlID1:
4113:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4114:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4115:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4116:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4117:../uvc.c      **** 							 i++;
4118:../uvc.c      **** 						 }
4119:../uvc.c      **** 						 else{
4120:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4121:../uvc.c      **** 						 }
4122:../uvc.c      **** 
4123:../uvc.c      **** 						 CyU3PBusyWait(500);
4124:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4125:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4126:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4127:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4128:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4129:../uvc.c      **** 						 }
4130:../uvc.c      **** 						 else{
4131:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4132:../uvc.c      **** 						 }
4133:../uvc.c      **** 						 break;
4134:../uvc.c      **** 					 case HueCtlID5:
4135:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4136:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4137:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4138:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4139:../uvc.c      **** 						 }
4140:../uvc.c      **** 						 else{
4141:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4142:../uvc.c      **** 						 }
4143:../uvc.c      **** 						 break;
4144:../uvc.c      **** 					 case SaturCtlID6:
4145:../uvc.c      **** 					 case WBTLevCtlID10:
4146:../uvc.c      **** 					 default:
4147:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4148:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4149:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4150:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4151:../uvc.c      **** 						 }
4152:../uvc.c      **** 						 else{
4153:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4154:../uvc.c      **** 						 }
4155:../uvc.c      **** 						 break;
4156:../uvc.c      **** 				 }
4157:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4158:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4159:../uvc.c      **** 			}
4160:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4161:../uvc.c      **** #endif
4162:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4163:../uvc.c      **** 		/* Allow other ready threads to run. */
4164:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4165:../uvc.c      **** 			CyU3PThreadRelinquish ();
 223              		.loc 1 4165 0
 224 019c FEFFFFEB 		bl	_txe_thread_relinquish
4166:../uvc.c      **** 		}
 225              		.loc 1 4166 0
 226 01a0 BFFFFFEA 		b	.L18
 227              	.LVL21:
 228              	.L9:
4046:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 229              		.loc 1 4046 0
 230 01a4 5230A0E3 		mov	r3, #82
 231 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 232              	.LVL22:
4048:../uvc.c      **** 							break;
 233              		.loc 1 4048 0
 234 01ac 7D1FA0E3 		mov	r1, #500
 235 01b0 EBFFFFEA 		b	.L13
 236              	.LVL23:
 237              	.L7:
4058:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 238              		.loc 1 4058 0
 239 01b4 FEFFFFEB 		bl	SensorSetControl
 240              	.LVL24:
 241 01b8 0A10A0E1 		mov	r1, sl
4059:../uvc.c      **** 							break;
 242              		.loc 1 4059 0
 243 01bc E8FFFFEA 		b	.L13
 244              	.LVL25:
 245              	.L8:
4042:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 246              		.loc 1 4042 0
 247 01c0 8230A0E3 		mov	r3, #130
 248 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 249              	.LVL26:
4044:../uvc.c      **** 							break;
 250              		.loc 1 4044 0
 251 01c8 7D1FA0E3 		mov	r1, #500
 252 01cc E4FFFFEA 		b	.L13
 253              	.LVL27:
 254              	.L6:
4086:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 255              		.loc 1 4086 0
 256 01d0 FA1FA0E3 		mov	r1, #1000
 257 01d4 44009FE5 		ldr	r0, .L22+4
 258 01d8 FEFFFFEB 		bl	_txe_timer_change
4087:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 259              		.loc 1 4087 0
 260 01dc 3C009FE5 		ldr	r0, .L22+4
 261 01e0 FEFFFFEB 		bl	_txe_timer_activate
 262 01e4 EAFFFFEA 		b	.L17
 263              	.LVL28:
 264              	.L21:
4075:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 265              		.loc 1 4075 0
 266 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4074:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 267              		.loc 1 4074 0
 268 01ec 3C9084E5 		str	r9, [r4, #60]
4075:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 269              		.loc 1 4075 0
 270 01f0 1F005CE3 		cmp	ip, #31
4076:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 271              		.loc 1 4076 0
 272 01f4 20C04C82 		subhi	ip, ip, #32
 273 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
4078:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 274              		.loc 1 4078 0
 275 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
4076:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 276              		.loc 1 4076 0
 277 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
4078:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 278              		.loc 1 4078 0
 279 0204 8CC18B90 		addls	ip, fp, ip, asl #3
4076:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 280              		.loc 1 4076 0
 281 0208 1090CC85 		strhib	r9, [ip, #16]
4078:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 282              		.loc 1 4078 0
 283 020c 9091CC95 		strlsb	r9, [ip, #400]
4080:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 284              		.loc 1 4080 0
 285 0210 344094E5 		ldr	r4, [r4, #52]
 286              	.LVL29:
 287 0214 104085E5 		str	r4, [r5, #16]
 288 0218 DDFFFFEA 		b	.L17
 289              	.L23:
 290              		.align	2
 291              	.L22:
 292 021c 00000000 		.word	I2CCmdCb
 293 0220 00000000 		.word	I2CCmdTimer
 294 0224 00000000 		.word	.LC0
 295 0228 00000000 		.word	cmdQu
 296 022c 14000000 		.word	.LC1
 297 0230 00000000 		.word	statQu
 298 0234 00000000 		.word	.LANCHOR1
 299 0238 00000000 		.word	.LANCHOR0
 300              		.cfi_endproc
 301              	.LFE26:
 303              		.align	2
 304              		.global	I2CCmdCb
 306              	I2CCmdCb:
 307              	.LFB18:
2571:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 308              		.loc 1 2571 0
 309              		.cfi_startproc
 310              		@ args = 0, pretend = 0, frame = 0
 311              		@ frame_needed = 0, uses_anonymous_args = 0
 312              		@ link register save eliminated.
 313              	.LVL30:
2573:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 314              		.loc 1 2573 0
 315 023c 08009FE5 		ldr	r0, .L25
 316              	.LVL31:
 317 0240 2010A0E3 		mov	r1, #32
 318 0244 0020A0E3 		mov	r2, #0
2574:../uvc.c      **** }
 319              		.loc 1 2574 0
2573:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 320              		.loc 1 2573 0
 321 0248 FEFFFFEA 		b	_txe_event_flags_set
 322              	.L26:
 323              		.align	2
 324              	.L25:
 325 024c 00000000 		.word	.LANCHOR0
 326              		.cfi_endproc
 327              	.LFE18:
 329              		.align	2
 331              	CyFxUVCApplnUSBEventCB:
 332              	.LFB9:
1632:../uvc.c      **** {
 333              		.loc 1 1632 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 8
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL32:
1633:../uvc.c      ****     switch (evtype)
 338              		.loc 1 1633 0
 339 0250 020050E3 		cmp	r0, #2
1632:../uvc.c      **** {
 340              		.loc 1 1632 0
 341 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 16
 344 0258 0130A0E1 		mov	r3, r1
 345 025c 10D04DE2 		sub	sp, sp, #16
 346              	.LCFI3:
 347              		.cfi_def_cfa_offset 32
1632:../uvc.c      **** {
 348              		.loc 1 1632 0
 349 0260 0040A0E1 		mov	r4, r0
 350              		.cfi_offset 14, -4
 351              		.cfi_offset 6, -8
 352              		.cfi_offset 5, -12
 353              		.cfi_offset 4, -16
1633:../uvc.c      ****     switch (evtype)
 354              		.loc 1 1633 0
 355 0264 3600000A 		beq	.L30
 356 0268 040050E3 		cmp	r0, #4
 357 026c 1F00000A 		beq	.L31
 358 0270 010050E3 		cmp	r0, #1
 359 0274 0100000A 		beq	.L33
 360              	.LVL33:
 361              	.L27:
1669:../uvc.c      **** }
 362              		.loc 1 1669 0
 363 0278 10D08DE2 		add	sp, sp, #16
 364 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 365              	.LVL34:
 366              	.L33:
1654:../uvc.c      ****             gpif_initialized = 0;
 367              		.loc 1 1654 0
 368 0280 28519FE5 		ldr	r5, .L34
1652:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 369              		.loc 1 1652 0
 370 0284 0020A0E1 		mov	r2, r0
 371 0288 24119FE5 		ldr	r1, .L34+4
 372              	.LVL35:
 373 028c 0400A0E3 		mov	r0, #4
 374              	.LVL36:
 375 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1653:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 376              		.loc 1 1653 0
 377 0294 0400A0E1 		mov	r0, r4
 378 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1654:../uvc.c      ****             gpif_initialized = 0;
 379              		.loc 1 1654 0
 380 029c 00C0A0E3 		mov	ip, #0
 381              	.LBB16:
 382              	.LBB17:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 383              		.loc 1 1616 0
 384 02a0 0410A0E1 		mov	r1, r4
 385 02a4 0500A0E1 		mov	r0, r5
 386 02a8 0220A0E3 		mov	r2, #2
 387 02ac 0C308DE2 		add	r3, sp, #12
 388              	.LBE17:
 389              	.LBE16:
1654:../uvc.c      ****             gpif_initialized = 0;
 390              		.loc 1 1654 0
 391 02b0 28C085E5 		str	ip, [r5, #40]
1655:../uvc.c      ****             isUsbConnected = CyFalse;
 392              		.loc 1 1655 0
 393 02b4 30C085E5 		str	ip, [r5, #48]
1656:../uvc.c      ****             streamingStarted = CyFalse;
 394              		.loc 1 1656 0
 395 02b8 2CC085E5 		str	ip, [r5, #44]
 396              	.LBB19:
 397              	.LBB18:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 398              		.loc 1 1616 0
 399 02bc 00C08DE5 		str	ip, [sp, #0]
 400 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 401 02c4 004050E2 		subs	r4, r0, #0
 402 02c8 EAFFFF1A 		bne	.L27
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 403              		.loc 1 1619 0
 404 02cc 0110E0E3 		mvn	r1, #1
 405 02d0 0220A0E3 		mov	r2, #2
 406 02d4 0500A0E1 		mov	r0, r5
 407              	.L32:
 408 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1622:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 409              		.loc 1 1622 0
 410 02dc 0500A0E1 		mov	r0, r5
 411 02e0 0210A0E3 		mov	r1, #2
 412 02e4 0420A0E1 		mov	r2, r4
 413 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 414 02ec E1FFFFEA 		b	.L27
 415              	.LVL37:
 416              	.L31:
 417              	.LBE18:
 418              	.LBE19:
1638:../uvc.c      ****             gpif_initialized = 0;
 419              		.loc 1 1638 0
 420 02f0 B8509FE5 		ldr	r5, .L34
1636:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 421              		.loc 1 1636 0
 422 02f4 BC109FE5 		ldr	r1, .L34+8
 423              	.LVL38:
 424 02f8 0020A0E1 		mov	r2, r0
 425 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 426              	.LVL39:
1637:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 427              		.loc 1 1637 0
 428 0300 0100A0E3 		mov	r0, #1
 429 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1638:../uvc.c      ****             gpif_initialized = 0;
 430              		.loc 1 1638 0
 431 0308 00C0A0E3 		mov	ip, #0
 432              	.LBB20:
 433              	.LBB21:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 434              		.loc 1 1616 0
 435 030c 0110A0E3 		mov	r1, #1
 436 0310 0220A0E3 		mov	r2, #2
 437 0314 0500A0E1 		mov	r0, r5
 438 0318 0C308DE2 		add	r3, sp, #12
 439              	.LBE21:
 440              	.LBE20:
1638:../uvc.c      ****             gpif_initialized = 0;
 441              		.loc 1 1638 0
 442 031c 28C085E5 		str	ip, [r5, #40]
1639:../uvc.c      ****             streamingStarted = CyFalse;
 443              		.loc 1 1639 0
 444 0320 2CC085E5 		str	ip, [r5, #44]
 445              	.LBB23:
 446              	.LBB22:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 447              		.loc 1 1616 0
 448 0324 00C08DE5 		str	ip, [sp, #0]
 449 0328 FEFFFFEB 		bl	_txe_event_flags_get
 450 032c 004050E2 		subs	r4, r0, #0
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 451              		.loc 1 1619 0
 452 0330 0500A001 		moveq	r0, r5
 453 0334 0110E003 		mvneq	r1, #1
 454 0338 0220A003 		moveq	r2, #2
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 455              		.loc 1 1616 0
 456 033c CDFFFF1A 		bne	.L27
 457 0340 E4FFFFEA 		b	.L32
 458              	.LVL40:
 459              	.L30:
 460              	.LBE22:
 461              	.LBE23:
1646:../uvc.c      ****             gpif_initialized = 0;
 462              		.loc 1 1646 0
 463 0344 64509FE5 		ldr	r5, .L34
1644:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 464              		.loc 1 1644 0
 465 0348 0020A0E1 		mov	r2, r0
 466 034c 68109FE5 		ldr	r1, .L34+12
 467              	.LVL41:
 468 0350 0400A0E3 		mov	r0, #4
 469              	.LVL42:
 470 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1645:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 471              		.loc 1 1645 0
 472 0358 0100A0E3 		mov	r0, #1
 473 035c FEFFFFEB 		bl	CyU3PGpifDisable
1646:../uvc.c      ****             gpif_initialized = 0;
 474              		.loc 1 1646 0
 475 0360 0060A0E3 		mov	r6, #0
 476              	.LBB24:
 477              	.LBB25:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 478              		.loc 1 1616 0
 479 0364 0500A0E1 		mov	r0, r5
 480 0368 0110A0E3 		mov	r1, #1
 481 036c 0420A0E1 		mov	r2, r4
 482 0370 0C308DE2 		add	r3, sp, #12
 483              	.LBE25:
 484              	.LBE24:
1646:../uvc.c      ****             gpif_initialized = 0;
 485              		.loc 1 1646 0
 486 0374 286085E5 		str	r6, [r5, #40]
1647:../uvc.c      ****             streamingStarted = CyFalse;
 487              		.loc 1 1647 0
 488 0378 2C6085E5 		str	r6, [r5, #44]
 489              	.LBB27:
 490              	.LBB26:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 491              		.loc 1 1616 0
 492 037c 00608DE5 		str	r6, [sp, #0]
 493 0380 FEFFFFEB 		bl	_txe_event_flags_get
 494 0384 006050E2 		subs	r6, r0, #0
 495 0388 BAFFFF1A 		bne	.L27
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 496              		.loc 1 1619 0
 497 038c 0420A0E1 		mov	r2, r4
 498 0390 0500A0E1 		mov	r0, r5
 499 0394 0110E0E3 		mvn	r1, #1
 500 0398 FEFFFFEB 		bl	_txe_event_flags_set
1622:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 501              		.loc 1 1622 0
 502 039c 0500A0E1 		mov	r0, r5
 503 03a0 0410A0E1 		mov	r1, r4
 504 03a4 0620A0E1 		mov	r2, r6
 505 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 506 03ac B1FFFFEA 		b	.L27
 507              	.L35:
 508              		.align	2
 509              	.L34:
 510 03b0 00000000 		.word	.LANCHOR0
 511 03b4 7C000000 		.word	.LC4
 512 03b8 38000000 		.word	.LC2
 513 03bc 58000000 		.word	.LC3
 514              	.LBE26:
 515              	.LBE27:
 516              		.cfi_endproc
 517              	.LFE9:
 519              		.align	2
 520              		.global	CyFxUvcApplnDmaCallback
 522              	CyFxUvcApplnDmaCallback:
 523              	.LFB11:
1829:../uvc.c      **** {
 524              		.loc 1 1829 0
 525              		.cfi_startproc
 526              		@ args = 0, pretend = 0, frame = 0
 527              		@ frame_needed = 0, uses_anonymous_args = 0
 528              	.LVL43:
1836:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 529              		.loc 1 1836 0
 530 03c0 080051E3 		cmp	r1, #8
1829:../uvc.c      **** {
 531              		.loc 1 1829 0
 532 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 533              	.LCFI4:
 534              		.cfi_def_cfa_offset 20
 535 03c8 0250A0E1 		mov	r5, r2
 536              		.cfi_offset 14, -4
 537              		.cfi_offset 7, -8
 538              		.cfi_offset 6, -12
 539              		.cfi_offset 5, -16
 540              		.cfi_offset 4, -20
 541 03cc 0CD04DE2 		sub	sp, sp, #12
 542              	.LCFI5:
 543              		.cfi_def_cfa_offset 32
1836:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 544              		.loc 1 1836 0
 545 03d0 0B00000A 		beq	.L42
1888:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 546              		.loc 1 1888 0
 547 03d4 100051E3 		cmp	r1, #16
 548 03d8 0700001A 		bne	.L36
1890:../uvc.c      ****         consCount++;
 549              		.loc 1 1890 0
 550 03dc 7C319FE5 		ldr	r3, .L45
1891:../uvc.c      ****         streamingStarted = CyTrue;
 551              		.loc 1 1891 0
 552 03e0 0120A0E3 		mov	r2, #1
 553              	.LVL44:
1890:../uvc.c      ****         consCount++;
 554              		.loc 1 1890 0
 555 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 556              	.LVL45:
1891:../uvc.c      ****         streamingStarted = CyTrue;
 557              		.loc 1 1891 0
 558 03e8 2C2083E5 		str	r2, [r3, #44]
1890:../uvc.c      ****         consCount++;
 559              		.loc 1 1890 0
 560 03ec 02C080E0 		add	ip, r0, r2
 561 03f0 0C18A0E1 		mov	r1, ip, asl #16
 562              	.LVL46:
 563 03f4 2128A0E1 		mov	r2, r1, lsr #16
 564 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 565              	.L36:
1893:../uvc.c      **** }
 566              		.loc 1 1893 0
 567 03fc 0CD08DE2 		add	sp, sp, #12
 568 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 569              	.LVL47:
 570              	.L42:
1838:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 571              		.loc 1 1838 0
 572 0404 B420D2E1 		ldrh	r2, [r2, #4]
 573 0408 54319FE5 		ldr	r3, .L45+4
 574 040c 030052E1 		cmp	r2, r3
 575 0410 3500000A 		beq	.L43
1858:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 576              		.loc 1 1858 0
 577 0414 006095E5 		ldr	r6, [r5, #0]
 578              	.LBB32:
 579              	.LBB34:
1577:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 580              		.loc 1 1577 0
 581 0418 48719FE5 		ldr	r7, .L45+8
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 582              		.loc 1 1576 0
 583 041c 0010E0E3 		mvn	r1, #0
 584              	.LVL48:
 585              	.LBE34:
 586              	.LBE32:
1858:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 587              		.loc 1 1858 0
 588 0420 0C4046E2 		sub	r4, r6, #12
 589              	.LVL49:
 590              	.LBB36:
 591              	.LBB33:
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 592              		.loc 1 1576 0
 593 0424 40019FE5 		ldr	r0, .L45+12
 594              	.LVL50:
 595 0428 FEFFFFEB 		bl	_txe_mutex_get
1577:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 596              		.loc 1 1577 0
 597 042c 0400A0E1 		mov	r0, r4
 598 0430 121D87E2 		add	r1, r7, #1152
 599 0434 0C20A0E3 		mov	r2, #12
 600 0438 FEFFFFEB 		bl	CyU3PMemCopy
1578:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 601              		.loc 1 1578 0
 602 043c 28019FE5 		ldr	r0, .L45+12
 603 0440 FEFFFFEB 		bl	_txe_mutex_put
1583:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 604              		.loc 1 1583 0
 605 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 606              	.LBE33:
 607              	.LBE36:
1859:../uvc.c      ****                 pb++;
 608              		.loc 1 1859 0
 609 0448 10419FE5 		ldr	r4, .L45
 610              	.LVL51:
 611              	.LBB37:
 612              	.LBB35:
1583:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 613              		.loc 1 1583 0
 614 044c 02108CE3 		orr	r1, ip, #2
 615 0450 0B1046E5 		strb	r1, [r6, #-11]
 616              	.LBE35:
 617              	.LBE37:
1859:../uvc.c      ****                 pb++;
 618              		.loc 1 1859 0
 619 0454 B603D4E1 		ldrh	r0, [r4, #54]
1865:../uvc.c      ****                 if(stiflag == 0x0F){
 620              		.loc 1 1865 0
 621 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
1860:../uvc.c      ****                 pbc = input->buffer_p.count;
 622              		.loc 1 1860 0
 623 045c B410D5E1 		ldrh	r1, [r5, #4]
1859:../uvc.c      ****                 pb++;
 624              		.loc 1 1859 0
 625 0460 013080E2 		add	r3, r0, #1
1865:../uvc.c      ****                 if(stiflag == 0x0F){
 626              		.loc 1 1865 0
 627 0464 0F0052E3 		cmp	r2, #15
1859:../uvc.c      ****                 pb++;
 628              		.loc 1 1859 0
 629 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1860:../uvc.c      ****                 pbc = input->buffer_p.count;
 630              		.loc 1 1860 0
 631 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1865:../uvc.c      ****                 if(stiflag == 0x0F){
 632              		.loc 1 1865 0
 633 0470 2E00000A 		beq	.L44
 634              	.L40:
1872:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 635              		.loc 1 1872 0
 636 0474 01E0A0E3 		mov	lr, #1
 637 0478 3CE084E5 		str	lr, [r4, #60]
 638              	.LVL52:
 639              	.L39:
1876:../uvc.c      ****             prodCount++;
 640              		.loc 1 1876 0
 641 047c B0E4D4E1 		ldrh	lr, [r4, #64]
1877:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 642              		.loc 1 1877 0
 643 0480 0C1081E2 		add	r1, r1, #12
1876:../uvc.c      ****             prodCount++;
 644              		.loc 1 1876 0
 645 0484 01308EE2 		add	r3, lr, #1
 646 0488 0308A0E1 		mov	r0, r3, asl #16
 647 048c 20C8A0E1 		mov	ip, r0, lsr #16
1877:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 648              		.loc 1 1877 0
 649 0490 0128A0E1 		mov	r2, r1, asl #16
 650 0494 2218A0E1 		mov	r1, r2, lsr #16
 651 0498 D0009FE5 		ldr	r0, .L45+16
 652 049c 0020A0E3 		mov	r2, #0
1876:../uvc.c      ****             prodCount++;
 653              		.loc 1 1876 0
 654 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
1877:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 655              		.loc 1 1877 0
 656 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 657              	.LVL53:
1876:../uvc.c      ****             prodCount++;
 658              		.loc 1 1876 0
 659 04a8 B0109FE5 		ldr	r1, .L45
1880:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 660              		.loc 1 1880 0
 661 04ac 002050E2 		subs	r2, r0, #0
 662 04b0 D1FFFF0A 		beq	.L36
1882:../uvc.c      ****                 prodCount--;
 663              		.loc 1 1882 0
 664 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 665              	.LVL54:
1883:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 666              		.loc 1 1883 0
 667 04b8 B430D5E1 		ldrh	r3, [r5, #4]
1882:../uvc.c      ****                 prodCount--;
 668              		.loc 1 1882 0
 669 04bc 01E040E2 		sub	lr, r0, #1
 670 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 671 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 672 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
1883:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 673              		.loc 1 1883 0
 674 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 675 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 676 04d4 0400A0E3 		mov	r0, #4
 677 04d8 94109FE5 		ldr	r1, .L45+20
 678 04dc 00E08DE5 		str	lr, [sp, #0]
 679 04e0 04C08DE5 		str	ip, [sp, #4]
 680 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 681              	.LVL55:
 682 04e8 C3FFFFEA 		b	.L36
 683              	.LVL56:
 684              	.L43:
1852:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 685              		.loc 1 1852 0
 686 04ec 006095E5 		ldr	r6, [r5, #0]
 687              	.LBB38:
 688              	.LBB39:
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 689              		.loc 1 1576 0
 690 04f0 0010E0E3 		mvn	r1, #0
 691              	.LVL57:
 692              	.LBE39:
 693              	.LBE38:
1853:../uvc.c      ****                 fb++;
 694              		.loc 1 1853 0
 695 04f4 64409FE5 		ldr	r4, .L45
1852:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 696              		.loc 1 1852 0
 697 04f8 0C6046E2 		sub	r6, r6, #12
 698              	.LVL58:
 699              	.LBB41:
 700              	.LBB40:
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 701              		.loc 1 1576 0
 702 04fc 68009FE5 		ldr	r0, .L45+12
 703              	.LVL59:
 704 0500 FEFFFFEB 		bl	_txe_mutex_get
1577:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 705              		.loc 1 1577 0
 706 0504 6C109FE5 		ldr	r1, .L45+24
 707 0508 0600A0E1 		mov	r0, r6
 708 050c 0C20A0E3 		mov	r2, #12
 709 0510 FEFFFFEB 		bl	CyU3PMemCopy
1578:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 710              		.loc 1 1578 0
 711 0514 50009FE5 		ldr	r0, .L45+12
 712 0518 FEFFFFEB 		bl	_txe_mutex_put
 713              	.LBE40:
 714              	.LBE41:
1853:../uvc.c      ****                 fb++;
 715              		.loc 1 1853 0
 716 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 717 0520 B410D5E1 		ldrh	r1, [r5, #4]
 718 0524 01008CE2 		add	r0, ip, #1
 719 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 720 052c D2FFFFEA 		b	.L39
 721              	.LVL60:
 722              	.L44:
1866:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 723              		.loc 1 1866 0
 724 0530 0010E0E3 		mvn	r1, #0
 725 0534 30009FE5 		ldr	r0, .L45+12
 726 0538 FEFFFFEB 		bl	_txe_mutex_get
1867:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 727              		.loc 1 1867 0
 728 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1868:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 729              		.loc 1 1868 0
 730 0540 24009FE5 		ldr	r0, .L45+12
1867:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 731              		.loc 1 1867 0
 732 0544 DF2001E2 		and	r2, r1, #223
 733 0548 8124C7E5 		strb	r2, [r7, #1153]
1868:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 734              		.loc 1 1868 0
 735 054c FEFFFFEB 		bl	_txe_mutex_put
1869:../uvc.c      ****                 	stiflag = 0xAA;
 736              		.loc 1 1869 0
 737 0550 5530E0E3 		mvn	r3, #85
 738 0554 3A30C4E5 		strb	r3, [r4, #58]
 739 0558 B410D5E1 		ldrh	r1, [r5, #4]
 740 055c C4FFFFEA 		b	.L40
 741              	.L46:
 742              		.align	2
 743              	.L45:
 744 0560 00000000 		.word	.LANCHOR0
 745 0564 F03F0000 		.word	16368
 746 0568 00000000 		.word	.LANCHOR1
 747 056c 00000000 		.word	imgHdMux
 748 0570 00000000 		.word	glChHandleUVCStream
 749 0574 9C000000 		.word	.LC5
 750 0578 80040000 		.word	.LANCHOR1+1152
 751              		.cfi_endproc
 752              	.LFE11:
 754              		.align	2
 756              	CyFxUVCApplnUSBSetupCB:
 757              	.LFB10:
1677:../uvc.c      **** {
 758              		.loc 1 1677 0
 759              		.cfi_startproc
 760              		@ args = 0, pretend = 0, frame = 8
 761              		@ frame_needed = 0, uses_anonymous_args = 0
 762              	.LVL61:
1682:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 763              		.loc 1 1682 0
 764 057c C0329FE5 		ldr	r3, .L72
1677:../uvc.c      **** {
 765              		.loc 1 1677 0
 766 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 767              	.LCFI6:
 768              		.cfi_def_cfa_offset 24
1683:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 769              		.loc 1 1683 0
 770 0584 BCC29FE5 		ldr	ip, .L72+4
1682:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 771              		.loc 1 1682 0
 772 0588 FF4000E2 		and	r4, r0, #255
 773              		.cfi_offset 14, -4
 774              		.cfi_offset 8, -8
 775              		.cfi_offset 7, -12
 776              		.cfi_offset 6, -16
 777              		.cfi_offset 5, -20
 778              		.cfi_offset 4, -24
1683:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 779              		.loc 1 1683 0
 780 058c FF8C00E2 		and	r8, r0, #65280
1684:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 781              		.loc 1 1684 0
 782 0590 2078A0E1 		mov	r7, r0, lsr #16
1682:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 783              		.loc 1 1682 0
 784 0594 0040C3E5 		strb	r4, [r3, #0]
1684:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 785              		.loc 1 1684 0
 786 0598 AC229FE5 		ldr	r2, .L72+8
1685:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 787              		.loc 1 1685 0
 788 059c AC029FE5 		ldr	r0, .L72+12
 789              	.LVL62:
1686:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 790              		.loc 1 1686 0
 791 05a0 AC329FE5 		ldr	r3, .L72+16
1685:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 792              		.loc 1 1685 0
 793 05a4 0158A0E1 		mov	r5, r1, asl #16
1683:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 794              		.loc 1 1683 0
 795 05a8 2884A0E1 		mov	r8, r8, lsr #8
1685:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 796              		.loc 1 1685 0
 797 05ac 2558A0E1 		mov	r5, r5, lsr #16
1686:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 798              		.loc 1 1686 0
 799 05b0 2118A0E1 		mov	r1, r1, lsr #16
 800              	.LVL63:
1689:../uvc.c      ****     switch (bmReqType)
 801              		.loc 1 1689 0
 802 05b4 020054E3 		cmp	r4, #2
1677:../uvc.c      **** {
 803              		.loc 1 1677 0
 804 05b8 10D04DE2 		sub	sp, sp, #16
 805              	.LCFI7:
 806              		.cfi_def_cfa_offset 40
1683:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 807              		.loc 1 1683 0
 808 05bc 0080CCE5 		strb	r8, [ip, #0]
1684:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 809              		.loc 1 1684 0
 810 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1685:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 811              		.loc 1 1685 0
 812 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1686:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 813              		.loc 1 1686 0
 814 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1689:../uvc.c      ****     switch (bmReqType)
 815              		.loc 1 1689 0
 816 05cc 4F00000A 		beq	.L50
 817 05d0 0600009A 		bls	.L68
 818 05d4 210054E3 		cmp	r4, #33
 819 05d8 3A00000A 		beq	.L51
 820 05dc A10054E3 		cmp	r4, #161
 821 05e0 3800000A 		beq	.L51
 822              	.L65:
1678:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 823              		.loc 1 1678 0
 824 05e4 0000A0E3 		mov	r0, #0
 825              	.LVL64:
 826              	.L48:
1816:../uvc.c      **** }
 827              		.loc 1 1816 0
 828 05e8 10D08DE2 		add	sp, sp, #16
 829 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 830              	.LVL65:
 831              	.L68:
1689:../uvc.c      ****     switch (bmReqType)
 832              		.loc 1 1689 0
 833 05f0 010054E3 		cmp	r4, #1
 834 05f4 FAFFFF1A 		bne	.L65
1729:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 835              		.loc 1 1729 0
 836 05f8 0B0058E3 		cmp	r8, #11
 837 05fc F8FFFF1A 		bne	.L65
1733:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 838              		.loc 1 1733 0
 839 0600 010055E3 		cmp	r5, #1
 840 0604 F6FFFF1A 		bne	.L65
1733:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 841              		.loc 1 1733 0 is_stmt 0 discriminator 1
 842 0608 000057E3 		cmp	r7, #0
 843 060c F4FFFF1A 		bne	.L65
1738:../uvc.c      ****                     gpif_initialized = 0;
 844              		.loc 1 1738 0 is_stmt 1
 845 0610 40429FE5 		ldr	r4, .L72+20
1736:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 846              		.loc 1 1736 0
 847 0614 40129FE5 		ldr	r1, .L72+24
 848 0618 0400A0E3 		mov	r0, #4
 849 061c FEFFFFEB 		bl	CyU3PDebugPrint
1737:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 850              		.loc 1 1737 0
 851 0620 0500A0E1 		mov	r0, r5
 852 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1741:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 853              		.loc 1 1741 0
 854 0628 0510A0E1 		mov	r1, r5
 855 062c 8300A0E3 		mov	r0, #131
1738:../uvc.c      ****                     gpif_initialized = 0;
 856              		.loc 1 1738 0
 857 0630 287084E5 		str	r7, [r4, #40]
1739:../uvc.c      ****                     streamingStarted = CyFalse;
 858              		.loc 1 1739 0
 859 0634 2C7084E5 		str	r7, [r4, #44]
1741:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 860              		.loc 1 1741 0
 861 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1742:../uvc.c      ****                     CyU3PBusyWait (100);
 862              		.loc 1 1742 0
 863 063c 6400A0E3 		mov	r0, #100
 864 0640 FEFFFFEB 		bl	CyU3PBusyWait
1745:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 865              		.loc 1 1745 0
 866 0644 14029FE5 		ldr	r0, .L72+28
 867 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1746:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 868              		.loc 1 1746 0
 869 064c 8300A0E3 		mov	r0, #131
 870 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1747:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 871              		.loc 1 1747 0
 872 0654 0710A0E1 		mov	r1, r7
 873 0658 8300A0E3 		mov	r0, #131
 874 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1748:../uvc.c      ****                     CyU3PBusyWait (100);
 875              		.loc 1 1748 0
 876 0660 6400A0E3 		mov	r0, #100
 877 0664 FEFFFFEB 		bl	CyU3PBusyWait
1751:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 878              		.loc 1 1751 0
 879 0668 0710A0E1 		mov	r1, r7
 880 066c 0520A0E1 		mov	r2, r5
 881 0670 8300A0E3 		mov	r0, #131
 882 0674 FEFFFFEB 		bl	CyU3PUsbStall
 883              	.LVL66:
1754:../uvc.c      ****                     CyU3PUsbAckSetup ();
 884              		.loc 1 1754 0
 885 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1756:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 886              		.loc 1 1756 0
 887 067c 445084E5 		str	r5, [r4, #68]
 888              	.LBB46:
 889              	.LBB47:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 890              		.loc 1 1616 0
 891 0680 0400A0E1 		mov	r0, r4
 892 0684 0510A0E1 		mov	r1, r5
 893 0688 0220A0E3 		mov	r2, #2
 894 068c 0C308DE2 		add	r3, sp, #12
 895 0690 00708DE5 		str	r7, [sp, #0]
 896 0694 FEFFFFEB 		bl	_txe_event_flags_get
 897 0698 006050E2 		subs	r6, r0, #0
 898 069c 2E00001A 		bne	.L63
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 899              		.loc 1 1619 0
 900 06a0 0110E0E3 		mvn	r1, #1
 901 06a4 0220A0E3 		mov	r2, #2
 902 06a8 0400A0E1 		mov	r0, r4
 903 06ac FEFFFFEB 		bl	_txe_event_flags_set
1622:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 904              		.loc 1 1622 0
 905 06b0 0400A0E1 		mov	r0, r4
 906 06b4 0210A0E3 		mov	r1, #2
 907 06b8 0620A0E1 		mov	r2, r6
 908 06bc FEFFFFEB 		bl	_txe_event_flags_set
1752:../uvc.c      ****                     uvcHandleReq = CyTrue;
 909              		.loc 1 1752 0
 910 06c0 0500A0E1 		mov	r0, r5
 911 06c4 C7FFFFEA 		b	.L48
 912              	.LVL67:
 913              	.L51:
 914              	.LBE47:
 915              	.LBE46:
1694:../uvc.c      ****             switch (wIndex & 0xFF)
 916              		.loc 1 1694 0
 917 06c8 FF5015E2 		ands	r5, r5, #255
 918 06cc 1A00001A 		bne	.L69
 919              	.LVL68:
1699:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 920              		.loc 1 1699 0
 921 06d0 0520A0E1 		mov	r2, r5
 922 06d4 7C019FE5 		ldr	r0, .L72+20
 923 06d8 0410A0E3 		mov	r1, #4
 924 06dc FEFFFFEB 		bl	_txe_event_flags_set
 925              	.LVL69:
1701:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 926              		.loc 1 1701 0
 927 06e0 002050E2 		subs	r2, r0, #0
1698:../uvc.c      ****                         uvcHandleReq = CyTrue;
 928              		.loc 1 1698 0
 929 06e4 0100A003 		moveq	r0, #1
 930              	.LVL70:
1701:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 931              		.loc 1 1701 0
 932 06e8 BEFFFF0A 		beq	.L48
1703:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 933              		.loc 1 1703 0
 934 06ec 70119FE5 		ldr	r1, .L72+32
 935 06f0 0400A0E3 		mov	r0, #4
 936 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 937              	.LVL71:
1704:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 938              		.loc 1 1704 0
 939 06f8 0500A0E1 		mov	r0, r5
 940 06fc 0110A0E3 		mov	r1, #1
 941 0700 0520A0E1 		mov	r2, r5
 942 0704 FEFFFFEB 		bl	CyU3PUsbStall
1698:../uvc.c      ****                         uvcHandleReq = CyTrue;
 943              		.loc 1 1698 0
 944 0708 0100A0E3 		mov	r0, #1
 945 070c B5FFFFEA 		b	.L48
 946              	.LVL72:
 947              	.L50:
1764:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 948              		.loc 1 1764 0
 949 0710 010058E3 		cmp	r8, #1
 950 0714 B2FFFF1A 		bne	.L65
1766:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 951              		.loc 1 1766 0
 952 0718 830055E3 		cmp	r5, #131
 953 071c B0FFFF1A 		bne	.L65
1772:../uvc.c      ****                     if (streamingStarted == CyTrue)
 954              		.loc 1 1772 0
 955 0720 30719FE5 		ldr	r7, .L72+20
 956 0724 2C6097E5 		ldr	r6, [r7, #44]
 957 0728 010056E3 		cmp	r6, #1
 958 072c 1500000A 		beq	.L70
 959              	.LVL73:
1804:../uvc.c      ****                         CyU3PUsbAckSetup ();
 960              		.loc 1 1804 0
 961 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1803:../uvc.c      ****                         uvcHandleReq = CyTrue;
 962              		.loc 1 1803 0
 963 0734 0800A0E1 		mov	r0, r8
 964 0738 AAFFFFEA 		b	.L48
 965              	.LVL74:
 966              	.L69:
1694:../uvc.c      ****             switch (wIndex & 0xFF)
 967              		.loc 1 1694 0
 968 073c 010055E3 		cmp	r5, #1
 969 0740 A7FFFF1A 		bne	.L65
 970              	.LVL75:
1712:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 971              		.loc 1 1712 0
 972 0744 0020A0E3 		mov	r2, #0
 973 0748 08019FE5 		ldr	r0, .L72+20
 974 074c 0810A0E3 		mov	r1, #8
 975 0750 FEFFFFEB 		bl	_txe_event_flags_set
 976              	.LVL76:
1714:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 977              		.loc 1 1714 0
 978 0754 002050E2 		subs	r2, r0, #0
 979 0758 0100001A 		bne	.L71
 980              	.LVL77:
 981              	.L63:
 982              	.LBB49:
 983              	.LBB48:
1752:../uvc.c      ****                     uvcHandleReq = CyTrue;
 984              		.loc 1 1752 0
 985 075c 0500A0E1 		mov	r0, r5
 986 0760 A0FFFFEA 		b	.L48
 987              	.LVL78:
 988              	.L71:
 989              	.LBE48:
 990              	.LBE49:
1717:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 991              		.loc 1 1717 0
 992 0764 FC109FE5 		ldr	r1, .L72+36
 993 0768 0400A0E3 		mov	r0, #4
 994              	.LVL79:
 995 076c FEFFFFEB 		bl	CyU3PDebugPrint
 996              	.LVL80:
1718:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 997              		.loc 1 1718 0
 998 0770 0000A0E3 		mov	r0, #0
 999 0774 0510A0E1 		mov	r1, r5
 1000 0778 0020A0E1 		mov	r2, r0
 1001 077c FEFFFFEB 		bl	CyU3PUsbStall
1711:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1002              		.loc 1 1711 0
 1003 0780 0500A0E1 		mov	r0, r5
 1004 0784 97FFFFEA 		b	.L48
 1005              	.LVL81:
 1006              	.L70:
1774:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1007              		.loc 1 1774 0
 1008 0788 DC109FE5 		ldr	r1, .L72+40
 1009 078c 0400A0E3 		mov	r0, #4
 1010 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1778:../uvc.c      ****                         gpif_initialized = 0;
 1011              		.loc 1 1778 0
 1012 0794 0080A0E3 		mov	r8, #0
1777:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1013              		.loc 1 1777 0
 1014 0798 0600A0E1 		mov	r0, r6
 1015 079c FEFFFFEB 		bl	CyU3PGpifDisable
1782:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1016              		.loc 1 1782 0
 1017 07a0 0610A0E1 		mov	r1, r6
 1018 07a4 0500A0E1 		mov	r0, r5
1778:../uvc.c      ****                         gpif_initialized = 0;
 1019              		.loc 1 1778 0
 1020 07a8 288087E5 		str	r8, [r7, #40]
1779:../uvc.c      ****                         streamingStarted = CyFalse;
 1021              		.loc 1 1779 0
 1022 07ac 2C8087E5 		str	r8, [r7, #44]
1782:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1023              		.loc 1 1782 0
 1024 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1783:../uvc.c      ****                         CyU3PBusyWait (100);
 1025              		.loc 1 1783 0
 1026 07b4 6400A0E3 		mov	r0, #100
 1027 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1786:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1028              		.loc 1 1786 0
 1029 07bc 9C009FE5 		ldr	r0, .L72+28
 1030 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1787:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1031              		.loc 1 1787 0
 1032 07c4 0500A0E1 		mov	r0, r5
 1033 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1788:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1034              		.loc 1 1788 0
 1035 07cc 0810A0E1 		mov	r1, r8
 1036 07d0 0500A0E1 		mov	r0, r5
 1037 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1789:../uvc.c      ****                         CyU3PBusyWait (100);
 1038              		.loc 1 1789 0
 1039 07d8 6400A0E3 		mov	r0, #100
 1040 07dc FEFFFFEB 		bl	CyU3PBusyWait
1792:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1041              		.loc 1 1792 0
 1042 07e0 0810A0E1 		mov	r1, r8
 1043 07e4 0620A0E1 		mov	r2, r6
 1044 07e8 0500A0E1 		mov	r0, r5
 1045 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1046              	.LVL82:
1796:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1047              		.loc 1 1796 0
 1048 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1798:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1049              		.loc 1 1798 0
 1050 07f4 446087E5 		str	r6, [r7, #68]
 1051              	.LBB50:
 1052              	.LBB51:
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1053              		.loc 1 1616 0
 1054 07f8 0700A0E1 		mov	r0, r7
 1055 07fc 0610A0E1 		mov	r1, r6
 1056 0800 0420A0E1 		mov	r2, r4
 1057 0804 0C308DE2 		add	r3, sp, #12
 1058 0808 00808DE5 		str	r8, [sp, #0]
 1059 080c FEFFFFEB 		bl	_txe_event_flags_get
 1060 0810 005050E2 		subs	r5, r0, #0
1794:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1061              		.loc 1 1794 0
 1062 0814 0600A011 		movne	r0, r6
1616:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1063              		.loc 1 1616 0
 1064 0818 72FFFF1A 		bne	.L48
1619:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1065              		.loc 1 1619 0
 1066 081c 0110E0E3 		mvn	r1, #1
 1067 0820 0420A0E1 		mov	r2, r4
 1068 0824 0700A0E1 		mov	r0, r7
 1069 0828 FEFFFFEB 		bl	_txe_event_flags_set
1622:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1070              		.loc 1 1622 0
 1071 082c 0700A0E1 		mov	r0, r7
 1072 0830 0410A0E1 		mov	r1, r4
 1073 0834 0520A0E1 		mov	r2, r5
 1074 0838 FEFFFFEB 		bl	_txe_event_flags_set
1794:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1075              		.loc 1 1794 0
 1076 083c 0600A0E1 		mov	r0, r6
 1077 0840 68FFFFEA 		b	.L48
 1078              	.L73:
 1079              		.align	2
 1080              	.L72:
 1081 0844 00000000 		.word	bmReqType
 1082 0848 00000000 		.word	bRequest
 1083 084c 00000000 		.word	wValue
 1084 0850 00000000 		.word	wIndex
 1085 0854 00000000 		.word	wLength
 1086 0858 00000000 		.word	.LANCHOR0
 1087 085c 54010000 		.word	.LC8
 1088 0860 00000000 		.word	glChHandleUVCStream
 1089 0864 E8000000 		.word	.LC6
 1090 0868 20010000 		.word	.LC7
 1091 086c 6C010000 		.word	.LC9
 1092              	.LBE51:
 1093              	.LBE50:
 1094              		.cfi_endproc
 1095              	.LFE10:
 1097              		.align	2
 1098              		.global	CyFxGpifCB
 1100              	CyFxGpifCB:
 1101              	.LFB13:
2015:../uvc.c      **** {
 1102              		.loc 1 2015 0
 1103              		.cfi_startproc
 1104              		@ args = 0, pretend = 0, frame = 0
 1105              		@ frame_needed = 0, uses_anonymous_args = 0
 1106              	.LVL83:
2016:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1107              		.loc 1 2016 0
 1108 0870 010050E3 		cmp	r0, #1
2015:../uvc.c      **** {
 1109              		.loc 1 2015 0
 1110 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1111              	.LCFI8:
 1112              		.cfi_def_cfa_offset 8
2015:../uvc.c      **** {
 1113              		.loc 1 2015 0
 1114 0878 0120A0E1 		mov	r2, r1
2016:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1115              		.loc 1 2016 0
 1116 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1117              		.cfi_offset 14, -4
 1118              		.cfi_offset 4, -8
 1119              	.LVL84:
 1120              	.LBB56:
 1121              	.LBB57:
1913:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1122              		.loc 1 1913 0
 1123 0880 CC309FE5 		ldr	r3, .L89
 1124 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1125 0888 030053E3 		cmp	r3, #3
 1126 088c 2100000A 		beq	.L88
1939:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1127              		.loc 1 1939 0
 1128 0890 020053E3 		cmp	r3, #2
 1129 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
1941:../uvc.c      ****         switch (stateId)
 1130              		.loc 1 1941 0
 1131 0898 080041E2 		sub	r0, r1, #8
 1132              	.LVL85:
 1133 089c 0A0050E3 		cmp	r0, #10
 1134 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1135 08a4 230000EA 		b	.L81
 1136              	.L83:
 1137 08a8 D8080000 		.word	.L78
 1138 08ac 38090000 		.word	.L81
 1139 08b0 38090000 		.word	.L81
 1140 08b4 D4080000 		.word	.L74
 1141 08b8 38090000 		.word	.L81
 1142 08bc 38090000 		.word	.L81
 1143 08c0 38090000 		.word	.L81
 1144 08c4 10090000 		.word	.L87
 1145 08c8 38090000 		.word	.L81
 1146 08cc 38090000 		.word	.L81
 1147 08d0 D4080000 		.word	.L74
 1148              	.LVL86:
 1149              	.L74:
 1150 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1151              	.LVL87:
 1152              	.L78:
1924:../uvc.c      ****                 socket = 0;
 1153              		.loc 1 1924 0
 1154 08d8 0010A0E3 		mov	r1, #0
 1155              	.LVL88:
 1156              	.L79:
1998:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1157              		.loc 1 1998 0
 1158 08dc 74009FE5 		ldr	r0, .L89+4
 1159 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1160              	.LVL89:
1999:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1161              		.loc 1 1999 0
 1162 08e4 002050E2 		subs	r2, r0, #0
 1163 08e8 F9FFFF0A 		beq	.L74
2001:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1164              		.loc 1 2001 0
 1165 08ec 0400A0E3 		mov	r0, #4
 1166              	.LVL90:
 1167 08f0 64109FE5 		ldr	r1, .L89+8
 1168 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1169              	.LVL91:
 1170              	.L84:
 1171              	.LBB58:
 1172              	.LBB59:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1173              		.loc 1 1603 0
 1174 08f8 60109FE5 		ldr	r1, .L89+12
 1175 08fc 0400A0E3 		mov	r0, #4
 1176 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 1177              		.loc 1 1604 0
 1178 0904 FA0FA0E3 		mov	r0, #1000
 1179 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1180 090c F9FFFFEA 		b	.L84
 1181              	.LVL92:
 1182              	.L87:
 1183              	.LBE59:
 1184              	.LBE58:
1968:../uvc.c      ****                 socket = 1;
 1185              		.loc 1 1968 0
 1186 0910 0110A0E3 		mov	r1, #1
 1187              	.LVL93:
 1188 0914 F0FFFFEA 		b	.L79
 1189              	.LVL94:
 1190              	.L88:
1915:../uvc.c      ****         switch (stateId)
 1191              		.loc 1 1915 0
 1192 0918 0B2041E2 		sub	r2, r1, #11
 1193 091c 030052E3 		cmp	r2, #3
 1194 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1195 0924 060000EA 		b	.L77
 1196              	.L80:
 1197 0928 D8080000 		.word	.L78
 1198 092c 10090000 		.word	.L87
 1199 0930 D4080000 		.word	.L74
 1200 0934 D4080000 		.word	.L74
 1201              	.LVL95:
 1202              	.L81:
1987:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1203              		.loc 1 1987 0
 1204 0938 24109FE5 		ldr	r1, .L89+16
 1205              	.LVL96:
 1206 093c 0100A0E3 		mov	r0, #1
 1207 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1208              	.LVL97:
 1209              	.L77:
 1210              	.LBE57:
 1211              	.LBE56:
2022:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1212              		.loc 1 2022 0
 1213 0944 1C109FE5 		ldr	r1, .L89+20
 1214 0948 0400A0E3 		mov	r0, #4
2025:../uvc.c      **** }
 1215              		.loc 1 2025 0
 1216 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
2022:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1217              		.loc 1 2022 0
 1218 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1219              	.L90:
 1220              		.align	2
 1221              	.L89:
 1222 0954 00000000 		.word	.LANCHOR0
 1223 0958 00000000 		.word	glChHandleUVCStream
 1224 095c A8010000 		.word	.LC11
 1225 0960 D8010000 		.word	.LC12
 1226 0964 90010000 		.word	.LC10
 1227 0968 EC010000 		.word	.LC13
 1228              		.cfi_endproc
 1229              	.LFE13:
 1231              		.align	2
 1232              		.global	I2CCmdHandler
 1234              	I2CCmdHandler:
 1235              	.LFB0:
 493:../uvc.c      **** void I2CCmdHandler(){
 1236              		.loc 1 493 0
 1237              		.cfi_startproc
 1238              		@ args = 0, pretend = 0, frame = 16
 1239              		@ frame_needed = 0, uses_anonymous_args = 0
 1240 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1241              	.LCFI9:
 1242              		.cfi_def_cfa_offset 36
 496:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1243              		.loc 1 496 0
 1244 0970 40429FE5 		ldr	r4, .L106
 1245              		.cfi_offset 14, -4
 1246              		.cfi_offset 11, -8
 1247              		.cfi_offset 10, -12
 1248              		.cfi_offset 9, -16
 1249              		.cfi_offset 8, -20
 1250              		.cfi_offset 7, -24
 1251              		.cfi_offset 6, -28
 1252              		.cfi_offset 5, -32
 1253              		.cfi_offset 4, -36
 493:../uvc.c      **** void I2CCmdHandler(){
 1254              		.loc 1 493 0
 1255 0974 3CD04DE2 		sub	sp, sp, #60
 1256              	.LCFI10:
 1257              		.cfi_def_cfa_offset 96
 501:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1258              		.loc 1 501 0
 1259 0978 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 496:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1260              		.loc 1 496 0
 1261 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1262              	.LVL98:
 497:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1263              		.loc 1 497 0
 1264 0980 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1265              	.LVL99:
 498:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1266              		.loc 1 498 0
 1267 0984 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1268              	.LVL100:
 501:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1269              		.loc 1 501 0
 1270 0988 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1271 098c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1272 0990 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1273 0994 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1274 0998 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1275 099c 14208DE5 		str	r2, [sp, #20]
 1276 09a0 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1277 09a4 0730A0E1 		mov	r3, r7
 1278 09a8 1C108DE5 		str	r1, [sp, #28]
 1279 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1280 09b0 0400A0E3 		mov	r0, #4
 1281 09b4 00129FE5 		ldr	r1, .L106+4
 1282 09b8 0520A0E1 		mov	r2, r5
 1283 09bc 00E08DE5 		str	lr, [sp, #0]
 1284 09c0 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1285 09c4 0C908DE5 		str	r9, [sp, #12]
 1286 09c8 10B08DE5 		str	fp, [sp, #16]
 1287 09cc 18608DE5 		str	r6, [sp, #24]
 1288 09d0 20C08DE5 		str	ip, [sp, #32]
 1289 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 504:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1290              		.loc 1 504 0
 1291 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1292 09dc 520053E3 		cmp	r3, #82
 1293 09e0 2C00000A 		beq	.L102
 1294              	.L92:
 514:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1295              		.loc 1 514 0
 1296 09e4 000055E3 		cmp	r5, #0
 1297 09e8 1600000A 		beq	.L103
 539:../uvc.c      **** 	}else if(CmdType == 1){
 1298              		.loc 1 539 0
 1299 09ec 010055E3 		cmp	r5, #1
 1300 09f0 0100000A 		beq	.L104
 1301              	.LVL101:
 1302              	.L91:
 558:../uvc.c      **** }
 1303              		.loc 1 558 0
 1304 09f4 3CD08DE2 		add	sp, sp, #60
 1305 09f8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1306              	.LVL102:
 1307              	.L104:
 541:../uvc.c      **** 			if(CmdRegLen == 2){
 1308              		.loc 1 541 0
 1309 09fc 020057E3 		cmp	r7, #2
 1310 0a00 3700000A 		beq	.L105
 546:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1311              		.loc 1 546 0
 1312 0a04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1313 0a08 A8319FE5 		ldr	r3, .L106
 1314 0a0c FE1001E2 		and	r1, r1, #254
 1315 0a10 820051E3 		cmp	r1, #130
 549:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1316              		.loc 1 549 0
 1317 0a14 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1318              	.LVL103:
 546:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1319              		.loc 1 546 0
 1320 0a18 0200001A 		bne	.L101
 546:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1321              		.loc 1 546 0 is_stmt 0 discriminator 1
 1322 0a1c 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1323 0a20 300055E3 		cmp	r5, #48
 1324 0a24 4F00000A 		beq	.L99
 1325              	.L101:
 549:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1326              		.loc 1 549 0 is_stmt 1
 1327 0a28 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1328              	.L100:
 551:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1329              		.loc 1 551 0
 1330 0a2c 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1331 0a30 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1332 0a34 FE0002E2 		and	r0, r2, #254
 1333 0a38 0520A0E1 		mov	r2, r5
 1334 0a3c 00E08DE5 		str	lr, [sp, #0]
 1335 0a40 FEFFFFEB 		bl	SensorWrite2B
 1336 0a44 EAFFFFEA 		b	.L91
 1337              	.LVL104:
 1338              	.L103:
 530:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1339              		.loc 1 530 0
 1340 0a48 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1341 0a4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 516:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1342              		.loc 1 516 0
 1343 0a50 0FE0A0E3 		mov	lr, #15
 530:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1344              		.loc 1 530 0
 1345 0a54 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1346 0a58 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 516:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1347              		.loc 1 516 0
 1348 0a5c 57E0C4E5 		strb	lr, [r4, #87]
 530:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1349              		.loc 1 530 0
 1350 0a60 34C08DE2 		add	ip, sp, #52
 1351 0a64 010080E3 		orr	r0, r0, #1
 1352 0a68 011081E3 		orr	r1, r1, #1
 1353 0a6c 00C08DE5 		str	ip, [sp, #0]
 1354 0a70 FEFFFFEB 		bl	SensorRead2B
 531:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1355              		.loc 1 531 0
 1356 0a74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 532:../uvc.c      **** 				if(CmdDataLen == 2){
 1357              		.loc 1 532 0
 1358 0a78 020056E3 		cmp	r6, #2
 531:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1359              		.loc 1 531 0
 1360 0a7c 5530C4E5 		strb	r3, [r4, #85]
 533:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1361              		.loc 1 533 0
 1362 0a80 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1363 0a84 2C319F05 		ldreq	r3, .L106
 535:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1364              		.loc 1 535 0
 1365 0a88 0020E0E3 		mvn	r2, #0
 1366 0a8c 5720C4E5 		strb	r2, [r4, #87]
 533:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1367              		.loc 1 533 0
 1368 0a90 5600C305 		streqb	r0, [r3, #86]
 1369 0a94 D6FFFFEA 		b	.L91
 1370              	.L102:
 504:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1371              		.loc 1 504 0 discriminator 1
 1372 0a98 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1373 0a9c 300050E3 		cmp	r0, #48
 1374 0aa0 CFFFFF1A 		bne	.L92
 1375 0aa4 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1376 0aa8 010053E3 		cmp	r3, #1
 1377 0aac CCFFFF1A 		bne	.L92
 506:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1378              		.loc 1 506 0
 1379 0ab0 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1380 0ab4 04C19FE5 		ldr	ip, .L106+8
 1381 0ab8 031002E2 		and	r1, r2, #3
 1382 0abc 8C14CCE5 		strb	r1, [ip, #1164]
 507:../uvc.c      **** 		if(is60Hz==CyFalse)
 1383              		.loc 1 507 0
 1384 0ac0 58E094E5 		ldr	lr, [r4, #88]
 511:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1385              		.loc 1 511 0
 1386 0ac4 F8109FE5 		ldr	r1, .L106+12
 507:../uvc.c      **** 		if(is60Hz==CyFalse)
 1387              		.loc 1 507 0
 1388 0ac8 00005EE3 		cmp	lr, #0
 509:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1389              		.loc 1 509 0
 1390 0acc 80208203 		orreq	r2, r2, #128
 1391 0ad0 5520C405 		streqb	r2, [r4, #85]
 511:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1392              		.loc 1 511 0
 1393 0ad4 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1394 0ad8 0400A0E3 		mov	r0, #4
 1395 0adc FEFFFFEB 		bl	CyU3PDebugPrint
 1396 0ae0 BFFFFFEA 		b	.L92
 1397              	.L105:
 543:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1398              		.loc 1 543 0
 1399 0ae4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1400 0ae8 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1401 0aec 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1402 0af0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1403 0af4 0020A0E3 		mov	r2, #0
 1404 0af8 FE0000E2 		and	r0, r0, #254
 1405 0afc 00E08DE5 		str	lr, [sp, #0]
 1406 0b00 FEFFFFEB 		bl	SensorWrite2B2
 1407 0b04 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1408 0b08 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1409 0b0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1410 0b10 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1411 0b14 FE0002E2 		and	r0, r2, #254
 1412 0b18 0020A0E3 		mov	r2, #0
 1413 0b1c 00C08DE5 		str	ip, [sp, #0]
 1414 0b20 FEFFFFEB 		bl	SensorWrite2B2
 1415              	.LVL105:
 1416 0b24 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1417 0b28 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1418 0b2c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1419 0b30 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1420 0b34 0020A0E3 		mov	r2, #0
 1421 0b38 FE0000E2 		and	r0, r0, #254
 1422 0b3c 00C08DE5 		str	ip, [sp, #0]
 1423 0b40 FEFFFFEB 		bl	SensorWrite2B2
 1424 0b44 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1425 0b48 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1426 0b4c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1427 0b50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1428 0b54 FE0002E2 		and	r0, r2, #254
 1429 0b58 0020A0E3 		mov	r2, #0
 1430 0b5c 00C08DE5 		str	ip, [sp, #0]
 1431 0b60 FEFFFFEB 		bl	SensorWrite2B2
 1432 0b64 A2FFFFEA 		b	.L91
 1433              	.LVL106:
 1434              	.L99:
 546:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1435              		.loc 1 546 0 discriminator 1
 1436 0b68 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1437 0b6c 100053E3 		cmp	r3, #16
 1438 0b70 ADFFFF1A 		bne	.L100
 547:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1439              		.loc 1 547 0
 1440 0b74 4C409FE5 		ldr	r4, .L106+16
 1441 0b78 0010E0E3 		mvn	r1, #0
 1442 0b7c 1C0094E5 		ldr	r0, [r4, #28]
 1443 0b80 2C308DE5 		str	r3, [sp, #44]
 1444 0b84 FEFFFFEB 		bl	_txe_mutex_get
 548:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1445              		.loc 1 548 0
 1446 0b88 2C309DE5 		ldr	r3, [sp, #44]
 1447 0b8c 00C0A0E3 		mov	ip, #0
 1448 0b90 0320A0E1 		mov	r2, r3
 1449 0b94 0400A0E1 		mov	r0, r4
 1450 0b98 1710A0E3 		mov	r1, #23
 1451 0b9c 0530A0E1 		mov	r3, r5
 1452 0ba0 00C08DE5 		str	ip, [sp, #0]
 1453 0ba4 04C08DE5 		str	ip, [sp, #4]
 1454 0ba8 FEFFFFEB 		bl	cmdSet
 549:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1455              		.loc 1 549 0
 1456 0bac 1C0094E5 		ldr	r0, [r4, #28]
 1457 0bb0 FEFFFFEB 		bl	_txe_mutex_put
 1458 0bb4 8EFFFFEA 		b	.L91
 1459              	.L107:
 1460              		.align	2
 1461              	.L106:
 1462 0bb8 00000000 		.word	.LANCHOR0
 1463 0bbc 04020000 		.word	.LC14
 1464 0bc0 00000000 		.word	.LANCHOR1
 1465 0bc4 50020000 		.word	.LC15
 1466 0bc8 00000000 		.word	cmdQu
 1467              		.cfi_endproc
 1468              	.LFE0:
 1470              		.align	2
 1471              		.global	setIrisauto
 1473              	setIrisauto:
 1474              	.LFB1:
 564:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1475              		.loc 1 564 0
 1476              		.cfi_startproc
 1477              		@ args = 0, pretend = 0, frame = 0
 1478              		@ frame_needed = 0, uses_anonymous_args = 0
 1479              	.LVL107:
 1480 0bcc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1481              	.LCFI11:
 1482              		.cfi_def_cfa_offset 16
 1483 0bd0 0160A0E1 		mov	r6, r1
 1484              		.cfi_offset 14, -4
 1485              		.cfi_offset 6, -8
 1486              		.cfi_offset 5, -12
 1487              		.cfi_offset 4, -16
 1488 0bd4 08D04DE2 		sub	sp, sp, #8
 1489              	.LCFI12:
 1490              		.cfi_def_cfa_offset 24
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1491              		.loc 1 567 0
 1492 0bd8 0050A0E3 		mov	r5, #0
 564:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1493              		.loc 1 564 0
 1494 0bdc 0040A0E1 		mov	r4, r0
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1495              		.loc 1 566 0
 1496 0be0 0010E0E3 		mvn	r1, #0
 1497              	.LVL108:
 1498 0be4 1C0090E5 		ldr	r0, [r0, #28]
 1499              	.LVL109:
 1500 0be8 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1501              		.loc 1 567 0
 1502 0bec 060065E0 		rsb	r0, r5, r6
 1503 0bf0 00C070E2 		rsbs	ip, r0, #0
 1504 0bf4 00C0ACE0 		adc	ip, ip, r0
 1505 0bf8 1410A0E3 		mov	r1, #20
 1506 0bfc 2720A0E3 		mov	r2, #39
 1507 0c00 3030A0E3 		mov	r3, #48
 1508 0c04 0400A0E1 		mov	r0, r4
 1509 0c08 00C08DE5 		str	ip, [sp, #0]
 1510 0c0c 04508DE5 		str	r5, [sp, #4]
 1511 0c10 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1512              		.loc 1 568 0
 1513 0c14 050056E1 		cmp	r6, r5
 1514 0c18 0260A003 		moveq	r6, #2
 1515 0c1c 0560A011 		movne	r6, r5
 1516 0c20 0400A0E1 		mov	r0, r4
 1517 0c24 1510A0E3 		mov	r1, #21
 1518 0c28 2520A0E3 		mov	r2, #37
 1519 0c2c 3030A0E3 		mov	r3, #48
 1520 0c30 00608DE5 		str	r6, [sp, #0]
 1521 0c34 04508DE5 		str	r5, [sp, #4]
 1522 0c38 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1523              		.loc 1 569 0
 1524 0c3c 1C0094E5 		ldr	r0, [r4, #28]
 570:../uvc.c      **** }
 1525              		.loc 1 570 0
 1526 0c40 08D08DE2 		add	sp, sp, #8
 1527 0c44 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1528              		.loc 1 569 0
 1529 0c48 FEFFFFEA 		b	_txe_mutex_put
 1530              		.cfi_endproc
 1531              	.LFE1:
 1533              		.align	2
 1534              		.global	getShutCtrl
 1536              	getShutCtrl:
 1537              	.LFB2:
 574:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1538              		.loc 1 574 0
 1539              		.cfi_startproc
 1540              		@ args = 0, pretend = 0, frame = 0
 1541              		@ frame_needed = 0, uses_anonymous_args = 0
 1542              	.LVL110:
 579:../uvc.c      **** 	switch (Data){
 1543              		.loc 1 579 0
 1544 0c4c 013040E2 		sub	r3, r0, #1
 574:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1545              		.loc 1 574 0
 1546 0c50 10402DE9 		stmfd	sp!, {r4, lr}
 1547              	.LCFI13:
 1548              		.cfi_def_cfa_offset 8
 1549 0c54 08D04DE2 		sub	sp, sp, #8
 1550              	.LCFI14:
 1551              		.cfi_def_cfa_offset 16
 579:../uvc.c      **** 	switch (Data){
 1552              		.loc 1 579 0
 1553 0c58 090053E3 		cmp	r3, #9
 1554 0c5c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1555 0c60 380000EA 		b	.L112
 1556              		.cfi_offset 14, -4
 1557              		.cfi_offset 4, -8
 1558              	.L115:
 1559 0c64 FC0C0000 		.word	.L113
 1560 0c68 FC0C0000 		.word	.L113
 1561 0c6c FC0C0000 		.word	.L113
 1562 0c70 FC0C0000 		.word	.L113
 1563 0c74 FC0C0000 		.word	.L113
 1564 0c78 8C0C0000 		.word	.L114
 1565 0c7c 8C0C0000 		.word	.L114
 1566 0c80 8C0C0000 		.word	.L114
 1567 0c84 8C0C0000 		.word	.L114
 1568 0c88 8C0C0000 		.word	.L114
 1569              	.L114:
 1570              	.LVL111:
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1571              		.loc 1 603 0
 1572 0c8c ECC09FE5 		ldr	ip, .L124
 601:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1573              		.loc 1 601 0
 1574 0c90 8330A0E1 		mov	r3, r3, asl #1
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1575              		.loc 1 603 0
 1576 0c94 B3309CE1 		ldrh	r3, [ip, r3]
 1577 0c98 E4E09FE5 		ldr	lr, .L124+4
 1578 0c9c 032263E0 		rsb	r2, r3, r3, asl #4
 1579 0ca0 8240A0E1 		mov	r4, r2, asl #1
 1580 0ca4 94CECEE0 		smull	ip, lr, r4, lr
 1581 0ca8 C4CFA0E1 		mov	ip, r4, asr #31
 1582 0cac 4E246CE0 		rsb	r2, ip, lr, asr #8
 604:../uvc.c      **** 		if(NumLn > 1944)
 1583              		.loc 1 604 0
 1584 0cb0 D0E09FE5 		ldr	lr, .L124+8
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1585              		.loc 1 603 0
 1586 0cb4 0228A0E1 		mov	r2, r2, asl #16
 1587 0cb8 22C8A0E1 		mov	ip, r2, lsr #16
 1588              	.LVL112:
 604:../uvc.c      **** 		if(NumLn > 1944)
 1589              		.loc 1 604 0
 1590 0cbc 0E005CE1 		cmp	ip, lr
 1591 0cc0 2600008A 		bhi	.L121
 606:../uvc.c      **** 		else if(NumLn < 8)
 1592              		.loc 1 606 0
 1593 0cc4 07005CE3 		cmp	ip, #7
 1594 0cc8 2700008A 		bhi	.L123
 1595              	.LVL113:
 1596              	.L122:
 1597 0ccc 01C0A0E3 		mov	ip, #1
 1598 0cd0 08E0A0E3 		mov	lr, #8
 1599 0cd4 0C40A0E1 		mov	r4, ip
 1600              	.L118:
 1601              	.LVL114:
 609:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1602              		.loc 1 609 0
 1603 0cd8 0120A0E3 		mov	r2, #1
 1604 0cdc 0020C1E5 		strb	r2, [r1, #0]
 610:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1605              		.loc 1 610 0
 1606 0ce0 0020A0E1 		mov	r2, r0
 1607 0ce4 A0109FE5 		ldr	r1, .L124+12
 1608              	.LVL115:
 1609 0ce8 0400A0E3 		mov	r0, #4
 1610              	.LVL116:
 1611 0cec 00E08DE5 		str	lr, [sp, #0]
 1612 0cf0 04C08DE5 		str	ip, [sp, #4]
 1613 0cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 611:../uvc.c      **** 		break;
 1614              		.loc 1 611 0
 1615 0cf8 150000EA 		b	.L117
 1616              	.LVL117:
 1617              	.L113:
 585:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1618              		.loc 1 585 0
 1619 0cfc 7CE09FE5 		ldr	lr, .L124
 1620 0d00 8330A0E1 		mov	r3, r3, asl #1
 1621 0d04 B3309EE1 		ldrh	r3, [lr, r3]
 1622              	.LVL118:
 587:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1623              		.loc 1 587 0
 1624 0d08 80C09FE5 		ldr	ip, .L124+16
 588:../uvc.c      **** 		if(NumLn > 1944)
 1625              		.loc 1 588 0
 1626 0d0c 74E09FE5 		ldr	lr, .L124+8
 587:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1627              		.loc 1 587 0
 1628 0d10 932C8CE0 		umull	r2, ip, r3, ip
 1629 0d14 AC24A0E1 		mov	r2, ip, lsr #9
 1630 0d18 024262E0 		rsb	r4, r2, r2, asl #4
 1631 0d1c 8448A0E1 		mov	r4, r4, asl #17
 1632 0d20 2428A0E1 		mov	r2, r4, lsr #16
 1633              	.LVL119:
 588:../uvc.c      **** 		if(NumLn > 1944)
 1634              		.loc 1 588 0
 1635 0d24 0E0052E1 		cmp	r2, lr
 1636 0d28 0C00008A 		bhi	.L121
 590:../uvc.c      **** 		else if(NumLn < 8)
 1637              		.loc 1 590 0
 1638 0d2c 070052E3 		cmp	r2, #7
 1639 0d30 E5FFFF9A 		bls	.L122
 1640 0d34 A449A0E1 		mov	r4, r4, lsr #19
 1641 0d38 FF4004E2 		and	r4, r4, #255
 1642 0d3c 02E0A0E1 		mov	lr, r2
 1643 0d40 04C0A0E1 		mov	ip, r4
 1644 0d44 E3FFFFEA 		b	.L118
 1645              	.LVL120:
 1646              	.L112:
 614:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1647              		.loc 1 614 0
 1648 0d48 0000A0E3 		mov	r0, #0
 1649              	.LVL121:
 615:../uvc.c      **** 		LnVal = 1;
 1650              		.loc 1 615 0
 1651 0d4c 0140A0E3 		mov	r4, #1
 614:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1652              		.loc 1 614 0
 1653 0d50 0000C1E5 		strb	r0, [r1, #0]
 1654              	.LVL122:
 1655              	.L117:
 619:../uvc.c      **** }
 1656              		.loc 1 619 0
 1657 0d54 0400A0E1 		mov	r0, r4
 1658 0d58 08D08DE2 		add	sp, sp, #8
 1659 0d5c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1660              	.LVL123:
 1661              	.L121:
 604:../uvc.c      **** 		if(NumLn > 1944)
 1662              		.loc 1 604 0
 1663 0d60 F3C0A0E3 		mov	ip, #243
 1664 0d64 0C40A0E1 		mov	r4, ip
 1665 0d68 DAFFFFEA 		b	.L118
 1666              	.LVL124:
 1667              	.L123:
 606:../uvc.c      **** 		else if(NumLn < 8)
 1668              		.loc 1 606 0
 1669 0d6c A2E9A0E1 		mov	lr, r2, lsr #19
 1670 0d70 FF400EE2 		and	r4, lr, #255
 1671 0d74 0CE0A0E1 		mov	lr, ip
 1672 0d78 04C0A0E1 		mov	ip, r4
 1673              	.LVL125:
 1674 0d7c D5FFFFEA 		b	.L118
 1675              	.L125:
 1676              		.align	2
 1677              	.L124:
 1678 0d80 00000000 		.word	.LANCHOR2
 1679 0d84 817F807F 		.word	2139127681
 1680 0d88 98070000 		.word	1944
 1681 0d8c 78020000 		.word	.LC16
 1682 0d90 01FF00FF 		.word	-16711935
 1683              		.cfi_endproc
 1684              	.LFE2:
 1686              		.align	2
 1687              		.global	ControlHandle
 1689              	ControlHandle:
 1690              	.LFB3:
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1691              		.loc 1 621 0
 1692              		.cfi_startproc
 1693              		@ args = 0, pretend = 0, frame = 24
 1694              		@ frame_needed = 0, uses_anonymous_args = 0
 1695              	.LVL126:
 1696 0d94 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1697              	.LCFI15:
 1698              		.cfi_def_cfa_offset 36
 628:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1699              		.loc 1 628 0
 1700 0d98 1F0050E3 		cmp	r0, #31
 627:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1701              		.loc 1 627 0
 1702 0d9c 207040E2 		sub	r7, r0, #32
 1703              		.cfi_offset 14, -4
 1704              		.cfi_offset 11, -8
 1705              		.cfi_offset 10, -12
 1706              		.cfi_offset 9, -16
 1707              		.cfi_offset 8, -20
 1708              		.cfi_offset 7, -24
 1709              		.cfi_offset 6, -28
 1710              		.cfi_offset 5, -32
 1711              		.cfi_offset 4, -36
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1712              		.loc 1 621 0
 1713 0da0 2CD04DE2 		sub	sp, sp, #44
 1714              	.LCFI16:
 1715              		.cfi_def_cfa_offset 80
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1716              		.loc 1 621 0
 1717 0da4 0040A0E1 		mov	r4, r0
 627:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1718              		.loc 1 627 0
 1719 0da8 FF7007E2 		and	r7, r7, #255
 1720              	.LVL127:
 628:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1721              		.loc 1 628 0
 1722 0dac 2400009A 		bls	.L127
 629:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1723              		.loc 1 629 0
 1724 0db0 206F9FE5 		ldr	r6, .L267
 1725 0db4 872087E0 		add	r2, r7, r7, asl #1
 1726 0db8 8221A0E1 		mov	r2, r2, asl #3
 1727 0dbc 023086E0 		add	r3, r6, r2
 630:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1728              		.loc 1 630 0
 1729 0dc0 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 631:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1730              		.loc 1 631 0
 1731 0dc4 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 632:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1732              		.loc 1 632 0
 1733 0dc8 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 643:../uvc.c      ****     reqData = bRequest;
 1734              		.loc 1 643 0
 1735 0dcc 083F9FE5 		ldr	r3, .L267+4
 629:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1736              		.loc 1 629 0
 1737 0dd0 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1738              	.LVL128:
 643:../uvc.c      ****     reqData = bRequest;
 1739              		.loc 1 643 0
 1740 0dd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1741              	.LVL129:
 651:../uvc.c      ****     switch (bRequest)
 1742              		.loc 1 651 0
 1743 0dd8 830055E3 		cmp	r5, #131
 1744 0ddc 2300000A 		beq	.L133
 1745              	.LVL130:
 1746              	.L259:
 1747 0de0 2C00009A 		bls	.L257
 1748 0de4 850055E3 		cmp	r5, #133
 1749 0de8 8700000A 		beq	.L135
 1750 0dec 7500003A 		bcc	.L134
 1751 0df0 860055E3 		cmp	r5, #134
 1752 0df4 C000000A 		beq	.L136
 1753 0df8 870055E3 		cmp	r5, #135
 1754 0dfc B400000A 		beq	.L258
 1755              	.L129:
1251:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1756              		.loc 1 1251 0
 1757 0e00 0000A0E3 		mov	r0, #0
 1758 0e04 0110A0E3 		mov	r1, #1
 1759 0e08 0020A0E1 		mov	r2, r0
 1760 0e0c FEFFFFEB 		bl	CyU3PUsbStall
1252:../uvc.c      **** 			  break;
 1761              		.loc 1 1252 0
 1762 0e10 FFC0A0E3 		mov	ip, #255
 1763 0e14 0C40A0E1 		mov	r4, ip
 1764 0e18 0C70A0E1 		mov	r7, ip
 1765              	.LVL131:
 1766 0e1c 0C80A0E1 		mov	r8, ip
 1767              	.LVL132:
 1768              	.L139:
1254:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1769              		.loc 1 1254 0
 1770 0e20 B81E9FE5 		ldr	r1, .L267+8
 1771 0e24 0520A0E1 		mov	r2, r5
 1772 0e28 0830A0E1 		mov	r3, r8
 1773 0e2c 0400A0E3 		mov	r0, #4
 1774 0e30 00708DE5 		str	r7, [sp, #0]
 1775 0e34 10108DE9 		stmib	sp, {r4, ip}	@ phole stm
 1776 0e38 FEFFFFEB 		bl	CyU3PDebugPrint
1255:../uvc.c      **** }
 1777              		.loc 1 1255 0
 1778 0e3c 2CD08DE2 		add	sp, sp, #44
 1779 0e40 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1780              	.LVL133:
 1781              	.L127:
 634:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1782              		.loc 1 634 0
 1783 0e44 8C6E9FE5 		ldr	r6, .L267
 643:../uvc.c      ****     reqData = bRequest;
 1784              		.loc 1 643 0
 1785 0e48 8C3E9FE5 		ldr	r3, .L267+4
 634:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1786              		.loc 1 634 0
 1787 0e4c 805080E0 		add	r5, r0, r0, asl #1
 1788 0e50 850186E0 		add	r0, r6, r5, asl #3
 1789              	.LVL134:
 643:../uvc.c      ****     reqData = bRequest;
 1790              		.loc 1 643 0
 1791 0e54 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 634:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1792              		.loc 1 634 0
 1793 0e58 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1794              	.LVL135:
 651:../uvc.c      ****     switch (bRequest)
 1795              		.loc 1 651 0
 1796 0e5c 830055E3 		cmp	r5, #131
 635:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1797              		.loc 1 635 0
 1798 0e60 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1799              	.LVL136:
 636:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1800              		.loc 1 636 0
 1801 0e64 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1802              	.LVL137:
 637:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1803              		.loc 1 637 0
 1804 0e68 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1805              	.LVL138:
 651:../uvc.c      ****     switch (bRequest)
 1806              		.loc 1 651 0
 1807 0e6c DBFFFF1A 		bne	.L259
 1808              	.LVL139:
 1809              	.L133:
 800:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1810              		.loc 1 800 0
 1811 0e70 1F0054E3 		cmp	r4, #31
 1812 0e74 BE00009A 		bls	.L165
 801:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1813              		.loc 1 801 0
 1814 0e78 872087E0 		add	r2, r7, r7, asl #1
 1815 0e7c 826186E0 		add	r6, r6, r2, asl #3
 1816 0e80 A0AE9FE5 		ldr	sl, .L267+80
 1817 0e84 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 802:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1818              		.loc 1 802 0
 1819 0e88 06E0D6E5 		ldrb	lr, [r6, #6]	@ zero_extendqisi2
 801:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1820              		.loc 1 801 0
 1821 0e8c 5C00CAE5 		strb	r0, [sl, #92]
 802:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1822              		.loc 1 802 0
 1823 0e90 5DE0CAE5 		strb	lr, [sl, #93]
 1824 0e94 0B0000EA 		b	.L173
 1825              	.L257:
 651:../uvc.c      ****     switch (bRequest)
 1826              		.loc 1 651 0
 1827 0e98 810055E3 		cmp	r5, #129
 1828 0e9c 6600000A 		beq	.L131
 1829 0ea0 1000009A 		bls	.L260
 781:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1830              		.loc 1 781 0
 1831 0ea4 1F0054E3 		cmp	r4, #31
 1832 0ea8 A500009A 		bls	.L162
 782:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1833              		.loc 1 782 0
 1834 0eac 87A087E0 		add	sl, r7, r7, asl #1
 1835 0eb0 8A6186E0 		add	r6, r6, sl, asl #3
 1836 0eb4 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 1837              	.LVL140:
 1838 0eb8 68AE9FE5 		ldr	sl, .L267+80
 783:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1839              		.loc 1 783 0
 1840 0ebc 04C0D6E5 		ldrb	ip, [r6, #4]	@ zero_extendqisi2
 782:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1841              		.loc 1 782 0
 1842 0ec0 5C70CAE5 		strb	r7, [sl, #92]
 783:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1843              		.loc 1 783 0
 1844 0ec4 5DC0CAE5 		strb	ip, [sl, #93]
 1845              	.L173:
 858:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1846              		.loc 1 858 0
 1847 0ec8 0800A0E1 		mov	r0, r8
 1848 0ecc 101E9FE5 		ldr	r1, .L267+12
 1849 0ed0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1850              	.LVL141:
 860:../uvc.c      **** 			  break;
 1851              		.loc 1 860 0
 1852 0ed4 FFC0A0E3 		mov	ip, #255
 858:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1853              		.loc 1 858 0
 1854 0ed8 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 860:../uvc.c      **** 			  break;
 1855              		.loc 1 860 0
 1856 0edc 0C70A0E1 		mov	r7, ip
 1857 0ee0 0C80A0E1 		mov	r8, ip
 1858 0ee4 CDFFFFEA 		b	.L139
 1859              	.LVL142:
 1860              	.L260:
 651:../uvc.c      ****     switch (bRequest)
 1861              		.loc 1 651 0
 1862 0ee8 010055E3 		cmp	r5, #1
 1863 0eec C3FFFF1A 		bne	.L129
 862:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1864              		.loc 1 862 0
 1865 0ef0 301E9FE5 		ldr	r1, .L267+80
 1866 0ef4 26208DE2 		add	r2, sp, #38
 1867 0ef8 2000A0E3 		mov	r0, #32
 1868 0efc 5C1081E2 		add	r1, r1, #92
 1869 0f00 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1870              	.LVL143:
 864:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1871              		.loc 1 864 0
 1872 0f04 002050E2 		subs	r2, r0, #0
 1873 0f08 4703001A 		bne	.L175
 866:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1874              		.loc 1 866 0
 1875 0f0c 143E9FE5 		ldr	r3, .L267+80
 867:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1876              		.loc 1 867 0
 1877 0f10 10CE9FE5 		ldr	ip, .L267+80
 869:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1878              		.loc 1 869 0
 1879 0f14 0C0E9FE5 		ldr	r0, .L267+80
 1880              	.LVL144:
 866:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1881              		.loc 1 866 0
 1882 0f18 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
 867:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1883              		.loc 1 867 0
 1884 0f1c 5DC0DCE5 		ldrb	ip, [ip, #93]	@ zero_extendqisi2
 869:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1885              		.loc 1 869 0
 1886 0f20 5EE0D0E5 		ldrb	lr, [r0, #94]	@ zero_extendqisi2
 866:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1887              		.loc 1 866 0
 1888 0f24 14308DE5 		str	r3, [sp, #20]
 1889              	.LVL145:
 867:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1890              		.loc 1 867 0
 1891 0f28 1CC08DE5 		str	ip, [sp, #28]
 1892              	.LVL146:
 869:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1893              		.loc 1 869 0
 1894 0f2c 18E08DE5 		str	lr, [sp, #24]
 1895              	.LVL147:
 873:../uvc.c      **** 				  switch(CtrlID)
 1896              		.loc 1 873 0
 1897 0f30 220054E3 		cmp	r4, #34
 1898 0f34 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1899 0f38 6E0200EA 		b	.L176
 1900              	.L192:
 1901 0f3c 60190000 		.word	.L177
 1902 0f40 90180000 		.word	.L178
 1903 0f44 F8180000 		.word	.L176
 1904 0f48 F8180000 		.word	.L176
 1905 0f4c 3C180000 		.word	.L179
 1906 0f50 FC160000 		.word	.L180
 1907 0f54 80160000 		.word	.L181
 1908 0f58 F8180000 		.word	.L176
 1909 0f5c F8180000 		.word	.L176
 1910 0f60 F8180000 		.word	.L176
 1911 0f64 F8180000 		.word	.L176
 1912 0f68 FC150000 		.word	.L182
 1913 0f6c F8180000 		.word	.L176
 1914 0f70 F8180000 		.word	.L176
 1915 0f74 F8180000 		.word	.L176
 1916 0f78 F8180000 		.word	.L176
 1917 0f7c A01B0000 		.word	.L183
 1918 0f80 F8180000 		.word	.L176
 1919 0f84 F8180000 		.word	.L176
 1920 0f88 F8180000 		.word	.L176
 1921 0f8c F8180000 		.word	.L176
 1922 0f90 F8180000 		.word	.L176
 1923 0f94 F8180000 		.word	.L176
 1924 0f98 F8180000 		.word	.L176
 1925 0f9c F8180000 		.word	.L176
 1926 0fa0 3C1A0000 		.word	.L184
 1927 0fa4 F8180000 		.word	.L176
 1928 0fa8 0C1B0000 		.word	.L185
 1929 0fac CC190000 		.word	.L186
 1930 0fb0 F8180000 		.word	.L176
 1931 0fb4 A0150000 		.word	.L187
 1932 0fb8 1C150000 		.word	.L188
 1933 0fbc 80140000 		.word	.L189
 1934 0fc0 68140000 		.word	.L190
 1935 0fc4 04140000 		.word	.L191
 1936              	.LVL148:
 1937              	.L134:
 818:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1938              		.loc 1 818 0
 1939 0fc8 1F0054E3 		cmp	r4, #31
 819:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1940              		.loc 1 819 0
 1941 0fcc 87708780 		addhi	r7, r7, r7, asl #1
 1942              	.LVL149:
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1943              		.loc 1 825 0
 1944 0fd0 84408490 		addls	r4, r4, r4, asl #1
 819:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1945              		.loc 1 819 0
 1946 0fd4 87618680 		addhi	r6, r6, r7, asl #3
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1947              		.loc 1 825 0
 1948 0fd8 84618690 		addls	r6, r6, r4, asl #3
 819:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1949              		.loc 1 819 0
 1950 0fdc 44AD9F85 		ldrhi	sl, .L267+80
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1951              		.loc 1 825 0
 1952 0fe0 40AD9F95 		ldrls	sl, .L267+80
 819:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1953              		.loc 1 819 0
 1954 0fe4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 820:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1955              		.loc 1 820 0
 1956 0fe8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1957              		.loc 1 825 0
 1958 0fec 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 826:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1959              		.loc 1 826 0
 1960 0ff0 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 827:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1961              		.loc 1 827 0
 1962 0ff4 0030A0E3 		mov	r3, #0
 825:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1963              		.loc 1 825 0
 1964 0ff8 5C10CAE5 		strb	r1, [sl, #92]
 826:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1965              		.loc 1 826 0
 1966 0ffc 5D20CAE5 		strb	r2, [sl, #93]
 827:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1967              		.loc 1 827 0
 1968 1000 5E30CAE5 		strb	r3, [sl, #94]
 828:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1969              		.loc 1 828 0
 1970 1004 5F30CAE5 		strb	r3, [sl, #95]
 1971 1008 AEFFFFEA 		b	.L173
 1972              	.LVL150:
 1973              	.L135:
 655:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1974              		.loc 1 655 0
 1975 100c 144D9FE5 		ldr	r4, .L267+80
 657:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1976              		.loc 1 657 0
 1977 1010 0200A0E3 		mov	r0, #2
 655:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1978              		.loc 1 655 0
 1979 1014 5C80C4E5 		strb	r8, [r4, #92]
 656:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1980              		.loc 1 656 0
 1981 1018 0080A0E3 		mov	r8, #0
 1982 101c 5D80C4E5 		strb	r8, [r4, #93]
 657:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1983              		.loc 1 657 0
 1984 1020 5C1084E2 		add	r1, r4, #92
 1985 1024 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1986              	.LVL151:
 659:../uvc.c      **** 			  break;
 1987              		.loc 1 659 0
 1988 1028 FFC0A0E3 		mov	ip, #255
 657:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1989              		.loc 1 657 0
 1990 102c 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 659:../uvc.c      **** 			  break;
 1991              		.loc 1 659 0
 1992 1030 0C70A0E1 		mov	r7, ip
 1993              	.LVL152:
 1994 1034 0C80A0E1 		mov	r8, ip
 1995 1038 78FFFFEA 		b	.L139
 1996              	.LVL153:
 1997              	.L131:
 662:../uvc.c      **** 			 switch(CtrlID)
 1998              		.loc 1 662 0
 1999 103c 011044E2 		sub	r1, r4, #1
 2000 1040 210051E3 		cmp	r1, #33
 2001 1044 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 2002 1048 C20000EA 		b	.L140
 2003              	.L150:
 2004 104c 2C130000 		.word	.L141
 2005 1050 58130000 		.word	.L140
 2006 1054 58130000 		.word	.L140
 2007 1058 58130000 		.word	.L140
 2008 105c 0C130000 		.word	.L142
 2009 1060 58130000 		.word	.L140
 2010 1064 58130000 		.word	.L140
 2011 1068 58130000 		.word	.L140
 2012 106c 58130000 		.word	.L140
 2013 1070 58130000 		.word	.L140
 2014 1074 9C130000 		.word	.L143
 2015 1078 58130000 		.word	.L140
 2016 107c 58130000 		.word	.L140
 2017 1080 58130000 		.word	.L140
 2018 1084 58130000 		.word	.L140
 2019 1088 7C130000 		.word	.L144
 2020 108c 58130000 		.word	.L140
 2021 1090 58130000 		.word	.L140
 2022 1094 58130000 		.word	.L140
 2023 1098 58130000 		.word	.L140
 2024 109c 58130000 		.word	.L140
 2025 10a0 58130000 		.word	.L140
 2026 10a4 58130000 		.word	.L140
 2027 10a8 58130000 		.word	.L140
 2028 10ac C0130000 		.word	.L145
 2029 10b0 58130000 		.word	.L140
 2030 10b4 EC120000 		.word	.L146
 2031 10b8 C4120000 		.word	.L147
 2032 10bc 58130000 		.word	.L140
 2033 10c0 58130000 		.word	.L140
 2034 10c4 28120000 		.word	.L148
 2035 10c8 F0110000 		.word	.L149
 2036 10cc F0110000 		.word	.L149
 2037 10d0 F0110000 		.word	.L149
 2038              	.L258:
 845:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2039              		.loc 1 845 0
 2040 10d4 1F0054E3 		cmp	r4, #31
 2041 10d8 3100009A 		bls	.L172
 846:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2042              		.loc 1 846 0
 2043 10dc 87C087E0 		add	ip, r7, r7, asl #1
 2044 10e0 8C6186E0 		add	r6, r6, ip, asl #3
 2045 10e4 3CAC9FE5 		ldr	sl, .L267+80
 2046 10e8 0B40D6E5 		ldrb	r4, [r6, #11]	@ zero_extendqisi2
 847:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2047              		.loc 1 847 0
 2048 10ec 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 846:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2049              		.loc 1 846 0
 2050 10f0 5C40CAE5 		strb	r4, [sl, #92]
 847:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2051              		.loc 1 847 0
 2052 10f4 5D10CAE5 		strb	r1, [sl, #93]
 2053 10f8 72FFFFEA 		b	.L173
 2054              	.L136:
 834:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2055              		.loc 1 834 0
 2056 10fc 1F0054E3 		cmp	r4, #31
 835:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2057              		.loc 1 835 0
 2058 1100 87708780 		addhi	r7, r7, r7, asl #1
 2059              	.LVL154:
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2060              		.loc 1 838 0
 2061 1104 84408490 		addls	r4, r4, r4, asl #1
 835:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2062              		.loc 1 835 0
 2063 1108 87618680 		addhi	r6, r6, r7, asl #3
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2064              		.loc 1 838 0
 2065 110c 84618690 		addls	r6, r6, r4, asl #3
 835:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2066              		.loc 1 835 0
 2067 1110 108C9F85 		ldrhi	r8, .L267+80
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2068              		.loc 1 838 0
 2069 1114 0C8C9F95 		ldrls	r8, .L267+80
 835:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2070              		.loc 1 835 0
 2071 1118 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2072              		.loc 1 838 0
 2073 111c 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 840:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2074              		.loc 1 840 0
 2075 1120 0100A0E3 		mov	r0, #1
 838:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2076              		.loc 1 838 0
 2077 1124 5C30C8E5 		strb	r3, [r8, #92]
 840:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2078              		.loc 1 840 0
 2079 1128 B41B9FE5 		ldr	r1, .L267+12
 2080 112c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2081              	.LVL155:
 843:../uvc.c      **** 			  break;
 2082              		.loc 1 843 0
 2083 1130 FFC0A0E3 		mov	ip, #255
 840:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2084              		.loc 1 840 0
 2085 1134 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 843:../uvc.c      **** 			  break;
 2086              		.loc 1 843 0
 2087 1138 0C70A0E1 		mov	r7, ip
 2088 113c 0C80A0E1 		mov	r8, ip
 2089 1140 36FFFFEA 		b	.L139
 2090              	.LVL156:
 2091              	.L162:
 786:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2092              		.loc 1 786 0
 2093 1144 0B0054E3 		cmp	r4, #11
 793:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2094              		.loc 1 793 0
 2095 1148 84408410 		addne	r4, r4, r4, asl #1
 2096 114c 84618610 		addne	r6, r6, r4, asl #3
 2097 1150 D0AB9F15 		ldrne	sl, .L267+80
 787:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2098              		.loc 1 787 0
 2099 1154 CCAB9F05 		ldreq	sl, .L267+80
 2100 1158 883B9F05 		ldreq	r3, .L267+16
 793:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2101              		.loc 1 793 0
 2102 115c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 794:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2103              		.loc 1 794 0
 2104 1160 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 787:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2105              		.loc 1 787 0
 2106 1164 5C308A05 		streq	r3, [sl, #92]
 793:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2107              		.loc 1 793 0
 2108 1168 5C20CA15 		strneb	r2, [sl, #92]
 794:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2109              		.loc 1 794 0
 2110 116c 5D30CA15 		strneb	r3, [sl, #93]
 2111 1170 54FFFFEA 		b	.L173
 2112              	.L165:
 804:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2113              		.loc 1 804 0
 2114 1174 0B0054E3 		cmp	r4, #11
 811:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2115              		.loc 1 811 0
 2116 1178 84408410 		addne	r4, r4, r4, asl #1
 2117 117c 84618610 		addne	r6, r6, r4, asl #3
 2118 1180 A0AB9F15 		ldrne	sl, .L267+80
 805:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2119              		.loc 1 805 0
 2120 1184 9CAB9F05 		ldreq	sl, .L267+80
 2121 1188 5C3B9F05 		ldreq	r3, .L267+20
 811:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2122              		.loc 1 811 0
 2123 118c 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 812:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2124              		.loc 1 812 0
 2125 1190 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 805:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2126              		.loc 1 805 0
 2127 1194 5C308A05 		streq	r3, [sl, #92]
 811:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2128              		.loc 1 811 0
 2129 1198 5C20CA15 		strneb	r2, [sl, #92]
 812:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2130              		.loc 1 812 0
 2131 119c 5D30CA15 		strneb	r3, [sl, #93]
 2132 11a0 48FFFFEA 		b	.L173
 2133              	.L172:
 849:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2134              		.loc 1 849 0
 2135 11a4 0B0054E3 		cmp	r4, #11
 2136 11a8 0700000A 		beq	.L261
 855:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2137              		.loc 1 855 0
 2138 11ac 84A084E0 		add	sl, r4, r4, asl #1
 2139 11b0 8A6186E0 		add	r6, r6, sl, asl #3
 2140 11b4 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2141 11b8 68AB9FE5 		ldr	sl, .L267+80
 856:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2142              		.loc 1 856 0
 2143 11bc 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
 855:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2144              		.loc 1 855 0
 2145 11c0 5C20CAE5 		strb	r2, [sl, #92]
 856:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2146              		.loc 1 856 0
 2147 11c4 5D30CAE5 		strb	r3, [sl, #93]
 2148 11c8 3EFFFFEA 		b	.L173
 2149              	.L261:
 850:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2150              		.loc 1 850 0
 2151 11cc 54AB9FE5 		ldr	sl, .L267+80
 2152 11d0 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 852:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2153              		.loc 1 852 0
 2154 11d4 94E2D6E5 		ldrb	lr, [r6, #660]	@ zero_extendqisi2
 851:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2155              		.loc 1 851 0
 2156 11d8 0070A0E3 		mov	r7, #0
 2157              	.LVL157:
 850:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2158              		.loc 1 850 0
 2159 11dc 5C00CAE5 		strb	r0, [sl, #92]
 851:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2160              		.loc 1 851 0
 2161 11e0 5D70CAE5 		strb	r7, [sl, #93]
 852:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2162              		.loc 1 852 0
 2163 11e4 5EE0CAE5 		strb	lr, [sl, #94]
 853:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2164              		.loc 1 853 0
 2165 11e8 5F70CAE5 		strb	r7, [sl, #95]
 2166 11ec 35FFFFEA 		b	.L173
 2167              	.LVL158:
 2168              	.L149:
 668:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2169              		.loc 1 668 0
 2170 11f0 87E087E0 		add	lr, r7, r7, asl #1
 2171 11f4 8E6186E0 		add	r6, r6, lr, asl #3
 2172 11f8 28CB9FE5 		ldr	ip, .L267+80
 2173 11fc 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 669:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2174              		.loc 1 669 0
 2175 1200 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 668:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 2176              		.loc 1 668 0
 2177 1204 5C40CCE5 		strb	r4, [ip, #92]
 669:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 2178              		.loc 1 669 0
 2179 1208 5D60CCE5 		strb	r6, [ip, #93]
 2180              	.LVL159:
 2181              	.L153:
 774:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2182              		.loc 1 774 0
 2183 120c 0800A0E1 		mov	r0, r8
 2184 1210 CC1A9FE5 		ldr	r1, .L267+12
 2185 1214 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 779:../uvc.c      **** 			  break;
 2186              		.loc 1 779 0
 2187 1218 FF70A0E3 		mov	r7, #255
 774:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2188              		.loc 1 774 0
 2189 121c 06C0A0E1 		mov	ip, r6
 779:../uvc.c      **** 			  break;
 2190              		.loc 1 779 0
 2191 1220 0780A0E1 		mov	r8, r7
 2192 1224 FDFEFFEA 		b	.L139
 2193              	.LVL160:
 2194              	.L148:
 701:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2195              		.loc 1 701 0 discriminator 1
 2196 1228 000058E3 		cmp	r8, #0
 2197 122c 3C03000A 		beq	.L253
 699:../uvc.c      **** 					 break;
 2198              		.loc 1 699 0
 2199 1230 28E1A0E1 		mov	lr, r8, lsr #2
 2200 1234 00005EE3 		cmp	lr, #0
 2201 1238 03005813 		cmpne	r8, #3
 2202 123c 0020A083 		movhi	r2, #0
 2203 1240 0120A093 		movls	r2, #1
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2204              		.loc 1 621 0
 2205 1244 0E31A0E1 		mov	r3, lr, asl #2
 699:../uvc.c      **** 					 break;
 2206              		.loc 1 699 0
 2207 1248 6203009A 		bls	.L231
 2208 124c 901A9FE5 		ldr	r1, .L267+12
 2209 1250 100041E2 		sub	r0, r1, #16
 2210              	.LVL161:
 2211              	.L157:
 702:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2212              		.loc 1 702 0 discriminator 2
 2213 1254 047090E4 		ldr	r7, [r0], #4
 2214 1258 012082E2 		add	r2, r2, #1
 2215 125c FF2002E2 		and	r2, r2, #255
 2216 1260 02005EE1 		cmp	lr, r2
 2217 1264 047081E4 		str	r7, [r1], #4
 2218 1268 F9FFFF8A 		bhi	.L157
 702:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2219              		.loc 1 702 0 is_stmt 0
 2220 126c 030058E1 		cmp	r8, r3
 2221 1270 B00A9F15 		ldrne	r0, .L267+80
 2222 1274 2A03000A 		beq	.L253
 2223              	.L244:
 2224 1278 034080E0 		add	r4, r0, r3
 2225 127c 4C10D4E5 		ldrb	r1, [r4, #76]	@ zero_extendqisi2
 701:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2226              		.loc 1 701 0 is_stmt 1
 2227 1280 01C083E2 		add	ip, r3, #1
 2228 1284 FF300CE2 		and	r3, ip, #255
 2229              	.LVL162:
 2230 1288 030058E1 		cmp	r8, r3
 702:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2231              		.loc 1 702 0
 2232 128c 5C10C4E5 		strb	r1, [r4, #92]
 701:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2233              		.loc 1 701 0
 2234 1290 F8FFFF8A 		bhi	.L244
 2235              	.LVL163:
 2236              	.L152:
 711:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2237              		.loc 1 711 0
 2238 1294 5760D0E5 		ldrb	r6, [r0, #87]	@ zero_extendqisi2
 704:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2239              		.loc 1 704 0
 2240 1298 883A9FE5 		ldr	r3, .L267+80
 711:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2241              		.loc 1 711 0
 2242 129c FF0056E3 		cmp	r6, #255
 704:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2243              		.loc 1 704 0
 2244 12a0 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2245              	.LVL164:
 705:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2246              		.loc 1 705 0
 2247 12a4 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2248              	.LVL165:
 711:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2249              		.loc 1 711 0
 2250 12a8 D7FFFF0A 		beq	.L153
 713:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2251              		.loc 1 713 0
 2252 12ac 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2253 12b0 381A9FE5 		ldr	r1, .L267+24
 2254 12b4 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2255 12b8 0400A0E3 		mov	r0, #4
 2256 12bc FEFFFFEB 		bl	CyU3PDebugPrint
 2257 12c0 D1FFFFEA 		b	.L153
 2258              	.LVL166:
 2259              	.L147:
 688:../uvc.c      **** 					 if(CamMode == 1){//720p
 2260              		.loc 1 688 0
 2261 12c4 5C7A9FE5 		ldr	r7, .L267+80
 2262              	.LVL167:
 687:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2263              		.loc 1 687 0
 2264 12c8 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2265              	.LVL168:
 688:../uvc.c      **** 					 if(CamMode == 1){//720p
 2266              		.loc 1 688 0
 2267 12cc 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2268 12d0 010052E3 		cmp	r2, #1
 2269 12d4 E002000A 		beq	.L262
 2270              	.LVL169:
 2271              	.L154:
 698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2272              		.loc 1 698 0
 2273 12d8 0030A0E3 		mov	r3, #0
 697:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2274              		.loc 1 697 0
 2275 12dc 5C40C7E5 		strb	r4, [r7, #92]
 698:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2276              		.loc 1 698 0
 2277 12e0 5D30C7E5 		strb	r3, [r7, #93]
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2278              		.loc 1 639 0
 2279 12e4 FF60A0E3 		mov	r6, #255
 699:../uvc.c      **** 					 break;
 2280              		.loc 1 699 0
 2281 12e8 C7FFFFEA 		b	.L153
 2282              	.LVL170:
 2283              	.L146:
 681:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 2284              		.loc 1 681 0
 2285 12ec B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
 2286 12f0 301A9FE5 		ldr	r1, .L267+80
 683:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 2287              		.loc 1 683 0
 2288 12f4 B204D6E5 		ldrb	r0, [r6, #1202]	@ zero_extendqisi2
 681:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVLo;
 2289              		.loc 1 681 0
 2290 12f8 FF4004E2 		and	r4, r4, #255
 2291 12fc 5C40C1E5 		strb	r4, [r1, #92]
 683:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtCtlShutlevCtlID11 - 0x10]->UVCCurVHi;
 2292              		.loc 1 683 0
 2293 1300 5D00C1E5 		strb	r0, [r1, #93]
 2294              	.LVL171:
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2295              		.loc 1 639 0
 2296 1304 FF60A0E3 		mov	r6, #255
 685:../uvc.c      **** 			 		 break;
 2297              		.loc 1 685 0
 2298 1308 BFFFFFEA 		b	.L153
 2299              	.LVL172:
 2300              	.L142:
 754:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2301              		.loc 1 754 0
 2302 130c 0572D6E5 		ldrb	r7, [r6, #517]	@ zero_extendqisi2
 2303              	.LVL173:
 2304 1310 106A9FE5 		ldr	r6, .L267+80
 2305 1314 804027E2 		eor	r4, r7, #128
 755:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2306              		.loc 1 755 0
 2307 1318 00C0A0E3 		mov	ip, #0
 754:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2308              		.loc 1 754 0
 2309 131c 5C40C6E5 		strb	r4, [r6, #92]
 755:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2310              		.loc 1 755 0
 2311 1320 5DC0C6E5 		strb	ip, [r6, #93]
 2312              	.LVL174:
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2313              		.loc 1 639 0
 2314 1324 FF60A0E3 		mov	r6, #255
 757:../uvc.c      **** 					 break;
 2315              		.loc 1 757 0
 2316 1328 B7FFFFEA 		b	.L153
 2317              	.LVL175:
 2318              	.L141:
 742:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2319              		.loc 1 742 0
 2320 132c A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2321              	.LVL176:
 748:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2322              		.loc 1 748 0
 2323 1330 F0199FE5 		ldr	r1, .L267+80
 743:../uvc.c      **** 					  if(Data0&0x80){
 2324              		.loc 1 743 0
 2325 1334 800014E3 		tst	r4, #128
 744:../uvc.c      **** 						  Data0 = ~Data0;
 2326              		.loc 1 744 0
 2327 1338 0440E011 		mvnne	r4, r4
 2328              	.LVL177:
 746:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2329              		.loc 1 746 0
 2330 133c 80404402 		subeq	r4, r4, #128
 2331 1340 FF4004E2 		and	r4, r4, #255
 2332              	.LVL178:
 749:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2333              		.loc 1 749 0
 2334 1344 0020A0E3 		mov	r2, #0
 748:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2335              		.loc 1 748 0
 2336 1348 5C40C1E5 		strb	r4, [r1, #92]
 749:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2337              		.loc 1 749 0
 2338 134c 5D20C1E5 		strb	r2, [r1, #93]
 2339              	.LVL179:
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2340              		.loc 1 639 0
 2341 1350 FF60A0E3 		mov	r6, #255
 751:../uvc.c      **** 			 		 break;
 2342              		.loc 1 751 0
 2343 1354 ACFFFFEA 		b	.L153
 2344              	.LVL180:
 2345              	.L140:
 768:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2346              		.loc 1 768 0
 2347 1358 844084E0 		add	r4, r4, r4, asl #1
 2348 135c 841186E0 		add	r1, r6, r4, asl #3
 2349 1360 C0399FE5 		ldr	r3, .L267+80
 2350 1364 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 769:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2351              		.loc 1 769 0
 2352 1368 0020A0E3 		mov	r2, #0
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2353              		.loc 1 639 0
 2354 136c FF60A0E3 		mov	r6, #255
 768:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2355              		.loc 1 768 0
 2356 1370 5C40C3E5 		strb	r4, [r3, #92]
 769:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2357              		.loc 1 769 0
 2358 1374 5D20C3E5 		strb	r2, [r3, #93]
 2359              	.LVL181:
 771:../uvc.c      **** 					 break;
 2360              		.loc 1 771 0
 2361 1378 A3FFFFEA 		b	.L153
 2362              	.LVL182:
 2363              	.L144:
 675:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 2364              		.loc 1 675 0
 2365 137c 9D24D6E5 		ldrb	r2, [r6, #1181]	@ zero_extendqisi2
 2366 1380 A0399FE5 		ldr	r3, .L267+80
 677:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 2367              		.loc 1 677 0
 2368 1384 9E74D6E5 		ldrb	r7, [r6, #1182]	@ zero_extendqisi2
 2369              	.LVL183:
 675:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVLo;
 2370              		.loc 1 675 0
 2371 1388 FF4002E2 		and	r4, r2, #255
 2372 138c 5C40C3E5 		strb	r4, [r3, #92]
 677:../uvc.c      **** 					 glEp0Buffer[1] = pSensorCtrl[ExtShutCtlID0 - 0x10]->UVCCurVHi;
 2373              		.loc 1 677 0
 2374 1390 5D70C3E5 		strb	r7, [r3, #93]
 2375              	.LVL184:
 639:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2376              		.loc 1 639 0
 2377 1394 FF60A0E3 		mov	r6, #255
 679:../uvc.c      **** 			 		 break;
 2378              		.loc 1 679 0
 2379 1398 9BFFFFEA 		b	.L153
 2380              	.LVL185:
 2381              	.L143:
 759:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2382              		.loc 1 759 0
 2383 139c 84099FE5 		ldr	r0, .L267+80
 2384 13a0 CC44D6E5 		ldrb	r4, [r6, #1228]	@ zero_extendqisi2
 761:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2385              		.loc 1 761 0
 2386 13a4 CE64D6E5 		ldrb	r6, [r6, #1230]	@ zero_extendqisi2
 760:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2387              		.loc 1 760 0
 2388 13a8 00E0A0E3 		mov	lr, #0
 759:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2389              		.loc 1 759 0
 2390 13ac 5C40C0E5 		strb	r4, [r0, #92]
 760:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2391              		.loc 1 760 0
 2392 13b0 5DE0C0E5 		strb	lr, [r0, #93]
 761:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2393              		.loc 1 761 0
 2394 13b4 5E60C0E5 		strb	r6, [r0, #94]
 762:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2395              		.loc 1 762 0
 2396 13b8 5FE0C0E5 		strb	lr, [r0, #95]
 2397              	.LVL186:
 765:../uvc.c      **** 					 break;
 2398              		.loc 1 765 0
 2399 13bc 92FFFFEA 		b	.L153
 2400              	.LVL187:
 2401              	.L145:
 717:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2402              		.loc 1 717 0
 2403 13c0 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
 718:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2404              		.loc 1 718 0
 2405 13c4 C604D6E5 		ldrb	r0, [r6, #1222]	@ zero_extendqisi2
 717:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2406              		.loc 1 717 0
 2407 13c8 58E99FE5 		ldr	lr, .L267+80
 721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2408              		.loc 1 721 0
 2409 13cc 0070A0E3 		mov	r7, #0
 2410              	.LVL188:
 717:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2411              		.loc 1 717 0
 2412 13d0 FF4003E2 		and	r4, r3, #255
 718:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2413              		.loc 1 718 0
 2414 13d4 FF6000E2 		and	r6, r0, #255
 717:../uvc.c      **** 					 glEp0Buffer[0] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVLo;
 2415              		.loc 1 717 0
 2416 13d8 5C40CEE5 		strb	r4, [lr, #92]
 718:../uvc.c      **** 					 glEp0Buffer[2] = pSensorCtrl[ExtAexModCtlID9 - 0x10]->UVCCurVHi;
 2417              		.loc 1 718 0
 2418 13dc 5E60CEE5 		strb	r6, [lr, #94]
 721:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2419              		.loc 1 721 0
 2420 13e0 5D70CEE5 		strb	r7, [lr, #93]
 723:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2421              		.loc 1 723 0
 2422 13e4 5F70CEE5 		strb	r7, [lr, #95]
 2423              	.LVL189:
 726:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2424              		.loc 1 726 0
 2425 13e8 04199FE5 		ldr	r1, .L267+28
 2426 13ec 0420A0E1 		mov	r2, r4
 2427 13f0 0730A0E1 		mov	r3, r7
 2428 13f4 0400A0E3 		mov	r0, #4
 2429 13f8 C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 2430 13fc FEFFFFEB 		bl	CyU3PDebugPrint
 727:../uvc.c      **** 					 break;
 2431              		.loc 1 727 0
 2432 1400 81FFFFEA 		b	.L153
 2433              	.LVL190:
 2434              	.L191:
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2435              		.loc 1 1076 0
 2436 1404 18499FE5 		ldr	r4, .L267+76
 2437 1408 0010E0E3 		mvn	r1, #0
 2438 140c 1C0094E5 		ldr	r0, [r4, #28]
 2439 1410 FEFFFFEB 		bl	_txe_mutex_get
 2440              	.LVL191:
1077:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2441              		.loc 1 1077 0
 2442 1414 2210A0E3 		mov	r1, #34
 2443              	.L256:
 2444 1418 14C09DE5 		ldr	ip, [sp, #20]
 2445 141c 0A30A0E1 		mov	r3, sl
 2446 1420 00E0A0E3 		mov	lr, #0
 2447 1424 0920A0E1 		mov	r2, r9
 2448 1428 0400A0E1 		mov	r0, r4
 2449 142c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2450 1430 FEFFFFEB 		bl	cmdSet
1078:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2451              		.loc 1 1078 0
 2452 1434 1C0094E5 		ldr	r0, [r4, #28]
 2453 1438 FEFFFFEB 		bl	_txe_mutex_put
1079:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2454              		.loc 1 1079 0
 2455 143c 14009DE5 		ldr	r0, [sp, #20]
 2456 1440 878087E0 		add	r8, r7, r7, asl #1
 2457 1444 886186E0 		add	r6, r6, r8, asl #3
1081:../uvc.c      **** 							 break;
 2458              		.loc 1 1081 0
 2459 1448 FFC0A0E3 		mov	ip, #255
1080:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2460              		.loc 1 1080 0
 2461 144c 0130A0E3 		mov	r3, #1
1079:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2462              		.loc 1 1079 0
 2463 1450 0D00C6E5 		strb	r0, [r6, #13]
1080:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2464              		.loc 1 1080 0
 2465 1454 1030C6E5 		strb	r3, [r6, #16]
 2466 1458 0080A0E1 		mov	r8, r0
 2467 145c 18709DE5 		ldr	r7, [sp, #24]
 2468              	.LVL192:
1081:../uvc.c      **** 							 break;
 2469              		.loc 1 1081 0
 2470 1460 0C40A0E1 		mov	r4, ip
 2471 1464 6DFEFFEA 		b	.L139
 2472              	.LVL193:
 2473              	.L190:
1068:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2474              		.loc 1 1068 0
 2475 1468 B4489FE5 		ldr	r4, .L267+76
 2476 146c 0010E0E3 		mvn	r1, #0
 2477 1470 1C0094E5 		ldr	r0, [r4, #28]
 2478 1474 FEFFFFEB 		bl	_txe_mutex_get
 2479              	.LVL194:
1069:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2480              		.loc 1 1069 0
 2481 1478 2110A0E3 		mov	r1, #33
 2482 147c E5FFFFEA 		b	.L256
 2483              	.LVL195:
 2484              	.L189:
1054:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2485              		.loc 1 1054 0
 2486 1480 9C489FE5 		ldr	r4, .L267+76
 2487 1484 0010E0E3 		mvn	r1, #0
 2488 1488 1C0094E5 		ldr	r0, [r4, #28]
 2489 148c FEFFFFEB 		bl	_txe_mutex_get
 2490              	.LVL196:
1053:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2491              		.loc 1 1053 0
 2492 1490 14109DE5 		ldr	r1, [sp, #20]
1056:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2493              		.loc 1 1056 0
 2494 1494 0A30A0E1 		mov	r3, sl
1053:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2495              		.loc 1 1053 0
 2496 1498 7F2001E2 		and	r2, r1, #127
 2497 149c 18208DE5 		str	r2, [sp, #24]
 2498              	.LVL197:
1056:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2499              		.loc 1 1056 0
 2500 14a0 18C09DE5 		ldr	ip, [sp, #24]
 2501 14a4 2010A0E3 		mov	r1, #32
 2502 14a8 0920A0E1 		mov	r2, r9
 2503 14ac 0400A0E1 		mov	r0, r4
 2504 14b0 00C08DE5 		str	ip, [sp, #0]
 2505 14b4 00C0A0E3 		mov	ip, #0
 2506 14b8 04C08DE5 		str	ip, [sp, #4]
 2507 14bc FEFFFFEB 		bl	cmdSet
 2508              	.LVL198:
1058:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2509              		.loc 1 1058 0
 2510 14c0 1CC09DE5 		ldr	ip, [sp, #28]
 2511 14c4 0180A0E3 		mov	r8, #1
 2512 14c8 0A30A0E1 		mov	r3, sl
 2513 14cc 2010A0E3 		mov	r1, #32
 2514 14d0 0B20A0E1 		mov	r2, fp
 2515 14d4 0400A0E1 		mov	r0, r4
 2516 14d8 00C08DE5 		str	ip, [sp, #0]
 2517 14dc 04808DE5 		str	r8, [sp, #4]
 2518 14e0 FEFFFFEB 		bl	cmdSet
1059:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2519              		.loc 1 1059 0
 2520 14e4 1C0094E5 		ldr	r0, [r4, #28]
 2521 14e8 FEFFFFEB 		bl	_txe_mutex_put
 2522              	.LVL199:
1062:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2523              		.loc 1 1062 0
 2524 14ec 874087E0 		add	r4, r7, r7, asl #1
1063:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2525              		.loc 1 1063 0
 2526 14f0 1C309DE5 		ldr	r3, [sp, #28]
1062:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2527              		.loc 1 1062 0
 2528 14f4 18709DE5 		ldr	r7, [sp, #24]
 2529              	.LVL200:
 2530 14f8 846186E0 		add	r6, r6, r4, asl #3
1065:../uvc.c      **** 							 break;
 2531              		.loc 1 1065 0
 2532 14fc FFC0A0E3 		mov	ip, #255
1062:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2533              		.loc 1 1062 0
 2534 1500 0D70C6E5 		strb	r7, [r6, #13]
1064:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2535              		.loc 1 1064 0
 2536 1504 1080C6E5 		strb	r8, [r6, #16]
1063:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2537              		.loc 1 1063 0
 2538 1508 0E30C6E5 		strb	r3, [r6, #14]
1064:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2539              		.loc 1 1064 0
 2540 150c 14809DE5 		ldr	r8, [sp, #20]
 2541 1510 0370A0E1 		mov	r7, r3
1065:../uvc.c      **** 							 break;
 2542              		.loc 1 1065 0
 2543 1514 0C40A0E1 		mov	r4, ip
 2544 1518 40FEFFEA 		b	.L139
 2545              	.LVL201:
 2546              	.L188:
1025:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2547              		.loc 1 1025 0 discriminator 1
 2548 151c 000058E3 		cmp	r8, #0
 2549 1520 1800000A 		beq	.L194
1023:../uvc.c      **** 							 break;
 2550              		.loc 1 1023 0
 2551 1524 28E1A0E1 		mov	lr, r8, lsr #2
 2552 1528 00005EE3 		cmp	lr, #0
 2553 152c 03005813 		cmpne	r8, #3
 2554 1530 0020A083 		movhi	r2, #0
 2555 1534 0120A093 		movls	r2, #1
 2556              	.LVL202:
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2557              		.loc 1 621 0
 2558 1538 0E31A0E1 		mov	r3, lr, asl #2
1023:../uvc.c      **** 							 break;
 2559              		.loc 1 1023 0
 2560 153c A302009A 		bls	.L237
 2561 1540 B0179FE5 		ldr	r1, .L267+32
 2562 1544 100081E2 		add	r0, r1, #16
 2563              	.LVL203:
 2564              	.L215:
1026:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2565              		.loc 1 1026 0 discriminator 2
 2566 1548 044090E4 		ldr	r4, [r0], #4
 2567 154c 012082E2 		add	r2, r2, #1
 2568 1550 FF2002E2 		and	r2, r2, #255
 2569 1554 02005EE1 		cmp	lr, r2
 2570 1558 044081E4 		str	r4, [r1], #4
 2571 155c F9FFFF8A 		bhi	.L215
1026:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2572              		.loc 1 1026 0 is_stmt 0
 2573 1560 030058E1 		cmp	r8, r3
 2574 1564 0700000A 		beq	.L194
 2575              	.L245:
 2576 1568 B8C79FE5 		ldr	ip, .L267+80
1025:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2577              		.loc 1 1025 0 is_stmt 1
 2578 156c 010083E2 		add	r0, r3, #1
1026:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2579              		.loc 1 1026 0
 2580 1570 03E08CE0 		add	lr, ip, r3
 2581 1574 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
1025:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2582              		.loc 1 1025 0
 2583 1578 FF3000E2 		and	r3, r0, #255
 2584              	.LVL204:
 2585 157c 030058E1 		cmp	r8, r3
1026:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2586              		.loc 1 1026 0
 2587 1580 4C10CEE5 		strb	r1, [lr, #76]
1025:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2588              		.loc 1 1025 0
 2589 1584 F7FFFF8A 		bhi	.L245
 2590              	.LVL205:
 2591              	.L194:
1028:../uvc.c      **** 					 		I2CCmdHandler();
 2592              		.loc 1 1028 0
 2593 1588 FEFFFFEB 		bl	I2CCmdHandler
1029:../uvc.c      **** 							 break;
 2594              		.loc 1 1029 0
 2595 158c FFC0A0E3 		mov	ip, #255
1028:../uvc.c      **** 					 		I2CCmdHandler();
 2596              		.loc 1 1028 0
 2597 1590 14809DE5 		ldr	r8, [sp, #20]
 2598 1594 18709DE5 		ldr	r7, [sp, #24]
 2599              	.LVL206:
1029:../uvc.c      **** 							 break;
 2600              		.loc 1 1029 0
 2601 1598 0C40A0E1 		mov	r4, ip
 2602 159c 1FFEFFEA 		b	.L139
 2603              	.LVL207:
 2604              	.L187:
1019:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2605              		.loc 1 1019 0
 2606 15a0 7C479FE5 		ldr	r4, .L267+76
 2607 15a4 0010E0E3 		mvn	r1, #0
 2608 15a8 1C0094E5 		ldr	r0, [r4, #28]
 2609 15ac FEFFFFEB 		bl	_txe_mutex_get
 2610              	.LVL208:
1020:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2611              		.loc 1 1020 0
 2612 15b0 14709DE5 		ldr	r7, [sp, #20]
 2613              	.LVL209:
 2614 15b4 00C0A0E3 		mov	ip, #0
 2615 15b8 018077E2 		rsbs	r8, r7, #1
 2616 15bc 0080A033 		movcc	r8, #0
 2617 15c0 0A30A0E1 		mov	r3, sl
 2618 15c4 1E10A0E3 		mov	r1, #30
 2619 15c8 0920A0E1 		mov	r2, r9
 2620 15cc 0400A0E1 		mov	r0, r4
 2621 15d0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2622 15d4 FEFFFFEB 		bl	cmdSet
1021:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2623              		.loc 1 1021 0
 2624 15d8 1C0094E5 		ldr	r0, [r4, #28]
 2625 15dc FEFFFFEB 		bl	_txe_mutex_put
1023:../uvc.c      **** 							 break;
 2626              		.loc 1 1023 0
 2627 15e0 FFC0A0E3 		mov	ip, #255
1022:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2628              		.loc 1 1022 0
 2629 15e4 0130A0E3 		mov	r3, #1
 2630 15e8 6034C6E5 		strb	r3, [r6, #1120]
 2631 15ec 14809DE5 		ldr	r8, [sp, #20]
 2632 15f0 18709DE5 		ldr	r7, [sp, #24]
1023:../uvc.c      **** 							 break;
 2633              		.loc 1 1023 0
 2634 15f4 0C40A0E1 		mov	r4, ip
 2635 15f8 08FEFFEA 		b	.L139
 2636              	.LVL210:
 2637              	.L182:
1158:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2638              		.loc 1 1158 0
 2639 15fc 20479FE5 		ldr	r4, .L267+76
 2640 1600 0010E0E3 		mvn	r1, #0
 2641 1604 1C0094E5 		ldr	r0, [r4, #28]
 2642 1608 FEFFFFEB 		bl	_txe_mutex_get
 2643              	.LVL211:
1159:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2644              		.loc 1 1159 0
 2645 160c 14809DE5 		ldr	r8, [sp, #20]
 2646 1610 00C0A0E3 		mov	ip, #0
 2647 1614 0B10A0E3 		mov	r1, #11
 2648 1618 0920A0E1 		mov	r2, r9
 2649 161c 0A30A0E1 		mov	r3, sl
 2650 1620 0400A0E1 		mov	r0, r4
 2651 1624 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2652 1628 FEFFFFEB 		bl	cmdSet
 2653              	.LVL212:
1161:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2654              		.loc 1 1161 0
 2655 162c 18809DE5 		ldr	r8, [sp, #24]
 2656 1630 0170A0E3 		mov	r7, #1
 2657              	.LVL213:
 2658 1634 0B20A0E1 		mov	r2, fp
 2659 1638 0A30A0E1 		mov	r3, sl
 2660 163c 0B10A0E3 		mov	r1, #11
 2661 1640 0400A0E1 		mov	r0, r4
 2662 1644 00808DE5 		str	r8, [sp, #0]
 2663 1648 04708DE5 		str	r7, [sp, #4]
 2664 164c FEFFFFEB 		bl	cmdSet
1162:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2665              		.loc 1 1162 0
 2666 1650 1C0094E5 		ldr	r0, [r4, #28]
 2667 1654 FEFFFFEB 		bl	_txe_mutex_put
1164:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2668              		.loc 1 1164 0
 2669 1658 14209DE5 		ldr	r2, [sp, #20]
1165:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2670              		.loc 1 1165 0
 2671 165c 18309DE5 		ldr	r3, [sp, #24]
1167:../uvc.c      **** 							 break;
 2672              		.loc 1 1167 0
 2673 1660 FFC0A0E3 		mov	ip, #255
1166:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2674              		.loc 1 1166 0
 2675 1664 9872C6E5 		strb	r7, [r6, #664]
1164:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2676              		.loc 1 1164 0
 2677 1668 CC24C6E5 		strb	r2, [r6, #1228]
1165:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2678              		.loc 1 1165 0
 2679 166c CE34C6E5 		strb	r3, [r6, #1230]
1166:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2680              		.loc 1 1166 0
 2681 1670 0280A0E1 		mov	r8, r2
 2682 1674 0370A0E1 		mov	r7, r3
1167:../uvc.c      **** 							 break;
 2683              		.loc 1 1167 0
 2684 1678 0C40A0E1 		mov	r4, ip
 2685 167c E7FDFFEA 		b	.L139
 2686              	.LVL214:
 2687              	.L181:
1144:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2688              		.loc 1 1144 0
 2689 1680 9C469FE5 		ldr	r4, .L267+76
 2690 1684 0010E0E3 		mvn	r1, #0
 2691 1688 1C0094E5 		ldr	r0, [r4, #28]
 2692 168c FEFFFFEB 		bl	_txe_mutex_get
 2693              	.LVL215:
1145:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2694              		.loc 1 1145 0
 2695 1690 14C09DE5 		ldr	ip, [sp, #20]
 2696 1694 0610A0E3 		mov	r1, #6
 2697 1698 0920A0E1 		mov	r2, r9
 2698 169c 0A30A0E1 		mov	r3, sl
 2699 16a0 0400A0E1 		mov	r0, r4
 2700 16a4 0080A0E3 		mov	r8, #0
 2701 16a8 00C08DE5 		str	ip, [sp, #0]
 2702 16ac 04808DE5 		str	r8, [sp, #4]
 2703 16b0 FEFFFFEB 		bl	cmdSet
 2704              	.LVL216:
1147:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2705              		.loc 1 1147 0
 2706 16b4 14C09DE5 		ldr	ip, [sp, #20]
 2707 16b8 0170A0E3 		mov	r7, #1
 2708              	.LVL217:
 2709 16bc 0610A0E3 		mov	r1, #6
 2710 16c0 0B20A0E1 		mov	r2, fp
 2711 16c4 0A30A0E1 		mov	r3, sl
 2712 16c8 0400A0E1 		mov	r0, r4
 2713 16cc 00C08DE5 		str	ip, [sp, #0]
 2714 16d0 04708DE5 		str	r7, [sp, #4]
 2715 16d4 FEFFFFEB 		bl	cmdSet
1148:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2716              		.loc 1 1148 0
 2717 16d8 1C0094E5 		ldr	r0, [r4, #28]
 2718 16dc FEFFFFEB 		bl	_txe_mutex_put
1149:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2719              		.loc 1 1149 0
 2720 16e0 14809DE5 		ldr	r8, [sp, #20]
1151:../uvc.c      **** 							 break;
 2721              		.loc 1 1151 0
 2722 16e4 FFC0A0E3 		mov	ip, #255
1150:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2723              		.loc 1 1150 0
 2724 16e8 2072C6E5 		strb	r7, [r6, #544]
1149:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2725              		.loc 1 1149 0
 2726 16ec 1D82C6E5 		strb	r8, [r6, #541]
1150:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2727              		.loc 1 1150 0
 2728 16f0 18709DE5 		ldr	r7, [sp, #24]
1151:../uvc.c      **** 							 break;
 2729              		.loc 1 1151 0
 2730 16f4 0C40A0E1 		mov	r4, ip
 2731 16f8 C8FDFFEA 		b	.L139
 2732              	.LVL218:
 2733              	.L180:
1124:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2734              		.loc 1 1124 0
 2735 16fc 20869FE5 		ldr	r8, .L267+76
 2736 1700 0010E0E3 		mvn	r1, #0
 2737 1704 1C0098E5 		ldr	r0, [r8, #28]
 2738 1708 FEFFFFEB 		bl	_txe_mutex_get
 2739              	.LVL219:
1125:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2740              		.loc 1 1125 0
 2741 170c 14009DE5 		ldr	r0, [sp, #20]
 2742 1710 00C0A0E3 		mov	ip, #0
 2743 1714 801040E2 		sub	r1, r0, #128
 2744 1718 FF4001E2 		and	r4, r1, #255
 2745 171c 0920A0E1 		mov	r2, r9
 2746 1720 0510A0E3 		mov	r1, #5
 2747 1724 0A30A0E1 		mov	r3, sl
 2748 1728 0800A0E1 		mov	r0, r8
 2749 172c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2750 1730 FEFFFFEB 		bl	cmdSet
 2751              	.LVL220:
1127:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2752              		.loc 1 1127 0
 2753 1734 14209DE5 		ldr	r2, [sp, #20]
 2754 1738 0510A0E3 		mov	r1, #5
 2755 173c 767042E2 		sub	r7, r2, #118
 2756              	.LVL221:
 2757 1740 FF4007E2 		and	r4, r7, #255
 2758 1744 DC20A0E3 		mov	r2, #220
 2759 1748 0170A0E3 		mov	r7, #1
 2760 174c 0A30A0E1 		mov	r3, sl
 2761 1750 0800A0E1 		mov	r0, r8
 2762 1754 90008DE8 		stmia	sp, {r4, r7}	@ phole stm
 2763 1758 FEFFFFEB 		bl	cmdSet
 2764              	.LVL222:
1129:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2765              		.loc 1 1129 0
 2766 175c 14309DE5 		ldr	r3, [sp, #20]
 2767 1760 0510A0E3 		mov	r1, #5
 2768 1764 7E0083E2 		add	r0, r3, #126
 2769 1768 FFC000E2 		and	ip, r0, #255
 2770 176c DE20A0E3 		mov	r2, #222
 2771 1770 0A30A0E1 		mov	r3, sl
 2772 1774 0800A0E1 		mov	r0, r8
 2773 1778 0240A0E3 		mov	r4, #2
 2774 177c 00C08DE5 		str	ip, [sp, #0]
 2775 1780 04408DE5 		str	r4, [sp, #4]
 2776 1784 FEFFFFEB 		bl	cmdSet
 2777              	.LVL223:
1131:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2778              		.loc 1 1131 0
 2779 1788 14109DE5 		ldr	r1, [sp, #20]
 2780 178c 0A30A0E1 		mov	r3, sl
 2781 1790 722081E2 		add	r2, r1, #114
 2782 1794 FFC002E2 		and	ip, r2, #255
 2783 1798 0510A0E3 		mov	r1, #5
 2784 179c E020A0E3 		mov	r2, #224
 2785 17a0 0800A0E1 		mov	r0, r8
 2786 17a4 0340A0E3 		mov	r4, #3
 2787 17a8 00C08DE5 		str	ip, [sp, #0]
 2788 17ac 04408DE5 		str	r4, [sp, #4]
 2789 17b0 FEFFFFEB 		bl	cmdSet
 2790              	.LVL224:
1133:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2791              		.loc 1 1133 0
 2792 17b4 14309DE5 		ldr	r3, [sp, #20]
 2793 17b8 0510A0E3 		mov	r1, #5
 2794 17bc 6F0043E2 		sub	r0, r3, #111
 2795 17c0 FFC000E2 		and	ip, r0, #255
 2796 17c4 DD20A0E3 		mov	r2, #221
 2797 17c8 0A30A0E1 		mov	r3, sl
 2798 17cc 0800A0E1 		mov	r0, r8
 2799 17d0 0440A0E3 		mov	r4, #4
 2800 17d4 00C08DE5 		str	ip, [sp, #0]
 2801 17d8 04408DE5 		str	r4, [sp, #4]
 2802 17dc FEFFFFEB 		bl	cmdSet
 2803              	.LVL225:
1135:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2804              		.loc 1 1135 0
 2805 17e0 40159FE5 		ldr	r1, .L267+80
 2806 17e4 05E0A0E3 		mov	lr, #5
 2807 17e8 5C20D1E5 		ldrb	r2, [r1, #92]	@ zero_extendqisi2
 2808 17ec 0A30A0E1 		mov	r3, sl
 2809 17f0 7FC082E2 		add	ip, r2, #127
 2810 17f4 FF400CE2 		and	r4, ip, #255
 2811 17f8 0E10A0E1 		mov	r1, lr
 2812 17fc 0B20A0E1 		mov	r2, fp
 2813 1800 0800A0E1 		mov	r0, r8
 2814 1804 10408DE8 		stmia	sp, {r4, lr}	@ phole stm
 2815 1808 FEFFFFEB 		bl	cmdSet
1136:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2816              		.loc 1 1136 0
 2817 180c 1C0098E5 		ldr	r0, [r8, #28]
 2818 1810 FEFFFFEB 		bl	_txe_mutex_put
1138:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2819              		.loc 1 1138 0
 2820 1814 0C359FE5 		ldr	r3, .L267+80
1140:../uvc.c      **** 							 break;
 2821              		.loc 1 1140 0
 2822 1818 FFC0A0E3 		mov	ip, #255
1138:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2823              		.loc 1 1138 0
 2824 181c 5C00D3E5 		ldrb	r0, [r3, #92]	@ zero_extendqisi2
1139:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2825              		.loc 1 1139 0
 2826 1820 0872C6E5 		strb	r7, [r6, #520]
1138:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2827              		.loc 1 1138 0
 2828 1824 801040E2 		sub	r1, r0, #128
 2829 1828 0512C6E5 		strb	r1, [r6, #517]
1139:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2830              		.loc 1 1139 0
 2831 182c 14809DE5 		ldr	r8, [sp, #20]
 2832 1830 18709DE5 		ldr	r7, [sp, #24]
1140:../uvc.c      **** 							 break;
 2833              		.loc 1 1140 0
 2834 1834 0C40A0E1 		mov	r4, ip
 2835 1838 78FDFFEA 		b	.L139
 2836              	.LVL226:
 2837              	.L179:
 2838 183c 03E0A0E1 		mov	lr, r3
 2839              	.LVL227:
1171:../uvc.c      **** 							 Data0 = Data0 - 1;
 2840              		.loc 1 1171 0
 2841 1840 013043E2 		sub	r3, r3, #1
 2842 1844 FF0003E2 		and	r0, r3, #255
 2843              	.LVL228:
1172:../uvc.c      **** 							 is60Hz = Data0;
 2844              		.loc 1 1172 0
 2845 1848 D8149FE5 		ldr	r1, .L267+80
1178:../uvc.c      **** 							 else if(Data0 >2)
 2846              		.loc 1 1178 0
 2847 184c 020050E3 		cmp	r0, #2
1170:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2848              		.loc 1 1170 0
 2849 1850 EDE1C6E5 		strb	lr, [r6, #493]
1181:../uvc.c      **** 								 is60Hz = CyTrue;
 2850              		.loc 1 1181 0
 2851 1854 01E0A083 		movhi	lr, #1
1172:../uvc.c      **** 							 is60Hz = Data0;
 2852              		.loc 1 1172 0
 2853 1858 580081E5 		str	r0, [r1, #88]
 2854              	.LVL229:
1181:../uvc.c      **** 								 is60Hz = CyTrue;
 2855              		.loc 1 1181 0
 2856 185c 58E08185 		strhi	lr, [r1, #88]
1184:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2857              		.loc 1 1184 0
 2858 1860 C0149FE5 		ldr	r1, .L267+80
 2859 1864 280091E5 		ldr	r0, [r1, #40]
 2860 1868 0130A0E1 		mov	r3, r1
 2861 186c 010050E3 		cmp	r0, #1
 2862 1870 7E01000A 		beq	.L263
 2863              	.LVL230:
 2864              	.L221:
1210:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2865              		.loc 1 1210 0
 2866 1874 0140A0E3 		mov	r4, #1
1211:../uvc.c      **** 							 break;
 2867              		.loc 1 1211 0
 2868 1878 FFC0A0E3 		mov	ip, #255
1210:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2869              		.loc 1 1210 0
 2870 187c F041C6E5 		strb	r4, [r6, #496]
 2871 1880 14809DE5 		ldr	r8, [sp, #20]
 2872 1884 18709DE5 		ldr	r7, [sp, #24]
1211:../uvc.c      **** 							 break;
 2873              		.loc 1 1211 0
 2874 1888 0C40A0E1 		mov	r4, ip
 2875 188c 63FDFFEA 		b	.L139
 2876              	.LVL231:
 2877              	.L178:
1106:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2878              		.loc 1 1106 0
 2879 1890 8C449FE5 		ldr	r4, .L267+76
 2880 1894 0010E0E3 		mvn	r1, #0
 2881 1898 1C0094E5 		ldr	r0, [r4, #28]
 2882 189c FEFFFFEB 		bl	_txe_mutex_get
 2883              	.LVL232:
1108:../uvc.c      **** 							  if(Data0&0x80){
 2884              		.loc 1 1108 0
 2885 18a0 14209DE5 		ldr	r2, [sp, #20]
1113:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2886              		.loc 1 1113 0
 2887 18a4 00C0A0E3 		mov	ip, #0
1108:../uvc.c      **** 							  if(Data0&0x80){
 2888              		.loc 1 1108 0
 2889 18a8 800012E3 		tst	r2, #128
1109:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2890              		.loc 1 1109 0
 2891 18ac 80704212 		subne	r7, r2, #128
 2892              	.LVL233:
1111:../uvc.c      **** 								  Data0 = ~Data0;
 2893              		.loc 1 1111 0
 2894 18b0 0270E001 		mvneq	r7, r2
 2895 18b4 FF8007E2 		and	r8, r7, #255
 2896              	.LVL234:
1113:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2897              		.loc 1 1113 0
 2898 18b8 0110A0E3 		mov	r1, #1
 2899 18bc 0B20A0E1 		mov	r2, fp
 2900 18c0 0A30A0E1 		mov	r3, sl
 2901 18c4 58049FE5 		ldr	r0, .L267+76
 2902 18c8 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 2903 18cc FEFFFFEB 		bl	cmdSet
1114:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2904              		.loc 1 1114 0
 2905 18d0 1C0094E5 		ldr	r0, [r4, #28]
 2906 18d4 FEFFFFEB 		bl	_txe_mutex_put
1117:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2907              		.loc 1 1117 0
 2908 18d8 0170A0E3 		mov	r7, #1
1120:../uvc.c      **** 							 break;
 2909              		.loc 1 1120 0
 2910 18dc FFC0A0E3 		mov	ip, #255
1116:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2911              		.loc 1 1116 0
 2912 18e0 A581C6E5 		strb	r8, [r6, #421]
1117:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2913              		.loc 1 1117 0
 2914 18e4 A871C6E5 		strb	r7, [r6, #424]
 2915 18e8 14809DE5 		ldr	r8, [sp, #20]
 2916              	.LVL235:
 2917 18ec 18709DE5 		ldr	r7, [sp, #24]
1120:../uvc.c      **** 							 break;
 2918              		.loc 1 1120 0
 2919 18f0 0C40A0E1 		mov	r4, ip
 2920 18f4 49FDFFEA 		b	.L139
 2921              	.LVL236:
 2922              	.L176:
1234:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2923              		.loc 1 1234 0
 2924 18f8 24749FE5 		ldr	r7, .L267+76
 2925              	.LVL237:
 2926 18fc 0010E0E3 		mvn	r1, #0
 2927 1900 1C0097E5 		ldr	r0, [r7, #28]
 2928 1904 FEFFFFEB 		bl	_txe_mutex_get
 2929              	.LVL238:
1235:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2930              		.loc 1 1235 0
 2931 1908 14C09DE5 		ldr	ip, [sp, #20]
 2932 190c 0410A0E1 		mov	r1, r4
 2933 1910 0A30A0E1 		mov	r3, sl
 2934 1914 0920A0E1 		mov	r2, r9
 2935 1918 0700A0E1 		mov	r0, r7
 2936 191c 0080A0E3 		mov	r8, #0
 2937 1920 00C08DE5 		str	ip, [sp, #0]
 2938 1924 04808DE5 		str	r8, [sp, #4]
 2939 1928 FEFFFFEB 		bl	cmdSet
1236:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2940              		.loc 1 1236 0
 2941 192c 1C0097E5 		ldr	r0, [r7, #28]
 2942 1930 FEFFFFEB 		bl	_txe_mutex_put
1238:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2943              		.loc 1 1238 0
 2944 1934 14109DE5 		ldr	r1, [sp, #20]
 2945 1938 843084E0 		add	r3, r4, r4, asl #1
 2946 193c 836186E0 		add	r6, r6, r3, asl #3
1240:../uvc.c      **** 							 break;
 2947              		.loc 1 1240 0
 2948 1940 FFC0A0E3 		mov	ip, #255
1239:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2949              		.loc 1 1239 0
 2950 1944 0100A0E3 		mov	r0, #1
1238:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2951              		.loc 1 1238 0
 2952 1948 8D11C6E5 		strb	r1, [r6, #397]
1239:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2953              		.loc 1 1239 0
 2954 194c 9001C6E5 		strb	r0, [r6, #400]
 2955 1950 0180A0E1 		mov	r8, r1
 2956 1954 18709DE5 		ldr	r7, [sp, #24]
1240:../uvc.c      **** 							 break;
 2957              		.loc 1 1240 0
 2958 1958 0C40A0E1 		mov	r4, ip
 2959 195c 2FFDFFEA 		b	.L139
 2960              	.LVL239:
 2961              	.L177:
1215:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2962              		.loc 1 1215 0
 2963 1960 C0E39FE5 		ldr	lr, .L267+80
1214:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2964              		.loc 1 1214 0
 2965 1964 0180A0E3 		mov	r8, #1
1215:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2966              		.loc 1 1215 0
 2967 1968 7C20DEE5 		ldrb	r2, [lr, #124]	@ zero_extendqisi2
 2968              	.LVL240:
1213:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2969              		.loc 1 1213 0
 2970 196c 8D31C6E5 		strb	r3, [r6, #397]
1215:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2971              		.loc 1 1215 0
 2972 1970 010052E3 		cmp	r2, #1
1214:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2973              		.loc 1 1214 0
 2974 1974 9081C6E5 		strb	r8, [r6, #400]
 2975 1978 0370A011 		movne	r7, r3
 2976              	.LVL241:
1215:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2977              		.loc 1 1215 0
 2978 197c 4D01000A 		beq	.L264
 2979              	.LVL242:
 2980              	.L228:
1226:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2981              		.loc 1 1226 0
 2982 1980 9C439FE5 		ldr	r4, .L267+76
 2983 1984 0010E0E3 		mvn	r1, #0
 2984 1988 1C0094E5 		ldr	r0, [r4, #28]
1224:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2985              		.loc 1 1224 0
 2986 198c 2D74C6E5 		strb	r7, [r6, #1069]
 2987              	.LVL243:
1226:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2988              		.loc 1 1226 0
 2989 1990 FEFFFFEB 		bl	_txe_mutex_get
1227:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2990              		.loc 1 1227 0
 2991 1994 00C0A0E3 		mov	ip, #0
 2992 1998 0C10A0E1 		mov	r1, ip
 2993 199c 0920A0E1 		mov	r2, r9
 2994 19a0 0A30A0E1 		mov	r3, sl
 2995 19a4 0400A0E1 		mov	r0, r4
 2996 19a8 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2997 19ac FEFFFFEB 		bl	cmdSet
 2998              	.LVL244:
 2999              	.L255:
1228:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3000              		.loc 1 1228 0
 3001 19b0 1C0094E5 		ldr	r0, [r4, #28]
 3002 19b4 FEFFFFEB 		bl	_txe_mutex_put
1230:../uvc.c      **** 					 		 break;
 3003              		.loc 1 1230 0
 3004 19b8 FFC0A0E3 		mov	ip, #255
1228:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3005              		.loc 1 1228 0
 3006 19bc 14809DE5 		ldr	r8, [sp, #20]
 3007 19c0 18709DE5 		ldr	r7, [sp, #24]
1230:../uvc.c      **** 					 		 break;
 3008              		.loc 1 1230 0
 3009 19c4 0C40A0E1 		mov	r4, ip
 3010 19c8 14FDFFEA 		b	.L139
 3011              	.LVL245:
 3012              	.L186:
 997:../uvc.c      **** 							 if(Data0 <= 3){
 3013              		.loc 1 997 0
 3014 19cc 030053E3 		cmp	r3, #3
 998:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3015              		.loc 1 998 0
 3016 19d0 50139F95 		ldrls	r1, .L267+80
1001:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3017              		.loc 1 1001 0
 3018 19d4 4CC39F85 		ldrhi	ip, .L267+80
1007:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3019              		.loc 1 1007 0
 3020 19d8 44439FE5 		ldr	r4, .L267+76
1004:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3021              		.loc 1 1004 0
 3022 19dc 14E09DE5 		ldr	lr, [sp, #20]
 3023 19e0 0300A0E1 		mov	r0, r3
 3024              	.LVL246:
1001:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3025              		.loc 1 1001 0
 3026 19e4 0120A083 		movhi	r2, #1
 3027              	.LVL247:
 998:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3028              		.loc 1 998 0
 3029 19e8 0030A093 		movls	r3, #0
 3030 19ec 7C30C195 		strlsb	r3, [r1, #124]
 3031              	.LVL248:
1002:../uvc.c      **** 								 Data1 = Data0-4;
 3032              		.loc 1 1002 0
 3033 19f0 04304382 		subhi	r3, r3, #4
 998:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3034              		.loc 1 998 0
 3035 19f4 0030A091 		movls	r3, r0
1001:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3036              		.loc 1 1001 0
 3037 19f8 7C20CC85 		strhib	r2, [ip, #124]
 3038              	.LVL249:
1006:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3039              		.loc 1 1006 0
 3040 19fc 0120A0E3 		mov	r2, #1
1005:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 3041              		.loc 1 1005 0
 3042 1a00 8D31C6E5 		strb	r3, [r6, #397]
1006:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3043              		.loc 1 1006 0
 3044 1a04 3024C6E5 		strb	r2, [r6, #1072]
1007:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3045              		.loc 1 1007 0
 3046 1a08 0010E0E3 		mvn	r1, #0
 3047 1a0c 1C0094E5 		ldr	r0, [r4, #28]
1004:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3048              		.loc 1 1004 0
 3049 1a10 2DE4C6E5 		strb	lr, [r6, #1069]
1007:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3050              		.loc 1 1007 0
 3051 1a14 FEFFFFEB 		bl	_txe_mutex_get
 3052              	.LVL250:
1008:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3053              		.loc 1 1008 0
 3054 1a18 14709DE5 		ldr	r7, [sp, #20]
 3055              	.LVL251:
 3056 1a1c 0080A0E3 		mov	r8, #0
 3057 1a20 1C10A0E3 		mov	r1, #28
 3058 1a24 0920A0E1 		mov	r2, r9
 3059 1a28 0A30A0E1 		mov	r3, sl
 3060 1a2c 0400A0E1 		mov	r0, r4
 3061 1a30 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3062 1a34 FEFFFFEB 		bl	cmdSet
 3063 1a38 DCFFFFEA 		b	.L255
 3064              	.LVL252:
 3065              	.L184:
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3066              		.loc 1 940 0
 3067 1a3c E0429FE5 		ldr	r4, .L267+76
 936:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3068              		.loc 1 936 0
 3069 1a40 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 937:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3070              		.loc 1 937 0
 3071 1a44 B994D6E5 		ldrb	r9, [r6, #1209]	@ zero_extendqisi2
 938:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3072              		.loc 1 938 0
 3073 1a48 C7E4D6E5 		ldrb	lr, [r6, #1223]	@ zero_extendqisi2
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3074              		.loc 1 940 0
 3075 1a4c 0010E0E3 		mvn	r1, #0
 3076 1a50 1C0094E5 		ldr	r0, [r4, #28]
 938:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3077              		.loc 1 938 0
 3078 1a54 FF700EE2 		and	r7, lr, #255
 3079              	.LVL253:
 940:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3080              		.loc 1 940 0
 3081 1a58 FEFFFFEB 		bl	_txe_mutex_get
 3082              	.LVL254:
 941:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3083              		.loc 1 941 0
 3084 1a5c 14C09DE5 		ldr	ip, [sp, #20]
 3085 1a60 C514D6E5 		ldrb	r1, [r6, #1221]	@ zero_extendqisi2
 936:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3086              		.loc 1 936 0
 3087 1a64 FFA00AE2 		and	sl, sl, #255
 3088              	.LVL255:
 941:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3089              		.loc 1 941 0
 3090 1a68 01005CE1 		cmp	ip, r1
 937:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3091              		.loc 1 937 0
 3092 1a6c FF9009E2 		and	r9, r9, #255
 3093              	.LVL256:
 936:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3094              		.loc 1 936 0
 3095 1a70 60229FE5 		ldr	r2, .L267
 3096 1a74 0C80A001 		moveq	r8, ip
 941:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3097              		.loc 1 941 0
 3098 1a78 0A00000A 		beq	.L208
 943:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3099              		.loc 1 943 0
 3100 1a7c C5C4C2E5 		strb	ip, [r2, #1221]
 944:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3101              		.loc 1 944 0
 3102 1a80 9D34D2E5 		ldrb	r3, [r2, #1181]	@ zero_extendqisi2
 945:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3103              		.loc 1 945 0
 3104 1a84 1910A0E3 		mov	r1, #25
 944:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3105              		.loc 1 944 0
 3106 1a88 03028CE1 		orr	r0, ip, r3, asl #4
 3107 1a8c FF8000E2 		and	r8, r0, #255
 3108              	.LVL257:
 945:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3109              		.loc 1 945 0
 3110 1a90 00C0A0E3 		mov	ip, #0
 3111 1a94 0400A0E1 		mov	r0, r4
 3112 1a98 0A20A0E1 		mov	r2, sl
 3113 1a9c 0730A0E1 		mov	r3, r7
 3114 1aa0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3115 1aa4 FEFFFFEB 		bl	cmdSet
 3116              	.LVL258:
 3117              	.L208:
 957:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3118              		.loc 1 957 0
 3119 1aa8 C624D6E5 		ldrb	r2, [r6, #1222]	@ zero_extendqisi2
 3120 1aac 18009DE5 		ldr	r0, [sp, #24]
 3121 1ab0 000052E1 		cmp	r2, r0
 3122 1ab4 0500000A 		beq	.L209
 959:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3123              		.loc 1 959 0
 3124 1ab8 14C09DE5 		ldr	ip, [sp, #20]
 958:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3125              		.loc 1 958 0
 3126 1abc 14129FE5 		ldr	r1, .L267
 959:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3127              		.loc 1 959 0
 3128 1ac0 02E04CE2 		sub	lr, ip, #2
 3129 1ac4 01005EE3 		cmp	lr, #1
 958:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3130              		.loc 1 958 0
 3131 1ac8 C604C1E5 		strb	r0, [r1, #1222]
 959:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3132              		.loc 1 959 0
 3133 1acc 1F01009A 		bls	.L265
 3134              	.LVL259:
 3135              	.L209:
 964:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3136              		.loc 1 964 0
 3137 1ad0 1C0094E5 		ldr	r0, [r4, #28]
 3138 1ad4 FEFFFFEB 		bl	_txe_mutex_put
 966:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3139              		.loc 1 966 0
 3140 1ad8 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 965:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3141              		.loc 1 965 0
 3142 1adc 18709DE5 		ldr	r7, [sp, #24]
 966:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3143              		.loc 1 966 0
 3144 1ae0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 3145 1ae4 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 965:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3146              		.loc 1 965 0
 3147 1ae8 0400A0E3 		mov	r0, #4
 3148 1aec 08129FE5 		ldr	r1, .L267+36
 3149 1af0 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3150 1af4 08708DE5 		str	r7, [sp, #8]
 3151 1af8 FEFFFFEB 		bl	CyU3PDebugPrint
 967:../uvc.c      **** 							 break;
 3152              		.loc 1 967 0
 3153 1afc FFC0A0E3 		mov	ip, #255
 965:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3154              		.loc 1 965 0
 3155 1b00 14809DE5 		ldr	r8, [sp, #20]
 3156              	.LVL260:
 967:../uvc.c      **** 							 break;
 3157              		.loc 1 967 0
 3158 1b04 0C40A0E1 		mov	r4, ip
 3159 1b08 C4FCFFEA 		b	.L139
 3160              	.LVL261:
 3161              	.L185:
 974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3162              		.loc 1 974 0
 3163 1b0c 10429FE5 		ldr	r4, .L267+76
 970:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3164              		.loc 1 970 0
 3165 1b10 A4A4D6E5 		ldrb	sl, [r6, #1188]	@ zero_extendqisi2
 971:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3166              		.loc 1 971 0
 3167 1b14 A584D6E5 		ldrb	r8, [r6, #1189]	@ zero_extendqisi2
 972:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3168              		.loc 1 972 0
 3169 1b18 B334D6E5 		ldrb	r3, [r6, #1203]	@ zero_extendqisi2
 974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3170              		.loc 1 974 0
 3171 1b1c 1C0094E5 		ldr	r0, [r4, #28]
 3172 1b20 0010E0E3 		mvn	r1, #0
 972:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3173              		.loc 1 972 0
 3174 1b24 FF7003E2 		and	r7, r3, #255
 3175              	.LVL262:
 974:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3176              		.loc 1 974 0
 3177 1b28 FEFFFFEB 		bl	_txe_mutex_get
 3178              	.LVL263:
 982:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3179              		.loc 1 982 0
 3180 1b2c B124D6E5 		ldrb	r2, [r6, #1201]	@ zero_extendqisi2
 3181 1b30 14009DE5 		ldr	r0, [sp, #20]
 970:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3182              		.loc 1 970 0
 3183 1b34 FFA00AE2 		and	sl, sl, #255
 3184              	.LVL264:
 982:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3185              		.loc 1 982 0
 3186 1b38 020050E1 		cmp	r0, r2
 971:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3187              		.loc 1 971 0
 3188 1b3c FF8008E2 		and	r8, r8, #255
 3189              	.LVL265:
 970:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3190              		.loc 1 970 0
 3191 1b40 90319FE5 		ldr	r3, .L267
 982:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3192              		.loc 1 982 0
 3193 1b44 0600000A 		beq	.L210
 983:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3194              		.loc 1 983 0
 3195 1b48 B104C3E5 		strb	r0, [r3, #1201]
 984:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3196              		.loc 1 984 0
 3197 1b4c C504D3E5 		ldrb	r0, [r3, #1221]	@ zero_extendqisi2
 3198 1b50 010050E3 		cmp	r0, #1
 3199 1b54 E100000A 		beq	.L211
 984:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3200              		.loc 1 984 0 is_stmt 0 discriminator 1
 3201 1b58 C514D3E5 		ldrb	r1, [r3, #1221]	@ zero_extendqisi2
 3202 1b5c 030051E3 		cmp	r1, #3
 3203 1b60 DE00000A 		beq	.L211
 3204              	.LVL266:
 3205              	.L210:
 991:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3206              		.loc 1 991 0 is_stmt 1
 3207 1b64 1C0094E5 		ldr	r0, [r4, #28]
 3208 1b68 FEFFFFEB 		bl	_txe_mutex_put
 993:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3209              		.loc 1 993 0
 3210 1b6c C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
 992:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3211              		.loc 1 992 0
 3212 1b70 14809DE5 		ldr	r8, [sp, #20]
 3213              	.LVL267:
 993:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3214              		.loc 1 993 0
 3215 1b74 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 992:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3216              		.loc 1 992 0
 3217 1b78 18709DE5 		ldr	r7, [sp, #24]
 993:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3218              		.loc 1 993 0
 3219 1b7c B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
 992:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3220              		.loc 1 992 0
 3221 1b80 0400A0E3 		mov	r0, #4
 3222 1b84 74119FE5 		ldr	r1, .L267+40
 3223 1b88 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3224 1b8c 08708DE5 		str	r7, [sp, #8]
 3225 1b90 FEFFFFEB 		bl	CyU3PDebugPrint
 994:../uvc.c      **** 							 break;
 3226              		.loc 1 994 0
 3227 1b94 FFC0A0E3 		mov	ip, #255
 3228 1b98 0C40A0E1 		mov	r4, ip
 3229 1b9c 9FFCFFEA 		b	.L139
 3230              	.LVL268:
 3231              	.L183:
 876:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3232              		.loc 1 876 0
 3233 1ba0 9084D6E5 		ldrb	r8, [r6, #1168]	@ zero_extendqisi2
 877:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3234              		.loc 1 877 0
 3235 1ba4 9174D6E5 		ldrb	r7, [r6, #1169]	@ zero_extendqisi2
 3236              	.LVL269:
 878:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3237              		.loc 1 878 0
 3238 1ba8 9F44D6E5 		ldrb	r4, [r6, #1183]	@ zero_extendqisi2
 895:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 3239              		.loc 1 895 0
 3240 1bac 000053E3 		cmp	r3, #0
 877:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3241              		.loc 1 877 0
 3242 1bb0 FFA007E2 		and	sl, r7, #255
 876:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3243              		.loc 1 876 0
 3244 1bb4 1C219FE5 		ldr	r2, .L267
 3245              	.LVL270:
 3246 1bb8 FF8008E2 		and	r8, r8, #255
 3247              	.LVL271:
 878:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3248              		.loc 1 878 0
 3249 1bbc FF7004E2 		and	r7, r4, #255
 3250              	.LVL272:
 879:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3251              		.loc 1 879 0
 3252 1bc0 9D34C6E5 		strb	r3, [r6, #1181]
 895:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 3253              		.loc 1 895 0
 3254 1bc4 2000001A 		bne	.L195
 896:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 3255              		.loc 1 896 0
 3256 1bc8 F534D2E5 		ldrb	r3, [r2, #1269]	@ zero_extendqisi2
 3257 1bcc 020053E3 		cmp	r3, #2
 3258 1bd0 08005313 		cmpne	r3, #8
 3259 1bd4 0030E003 		mvneq	r3, #0
 3260 1bd8 2F00000A 		beq	.L196
 897:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 3261              		.loc 1 897 0
 3262 1bdc 010053E3 		cmp	r3, #1
 900:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 3263              		.loc 1 900 0
 3264 1be0 0230A013 		movne	r3, #2
 898:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 3265              		.loc 1 898 0
 3266 1be4 0810A003 		moveq	r1, #8
 900:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 3267              		.loc 1 900 0
 3268 1be8 F534C215 		strneb	r3, [r2, #1269]
 920:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
 3269              		.loc 1 920 0
 3270 1bec 0130A013 		movne	r3, #1
 898:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 3271              		.loc 1 898 0
 3272 1bf0 F514C205 		streqb	r1, [r2, #1269]
 920:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
 3273              		.loc 1 920 0
 3274 1bf4 A134C2E5 		strb	r3, [r2, #1185]
 3275              	.LVL273:
 3276              	.L198:
 923:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3277              		.loc 1 923 0
 3278 1bf8 24419FE5 		ldr	r4, .L267+76
 3279 1bfc 0010E0E3 		mvn	r1, #0
 3280 1c00 1C0094E5 		ldr	r0, [r4, #28]
 3281 1c04 FEFFFFEB 		bl	_txe_mutex_get
 924:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
 3282              		.loc 1 924 0
 3283 1c08 00C0A0E3 		mov	ip, #0
 3284 1c0c 0400A0E1 		mov	r0, r4
 3285 1c10 1010A0E3 		mov	r1, #16
 3286 1c14 0820A0E1 		mov	r2, r8
 3287 1c18 0730A0E1 		mov	r3, r7
 3288 1c1c 00C08DE5 		str	ip, [sp, #0]
 3289 1c20 04C08DE5 		str	ip, [sp, #4]
 3290 1c24 FEFFFFEB 		bl	cmdSet
 3291 1c28 60FFFFEA 		b	.L255
 3292              	.LVL274:
 3293              	.L175:
1243:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3294              		.loc 1 1243 0
 3295 1c2c 0400A0E3 		mov	r0, #4
 3296              	.LVL275:
 3297 1c30 CC109FE5 		ldr	r1, .L267+44
 3298 1c34 FEFFFFEB 		bl	CyU3PDebugPrint
 3299              	.LVL276:
 3300 1c38 FFC0A0E3 		mov	ip, #255
 3301 1c3c 0C40A0E1 		mov	r4, ip
 3302 1c40 0C70A0E1 		mov	r7, ip
 3303              	.LVL277:
 3304 1c44 0C80A0E1 		mov	r8, ip
 3305 1c48 74FCFFEA 		b	.L139
 3306              	.LVL278:
 3307              	.L195:
 905:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3308              		.loc 1 905 0
 3309 1c4c F514D2E5 		ldrb	r1, [r2, #1269]	@ zero_extendqisi2
 904:../uvc.c      **** 								 Data1 = Data0 - 1;
 3310              		.loc 1 904 0
 3311 1c50 013043E2 		sub	r3, r3, #1
 905:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3312              		.loc 1 905 0
 3313 1c54 040051E3 		cmp	r1, #4
 3314 1c58 01005113 		cmpne	r1, #1
 904:../uvc.c      **** 								 Data1 = Data0 - 1;
 3315              		.loc 1 904 0
 3316 1c5c FF0003E2 		and	r0, r3, #255
 3317              	.LVL279:
 905:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 3318              		.loc 1 905 0
 3319 1c60 0300000A 		beq	.L199
 906:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 3320              		.loc 1 906 0
 3321 1c64 080051E3 		cmp	r1, #8
 907:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 3322              		.loc 1 907 0
 3323 1c68 0110A003 		moveq	r1, #1
 909:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 3324              		.loc 1 909 0
 3325 1c6c 0410A013 		movne	r1, #4
 3326 1c70 F514C2E5 		strb	r1, [r2, #1269]
 3327              	.L199:
 912:../uvc.c      **** 								 if(Data1 < 8){
 3328              		.loc 1 912 0
 3329 1c74 070050E3 		cmp	r0, #7
 913:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3330              		.loc 1 913 0
 3331 1c78 8C209F95 		ldrls	r2, .L267+52
 916:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3332              		.loc 1 916 0
 3333 1c7c 0120A083 		movhi	r2, #1
 913:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3334              		.loc 1 913 0
 3335 1c80 80008290 		addls	r0, r2, r0, asl #1
 3336              	.LVL280:
 3337 1c84 2010D095 		ldrlsb	r1, [r0, #32]	@ zero_extendqisi2
 914:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3338              		.loc 1 914 0
 3339 1c88 2120D095 		ldrlsb	r2, [r0, #33]	@ zero_extendqisi2
 916:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3340              		.loc 1 916 0
 3341 1c8c 2525C685 		strhib	r2, [r6, #1317]
 917:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3342              		.loc 1 917 0
 3343 1c90 0020A083 		movhi	r2, #0
 913:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3344              		.loc 1 913 0
 3345 1c94 2515C695 		strlsb	r1, [r6, #1317]
 917:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3346              		.loc 1 917 0
 3347 1c98 2625C6E5 		strb	r2, [r6, #1318]
 3348              	.L196:
 920:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
 3349              		.loc 1 920 0
 3350 1c9c 0120A0E3 		mov	r2, #1
 3351 1ca0 A124C6E5 		strb	r2, [r6, #1185]
 3352              	.LVL281:
 3353              	.LBB62:
 3354              	.LBB63:
 579:../uvc.c      **** 	switch (Data){
 3355              		.loc 1 579 0
 3356 1ca4 090053E3 		cmp	r3, #9
 3357 1ca8 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3358 1cac D1FFFFEA 		b	.L198
 3359              	.L204:
 3360 1cb0 FC1D0000 		.word	.L202
 3361 1cb4 FC1D0000 		.word	.L202
 3362 1cb8 FC1D0000 		.word	.L202
 3363 1cbc FC1D0000 		.word	.L202
 3364 1cc0 FC1D0000 		.word	.L202
 3365 1cc4 2C1D0000 		.word	.L203
 3366 1cc8 2C1D0000 		.word	.L203
 3367 1ccc 2C1D0000 		.word	.L203
 3368 1cd0 2C1D0000 		.word	.L203
 3369 1cd4 2C1D0000 		.word	.L203
 3370              	.L268:
 3371              		.align	2
 3372              	.L267:
 3373 1cd8 00000000 		.word	.LANCHOR1
 3374 1cdc 00000000 		.word	bRequest
 3375 1ce0 DC030000 		.word	.LC23
 3376 1ce4 5C000000 		.word	.LANCHOR0+92
 3377 1ce8 01000100 		.word	65537
 3378 1cec FF00FF00 		.word	16711935
 3379 1cf0 DC020000 		.word	.LC18
 3380 1cf4 18030000 		.word	.LC19
 3381 1cf8 4C000000 		.word	.LANCHOR0+76
 3382 1cfc 40030000 		.word	.LC20
 3383 1d00 74030000 		.word	.LC21
 3384 1d04 AC030000 		.word	.LC22
 3385 1d08 817F807F 		.word	2139127681
 3386 1d0c 00000000 		.word	.LANCHOR2
 3387 1d10 01FF00FF 		.word	-16711935
 3388 1d14 98070000 		.word	1944
 3389 1d18 78020000 		.word	.LC16
 3390 1d1c A4020000 		.word	.LC17
 3391 1d20 00000000 		.word	.LANCHOR1
 3392 1d24 00000000 		.word	cmdQu
 3393 1d28 00000000 		.word	.LANCHOR0
 3394              	.L203:
 3395              	.LVL282:
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 3396              		.loc 1 603 0
 3397 1d2c 28401FE5 		ldr	r4, .L267+52
 601:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 3398              		.loc 1 601 0
 3399 1d30 8330A0E1 		mov	r3, r3, asl #1
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 3400              		.loc 1 603 0
 3401 1d34 B33094E1 		ldrh	r3, [r4, r3]
 3402 1d38 38E01FE5 		ldr	lr, .L267+48
 3403 1d3c 030263E0 		rsb	r0, r3, r3, asl #4
 3404 1d40 80C0A0E1 		mov	ip, r0, asl #1
 3405 1d44 9C1ECEE0 		smull	r1, lr, ip, lr
 3406 1d48 CC1FA0E1 		mov	r1, ip, asr #31
 604:../uvc.c      **** 		if(NumLn > 1944)
 3407              		.loc 1 604 0
 3408 1d4c 40201FE5 		ldr	r2, .L267+60
 603:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 3409              		.loc 1 603 0
 3410 1d50 4E6461E0 		rsb	r6, r1, lr, asr #8
 3411 1d54 0698A0E1 		mov	r9, r6, asl #16
 3412 1d58 29C8A0E1 		mov	ip, r9, lsr #16
 3413              	.LVL283:
 604:../uvc.c      **** 		if(NumLn > 1944)
 3414              		.loc 1 604 0
 3415 1d5c 02005CE1 		cmp	ip, r2
 605:../uvc.c      **** 			NumLn =1944;
 3416              		.loc 1 605 0
 3417 1d60 02C0A081 		movhi	ip, r2
 3418              	.LVL284:
 604:../uvc.c      **** 		if(NumLn > 1944)
 3419              		.loc 1 604 0
 3420 1d64 0100008A 		bhi	.L207
 607:../uvc.c      **** 			NumLn = 8;
 3421              		.loc 1 607 0
 3422 1d68 07005CE3 		cmp	ip, #7
 3423 1d6c 08C0A093 		movls	ip, #8
 3424              	.L207:
 3425              	.LVL285:
 608:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 3426              		.loc 1 608 0
 3427 1d70 AC21A0E1 		mov	r2, ip, lsr #3
 3428 1d74 FF6002E2 		and	r6, r2, #255
 3429              	.LVL286:
 610:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 3430              		.loc 1 610 0
 3431 1d78 0400A0E3 		mov	r0, #4
 3432 1d7c 6C101FE5 		ldr	r1, .L267+64
 3433 1d80 14209DE5 		ldr	r2, [sp, #20]
 3434 1d84 00C08DE5 		str	ip, [sp, #0]
 3435 1d88 04608DE5 		str	r6, [sp, #4]
 3436 1d8c FEFFFFEB 		bl	CyU3PDebugPrint
 3437              	.LVL287:
 3438              	.L206:
 3439              	.LBE63:
 3440              	.LBE62:
 923:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3441              		.loc 1 923 0
 3442 1d90 74401FE5 		ldr	r4, .L267+76
 3443 1d94 0010E0E3 		mvn	r1, #0
 3444 1d98 1C0094E5 		ldr	r0, [r4, #28]
 3445 1d9c FEFFFFEB 		bl	_txe_mutex_get
 924:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
 3446              		.loc 1 924 0
 3447 1da0 0190A0E3 		mov	r9, #1
 3448 1da4 00C0A0E3 		mov	ip, #0
 3449 1da8 0820A0E1 		mov	r2, r8
 3450 1dac 0730A0E1 		mov	r3, r7
 3451 1db0 1010A0E3 		mov	r1, #16
 3452 1db4 0400A0E1 		mov	r0, r4
 3453 1db8 00128DE8 		stmia	sp, {r9, ip}	@ phole stm
 927:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
 3454              		.loc 1 927 0
 3455 1dbc 8080A0E3 		mov	r8, #128
 3456              	.LVL288:
 924:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
 3457              		.loc 1 924 0
 3458 1dc0 FEFFFFEB 		bl	cmdSet
 3459              	.LVL289:
 927:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
 3460              		.loc 1 927 0
 3461 1dc4 0A20A0E1 		mov	r2, sl
 3462 1dc8 0730A0E1 		mov	r3, r7
 3463 1dcc 1010A0E3 		mov	r1, #16
 3464 1dd0 0400A0E1 		mov	r0, r4
 3465 1dd4 00038DE8 		stmia	sp, {r8, r9}	@ phole stm
 3466 1dd8 FEFFFFEB 		bl	cmdSet
 3467              	.LVL290:
 929:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
 3468              		.loc 1 929 0
 3469 1ddc 0730A0E1 		mov	r3, r7
 3470 1de0 0400A0E1 		mov	r0, r4
 3471 1de4 0270A0E3 		mov	r7, #2
 3472              	.LVL291:
 3473 1de8 1010A0E3 		mov	r1, #16
 3474 1dec 1220A0E3 		mov	r2, #18
 3475 1df0 C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 3476 1df4 FEFFFFEB 		bl	cmdSet
 3477              	.LVL292:
 3478 1df8 ECFEFFEA 		b	.L255
 3479              	.LVL293:
 3480              	.L202:
 3481              	.LBB65:
 3482              	.LBB64:
 585:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 3483              		.loc 1 585 0
 3484 1dfc 8300A0E1 		mov	r0, r3, asl #1
 3485 1e00 FC301FE5 		ldr	r3, .L267+52
 587:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 3486              		.loc 1 587 0
 3487 1e04 FCC01FE5 		ldr	ip, .L267+56
 585:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 3488              		.loc 1 585 0
 3489 1e08 B03093E1 		ldrh	r3, [r3, r0]
 3490              	.LVL294:
 588:../uvc.c      **** 		if(NumLn > 1944)
 3491              		.loc 1 588 0
 3492 1e0c 00911FE5 		ldr	r9, .L267+60
 587:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 3493              		.loc 1 587 0
 3494 1e10 930C8CE0 		umull	r0, ip, r3, ip
 3495 1e14 ACE4A0E1 		mov	lr, ip, lsr #9
 3496 1e18 0E126EE0 		rsb	r1, lr, lr, asl #4
 3497 1e1c 8168A0E1 		mov	r6, r1, asl #17
 3498 1e20 26C8A0E1 		mov	ip, r6, lsr #16
 3499              	.LVL295:
 588:../uvc.c      **** 		if(NumLn > 1944)
 3500              		.loc 1 588 0
 3501 1e24 09005CE1 		cmp	ip, r9
 589:../uvc.c      **** 			NumLn =1944;
 3502              		.loc 1 589 0
 3503 1e28 09C0A081 		movhi	ip, r9
 3504              	.LVL296:
 588:../uvc.c      **** 		if(NumLn > 1944)
 3505              		.loc 1 588 0
 3506 1e2c 0100008A 		bhi	.L205
 591:../uvc.c      **** 			NumLn = 8;
 3507              		.loc 1 591 0
 3508 1e30 07005CE3 		cmp	ip, #7
 3509 1e34 08C0A093 		movls	ip, #8
 3510              	.L205:
 3511              	.LVL297:
 592:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 3512              		.loc 1 592 0
 3513 1e38 AC41A0E1 		mov	r4, ip, lsr #3
 3514 1e3c FF6004E2 		and	r6, r4, #255
 3515              	.LVL298:
 594:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 3516              		.loc 1 594 0
 3517 1e40 30111FE5 		ldr	r1, .L267+64
 3518 1e44 14209DE5 		ldr	r2, [sp, #20]
 3519 1e48 0400A0E3 		mov	r0, #4
 3520 1e4c 00C08DE5 		str	ip, [sp, #0]
 3521 1e50 04608DE5 		str	r6, [sp, #4]
 3522 1e54 FEFFFFEB 		bl	CyU3PDebugPrint
 3523              	.LVL299:
 3524 1e58 CCFFFFEA 		b	.L206
 3525              	.LVL300:
 3526              	.L262:
 3527              	.LBE64:
 3528              	.LBE65:
 689:../uvc.c      **** 						if(sendData >= 3){
 3529              		.loc 1 689 0
 3530 1e5c 020054E3 		cmp	r4, #2
 3531 1e60 3100008A 		bhi	.L266
 3532              	.LVL301:
 3533              	.L155:
 694:../uvc.c      **** 						sendData += 4;
 3534              		.loc 1 694 0
 3535 1e64 04E084E2 		add	lr, r4, #4
 3536 1e68 FF400EE2 		and	r4, lr, #255
 3537              	.LVL302:
 3538 1e6c 19FDFFEA 		b	.L154
 3539              	.LVL303:
 3540              	.L263:
1187:../uvc.c      **** 			                       switch (setRes)
 3541              		.loc 1 1187 0
 3542 1e70 7D10D1E5 		ldrb	r1, [r1, #125]	@ zero_extendqisi2
 3543 1e74 020051E3 		cmp	r1, #2
 3544 1e78 4A00000A 		beq	.L223
 3545 1e7c 030051E3 		cmp	r1, #3
 3546 1e80 3C00000A 		beq	.L224
 3547 1e84 010051E3 		cmp	r1, #1
 3548 1e88 79FEFF1A 		bne	.L221
1190:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3549              		.loc 1 1190 0
 3550 1e8c 582093E5 		ldr	r2, [r3, #88]
 3551              	.LVL304:
 3552 1e90 0100A0E1 		mov	r0, r1
 3553 1e94 000052E3 		cmp	r2, #0
 3554 1e98 2F1081E2 		add	r1, r1, #47
 3555 1e9c E420A003 		moveq	r2, #228
 3556 1ea0 6420A013 		movne	r2, #100
 3557 1ea4 5230A0E3 		mov	r3, #82
 3558 1ea8 FEFFFFEB 		bl	SensorSetIrisControl
1191:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3559              		.loc 1 1191 0
 3560 1eac 7D0FA0E3 		mov	r0, #500
 3561 1eb0 FEFFFFEB 		bl	_tx_thread_sleep
1193:../uvc.c      **** 			                         		break;
 3562              		.loc 1 1193 0
 3563 1eb4 6EFEFFEA 		b	.L221
 3564              	.LVL305:
 3565              	.L264:
1217:../uvc.c      **** 								 if(Data0 < 3){
 3566              		.loc 1 1217 0
 3567 1eb8 020053E3 		cmp	r3, #2
1218:../uvc.c      **** 					 				 Data0 += 4;
 3568              		.loc 1 1218 0
 3569 1ebc 04708392 		addls	r7, r3, #4
 3570 1ec0 FF700792 		andls	r7, r7, #255
1217:../uvc.c      **** 								 if(Data0 < 3){
 3571              		.loc 1 1217 0
 3572 1ec4 ADFEFF9A 		bls	.L228
1220:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3573              		.loc 1 1220 0
 3574 1ec8 0400A0E3 		mov	r0, #4
 3575 1ecc B8111FE5 		ldr	r1, .L267+68
 3576 1ed0 14309DE5 		ldr	r3, [sp, #20]
 3577 1ed4 FEFFFFEB 		bl	CyU3PDebugPrint
 3578              	.LVL306:
1221:../uvc.c      **** 									Data0 = 4; //set to default.
 3579              		.loc 1 1221 0
 3580 1ed8 0470A0E3 		mov	r7, #4
 3581 1edc A7FEFFEA 		b	.L228
 3582              	.LVL307:
 3583              	.L211:
 985:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3584              		.loc 1 985 0
 3585 1ee0 0A20A0E1 		mov	r2, sl
 3586 1ee4 0730A0E1 		mov	r3, r7
 3587 1ee8 80C0A0E3 		mov	ip, #128
 3588 1eec 00E0A0E3 		mov	lr, #0
 3589 1ef0 1B10A0E3 		mov	r1, #27
 3590 1ef4 D8011FE5 		ldr	r0, .L267+76
 3591 1ef8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3592 1efc FEFFFFEB 		bl	cmdSet
 3593              	.LVL308:
 987:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 3594              		.loc 1 987 0
 3595 1f00 0730A0E1 		mov	r3, r7
 3596 1f04 14709DE5 		ldr	r7, [sp, #20]
 3597              	.LVL309:
 3598 1f08 01C0A0E3 		mov	ip, #1
 3599 1f0c 1B10A0E3 		mov	r1, #27
 3600 1f10 0820A0E1 		mov	r2, r8
 3601 1f14 F8011FE5 		ldr	r0, .L267+76
 3602 1f18 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3603 1f1c FEFFFFEB 		bl	cmdSet
 3604              	.LVL310:
 3605 1f20 0FFFFFEA 		b	.L210
 3606              	.LVL311:
 3607              	.L253:
 3608 1f24 04021FE5 		ldr	r0, .L267+80
 3609 1f28 D9FCFFEA 		b	.L152
 3610              	.LVL312:
 3611              	.L266:
 690:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3612              		.loc 1 690 0
 3613 1f2c 0430A0E1 		mov	r3, r4
 3614 1f30 0400A0E3 		mov	r0, #4
 3615 1f34 20121FE5 		ldr	r1, .L267+68
 3616 1f38 FEFFFFEB 		bl	CyU3PDebugPrint
 3617              	.LVL313:
 692:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3618              		.loc 1 692 0
 3619 1f3c 24C21FE5 		ldr	ip, .L267+72
 3620 1f40 0060A0E3 		mov	r6, #0
 691:../uvc.c      **** 							sendData = 0; //set back to default
 3621              		.loc 1 691 0
 3622 1f44 0640A0E1 		mov	r4, r6
 692:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3623              		.loc 1 692 0
 3624 1f48 2D64CCE5 		strb	r6, [ip, #1069]
 3625 1f4c C4FFFFEA 		b	.L155
 3626              	.LVL314:
 3627              	.L265:
 960:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3628              		.loc 1 960 0
 3629 1f50 18E09DE5 		ldr	lr, [sp, #24]
 3630 1f54 0730A0E1 		mov	r3, r7
 3631 1f58 1910A0E3 		mov	r1, #25
 3632 1f5c 0070A0E3 		mov	r7, #0
 3633              	.LVL315:
 3634 1f60 0920A0E1 		mov	r2, r9
 3635 1f64 48021FE5 		ldr	r0, .L267+76
 3636 1f68 00E08DE5 		str	lr, [sp, #0]
 3637 1f6c 04708DE5 		str	r7, [sp, #4]
 3638 1f70 FEFFFFEB 		bl	cmdSet
 3639              	.LVL316:
 3640 1f74 D5FEFFEA 		b	.L209
 3641              	.LVL317:
 3642              	.L224:
1200:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3643              		.loc 1 1200 0
 3644 1f78 582093E5 		ldr	r2, [r3, #88]
 3645              	.LVL318:
 3646 1f7c 8C74D6E5 		ldrb	r7, [r6, #1164]	@ zero_extendqisi2
 3647              	.LVL319:
 3648 1f80 000052E3 		cmp	r2, #0
 3649 1f84 C420A003 		moveq	r2, #196
 3650 1f88 4420A013 		movne	r2, #68
 3651 1f8c 3010A0E3 		mov	r1, #48
 3652 1f90 072082E1 		orr	r2, r2, r7
 3653 1f94 5230A0E3 		mov	r3, #82
 3654 1f98 FEFFFFEB 		bl	SensorSetIrisControl
1201:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3655              		.loc 1 1201 0
 3656 1f9c 7D0FA0E3 		mov	r0, #500
 3657 1fa0 FEFFFFEB 		bl	_tx_thread_sleep
1203:../uvc.c      **** 			                         		break;
 3658              		.loc 1 1203 0
 3659 1fa4 32FEFFEA 		b	.L221
 3660              	.LVL320:
 3661              	.L223:
1195:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3662              		.loc 1 1195 0
 3663 1fa8 582093E5 		ldr	r2, [r3, #88]
 3664              	.LVL321:
 3665 1fac 3010A0E3 		mov	r1, #48
 3666 1fb0 000052E3 		cmp	r2, #0
 3667 1fb4 D420A003 		moveq	r2, #212
 3668 1fb8 5420A013 		movne	r2, #84
 3669 1fbc 5230A0E3 		mov	r3, #82
 3670 1fc0 FEFFFFEB 		bl	SensorSetIrisControl
1196:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3671              		.loc 1 1196 0
 3672 1fc4 7D0FA0E3 		mov	r0, #500
 3673 1fc8 FEFFFFEB 		bl	_tx_thread_sleep
1198:../uvc.c      **** 			                         		break;
 3674              		.loc 1 1198 0
 3675 1fcc 28FEFFEA 		b	.L221
 3676              	.LVL322:
 3677              	.L237:
 621:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3678              		.loc 1 621 0
 3679 1fd0 0030A0E3 		mov	r3, #0
 3680 1fd4 63FDFFEA 		b	.L245
 3681              	.LVL323:
 3682              	.L231:
 3683 1fd8 B8021FE5 		ldr	r0, .L267+80
 3684 1fdc 0030A0E3 		mov	r3, #0
 3685 1fe0 A4FCFFEA 		b	.L244
 3686              		.cfi_endproc
 3687              	.LFE3:
 3689              		.align	2
 3690              		.global	CTControlHandle
 3692              	CTControlHandle:
 3693              	.LFB4:
1259:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3694              		.loc 1 1259 0
 3695              		.cfi_startproc
 3696              		@ args = 0, pretend = 0, frame = 64
 3697              		@ frame_needed = 0, uses_anonymous_args = 0
 3698              	.LVL324:
 3699 1fe4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3700              	.LCFI17:
 3701              		.cfi_def_cfa_offset 36
1278:../uvc.c      ****     reqData = bRequest;
 3702              		.loc 1 1278 0
 3703 1fe8 60A99FE5 		ldr	sl, .L354
 3704              		.cfi_offset 14, -4
 3705              		.cfi_offset 11, -8
 3706              		.cfi_offset 10, -12
 3707              		.cfi_offset 9, -16
 3708              		.cfi_offset 8, -20
 3709              		.cfi_offset 7, -24
 3710              		.cfi_offset 6, -28
 3711              		.cfi_offset 5, -32
 3712              		.cfi_offset 4, -36
1270:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3713              		.loc 1 1270 0
 3714 1fec 60899FE5 		ldr	r8, .L354+4
1278:../uvc.c      ****     reqData = bRequest;
 3715              		.loc 1 1278 0
 3716 1ff0 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1270:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3717              		.loc 1 1270 0
 3718 1ff4 8090A0E1 		mov	r9, r0, asl #1
 3719 1ff8 002089E0 		add	r2, r9, r0
 3720 1ffc 822188E0 		add	r2, r8, r2, asl #3
1280:../uvc.c      ****     switch (bRequest)
 3721              		.loc 1 1280 0
 3722 2000 830055E3 		cmp	r5, #131
1259:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3723              		.loc 1 1259 0
 3724 2004 5CD04DE2 		sub	sp, sp, #92
 3725              	.LCFI18:
 3726              		.cfi_def_cfa_offset 128
1259:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3727              		.loc 1 1259 0
 3728 2008 0060A0E1 		mov	r6, r0
1270:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3729              		.loc 1 1270 0
 3730 200c DF34D2E5 		ldrb	r3, [r2, #1247]	@ zero_extendqisi2
 3731              	.LVL325:
1271:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3732              		.loc 1 1271 0
 3733 2010 D0B4D2E5 		ldrb	fp, [r2, #1232]	@ zero_extendqisi2
 3734              	.LVL326:
1273:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3735              		.loc 1 1273 0
 3736 2014 D274D2E5 		ldrb	r7, [r2, #1234]	@ zero_extendqisi2
 3737              	.LVL327:
1280:../uvc.c      ****     switch (bRequest)
 3738              		.loc 1 1280 0
 3739 2018 7600000A 		beq	.L274
 3740 201c 2100009A 		bls	.L349
 3741 2020 850055E3 		cmp	r5, #133
 3742 2024 5900000A 		beq	.L276
 3743 2028 4E00003A 		bcc	.L275
 3744 202c 860055E3 		cmp	r5, #134
 3745 2030 8000000A 		beq	.L277
 3746 2034 870055E3 		cmp	r5, #135
 3747 2038 7600000A 		beq	.L350
 3748              	.L270:
1487:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3749              		.loc 1 1487 0
 3750 203c 0000A0E3 		mov	r0, #0
 3751              	.LVL328:
 3752 2040 0110A0E3 		mov	r1, #1
 3753 2044 0020A0E1 		mov	r2, r0
 3754 2048 FEFFFFEB 		bl	CyU3PUsbStall
 3755              	.LVL329:
 3756 204c 04499FE5 		ldr	r4, .L354+8
1488:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3757              		.loc 1 1488 0
 3758 2050 0620A0E1 		mov	r2, r6
 3759 2054 0400A0E3 		mov	r0, #4
 3760 2058 FC189FE5 		ldr	r1, .L354+12
 3761 205c 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3762 2060 FEFFFFEB 		bl	CyU3PDebugPrint
1489:../uvc.c      **** 			  break;
 3763              		.loc 1 1489 0
 3764 2064 FFC0A0E3 		mov	ip, #255
 3765 2068 0C60A0E1 		mov	r6, ip
 3766 206c 0C80A0E1 		mov	r8, ip
 3767              	.LVL330:
 3768              	.L280:
1493:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3769              		.loc 1 1493 0
 3770 2070 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3771 2074 08C08DE5 		str	ip, [sp, #8]
 3772 2078 E0189FE5 		ldr	r1, .L354+16
 3773 207c FFC0A0E3 		mov	ip, #255
 3774 2080 0520A0E1 		mov	r2, r5
 3775 2084 0830A0E1 		mov	r3, r8
 3776 2088 0400A0E3 		mov	r0, #4
 3777 208c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3778 2090 0CC08DE5 		str	ip, [sp, #12]
 3779 2094 10E08DE5 		str	lr, [sp, #16]
 3780 2098 14708DE5 		str	r7, [sp, #20]
 3781 209c FEFFFFEB 		bl	CyU3PDebugPrint
1494:../uvc.c      **** }
 3782              		.loc 1 1494 0
 3783 20a0 5CD08DE2 		add	sp, sp, #92
 3784 20a4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3785              	.LVL331:
 3786              	.L349:
1280:../uvc.c      ****     switch (bRequest)
 3787              		.loc 1 1280 0
 3788 20a8 810055E3 		cmp	r5, #129
 3789 20ac 4200000A 		beq	.L272
 3790 20b0 1100009A 		bls	.L351
1309:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3791              		.loc 1 1309 0
 3792 20b4 9C489FE5 		ldr	r4, .L354+8
 3793 20b8 D314D2E5 		ldrb	r1, [r2, #1235]	@ zero_extendqisi2
1310:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3794              		.loc 1 1310 0
 3795 20bc D464D2E5 		ldrb	r6, [r2, #1236]	@ zero_extendqisi2
1311:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3796              		.loc 1 1311 0
 3797 20c0 0A0050E3 		cmp	r0, #10
1309:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3798              		.loc 1 1309 0
 3799 20c4 5C10C4E5 		strb	r1, [r4, #92]
1310:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3800              		.loc 1 1310 0
 3801 20c8 5D60C4E5 		strb	r6, [r4, #93]
1311:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3802              		.loc 1 1311 0
 3803 20cc 2C00000A 		beq	.L348
 3804              	.LVL332:
 3805              	.L287:
1345:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3806              		.loc 1 1345 0
 3807 20d0 00E0A0E3 		mov	lr, #0
 3808 20d4 5EE0C4E5 		strb	lr, [r4, #94]
 3809              	.L288:
1346:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3810              		.loc 1 1346 0
 3811 20d8 0030A0E3 		mov	r3, #0
1347:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3812              		.loc 1 1347 0
 3813 20dc 0700A0E1 		mov	r0, r7
 3814              	.LVL333:
 3815 20e0 7C189FE5 		ldr	r1, .L354+20
1349:../uvc.c      **** 			  break;
 3816              		.loc 1 1349 0
 3817 20e4 FF60A0E3 		mov	r6, #255
1346:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3818              		.loc 1 1346 0
 3819 20e8 5F30C4E5 		strb	r3, [r4, #95]
1349:../uvc.c      **** 			  break;
 3820              		.loc 1 1349 0
 3821 20ec 0680A0E1 		mov	r8, r6
1347:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3822              		.loc 1 1347 0
 3823 20f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3824              	.LVL334:
 3825 20f4 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1349:../uvc.c      **** 			  break;
 3826              		.loc 1 1349 0
 3827 20f8 DCFFFFEA 		b	.L280
 3828              	.LVL335:
 3829              	.L351:
1280:../uvc.c      ****     switch (bRequest)
 3830              		.loc 1 1280 0
 3831 20fc 010055E3 		cmp	r5, #1
 3832 2100 CDFFFF1A 		bne	.L270
1351:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3833              		.loc 1 1351 0
 3834 2104 4C489FE5 		ldr	r4, .L354+8
 3835 2108 56208DE2 		add	r2, sp, #86
 3836 210c 2000A0E3 		mov	r0, #32
 3837              	.LVL336:
 3838 2110 5C1084E2 		add	r1, r4, #92
 3839 2114 2C308DE5 		str	r3, [sp, #44]
 3840 2118 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3841              	.LVL337:
1353:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3842              		.loc 1 1353 0
 3843 211c 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1354:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3844              		.loc 1 1354 0
 3845 2120 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1357:../uvc.c      **** 			  switch(CtrlID)
 3846              		.loc 1 1357 0
 3847 2124 012046E2 		sub	r2, r6, #1
1353:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3848              		.loc 1 1353 0
 3849 2128 30008DE5 		str	r0, [sp, #48]
 3850              	.LVL338:
1354:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3851              		.loc 1 1354 0
 3852 212c 34C08DE5 		str	ip, [sp, #52]
 3853              	.LVL339:
1357:../uvc.c      **** 			  switch(CtrlID)
 3854              		.loc 1 1357 0
 3855 2130 2C309DE5 		ldr	r3, [sp, #44]
 3856 2134 090052E3 		cmp	r2, #9
 3857 2138 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3858 213c 550100EA 		b	.L289
 3859              	.L294:
 3860 2140 54260000 		.word	.L290
 3861 2144 98260000 		.word	.L289
 3862 2148 64230000 		.word	.L291
 3863 214c 98260000 		.word	.L289
 3864 2150 98260000 		.word	.L289
 3865 2154 98260000 		.word	.L289
 3866 2158 E0220000 		.word	.L292
 3867 215c 98260000 		.word	.L289
 3868 2160 98260000 		.word	.L289
 3869 2164 64220000 		.word	.L293
 3870              	.LVL340:
 3871              	.L275:
1327:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3872              		.loc 1 1327 0
 3873 2168 E8479FE5 		ldr	r4, .L354+8
 3874 216c D784D2E5 		ldrb	r8, [r2, #1239]	@ zero_extendqisi2
1328:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3875              		.loc 1 1328 0
 3876 2170 D824D2E5 		ldrb	r2, [r2, #1240]	@ zero_extendqisi2
1329:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3877              		.loc 1 1329 0
 3878 2174 0A0050E3 		cmp	r0, #10
1327:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3879              		.loc 1 1327 0
 3880 2178 5C80C4E5 		strb	r8, [r4, #92]
1328:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3881              		.loc 1 1328 0
 3882 217c 5D20C4E5 		strb	r2, [r4, #93]
1329:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3883              		.loc 1 1329 0
 3884 2180 D2FFFF1A 		bne	.L287
 3885              	.LVL341:
 3886              	.L348:
1344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3887              		.loc 1 1344 0 discriminator 1
 3888 2184 0110A0E3 		mov	r1, #1
 3889 2188 5E10C4E5 		strb	r1, [r4, #94]
 3890 218c D1FFFFEA 		b	.L288
 3891              	.LVL342:
 3892              	.L276:
1284:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3893              		.loc 1 1284 0
 3894 2190 C0479FE5 		ldr	r4, .L354+8
1285:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3895              		.loc 1 1285 0
 3896 2194 0030A0E3 		mov	r3, #0
 3897              	.LVL343:
1286:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3898              		.loc 1 1286 0
 3899 2198 0200A0E3 		mov	r0, #2
 3900              	.LVL344:
 3901 219c 5C1084E2 		add	r1, r4, #92
1288:../uvc.c      **** 			  break;
 3902              		.loc 1 1288 0
 3903 21a0 FF60A0E3 		mov	r6, #255
1284:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3904              		.loc 1 1284 0
 3905 21a4 5C70C4E5 		strb	r7, [r4, #92]
1285:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3906              		.loc 1 1285 0
 3907 21a8 5D30C4E5 		strb	r3, [r4, #93]
1288:../uvc.c      **** 			  break;
 3908              		.loc 1 1288 0
 3909 21ac 0680A0E1 		mov	r8, r6
1286:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3910              		.loc 1 1286 0
 3911 21b0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3912              	.LVL345:
 3913 21b4 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1288:../uvc.c      **** 			  break;
 3914              		.loc 1 1288 0
 3915 21b8 ACFFFFEA 		b	.L280
 3916              	.LVL346:
 3917              	.L272:
1294:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3918              		.loc 1 1294 0
 3919 21bc 94479FE5 		ldr	r4, .L354+8
 3920 21c0 DDA4D2E5 		ldrb	sl, [r2, #1245]	@ zero_extendqisi2
1295:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3921              		.loc 1 1295 0
 3922 21c4 DEC4D2E5 		ldrb	ip, [r2, #1246]	@ zero_extendqisi2
1296:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3923              		.loc 1 1296 0
 3924 21c8 0080A0E3 		mov	r8, #0
1302:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3925              		.loc 1 1302 0
 3926 21cc 0700A0E1 		mov	r0, r7
 3927              	.LVL347:
 3928 21d0 5C1084E2 		add	r1, r4, #92
1307:../uvc.c      **** 			  break;
 3929              		.loc 1 1307 0
 3930 21d4 FF60A0E3 		mov	r6, #255
1295:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3931              		.loc 1 1295 0
 3932 21d8 5DC0C4E5 		strb	ip, [r4, #93]
1296:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3933              		.loc 1 1296 0
 3934 21dc 5E80C4E5 		strb	r8, [r4, #94]
1297:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3935              		.loc 1 1297 0
 3936 21e0 5F80C4E5 		strb	r8, [r4, #95]
 3937              	.LVL348:
1294:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3938              		.loc 1 1294 0
 3939 21e4 5CA0C4E5 		strb	sl, [r4, #92]
1307:../uvc.c      **** 			  break;
 3940              		.loc 1 1307 0
 3941 21e8 0680A0E1 		mov	r8, r6
1302:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3942              		.loc 1 1302 0
 3943 21ec FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3944              	.LVL349:
 3945 21f0 0AC0A0E1 		mov	ip, sl
1307:../uvc.c      **** 			  break;
 3946              		.loc 1 1307 0
 3947 21f4 9DFFFFEA 		b	.L280
 3948              	.LVL350:
 3949              	.L274:
1318:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3950              		.loc 1 1318 0
 3951 21f8 58479FE5 		ldr	r4, .L354+8
 3952 21fc D534D2E5 		ldrb	r3, [r2, #1237]	@ zero_extendqisi2
 3953              	.LVL351:
1319:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3954              		.loc 1 1319 0
 3955 2200 D6E4D2E5 		ldrb	lr, [r2, #1238]	@ zero_extendqisi2
1320:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3956              		.loc 1 1320 0
 3957 2204 0A0050E3 		cmp	r0, #10
1318:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3958              		.loc 1 1318 0
 3959 2208 5C30C4E5 		strb	r3, [r4, #92]
1319:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3960              		.loc 1 1319 0
 3961 220c 5DE0C4E5 		strb	lr, [r4, #93]
1320:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3962              		.loc 1 1320 0
 3963 2210 AEFFFF1A 		bne	.L287
 3964 2214 DAFFFFEA 		b	.L348
 3965              	.LVL352:
 3966              	.L350:
1342:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3967              		.loc 1 1342 0
 3968 2218 38479FE5 		ldr	r4, .L354+8
 3969 221c DB64D2E5 		ldrb	r6, [r2, #1243]	@ zero_extendqisi2
1343:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3970              		.loc 1 1343 0
 3971 2220 DCC4D2E5 		ldrb	ip, [r2, #1244]	@ zero_extendqisi2
1344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3972              		.loc 1 1344 0
 3973 2224 0A0050E3 		cmp	r0, #10
1342:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3974              		.loc 1 1342 0
 3975 2228 5C60C4E5 		strb	r6, [r4, #92]
1343:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3976              		.loc 1 1343 0
 3977 222c 5DC0C4E5 		strb	ip, [r4, #93]
1344:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3978              		.loc 1 1344 0
 3979 2230 A6FFFF1A 		bne	.L287
 3980 2234 D2FFFFEA 		b	.L348
 3981              	.L277:
1336:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3982              		.loc 1 1336 0
 3983 2238 18479FE5 		ldr	r4, .L354+8
 3984 223c D904D2E5 		ldrb	r0, [r2, #1241]	@ zero_extendqisi2
 3985              	.LVL353:
 3986 2240 0410A0E1 		mov	r1, r4
 3987 2244 5C00E1E5 		strb	r0, [r1, #92]!
1340:../uvc.c      **** 			  break;
 3988              		.loc 1 1340 0
 3989 2248 FF60A0E3 		mov	r6, #255
1337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3990              		.loc 1 1337 0
 3991 224c 0100A0E3 		mov	r0, #1
 3992 2250 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3993              	.LVL354:
1340:../uvc.c      **** 			  break;
 3994              		.loc 1 1340 0
 3995 2254 0680A0E1 		mov	r8, r6
1337:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3996              		.loc 1 1337 0
 3997 2258 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1340:../uvc.c      **** 			  break;
 3998              		.loc 1 1340 0
 3999 225c 0170A0E3 		mov	r7, #1
 4000 2260 82FFFFEA 		b	.L280
 4001              	.LVL355:
 4002              	.L293:
1466:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4003              		.loc 1 1466 0
 4004 2264 FC669FE5 		ldr	r6, .L354+24
 4005 2268 0010E0E3 		mvn	r1, #0
 4006 226c 1C0096E5 		ldr	r0, [r6, #28]
 4007 2270 2C308DE5 		str	r3, [sp, #44]
 4008 2274 FEFFFFEB 		bl	_txe_mutex_get
1467:../uvc.c      **** 					  if(getData == 1)
 4009              		.loc 1 1467 0
 4010 2278 30E09DE5 		ldr	lr, [sp, #48]
 4011 227c 2C309DE5 		ldr	r3, [sp, #44]
 4012 2280 01005EE3 		cmp	lr, #1
 4013 2284 A901000A 		beq	.L352
1469:../uvc.c      **** 					  else if(getData == 0xff)
 4014              		.loc 1 1469 0
 4015 2288 FF005EE3 		cmp	lr, #255
 4016 228c 9E01000A 		beq	.L353
1472:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 4017              		.loc 1 1472 0
 4018 2290 0080A0E3 		mov	r8, #0
 4019 2294 0600A0E1 		mov	r0, r6
 4020 2298 1710A0E3 		mov	r1, #23
 4021 229c 0B20A0E1 		mov	r2, fp
 4022 22a0 00808DE5 		str	r8, [sp, #0]
 4023 22a4 04808DE5 		str	r8, [sp, #4]
 4024 22a8 FEFFFFEB 		bl	cmdSet
 4025              	.L346:
1475:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4026              		.loc 1 1475 0
 4027 22ac 1C0096E5 		ldr	r0, [r6, #28]
 4028 22b0 FEFFFFEB 		bl	_txe_mutex_put
1477:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4029              		.loc 1 1477 0
 4030 22b4 30809DE5 		ldr	r8, [sp, #48]
 4031 22b8 34609DE5 		ldr	r6, [sp, #52]
 4032 22bc 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4033 22c0 0400A0E3 		mov	r0, #4
 4034 22c4 A0169FE5 		ldr	r1, .L354+28
 4035 22c8 0820A0E1 		mov	r2, r8
 4036 22cc 0630A0E1 		mov	r3, r6
 4037 22d0 00C08DE5 		str	ip, [sp, #0]
 4038 22d4 FEFFFFEB 		bl	CyU3PDebugPrint
1478:../uvc.c      **** 					  break;
 4039              		.loc 1 1478 0
 4040 22d8 FFC0A0E3 		mov	ip, #255
 4041 22dc 63FFFFEA 		b	.L280
 4042              	.LVL356:
 4043              	.L292:
1443:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4044              		.loc 1 1443 0
 4045 22e0 F584D8E5 		ldrb	r8, [r8, #1269]	@ zero_extendqisi2
 4046 22e4 010058E3 		cmp	r8, #1
 4047 22e8 08005813 		cmpne	r8, #8
 4048 22ec 0000A013 		movne	r0, #0
 4049 22f0 0100A003 		moveq	r0, #1
 4050 22f4 8001001A 		bne	.L343
 4051              	.LVL357:
1446:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4052              		.loc 1 1446 0
 4053 22f8 68869FE5 		ldr	r8, .L354+24
 4054 22fc 0010E0E3 		mvn	r1, #0
 4055 2300 1C0098E5 		ldr	r0, [r8, #28]
 4056 2304 2C308DE5 		str	r3, [sp, #44]
 4057 2308 FEFFFFEB 		bl	_txe_mutex_get
1447:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4058              		.loc 1 1447 0
 4059 230c 30A09DE5 		ldr	sl, [sp, #48]
 4060 2310 1610A0E3 		mov	r1, #22
 4061 2314 0B20A0E1 		mov	r2, fp
 4062 2318 2C309DE5 		ldr	r3, [sp, #44]
 4063 231c 00C0A0E3 		mov	ip, #0
 4064 2320 0800A0E1 		mov	r0, r8
 4065 2324 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4066 2328 FEFFFFEB 		bl	cmdSet
1448:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4067              		.loc 1 1448 0
 4068 232c 1C0098E5 		ldr	r0, [r8, #28]
 4069 2330 FEFFFFEB 		bl	_txe_mutex_put
1451:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4070              		.loc 1 1451 0
 4071 2334 18069FE5 		ldr	r0, .L354+4
1452:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4072              		.loc 1 1452 0
 4073 2338 34209DE5 		ldr	r2, [sp, #52]
1451:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4074              		.loc 1 1451 0
 4075 233c 061089E0 		add	r1, r9, r6
 4076 2340 813180E0 		add	r3, r0, r1, asl #3
1453:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4077              		.loc 1 1453 0
 4078 2344 0160A0E3 		mov	r6, #1
1451:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4079              		.loc 1 1451 0
 4080 2348 DDA4C3E5 		strb	sl, [r3, #1245]
1452:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4081              		.loc 1 1452 0
 4082 234c DE24C3E5 		strb	r2, [r3, #1246]
1453:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4083              		.loc 1 1453 0
 4084 2350 E064C3E5 		strb	r6, [r3, #1248]
 4085              	.LVL358:
 4086              	.L344:
1455:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4087              		.loc 1 1455 0
 4088 2354 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4089 2358 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1460:../uvc.c      **** 					  break;
 4090              		.loc 1 1460 0
 4091 235c FFC0A0E3 		mov	ip, #255
 4092 2360 42FFFFEA 		b	.L280
 4093              	.LVL359:
 4094              	.L291:
1409:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4095              		.loc 1 1409 0
 4096 2364 F504D8E5 		ldrb	r0, [r8, #1269]	@ zero_extendqisi2
 4097 2368 010050E3 		cmp	r0, #1
 4098 236c 04005013 		cmpne	r0, #4
 4099 2370 5C01001A 		bne	.L301
1408:../uvc.c      **** 					  value = (value << 8)|Data0;
 4100              		.loc 1 1408 0
 4101 2374 30109DE5 		ldr	r1, [sp, #48]
 4102 2378 34E09DE5 		ldr	lr, [sp, #52]
 4103 237c 0E2481E1 		orr	r2, r1, lr, asl #8
1410:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4104              		.loc 1 1410 0
 4105 2380 F90052E3 		cmp	r2, #249
 4106 2384 5701008A 		bhi	.L301
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4107              		.loc 1 1415 0
 4108 2388 C8A042E2 		sub	sl, r2, #200
 4109 238c 0AC8A0E1 		mov	ip, sl, asl #16
 4110 2390 3CC08DE5 		str	ip, [sp, #60]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4111              		.loc 1 1417 0
 4112 2394 27A062E2 		rsb	sl, r2, #39
 4113 2398 38A08DE5 		str	sl, [sp, #56]
 4114 239c 3CA09DE5 		ldr	sl, [sp, #60]
 4115 23a0 C81062E2 		rsb	r1, r2, #200
 4116 23a4 C80052E3 		cmp	r2, #200
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4117              		.loc 1 1415 0
 4118 23a8 640042E2 		sub	r0, r2, #100
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4119              		.loc 1 1417 0
 4120 23ac 0118A0E1 		mov	r1, r1, asl #16
 4121 23b0 64E062E2 		rsb	lr, r2, #100
 4122 23b4 2A18A081 		movhi	r1, sl, lsr #16
 4123 23b8 2118A091 		movls	r1, r1, lsr #16
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4124              		.loc 1 1415 0
 4125 23bc 00C8A0E1 		mov	ip, r0, asl #16
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4126              		.loc 1 1417 0
 4127 23c0 640052E3 		cmp	r2, #100
 4128 23c4 0E08A0E1 		mov	r0, lr, asl #16
 4129 23c8 2C08A081 		movhi	r0, ip, lsr #16
 4130 23cc 38C09DE5 		ldr	ip, [sp, #56]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4131              		.loc 1 1415 0
 4132 23d0 14A042E2 		sub	sl, r2, #20
 4133 23d4 38A08DE5 		str	sl, [sp, #56]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4134              		.loc 1 1417 0
 4135 23d8 2008A091 		movls	r0, r0, lsr #16
 4136 23dc 14A062E2 		rsb	sl, r2, #20
 4137 23e0 3CA08DE5 		str	sl, [sp, #60]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4138              		.loc 1 1415 0
 4139 23e4 27E042E2 		sub	lr, r2, #39
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4140              		.loc 1 1417 0
 4141 23e8 000051E1 		cmp	r1, r0
 4142 23ec 01A0A031 		movcc	sl, r1
 4143 23f0 00A0A021 		movcs	sl, r0
 4144 23f4 0CC8A0E1 		mov	ip, ip, asl #16
 4145 23f8 270052E3 		cmp	r2, #39
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4146              		.loc 1 1415 0
 4147 23fc 0EE8A0E1 		mov	lr, lr, asl #16
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4148              		.loc 1 1417 0
 4149 2400 2CE8A091 		movls	lr, ip, lsr #16
 4150 2404 64C59FE5 		ldr	ip, .L354+32
 4151 2408 20A08DE5 		str	sl, [sp, #32]
 4152 240c 01A06CE0 		rsb	sl, ip, r1
 4153 2410 2EE8A081 		movhi	lr, lr, lsr #16
 4154 2414 00C07AE2 		rsbs	ip, sl, #0
 4155 2418 0AC0ACE0 		adc	ip, ip, sl
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4156              		.loc 1 1415 0
 4157 241c 38A09DE5 		ldr	sl, [sp, #56]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4158              		.loc 1 1417 0
 4159 2420 44C08DE5 		str	ip, [sp, #68]
 4160              	.LVL360:
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4161              		.loc 1 1415 0
 4162 2424 0AC8A0E1 		mov	ip, sl, asl #16
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4163              		.loc 1 1417 0
 4164 2428 3CA09DE5 		ldr	sl, [sp, #60]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4165              		.loc 1 1415 0
 4166 242c 4CC08DE5 		str	ip, [sp, #76]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4167              		.loc 1 1417 0
 4168 2430 0AC8A0E1 		mov	ip, sl, asl #16
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4169              		.loc 1 1415 0
 4170 2434 0AA042E2 		sub	sl, r2, #10
 4171 2438 48A08DE5 		str	sl, [sp, #72]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4172              		.loc 1 1417 0
 4173 243c 20A09DE5 		ldr	sl, [sp, #32]
 4174 2440 3CC08DE5 		str	ip, [sp, #60]
 4175 2444 0A005EE1 		cmp	lr, sl
 4176 2448 0EA0A031 		movcc	sl, lr
 4177 244c 0AC062E2 		rsb	ip, r2, #10
 4178 2450 40C08DE5 		str	ip, [sp, #64]
 4179 2454 38A08DE5 		str	sl, [sp, #56]
 4180 2458 3CC09DE5 		ldr	ip, [sp, #60]
 4181 245c 4CA09DE5 		ldr	sl, [sp, #76]
 4182 2460 140052E3 		cmp	r2, #20
 4183 2464 2CA8A091 		movls	sl, ip, lsr #16
 4184 2468 2AA8A081 		movhi	sl, sl, lsr #16
 4185 246c 44C09DE5 		ldr	ip, [sp, #68]
 4186 2470 010050E1 		cmp	r0, r1
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4187              		.loc 1 1415 0
 4188 2474 48109DE5 		ldr	r1, [sp, #72]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4189              		.loc 1 1417 0
 4190 2478 01C0A033 		movcc	ip, #1
 4191 247c 3CA08DE5 		str	sl, [sp, #60]
 4192 2480 24C08DE5 		str	ip, [sp, #36]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4193              		.loc 1 1415 0
 4194 2484 01A8A0E1 		mov	sl, r1, asl #16
 4195 2488 05C042E2 		sub	ip, r2, #5
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4196              		.loc 1 1417 0
 4197 248c 051062E2 		rsb	r1, r2, #5
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4198              		.loc 1 1415 0
 4199 2490 48A08DE5 		str	sl, [sp, #72]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4200              		.loc 1 1417 0
 4201 2494 40009DE5 		ldr	r0, [sp, #64]
 4202 2498 38A09DE5 		ldr	sl, [sp, #56]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4203              		.loc 1 1415 0
 4204 249c 40C08DE5 		str	ip, [sp, #64]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4205              		.loc 1 1417 0
 4206 24a0 3CC09DE5 		ldr	ip, [sp, #60]
 4207 24a4 4C108DE5 		str	r1, [sp, #76]
 4208 24a8 48109DE5 		ldr	r1, [sp, #72]
 4209 24ac 0008A0E1 		mov	r0, r0, asl #16
 4210 24b0 0A005CE1 		cmp	ip, sl
 4211 24b4 0AC0A021 		movcs	ip, sl
 4212 24b8 0A0052E3 		cmp	r2, #10
 4213 24bc 20A09DE5 		ldr	sl, [sp, #32]
 4214 24c0 2108A081 		movhi	r0, r1, lsr #16
 4215 24c4 2008A091 		movls	r0, r0, lsr #16
 4216 24c8 48008DE5 		str	r0, [sp, #72]
 4217 24cc 24009DE5 		ldr	r0, [sp, #36]
 4218 24d0 0A005EE1 		cmp	lr, sl
 4219 24d4 0200A033 		movcc	r0, #2
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4220              		.loc 1 1415 0
 4221 24d8 02E042E2 		sub	lr, r2, #2
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4222              		.loc 1 1417 0
 4223 24dc 44C08DE5 		str	ip, [sp, #68]
 4224 24e0 24008DE5 		str	r0, [sp, #36]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4225              		.loc 1 1415 0
 4226 24e4 40C09DE5 		ldr	ip, [sp, #64]
 4227 24e8 1CE08DE5 		str	lr, [sp, #28]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4228              		.loc 1 1417 0
 4229 24ec 44009DE5 		ldr	r0, [sp, #68]
 4230 24f0 48E09DE5 		ldr	lr, [sp, #72]
 4231 24f4 4C109DE5 		ldr	r1, [sp, #76]
 4232 24f8 02A062E2 		rsb	sl, r2, #2
 4233 24fc 00005EE1 		cmp	lr, r0
 4234 2500 00E0A021 		movcs	lr, r0
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4235              		.loc 1 1415 0
 4236 2504 0CC8A0E1 		mov	ip, ip, asl #16
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4237              		.loc 1 1417 0
 4238 2508 050052E3 		cmp	r2, #5
 4239 250c 40A08DE5 		str	sl, [sp, #64]
 4240 2510 0118A0E1 		mov	r1, r1, asl #16
 4241 2514 3CA09DE5 		ldr	sl, [sp, #60]
 4242 2518 2C18A081 		movhi	r1, ip, lsr #16
 4243 251c 38C09DE5 		ldr	ip, [sp, #56]
 4244 2520 4CE08DE5 		str	lr, [sp, #76]
 4245 2524 24009DE5 		ldr	r0, [sp, #36]
 4246 2528 40E09DE5 		ldr	lr, [sp, #64]
 4247 252c 2118A091 		movls	r1, r1, lsr #16
 4248 2530 0C005AE1 		cmp	sl, ip
 4249 2534 20108DE5 		str	r1, [sp, #32]
 4250 2538 0300A033 		movcc	r0, #3
 4251 253c 38008DE5 		str	r0, [sp, #56]
 4252 2540 4CA09DE5 		ldr	sl, [sp, #76]
 4253 2544 0E08A0E1 		mov	r0, lr, asl #16
 4254 2548 20E09DE5 		ldr	lr, [sp, #32]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4255              		.loc 1 1415 0
 4256 254c 1C109DE5 		ldr	r1, [sp, #28]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4257              		.loc 1 1417 0
 4258 2550 0A005EE1 		cmp	lr, sl
 4259 2554 0AE0A021 		movcs	lr, sl
 4260 2558 44C09DE5 		ldr	ip, [sp, #68]
 4261 255c 48A09DE5 		ldr	sl, [sp, #72]
 4262 2560 020052E3 		cmp	r2, #2
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4263              		.loc 1 1415 0
 4264 2564 0118A0E1 		mov	r1, r1, asl #16
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4265              		.loc 1 1417 0
 4266 2568 2018A091 		movls	r1, r0, lsr #16
 4267 256c 38009DE5 		ldr	r0, [sp, #56]
 4268 2570 2118A081 		movhi	r1, r1, lsr #16
 4269 2574 0C005AE1 		cmp	sl, ip
 4270 2578 0400A033 		movcc	r0, #4
 4271 257c 40008DE5 		str	r0, [sp, #64]
1415:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4272              		.loc 1 1415 0
 4273 2580 010042E2 		sub	r0, r2, #1
 4274 2584 38008DE5 		str	r0, [sp, #56]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4275              		.loc 1 1417 0
 4276 2588 4CA09DE5 		ldr	sl, [sp, #76]
 4277 258c 20009DE5 		ldr	r0, [sp, #32]
 4278 2590 01C062E2 		rsb	ip, r2, #1
 4279 2594 3CC08DE5 		str	ip, [sp, #60]
 4280 2598 0A0050E1 		cmp	r0, sl
1424:../uvc.c      **** 						  shutter = shutter+index;
 4281              		.loc 1 1424 0
 4282 259c 38A09DE5 		ldr	sl, [sp, #56]
 4283 25a0 3C009DE5 		ldr	r0, [sp, #60]
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4284              		.loc 1 1417 0
 4285 25a4 40C09DE5 		ldr	ip, [sp, #64]
 4286 25a8 05C0A033 		movcc	ip, #5
1424:../uvc.c      **** 						  shutter = shutter+index;
 4287              		.loc 1 1424 0
 4288 25ac 010052E3 		cmp	r2, #1
 4289 25b0 0028A091 		movls	r2, r0, asl #16
 4290 25b4 0A28A081 		movhi	r2, sl, asl #16
 4291 25b8 0E0051E1 		cmp	r1, lr
 4292 25bc 01A0A031 		movcc	sl, r1
 4293 25c0 0EA0A021 		movcs	sl, lr
1417:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4294              		.loc 1 1417 0
 4295 25c4 0E0051E1 		cmp	r1, lr
 4296 25c8 0C10A021 		movcs	r1, ip
 4297 25cc 0610A033 		movcc	r1, #6
1424:../uvc.c      **** 						  shutter = shutter+index;
 4298              		.loc 1 1424 0
 4299 25d0 22085AE1 		cmp	sl, r2, lsr #16
1427:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4300              		.loc 1 1427 0
 4301 25d4 8CA39FE5 		ldr	sl, .L354+24
1424:../uvc.c      **** 						  shutter = shutter+index;
 4302              		.loc 1 1424 0
 4303 25d8 0120A091 		movls	r2, r1
 4304 25dc 0720A083 		movhi	r2, #7
 4305 25e0 012082E2 		add	r2, r2, #1
 4306 25e4 FFE002E2 		and	lr, r2, #255
1427:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4307              		.loc 1 1427 0
 4308 25e8 0010E0E3 		mvn	r1, #0
 4309 25ec 1C009AE5 		ldr	r0, [sl, #28]
1424:../uvc.c      **** 						  shutter = shutter+index;
 4310              		.loc 1 1424 0
 4311 25f0 38E08DE5 		str	lr, [sp, #56]
 4312              	.LVL361:
1427:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4313              		.loc 1 1427 0
 4314 25f4 2C308DE5 		str	r3, [sp, #44]
 4315 25f8 FEFFFFEB 		bl	_txe_mutex_get
1428:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 4316              		.loc 1 1428 0
 4317 25fc 38C09DE5 		ldr	ip, [sp, #56]
 4318 2600 0310A0E3 		mov	r1, #3
 4319 2604 0B20A0E1 		mov	r2, fp
 4320 2608 2C309DE5 		ldr	r3, [sp, #44]
 4321 260c 00C08DE5 		str	ip, [sp, #0]
 4322 2610 0A00A0E1 		mov	r0, sl
 4323 2614 00C0A0E3 		mov	ip, #0
 4324 2618 04C08DE5 		str	ip, [sp, #4]
 4325 261c FEFFFFEB 		bl	cmdSet
1429:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4326              		.loc 1 1429 0
 4327 2620 1C009AE5 		ldr	r0, [sl, #28]
 4328 2624 FEFFFFEB 		bl	_txe_mutex_put
1432:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4329              		.loc 1 1432 0
 4330 2628 30009DE5 		ldr	r0, [sp, #48]
1433:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4331              		.loc 1 1433 0
 4332 262c 34C09DE5 		ldr	ip, [sp, #52]
1435:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4333              		.loc 1 1435 0
 4334 2630 38309DE5 		ldr	r3, [sp, #56]
1432:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4335              		.loc 1 1432 0
 4336 2634 061089E0 		add	r1, r9, r6
 4337 2638 816188E0 		add	r6, r8, r1, asl #3
1434:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4338              		.loc 1 1434 0
 4339 263c 0120A0E3 		mov	r2, #1
1432:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4340              		.loc 1 1432 0
 4341 2640 DD04C6E5 		strb	r0, [r6, #1245]
1433:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4342              		.loc 1 1433 0
 4343 2644 DEC4C6E5 		strb	ip, [r6, #1246]
1434:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4344              		.loc 1 1434 0
 4345 2648 E024C6E5 		strb	r2, [r6, #1248]
1435:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4346              		.loc 1 1435 0
 4347 264c 0D33C8E5 		strb	r3, [r8, #781]
 4348 2650 3FFFFFEA 		b	.L344
 4349              	.LVL362:
 4350              	.L290:
1362:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4351              		.loc 1 1362 0
 4352 2654 062089E0 		add	r2, r9, r6
 4353 2658 826188E0 		add	r6, r8, r2, asl #3
1363:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4354              		.loc 1 1363 0
 4355 265c 0110A0E3 		mov	r1, #1
1366:../uvc.c      **** 		  		    switch (getData){
 4356              		.loc 1 1366 0
 4357 2660 01E040E2 		sub	lr, r0, #1
1362:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4358              		.loc 1 1362 0
 4359 2664 DD04C6E5 		strb	r0, [r6, #1245]
1363:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4360              		.loc 1 1363 0
 4361 2668 E014C6E5 		strb	r1, [r6, #1248]
 4362              	.LVL363:
1366:../uvc.c      **** 		  		    switch (getData){
 4363              		.loc 1 1366 0
 4364 266c 07005EE3 		cmp	lr, #7
 4365 2670 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 4366 2674 970000EA 		b	.L295
 4367              	.L300:
 4368 2678 6C280000 		.word	.L296
 4369 267c D0270000 		.word	.L297
 4370 2680 D8280000 		.word	.L295
 4371 2684 6C270000 		.word	.L298
 4372 2688 D8280000 		.word	.L295
 4373 268c D8280000 		.word	.L295
 4374 2690 D8280000 		.word	.L295
 4375 2694 CC260000 		.word	.L299
 4376              	.LVL364:
 4377              	.L289:
1482:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4378              		.loc 1 1482 0
 4379 2698 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1481:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4380              		.loc 1 1481 0
 4381 269c 30A09DE5 		ldr	sl, [sp, #48]
 4382 26a0 069089E0 		add	r9, r9, r6
 4383 26a4 89E188E0 		add	lr, r8, r9, asl #3
1482:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4384              		.loc 1 1482 0
 4385 26a8 0620A0E1 		mov	r2, r6
 4386 26ac 0400A0E3 		mov	r0, #4
 4387 26b0 BC129FE5 		ldr	r1, .L354+36
1481:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4388              		.loc 1 1481 0
 4389 26b4 DDA4CEE5 		strb	sl, [lr, #1245]
1482:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4390              		.loc 1 1482 0
 4391 26b8 FEFFFFEB 		bl	CyU3PDebugPrint
1483:../uvc.c      **** 			  		 break;
 4392              		.loc 1 1483 0
 4393 26bc FFC0A0E3 		mov	ip, #255
 4394 26c0 0C60A0E1 		mov	r6, ip
 4395 26c4 0C80A0E1 		mov	r8, ip
 4396 26c8 68FEFFEA 		b	.L280
 4397              	.LVL365:
 4398              	.L299:
1385:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4399              		.loc 1 1385 0
 4400 26cc 94629FE5 		ldr	r6, .L354+24
1383:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4401              		.loc 1 1383 0
 4402 26d0 00A0A0E3 		mov	sl, #0
1385:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4403              		.loc 1 1385 0
 4404 26d4 1C0096E5 		ldr	r0, [r6, #28]
1383:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4405              		.loc 1 1383 0
 4406 26d8 0DA3C8E5 		strb	sl, [r8, #781]
 4407              	.LVL366:
1385:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4408              		.loc 1 1385 0
 4409 26dc 0010E0E3 		mvn	r1, #0
 4410 26e0 2C308DE5 		str	r3, [sp, #44]
 4411 26e4 FEFFFFEB 		bl	_txe_mutex_get
1386:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4412              		.loc 1 1386 0
 4413 26e8 0B20A0E1 		mov	r2, fp
 4414 26ec 2C309DE5 		ldr	r3, [sp, #44]
 4415 26f0 1010A0E3 		mov	r1, #16
 4416 26f4 0600A0E1 		mov	r0, r6
 4417 26f8 00A08DE5 		str	sl, [sp, #0]
 4418 26fc 04A08DE5 		str	sl, [sp, #4]
 4419 2700 FEFFFFEB 		bl	cmdSet
1387:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4420              		.loc 1 1387 0
 4421 2704 1C0096E5 		ldr	r0, [r6, #28]
 4422 2708 FEFFFFEB 		bl	_txe_mutex_put
 4423              	.LVL367:
 4424              	.LBB74:
 4425              	.LBB75:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4426              		.loc 1 566 0
 4427 270c 0010E0E3 		mvn	r1, #0
 4428 2710 1C0096E5 		ldr	r0, [r6, #28]
 4429 2714 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4430              		.loc 1 567 0
 4431 2718 0180A0E3 		mov	r8, #1
 4432 271c 1410A0E3 		mov	r1, #20
 4433 2720 2720A0E3 		mov	r2, #39
 4434 2724 3030A0E3 		mov	r3, #48
 4435 2728 0600A0E1 		mov	r0, r6
 4436 272c 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4437 2730 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4438              		.loc 1 568 0
 4439 2734 02C0A0E3 		mov	ip, #2
 4440 2738 1510A0E3 		mov	r1, #21
 4441 273c 2520A0E3 		mov	r2, #37
 4442 2740 3030A0E3 		mov	r3, #48
 4443 2744 0600A0E1 		mov	r0, r6
 4444 2748 00C08DE5 		str	ip, [sp, #0]
 4445 274c 04A08DE5 		str	sl, [sp, #4]
 4446 2750 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4447              		.loc 1 569 0
 4448 2754 1C0096E5 		ldr	r0, [r6, #28]
 4449 2758 FEFFFFEB 		bl	_txe_mutex_put
 4450              	.LBE75:
 4451              	.LBE74:
1389:../uvc.c      **** 							break;
 4452              		.loc 1 1389 0
 4453 275c FFC0A0E3 		mov	ip, #255
 4454 2760 0C60A0E1 		mov	r6, ip
 4455 2764 0880A0E3 		mov	r8, #8
 4456 2768 40FEFFEA 		b	.L280
 4457              	.LVL368:
 4458              	.L298:
 4459              	.LBB76:
 4460              	.LBB77:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4461              		.loc 1 566 0
 4462 276c F4819FE5 		ldr	r8, .L354+24
 4463 2770 0010E0E3 		mvn	r1, #0
 4464 2774 1C0098E5 		ldr	r0, [r8, #28]
 4465 2778 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4466              		.loc 1 567 0
 4467 277c 0060A0E3 		mov	r6, #0
 4468 2780 1410A0E3 		mov	r1, #20
 4469 2784 2720A0E3 		mov	r2, #39
 4470 2788 3030A0E3 		mov	r3, #48
 4471 278c 0800A0E1 		mov	r0, r8
 4472 2790 00608DE5 		str	r6, [sp, #0]
 4473 2794 04608DE5 		str	r6, [sp, #4]
 4474 2798 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4475              		.loc 1 568 0
 4476 279c 1510A0E3 		mov	r1, #21
 4477 27a0 2520A0E3 		mov	r2, #37
 4478 27a4 3030A0E3 		mov	r3, #48
 4479 27a8 0800A0E1 		mov	r0, r8
 4480 27ac 00608DE5 		str	r6, [sp, #0]
 4481 27b0 04608DE5 		str	r6, [sp, #4]
 4482 27b4 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4483              		.loc 1 569 0
 4484 27b8 1C0098E5 		ldr	r0, [r8, #28]
 4485 27bc FEFFFFEB 		bl	_txe_mutex_put
 4486 27c0 FFC0A0E3 		mov	ip, #255
 4487 27c4 0C60A0E1 		mov	r6, ip
 4488 27c8 0480A0E3 		mov	r8, #4
 4489 27cc 27FEFFEA 		b	.L280
 4490              	.LVL369:
 4491              	.L297:
 4492              	.LBE77:
 4493              	.LBE76:
1373:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4494              		.loc 1 1373 0
 4495 27d0 90A19FE5 		ldr	sl, .L354+24
1371:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4496              		.loc 1 1371 0
 4497 27d4 0060A0E3 		mov	r6, #0
 4498 27d8 0D63C8E5 		strb	r6, [r8, #781]
 4499              	.LVL370:
1373:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4500              		.loc 1 1373 0
 4501 27dc 0010E0E3 		mvn	r1, #0
 4502 27e0 1C009AE5 		ldr	r0, [sl, #28]
 4503 27e4 2C308DE5 		str	r3, [sp, #44]
 4504 27e8 FEFFFFEB 		bl	_txe_mutex_get
1374:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4505              		.loc 1 1374 0
 4506 27ec 0B20A0E1 		mov	r2, fp
 4507 27f0 2C309DE5 		ldr	r3, [sp, #44]
 4508 27f4 1010A0E3 		mov	r1, #16
 4509 27f8 0A00A0E1 		mov	r0, sl
 4510 27fc 00608DE5 		str	r6, [sp, #0]
 4511 2800 04608DE5 		str	r6, [sp, #4]
 4512 2804 FEFFFFEB 		bl	cmdSet
1375:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4513              		.loc 1 1375 0
 4514 2808 1C009AE5 		ldr	r0, [sl, #28]
 4515 280c FEFFFFEB 		bl	_txe_mutex_put
 4516              	.LVL371:
 4517              	.LBB78:
 4518              	.LBB79:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4519              		.loc 1 566 0
 4520 2810 0010E0E3 		mvn	r1, #0
 4521 2814 1C009AE5 		ldr	r0, [sl, #28]
 4522 2818 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4523              		.loc 1 567 0
 4524 281c 1410A0E3 		mov	r1, #20
 4525 2820 2720A0E3 		mov	r2, #39
 4526 2824 3030A0E3 		mov	r3, #48
 4527 2828 0A00A0E1 		mov	r0, sl
 4528 282c 00608DE5 		str	r6, [sp, #0]
 4529 2830 04608DE5 		str	r6, [sp, #4]
 4530 2834 FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4531              		.loc 1 568 0
 4532 2838 1510A0E3 		mov	r1, #21
 4533 283c 2520A0E3 		mov	r2, #37
 4534 2840 3030A0E3 		mov	r3, #48
 4535 2844 0A00A0E1 		mov	r0, sl
 4536 2848 00608DE5 		str	r6, [sp, #0]
 4537 284c 04608DE5 		str	r6, [sp, #4]
 4538 2850 FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4539              		.loc 1 569 0
 4540 2854 1C009AE5 		ldr	r0, [sl, #28]
 4541 2858 FEFFFFEB 		bl	_txe_mutex_put
 4542 285c FFC0A0E3 		mov	ip, #255
 4543 2860 0C60A0E1 		mov	r6, ip
 4544 2864 0280A0E3 		mov	r8, #2
 4545 2868 00FEFFEA 		b	.L280
 4546              	.LVL372:
 4547              	.L296:
 4548              	.LBE79:
 4549              	.LBE78:
 4550              	.LBB80:
 4551              	.LBB81:
 566:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4552              		.loc 1 566 0
 4553 286c F4609FE5 		ldr	r6, .L354+24
 4554 2870 0010E0E3 		mvn	r1, #0
 4555 2874 1C0096E5 		ldr	r0, [r6, #28]
 4556 2878 FEFFFFEB 		bl	_txe_mutex_get
 567:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4557              		.loc 1 567 0
 4558 287c 0080A0E3 		mov	r8, #0
 4559 2880 01A0A0E3 		mov	sl, #1
 4560 2884 1410A0E3 		mov	r1, #20
 4561 2888 2720A0E3 		mov	r2, #39
 4562 288c 3030A0E3 		mov	r3, #48
 4563 2890 0600A0E1 		mov	r0, r6
 4564 2894 04808DE5 		str	r8, [sp, #4]
 4565 2898 00A08DE5 		str	sl, [sp, #0]
 4566 289c FEFFFFEB 		bl	cmdSet
 568:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4567              		.loc 1 568 0
 4568 28a0 02C0A0E3 		mov	ip, #2
 4569 28a4 1510A0E3 		mov	r1, #21
 4570 28a8 2520A0E3 		mov	r2, #37
 4571 28ac 3030A0E3 		mov	r3, #48
 4572 28b0 0600A0E1 		mov	r0, r6
 4573 28b4 00C08DE5 		str	ip, [sp, #0]
 4574 28b8 04808DE5 		str	r8, [sp, #4]
 4575 28bc FEFFFFEB 		bl	cmdSet
 569:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4576              		.loc 1 569 0
 4577 28c0 1C0096E5 		ldr	r0, [r6, #28]
 4578 28c4 FEFFFFEB 		bl	_txe_mutex_put
 4579              	.LBE81:
 4580              	.LBE80:
1369:../uvc.c      **** 							break;
 4581              		.loc 1 1369 0
 4582 28c8 FFC0A0E3 		mov	ip, #255
 4583 28cc 0C60A0E1 		mov	r6, ip
 4584 28d0 0A80A0E1 		mov	r8, sl
 4585 28d4 E5FDFFEA 		b	.L280
 4586              	.LVL373:
 4587              	.L295:
1366:../uvc.c      **** 		  		    switch (getData){
 4588              		.loc 1 1366 0
 4589 28d8 FFC0A0E3 		mov	ip, #255
 4590 28dc 0080A0E1 		mov	r8, r0
 4591 28e0 0C60A0E1 		mov	r6, ip
 4592 28e4 E1FDFFEA 		b	.L280
 4593              	.LVL374:
 4594              	.L301:
1437:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4595              		.loc 1 1437 0
 4596 28e8 0000A0E3 		mov	r0, #0
 4597 28ec 0110A0E3 		mov	r1, #1
 4598 28f0 0020A0E1 		mov	r2, r0
 4599 28f4 FEFFFFEB 		bl	CyU3PUsbStall
 4600              	.LVL375:
 4601 28f8 95FEFFEA 		b	.L344
 4602              	.LVL376:
 4603              	.L343:
1455:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4604              		.loc 1 1455 0
 4605 28fc 0110A0E3 		mov	r1, #1
 4606 2900 0020A0E1 		mov	r2, r0
 4607 2904 FEFFFFEB 		bl	CyU3PUsbStall
 4608 2908 91FEFFEA 		b	.L344
 4609              	.LVL377:
 4610              	.L353:
1470:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4611              		.loc 1 1470 0
 4612 290c 08E0A0E3 		mov	lr, #8
 4613 2910 00C0A0E3 		mov	ip, #0
 4614 2914 0600A0E1 		mov	r0, r6
 4615 2918 1710A0E3 		mov	r1, #23
 4616 291c 0B20A0E1 		mov	r2, fp
 4617 2920 00E08DE5 		str	lr, [sp, #0]
 4618 2924 04C08DE5 		str	ip, [sp, #4]
 4619 2928 FEFFFFEB 		bl	cmdSet
 4620 292c 5EFEFFEA 		b	.L346
 4621              	.L352:
1468:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4622              		.loc 1 1468 0
 4623 2930 0480A0E3 		mov	r8, #4
 4624 2934 00E0A0E3 		mov	lr, #0
 4625 2938 0600A0E1 		mov	r0, r6
 4626 293c 1710A0E3 		mov	r1, #23
 4627 2940 0B20A0E1 		mov	r2, fp
 4628 2944 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4629 2948 FEFFFFEB 		bl	cmdSet
 4630 294c 56FEFFEA 		b	.L346
 4631              	.L355:
 4632              		.align	2
 4633              	.L354:
 4634 2950 00000000 		.word	bRequest
 4635 2954 00000000 		.word	.LANCHOR1
 4636 2958 00000000 		.word	.LANCHOR0
 4637 295c 78040000 		.word	.LC26
 4638 2960 9C040000 		.word	.LC27
 4639 2964 5C000000 		.word	.LANCHOR0+92
 4640 2968 00000000 		.word	cmdQu
 4641 296c 2C040000 		.word	.LC24
 4642 2970 FFFF0000 		.word	65535
 4643 2974 54040000 		.word	.LC25
 4644              		.cfi_endproc
 4645              	.LFE4:
 4647              		.align	2
 4648              		.global	UVCAppEP0Thread_Entry
 4650              	UVCAppEP0Thread_Entry:
 4651              	.LFB25:
3629:../uvc.c      **** {
 4652              		.loc 1 3629 0
 4653              		.cfi_startproc
 4654              		@ args = 0, pretend = 0, frame = 24
 4655              		@ frame_needed = 0, uses_anonymous_args = 0
 4656              	.LVL378:
 4657 2978 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4658              	.LCFI19:
 4659              		.cfi_def_cfa_offset 36
 4660 297c BC4B9FE5 		ldr	r4, .L527
 4661              		.cfi_offset 14, -4
 4662              		.cfi_offset 11, -8
 4663              		.cfi_offset 10, -12
 4664              		.cfi_offset 9, -16
 4665              		.cfi_offset 8, -20
 4666              		.cfi_offset 7, -24
 4667              		.cfi_offset 6, -28
 4668              		.cfi_offset 5, -32
 4669              		.cfi_offset 4, -36
 4670 2980 BC6B9FE5 		ldr	r6, .L527+4
 4671 2984 BC8B9FE5 		ldr	r8, .L527+8
 4672 2988 BCAB9FE5 		ldr	sl, .L527+12
 4673 298c BCBB9FE5 		ldr	fp, .L527+16
 4674 2990 BC7B9FE5 		ldr	r7, .L527+20
 4675 2994 34D04DE2 		sub	sp, sp, #52
 4676              	.LCFI20:
 4677              		.cfi_def_cfa_offset 88
 4678              	.LVL379:
3651:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4679              		.loc 1 3651 0
 4680 2998 0450A0E1 		mov	r5, r4
 4681              	.LVL380:
 4682              	.L497:
 4683 299c 00C0E0E3 		mvn	ip, #0
 4684 29a0 980B9FE5 		ldr	r0, .L527
 4685 29a4 4C10A0E3 		mov	r1, #76
 4686 29a8 0120A0E3 		mov	r2, #1
 4687 29ac 28308DE2 		add	r3, sp, #40
 4688 29b0 00C08DE5 		str	ip, [sp, #0]
 4689 29b4 FEFFFFEB 		bl	_txe_event_flags_get
 4690 29b8 000050E3 		cmp	r0, #0
 4691 29bc 3000001A 		bne	.L357
3655:../uvc.c      ****             if (!isUsbConnected)
 4692              		.loc 1 3655 0
 4693 29c0 303095E5 		ldr	r3, [r5, #48]
 4694 29c4 000053E3 		cmp	r3, #0
 4695 29c8 8C00000A 		beq	.L516
 4696              	.L358:
3664:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4697              		.loc 1 3664 0
 4698 29cc 28309DE5 		ldr	r3, [sp, #40]
 4699 29d0 0C0013E3 		tst	r3, #12
 4700 29d4 7500001A 		bne	.L517
 4701              	.L359:
3671:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4702              		.loc 1 3671 0
 4703 29d8 040013E3 		tst	r3, #4
 4704 29dc 1C00000A 		beq	.L360
3673:../uvc.c      ****             	switch ((wIndex >> 8))
 4705              		.loc 1 3673 0
 4706 29e0 B0E0DBE1 		ldrh	lr, [fp, #0]
 4707 29e4 2E24A0E1 		mov	r2, lr, lsr #8
 4708 29e8 030052E3 		cmp	r2, #3
 4709 29ec 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4710 29f0 120000EA 		b	.L361
 4711              	.L366:
 4712 29f4 402A0000 		.word	.L361
 4713 29f8 302B0000 		.word	.L363
 4714 29fc 042A0000 		.word	.L364
 4715 2a00 6C2B0000 		.word	.L365
 4716              	.L364:
 4717              	.LBB96:
 4718              	.LBB100:
2889:../uvc.c      ****     switch (wValue)
 4719              		.loc 1 2889 0
 4720 2a04 B020DAE1 		ldrh	r2, [sl, #0]
 4721 2a08 060C52E3 		cmp	r2, #1536
 4722 2a0c 7202000A 		beq	.L372
 4723 2a10 D900008A 		bhi	.L378
 4724 2a14 030C52E3 		cmp	r2, #768
 4725 2a18 6B02000A 		beq	.L370
 4726 2a1c B101008A 		bhi	.L379
 4727 2a20 010C52E3 		cmp	r2, #256
 4728 2a24 9A02000A 		beq	.L368
 4729 2a28 020C52E3 		cmp	r2, #512
 4730 2a2c 9402000A 		beq	.L518
 4731              	.L381:
 4732              	.LBE100:
 4733              	.LBE96:
 4734              	.LBB105:
 4735              	.LBB110:
3021:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4736              		.loc 1 3021 0
 4737 2a30 201B9FE5 		ldr	r1, .L527+24
 4738 2a34 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4739 2a38 0400A0E3 		mov	r0, #4
 4740 2a3c FEFFFFEB 		bl	CyU3PDebugPrint
 4741              	.L361:
 4742              	.LBE110:
 4743              	.LBE105:
3694:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4744              		.loc 1 3694 0
 4745 2a40 0000A0E3 		mov	r0, #0
 4746 2a44 0110A0E3 		mov	r1, #1
 4747 2a48 0020A0E1 		mov	r2, r0
 4748 2a4c FEFFFFEB 		bl	CyU3PUsbStall
 4749 2a50 28309DE5 		ldr	r3, [sp, #40]
 4750              	.L360:
3699:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4751              		.loc 1 3699 0
 4752 2a54 080013E3 		tst	r3, #8
 4753 2a58 0700000A 		beq	.L424
3703:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4754              		.loc 1 3703 0
 4755 2a5c B030DBE1 		ldrh	r3, [fp, #0]
 4756 2a60 010053E3 		cmp	r3, #1
 4757 2a64 6B00000A 		beq	.L425
 4758              	.L426:
 4759              	.LBB116:
 4760              	.LBB120:
3618:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4761              		.loc 1 3618 0
 4762 2a68 0000A0E3 		mov	r0, #0
 4763 2a6c 0110A0E3 		mov	r1, #1
 4764 2a70 0020A0E1 		mov	r2, r0
 4765 2a74 FEFFFFEB 		bl	CyU3PUsbStall
 4766              	.L506:
 4767 2a78 28309DE5 		ldr	r3, [sp, #40]
 4768              	.L424:
 4769              	.LBE120:
 4770              	.LBE116:
3714:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4771              		.loc 1 3714 0
 4772 2a7c 400013E3 		tst	r3, #64
 4773 2a80 0100001A 		bne	.L519
 4774              	.L357:
3927:../uvc.c      ****         CyU3PThreadRelinquish ();
 4775              		.loc 1 3927 0
 4776 2a84 FEFFFFEB 		bl	_txe_thread_relinquish
3928:../uvc.c      ****     }
 4777              		.loc 1 3928 0
 4778 2a88 C3FFFFEA 		b	.L497
 4779              	.L519:
3719:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4780              		.loc 1 3719 0
 4781 2a8c 1800A0E3 		mov	r0, #24
 4782 2a90 24108DE2 		add	r1, sp, #36
 4783 2a94 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3776:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4784              		.loc 1 3776 0
 4785 2a98 BB36D6E5 		ldrb	r3, [r6, #1723]	@ zero_extendqisi2
 4786 2a9c 0F0053E3 		cmp	r3, #15
 4787 2aa0 9400000A 		beq	.L520
3803:../uvc.c      **** 				}else if(!snapButFlag){
 4788              		.loc 1 3803 0
 4789 2aa4 000053E3 		cmp	r3, #0
 4790 2aa8 F5FFFF1A 		bne	.L357
3805:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4791              		.loc 1 3805 0
 4792 2aac 002097E5 		ldr	r2, [r7, #0]
 4793 2ab0 0290A0E3 		mov	r9, #2
 4794 2ab4 0090C2E5 		strb	r9, [r2, #0]
3806:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4795              		.loc 1 3806 0
 4796 2ab8 001097E5 		ldr	r1, [r7, #0]
 4797 2abc 0190A0E3 		mov	r9, #1
 4798 2ac0 0190C1E5 		strb	r9, [r1, #1]
3807:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4799              		.loc 1 3807 0
 4800 2ac4 000097E5 		ldr	r0, [r7, #0]
3811:../uvc.c      **** 					interStabuf.size   = 1024;
 4801              		.loc 1 3811 0
 4802 2ac8 01CBA0E3 		mov	ip, #1024	@ movhi
3807:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4803              		.loc 1 3807 0
 4804 2acc 0230C0E5 		strb	r3, [r0, #2]
3808:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4805              		.loc 1 3808 0
 4806 2ad0 00E097E5 		ldr	lr, [r7, #0]
3817:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4807              		.loc 1 3817 0
 4808 2ad4 0010E0E3 		mvn	r1, #0
3808:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4809              		.loc 1 3808 0
 4810 2ad8 0390CEE5 		strb	r9, [lr, #3]
3810:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4811              		.loc 1 3810 0
 4812 2adc 002097E5 		ldr	r2, [r7, #0]
3814:../uvc.c      **** 					interStabuf.count = 4;
 4813              		.loc 1 3814 0
 4814 2ae0 04E0A0E3 		mov	lr, #4	@ movhi
3817:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4815              		.loc 1 3817 0
 4816 2ae4 700A9FE5 		ldr	r0, .L527+28
3810:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4817              		.loc 1 3810 0
 4818 2ae8 18208DE5 		str	r2, [sp, #24]
3811:../uvc.c      **** 					interStabuf.size   = 1024;
 4819              		.loc 1 3811 0
 4820 2aec BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
3812:../uvc.c      **** 					interStabuf.status = 0;
 4821              		.loc 1 3812 0
 4822 2af0 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3814:../uvc.c      **** 					interStabuf.count = 4;
 4823              		.loc 1 3814 0
 4824 2af4 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3817:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4825              		.loc 1 3817 0
 4826 2af8 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3820:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4827              		.loc 1 3820 0
 4828 2afc 580A9FE5 		ldr	r0, .L527+28
 4829 2b00 18108DE2 		add	r1, sp, #24
 4830 2b04 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4831              	.LVL381:
3822:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4832              		.loc 1 3822 0
 4833 2b08 002050E2 		subs	r2, r0, #0
 4834 2b0c 6C01001A 		bne	.L521
3828:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4835              		.loc 1 3828 0
 4836 2b10 3010A0E3 		mov	r1, #48
 4837 2b14 0920A0E1 		mov	r2, r9
 4838 2b18 0500A0E3 		mov	r0, #5
 4839              	.LVL382:
 4840 2b1c FEFFFFEB 		bl	SensorSetControl
3829:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4841              		.loc 1 3829 0
 4842 2b20 1C3A9FE5 		ldr	r3, .L527+4
 4843 2b24 BB96C3E5 		strb	r9, [r3, #1723]
3927:../uvc.c      ****         CyU3PThreadRelinquish ();
 4844              		.loc 1 3927 0
 4845 2b28 FEFFFFEB 		bl	_txe_thread_relinquish
 4846 2b2c 9AFFFFEA 		b	.L497
 4847              	.L363:
 4848              	.LBB124:
 4849              	.LBB111:
2964:../uvc.c      ****     switch (wValue)
 4850              		.loc 1 2964 0
 4851 2b30 B020DAE1 		ldrh	r2, [sl, #0]
 4852 2b34 060C52E3 		cmp	r2, #1536
 4853 2b38 4D02000A 		beq	.L387
 4854 2b3c 9900008A 		bhi	.L393
 4855 2b40 030C52E3 		cmp	r2, #768
 4856 2b44 4602000A 		beq	.L384
 4857 2b48 9201008A 		bhi	.L394
 4858 2b4c 010C52E3 		cmp	r2, #256
 4859 2b50 2D02000A 		beq	.L382
 4860 2b54 020C52E3 		cmp	r2, #512
 4861 2b58 B4FFFF1A 		bne	.L381
 4862              	.LVL383:
2972:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4863              		.loc 1 2972 0
 4864 2b5c 0100A0E3 		mov	r0, #1
 4865 2b60 FEFFFFEB 		bl	CTControlHandle
 4866              	.LVL384:
 4867 2b64 28309DE5 		ldr	r3, [sp, #40]
 4868 2b68 B9FFFFEA 		b	.L360
 4869              	.L365:
 4870              	.LBE111:
 4871              	.LBE124:
 4872              	.LBB125:
 4873              	.LBB131:
3189:../uvc.c      ****     switch (wValue)
 4874              		.loc 1 3189 0
 4875 2b6c B030DAE1 		ldrh	r3, [sl, #0]
 4876 2b70 090C53E3 		cmp	r3, #2304
 4877 2b74 2002000A 		beq	.L408
 4878 2b78 9200008A 		bhi	.L418
 4879 2b7c 010B53E3 		cmp	r3, #1024
 4880 2b80 1902000A 		beq	.L403
 4881 2b84 6801008A 		bhi	.L419
 4882 2b88 020C53E3 		cmp	r3, #512
 4883 2b8c FE01000A 		beq	.L401
 4884 2b90 030C53E3 		cmp	r3, #768
 4885 2b94 F801000A 		beq	.L402
 4886 2b98 010C53E3 		cmp	r3, #256
 4887 2b9c A7FFFF1A 		bne	.L361
 4888              	.LVL385:
3193:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4889              		.loc 1 3193 0
 4890 2ba0 1000A0E3 		mov	r0, #16
 4891 2ba4 FEFFFFEB 		bl	ControlHandle
 4892              	.LVL386:
 4893 2ba8 28309DE5 		ldr	r3, [sp, #40]
 4894 2bac A8FFFFEA 		b	.L360
 4895              	.L517:
 4896              	.LBE131:
 4897              	.LBE125:
3665:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4898              		.loc 1 3665 0
 4899 2bb0 B0C0DAE1 		ldrh	ip, [sl, #0]
 4900 2bb4 A4999FE5 		ldr	r9, .L527+32
 4901 2bb8 A4199FE5 		ldr	r1, .L527+36
 4902 2bbc 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4903 2bc0 08C08DE5 		str	ip, [sp, #8]
 4904 2bc4 B000DBE1 		ldrh	r0, [fp, #0]
 4905 2bc8 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4906 2bcc 0C008DE5 		str	r0, [sp, #12]
 4907 2bd0 B0C0D1E1 		ldrh	ip, [r1, #0]
 4908 2bd4 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4909 2bd8 04908DE5 		str	r9, [sp, #4]
 4910 2bdc 0400A0E3 		mov	r0, #4
 4911 2be0 80199FE5 		ldr	r1, .L527+40
 4912 2be4 0090A0E3 		mov	r9, #0
 4913 2be8 00E08DE5 		str	lr, [sp, #0]
 4914 2bec 10C08DE5 		str	ip, [sp, #16]
 4915 2bf0 14908DE5 		str	r9, [sp, #20]
 4916 2bf4 FEFFFFEB 		bl	CyU3PDebugPrint
 4917 2bf8 28309DE5 		ldr	r3, [sp, #40]
 4918 2bfc 75FFFFEA 		b	.L359
 4919              	.L516:
3657:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4920              		.loc 1 3657 0
 4921 2c00 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3658:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4922              		.loc 1 3658 0
 4923 2c04 000050E3 		cmp	r0, #0
3657:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4924              		.loc 1 3657 0
 4925 2c08 4800C5E5 		strb	r0, [r5, #72]
3660:../uvc.c      ****                     isUsbConnected = CyTrue;
 4926              		.loc 1 3660 0
 4927 2c0c 0100A013 		movne	r0, #1
 4928 2c10 30008515 		strne	r0, [r5, #48]
 4929 2c14 6CFFFFEA 		b	.L358
 4930              	.L425:
 4931              	.LVL387:
 4932              	.LBB137:
 4933              	.LBB119:
3290:../uvc.c      ****     switch (wValue)
 4934              		.loc 1 3290 0
 4935 2c18 B020DAE1 		ldrh	r2, [sl, #0]
 4936 2c1c 030C52E3 		cmp	r2, #768
 4937 2c20 DE00000A 		beq	.L429
 4938 2c24 0F00008A 		bhi	.L432
 4939 2c28 010C52E3 		cmp	r2, #256
 4940 2c2c 9700000A 		beq	.L427
 4941 2c30 020C52E3 		cmp	r2, #512
 4942 2c34 8BFFFF1A 		bne	.L426
3355:../uvc.c      ****             switch (bRequest)
 4943              		.loc 1 3355 0
 4944 2c38 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4945 2c3c 810053E3 		cmp	r3, #129
 4946 2c40 C001000A 		beq	.L484
 4947 2c44 E200008A 		bhi	.L447
 4948 2c48 010053E3 		cmp	r3, #1
 4949 2c4c 8201000A 		beq	.L522
 4950              	.L467:
3556:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4951              		.loc 1 3556 0
 4952 2c50 0000A0E3 		mov	r0, #0
 4953 2c54 0110A0E3 		mov	r1, #1
 4954 2c58 0020A0E1 		mov	r2, r0
 4955 2c5c FEFFFFEB 		bl	CyU3PUsbStall
 4956 2c60 28309DE5 		ldr	r3, [sp, #40]
 4957 2c64 84FFFFEA 		b	.L424
 4958              	.L432:
3290:../uvc.c      ****     switch (wValue)
 4959              		.loc 1 3290 0
 4960 2c68 010B52E3 		cmp	r2, #1024
 4961 2c6c 6100000A 		beq	.L430
 4962 2c70 050C52E3 		cmp	r2, #1280
 4963 2c74 7BFFFF1A 		bne	.L426
3563:../uvc.c      ****             	switch (bRequest)
 4964              		.loc 1 3563 0
 4965 2c78 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4966 2c7c 810052E3 		cmp	r2, #129
 4967 2c80 B001000A 		beq	.L484
 4968 2c84 5501008A 		bhi	.L487
 4969 2c88 010052E3 		cmp	r2, #1
 4970 2c8c 75FFFF1A 		bne	.L426
3588:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4971              		.loc 1 3588 0
 4972 2c90 2000A0E3 		mov	r0, #32
 4973 2c94 D0189FE5 		ldr	r1, .L527+44
 4974 2c98 2E208DE2 		add	r2, sp, #46
 4975 2c9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4976              	.LVL388:
3590:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4977              		.loc 1 3590 0
 4978 2ca0 000050E3 		cmp	r0, #0
 4979 2ca4 6601001A 		bne	.L489
3594:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4980              		.loc 1 3594 0
 4981 2ca8 0020A0E3 		mov	r2, #0
 4982 2cac 8C089FE5 		ldr	r0, .L527
 4983              	.LVL389:
 4984 2cb0 8010A0E3 		mov	r1, #128
 4985 2cb4 FEFFFFEB 		bl	_txe_event_flags_set
 4986              	.LVL390:
3595:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4987              		.loc 1 3595 0
 4988 2cb8 002050E2 		subs	r2, r0, #0
3601:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4989              		.loc 1 3601 0
 4990 2cbc 0F00E003 		mvneq	r0, #15
 4991              	.LVL391:
 4992 2cc0 3A00C505 		streqb	r0, [r5, #58]
3595:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4993              		.loc 1 3595 0
 4994 2cc4 0200000A 		beq	.L491
3597:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4995              		.loc 1 3597 0
 4996 2cc8 A0189FE5 		ldr	r1, .L527+48
 4997 2ccc 0400A0E3 		mov	r0, #4
 4998 2cd0 FEFFFFEB 		bl	CyU3PDebugPrint
 4999              	.LVL392:
 5000              	.L491:
3604:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5001              		.loc 1 3604 0
 5002 2cd4 81C0D4E5 		ldrb	ip, [r4, #129]	@ zero_extendqisi2
 5003 2cd8 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5004 2cdc BE22DDE1 		ldrh	r2, [sp, #46]
 5005              	.LVL393:
 5006 2ce0 0400A0E3 		mov	r0, #4
 5007 2ce4 88189FE5 		ldr	r1, .L527+52
 5008 2ce8 00C08DE5 		str	ip, [sp, #0]
 5009 2cec FEFFFFEB 		bl	CyU3PDebugPrint
 5010 2cf0 28309DE5 		ldr	r3, [sp, #40]
 5011 2cf4 60FFFFEA 		b	.L424
 5012              	.LVL394:
 5013              	.L520:
 5014              	.LBE119:
 5015              	.LBE137:
3778:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5016              		.loc 1 3778 0
 5017 2cf8 003097E5 		ldr	r3, [r7, #0]
 5018 2cfc 0290A0E3 		mov	r9, #2
 5019 2d00 0090C3E5 		strb	r9, [r3, #0]
3779:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5020              		.loc 1 3779 0
 5021 2d04 002097E5 		ldr	r2, [r7, #0]
 5022 2d08 0190A0E3 		mov	r9, #1
 5023 2d0c 0190C2E5 		strb	r9, [r2, #1]
3780:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5024              		.loc 1 3780 0
 5025 2d10 001097E5 		ldr	r1, [r7, #0]
 5026 2d14 0030A0E3 		mov	r3, #0
 5027 2d18 0230C1E5 		strb	r3, [r1, #2]
3781:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5028              		.loc 1 3781 0
 5029 2d1c 000097E5 		ldr	r0, [r7, #0]
3787:../uvc.c      **** 					interStabuf.count = 4;
 5030              		.loc 1 3787 0
 5031 2d20 0420A0E3 		mov	r2, #4	@ movhi
3781:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5032              		.loc 1 3781 0
 5033 2d24 0330C0E5 		strb	r3, [r0, #3]
3783:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5034              		.loc 1 3783 0
 5035 2d28 00C097E5 		ldr	ip, [r7, #0]
3784:../uvc.c      **** 					interStabuf.size   = 1024;
 5036              		.loc 1 3784 0
 5037 2d2c 01EBA0E3 		mov	lr, #1024	@ movhi
3790:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5038              		.loc 1 3790 0
 5039 2d30 0010E0E3 		mvn	r1, #0
 5040 2d34 20089FE5 		ldr	r0, .L527+28
3787:../uvc.c      **** 					interStabuf.count = 4;
 5041              		.loc 1 3787 0
 5042 2d38 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3783:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5043              		.loc 1 3783 0
 5044 2d3c 18C08DE5 		str	ip, [sp, #24]
3784:../uvc.c      **** 					interStabuf.size   = 1024;
 5045              		.loc 1 3784 0
 5046 2d40 BEE1CDE1 		strh	lr, [sp, #30]	@ movhi
3785:../uvc.c      **** 					interStabuf.status = 0;
 5047              		.loc 1 3785 0
 5048 2d44 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3790:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5049              		.loc 1 3790 0
 5050 2d48 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3793:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5051              		.loc 1 3793 0
 5052 2d4c 08089FE5 		ldr	r0, .L527+28
 5053 2d50 18108DE2 		add	r1, sp, #24
 5054 2d54 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5055              	.LVL395:
3795:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5056              		.loc 1 3795 0
 5057 2d58 002050E2 		subs	r2, r0, #0
 5058 2d5c E900001A 		bne	.L523
3800:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5059              		.loc 1 3800 0
 5060 2d60 3010A0E3 		mov	r1, #48
 5061 2d64 0500A0E3 		mov	r0, #5
 5062              	.LVL396:
 5063 2d68 FEFFFFEB 		bl	SensorSetControl
 5064              	.LVL397:
3802:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5065              		.loc 1 3802 0
 5066 2d6c D0C79FE5 		ldr	ip, .L527+4
 5067 2d70 BB96CCE5 		strb	r9, [ip, #1723]
3927:../uvc.c      ****         CyU3PThreadRelinquish ();
 5068              		.loc 1 3927 0
 5069 2d74 FEFFFFEB 		bl	_txe_thread_relinquish
 5070 2d78 07FFFFEA 		b	.L497
 5071              	.L378:
 5072              	.LBB138:
 5073              	.LBB101:
2889:../uvc.c      ****     switch (wValue)
 5074              		.loc 1 2889 0
 5075 2d7c 0A0C52E3 		cmp	r2, #2560
 5076 2d80 2B01000A 		beq	.L375
 5077 2d84 0B01008A 		bhi	.L380
 5078 2d88 070C52E3 		cmp	r2, #1792
 5079 2d8c 2401000A 		beq	.L373
 5080 2d90 020B52E3 		cmp	r2, #2048
 5081 2d94 25FFFF1A 		bne	.L381
 5082              	.LVL398:
2920:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5083              		.loc 1 2920 0
 5084 2d98 0700A0E3 		mov	r0, #7
 5085 2d9c FEFFFFEB 		bl	ControlHandle
 5086              	.LVL399:
 5087 2da0 28309DE5 		ldr	r3, [sp, #40]
 5088 2da4 2AFFFFEA 		b	.L360
 5089              	.L393:
 5090              	.LBE101:
 5091              	.LBE138:
 5092              	.LBB139:
 5093              	.LBB109:
2964:../uvc.c      ****     switch (wValue)
 5094              		.loc 1 2964 0
 5095 2da8 090C52E3 		cmp	r2, #2304
 5096 2dac 8201000A 		beq	.L389
 5097 2db0 E600008A 		bhi	.L395
 5098 2db4 070C52E3 		cmp	r2, #1792
 5099 2db8 7B01000A 		beq	.L388
 5100 2dbc 020B52E3 		cmp	r2, #2048
 5101 2dc0 1AFFFF1A 		bne	.L381
 5102 2dc4 22FFFFEA 		b	.L360
 5103              	.L418:
 5104              	.LBE109:
 5105              	.LBE139:
 5106              	.LBB140:
 5107              	.LBB130:
3189:../uvc.c      ****     switch (wValue)
 5108              		.loc 1 3189 0
 5109 2dc8 0F0C53E3 		cmp	r3, #3840
 5110 2dcc 7201000A 		beq	.L413
 5111 2dd0 B200008A 		bhi	.L421
 5112 2dd4 0B0C53E3 		cmp	r3, #2816
 5113 2dd8 0D01000A 		beq	.L410
 5114 2ddc A700008A 		bhi	.L422
 5115 2de0 0A0C53E3 		cmp	r3, #2560
 5116 2de4 15FFFF1A 		bne	.L361
 5117              	.LVL400:
3230:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5118              		.loc 1 3230 0
 5119 2de8 1900A0E3 		mov	r0, #25
 5120 2dec FEFFFFEB 		bl	ControlHandle
 5121              	.LVL401:
 5122 2df0 28309DE5 		ldr	r3, [sp, #40]
 5123 2df4 16FFFFEA 		b	.L360
 5124              	.LVL402:
 5125              	.L430:
 5126              	.LBE130:
 5127              	.LBE140:
 5128              	.LBB141:
 5129              	.LBB121:
3482:../uvc.c      ****                 switch (bRequest)
 5130              		.loc 1 3482 0
 5131 2df8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5132 2dfc 810052E3 		cmp	r2, #129
 5133 2e00 6B00000A 		beq	.L469
 5134 2e04 3200008A 		bhi	.L472
 5135 2e08 010052E3 		cmp	r2, #1
 5136 2e0c 8FFFFF1A 		bne	.L467
3507:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5137              		.loc 1 3507 0
 5138 2e10 2000A0E3 		mov	r0, #32
 5139 2e14 50179FE5 		ldr	r1, .L527+44
 5140 2e18 2E208DE2 		add	r2, sp, #46
 5141 2e1c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5142              	.LVL403:
3509:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5143              		.loc 1 3509 0
 5144 2e20 000050E3 		cmp	r0, #0
 5145 2e24 13FFFF1A 		bne	.L506
3528:../uvc.c      ****                            switch (glCommitCtrl[1])
 5146              		.loc 1 3528 0
 5147 2e28 8100D5E5 		ldrb	r0, [r5, #129]	@ zero_extendqisi2
 5148              	.LVL404:
 5149 2e2c 020050E3 		cmp	r0, #2
 5150 2e30 8201000A 		beq	.L477
 5151 2e34 030050E3 		cmp	r0, #3
 5152 2e38 7701000A 		beq	.L478
 5153 2e3c 010050E3 		cmp	r0, #1
 5154 2e40 0800001A 		bne	.L475
3541:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 5155              		.loc 1 3541 0
 5156 2e44 58C094E5 		ldr	ip, [r4, #88]
 5157 2e48 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5158 2e4c 00005CE3 		cmp	ip, #0
 5159 2e50 C4C0A003 		moveq	ip, #196
 5160 2e54 44C0A013 		movne	ip, #68
 5161 2e58 03208CE1 		orr	r2, ip, r3
 5162 2e5c 3010A0E3 		mov	r1, #48
 5163 2e60 5230A0E3 		mov	r3, #82
 5164 2e64 FEFFFFEB 		bl	SensorSetIrisControl
 5165              	.L475:
3548:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 5166              		.loc 1 3548 0
 5167 2e68 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3550:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 5168              		.loc 1 3550 0
 5169 2e6c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5170 2e70 BE22DDE1 		ldrh	r2, [sp, #46]
 5171              	.LVL405:
 5172 2e74 0400A0E3 		mov	r0, #4
 5173 2e78 F8169FE5 		ldr	r1, .L527+56
3548:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 5174              		.loc 1 3548 0
 5175 2e7c A0E0C4E5 		strb	lr, [r4, #160]
3550:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 5176              		.loc 1 3550 0
 5177 2e80 00E08DE5 		str	lr, [sp, #0]
 5178 2e84 FEFFFFEB 		bl	CyU3PDebugPrint
 5179 2e88 28309DE5 		ldr	r3, [sp, #40]
 5180 2e8c FAFEFFEA 		b	.L424
 5181              	.LVL406:
 5182              	.L427:
3293:../uvc.c      ****             switch (bRequest)
 5183              		.loc 1 3293 0
 5184 2e90 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5185 2e94 830052E3 		cmp	r2, #131
 5186 2e98 3100008A 		bhi	.L438
 5187 2e9c 810052E3 		cmp	r2, #129
 5188 2ea0 1600003A 		bcc	.L524
 5189              	.L435:
3308:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5190              		.loc 1 3308 0
 5191 2ea4 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5192 2ea8 030053E3 		cmp	r3, #3
 5193 2eac 2801001A 		bne	.L488
3310:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5194              		.loc 1 3310 0
 5195 2eb0 C4169FE5 		ldr	r1, .L527+60
 5196 2eb4 1A00A0E3 		mov	r0, #26
 5197 2eb8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3311:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5198              		.loc 1 3311 0
 5199 2ebc 0400A0E3 		mov	r0, #4
 5200 2ec0 B8169FE5 		ldr	r1, .L527+64
 5201 2ec4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5202 2ec8 FEFFFFEB 		bl	CyU3PDebugPrint
 5203 2ecc 28309DE5 		ldr	r3, [sp, #40]
 5204 2ed0 E9FEFFEA 		b	.L424
 5205              	.L472:
3482:../uvc.c      ****                 switch (bRequest)
 5206              		.loc 1 3482 0
 5207 2ed4 850052E3 		cmp	r2, #133
 5208 2ed8 2700000A 		beq	.L470
 5209 2edc 860052E3 		cmp	r2, #134
 5210 2ee0 5AFFFF1A 		bne	.L467
 5211              	.L510:
3486:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5212              		.loc 1 3486 0
 5213 2ee4 0300A0E1 		mov	r0, r3
 5214              	.L505:
3359:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5215              		.loc 1 3359 0
 5216 2ee8 94169FE5 		ldr	r1, .L527+68
3358:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5217              		.loc 1 3358 0
 5218 2eec 0390A0E3 		mov	r9, #3
 5219 2ef0 5C90C4E5 		strb	r9, [r4, #92]
3359:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5220              		.loc 1 3359 0
 5221 2ef4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5222 2ef8 28309DE5 		ldr	r3, [sp, #40]
 5223 2efc DEFEFFEA 		b	.L424
 5224              	.L524:
3293:../uvc.c      ****             switch (bRequest)
 5225              		.loc 1 3293 0
 5226 2f00 010052E3 		cmp	r2, #1
 5227 2f04 51FFFF1A 		bne	.L467
3320:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5228              		.loc 1 3320 0
 5229 2f08 2000A0E3 		mov	r0, #32
 5230 2f0c 58169FE5 		ldr	r1, .L527+44
 5231 2f10 2E208DE2 		add	r2, sp, #46
 5232 2f14 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5233              	.LVL407:
3322:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5234              		.loc 1 3322 0
 5235 2f18 000050E3 		cmp	r0, #0
 5236 2f1c D5FEFF1A 		bne	.L506
3324:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5237              		.loc 1 3324 0
 5238 2f20 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 5239 2f24 030051E3 		cmp	r1, #3
 5240 2f28 D2FEFF1A 		bne	.L506
3331:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5241              		.loc 1 3331 0
 5242 2f2c 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3328:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5243              		.loc 1 3328 0
 5244 2f30 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3329:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5245              		.loc 1 3329 0
 5246 2f34 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3330:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5247              		.loc 1 3330 0
 5248 2f38 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 5249              	.LVL408:
3332:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5250              		.loc 1 3332 0
 5251 2f3c 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3333:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5252              		.loc 1 3333 0
 5253 2f40 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3331:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5254              		.loc 1 3331 0
 5255 2f44 5536C6E5 		strb	r3, [r6, #1621]
3328:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5256              		.loc 1 3328 0
 5257 2f48 52E6C6E5 		strb	lr, [r6, #1618]
3329:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5258              		.loc 1 3329 0
 5259 2f4c 53C6C6E5 		strb	ip, [r6, #1619]
3330:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5260              		.loc 1 3330 0
 5261 2f50 5406C6E5 		strb	r0, [r6, #1620]
3332:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5262              		.loc 1 3332 0
 5263 2f54 5626C6E5 		strb	r2, [r6, #1622]
3333:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5264              		.loc 1 3333 0
 5265 2f58 5796C6E5 		strb	r9, [r6, #1623]
 5266 2f5c 28309DE5 		ldr	r3, [sp, #40]
 5267 2f60 C5FEFFEA 		b	.L424
 5268              	.LVL409:
 5269              	.L438:
3293:../uvc.c      ****             switch (bRequest)
 5270              		.loc 1 3293 0
 5271 2f64 860052E3 		cmp	r2, #134
 5272 2f68 DDFFFF0A 		beq	.L510
 5273 2f6c 870052E3 		cmp	r2, #135
 5274 2f70 CBFFFF0A 		beq	.L435
 5275              	.L515:
3432:../uvc.c      ****                 switch (bRequest)
 5276              		.loc 1 3432 0
 5277 2f74 850052E3 		cmp	r2, #133
 5278 2f78 34FFFF1A 		bne	.L467
 5279              	.L470:
3491:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5280              		.loc 1 3491 0
 5281 2f7c 00169FE5 		ldr	r1, .L527+68
 5282 2f80 0200A0E3 		mov	r0, #2
3489:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 5283              		.loc 1 3489 0
 5284 2f84 1A30A0E3 		mov	r3, #26
 5285              	.L507:
3571:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5286              		.loc 1 3571 0
 5287 2f88 0090A0E3 		mov	r9, #0
3570:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5288              		.loc 1 3570 0
 5289 2f8c 5C30C4E5 		strb	r3, [r4, #92]
3571:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5290              		.loc 1 3571 0
 5291 2f90 5D90C4E5 		strb	r9, [r4, #93]
3572:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5292              		.loc 1 3572 0
 5293 2f94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5294 2f98 28309DE5 		ldr	r3, [sp, #40]
 5295 2f9c B6FEFFEA 		b	.L424
 5296              	.L429:
3432:../uvc.c      ****                 switch (bRequest)
 5297              		.loc 1 3432 0
 5298 2fa0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5299 2fa4 830052E3 		cmp	r2, #131
 5300 2fa8 2F00008A 		bhi	.L463
 5301 2fac 810052E3 		cmp	r2, #129
 5302 2fb0 0D00003A 		bcc	.L525
 5303              	.L469:
3494:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5304              		.loc 1 3494 0
 5305 2fb4 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
3496:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5306              		.loc 1 3496 0
 5307 2fb8 0B00A0E3 		mov	r0, #11
3494:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5308              		.loc 1 3494 0
 5309 2fbc 030052E3 		cmp	r2, #3
3496:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5310              		.loc 1 3496 0
 5311 2fc0 C0159F05 		ldreq	r1, .L527+72
3500:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5312              		.loc 1 3500 0
 5313 2fc4 C0159F15 		ldrne	r1, .L527+76
 5314 2fc8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5315 2fcc 28309DE5 		ldr	r3, [sp, #40]
 5316 2fd0 A9FEFFEA 		b	.L424
 5317              	.L447:
3355:../uvc.c      ****             switch (bRequest)
 5318              		.loc 1 3355 0
 5319 2fd4 850053E3 		cmp	r3, #133
 5320 2fd8 E7FFFF0A 		beq	.L470
 5321 2fdc 860053E3 		cmp	r3, #134
 5322 2fe0 1AFFFF1A 		bne	.L467
 5323              	.L511:
3359:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5324              		.loc 1 3359 0
 5325 2fe4 0100A0E3 		mov	r0, #1
 5326 2fe8 BEFFFFEA 		b	.L505
 5327              	.L525:
3432:../uvc.c      ****                 switch (bRequest)
 5328              		.loc 1 3432 0
 5329 2fec 010052E3 		cmp	r2, #1
 5330 2ff0 16FFFF1A 		bne	.L467
3457:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5331              		.loc 1 3457 0
 5332 2ff4 2000A0E3 		mov	r0, #32
 5333 2ff8 6C159FE5 		ldr	r1, .L527+44
 5334 2ffc 2E208DE2 		add	r2, sp, #46
 5335 3000 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5336              	.LVL410:
3459:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5337              		.loc 1 3459 0
 5338 3004 000050E3 		cmp	r0, #0
 5339 3008 9AFEFF1A 		bne	.L506
3461:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5340              		.loc 1 3461 0
 5341 300c 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 5342 3010 030051E3 		cmp	r1, #3
 5343 3014 0B00001A 		bne	.L466
3465:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5344              		.loc 1 3465 0
 5345 3018 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3466:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5346              		.loc 1 3466 0
 5347 301c 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3467:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5348              		.loc 1 3467 0
 5349 3020 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 5350              	.LVL411:
3468:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5351              		.loc 1 3468 0
 5352 3024 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3469:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5353              		.loc 1 3469 0
 5354 3028 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3470:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5355              		.loc 1 3470 0
 5356 302c 8690D5E5 		ldrb	r9, [r5, #134]	@ zero_extendqisi2
3465:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5357              		.loc 1 3465 0
 5358 3030 A5E6C6E5 		strb	lr, [r6, #1701]
3466:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5359              		.loc 1 3466 0
 5360 3034 A6C6C6E5 		strb	ip, [r6, #1702]
3467:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5361              		.loc 1 3467 0
 5362 3038 A706C6E5 		strb	r0, [r6, #1703]
3468:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5363              		.loc 1 3468 0
 5364 303c A836C6E5 		strb	r3, [r6, #1704]
3469:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5365              		.loc 1 3469 0
 5366 3040 A926C6E5 		strb	r2, [r6, #1705]
3470:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5367              		.loc 1 3470 0
 5368 3044 AA96C6E5 		strb	r9, [r6, #1706]
 5369              	.L466:
3472:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 5370              		.loc 1 3472 0
 5371 3048 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 5372 304c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5373 3050 BE22DDE1 		ldrh	r2, [sp, #46]
 5374              	.LVL412:
 5375 3054 0400A0E3 		mov	r0, #4
 5376 3058 30159FE5 		ldr	r1, .L527+80
 5377 305c 00908DE5 		str	r9, [sp, #0]
 5378 3060 FEFFFFEB 		bl	CyU3PDebugPrint
 5379 3064 28309DE5 		ldr	r3, [sp, #40]
 5380 3068 83FEFFEA 		b	.L424
 5381              	.LVL413:
 5382              	.L463:
3432:../uvc.c      ****                 switch (bRequest)
 5383              		.loc 1 3432 0
 5384 306c 860052E3 		cmp	r2, #134
 5385 3070 9BFFFF0A 		beq	.L510
 5386 3074 870052E3 		cmp	r2, #135
 5387 3078 BDFFFF1A 		bne	.L515
 5388 307c CCFFFFEA 		b	.L469
 5389              	.LVL414:
 5390              	.L422:
 5391              	.LBE121:
 5392              	.LBE141:
 5393              	.LBB142:
 5394              	.LBB132:
3189:../uvc.c      ****     switch (wValue)
 5395              		.loc 1 3189 0
 5396 3080 030B53E3 		cmp	r3, #3072
 5397 3084 2901000A 		beq	.L411
 5398 3088 0D0C53E3 		cmp	r3, #3328
 5399 308c 6BFEFF1A 		bne	.L361
 5400              	.LVL415:
3246:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5401              		.loc 1 3246 0
 5402 3090 1C00A0E3 		mov	r0, #28
 5403 3094 FEFFFFEB 		bl	ControlHandle
 5404              	.LVL416:
 5405 3098 28309DE5 		ldr	r3, [sp, #40]
 5406 309c 6CFEFFEA 		b	.L360
 5407              	.L421:
3189:../uvc.c      ****     switch (wValue)
 5408              		.loc 1 3189 0
 5409 30a0 110C53E3 		cmp	r3, #4352
 5410 30a4 1D01000A 		beq	.L415
 5411 30a8 5100008A 		bhi	.L423
 5412 30ac 010A53E3 		cmp	r3, #4096
 5413 30b0 62FEFF1A 		bne	.L361
 5414              	.LVL417:
3258:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 5415              		.loc 1 3258 0
 5416 30b4 1F00A0E3 		mov	r0, #31
 5417 30b8 FEFFFFEB 		bl	ControlHandle
 5418              	.LVL418:
 5419 30bc 28309DE5 		ldr	r3, [sp, #40]
 5420 30c0 63FEFFEA 		b	.L360
 5421              	.LVL419:
 5422              	.L521:
 5423              	.LBE132:
 5424              	.LBE142:
3824:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5425              		.loc 1 3824 0
 5426 30c4 0400A0E3 		mov	r0, #4
 5427              	.LVL420:
 5428 30c8 C4149FE5 		ldr	r1, .L527+84
 5429 30cc FEFFFFEB 		bl	CyU3PDebugPrint
 5430              	.LVL421:
 5431              	.L496:
 5432              	.LBB143:
 5433              	.LBB144:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5434              		.loc 1 1603 0
 5435 30d0 C0149FE5 		ldr	r1, .L527+88
 5436 30d4 0400A0E3 		mov	r0, #4
 5437 30d8 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 5438              		.loc 1 1604 0
 5439 30dc FA0FA0E3 		mov	r0, #1000
 5440 30e0 FEFFFFEB 		bl	_tx_thread_sleep
 5441 30e4 F9FFFFEA 		b	.L496
 5442              	.L379:
 5443              	.LBE144:
 5444              	.LBE143:
 5445              	.LBB145:
 5446              	.LBB99:
2889:../uvc.c      ****     switch (wValue)
 5447              		.loc 1 2889 0
 5448 30e8 010B52E3 		cmp	r2, #1024
 5449 30ec 58FEFF0A 		beq	.L360
 5450 30f0 050C52E3 		cmp	r2, #1280
 5451 30f4 4DFEFF1A 		bne	.L381
 5452              	.LVL422:
2908:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5453              		.loc 1 2908 0
 5454 30f8 0400A0E3 		mov	r0, #4
 5455 30fc FEFFFFEB 		bl	ControlHandle
 5456              	.LVL423:
 5457 3100 28309DE5 		ldr	r3, [sp, #40]
 5458 3104 52FEFFEA 		b	.L360
 5459              	.LVL424:
 5460              	.L523:
 5461              	.LBE99:
 5462              	.LBE145:
3797:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5463              		.loc 1 3797 0
 5464 3108 0400A0E3 		mov	r0, #4
 5465              	.LVL425:
 5466 310c 80149FE5 		ldr	r1, .L527+84
 5467 3110 FEFFFFEB 		bl	CyU3PDebugPrint
 5468              	.LVL426:
 5469              	.L494:
 5470              	.LBB146:
 5471              	.LBB147:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5472              		.loc 1 1603 0
 5473 3114 7C149FE5 		ldr	r1, .L527+88
 5474 3118 0400A0E3 		mov	r0, #4
 5475 311c FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 5476              		.loc 1 1604 0
 5477 3120 FA0FA0E3 		mov	r0, #1000
 5478 3124 FEFFFFEB 		bl	_tx_thread_sleep
 5479 3128 F9FFFFEA 		b	.L494
 5480              	.L419:
 5481              	.LBE147:
 5482              	.LBE146:
 5483              	.LBB148:
 5484              	.LBB129:
3189:../uvc.c      ****     switch (wValue)
 5485              		.loc 1 3189 0
 5486 312c 060C53E3 		cmp	r3, #1536
 5487 3130 F600000A 		beq	.L405
 5488 3134 0F00008A 		bhi	.L420
 5489 3138 050C53E3 		cmp	r3, #1280
 5490 313c 3FFEFF1A 		bne	.L361
 5491              	.LVL427:
3209:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5492              		.loc 1 3209 0
 5493 3140 1400A0E3 		mov	r0, #20
 5494 3144 FEFFFFEB 		bl	ControlHandle
 5495              	.LVL428:
 5496 3148 28309DE5 		ldr	r3, [sp, #40]
 5497 314c 40FEFFEA 		b	.L360
 5498              	.L395:
 5499              	.LBE129:
 5500              	.LBE148:
 5501              	.LBB149:
 5502              	.LBB112:
2964:../uvc.c      ****     switch (wValue)
 5503              		.loc 1 2964 0
 5504 3150 0B0C52E3 		cmp	r2, #2816
 5505 3154 E900000A 		beq	.L391
 5506 3158 030B52E3 		cmp	r2, #3072
 5507 315c E300000A 		beq	.L392
 5508 3160 0A0C52E3 		cmp	r2, #2560
 5509 3164 31FEFF1A 		bne	.L381
 5510              	.LVL429:
3005:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5511              		.loc 1 3005 0
 5512 3168 0800A0E3 		mov	r0, #8
 5513 316c FEFFFFEB 		bl	CTControlHandle
 5514              	.LVL430:
 5515 3170 28309DE5 		ldr	r3, [sp, #40]
 5516 3174 36FEFFEA 		b	.L360
 5517              	.L420:
 5518              	.LBE112:
 5519              	.LBE149:
 5520              	.LBB150:
 5521              	.LBB133:
3189:../uvc.c      ****     switch (wValue)
 5522              		.loc 1 3189 0
 5523 3178 070C53E3 		cmp	r3, #1792
 5524 317c D700000A 		beq	.L406
 5525 3180 020B53E3 		cmp	r3, #2048
 5526 3184 2DFEFF1A 		bne	.L361
 5527              	.LVL431:
3221:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5528              		.loc 1 3221 0
 5529 3188 1700A0E3 		mov	r0, #23
 5530 318c FEFFFFEB 		bl	ControlHandle
 5531              	.LVL432:
 5532 3190 28309DE5 		ldr	r3, [sp, #40]
 5533 3194 2EFEFFEA 		b	.L360
 5534              	.L394:
 5535              	.LBE133:
 5536              	.LBE150:
 5537              	.LBB151:
 5538              	.LBB108:
2964:../uvc.c      ****     switch (wValue)
 5539              		.loc 1 2964 0
 5540 3198 010B52E3 		cmp	r2, #1024
 5541 319c CB00000A 		beq	.L385
 5542 31a0 050C52E3 		cmp	r2, #1280
 5543 31a4 21FEFF1A 		bne	.L381
 5544              	.LVL433:
2986:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 5545              		.loc 1 2986 0
 5546 31a8 0400A0E3 		mov	r0, #4
 5547 31ac FEFFFFEB 		bl	CTControlHandle
 5548              	.LVL434:
 5549 31b0 28309DE5 		ldr	r3, [sp, #40]
 5550 31b4 26FEFFEA 		b	.L360
 5551              	.L380:
 5552              	.LBE108:
 5553              	.LBE151:
 5554              	.LBB152:
 5555              	.LBB102:
2889:../uvc.c      ****     switch (wValue)
 5556              		.loc 1 2889 0
 5557 31b8 0D0C52E3 		cmp	r2, #3328
 5558 31bc 1C00000A 		beq	.L375
 5559 31c0 0E0C52E3 		cmp	r2, #3584
 5560 31c4 BD00000A 		beq	.L377
 5561 31c8 030B52E3 		cmp	r2, #3072
 5562 31cc 17FEFF1A 		bne	.L381
 5563              	.LVL435:
2930:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5564              		.loc 1 2930 0
 5565 31d0 0B00A0E3 		mov	r0, #11
 5566 31d4 FEFFFFEB 		bl	ControlHandle
 5567              	.LVL436:
 5568 31d8 28309DE5 		ldr	r3, [sp, #40]
 5569 31dc 1CFEFFEA 		b	.L360
 5570              	.LVL437:
 5571              	.L487:
 5572              	.LBE102:
 5573              	.LBE152:
 5574              	.LBB153:
 5575              	.LBB118:
3563:../uvc.c      ****             	switch (bRequest)
 5576              		.loc 1 3563 0
 5577 31e0 850052E3 		cmp	r2, #133
 5578 31e4 B200000A 		beq	.L485
 5579 31e8 860052E3 		cmp	r2, #134
 5580 31ec 1DFEFF1A 		bne	.L426
 5581 31f0 7BFFFFEA 		b	.L511
 5582              	.LVL438:
 5583              	.L423:
 5584              	.LBE118:
 5585              	.LBE153:
 5586              	.LBB154:
 5587              	.LBB128:
3189:../uvc.c      ****     switch (wValue)
 5588              		.loc 1 3189 0
 5589 31f4 120C53E3 		cmp	r3, #4608
 5590 31f8 A900000A 		beq	.L416
 5591 31fc 130C53E3 		cmp	r3, #4864
 5592 3200 0EFEFF1A 		bne	.L361
 5593              	.LVL439:
3270:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 5594              		.loc 1 3270 0
 5595 3204 2200A0E3 		mov	r0, #34
 5596 3208 FEFFFFEB 		bl	ControlHandle
 5597              	.LVL440:
 5598 320c 28309DE5 		ldr	r3, [sp, #40]
 5599 3210 0FFEFFEA 		b	.L360
 5600              	.L410:
 5601              	.LVL441:
3236:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5602              		.loc 1 3236 0
 5603 3214 1A00A0E3 		mov	r0, #26
 5604 3218 FEFFFFEB 		bl	ControlHandle
 5605              	.LVL442:
 5606 321c 28309DE5 		ldr	r3, [sp, #40]
 5607 3220 0BFEFFEA 		b	.L360
 5608              	.L373:
 5609              	.LVL443:
 5610              	.LBE128:
 5611              	.LBE154:
 5612              	.LBB155:
 5613              	.LBB98:
2916:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5614              		.loc 1 2916 0
 5615 3224 0600A0E3 		mov	r0, #6
 5616 3228 FEFFFFEB 		bl	ControlHandle
 5617              	.LVL444:
 5618 322c 28309DE5 		ldr	r3, [sp, #40]
 5619 3230 07FEFFEA 		b	.L360
 5620              	.L375:
 5621              	.LVL445:
2926:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5622              		.loc 1 2926 0
 5623 3234 0900A0E3 		mov	r0, #9
 5624 3238 FEFFFFEB 		bl	ControlHandle
 5625              	.LVL446:
 5626 323c 28309DE5 		ldr	r3, [sp, #40]
 5627 3240 03FEFFEA 		b	.L360
 5628              	.LVL447:
 5629              	.L489:
 5630              	.LBE98:
 5631              	.LBE155:
 5632              	.LBB156:
 5633              	.LBB122:
3606:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5634              		.loc 1 3606 0
 5635 3244 50139FE5 		ldr	r1, .L527+92
 5636 3248 BE22DDE1 		ldrh	r2, [sp, #46]
 5637 324c 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5638 3250 0400A0E3 		mov	r0, #4
 5639              	.LVL448:
 5640 3254 FEFFFFEB 		bl	CyU3PDebugPrint
 5641 3258 02FEFFEA 		b	.L426
 5642              	.LVL449:
 5643              	.L522:
3380:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5644              		.loc 1 3380 0
 5645 325c 2000A0E3 		mov	r0, #32
 5646 3260 04139FE5 		ldr	r1, .L527+44
 5647 3264 2E208DE2 		add	r2, sp, #46
 5648 3268 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5649              	.LVL450:
3382:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5650              		.loc 1 3382 0
 5651 326c 000050E3 		cmp	r0, #0
 5652 3270 00FEFF1A 		bne	.L506
3384:../uvc.c      ****                         switch (glCommitCtrl[3])
 5653              		.loc 1 3384 0
 5654 3274 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5655              	.LVL451:
 5656 3278 020050E3 		cmp	r0, #2
 5657 327c 2600000A 		beq	.L452
 5658 3280 030050E3 		cmp	r0, #3
 5659 3284 1700000A 		beq	.L453
 5660 3288 010050E3 		cmp	r0, #1
 5661 328c 0800001A 		bne	.L450
3387:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5662              		.loc 1 3387 0
 5663 3290 582095E5 		ldr	r2, [r5, #88]
 5664 3294 3010A0E3 		mov	r1, #48
 5665 3298 000052E3 		cmp	r2, #0
 5666 329c E420A003 		moveq	r2, #228
 5667 32a0 6420A013 		movne	r2, #100
 5668 32a4 5230A0E3 		mov	r3, #82
 5669 32a8 FEFFFFEB 		bl	SensorSetIrisControl
3388:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5670              		.loc 1 3388 0
 5671 32ac 7D0FA0E3 		mov	r0, #500
 5672 32b0 FEFFFFEB 		bl	_tx_thread_sleep
 5673              	.L450:
3404:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5674              		.loc 1 3404 0
 5675 32b4 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3416:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5676              		.loc 1 3416 0
 5677 32b8 0020A0E3 		mov	r2, #0
 5678 32bc 7C029FE5 		ldr	r0, .L527
 5679 32c0 0110A0E3 		mov	r1, #1
3404:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5680              		.loc 1 3404 0
 5681 32c4 7DC0C4E5 		strb	ip, [r4, #125]
3416:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5682              		.loc 1 3416 0
 5683 32c8 FEFFFFEB 		bl	_txe_event_flags_set
 5684              	.LVL452:
3417:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5685              		.loc 1 3417 0
 5686 32cc 002050E2 		subs	r2, r0, #0
 5687 32d0 E8FDFF0A 		beq	.L506
3419:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5688              		.loc 1 3419 0
 5689 32d4 0400A0E3 		mov	r0, #4
 5690              	.LVL453:
 5691 32d8 90129FE5 		ldr	r1, .L527+48
 5692 32dc FEFFFFEB 		bl	CyU3PDebugPrint
 5693              	.LVL454:
 5694 32e0 28309DE5 		ldr	r3, [sp, #40]
 5695 32e4 E4FDFFEA 		b	.L424
 5696              	.L453:
3397:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5697              		.loc 1 3397 0
 5698 32e8 582095E5 		ldr	r2, [r5, #88]
 5699 32ec 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5700 32f0 000052E3 		cmp	r2, #0
 5701 32f4 C420A003 		moveq	r2, #196
 5702 32f8 4420A013 		movne	r2, #68
 5703 32fc 032082E1 		orr	r2, r2, r3
 5704 3300 3010A0E3 		mov	r1, #48
 5705 3304 5230A0E3 		mov	r3, #82
 5706 3308 0100A0E3 		mov	r0, #1
 5707 330c FEFFFFEB 		bl	SensorSetIrisControl
3398:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5708              		.loc 1 3398 0
 5709 3310 7D0FA0E3 		mov	r0, #500
 5710 3314 FEFFFFEB 		bl	_tx_thread_sleep
 5711 3318 E5FFFFEA 		b	.L450
 5712              	.L452:
3392:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5713              		.loc 1 3392 0
 5714 331c 582095E5 		ldr	r2, [r5, #88]
 5715 3320 3010A0E3 		mov	r1, #48
 5716 3324 000052E3 		cmp	r2, #0
 5717 3328 D420A003 		moveq	r2, #212
 5718 332c 5420A013 		movne	r2, #84
 5719 3330 5230A0E3 		mov	r3, #82
 5720 3334 0100A0E3 		mov	r0, #1
 5721 3338 FEFFFFEB 		bl	SensorSetIrisControl
3393:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5722              		.loc 1 3393 0
 5723 333c 7D0FA0E3 		mov	r0, #500
 5724 3340 FEFFFFEB 		bl	_tx_thread_sleep
 5725 3344 DAFFFFEA 		b	.L450
 5726              	.LVL455:
 5727              	.L484:
3575:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5728              		.loc 1 3575 0
 5729 3348 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5730 334c 030051E3 		cmp	r1, #3
 5731 3350 0400000A 		beq	.L526
 5732              	.L488:
3581:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5733              		.loc 1 3581 0
 5734 3354 1A00A0E3 		mov	r0, #26
 5735 3358 40129FE5 		ldr	r1, .L527+96
 5736 335c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5737 3360 28309DE5 		ldr	r3, [sp, #40]
 5738 3364 C4FDFFEA 		b	.L424
 5739              	.L526:
3577:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5740              		.loc 1 3577 0
 5741 3368 1A00A0E3 		mov	r0, #26
 5742 336c 30129FE5 		ldr	r1, .L527+100
 5743 3370 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5744 3374 28309DE5 		ldr	r3, [sp, #40]
 5745 3378 BFFDFFEA 		b	.L424
 5746              	.LVL456:
 5747              	.L402:
 5748              	.LBE122:
 5749              	.LBE156:
 5750              	.LBB157:
 5751              	.LBB134:
3201:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5752              		.loc 1 3201 0
 5753 337c 1200A0E3 		mov	r0, #18
 5754 3380 FEFFFFEB 		bl	ControlHandle
 5755              	.LVL457:
 5756 3384 28309DE5 		ldr	r3, [sp, #40]
 5757 3388 B1FDFFEA 		b	.L360
 5758              	.L401:
 5759              	.LVL458:
3197:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5760              		.loc 1 3197 0
 5761 338c 1100A0E3 		mov	r0, #17
 5762 3390 FEFFFFEB 		bl	ControlHandle
 5763              	.LVL459:
 5764 3394 28309DE5 		ldr	r3, [sp, #40]
 5765 3398 ADFDFFEA 		b	.L360
 5766              	.L413:
 5767              	.LVL460:
3254:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5768              		.loc 1 3254 0
 5769 339c 1E00A0E3 		mov	r0, #30
 5770 33a0 FEFFFFEB 		bl	ControlHandle
 5771              	.LVL461:
 5772 33a4 28309DE5 		ldr	r3, [sp, #40]
 5773 33a8 A9FDFFEA 		b	.L360
 5774              	.L388:
 5775              	.LVL462:
 5776              	.LBE134:
 5777              	.LBE157:
 5778              	.LBB158:
 5779              	.LBB113:
2994:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5780              		.loc 1 2994 0
 5781 33ac 0600A0E3 		mov	r0, #6
 5782 33b0 FEFFFFEB 		bl	CTControlHandle
 5783              	.LVL463:
 5784 33b4 28309DE5 		ldr	r3, [sp, #40]
 5785 33b8 A5FDFFEA 		b	.L360
 5786              	.L389:
 5787              	.LVL464:
3000:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5788              		.loc 1 3000 0
 5789 33bc 0700A0E3 		mov	r0, #7
 5790 33c0 FEFFFFEB 		bl	CTControlHandle
 5791              	.LVL465:
 5792 33c4 28309DE5 		ldr	r3, [sp, #40]
 5793 33c8 A1FDFFEA 		b	.L360
 5794              	.L370:
 5795              	.LVL466:
 5796              	.LBE113:
 5797              	.LBE158:
 5798              	.LBB159:
 5799              	.LBB103:
2901:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5800              		.loc 1 2901 0
 5801 33cc 0200A0E3 		mov	r0, #2
 5802 33d0 FEFFFFEB 		bl	ControlHandle
 5803              	.LVL467:
 5804 33d4 28309DE5 		ldr	r3, [sp, #40]
 5805 33d8 9DFDFFEA 		b	.L360
 5806              	.L372:
 5807              	.LVL468:
2912:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5808              		.loc 1 2912 0
 5809 33dc 0500A0E3 		mov	r0, #5
 5810 33e0 FEFFFFEB 		bl	ControlHandle
 5811              	.LVL469:
 5812 33e4 28309DE5 		ldr	r3, [sp, #40]
 5813 33e8 99FDFFEA 		b	.L360
 5814              	.L403:
 5815              	.LVL470:
 5816              	.LBE103:
 5817              	.LBE159:
 5818              	.LBB160:
 5819              	.LBB127:
3205:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5820              		.loc 1 3205 0
 5821 33ec 1300A0E3 		mov	r0, #19
 5822 33f0 FEFFFFEB 		bl	ControlHandle
 5823              	.LVL471:
 5824 33f4 28309DE5 		ldr	r3, [sp, #40]
 5825 33f8 95FDFFEA 		b	.L360
 5826              	.L408:
 5827              	.LVL472:
3225:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5828              		.loc 1 3225 0
 5829 33fc 1800A0E3 		mov	r0, #24
 5830 3400 FEFFFFEB 		bl	ControlHandle
 5831              	.LVL473:
 5832 3404 28309DE5 		ldr	r3, [sp, #40]
 5833 3408 91FDFFEA 		b	.L360
 5834              	.L382:
 5835              	.LVL474:
 5836              	.LBE127:
 5837              	.LBE160:
 5838              	.LBB161:
 5839              	.LBB107:
2968:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5840              		.loc 1 2968 0
 5841 340c 0000A0E3 		mov	r0, #0
 5842 3410 FEFFFFEB 		bl	CTControlHandle
 5843              	.LVL475:
 5844 3414 28309DE5 		ldr	r3, [sp, #40]
 5845 3418 8DFDFFEA 		b	.L360
 5846              	.L478:
 5847              	.LBE107:
 5848              	.LBE161:
 5849              	.LBB162:
 5850              	.LBB117:
3531:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 5851              		.loc 1 3531 0
 5852 341c 582094E5 		ldr	r2, [r4, #88]
 5853 3420 3010A0E3 		mov	r1, #48
 5854 3424 000052E3 		cmp	r2, #0
 5855 3428 E420A003 		moveq	r2, #228
 5856 342c 6420A013 		movne	r2, #100
 5857 3430 5230A0E3 		mov	r3, #82
 5858 3434 0100A0E3 		mov	r0, #1
 5859 3438 FEFFFFEB 		bl	SensorSetIrisControl
 5860 343c 89FEFFEA 		b	.L475
 5861              	.L477:
3536:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 5862              		.loc 1 3536 0
 5863 3440 582094E5 		ldr	r2, [r4, #88]
 5864 3444 3010A0E3 		mov	r1, #48
 5865 3448 000052E3 		cmp	r2, #0
 5866 344c D420A003 		moveq	r2, #212
 5867 3450 5420A013 		movne	r2, #84
 5868 3454 5230A0E3 		mov	r3, #82
 5869 3458 0100A0E3 		mov	r0, #1
 5870 345c FEFFFFEB 		bl	SensorSetIrisControl
 5871 3460 80FEFFEA 		b	.L475
 5872              	.L384:
 5873              	.LVL476:
 5874              	.LBE117:
 5875              	.LBE162:
 5876              	.LBB163:
 5877              	.LBB114:
2976:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5878              		.loc 1 2976 0
 5879 3464 0200A0E3 		mov	r0, #2
 5880 3468 FEFFFFEB 		bl	CTControlHandle
 5881              	.LVL477:
 5882 346c 28309DE5 		ldr	r3, [sp, #40]
 5883 3470 77FDFFEA 		b	.L360
 5884              	.L387:
 5885              	.LVL478:
2990:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 5886              		.loc 1 2990 0
 5887 3474 0500A0E3 		mov	r0, #5
 5888 3478 FEFFFFEB 		bl	CTControlHandle
 5889              	.LVL479:
 5890 347c 28309DE5 		ldr	r3, [sp, #40]
 5891 3480 73FDFFEA 		b	.L360
 5892              	.L518:
 5893              	.LVL480:
 5894              	.LBE114:
 5895              	.LBE163:
 5896              	.LBB164:
 5897              	.LBB97:
2897:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5898              		.loc 1 2897 0
 5899 3484 0100A0E3 		mov	r0, #1
 5900 3488 FEFFFFEB 		bl	ControlHandle
 5901              	.LVL481:
 5902 348c 28309DE5 		ldr	r3, [sp, #40]
 5903 3490 6FFDFFEA 		b	.L360
 5904              	.L368:
 5905              	.LVL482:
2893:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 5906              		.loc 1 2893 0
 5907 3494 0000A0E3 		mov	r0, #0
 5908 3498 FEFFFFEB 		bl	ControlHandle
 5909              	.LVL483:
 5910 349c 28309DE5 		ldr	r3, [sp, #40]
 5911 34a0 6BFDFFEA 		b	.L360
 5912              	.L416:
 5913              	.LVL484:
 5914              	.LBE97:
 5915              	.LBE164:
 5916              	.LBB165:
 5917              	.LBB135:
3266:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5918              		.loc 1 3266 0
 5919 34a4 2100A0E3 		mov	r0, #33
 5920 34a8 FEFFFFEB 		bl	ControlHandle
 5921              	.LVL485:
 5922 34ac 28309DE5 		ldr	r3, [sp, #40]
 5923 34b0 67FDFFEA 		b	.L360
 5924              	.LVL486:
 5925              	.L485:
 5926              	.LBE135:
 5927              	.LBE165:
 5928              	.LBB166:
 5929              	.LBB123:
3572:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5930              		.loc 1 3572 0
 5931 34b4 0200A0E3 		mov	r0, #2
 5932 34b8 C4109FE5 		ldr	r1, .L527+68
 5933 34bc B1FEFFEA 		b	.L507
 5934              	.LVL487:
 5935              	.L377:
 5936              	.LBE123:
 5937              	.LBE166:
 5938              	.LBB167:
 5939              	.LBB104:
2934:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5940              		.loc 1 2934 0
 5941 34c0 0E00A0E3 		mov	r0, #14
 5942 34c4 FEFFFFEB 		bl	ControlHandle
 5943              	.LVL488:
 5944 34c8 28309DE5 		ldr	r3, [sp, #40]
 5945 34cc 60FDFFEA 		b	.L360
 5946              	.L385:
 5947              	.LVL489:
 5948              	.LBE104:
 5949              	.LBE167:
 5950              	.LBB168:
 5951              	.LBB106:
2981:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 5952              		.loc 1 2981 0
 5953 34d0 0300A0E3 		mov	r0, #3
 5954 34d4 FEFFFFEB 		bl	CTControlHandle
 5955              	.LVL490:
 5956 34d8 28309DE5 		ldr	r3, [sp, #40]
 5957 34dc 5CFDFFEA 		b	.L360
 5958              	.L406:
 5959              	.LVL491:
 5960              	.LBE106:
 5961              	.LBE168:
 5962              	.LBB169:
 5963              	.LBB126:
3217:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5964              		.loc 1 3217 0
 5965 34e0 1600A0E3 		mov	r0, #22
 5966 34e4 FEFFFFEB 		bl	ControlHandle
 5967              	.LVL492:
 5968 34e8 28309DE5 		ldr	r3, [sp, #40]
 5969 34ec 58FDFFEA 		b	.L360
 5970              	.L392:
 5971              	.LVL493:
 5972              	.LBE126:
 5973              	.LBE169:
 5974              	.LBB170:
 5975              	.LBB115:
3013:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5976              		.loc 1 3013 0
 5977 34f0 0A00A0E3 		mov	r0, #10
 5978 34f4 FEFFFFEB 		bl	CTControlHandle
 5979              	.LVL494:
 5980 34f8 28309DE5 		ldr	r3, [sp, #40]
 5981 34fc 54FDFFEA 		b	.L360
 5982              	.L391:
 5983              	.LVL495:
3009:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5984              		.loc 1 3009 0
 5985 3500 0900A0E3 		mov	r0, #9
 5986 3504 FEFFFFEB 		bl	CTControlHandle
 5987              	.LVL496:
 5988 3508 28309DE5 		ldr	r3, [sp, #40]
 5989 350c 50FDFFEA 		b	.L360
 5990              	.L405:
 5991              	.LVL497:
 5992              	.LBE115:
 5993              	.LBE170:
 5994              	.LBB171:
 5995              	.LBB136:
3213:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5996              		.loc 1 3213 0
 5997 3510 1500A0E3 		mov	r0, #21
 5998 3514 FEFFFFEB 		bl	ControlHandle
 5999              	.LVL498:
 6000 3518 28309DE5 		ldr	r3, [sp, #40]
 6001 351c 4CFDFFEA 		b	.L360
 6002              	.L415:
 6003              	.LVL499:
3262:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 6004              		.loc 1 3262 0
 6005 3520 2000A0E3 		mov	r0, #32
 6006 3524 FEFFFFEB 		bl	ControlHandle
 6007              	.LVL500:
 6008 3528 28309DE5 		ldr	r3, [sp, #40]
 6009 352c 48FDFFEA 		b	.L360
 6010              	.L411:
 6011              	.LVL501:
3240:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6012              		.loc 1 3240 0
 6013 3530 1B00A0E3 		mov	r0, #27
 6014 3534 FEFFFFEB 		bl	ControlHandle
 6015              	.LVL502:
 6016 3538 28309DE5 		ldr	r3, [sp, #40]
 6017 353c 44FDFFEA 		b	.L360
 6018              	.L528:
 6019              		.align	2
 6020              	.L527:
 6021 3540 00000000 		.word	.LANCHOR0
 6022 3544 00000000 		.word	.LANCHOR1
 6023 3548 00000000 		.word	bRequest
 6024 354c 00000000 		.word	wValue
 6025 3550 00000000 		.word	wIndex
 6026 3554 00000000 		.word	glInterStaBuffer
 6027 3558 7C050000 		.word	.LC29
 6028 355c 00000000 		.word	glChHandleInterStat
 6029 3560 00000000 		.word	bmReqType
 6030 3564 00000000 		.word	wLength
 6031 3568 00050000 		.word	.LC28
 6032 356c 80000000 		.word	.LANCHOR0+128
 6033 3570 D0050000 		.word	.LC31
 6034 3574 4C060000 		.word	.LC34
 6035 3578 24060000 		.word	.LC33
 6036 357c 50060000 		.word	.LANCHOR1+1616
 6037 3580 A8050000 		.word	.LC30
 6038 3584 5C000000 		.word	.LANCHOR0+92
 6039 3588 A4060000 		.word	.LANCHOR1+1700
 6040 358c B0060000 		.word	.LANCHOR1+1712
 6041 3590 F8050000 		.word	.LC32
 6042 3594 A0060000 		.word	.LC36
 6043 3598 D8010000 		.word	.LC12
 6044 359c 78060000 		.word	.LC35
 6045 35a0 6C060000 		.word	.LANCHOR1+1644
 6046 35a4 88060000 		.word	.LANCHOR1+1672
 6047              	.LBE136:
 6048              	.LBE171:
 6049              		.cfi_endproc
 6050              	.LFE25:
 6052              		.align	2
 6053              		.global	CamDefSet
 6055              	CamDefSet:
 6056              	.LFB5:
1498:../uvc.c      **** {
 6057              		.loc 1 1498 0
 6058              		.cfi_startproc
 6059              		@ args = 0, pretend = 0, frame = 24
 6060              		@ frame_needed = 0, uses_anonymous_args = 0
 6061              	.LVL503:
 6062 35a8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6063              	.LCFI21:
 6064              		.cfi_def_cfa_offset 36
1504:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6065              		.loc 1 1504 0
 6066 35ac AC429FE5 		ldr	r4, .L532
 6067              		.cfi_offset 14, -4
 6068              		.cfi_offset 11, -8
 6069              		.cfi_offset 10, -12
 6070              		.cfi_offset 9, -16
 6071              		.cfi_offset 8, -20
 6072              		.cfi_offset 7, -24
 6073              		.cfi_offset 6, -28
 6074              		.cfi_offset 5, -32
 6075              		.cfi_offset 4, -36
1509:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6076              		.loc 1 1509 0
 6077 35b0 AC229FE5 		ldr	r2, .L532+4
1506:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6078              		.loc 1 1506 0
 6079 35b4 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1498:../uvc.c      **** {
 6080              		.loc 1 1498 0
 6081 35b8 2CD04DE2 		sub	sp, sp, #44
 6082              	.LCFI22:
 6083              		.cfi_def_cfa_offset 80
1509:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6084              		.loc 1 1509 0
 6085 35bc 1C0092E5 		ldr	r0, [r2, #28]
 6086 35c0 0010E0E3 		mvn	r1, #0
1511:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6087              		.loc 1 1511 0
 6088 35c4 2963A0E1 		mov	r6, r9, lsr #6
1505:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6089              		.loc 1 1505 0
 6090 35c8 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1504:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6091              		.loc 1 1504 0
 6092 35cc 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 6093              	.LVL504:
1509:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6094              		.loc 1 1509 0
 6095 35d0 FEFFFFEB 		bl	_txe_mutex_get
1510:../uvc.c      ****     if(Data1&0x80){
 6096              		.loc 1 1510 0
 6097 35d4 800019E3 		tst	r9, #128
1511:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6098              		.loc 1 1511 0
 6099 35d8 01600612 		andne	r6, r6, #1
 6100 35dc 0660E011 		mvnne	r6, r6
 6101 35e0 3B600612 		andne	r6, r6, #59
 6102 35e4 0660E011 		mvnne	r6, r6
 6103 35e8 FF600612 		andne	r6, r6, #255
 6104              	.LVL505:
1513:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 6105              		.loc 1 1513 0
 6106 35ec C6608603 		orreq	r6, r6, #198
 6107              	.LVL506:
1517:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6108              		.loc 1 1517 0
 6109 35f0 0080A0E3 		mov	r8, #0
 6110 35f4 0A20A0E1 		mov	r2, sl
 6111 35f8 0730A0E1 		mov	r3, r7
 6112 35fc 0110A0E3 		mov	r1, #1
1515:../uvc.c      ****     Data0 = (Data0 << 2);
 6113              		.loc 1 1515 0
 6114 3600 0951A0E1 		mov	r5, r9, asl #2
1517:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6115              		.loc 1 1517 0
 6116 3604 58029FE5 		ldr	r0, .L532+4
1520:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6117              		.loc 1 1520 0
 6118 3608 0190A0E3 		mov	r9, #1
 6119              	.LVL507:
1515:../uvc.c      ****     Data0 = (Data0 << 2);
 6120              		.loc 1 1515 0
 6121 360c FF5005E2 		and	r5, r5, #255
 6122              	.LVL508:
1517:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6123              		.loc 1 1517 0
 6124 3610 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6125 3614 FEFFFFEB 		bl	cmdSet
 6126              	.LVL509:
1520:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6127              		.loc 1 1520 0
 6128 3618 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6129 361c 0910A0E1 		mov	r1, r9
 6130 3620 0730A0E1 		mov	r3, r7
 6131 3624 38029FE5 		ldr	r0, .L532+4
 6132 3628 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 6133 362c FEFFFFEB 		bl	cmdSet
 6134              	.LVL510:
1523:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6135              		.loc 1 1523 0
 6136 3630 0620A0E1 		mov	r2, r6
 6137 3634 0530A0E1 		mov	r3, r5
 6138 3638 28129FE5 		ldr	r1, .L532+8
 6139 363c 0400A0E3 		mov	r0, #4
1522:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6140              		.loc 1 1522 0
 6141 3640 A661C4E5 		strb	r6, [r4, #422]
1521:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6142              		.loc 1 1521 0
 6143 3644 A551C4E5 		strb	r5, [r4, #421]
1523:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6144              		.loc 1 1523 0
 6145 3648 FEFFFFEB 		bl	CyU3PDebugPrint
 6146              	.LVL511:
1528:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6147              		.loc 1 1528 0
 6148 364c BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 6149              	.LVL512:
1529:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6150              		.loc 1 1529 0
 6151 3650 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6152 3654 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6153 3658 0210A0E3 		mov	r1, #2
 6154 365c 00029FE5 		ldr	r0, .L532+4
 6155 3660 00B08DE5 		str	fp, [sp, #0]
 6156 3664 04808DE5 		str	r8, [sp, #4]
 6157 3668 FEFFFFEB 		bl	cmdSet
 6158              	.LVL513:
1531:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6159              		.loc 1 1531 0
 6160 366c 0B20A0E1 		mov	r2, fp
 6161 3670 0530A0E1 		mov	r3, r5
 6162 3674 EC119FE5 		ldr	r1, .L532+8
 6163 3678 0400A0E3 		mov	r0, #4
1530:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6164              		.loc 1 1530 0
 6165 367c BD51C4E5 		strb	r5, [r4, #445]
1531:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6166              		.loc 1 1531 0
 6167 3680 FEFFFFEB 		bl	CyU3PDebugPrint
 6168              	.LVL514:
1536:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6169              		.loc 1 1536 0
 6170 3684 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1535:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6171              		.loc 1 1535 0
 6172 3688 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6173              	.LVL515:
1537:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6174              		.loc 1 1537 0
 6175 368c 80B047E2 		sub	fp, r7, #128
 6176 3690 FF100BE2 		and	r1, fp, #255
 6177 3694 14108DE5 		str	r1, [sp, #20]
 6178 3698 14C09DE5 		ldr	ip, [sp, #20]
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6179              		.loc 1 1538 0
 6180 369c 760047E2 		sub	r0, r7, #118
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6181              		.loc 1 1539 0
 6182 36a0 7EE087E2 		add	lr, r7, #126
1537:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6183              		.loc 1 1537 0
 6184 36a4 0630A0E1 		mov	r3, r6
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6185              		.loc 1 1538 0
 6186 36a8 18008DE5 		str	r0, [sp, #24]
1537:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6187              		.loc 1 1537 0
 6188 36ac 0510A0E3 		mov	r1, #5
 6189 36b0 DF20A0E3 		mov	r2, #223
 6190 36b4 A8019FE5 		ldr	r0, .L532+4
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6191              		.loc 1 1539 0
 6192 36b8 1CE08DE5 		str	lr, [sp, #28]
1537:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6193              		.loc 1 1537 0
 6194 36bc 00C08DE5 		str	ip, [sp, #0]
 6195 36c0 04808DE5 		str	r8, [sp, #4]
 6196 36c4 FEFFFFEB 		bl	cmdSet
 6197              	.LVL516:
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6198              		.loc 1 1538 0
 6199 36c8 18A09DE5 		ldr	sl, [sp, #24]
1540:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6200              		.loc 1 1540 0
 6201 36cc 72E087E2 		add	lr, r7, #114
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6202              		.loc 1 1538 0
 6203 36d0 FFC00AE2 		and	ip, sl, #255
 6204 36d4 0630A0E1 		mov	r3, r6
 6205 36d8 0510A0E3 		mov	r1, #5
 6206 36dc DC20A0E3 		mov	r2, #220
 6207 36e0 7C019FE5 		ldr	r0, .L532+4
1540:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6208              		.loc 1 1540 0
 6209 36e4 20E08DE5 		str	lr, [sp, #32]
1538:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6210              		.loc 1 1538 0
 6211 36e8 00C08DE5 		str	ip, [sp, #0]
 6212 36ec 04908DE5 		str	r9, [sp, #4]
 6213 36f0 FEFFFFEB 		bl	cmdSet
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6214              		.loc 1 1539 0
 6215 36f4 1C009DE5 		ldr	r0, [sp, #28]
 6216 36f8 02E0A0E3 		mov	lr, #2
 6217 36fc FFC000E2 		and	ip, r0, #255
 6218 3700 0630A0E1 		mov	r3, r6
1541:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6219              		.loc 1 1541 0
 6220 3704 6FA047E2 		sub	sl, r7, #111
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6221              		.loc 1 1539 0
 6222 3708 0510A0E3 		mov	r1, #5
 6223 370c DE20A0E3 		mov	r2, #222
 6224 3710 4C019FE5 		ldr	r0, .L532+4
 6225 3714 04E08DE5 		str	lr, [sp, #4]
1541:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6226              		.loc 1 1541 0
 6227 3718 24A08DE5 		str	sl, [sp, #36]
1539:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6228              		.loc 1 1539 0
 6229 371c 00C08DE5 		str	ip, [sp, #0]
 6230 3720 FEFFFFEB 		bl	cmdSet
1540:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6231              		.loc 1 1540 0
 6232 3724 20A09DE5 		ldr	sl, [sp, #32]
 6233 3728 0630A0E1 		mov	r3, r6
 6234 372c FFC00AE2 		and	ip, sl, #255
 6235 3730 00C08DE5 		str	ip, [sp, #0]
 6236 3734 0510A0E3 		mov	r1, #5
 6237 3738 03C0A0E3 		mov	ip, #3
 6238 373c E020A0E3 		mov	r2, #224
 6239 3740 1C019FE5 		ldr	r0, .L532+4
 6240 3744 04C08DE5 		str	ip, [sp, #4]
 6241 3748 FEFFFFEB 		bl	cmdSet
1541:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6242              		.loc 1 1541 0
 6243 374c 24009DE5 		ldr	r0, [sp, #36]
 6244 3750 04A0A0E3 		mov	sl, #4
 6245 3754 FFC000E2 		and	ip, r0, #255
 6246 3758 0630A0E1 		mov	r3, r6
 6247 375c 0510A0E3 		mov	r1, #5
 6248 3760 DD20A0E3 		mov	r2, #221
 6249 3764 F8009FE5 		ldr	r0, .L532+4
 6250 3768 00C08DE5 		str	ip, [sp, #0]
1542:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6251              		.loc 1 1542 0
 6252 376c 7F7087E2 		add	r7, r7, #127
 6253              	.LVL517:
1541:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6254              		.loc 1 1541 0
 6255 3770 04A08DE5 		str	sl, [sp, #4]
 6256 3774 FEFFFFEB 		bl	cmdSet
1542:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6257              		.loc 1 1542 0
 6258 3778 05E0A0E3 		mov	lr, #5
 6259 377c 0E10A0E1 		mov	r1, lr
 6260 3780 0630A0E1 		mov	r3, r6
 6261 3784 E120A0E3 		mov	r2, #225
 6262 3788 FF6007E2 		and	r6, r7, #255
 6263              	.LVL518:
 6264 378c D0009FE5 		ldr	r0, .L532+4
 6265 3790 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 6266 3794 FEFFFFEB 		bl	cmdSet
 6267              	.LVL519:
1543:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6268              		.loc 1 1543 0
 6269 3798 14C09DE5 		ldr	ip, [sp, #20]
1544:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6270              		.loc 1 1544 0
 6271 379c 24E09DE5 		ldr	lr, [sp, #36]
 6272 37a0 1C609DE5 		ldr	r6, [sp, #28]
1543:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6273              		.loc 1 1543 0
 6274 37a4 05C2C4E5 		strb	ip, [r4, #517]
1544:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6275              		.loc 1 1544 0
 6276 37a8 20C09DE5 		ldr	ip, [sp, #32]
 6277 37ac 0B20A0E1 		mov	r2, fp
 6278 37b0 18309DE5 		ldr	r3, [sp, #24]
 6279 37b4 B0109FE5 		ldr	r1, .L532+12
 6280 37b8 0A00A0E1 		mov	r0, sl
 6281 37bc 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 6282 37c0 0C708DE5 		str	r7, [sp, #12]
 6283 37c4 FEFFFFEB 		bl	CyU3PDebugPrint
 6284              	.LVL520:
1548:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6285              		.loc 1 1548 0
 6286 37c8 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 6287              	.LVL521:
1549:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6288              		.loc 1 1549 0
 6289 37cc 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 6290              	.LVL522:
1550:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6291              		.loc 1 1550 0
 6292 37d0 0730A0E1 		mov	r3, r7
 6293 37d4 0610A0E3 		mov	r1, #6
 6294 37d8 8520A0E3 		mov	r2, #133
 6295 37dc 80009FE5 		ldr	r0, .L532+4
 6296 37e0 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6297 37e4 FEFFFFEB 		bl	cmdSet
1551:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6298              		.loc 1 1551 0
 6299 37e8 0730A0E1 		mov	r3, r7
 6300 37ec 0610A0E3 		mov	r1, #6
 6301 37f0 8620A0E3 		mov	r2, #134
 6302 37f4 68009FE5 		ldr	r0, .L532+4
 6303 37f8 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 6304 37fc FEFFFFEB 		bl	cmdSet
1553:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6305              		.loc 1 1553 0
 6306 3800 0620A0E1 		mov	r2, r6
 6307 3804 0530A0E1 		mov	r3, r5
 6308 3808 58109FE5 		ldr	r1, .L532+8
 6309 380c 0A00A0E1 		mov	r0, sl
1552:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6310              		.loc 1 1552 0
 6311 3810 1D62C4E5 		strb	r6, [r4, #541]
1553:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6312              		.loc 1 1553 0
 6313 3814 FEFFFFEB 		bl	CyU3PDebugPrint
 6314              	.LVL523:
1558:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6315              		.loc 1 1558 0
 6316 3818 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 6317              	.LVL524:
1559:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6318              		.loc 1 1559 0
 6319 381c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 6320 3820 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 6321 3824 0710A0E3 		mov	r1, #7
 6322 3828 34009FE5 		ldr	r0, .L532+4
 6323 382c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6324 3830 FEFFFFEB 		bl	cmdSet
 6325              	.LVL525:
1561:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6326              		.loc 1 1561 0
 6327 3834 0530A0E1 		mov	r3, r5
 6328 3838 0A00A0E1 		mov	r0, sl
 6329 383c 24109FE5 		ldr	r1, .L532+8
 6330 3840 0620A0E1 		mov	r2, r6
1560:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6331              		.loc 1 1560 0
 6332 3844 3552C4E5 		strb	r5, [r4, #565]
1561:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6333              		.loc 1 1561 0
 6334 3848 FEFFFFEB 		bl	CyU3PDebugPrint
1563:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6335              		.loc 1 1563 0
 6336 384c 10309FE5 		ldr	r3, .L532+4
 6337 3850 1C0093E5 		ldr	r0, [r3, #28]
1566:../uvc.c      **** }
 6338              		.loc 1 1566 0
 6339 3854 2CD08DE2 		add	sp, sp, #44
 6340 3858 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1563:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 6341              		.loc 1 1563 0
 6342 385c FEFFFFEA 		b	_txe_mutex_put
 6343              	.L533:
 6344              		.align	2
 6345              	.L532:
 6346 3860 00000000 		.word	.LANCHOR1
 6347 3864 00000000 		.word	cmdQu
 6348 3868 D4060000 		.word	.LC37
 6349 386c F4060000 		.word	.LC38
 6350              		.cfi_endproc
 6351              	.LFE5:
 6353              		.align	2
 6354              		.global	CyFxUVCAddHeader
 6356              	CyFxUVCAddHeader:
 6357              	.LFB6:
1574:../uvc.c      **** {
 6358              		.loc 1 1574 0
 6359              		.cfi_startproc
 6360              		@ args = 0, pretend = 0, frame = 0
 6361              		@ frame_needed = 0, uses_anonymous_args = 0
 6362              	.LVL526:
 6363 3870 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6364              	.LCFI23:
 6365              		.cfi_def_cfa_offset 16
1574:../uvc.c      **** {
 6366              		.loc 1 1574 0
 6367 3874 0040A0E1 		mov	r4, r0
 6368              		.cfi_offset 14, -4
 6369              		.cfi_offset 5, -8
 6370              		.cfi_offset 4, -12
 6371              		.cfi_offset 3, -16
 6372 3878 0150A0E1 		mov	r5, r1
1576:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6373              		.loc 1 1576 0
 6374 387c 30009FE5 		ldr	r0, .L536
 6375              	.LVL527:
 6376 3880 0010E0E3 		mvn	r1, #0
 6377              	.LVL528:
 6378 3884 FEFFFFEB 		bl	_txe_mutex_get
1577:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6379              		.loc 1 1577 0
 6380 3888 0400A0E1 		mov	r0, r4
 6381 388c 24109FE5 		ldr	r1, .L536+4
 6382 3890 0C20A0E3 		mov	r2, #12
 6383 3894 FEFFFFEB 		bl	CyU3PMemCopy
1578:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6384              		.loc 1 1578 0
 6385 3898 14009FE5 		ldr	r0, .L536
 6386 389c FEFFFFEB 		bl	_txe_mutex_put
1581:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 6387              		.loc 1 1581 0
 6388 38a0 020015E3 		tst	r5, #2
1583:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 6389              		.loc 1 1583 0
 6390 38a4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6391 38a8 02308313 		orrne	r3, r3, #2
 6392 38ac 0130C415 		strneb	r3, [r4, #1]
 6393 38b0 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6394              	.L537:
 6395              		.align	2
 6396              	.L536:
 6397 38b4 00000000 		.word	imgHdMux
 6398 38b8 80040000 		.word	.LANCHOR1+1152
 6399              		.cfi_endproc
 6400              	.LFE6:
 6402              		.align	2
 6403              		.global	CyFxAppErrorHandler
 6405              	CyFxAppErrorHandler:
 6406              	.LFB7:
1593:../uvc.c      **** {
 6407              		.loc 1 1593 0
 6408              		.cfi_startproc
 6409              		@ args = 0, pretend = 0, frame = 0
 6410              		@ frame_needed = 0, uses_anonymous_args = 0
 6411              	.LVL529:
 6412 38bc 08402DE9 		stmfd	sp!, {r3, lr}
 6413              	.LCFI24:
 6414              		.cfi_def_cfa_offset 8
 6415              	.LVL530:
 6416              	.L539:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6417              		.loc 1 1603 0 discriminator 1
 6418 38c0 10109FE5 		ldr	r1, .L540
 6419 38c4 0400A0E3 		mov	r0, #4
 6420              		.cfi_offset 14, -4
 6421              		.cfi_offset 3, -8
 6422 38c8 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 6423              		.loc 1 1604 0 discriminator 1
 6424 38cc FA0FA0E3 		mov	r0, #1000
 6425 38d0 FEFFFFEB 		bl	_tx_thread_sleep
 6426 38d4 F9FFFFEA 		b	.L539
 6427              	.L541:
 6428              		.align	2
 6429              	.L540:
 6430 38d8 D8010000 		.word	.LC12
 6431              		.cfi_endproc
 6432              	.LFE7:
 6434              		.align	2
 6435              		.global	UVCAppThread_Entry
 6437              	UVCAppThread_Entry:
 6438              	.LFB19:
2580:../uvc.c      **** {
 6439              		.loc 1 2580 0
 6440              		.cfi_startproc
 6441              		@ args = 0, pretend = 0, frame = 176
 6442              		@ frame_needed = 0, uses_anonymous_args = 0
 6443              	.LVL531:
 6444 38dc F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 6445              	.LCFI25:
 6446              		.cfi_def_cfa_offset 28
 6447 38e0 BCD04DE2 		sub	sp, sp, #188
 6448              	.LCFI26:
 6449              		.cfi_def_cfa_offset 216
 6450              	.LBB224:
 6451              	.LBB225:
2036:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 6452              		.loc 1 2036 0
 6453              		.cfi_offset 14, -4
 6454              		.cfi_offset 10, -8
 6455              		.cfi_offset 8, -12
 6456              		.cfi_offset 7, -16
 6457              		.cfi_offset 6, -20
 6458              		.cfi_offset 5, -24
 6459              		.cfi_offset 4, -28
 6460 38e4 FEFFFFEB 		bl	CyU3PUartInit
 6461              	.LVL532:
2037:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6462              		.loc 1 2037 0
 6463 38e8 004050E2 		subs	r4, r0, #0
 6464 38ec 0400000A 		beq	.L543
2039:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6465              		.loc 1 2039 0
 6466 38f0 0400A0E3 		mov	r0, #4
 6467              	.LVL533:
 6468 38f4 301B9FE5 		ldr	r1, .L647
 6469 38f8 FEFFFFEB 		bl	CyU3PDebugPrint
2040:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6470              		.loc 1 2040 0
 6471 38fc 0400A0E1 		mov	r0, r4
 6472 3900 FEFFFFEB 		bl	CyFxAppErrorHandler
 6473              	.L543:
2044:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6474              		.loc 1 2044 0
 6475 3904 24CB9FE5 		ldr	ip, .L647+4
2046:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6476              		.loc 1 2046 0
 6477 3908 0030A0E3 		mov	r3, #0
2045:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6478              		.loc 1 2045 0
 6479 390c 0120A0E3 		mov	r2, #1
2053:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6480              		.loc 1 2053 0
 6481 3910 50008DE2 		add	r0, sp, #80
 6482 3914 0310A0E1 		mov	r1, r3
2044:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6483              		.loc 1 2044 0
 6484 3918 60C08DE5 		str	ip, [sp, #96]
2045:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6485              		.loc 1 2045 0
 6486 391c 6420CDE5 		strb	r2, [sp, #100]
2046:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6487              		.loc 1 2046 0
 6488 3920 6530CDE5 		strb	r3, [sp, #101]
2047:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6489              		.loc 1 2047 0
 6490 3924 50208DE5 		str	r2, [sp, #80]
2048:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6491              		.loc 1 2048 0
 6492 3928 54308DE5 		str	r3, [sp, #84]
2049:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6493              		.loc 1 2049 0
 6494 392c 58308DE5 		str	r3, [sp, #88]
2050:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6495              		.loc 1 2050 0
 6496 3930 5C208DE5 		str	r2, [sp, #92]
2053:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6497              		.loc 1 2053 0
 6498 3934 FEFFFFEB 		bl	CyU3PUartSetConfig
 6499              	.LVL534:
2054:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6500              		.loc 1 2054 0
 6501 3938 000050E3 		cmp	r0, #0
 6502 393c 0000000A 		beq	.L544
2056:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6503              		.loc 1 2056 0
 6504 3940 FEFFFFEB 		bl	CyFxAppErrorHandler
 6505              	.LVL535:
 6506              	.L544:
2060:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 6507              		.loc 1 2060 0
 6508 3944 0000E0E3 		mvn	r0, #0
 6509 3948 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6510              	.LVL536:
2061:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6511              		.loc 1 2061 0
 6512 394c 000050E3 		cmp	r0, #0
 6513 3950 0000000A 		beq	.L545
2063:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6514              		.loc 1 2063 0
 6515 3954 FEFFFFEB 		bl	CyFxAppErrorHandler
 6516              	.LVL537:
 6517              	.L545:
2067:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 6518              		.loc 1 2067 0
 6519 3958 0300A0E3 		mov	r0, #3
 6520 395c 0410A0E3 		mov	r1, #4
 6521 3960 FEFFFFEB 		bl	CyU3PDebugInit
 6522              	.LVL538:
2068:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6523              		.loc 1 2068 0
 6524 3964 000050E3 		cmp	r0, #0
 6525 3968 0000000A 		beq	.L546
2070:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6526              		.loc 1 2070 0
 6527 396c FEFFFFEB 		bl	CyFxAppErrorHandler
 6528              	.LVL539:
 6529              	.L546:
2074:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 6530              		.loc 1 2074 0
 6531 3970 0000A0E3 		mov	r0, #0
 6532 3974 FEFFFFEB 		bl	CyU3PDebugPreamble
 6533              	.LVL540:
 6534              	.LBE225:
 6535              	.LBE224:
2596:../uvc.c      **** 		CyU3PThreadSleep(500);
 6536              		.loc 1 2596 0
 6537 3978 7D0FA0E3 		mov	r0, #500
 6538 397c FEFFFFEB 		bl	_tx_thread_sleep
 6539              	.LVL541:
 6540 3980 7D0FA0E3 		mov	r0, #500
 6541 3984 FEFFFFEB 		bl	_tx_thread_sleep
 6542 3988 7D0FA0E3 		mov	r0, #500
 6543 398c FEFFFFEB 		bl	_tx_thread_sleep
 6544 3990 7D0FA0E3 		mov	r0, #500
 6545 3994 FEFFFFEB 		bl	_tx_thread_sleep
 6546 3998 7D0FA0E3 		mov	r0, #500
 6547 399c FEFFFFEB 		bl	_tx_thread_sleep
 6548 39a0 7D0FA0E3 		mov	r0, #500
 6549 39a4 FEFFFFEB 		bl	_tx_thread_sleep
 6550              	.LBB226:
 6551              	.LBB227:
2084:../uvc.c      ****     status = CyU3PI2cInit ();
 6552              		.loc 1 2084 0
 6553 39a8 FEFFFFEB 		bl	CyU3PI2cInit
 6554              	.LVL542:
2085:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6555              		.loc 1 2085 0
 6556 39ac 004050E2 		subs	r4, r0, #0
 6557 39b0 0400000A 		beq	.L547
2087:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6558              		.loc 1 2087 0
 6559 39b4 0400A0E3 		mov	r0, #4
 6560              	.LVL543:
 6561 39b8 741A9FE5 		ldr	r1, .L647+8
 6562 39bc FEFFFFEB 		bl	CyU3PDebugPrint
2088:../uvc.c      ****         CyFxAppErrorHandler (status);
 6563              		.loc 1 2088 0
 6564 39c0 0400A0E1 		mov	r0, r4
 6565 39c4 FEFFFFEB 		bl	CyFxAppErrorHandler
 6566              	.L547:
2092:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6567              		.loc 1 2092 0
 6568 39c8 686A9FE5 		ldr	r6, .L647+12
2093:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6569              		.loc 1 2093 0
 6570 39cc 0050A0E3 		mov	r5, #0
2094:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6571              		.loc 1 2094 0
 6572 39d0 0040E0E3 		mvn	r4, #0
 6573              	.LVL544:
2097:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6574              		.loc 1 2097 0
 6575 39d4 8C008DE2 		add	r0, sp, #140
 6576 39d8 0510A0E1 		mov	r1, r5
2094:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6577              		.loc 1 2094 0
 6578 39dc 94408DE5 		str	r4, [sp, #148]
2095:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6579              		.loc 1 2095 0
 6580 39e0 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2092:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6581              		.loc 1 2092 0
 6582 39e4 8C608DE5 		str	r6, [sp, #140]
2093:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6583              		.loc 1 2093 0
 6584 39e8 90508DE5 		str	r5, [sp, #144]
2097:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6585              		.loc 1 2097 0
 6586 39ec FEFFFFEB 		bl	CyU3PI2cSetConfig
 6587              	.LVL545:
2098:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6588              		.loc 1 2098 0
 6589 39f0 004050E2 		subs	r4, r0, #0
 6590 39f4 0400000A 		beq	.L548
2100:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6591              		.loc 1 2100 0
 6592 39f8 0400A0E3 		mov	r0, #4
 6593              	.LVL546:
 6594 39fc 381A9FE5 		ldr	r1, .L647+16
 6595 3a00 FEFFFFEB 		bl	CyU3PDebugPrint
2101:../uvc.c      ****         CyFxAppErrorHandler (status);
 6596              		.loc 1 2101 0
 6597 3a04 0400A0E1 		mov	r0, r4
 6598 3a08 FEFFFFEB 		bl	CyFxAppErrorHandler
 6599              	.L548:
 6600              	.LBE227:
 6601              	.LBE226:
 6602              	.LBB228:
 6603              	.LBB231:
2171:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6604              		.loc 1 2171 0
 6605 3a0c 2C4A9FE5 		ldr	r4, .L647+20
 6606              	.LVL547:
 6607 3a10 2820A0E3 		mov	r2, #40
 6608 3a14 0010A0E3 		mov	r1, #0
 6609 3a18 0400A0E1 		mov	r0, r4
 6610 3a1c FEFFFFEB 		bl	_txe_event_flags_create
 6611              	.LVL548:
2172:../uvc.c      ****     if (apiRetStatus != 0)
 6612              		.loc 1 2172 0
 6613 3a20 002050E2 		subs	r2, r0, #0
 6614 3a24 F800001A 		bne	.L621
2186:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6615              		.loc 1 2186 0
 6616 3a28 0260A0E3 		mov	r6, #2
2193:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6617              		.loc 1 2193 0
 6618 3a2c 0210A0E1 		mov	r1, r2
2182:../uvc.c      ****     isUsbConnected = CyFalse;
 6619              		.loc 1 2182 0
 6620 3a30 302084E5 		str	r2, [r4, #48]
2183:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6621              		.loc 1 2183 0
 6622 3a34 442084E5 		str	r2, [r4, #68]
2189:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6623              		.loc 1 2189 0
 6624 3a38 0370A0E3 		mov	r7, #3
2193:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6625              		.loc 1 2193 0
 6626 3a3c 9C008DE2 		add	r0, sp, #156
 6627              	.LVL549:
2188:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6628              		.loc 1 2188 0
 6629 3a40 A420CDE5 		strb	r2, [sp, #164]
2190:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6630              		.loc 1 2190 0
 6631 3a44 A0208DE5 		str	r2, [sp, #160]
2186:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6632              		.loc 1 2186 0
 6633 3a48 9C60CDE5 		strb	r6, [sp, #156]
2187:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6634              		.loc 1 2187 0
 6635 3a4c 9D60CDE5 		strb	r6, [sp, #157]
2189:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6636              		.loc 1 2189 0
 6637 3a50 A570CDE5 		strb	r7, [sp, #165]
2193:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6638              		.loc 1 2193 0
 6639 3a54 FEFFFFEB 		bl	CyU3PGpioInit
 6640              	.LVL550:
2194:../uvc.c      ****     if (apiRetStatus != 0)
 6641              		.loc 1 2194 0
 6642 3a58 002050E2 		subs	r2, r0, #0
 6643 3a5c FC00001A 		bne	.L622
2202:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6644              		.loc 1 2202 0
 6645 3a60 1600A0E3 		mov	r0, #22
 6646              	.LVL551:
 6647 3a64 0110A0E3 		mov	r1, #1
 6648 3a68 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6649              	.LVL552:
2203:../uvc.c      ****     if (apiRetStatus != 0)
 6650              		.loc 1 2203 0
 6651 3a6c 002050E2 		subs	r2, r0, #0
 6652 3a70 EE00001A 		bne	.L623
2208:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6653              		.loc 1 2208 0
 6654 3a74 1400A0E3 		mov	r0, #20
 6655              	.LVL553:
 6656 3a78 0110A0E3 		mov	r1, #1
 6657 3a7c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6658              	.LVL554:
2209:../uvc.c      ****     if (apiRetStatus != 0)
 6659              		.loc 1 2209 0
 6660 3a80 002050E2 		subs	r2, r0, #0
 6661 3a84 FB00001A 		bne	.L624
2214:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6662              		.loc 1 2214 0
 6663 3a88 1800A0E3 		mov	r0, #24
 6664              	.LVL555:
 6665 3a8c 0110A0E3 		mov	r1, #1
 6666 3a90 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6667              	.LVL556:
2215:../uvc.c      ****     if (apiRetStatus != 0)
 6668              		.loc 1 2215 0
 6669 3a94 002050E2 		subs	r2, r0, #0
 6670 3a98 D601001A 		bne	.L625
2222:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6671              		.loc 1 2222 0
 6672 3a9c 0150A0E3 		mov	r5, #1
2227:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6673              		.loc 1 2227 0
 6674 3aa0 1600A0E3 		mov	r0, #22
 6675              	.LVL557:
 6676 3aa4 68108DE2 		add	r1, sp, #104
2225:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6677              		.loc 1 2225 0
 6678 3aa8 74208DE5 		str	r2, [sp, #116]
2226:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6679              		.loc 1 2226 0
 6680 3aac 7820CDE5 		strb	r2, [sp, #120]
2222:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6681              		.loc 1 2222 0
 6682 3ab0 68508DE5 		str	r5, [sp, #104]
2223:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6683              		.loc 1 2223 0
 6684 3ab4 6C508DE5 		str	r5, [sp, #108]
2224:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6685              		.loc 1 2224 0
 6686 3ab8 70508DE5 		str	r5, [sp, #112]
2227:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6687              		.loc 1 2227 0
 6688 3abc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6689              	.LVL558:
2228:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6690              		.loc 1 2228 0
 6691 3ac0 002050E2 		subs	r2, r0, #0
 6692 3ac4 C201001A 		bne	.L626
2241:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6693              		.loc 1 2241 0
 6694 3ac8 1400A0E3 		mov	r0, #20
 6695              	.LVL559:
 6696 3acc 68108DE2 		add	r1, sp, #104
2239:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6697              		.loc 1 2239 0
 6698 3ad0 74208DE5 		str	r2, [sp, #116]
2240:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6699              		.loc 1 2240 0
 6700 3ad4 7820CDE5 		strb	r2, [sp, #120]
2236:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6701              		.loc 1 2236 0
 6702 3ad8 68508DE5 		str	r5, [sp, #104]
2237:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6703              		.loc 1 2237 0
 6704 3adc 6C508DE5 		str	r5, [sp, #108]
2238:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6705              		.loc 1 2238 0
 6706 3ae0 70508DE5 		str	r5, [sp, #112]
2241:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6707              		.loc 1 2241 0
 6708 3ae4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6709              	.LVL560:
2242:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6710              		.loc 1 2242 0
 6711 3ae8 002050E2 		subs	r2, r0, #0
 6712 3aec CA01001A 		bne	.L627
2255:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6713              		.loc 1 2255 0
 6714 3af0 1800A0E3 		mov	r0, #24
 6715              	.LVL561:
 6716 3af4 68108DE2 		add	r1, sp, #104
2250:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6717              		.loc 1 2250 0
 6718 3af8 68208DE5 		str	r2, [sp, #104]
2251:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6719              		.loc 1 2251 0
 6720 3afc 6C208DE5 		str	r2, [sp, #108]
2252:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6721              		.loc 1 2252 0
 6722 3b00 70208DE5 		str	r2, [sp, #112]
2254:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6723              		.loc 1 2254 0
 6724 3b04 7820CDE5 		strb	r2, [sp, #120]
2253:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6725              		.loc 1 2253 0
 6726 3b08 74508DE5 		str	r5, [sp, #116]
2255:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6727              		.loc 1 2255 0
 6728 3b0c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6729              	.LVL562:
2256:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6730              		.loc 1 2256 0
 6731 3b10 002050E2 		subs	r2, r0, #0
 6732 3b14 A501001A 		bne	.L628
2268:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6733              		.loc 1 2268 0
 6734 3b18 0500A0E1 		mov	r0, r5
 6735              	.LVL563:
 6736 3b1c 7C108DE2 		add	r1, sp, #124
2265:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6737              		.loc 1 2265 0
 6738 3b20 84208DE5 		str	r2, [sp, #132]
2266:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6739              		.loc 1 2266 0
 6740 3b24 80208DE5 		str	r2, [sp, #128]
2263:../uvc.c      ****     pibclock.clkDiv      = 2;
 6741              		.loc 1 2263 0
 6742 3b28 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2264:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6743              		.loc 1 2264 0
 6744 3b2c 8870CDE5 		strb	r7, [sp, #136]
2268:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6745              		.loc 1 2268 0
 6746 3b30 FEFFFFEB 		bl	CyU3PPibInit
 6747              	.LVL564:
2269:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6748              		.loc 1 2269 0
 6749 3b34 002050E2 		subs	r2, r0, #0
 6750 3b38 9301001A 		bne	.L629
2276:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6751              		.loc 1 2276 0
 6752 3b3c 00099FE5 		ldr	r0, .L647+24
 6753              	.LVL565:
 6754 3b40 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6755              	.LVL566:
2284:../uvc.c      ****     SensorReset ();
 6756              		.loc 1 2284 0
 6757 3b44 FEFFFFEB 		bl	SensorReset
2285:../uvc.c      ****     CyU3PThreadSleep(5000);
 6758              		.loc 1 2285 0
 6759 3b48 F8089FE5 		ldr	r0, .L647+28
 6760 3b4c FEFFFFEB 		bl	_tx_thread_sleep
2289:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6761              		.loc 1 2289 0
 6762 3b50 FEFFFFEB 		bl	CyU3PUsbStart
 6763              	.LVL567:
2290:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6764              		.loc 1 2290 0
 6765 3b54 002050E2 		subs	r2, r0, #0
 6766 3b58 8201001A 		bne	.L630
2296:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6767              		.loc 1 2296 0
 6768 3b5c 0010A0E3 		mov	r1, #0
 6769 3b60 E4089FE5 		ldr	r0, .L647+32
 6770              	.LVL568:
 6771 3b64 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6772              	.LVL569:
2299:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6773              		.loc 1 2299 0
 6774 3b68 E0089FE5 		ldr	r0, .L647+36
 6775 3b6c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2305:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6776              		.loc 1 2305 0
 6777 3b70 0010A0E3 		mov	r1, #0
 6778 3b74 D8289FE5 		ldr	r2, .L647+40
 6779 3b78 0100A0E3 		mov	r0, #1
 6780 3b7c FEFFFFEB 		bl	CyU3PUsbSetDesc
2306:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6781              		.loc 1 2306 0
 6782 3b80 0000A0E3 		mov	r0, #0
 6783 3b84 0010A0E1 		mov	r1, r0
 6784 3b88 C8289FE5 		ldr	r2, .L647+44
 6785 3b8c FEFFFFEB 		bl	CyU3PUsbSetDesc
2309:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6786              		.loc 1 2309 0
 6787 3b90 0010A0E3 		mov	r1, #0
 6788 3b94 C0289FE5 		ldr	r2, .L647+48
 6789 3b98 0200A0E3 		mov	r0, #2
 6790 3b9c FEFFFFEB 		bl	CyU3PUsbSetDesc
2310:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6791              		.loc 1 2310 0
 6792 3ba0 0010A0E3 		mov	r1, #0
 6793 3ba4 B4289FE5 		ldr	r2, .L647+52
 6794 3ba8 0700A0E3 		mov	r0, #7
 6795 3bac FEFFFFEB 		bl	CyU3PUsbSetDesc
2313:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6796              		.loc 1 2313 0
 6797 3bb0 0010A0E3 		mov	r1, #0
 6798 3bb4 A8289FE5 		ldr	r2, .L647+56
 6799 3bb8 0400A0E3 		mov	r0, #4
 6800 3bbc FEFFFFEB 		bl	CyU3PUsbSetDesc
2314:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6801              		.loc 1 2314 0
 6802 3bc0 0010A0E3 		mov	r1, #0
 6803 3bc4 9C289FE5 		ldr	r2, .L647+60
 6804 3bc8 0300A0E3 		mov	r0, #3
 6805 3bcc FEFFFFEB 		bl	CyU3PUsbSetDesc
2315:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6806              		.loc 1 2315 0
 6807 3bd0 0010A0E3 		mov	r1, #0
 6808 3bd4 90289FE5 		ldr	r2, .L647+64
 6809 3bd8 0600A0E3 		mov	r0, #6
 6810 3bdc FEFFFFEB 		bl	CyU3PUsbSetDesc
2318:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6811              		.loc 1 2318 0
 6812 3be0 0010A0E3 		mov	r1, #0
 6813 3be4 84289FE5 		ldr	r2, .L647+68
 6814 3be8 0500A0E3 		mov	r0, #5
 6815 3bec FEFFFFEB 		bl	CyU3PUsbSetDesc
2319:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6816              		.loc 1 2319 0
 6817 3bf0 0110A0E3 		mov	r1, #1
 6818 3bf4 78289FE5 		ldr	r2, .L647+72
 6819 3bf8 0500A0E3 		mov	r0, #5
 6820 3bfc FEFFFFEB 		bl	CyU3PUsbSetDesc
2320:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6821              		.loc 1 2320 0
 6822 3c00 0210A0E3 		mov	r1, #2
 6823 3c04 6C289FE5 		ldr	r2, .L647+76
 6824 3c08 0500A0E3 		mov	r0, #5
 6825 3c0c FEFFFFEB 		bl	CyU3PUsbSetDesc
2330:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6826              		.loc 1 2330 0
 6827 3c10 0080A0E3 		mov	r8, #0
2327:../uvc.c      ****     endPointConfig.enable   = 1;
 6828              		.loc 1 2327 0
 6829 3c14 0150A0E3 		mov	r5, #1
2329:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6830              		.loc 1 2329 0
 6831 3c18 4070A0E3 		mov	r7, #64	@ movhi
2333:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6832              		.loc 1 2333 0
 6833 3c1c 8200A0E3 		mov	r0, #130
 6834 3c20 A8108DE2 		add	r1, sp, #168
2328:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6835              		.loc 1 2328 0
 6836 3c24 03A0A0E3 		mov	sl, #3
2329:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6837              		.loc 1 2329 0
 6838 3c28 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2327:../uvc.c      ****     endPointConfig.enable   = 1;
 6839              		.loc 1 2327 0
 6840 3c2c A8508DE5 		str	r5, [sp, #168]
2328:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6841              		.loc 1 2328 0
 6842 3c30 ACA0CDE5 		strb	sl, [sp, #172]
2330:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6843              		.loc 1 2330 0
 6844 3c34 B380CDE5 		strb	r8, [sp, #179]
2331:../uvc.c      ****     endPointConfig.streams  = 0;
 6845              		.loc 1 2331 0
 6846 3c38 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2332:../uvc.c      ****     endPointConfig.burstLen = 1;
 6847              		.loc 1 2332 0
 6848 3c3c B250CDE5 		strb	r5, [sp, #178]
2333:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6849              		.loc 1 2333 0
 6850 3c40 FEFFFFEB 		bl	CyU3PSetEpConfig
 6851              	.LVL570:
2331:../uvc.c      ****     endPointConfig.streams  = 0;
 6852              		.loc 1 2331 0
 6853 3c44 0870A0E1 		mov	r7, r8	@ movhi
2334:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6854              		.loc 1 2334 0
 6855 3c48 003050E2 		subs	r3, r0, #0
 6856 3c4c 3B01001A 		bne	.L631
2344:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6857              		.loc 1 2344 0
 6858 3c50 24C89FE5 		ldr	ip, .L647+80
2345:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6859              		.loc 1 2345 0
 6860 3c54 24E89FE5 		ldr	lr, .L647+84
2342:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6861              		.loc 1 2342 0
 6862 3c58 016BA0E3 		mov	r6, #1024	@ movhi
2351:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6863              		.loc 1 2351 0
 6864 3c5c 1080A0E3 		mov	r8, #16
2353:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6865              		.loc 1 2353 0
 6866 3c60 1C089FE5 		ldr	r0, .L647+88
 6867              	.LVL571:
 6868 3c64 0410A0E3 		mov	r1, #4
 6869 3c68 34208DE2 		add	r2, sp, #52
2342:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6870              		.loc 1 2342 0
 6871 3c6c B463CDE1 		strh	r6, [sp, #52]	@ movhi
2343:../uvc.c      ****     dmaInterConfig.count          = 1;
 6872              		.loc 1 2343 0
 6873 3c70 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2344:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6874              		.loc 1 2344 0
 6875 3c74 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2345:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6876              		.loc 1 2345 0
 6877 3c78 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2346:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6878              		.loc 1 2346 0
 6879 3c7c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2347:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6880              		.loc 1 2347 0
 6881 3c80 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2348:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6882              		.loc 1 2348 0
 6883 3c84 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2349:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6884              		.loc 1 2349 0
 6885 3c88 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2350:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6886              		.loc 1 2350 0
 6887 3c8c 4470CDE5 		strb	r7, [sp, #68]
2351:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6888              		.loc 1 2351 0
 6889 3c90 48808DE5 		str	r8, [sp, #72]
2352:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6890              		.loc 1 2352 0
 6891 3c94 4C308DE5 		str	r3, [sp, #76]
2353:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6892              		.loc 1 2353 0
 6893 3c98 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6894              	.LVL572:
2355:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6895              		.loc 1 2355 0
 6896 3c9c 006050E2 		subs	r6, r0, #0
 6897 3ca0 DF00001A 		bne	.L632
2362:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6898              		.loc 1 2362 0
 6899 3ca4 010BA0E3 		mov	r0, #1024
 6900              	.LVL573:
 6901 3ca8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6902 3cac D4179FE5 		ldr	r1, .L647+92
2363:../uvc.c      ****     if (glInterStaBuffer == 0)
 6903              		.loc 1 2363 0
 6904 3cb0 000050E3 		cmp	r0, #0
2362:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6905              		.loc 1 2362 0
 6906 3cb4 000081E5 		str	r0, [r1, #0]
2363:../uvc.c      ****     if (glInterStaBuffer == 0)
 6907              		.loc 1 2363 0
 6908 3cb8 D000000A 		beq	.L633
2370:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6909              		.loc 1 2370 0
 6910 3cbc 0610A0E1 		mov	r1, r6
 6911 3cc0 0620A0E1 		mov	r2, r6
 6912 3cc4 3830A0E3 		mov	r3, #56
 6913 3cc8 BC079FE5 		ldr	r0, .L647+96
 6914 3ccc FEFFFFEB 		bl	_txe_mutex_create
2372:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6915              		.loc 1 2372 0
 6916 3cd0 0430A0E3 		mov	r3, #4	@ movhi
 6917 3cd4 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2375:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6918              		.loc 1 2375 0
 6919 3cd8 B0379FE5 		ldr	r3, .L647+100
2371:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6920              		.loc 1 2371 0
 6921 3cdc 01C9A0E3 		mov	ip, #16384	@ movhi
 6922 3ce0 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2374:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6923              		.loc 1 2374 0
 6924 3ce4 01CCA0E3 		mov	ip, #256	@ movhi
 6925 3ce8 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2375:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6926              		.loc 1 2375 0
 6927 3cec B431CDE1 		strh	r3, [sp, #20]	@ movhi
2376:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6928              		.loc 1 2376 0
 6929 3cf0 9CC79FE5 		ldr	ip, .L647+104
2378:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6930              		.loc 1 2378 0
 6931 3cf4 0C30A0E3 		mov	r3, #12	@ movhi
 6932 3cf8 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2383:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6933              		.loc 1 2383 0
 6934 3cfc 94379FE5 		ldr	r3, .L647+108
2384:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6935              		.loc 1 2384 0
 6936 3d00 0C208DE2 		add	r2, sp, #12
2376:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6937              		.loc 1 2376 0
 6938 3d04 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2381:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6939              		.loc 1 2381 0
 6940 3d08 2A70CDE5 		strb	r7, [sp, #42]
2379:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6941              		.loc 1 2379 0
 6942 3d0c 04C0A0E3 		mov	ip, #4	@ movhi
2373:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6943              		.loc 1 2373 0
 6944 3d10 02A0A0E3 		mov	sl, #2	@ movhi
2384:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6945              		.loc 1 2384 0
 6946 3d14 80079FE5 		ldr	r0, .L647+112
 6947 3d18 0710A0E3 		mov	r1, #7
2382:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6948              		.loc 1 2382 0
 6949 3d1c 1870A0E3 		mov	r7, #24
2373:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6950              		.loc 1 2373 0
 6951 3d20 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2377:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6952              		.loc 1 2377 0
 6953 3d24 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2379:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6954              		.loc 1 2379 0
 6955 3d28 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2380:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6956              		.loc 1 2380 0
 6957 3d2c B862CDE1 		strh	r6, [sp, #40]	@ movhi
2382:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6958              		.loc 1 2382 0
 6959 3d30 2C708DE5 		str	r7, [sp, #44]
2383:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6960              		.loc 1 2383 0
 6961 3d34 30308DE5 		str	r3, [sp, #48]
2384:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6962              		.loc 1 2384 0
 6963 3d38 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6964              	.LVL574:
2386:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6965              		.loc 1 2386 0
 6966 3d3c 002050E2 		subs	r2, r0, #0
 6967 3d40 A500001A 		bne	.L634
2477:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6968              		.loc 1 2477 0
 6969 3d44 0500A0E1 		mov	r0, r5
 6970              	.LVL575:
 6971 3d48 0510A0E1 		mov	r1, r5
 6972 3d4c FEFFFFEB 		bl	CyU3PConnectState
 6973              	.LVL576:
2478:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6974              		.loc 1 2478 0
 6975 3d50 002050E2 		subs	r2, r0, #0
 6976 3d54 9700001A 		bne	.L635
2484:../uvc.c      ****     CyU3PBusyWait(100);
 6977              		.loc 1 2484 0
 6978 3d58 6400A0E3 		mov	r0, #100
 6979              	.LVL577:
 6980 3d5c FEFFFFEB 		bl	CyU3PBusyWait
 6981              	.LVL578:
2486:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6982              		.loc 1 2486 0
 6983 3d60 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2500:../uvc.c      ****     endPointConfig.streams  = 0;
 6984              		.loc 1 2500 0
 6985 3d64 0020A0E3 		mov	r2, #0	@ movhi
2489:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6986              		.loc 1 2489 0
 6987 3d68 ACA0CDE5 		strb	sl, [sp, #172]
2501:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6988              		.loc 1 2501 0
 6989 3d6c A8108DE2 		add	r1, sp, #168
2500:../uvc.c      ****     endPointConfig.streams  = 0;
 6990              		.loc 1 2500 0
 6991 3d70 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2488:../uvc.c      ****     endPointConfig.enable   = 1;
 6992              		.loc 1 2488 0
 6993 3d74 A8508DE5 		str	r5, [sp, #168]
2490:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6994              		.loc 1 2490 0
 6995 3d78 030050E3 		cmp	r0, #3
2486:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6996              		.loc 1 2486 0
 6997 3d7c 4800C4E5 		strb	r0, [r4, #72]
2497:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6998              		.loc 1 2497 0
 6999 3d80 020CA013 		movne	r0, #512	@ movhi
2492:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7000              		.loc 1 2492 0
 7001 3d84 01ABA003 		moveq	sl, #1024	@ movhi
2497:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7002              		.loc 1 2497 0
 7003 3d88 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2501:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7004              		.loc 1 2501 0
 7005 3d8c 8300A0E3 		mov	r0, #131
2492:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7006              		.loc 1 2492 0
 7007 3d90 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2493:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7008              		.loc 1 2493 0
 7009 3d94 B280CD05 		streqb	r8, [sp, #178]
2498:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7010              		.loc 1 2498 0
 7011 3d98 B250CD15 		strneb	r5, [sp, #178]
2501:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7012              		.loc 1 2501 0
 7013 3d9c FEFFFFEB 		bl	CyU3PSetEpConfig
 7014              	.LVL579:
2502:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7015              		.loc 1 2502 0
 7016 3da0 002050E2 		subs	r2, r0, #0
 7017 3da4 4F00001A 		bne	.L618
 7018 3da8 F0769FE5 		ldr	r7, .L647+116
 7019              	.LBE231:
 7020              	.LBE228:
2625:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7021              		.loc 1 2625 0
 7022 3dac 8C569FE5 		ldr	r5, .L647+20
 7023 3db0 0260A0E1 		mov	r6, r2
2809:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7024              		.loc 1 2809 0
 7025 3db4 0080E0E3 		mvn	r8, #0
 7026              	.LVL580:
 7027              	.L581:
2625:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7028              		.loc 1 2625 0
 7029 3db8 80069FE5 		ldr	r0, .L647+20
 7030 3dbc 0110A0E3 		mov	r1, #1
 7031 3dc0 0220A0E3 		mov	r2, #2
 7032 3dc4 B4308DE2 		add	r3, sp, #180
 7033 3dc8 00608DE5 		str	r6, [sp, #0]
 7034 3dcc FEFFFFEB 		bl	_txe_event_flags_get
 7035 3dd0 000050E3 		cmp	r0, #0
 7036 3dd4 3000001A 		bne	.L583
2671:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7037              		.loc 1 2671 0
 7038 3dd8 3CE095E5 		ldr	lr, [r5, #60]
 7039 3ddc 00005EE3 		cmp	lr, #0
 7040 3de0 0300000A 		beq	.L584
2671:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7041              		.loc 1 2671 0 is_stmt 0 discriminator 1
 7042 3de4 B014D5E1 		ldrh	r1, [r5, #64]
 7043 3de8 B234D5E1 		ldrh	r3, [r5, #66]
 7044 3dec 030051E1 		cmp	r1, r3
 7045 3df0 1201000A 		beq	.L636
 7046              	.L584:
2870:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7047              		.loc 1 2870 0 is_stmt 1
 7048 3df4 4010A0E3 		mov	r1, #64
 7049 3df8 0020A0E3 		mov	r2, #0
 7050 3dfc 3C069FE5 		ldr	r0, .L647+20
 7051 3e00 FEFFFFEB 		bl	_txe_event_flags_set
2873:../uvc.c      ****         CyU3PThreadRelinquish ();
 7052              		.loc 1 2873 0
 7053 3e04 FEFFFFEB 		bl	_txe_thread_relinquish
2874:../uvc.c      ****     }
 7054              		.loc 1 2874 0
 7055 3e08 EAFFFFEA 		b	.L581
 7056              	.LVL581:
 7057              	.L621:
 7058              	.LBB266:
 7059              	.LBB230:
2174:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 7060              		.loc 1 2174 0
 7061 3e0c 0400A0E3 		mov	r0, #4
 7062              	.LVL582:
 7063 3e10 8C169FE5 		ldr	r1, .L647+120
 7064 3e14 FEFFFFEB 		bl	CyU3PDebugPrint
 7065              	.LVL583:
 7066              	.L550:
 7067              	.LBB246:
 7068              	.LBB247:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7069              		.loc 1 1603 0
 7070 3e18 88169FE5 		ldr	r1, .L647+124
 7071 3e1c 0400A0E3 		mov	r0, #4
 7072 3e20 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7073              		.loc 1 1604 0
 7074 3e24 FA0FA0E3 		mov	r0, #1000
 7075 3e28 FEFFFFEB 		bl	_tx_thread_sleep
 7076 3e2c F9FFFFEA 		b	.L550
 7077              	.LVL584:
 7078              	.L623:
 7079              	.LBE247:
 7080              	.LBE246:
2205:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 7081              		.loc 1 2205 0
 7082 3e30 0400A0E3 		mov	r0, #4
 7083              	.LVL585:
 7084 3e34 70169FE5 		ldr	r1, .L647+128
 7085 3e38 FEFFFFEB 		bl	CyU3PDebugPrint
 7086              	.LVL586:
 7087              	.L554:
 7088              	.LBB244:
 7089              	.LBB245:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7090              		.loc 1 1603 0
 7091 3e3c 64169FE5 		ldr	r1, .L647+124
 7092 3e40 0400A0E3 		mov	r0, #4
 7093 3e44 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7094              		.loc 1 1604 0
 7095 3e48 FA0FA0E3 		mov	r0, #1000
 7096 3e4c FEFFFFEB 		bl	_tx_thread_sleep
 7097 3e50 F9FFFFEA 		b	.L554
 7098              	.LVL587:
 7099              	.L622:
 7100              	.LBE245:
 7101              	.LBE244:
2196:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 7102              		.loc 1 2196 0
 7103 3e54 0400A0E3 		mov	r0, #4
 7104              	.LVL588:
 7105 3e58 50169FE5 		ldr	r1, .L647+132
 7106 3e5c FEFFFFEB 		bl	CyU3PDebugPrint
 7107              	.LVL589:
 7108              	.L552:
 7109              	.LBB242:
 7110              	.LBB243:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7111              		.loc 1 1603 0
 7112 3e60 40169FE5 		ldr	r1, .L647+124
 7113 3e64 0400A0E3 		mov	r0, #4
 7114 3e68 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7115              		.loc 1 1604 0
 7116 3e6c FA0FA0E3 		mov	r0, #1000
 7117 3e70 FEFFFFEB 		bl	_tx_thread_sleep
 7118 3e74 F9FFFFEA 		b	.L552
 7119              	.LVL590:
 7120              	.L624:
 7121              	.LBE243:
 7122              	.LBE242:
2211:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 7123              		.loc 1 2211 0
 7124 3e78 0400A0E3 		mov	r0, #4
 7125              	.LVL591:
 7126 3e7c 30169FE5 		ldr	r1, .L647+136
 7127 3e80 FEFFFFEB 		bl	CyU3PDebugPrint
 7128              	.LVL592:
 7129              	.L556:
 7130              	.LBB240:
 7131              	.LBB241:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7132              		.loc 1 1603 0
 7133 3e84 1C169FE5 		ldr	r1, .L647+124
 7134 3e88 0400A0E3 		mov	r0, #4
 7135 3e8c FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7136              		.loc 1 1604 0
 7137 3e90 FA0FA0E3 		mov	r0, #1000
 7138 3e94 FEFFFFEB 		bl	_tx_thread_sleep
 7139 3e98 F9FFFFEA 		b	.L556
 7140              	.LVL593:
 7141              	.L583:
 7142              	.LBE241:
 7143              	.LBE240:
 7144              	.LBE230:
 7145              	.LBE266:
2777:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 7146              		.loc 1 2777 0
 7147 3e9c 9C059FE5 		ldr	r0, .L647+20
 7148 3ea0 0210A0E3 		mov	r1, #2
 7149 3ea4 0320A0E3 		mov	r2, #3
 7150 3ea8 B4308DE2 		add	r3, sp, #180
 7151 3eac 00608DE5 		str	r6, [sp, #0]
 7152 3eb0 FEFFFFEB 		bl	_txe_event_flags_get
 7153 3eb4 000050E3 		cmp	r0, #0
 7154 3eb8 2500001A 		bne	.L599
2792:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7155              		.loc 1 2792 0
 7156 3ebc 441095E5 		ldr	r1, [r5, #68]
2780:../uvc.c      ****                 hitFV     = CyFalse;
 7157              		.loc 1 2780 0
 7158 3ec0 3C6085E5 		str	r6, [r5, #60]
2792:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7159              		.loc 1 2792 0
 7160 3ec4 000051E3 		cmp	r1, #0
2781:../uvc.c      ****                 prodCount = 0;
 7161              		.loc 1 2781 0
 7162 3ec8 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2788:../uvc.c      ****                 fb=0;
 7163              		.loc 1 2788 0
 7164 3ecc B463C5E1 		strh	r6, [r5, #52]	@ movhi
2782:../uvc.c      ****                 consCount = 0;
 7165              		.loc 1 2782 0
 7166 3ed0 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2789:../uvc.c      ****                 pb=0;
 7167              		.loc 1 2789 0
 7168 3ed4 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2790:../uvc.c      ****                 pbc=0;
 7169              		.loc 1 2790 0
 7170 3ed8 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2792:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7171              		.loc 1 2792 0
 7172 3edc 0A00000A 		beq	.L637
 7173              	.L600:
2804:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 7174              		.loc 1 2804 0
 7175 3ee0 446084E5 		str	r6, [r4, #68]
 7176 3ee4 C2FFFFEA 		b	.L584
 7177              	.LVL594:
 7178              	.L618:
 7179              	.LBB267:
 7180              	.LBB264:
2505:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7181              		.loc 1 2505 0
 7182 3ee8 0400A0E3 		mov	r0, #4
 7183              	.LVL595:
 7184 3eec C4159FE5 		ldr	r1, .L647+140
 7185 3ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 7186              	.LVL596:
 7187              	.L582:
 7188              	.LBB248:
 7189              	.LBB249:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7190              		.loc 1 1603 0
 7191 3ef4 AC159FE5 		ldr	r1, .L647+124
 7192 3ef8 0400A0E3 		mov	r0, #4
 7193 3efc FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7194              		.loc 1 1604 0
 7195 3f00 FA0FA0E3 		mov	r0, #1000
 7196 3f04 FEFFFFEB 		bl	_tx_thread_sleep
 7197 3f08 F9FFFFEA 		b	.L582
 7198              	.LVL597:
 7199              	.L637:
 7200              	.LBE249:
 7201              	.LBE248:
 7202              	.LBE264:
 7203              	.LBE267:
2794:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7204              		.loc 1 2794 0
 7205 3f0c 88059FE5 		ldr	r0, .L647+112
 7206 3f10 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7207              	.LVL598:
2795:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7208              		.loc 1 2795 0
 7209 3f14 000050E3 		cmp	r0, #0
 7210 3f18 0200001A 		bne	.L619
2801:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 7211              		.loc 1 2801 0
 7212 3f1c 8300A0E3 		mov	r0, #131
 7213              	.LVL599:
 7214 3f20 FEFFFFEB 		bl	CyU3PUsbFlushEp
 7215 3f24 EDFFFFEA 		b	.L600
 7216              	.L619:
 7217              	.LBB268:
 7218              	.LBB269:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7219              		.loc 1 1603 0
 7220 3f28 78159FE5 		ldr	r1, .L647+124
 7221 3f2c 0400A0E3 		mov	r0, #4
 7222 3f30 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7223              		.loc 1 1604 0
 7224 3f34 FA0FA0E3 		mov	r0, #1000
 7225 3f38 FEFFFFEB 		bl	_tx_thread_sleep
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7226              		.loc 1 1603 0
 7227 3f3c 64159FE5 		ldr	r1, .L647+124
 7228 3f40 0400A0E3 		mov	r0, #4
 7229 3f44 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7230              		.loc 1 1604 0
 7231 3f48 FA0FA0E3 		mov	r0, #1000
 7232 3f4c FEFFFFEB 		bl	_tx_thread_sleep
 7233 3f50 F4FFFFEA 		b	.L619
 7234              	.L599:
 7235              	.LBE269:
 7236              	.LBE268:
2809:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7237              		.loc 1 2809 0
 7238 3f54 0110A0E3 		mov	r1, #1
 7239 3f58 0220A0E3 		mov	r2, #2
 7240 3f5c B4308DE2 		add	r3, sp, #180
 7241 3f60 D8049FE5 		ldr	r0, .L647+20
 7242 3f64 00808DE5 		str	r8, [sp, #0]
 7243 3f68 FEFFFFEB 		bl	_txe_event_flags_get
2813:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7244              		.loc 1 2813 0
 7245 3f6c 0620A0E1 		mov	r2, r6
 7246 3f70 24059FE5 		ldr	r0, .L647+112
 7247 3f74 0610A0E1 		mov	r1, r6
 7248 3f78 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7249              	.LVL600:
2814:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7250              		.loc 1 2814 0
 7251 3f7c 002050E2 		subs	r2, r0, #0
 7252 3f80 6500001A 		bne	.L638
2822:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7253              		.loc 1 2822 0
 7254 3f84 282095E5 		ldr	r2, [r5, #40]
 7255 3f88 000052E3 		cmp	r2, #0
 7256 3f8c 5A00001A 		bne	.L605
 7257              	.LVL601:
 7258              	.LBB270:
 7259              	.LBB271:
2530:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7260              		.loc 1 2530 0
 7261 3f90 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 7262 3f94 030053E3 		cmp	r3, #3
 7263 3f98 4700000A 		beq	.L639
2535:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7264              		.loc 1 2535 0
 7265 3f9c 020053E3 		cmp	r3, #2
 7266 3fa0 2900000A 		beq	.L640
 7267              	.LVL602:
 7268              	.L608:
 7269              	.LBE271:
 7270              	.LBE270:
2858:../uvc.c      ****                     gpif_initialized = CyTrue;
 7271              		.loc 1 2858 0
 7272 3fa4 01E0A0E3 		mov	lr, #1
 7273 3fa8 28E084E5 		str	lr, [r4, #40]
2859:../uvc.c      ****                     CyU3PThreadSleep(200);
 7274              		.loc 1 2859 0
 7275 3fac C800A0E3 		mov	r0, #200
 7276 3fb0 FEFFFFEB 		bl	_tx_thread_sleep
 7277 3fb4 8EFFFFEA 		b	.L584
 7278              	.LVL603:
 7279              	.L635:
 7280              	.LBB277:
 7281              	.LBB229:
2480:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 7282              		.loc 1 2480 0
 7283 3fb8 0400A0E3 		mov	r0, #4
 7284              	.LVL604:
 7285 3fbc F8149FE5 		ldr	r1, .L647+144
 7286 3fc0 FEFFFFEB 		bl	CyU3PDebugPrint
 7287              	.LVL605:
 7288              	.L578:
 7289              	.LBB238:
 7290              	.LBB239:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7291              		.loc 1 1603 0
 7292 3fc4 DC149FE5 		ldr	r1, .L647+124
 7293 3fc8 0400A0E3 		mov	r0, #4
 7294 3fcc FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7295              		.loc 1 1604 0
 7296 3fd0 FA0FA0E3 		mov	r0, #1000
 7297 3fd4 FEFFFFEB 		bl	_tx_thread_sleep
 7298 3fd8 F9FFFFEA 		b	.L578
 7299              	.LVL606:
 7300              	.L634:
 7301              	.LBE239:
 7302              	.LBE238:
2389:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 7303              		.loc 1 2389 0
 7304 3fdc 0400A0E3 		mov	r0, #4
 7305              	.LVL607:
 7306 3fe0 D8149FE5 		ldr	r1, .L647+148
 7307 3fe4 FEFFFFEB 		bl	CyU3PDebugPrint
 7308              	.LVL608:
 7309              	.L576:
 7310              	.LBB236:
 7311              	.LBB237:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7312              		.loc 1 1603 0
 7313 3fe8 B8149FE5 		ldr	r1, .L647+124
 7314 3fec 0400A0E3 		mov	r0, #4
 7315 3ff0 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7316              		.loc 1 1604 0
 7317 3ff4 FA0FA0E3 		mov	r0, #1000
 7318 3ff8 FEFFFFEB 		bl	_tx_thread_sleep
 7319 3ffc F9FFFFEA 		b	.L576
 7320              	.LVL609:
 7321              	.L633:
 7322              	.LBE237:
 7323              	.LBE236:
2365:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 7324              		.loc 1 2365 0
 7325 4000 040080E2 		add	r0, r0, #4
 7326 4004 B8149FE5 		ldr	r1, .L647+152
 7327 4008 FEFFFFEB 		bl	CyU3PDebugPrint
 7328              	.LVL610:
 7329              	.L574:
 7330              	.LBB234:
 7331              	.LBB235:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7332              		.loc 1 1603 0
 7333 400c 94149FE5 		ldr	r1, .L647+124
 7334 4010 0400A0E3 		mov	r0, #4
 7335 4014 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7336              		.loc 1 1604 0
 7337 4018 FA0FA0E3 		mov	r0, #1000
 7338 401c FEFFFFEB 		bl	_tx_thread_sleep
 7339 4020 F9FFFFEA 		b	.L574
 7340              	.LVL611:
 7341              	.L632:
 7342              	.LBE235:
 7343              	.LBE234:
2358:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 7344              		.loc 1 2358 0
 7345 4024 0400A0E3 		mov	r0, #4
 7346 4028 98149FE5 		ldr	r1, .L647+156
 7347 402c 0620A0E1 		mov	r2, r6
 7348 4030 FEFFFFEB 		bl	CyU3PDebugPrint
 7349              	.L572:
 7350              	.LBB232:
 7351              	.LBB233:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7352              		.loc 1 1603 0
 7353 4034 6C149FE5 		ldr	r1, .L647+124
 7354 4038 0400A0E3 		mov	r0, #4
 7355 403c FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7356              		.loc 1 1604 0
 7357 4040 FA0FA0E3 		mov	r0, #1000
 7358 4044 FEFFFFEB 		bl	_tx_thread_sleep
 7359 4048 F9FFFFEA 		b	.L572
 7360              	.LVL612:
 7361              	.L640:
 7362              	.LBE233:
 7363              	.LBE232:
 7364              	.LBE229:
 7365              	.LBE277:
 7366              	.LBB278:
 7367              	.LBB276:
2537:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7368              		.loc 1 2537 0
 7369 404c 78149FE5 		ldr	r1, .L647+160
 7370 4050 0100A0E3 		mov	r0, #1
 7371              	.LVL613:
 7372 4054 FEFFFFEB 		bl	CyU3PDebugPrint
2538:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7373              		.loc 1 2538 0
 7374 4058 70049FE5 		ldr	r0, .L647+164
 7375 405c FEFFFFEB 		bl	CyU3PGpifLoad
 7376 4060 0020A0E1 		mov	r2, r0
 7377              	.LVL614:
 7378              	.L607:
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7379              		.loc 1 2540 0
 7380 4064 000052E3 		cmp	r2, #0
 7381 4068 1A00001A 		bne	.L641
2548:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7382              		.loc 1 2548 0
 7383 406c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7384 4070 030053E3 		cmp	r3, #3
 7385 4074 0100000A 		beq	.L620
2552:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7386              		.loc 1 2552 0
 7387 4078 020053E3 		cmp	r3, #2
 7388 407c C8FFFF1A 		bne	.L608
 7389              	.L620:
2554:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7390              		.loc 1 2554 0
 7391 4080 0200A0E1 		mov	r0, r2
 7392              	.LVL615:
 7393 4084 0210A0E1 		mov	r1, r2
 7394 4088 FEFFFFEB 		bl	CyU3PGpifSMStart
 7395              	.LVL616:
2556:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7396              		.loc 1 2556 0
 7397 408c 000050E3 		cmp	r0, #0
2554:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7398              		.loc 1 2554 0
 7399 4090 0020A0E1 		mov	r2, r0
 7400              	.LVL617:
2556:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7401              		.loc 1 2556 0
 7402 4094 C2FFFF0A 		beq	.L608
2559:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7403              		.loc 1 2559 0
 7404 4098 0400A0E3 		mov	r0, #4
 7405              	.LVL618:
 7406 409c 30149FE5 		ldr	r1, .L647+168
 7407 40a0 FEFFFFEB 		bl	CyU3PDebugPrint
 7408              	.LVL619:
 7409              	.L613:
 7410              	.LBB272:
 7411              	.LBB273:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7412              		.loc 1 1603 0
 7413 40a4 FC139FE5 		ldr	r1, .L647+124
 7414 40a8 0400A0E3 		mov	r0, #4
 7415 40ac FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7416              		.loc 1 1604 0
 7417 40b0 FA0FA0E3 		mov	r0, #1000
 7418 40b4 FEFFFFEB 		bl	_tx_thread_sleep
 7419 40b8 F9FFFFEA 		b	.L613
 7420              	.LVL620:
 7421              	.L639:
 7422              	.LBE273:
 7423              	.LBE272:
2532:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7424              		.loc 1 2532 0
 7425 40bc 14149FE5 		ldr	r1, .L647+172
 7426 40c0 0100A0E3 		mov	r0, #1
 7427              	.LVL621:
 7428 40c4 FEFFFFEB 		bl	CyU3PDebugPrint
2533:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7429              		.loc 1 2533 0
 7430 40c8 0C049FE5 		ldr	r0, .L647+176
 7431 40cc FEFFFFEB 		bl	CyU3PGpifLoad
 7432 40d0 0020A0E1 		mov	r2, r0
 7433              	.LVL622:
 7434 40d4 E2FFFFEA 		b	.L607
 7435              	.L641:
2543:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7436              		.loc 1 2543 0
 7437 40d8 0400A0E3 		mov	r0, #4
 7438              	.LVL623:
 7439 40dc FC139FE5 		ldr	r1, .L647+180
 7440 40e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7441              	.LVL624:
 7442              	.L610:
 7443              	.LBB274:
 7444              	.LBB275:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7445              		.loc 1 1603 0
 7446 40e4 BC139FE5 		ldr	r1, .L647+124
 7447 40e8 0400A0E3 		mov	r0, #4
 7448 40ec FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7449              		.loc 1 1604 0
 7450 40f0 FA0FA0E3 		mov	r0, #1000
 7451 40f4 FEFFFFEB 		bl	_tx_thread_sleep
 7452 40f8 F9FFFFEA 		b	.L610
 7453              	.LVL625:
 7454              	.L605:
 7455              	.LBE275:
 7456              	.LBE274:
 7457              	.LBE276:
 7458              	.LBE278:
2866:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7459              		.loc 1 2866 0
 7460 40fc 8C039FE5 		ldr	r0, .L647+100
 7461              	.LVL626:
 7462 4100 02C0A0E3 		mov	ip, #2
 7463 4104 0610A0E1 		mov	r1, r6
 7464 4108 0020A0E1 		mov	r2, r0
 7465 410c 0630A0E1 		mov	r3, r6
 7466 4110 00C08DE5 		str	ip, [sp, #0]
 7467 4114 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7468 4118 35FFFFEA 		b	.L584
 7469              	.LVL627:
 7470              	.L638:
2817:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7471              		.loc 1 2817 0
 7472 411c 0400A0E3 		mov	r0, #4
 7473              	.LVL628:
 7474 4120 BC139FE5 		ldr	r1, .L647+184
 7475 4124 FEFFFFEB 		bl	CyU3PDebugPrint
 7476              	.LVL629:
 7477              	.L604:
 7478              	.LBB279:
 7479              	.LBB280:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7480              		.loc 1 1603 0
 7481 4128 78139FE5 		ldr	r1, .L647+124
 7482 412c 0400A0E3 		mov	r0, #4
 7483 4130 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7484              		.loc 1 1604 0
 7485 4134 FA0FA0E3 		mov	r0, #1000
 7486 4138 FEFFFFEB 		bl	_tx_thread_sleep
 7487 413c F9FFFFEA 		b	.L604
 7488              	.LVL630:
 7489              	.L631:
 7490              	.LBE280:
 7491              	.LBE279:
 7492              	.LBB281:
 7493              	.LBB265:
2337:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7494              		.loc 1 2337 0
 7495 4140 0400A0E3 		mov	r0, #4
 7496              	.LVL631:
 7497 4144 6C139FE5 		ldr	r1, .L647+140
 7498 4148 0320A0E1 		mov	r2, r3
 7499 414c FEFFFFEB 		bl	CyU3PDebugPrint
 7500              	.LVL632:
 7501              	.L570:
 7502              	.LBB250:
 7503              	.LBB251:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7504              		.loc 1 1603 0
 7505 4150 50139FE5 		ldr	r1, .L647+124
 7506 4154 0400A0E3 		mov	r0, #4
 7507 4158 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7508              		.loc 1 1604 0
 7509 415c FA0FA0E3 		mov	r0, #1000
 7510 4160 FEFFFFEB 		bl	_tx_thread_sleep
 7511 4164 F9FFFFEA 		b	.L570
 7512              	.LVL633:
 7513              	.L630:
 7514              	.LBE251:
 7515              	.LBE250:
2292:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7516              		.loc 1 2292 0
 7517 4168 0400A0E3 		mov	r0, #4
 7518              	.LVL634:
 7519 416c 74139FE5 		ldr	r1, .L647+188
 7520 4170 FEFFFFEB 		bl	CyU3PDebugPrint
 7521              	.LVL635:
 7522              	.L568:
 7523              	.LBB252:
 7524              	.LBB253:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7525              		.loc 1 1603 0
 7526 4174 2C139FE5 		ldr	r1, .L647+124
 7527 4178 0400A0E3 		mov	r0, #4
 7528 417c FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7529              		.loc 1 1604 0
 7530 4180 FA0FA0E3 		mov	r0, #1000
 7531 4184 FEFFFFEB 		bl	_tx_thread_sleep
 7532 4188 F9FFFFEA 		b	.L568
 7533              	.LVL636:
 7534              	.L629:
 7535              	.LBE253:
 7536              	.LBE252:
2271:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7537              		.loc 1 2271 0
 7538 418c 0400A0E3 		mov	r0, #4
 7539              	.LVL637:
 7540 4190 54139FE5 		ldr	r1, .L647+192
 7541 4194 FEFFFFEB 		bl	CyU3PDebugPrint
 7542              	.LVL638:
 7543              	.L566:
 7544              	.LBB254:
 7545              	.LBB255:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7546              		.loc 1 1603 0
 7547 4198 08139FE5 		ldr	r1, .L647+124
 7548 419c 0400A0E3 		mov	r0, #4
 7549 41a0 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7550              		.loc 1 1604 0
 7551 41a4 FA0FA0E3 		mov	r0, #1000
 7552 41a8 FEFFFFEB 		bl	_tx_thread_sleep
 7553 41ac F9FFFFEA 		b	.L566
 7554              	.LVL639:
 7555              	.L628:
 7556              	.LBE255:
 7557              	.LBE254:
2258:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7558              		.loc 1 2258 0
 7559 41b0 0400A0E3 		mov	r0, #4
 7560              	.LVL640:
 7561 41b4 34139FE5 		ldr	r1, .L647+196
 7562 41b8 FEFFFFEB 		bl	CyU3PDebugPrint
 7563              	.LVL641:
 7564              	.L564:
 7565              	.LBB256:
 7566              	.LBB257:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7567              		.loc 1 1603 0
 7568 41bc E4129FE5 		ldr	r1, .L647+124
 7569 41c0 0400A0E3 		mov	r0, #4
 7570 41c4 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7571              		.loc 1 1604 0
 7572 41c8 FA0FA0E3 		mov	r0, #1000
 7573 41cc FEFFFFEB 		bl	_tx_thread_sleep
 7574 41d0 F9FFFFEA 		b	.L564
 7575              	.LVL642:
 7576              	.L626:
 7577              	.LBE257:
 7578              	.LBE256:
2230:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7579              		.loc 1 2230 0
 7580 41d4 0400A0E3 		mov	r0, #4
 7581              	.LVL643:
 7582 41d8 14139FE5 		ldr	r1, .L647+200
 7583 41dc FEFFFFEB 		bl	CyU3PDebugPrint
 7584              	.LVL644:
 7585              	.L560:
 7586              	.LBB258:
 7587              	.LBB259:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7588              		.loc 1 1603 0
 7589 41e0 C0129FE5 		ldr	r1, .L647+124
 7590 41e4 0400A0E3 		mov	r0, #4
 7591 41e8 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7592              		.loc 1 1604 0
 7593 41ec FA0FA0E3 		mov	r0, #1000
 7594 41f0 FEFFFFEB 		bl	_tx_thread_sleep
 7595 41f4 F9FFFFEA 		b	.L560
 7596              	.LVL645:
 7597              	.L625:
 7598              	.LBE259:
 7599              	.LBE258:
2217:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7600              		.loc 1 2217 0
 7601 41f8 0400A0E3 		mov	r0, #4
 7602              	.LVL646:
 7603 41fc F4129FE5 		ldr	r1, .L647+204
 7604 4200 FEFFFFEB 		bl	CyU3PDebugPrint
 7605              	.LVL647:
 7606              	.L558:
 7607              	.LBB260:
 7608              	.LBB261:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7609              		.loc 1 1603 0
 7610 4204 9C129FE5 		ldr	r1, .L647+124
 7611 4208 0400A0E3 		mov	r0, #4
 7612 420c FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7613              		.loc 1 1604 0
 7614 4210 FA0FA0E3 		mov	r0, #1000
 7615 4214 FEFFFFEB 		bl	_tx_thread_sleep
 7616 4218 F9FFFFEA 		b	.L558
 7617              	.LVL648:
 7618              	.L627:
 7619              	.LBE261:
 7620              	.LBE260:
2244:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 7621              		.loc 1 2244 0
 7622 421c 0400A0E3 		mov	r0, #4
 7623              	.LVL649:
 7624 4220 D4129FE5 		ldr	r1, .L647+208
 7625 4224 FEFFFFEB 		bl	CyU3PDebugPrint
 7626              	.LVL650:
 7627              	.L562:
 7628              	.LBB262:
 7629              	.LBB263:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7630              		.loc 1 1603 0
 7631 4228 78129FE5 		ldr	r1, .L647+124
 7632 422c 0400A0E3 		mov	r0, #4
 7633 4230 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7634              		.loc 1 1604 0
 7635 4234 FA0FA0E3 		mov	r0, #1000
 7636 4238 FEFFFFEB 		bl	_tx_thread_sleep
 7637 423c F9FFFFEA 		b	.L562
 7638              	.LVL651:
 7639              	.L636:
 7640              	.LBE263:
 7641              	.LBE262:
 7642              	.LBE265:
 7643              	.LBE281:
2681:../uvc.c      ****                 prodCount = 0;
 7644              		.loc 1 2681 0
 7645 4240 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2696:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7646              		.loc 1 2696 0
 7647 4244 40029FE5 		ldr	r0, .L647+96
2682:../uvc.c      ****                 consCount = 0;
 7648              		.loc 1 2682 0
 7649 4248 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2696:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7650              		.loc 1 2696 0
 7651 424c 0010E0E3 		mvn	r1, #0
2678:../uvc.c      ****             	fb=0;
 7652              		.loc 1 2678 0
 7653 4250 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2679:../uvc.c      ****             	pb=0;
 7654              		.loc 1 2679 0
 7655 4254 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2680:../uvc.c      ****             	pbc=0;
 7656              		.loc 1 2680 0
 7657 4258 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2683:../uvc.c      ****                 hitFV     = CyFalse;
 7658              		.loc 1 2683 0
 7659 425c 3C6085E5 		str	r6, [r5, #60]
2696:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7660              		.loc 1 2696 0
 7661 4260 FEFFFFEB 		bl	_txe_mutex_get
2697:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7662              		.loc 1 2697 0
 7663 4264 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7664 4268 012020E2 		eor	r2, r0, #1
 7665 426c 8124C7E5 		strb	r2, [r7, #1153]
2699:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7666              		.loc 1 2699 0
 7667 4270 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7668 4274 F0005CE3 		cmp	ip, #240
 7669 4278 1800000A 		beq	.L642
 7670              	.L585:
2707:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7671              		.loc 1 2707 0
 7672 427c 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7673 4280 FF005AE3 		cmp	sl, #255
 7674 4284 5C00000A 		beq	.L643
2719:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7675              		.loc 1 2719 0
 7676 4288 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7677 428c AA0050E3 		cmp	r0, #170
 7678 4290 2F00000A 		beq	.L644
 7679              	.L586:
2752:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7680              		.loc 1 2752 0
 7681 4294 F0019FE5 		ldr	r0, .L647+96
 7682 4298 FEFFFFEB 		bl	_txe_mutex_put
2754:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7683              		.loc 1 2754 0
 7684 429c F8019FE5 		ldr	r0, .L647+112
 7685 42a0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7686              	.LVL652:
2755:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7687              		.loc 1 2755 0
 7688 42a4 002050E2 		subs	r2, r0, #0
 7689 42a8 2000001A 		bne	.L645
2762:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7690              		.loc 1 2762 0
 7691 42ac 0210A0E1 		mov	r1, r2
 7692 42b0 E4019FE5 		ldr	r0, .L647+112
 7693              	.LVL653:
 7694 42b4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7695              	.LVL654:
2763:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7696              		.loc 1 2763 0
 7697 42b8 002050E2 		subs	r2, r0, #0
 7698 42bc 1200001A 		bne	.L646
2771:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7699              		.loc 1 2771 0
 7700 42c0 C8019FE5 		ldr	r0, .L647+100
 7701              	.LVL655:
 7702 42c4 0210A0E1 		mov	r1, r2
 7703 42c8 02A0A0E3 		mov	sl, #2
 7704 42cc 0020A0E1 		mov	r2, r0
 7705              	.LVL656:
 7706 42d0 0130A0E1 		mov	r3, r1
 7707 42d4 00A08DE5 		str	sl, [sp, #0]
 7708 42d8 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7709              	.LVL657:
 7710 42dc C4FEFFEA 		b	.L584
 7711              	.L642:
2699:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7712              		.loc 1 2699 0 discriminator 1
 7713 42e0 58019FE5 		ldr	r0, .L647+20
 7714 42e4 8010A0E3 		mov	r1, #128
 7715 42e8 0320A0E3 		mov	r2, #3
 7716 42ec B4308DE2 		add	r3, sp, #180
 7717 42f0 00608DE5 		str	r6, [sp, #0]
 7718 42f4 FEFFFFEB 		bl	_txe_event_flags_get
 7719 42f8 000050E3 		cmp	r0, #0
2704:../uvc.c      ****                 		stiflag = 0xFF;
 7720              		.loc 1 2704 0 discriminator 1
 7721 42fc 3A80C505 		streqb	r8, [r5, #58]
2705:../uvc.c      ****                 		IMcount = 0;
 7722              		.loc 1 2705 0 discriminator 1
 7723 4300 A160C505 		streqb	r6, [r5, #161]
2699:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7724              		.loc 1 2699 0 discriminator 1
 7725 4304 E2FFFF0A 		beq	.L586
 7726 4308 DBFFFFEA 		b	.L585
 7727              	.LVL658:
 7728              	.L646:
2765:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7729              		.loc 1 2765 0
 7730 430c 0400A0E3 		mov	r0, #4
 7731              	.LVL659:
 7732 4310 E8119FE5 		ldr	r1, .L647+212
 7733 4314 FEFFFFEB 		bl	CyU3PDebugPrint
 7734              	.LVL660:
 7735              	.L598:
 7736              	.LBB282:
 7737              	.LBB283:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7738              		.loc 1 1603 0
 7739 4318 88119FE5 		ldr	r1, .L647+124
 7740 431c 0400A0E3 		mov	r0, #4
 7741 4320 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7742              		.loc 1 1604 0
 7743 4324 FA0FA0E3 		mov	r0, #1000
 7744 4328 FEFFFFEB 		bl	_tx_thread_sleep
 7745 432c F9FFFFEA 		b	.L598
 7746              	.LVL661:
 7747              	.L645:
 7748              	.LBE283:
 7749              	.LBE282:
2757:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7750              		.loc 1 2757 0
 7751 4330 0400A0E3 		mov	r0, #4
 7752              	.LVL662:
 7753 4334 C8119FE5 		ldr	r1, .L647+216
 7754 4338 FEFFFFEB 		bl	CyU3PDebugPrint
 7755              	.LVL663:
 7756              	.L596:
 7757              	.LBB284:
 7758              	.LBB285:
1603:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7759              		.loc 1 1603 0
 7760 433c 64119FE5 		ldr	r1, .L647+124
 7761 4340 0400A0E3 		mov	r0, #4
 7762 4344 FEFFFFEB 		bl	CyU3PDebugPrint
1604:../uvc.c      ****         CyU3PThreadSleep (1000);
 7763              		.loc 1 1604 0
 7764 4348 FA0FA0E3 		mov	r0, #1000
 7765 434c FEFFFFEB 		bl	_tx_thread_sleep
 7766 4350 F9FFFFEA 		b	.L596
 7767              	.L644:
 7768              	.LBE285:
 7769              	.LBE284:
2725:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 7770              		.loc 1 2725 0
 7771 4354 A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 7772 4358 01A08EE2 		add	sl, lr, #1
 7773 435c 02005EE3 		cmp	lr, #2
 7774 4360 A1A0C5E5 		strb	sl, [r5, #161]
 7775 4364 CAFFFF9A 		bls	.L586
2727:../uvc.c      ****                     switch (setRes)
 7776              		.loc 1 2727 0
 7777 4368 7D00D5E5 		ldrb	r0, [r5, #125]	@ zero_extendqisi2
 7778 436c 020050E3 		cmp	r0, #2
 7779 4370 1800000A 		beq	.L590
 7780 4374 030050E3 		cmp	r0, #3
 7781 4378 0B00000A 		beq	.L591
 7782 437c 010050E3 		cmp	r0, #1
 7783 4380 0600001A 		bne	.L588
2730:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 7784              		.loc 1 2730 0
 7785 4384 582095E5 		ldr	r2, [r5, #88]
 7786 4388 3010A0E3 		mov	r1, #48
 7787 438c 000052E3 		cmp	r2, #0
 7788 4390 E420A003 		moveq	r2, #228
 7789 4394 6420A013 		movne	r2, #100
 7790 4398 5230A0E3 		mov	r3, #82
 7791 439c FEFFFFEB 		bl	SensorSetIrisControl
 7792              	.L588:
2747:../uvc.c      ****                     IMcount = 0;
 7793              		.loc 1 2747 0
 7794 43a0 A160C4E5 		strb	r6, [r4, #161]
2749:../uvc.c      ****                 	stiflag = 0x0;
 7795              		.loc 1 2749 0
 7796 43a4 3A60C4E5 		strb	r6, [r4, #58]
 7797 43a8 B9FFFFEA 		b	.L586
 7798              	.L591:
2740:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 7799              		.loc 1 2740 0
 7800 43ac 58C095E5 		ldr	ip, [r5, #88]
 7801 43b0 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 7802 43b4 00005CE3 		cmp	ip, #0
 7803 43b8 C4C0A003 		moveq	ip, #196
 7804 43bc 44C0A013 		movne	ip, #68
 7805 43c0 03208CE1 		orr	r2, ip, r3
 7806 43c4 3010A0E3 		mov	r1, #48
 7807 43c8 5230A0E3 		mov	r3, #82
 7808 43cc 0100A0E3 		mov	r0, #1
 7809 43d0 FEFFFFEB 		bl	SensorSetIrisControl
2743:../uvc.c      ****                  		break;
 7810              		.loc 1 2743 0
 7811 43d4 F1FFFFEA 		b	.L588
 7812              	.L590:
2735:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 7813              		.loc 1 2735 0
 7814 43d8 582095E5 		ldr	r2, [r5, #88]
 7815 43dc 3010A0E3 		mov	r1, #48
 7816 43e0 000052E3 		cmp	r2, #0
 7817 43e4 D420A003 		moveq	r2, #212
 7818 43e8 5420A013 		movne	r2, #84
 7819 43ec 5230A0E3 		mov	r3, #82
 7820 43f0 0100A0E3 		mov	r0, #1
 7821 43f4 FEFFFFEB 		bl	SensorSetIrisControl
2738:../uvc.c      ****                  		break;
 7822              		.loc 1 2738 0
 7823 43f8 E8FFFFEA 		b	.L588
 7824              	.L643:
2709:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 7825              		.loc 1 2709 0
 7826 43fc A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 7827 4400 01E081E2 		add	lr, r1, #1
 7828 4404 020051E3 		cmp	r1, #2
 7829 4408 A1E0C5E5 		strb	lr, [r5, #161]
 7830 440c A0FFFF9A 		bls	.L586
2710:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7831              		.loc 1 2710 0
 7832 4410 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2711:../uvc.c      ****                 		stiflag = 0x0F;
 7833              		.loc 1 2711 0
 7834 4414 0F30A0E3 		mov	r3, #15
2710:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7835              		.loc 1 2710 0
 7836 4418 20C082E3 		orr	ip, r2, #32
 7837 441c 81C4C7E5 		strb	ip, [r7, #1153]
2712:../uvc.c      ****                 		IMcount = 0;
 7838              		.loc 1 2712 0
 7839 4420 A160C5E5 		strb	r6, [r5, #161]
2711:../uvc.c      ****                 		stiflag = 0x0F;
 7840              		.loc 1 2711 0
 7841 4424 3A30C5E5 		strb	r3, [r5, #58]
 7842 4428 99FFFFEA 		b	.L586
 7843              	.L648:
 7844              		.align	2
 7845              	.L647:
 7846 442c 2C070000 		.word	.LC39
 7847 4430 00C20100 		.word	115200
 7848 4434 4C070000 		.word	.LC40
 7849 4438 A0860100 		.word	100000
 7850 443c 68070000 		.word	.LC41
 7851 4440 00000000 		.word	.LANCHOR0
 7852 4444 00000000 		.word	CyFxGpifCB
 7853 4448 88130000 		.word	5000
 7854 444c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7855 4450 00000000 		.word	CyFxUVCApplnUSBEventCB
 7856 4454 00000000 		.word	CyFxUSBDeviceDscr
 7857 4458 00000000 		.word	CyFxUSBDeviceDscrSS
 7858 445c 00000000 		.word	CyFxUSBDeviceQualDscr
 7859 4460 00000000 		.word	CyFxUSBBOSDscr
 7860 4464 00000000 		.word	CyFxUSBHSConfigDscr
 7861 4468 00000000 		.word	CyFxUSBFSConfigDscr
 7862 446c 00000000 		.word	CyFxUSBSSConfigDscr
 7863 4470 00000000 		.word	CyFxUSBStringLangIDDscr
 7864 4474 00000000 		.word	CyFxUSBManufactureDscr
 7865 4478 00000000 		.word	CyFxUSBProductDscr
 7866 447c 013F0000 		.word	16129
 7867 4480 02030000 		.word	770
 7868 4484 00000000 		.word	glChHandleInterStat
 7869 4488 00000000 		.word	glInterStaBuffer
 7870 448c 00000000 		.word	imgHdMux
 7871 4490 01010000 		.word	257
 7872 4494 03030000 		.word	771
 7873 4498 00000000 		.word	CyFxUvcApplnDmaCallback
 7874 449c 00000000 		.word	glChHandleUVCStream
 7875 44a0 00000000 		.word	.LANCHOR1
 7876 44a4 84070000 		.word	.LC42
 7877 44a8 D8010000 		.word	.LC12
 7878 44ac D4070000 		.word	.LC44
 7879 44b0 B0070000 		.word	.LC43
 7880 44b4 FC070000 		.word	.LC45
 7881 44b8 54090000 		.word	.LC52
 7882 44bc 300A0000 		.word	.LC56
 7883 44c0 000A0000 		.word	.LC55
 7884 44c4 C8090000 		.word	.LC54
 7885 44c8 88090000 		.word	.LC53
 7886 44cc FC0A0000 		.word	.LC61
 7887 44d0 4C000000 		.word	.LANCHOR2+76
 7888 44d4 440B0000 		.word	.LC63
 7889 44d8 EC0A0000 		.word	.LC60
 7890 44dc 30000000 		.word	.LANCHOR2+48
 7891 44e0 0C0B0000 		.word	.LC62
 7892 44e4 B80A0000 		.word	.LC59
 7893 44e8 24090000 		.word	.LC51
 7894 44ec F4080000 		.word	.LC50
 7895 44f0 BC080000 		.word	.LC49
 7896 44f4 54080000 		.word	.LC47
 7897 44f8 28080000 		.word	.LC46
 7898 44fc 88080000 		.word	.LC48
 7899 4500 840A0000 		.word	.LC58
 7900 4504 580A0000 		.word	.LC57
 7901              		.cfi_endproc
 7902              	.LFE19:
 7904              		.align	2
 7905              		.global	CyFxApplicationDefine
 7907              	CyFxApplicationDefine:
 7908              	.LFB27:
4167:../uvc.c      **** }
4168:../uvc.c      **** 
4169:../uvc.c      **** 
4170:../uvc.c      **** /*
4171:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4172:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4173:../uvc.c      ****  */
4174:../uvc.c      **** void
4175:../uvc.c      **** CyFxApplicationDefine (
4176:../uvc.c      ****         void)
4177:../uvc.c      **** {
 7909              		.loc 1 4177 0
 7910              		.cfi_startproc
 7911              		@ args = 0, pretend = 0, frame = 40
 7912              		@ frame_needed = 0, uses_anonymous_args = 0
 7913              	.LVL664:
 7914 4508 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7915              	.LCFI27:
 7916              		.cfi_def_cfa_offset 36
4178:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4179:../uvc.c      ****     uint32_t retThrdCreate;
4180:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4181:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4182:../uvc.c      **** 
4183:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4184:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7917              		.loc 1 4184 0
 7918 450c 010AA0E3 		mov	r0, #4096
4177:../uvc.c      **** {
 7919              		.loc 1 4177 0
 7920 4510 4CD04DE2 		sub	sp, sp, #76
 7921              	.LCFI28:
 7922              		.cfi_def_cfa_offset 112
 7923              		.loc 1 4184 0
 7924              		.cfi_offset 14, -4
 7925              		.cfi_offset 11, -8
 7926              		.cfi_offset 10, -12
 7927              		.cfi_offset 9, -16
 7928              		.cfi_offset 8, -20
 7929              		.cfi_offset 7, -24
 7930              		.cfi_offset 6, -28
 7931              		.cfi_offset 5, -32
 7932              		.cfi_offset 4, -36
 7933 4514 FEFFFFEB 		bl	CyU3PMemAlloc
 7934 4518 00A0A0E1 		mov	sl, r0
 7935              	.LVL665:
4185:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7936              		.loc 1 4185 0
 7937 451c 010AA0E3 		mov	r0, #4096
 7938              	.LVL666:
 7939 4520 FEFFFFEB 		bl	CyU3PMemAlloc
 7940 4524 00B0A0E1 		mov	fp, r0
 7941              	.LVL667:
4186:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7942              		.loc 1 4186 0
 7943 4528 010AA0E3 		mov	r0, #4096
 7944              	.LVL668:
 7945 452c FEFFFFEB 		bl	CyU3PMemAlloc
4187:../uvc.c      **** 
4188:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7946              		.loc 1 4188 0
 7947 4530 00005AE3 		cmp	sl, #0
 7948 4534 00005B13 		cmpne	fp, #0
 7949 4538 0090A013 		movne	r9, #0
 7950 453c 0190A003 		moveq	r9, #1
4186:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7951              		.loc 1 4186 0
 7952 4540 24008DE5 		str	r0, [sp, #36]
 7953              	.LVL669:
 7954              		.loc 1 4188 0
 7955 4544 0000001A 		bne	.L653
 7956              	.LVL670:
 7957              	.L650:
 7958              	.L652:
 7959 4548 FEFFFFEA 		b	.L652
 7960              	.L653:
 7961              		.loc 1 4188 0 is_stmt 0 discriminator 1
 7962 454c 000050E3 		cmp	r0, #0
 7963 4550 FCFFFF0A 		beq	.L650
4189:../uvc.c      ****         goto fatalErrorHandler;
4190:../uvc.c      **** 
4191:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4192:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7964              		.loc 1 4192 0 is_stmt 1
 7965 4554 28408DE2 		add	r4, sp, #40
 7966 4558 0400A0E1 		mov	r0, r4
 7967 455c 4010A0E3 		mov	r1, #64
 7968 4560 18219FE5 		ldr	r2, .L654
 7969 4564 FEFFFFEB 		bl	cmdbufCreate
 7970 4568 0450A0E1 		mov	r5, r4
 7971 456c 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7972 4570 0C719FE5 		ldr	r7, .L654+4
4193:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7973              		.loc 1 4193 0
 7974 4574 0C819FE5 		ldr	r8, .L654+8
4192:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7975              		.loc 1 4192 0
 7976 4578 07C0A0E1 		mov	ip, r7
 7977 457c 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7978 4580 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4194:../uvc.c      **** 
4195:../uvc.c      **** 	/****** initialize command descriptor ***********/
4196:../uvc.c      **** 	cmdquInit(cmdQuptr);
4197:../uvc.c      **** 	cmdquInit(statQuptr);
4198:../uvc.c      **** 
4199:../uvc.c      ****     /* Create the UVC application thread. */
4200:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7979              		.loc 1 4200 0
 7980 4584 0860A0E3 		mov	r6, #8
4192:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7981              		.loc 1 4192 0
 7982 4588 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4193:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7983              		.loc 1 4193 0
 7984 458c F8209FE5 		ldr	r2, .L654+12
 7985 4590 0400A0E1 		mov	r0, r4
 7986 4594 2010A0E3 		mov	r1, #32
 7987 4598 FEFFFFEB 		bl	cmdbufCreate
 7988 459c 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7989 45a0 08C0A0E1 		mov	ip, r8
 7990 45a4 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7991 45a8 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7992              		.loc 1 4200 0
 7993 45ac 0140A0E3 		mov	r4, #1
4193:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7994              		.loc 1 4193 0
 7995 45b0 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4196:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7996              		.loc 1 4196 0
 7997 45b4 0700A0E1 		mov	r0, r7
 7998 45b8 FEFFFFEB 		bl	cmdquInit
4197:../uvc.c      **** 	cmdquInit(statQuptr);
 7999              		.loc 1 4197 0
 8000 45bc 0800A0E1 		mov	r0, r8
 8001 45c0 FEFFFFEB 		bl	cmdquInit
 8002              		.loc 1 4200 0
 8003 45c4 A850A0E3 		mov	r5, #168
 8004 45c8 01CAA0E3 		mov	ip, #4096
 8005 45cc BC009FE5 		ldr	r0, .L654+16
 8006 45d0 BC109FE5 		ldr	r1, .L654+20
 8007 45d4 BC209FE5 		ldr	r2, .L654+24
 8008 45d8 0930A0E1 		mov	r3, r9
 8009 45dc 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 8010 45e0 08608DE5 		str	r6, [sp, #8]
 8011 45e4 0C608DE5 		str	r6, [sp, #12]
 8012 45e8 10908DE5 		str	r9, [sp, #16]
 8013 45ec 14408DE5 		str	r4, [sp, #20]
 8014 45f0 18508DE5 		str	r5, [sp, #24]
 8015 45f4 FEFFFFEB 		bl	_txe_thread_create
 8016              	.LVL671:
4201:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4202:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4203:../uvc.c      ****             0,                                          /* No input parameter to thread */
4204:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4205:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4206:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4207:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4208:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4209:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4210:../uvc.c      ****             );
4211:../uvc.c      ****     if (retThrdCreate != 0)
 8017              		.loc 1 4211 0
 8018 45f8 00C050E2 		subs	ip, r0, #0
 8019 45fc D1FFFF1A 		bne	.L650
4212:../uvc.c      ****     {
4213:../uvc.c      ****         goto fatalErrorHandler;
4214:../uvc.c      ****     }
4215:../uvc.c      **** 
4216:../uvc.c      ****     /* Create the control request handling thread. */
4217:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 8020              		.loc 1 4217 0
 8021 4600 0C30A0E1 		mov	r3, ip
 8022 4604 027BA0E3 		mov	r7, #2048
 8023 4608 8C009FE5 		ldr	r0, .L654+28
 8024              	.LVL672:
 8025 460c 8C109FE5 		ldr	r1, .L654+32
 8026 4610 8C209FE5 		ldr	r2, .L654+36
 8027 4614 10C08DE5 		str	ip, [sp, #16]
 8028 4618 00B08DE5 		str	fp, [sp, #0]
 8029 461c 04708DE5 		str	r7, [sp, #4]
 8030 4620 08608DE5 		str	r6, [sp, #8]
 8031 4624 0C608DE5 		str	r6, [sp, #12]
 8032 4628 14408DE5 		str	r4, [sp, #20]
 8033 462c 18508DE5 		str	r5, [sp, #24]
 8034 4630 FEFFFFEB 		bl	_txe_thread_create
 8035              	.LVL673:
4218:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4219:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4220:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4221:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4222:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4223:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4224:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4225:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4226:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4227:../uvc.c      ****             );
4228:../uvc.c      ****     if (retThrdCreate != 0)
 8036              		.loc 1 4228 0
 8037 4634 00C050E2 		subs	ip, r0, #0
 8038 4638 C2FFFF1A 		bne	.L650
4229:../uvc.c      ****     {
4230:../uvc.c      ****         goto fatalErrorHandler;
4231:../uvc.c      ****     }
4232:../uvc.c      **** #if 1
4233:../uvc.c      ****     /* Create the I2C control command handling thread. */
4234:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 8039              		.loc 1 4234 0
 8040 463c 24E09DE5 		ldr	lr, [sp, #36]
 8041 4640 60009FE5 		ldr	r0, .L654+40
 8042              	.LVL674:
 8043 4644 60109FE5 		ldr	r1, .L654+44
 8044 4648 60209FE5 		ldr	r2, .L654+48
 8045 464c 0C30A0E1 		mov	r3, ip
 8046 4650 00E08DE5 		str	lr, [sp, #0]
 8047 4654 04708DE5 		str	r7, [sp, #4]
 8048 4658 08608DE5 		str	r6, [sp, #8]
 8049 465c 0C608DE5 		str	r6, [sp, #12]
 8050 4660 10C08DE5 		str	ip, [sp, #16]
 8051 4664 14408DE5 		str	r4, [sp, #20]
 8052 4668 18508DE5 		str	r5, [sp, #24]
 8053 466c FEFFFFEB 		bl	_txe_thread_create
 8054              	.LVL675:
4235:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4236:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4237:../uvc.c      ****             0,                                          /* No input parameter to thread */
4238:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4239:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4240:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4241:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4242:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4243:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4244:../uvc.c      ****             );
4245:../uvc.c      ****     if (retThrdCreate != 0)
 8055              		.loc 1 4245 0
 8056 4670 000050E3 		cmp	r0, #0
 8057 4674 B3FFFF1A 		bne	.L650
4246:../uvc.c      ****     {
4247:../uvc.c      ****         goto fatalErrorHandler;
4248:../uvc.c      ****     }
4249:../uvc.c      **** #endif
4250:../uvc.c      **** 
4251:../uvc.c      ****     return;
4252:../uvc.c      **** 
4253:../uvc.c      **** fatalErrorHandler:
4254:../uvc.c      ****     /* Add custom recovery or debug actions here */
4255:../uvc.c      ****     /* Loop indefinitely */
4256:../uvc.c      ****     while (1);
4257:../uvc.c      **** }
 8058              		.loc 1 4257 0
 8059 4678 4CD08DE2 		add	sp, sp, #76
 8060 467c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8061              	.L655:
 8062              		.align	2
 8063              	.L654:
 8064 4680 00000000 		.word	cmdQuMux
 8065 4684 00000000 		.word	cmdQu
 8066 4688 00000000 		.word	statQu
 8067 468c 00000000 		.word	staQuMux
 8068 4690 A4000000 		.word	.LANCHOR0+164
 8069 4694 7C0B0000 		.word	.LC64
 8070 4698 00000000 		.word	UVCAppThread_Entry
 8071 469c 4C010000 		.word	.LANCHOR0+332
 8072 46a0 900B0000 		.word	.LC65
 8073 46a4 00000000 		.word	UVCAppEP0Thread_Entry
 8074 46a8 F4010000 		.word	.LANCHOR0+500
 8075 46ac A80B0000 		.word	.LC66
 8076 46b0 00000000 		.word	I2cAppThread_Entry
 8077              		.cfi_endproc
 8078              	.LFE27:
 8080              		.align	2
 8081              		.global	main
 8083              	main:
 8084              	.LFB28:
4258:../uvc.c      **** 
4259:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4260:../uvc.c      ****  * the ThreadX RTOS here.
4261:../uvc.c      ****  */
4262:../uvc.c      **** int
4263:../uvc.c      **** main (
4264:../uvc.c      ****         void)
4265:../uvc.c      **** {
 8085              		.loc 1 4265 0
 8086              		.cfi_startproc
 8087              		@ args = 0, pretend = 0, frame = 56
 8088              		@ frame_needed = 0, uses_anonymous_args = 0
 8089 46b4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 8090              	.LCFI29:
 8091              		.cfi_def_cfa_offset 12
4266:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4267:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4268:../uvc.c      **** 
4269:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4270:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4271:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4272:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4273:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4274:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8092              		.loc 1 4274 0
 8093 46b8 0010A0E3 		mov	r1, #0
4265:../uvc.c      **** {
 8094              		.loc 1 4265 0
 8095 46bc 3CD04DE2 		sub	sp, sp, #60
 8096              	.LCFI30:
 8097              		.cfi_def_cfa_offset 72
4271:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8098              		.loc 1 4271 0
 8099 46c0 0220A0E3 		mov	r2, #2
4275:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8100              		.loc 1 4275 0
 8101 46c4 033081E2 		add	r3, r1, #3
4270:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8102              		.loc 1 4270 0
 8103 46c8 0150A0E3 		mov	r5, #1
 8104              		.cfi_offset 14, -4
 8105              		.cfi_offset 5, -8
 8106              		.cfi_offset 4, -12
4276:../uvc.c      **** 
4277:../uvc.c      ****     /* Initialize the device */
4278:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 8107              		.loc 1 4278 0
 8108 46cc 28008DE2 		add	r0, sp, #40
4270:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8109              		.loc 1 4270 0
 8110 46d0 28508DE5 		str	r5, [sp, #40]
4271:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8111              		.loc 1 4271 0
 8112 46d4 2C20CDE5 		strb	r2, [sp, #44]
4272:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 8113              		.loc 1 4272 0
 8114 46d8 2D20CDE5 		strb	r2, [sp, #45]
4273:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 8115              		.loc 1 4273 0
 8116 46dc 2E20CDE5 		strb	r2, [sp, #46]
4274:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8117              		.loc 1 4274 0
 8118 46e0 30108DE5 		str	r1, [sp, #48]
4275:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8119              		.loc 1 4275 0
 8120 46e4 3430CDE5 		strb	r3, [sp, #52]
 8121              		.loc 1 4278 0
 8122 46e8 FEFFFFEB 		bl	CyU3PDeviceInit
 8123              	.LVL676:
4279:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8124              		.loc 1 4279 0
 8125 46ec 004050E2 		subs	r4, r0, #0
 8126 46f0 0000000A 		beq	.L659
 8127              	.L657:
 8128              	.L658:
 8129 46f4 FEFFFFEA 		b	.L658
 8130              	.L659:
4280:../uvc.c      ****     {
4281:../uvc.c      ****         goto handle_fatal_error;
4282:../uvc.c      ****     }
4283:../uvc.c      **** 
4284:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4285:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 8131              		.loc 1 4285 0
 8132 46f8 0410A0E1 		mov	r1, r4
 8133 46fc 0420A0E1 		mov	r2, r4
 8134 4700 0500A0E1 		mov	r0, r5
 8135              	.LVL677:
 8136 4704 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 8137              	.LVL678:
4286:../uvc.c      **** 
4287:../uvc.c      ****     /* Configure the IO matrix for the device. */
4288:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4289:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4290:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4291:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4292:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4293:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4294:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4295:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4296:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4297:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4298:../uvc.c      **** 
4299:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 8138              		.loc 1 4299 0
 8139 4708 0D00A0E1 		mov	r0, sp
4289:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 8140              		.loc 1 4289 0
 8141 470c 1640CDE5 		strb	r4, [sp, #22]
4290:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 8142              		.loc 1 4290 0
 8143 4710 18408DE5 		str	r4, [sp, #24]
4291:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 8144              		.loc 1 4291 0
 8145 4714 1C408DE5 		str	r4, [sp, #28]
4292:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 8146              		.loc 1 4292 0
 8147 4718 20408DE5 		str	r4, [sp, #32]
4293:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 8148              		.loc 1 4293 0
 8149 471c 24408DE5 		str	r4, [sp, #36]
4296:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 8150              		.loc 1 4296 0
 8151 4720 0C408DE5 		str	r4, [sp, #12]
4297:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 8152              		.loc 1 4297 0
 8153 4724 10408DE5 		str	r4, [sp, #16]
4288:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 8154              		.loc 1 4288 0
 8155 4728 00508DE5 		str	r5, [sp, #0]
4294:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 8156              		.loc 1 4294 0
 8157 472c 04508DE5 		str	r5, [sp, #4]
4295:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 8158              		.loc 1 4295 0
 8159 4730 08508DE5 		str	r5, [sp, #8]
 8160              		.loc 1 4299 0
 8161 4734 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 8162              	.LVL679:
4300:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8163              		.loc 1 4300 0
 8164 4738 004050E2 		subs	r4, r0, #0
 8165 473c ECFFFF1A 		bne	.L657
4301:../uvc.c      ****     {
4302:../uvc.c      ****         goto handle_fatal_error;
4303:../uvc.c      ****     }
4304:../uvc.c      **** 
4305:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4306:../uvc.c      ****     CyU3PKernelEntry ();
 8166              		.loc 1 4306 0
 8167 4740 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 8168              	.LVL680:
4307:../uvc.c      **** 
4308:../uvc.c      ****     /* Dummy return to make the compiler happy */
4309:../uvc.c      ****     return 0;
4310:../uvc.c      **** 
4311:../uvc.c      **** handle_fatal_error:
4312:../uvc.c      ****     /* Cannot recover from this error. */
4313:../uvc.c      ****     while (1);
4314:../uvc.c      **** }
 8169              		.loc 1 4314 0
 8170 4744 0400A0E1 		mov	r0, r4
 8171 4748 3CD08DE2 		add	sp, sp, #60
 8172 474c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 8173              		.cfi_endproc
 8174              	.LFE28:
 8176              		.global	CyFxGpifTransition
 8177              		.global	CyFxGpifWavedata
 8178              		.global	CyFxGpifWavedataPosition
 8179              		.global	CyFxGpifRegValue
 8180              		.global	CyFxGpifConfig
 8181              		.global	CyFxGpifTransition_usb2
 8182              		.global	CyFxGpifWavedata_usb2
 8183              		.global	CyFxGpifWavedataPosition_usb2
 8184              		.global	CyFxGpifRegValue_usb2
 8185              		.global	CyFxGpifConfig_usb2
 8186              		.global	snapButFlag
 8187              		.global	testSnap
 8188              		.global	fb
 8189              		.global	pb
 8190              		.global	pbc
 8191              		.global	fbbak
 8192              		.global	pbbak
 8193              		.global	pbcbak
 8194              		.global	pbcpbak
 8195              		.global	isUsbConnected
 8196              		.global	usbSpeed
 8197              		.global	clearFeatureRqtReceived
 8198              		.global	streamingStarted
 8199              		.global	glProbeCtrl
 8200              		.global	glProbeCtrlFull
 8201              		.global	glProbeStilCtrl
 8202              		.global	glProbeCtrl20
 8203              		.global	glProbeStilCtrl20
 8204              		.global	glUVCHeader
 8205              		.comm	glChHandleUVCStream,220,4
 8206              		.comm	glChHandleStillStream,220,4
 8207              		.comm	glChHandleInterStat,160,4
 8208              		.comm	glInterStaBuffer,4,4
 8209              		.comm	cmdQu,32,4
 8210              		.comm	statQu,32,4
 8211              		.comm	cmdQuMux,56,4
 8212              		.comm	staQuMux,56,4
 8213              		.comm	timMux,56,4
 8214              		.comm	imgHdMux,56,4
 8215              		.comm	bmReqType,1,1
 8216              		.comm	bRequest,1,1
 8217              		.comm	wValue,2,2
 8218              		.comm	wIndex,2,2
 8219              		.comm	wLength,2,2
 8220              		.comm	posTick,4,4
 8221              		.comm	I2CCmdTimer,44,4
 8222              		.section	.rodata
 8223              		.align	2
 8224              		.set	.LANCHOR2,. + 0
 8227              	ShutSp:
 8228 0000 3582     		.short	-32203
 8229 0002 1B41     		.short	16667
 8230 0004 8D20     		.short	8333
 8231 0006 A00F     		.short	4000
 8232 0008 D007     		.short	2000
 8233 000a E803     		.short	1000
 8234 000c F401     		.short	500
 8235 000e C800     		.short	200
 8236 0010 6400     		.short	100
 8237 0012 0A00     		.short	10
 8238 0014 0000     		.short	0
 8239 0016 00000000 		.space	10
 8239      00000000 
 8239      0000
 8242              	ExTime:
 8243 0020 9C       		.byte	-100
 8244 0021 00       		.byte	0
 8245 0022 4E       		.byte	78
 8246 0023 00       		.byte	0
 8247 0024 27       		.byte	39
 8248 0025 00       		.byte	0
 8249 0026 14       		.byte	20
 8250 0027 00       		.byte	0
 8251 0028 0A       		.byte	10
 8252 0029 00       		.byte	0
 8253 002a 05       		.byte	5
 8254 002b 00       		.byte	0
 8255 002c 02       		.byte	2
 8256 002d 00       		.byte	0
 8257 002e 01       		.byte	1
 8258 002f 00       		.byte	0
 8261              	CyFxGpifConfig:
 8262 0030 0F00     		.short	15
 8263 0032 0000     		.space	2
 8264 0034 00000000 		.word	CyFxGpifWavedata
 8265 0038 00000000 		.word	CyFxGpifWavedataPosition
 8266 003c 0500     		.short	5
 8267 003e 0000     		.space	2
 8268 0040 00000000 		.word	CyFxGpifTransition
 8269 0044 4C00     		.short	76
 8270 0046 0000     		.space	2
 8271 0048 00000000 		.word	CyFxGpifRegValue
 8274              	CyFxGpifConfig_usb2:
 8275 004c 9300     		.short	147
 8276 004e 0000     		.space	2
 8277 0050 00000000 		.word	CyFxGpifWavedata_usb2
 8278 0054 00000000 		.word	CyFxGpifWavedataPosition_usb2
 8279 0058 0800     		.short	8
 8280 005a 0000     		.space	2
 8281 005c 00000000 		.word	CyFxGpifTransition_usb2
 8282 0060 4C00     		.short	76
 8283 0062 0000     		.space	2
 8284 0064 00000000 		.word	CyFxGpifRegValue_usb2
 8285              		.data
 8286              		.align	2
 8287              		.set	.LANCHOR1,. + 0
 8290              	ExUCtrlParArry:
 8291 0000 13       		.byte	19
 8292 0001 14       		.byte	20
 8293 0002 02       		.byte	2
 8294 0003 01       		.byte	1
 8295 0004 00       		.byte	0
 8296 0005 03       		.byte	3
 8297 0006 00       		.byte	0
 8298 0007 01       		.byte	1
 8299 0008 00       		.byte	0
 8300 0009 03       		.byte	3
 8301 000a 00       		.byte	0
 8302 000b 23       		.byte	35
 8303 000c 37       		.byte	55
 8304 000d 23       		.byte	35
 8305 000e 37       		.byte	55
 8306 000f 30       		.byte	48
 8307 0010 01       		.byte	1
 8308 0011 00       		.byte	0
 8309 0012 00       		.byte	0
 8310 0013 00000000 		.space	5
 8310      00
 8311 0018 11       		.byte	17
 8312 0019 00       		.byte	0
 8313 001a 02       		.byte	2
 8314 001b 01       		.byte	1
 8315 001c 00       		.byte	0
 8316 001d 03       		.byte	3
 8317 001e 00       		.byte	0
 8318 001f 01       		.byte	1
 8319 0020 00       		.byte	0
 8320 0021 03       		.byte	3
 8321 0022 00       		.byte	0
 8322 0023 01       		.byte	1
 8323 0024 00       		.byte	0
 8324 0025 01       		.byte	1
 8325 0026 00       		.byte	0
 8326 0027 30       		.byte	48
 8327 0028 01       		.byte	1
 8328 0029 01       		.byte	1
 8329 002a 00       		.byte	0
 8330 002b 00000000 		.space	5
 8330      00
 8331 0030 17       		.byte	23
 8332 0031 00       		.byte	0
 8333 0032 01       		.byte	1
 8334 0033 01       		.byte	1
 8335 0034 00       		.byte	0
 8336 0035 02       		.byte	2
 8337 0036 00       		.byte	0
 8338 0037 01       		.byte	1
 8339 0038 00       		.byte	0
 8340 0039 03       		.byte	3
 8341 003a 00       		.byte	0
 8342 003b 00       		.byte	0
 8343 003c 00       		.byte	0
 8344 003d 00       		.byte	0
 8345 003e 00       		.byte	0
 8346 003f 30       		.byte	48
 8347 0040 01       		.byte	1
 8348 0041 01       		.byte	1
 8349 0042 00       		.byte	0
 8350 0043 00000000 		.space	5
 8350      00
 8351 0048 00       		.byte	0
 8352 0049 00       		.byte	0
 8353 004a 04       		.byte	4
 8354 004b 01       		.byte	1
 8355 004c 00       		.byte	0
 8356 004d 38       		.byte	56
 8357 004e 01       		.byte	1
 8358 004f 01       		.byte	1
 8359 0050 00       		.byte	0
 8360 0051 03       		.byte	3
 8361 0052 00       		.byte	0
 8362 0053 4E       		.byte	78
 8363 0054 00       		.byte	0
 8364 0055 4E       		.byte	78
 8365 0056 00       		.byte	0
 8366 0057 30       		.byte	48
 8367 0058 01       		.byte	1
 8368 0059 00       		.byte	0
 8369 005a 00       		.byte	0
 8370 005b 00000000 		.space	5
 8370      00
 8371 0060 00       		.byte	0
 8372 0061 00       		.byte	0
 8373 0062 01       		.byte	1
 8374 0063 00       		.byte	0
 8375 0064 00       		.byte	0
 8376 0065 00       		.byte	0
 8377 0066 00       		.byte	0
 8378 0067 01       		.byte	1
 8379 0068 00       		.byte	0
 8380 0069 03       		.byte	3
 8381 006a 00       		.byte	0
 8382 006b 00       		.byte	0
 8383 006c 00       		.byte	0
 8384 006d 00       		.byte	0
 8385 006e 00       		.byte	0
 8386 006f 30       		.byte	48
 8387 0070 01       		.byte	1
 8388 0071 00       		.byte	0
 8389 0072 00       		.byte	0
 8390 0073 00000000 		.space	5
 8390      00
 8391 0078 00       		.byte	0
 8392 0079 00       		.byte	0
 8393 007a 02       		.byte	2
 8394 007b 00       		.byte	0
 8395 007c 00       		.byte	0
 8396 007d FF       		.byte	-1
 8397 007e 00       		.byte	0
 8398 007f 01       		.byte	1
 8399 0080 00       		.byte	0
 8400 0081 03       		.byte	3
 8401 0082 00       		.byte	0
 8402 0083 01       		.byte	1
 8403 0084 00       		.byte	0
 8404 0085 00       		.byte	0
 8405 0086 00       		.byte	0
 8406 0087 30       		.byte	48
 8407 0088 01       		.byte	1
 8408 0089 01       		.byte	1
 8409 008a 00       		.byte	0
 8410 008b 00000000 		.space	5
 8410      00
 8411 0090 00       		.byte	0
 8412 0091 00       		.byte	0
 8413 0092 02       		.byte	2
 8414 0093 00       		.byte	0
 8415 0094 00       		.byte	0
 8416 0095 00       		.byte	0
 8417 0096 00       		.byte	0
 8418 0097 00       		.byte	0
 8419 0098 00       		.byte	0
 8420 0099 03       		.byte	3
 8421 009a 00       		.byte	0
 8422 009b 00       		.byte	0
 8423 009c 00       		.byte	0
 8424 009d 00       		.byte	0
 8425 009e 00       		.byte	0
 8426 009f 30       		.byte	48
 8427 00a0 01       		.byte	1
 8428 00a1 01       		.byte	1
 8429 00a2 00       		.byte	0
 8430 00a3 00000000 		.space	5
 8430      00
 8431 00a8 00       		.byte	0
 8432 00a9 00       		.byte	0
 8433 00aa 02       		.byte	2
 8434 00ab 00       		.byte	0
 8435 00ac 00       		.byte	0
 8436 00ad 30       		.byte	48
 8437 00ae 00       		.byte	0
 8438 00af 01       		.byte	1
 8439 00b0 00       		.byte	0
 8440 00b1 03       		.byte	3
 8441 00b2 0A       		.byte	10
 8442 00b3 00       		.byte	0
 8443 00b4 00       		.byte	0
 8444 00b5 0A       		.byte	10
 8445 00b6 00       		.byte	0
 8446 00b7 30       		.byte	48
 8447 00b8 01       		.byte	1
 8448 00b9 01       		.byte	1
 8449 00ba 00       		.byte	0
 8450 00bb 00000000 		.space	5
 8450      00
 8451 00c0 00       		.byte	0
 8452 00c1 00       		.byte	0
 8453 00c2 01       		.byte	1
 8454 00c3 00       		.byte	0
 8455 00c4 00       		.byte	0
 8456 00c5 7F       		.byte	127
 8457 00c6 00       		.byte	0
 8458 00c7 01       		.byte	1
 8459 00c8 00       		.byte	0
 8460 00c9 03       		.byte	3
 8461 00ca 00       		.byte	0
 8462 00cb 00       		.byte	0
 8463 00cc 00       		.byte	0
 8464 00cd 00       		.byte	0
 8465 00ce 00       		.byte	0
 8466 00cf 30       		.byte	48
 8467 00d0 01       		.byte	1
 8468 00d1 00       		.byte	0
 8469 00d2 00       		.byte	0
 8470 00d3 00000000 		.space	5
 8470      00
 8471 00d8 00       		.byte	0
 8472 00d9 00       		.byte	0
 8473 00da 02       		.byte	2
 8474 00db 00       		.byte	0
 8475 00dc 00       		.byte	0
 8476 00dd 05       		.byte	5
 8477 00de 00       		.byte	0
 8478 00df 01       		.byte	1
 8479 00e0 00       		.byte	0
 8480 00e1 03       		.byte	3
 8481 00e2 00       		.byte	0
 8482 00e3 00       		.byte	0
 8483 00e4 00       		.byte	0
 8484 00e5 00       		.byte	0
 8485 00e6 00       		.byte	0
 8486 00e7 30       		.byte	48
 8487 00e8 01       		.byte	1
 8488 00e9 00       		.byte	0
 8489 00ea 00       		.byte	0
 8490 00eb 00000000 		.space	5
 8490      00
 8491 00f0 00       		.byte	0
 8492 00f1 00       		.byte	0
 8493 00f2 03       		.byte	3
 8494 00f3 00       		.byte	0
 8495 00f4 00       		.byte	0
 8496 00f5 0A       		.byte	10
 8497 00f6 00       		.byte	0
 8498 00f7 01       		.byte	1
 8499 00f8 00       		.byte	0
 8500 00f9 03       		.byte	3
 8501 00fa 00       		.byte	0
 8502 00fb 00       		.byte	0
 8503 00fc 00       		.byte	0
 8504 00fd 00       		.byte	0
 8505 00fe 00       		.byte	0
 8506 00ff 30       		.byte	48
 8507 0100 01       		.byte	1
 8508 0101 00       		.byte	0
 8509 0102 00       		.byte	0
 8510 0103 00000000 		.space	5
 8510      00
 8511 0108 00       		.byte	0
 8512 0109 00       		.byte	0
 8513 010a 02       		.byte	2
 8514 010b 00       		.byte	0
 8515 010c 00       		.byte	0
 8516 010d 40       		.byte	64
 8517 010e 00       		.byte	0
 8518 010f 01       		.byte	1
 8519 0110 00       		.byte	0
 8520 0111 03       		.byte	3
 8521 0112 00       		.byte	0
 8522 0113 0F       		.byte	15
 8523 0114 11       		.byte	17
 8524 0115 00       		.byte	0
 8525 0116 00       		.byte	0
 8526 0117 30       		.byte	48
 8527 0118 01       		.byte	1
 8528 0119 00       		.byte	0
 8529 011a 00       		.byte	0
 8530 011b 00000000 		.space	5
 8530      00
 8531 0120 00       		.byte	0
 8532 0121 00       		.byte	0
 8533 0122 02       		.byte	2
 8534 0123 00       		.byte	0
 8535 0124 00       		.byte	0
 8536 0125 64       		.byte	100
 8537 0126 00       		.byte	0
 8538 0127 01       		.byte	1
 8539 0128 00       		.byte	0
 8540 0129 03       		.byte	3
 8541 012a 00       		.byte	0
 8542 012b 00       		.byte	0
 8543 012c 00       		.byte	0
 8544 012d 00       		.byte	0
 8545 012e 00       		.byte	0
 8546 012f 30       		.byte	48
 8547 0130 01       		.byte	1
 8548 0131 00       		.byte	0
 8549 0132 00       		.byte	0
 8550 0133 00000000 		.space	5
 8550      00
 8551 0138 00       		.byte	0
 8552 0139 00       		.byte	0
 8553 013a 02       		.byte	2
 8554 013b 00       		.byte	0
 8555 013c 00       		.byte	0
 8556 013d 64       		.byte	100
 8557 013e 00       		.byte	0
 8558 013f 01       		.byte	1
 8559 0140 00       		.byte	0
 8560 0141 03       		.byte	3
 8561 0142 00       		.byte	0
 8562 0143 00       		.byte	0
 8563 0144 00       		.byte	0
 8564 0145 00       		.byte	0
 8565 0146 00       		.byte	0
 8566 0147 30       		.byte	48
 8567 0148 01       		.byte	1
 8568 0149 00       		.byte	0
 8569 014a 00       		.byte	0
 8570 014b 00000000 		.space	5
 8570      00
 8571 0150 00       		.byte	0
 8572 0151 00       		.byte	0
 8573 0152 02       		.byte	2
 8574 0153 00       		.byte	0
 8575 0154 00       		.byte	0
 8576 0155 64       		.byte	100
 8577 0156 00       		.byte	0
 8578 0157 01       		.byte	1
 8579 0158 00       		.byte	0
 8580 0159 03       		.byte	3
 8581 015a 00       		.byte	0
 8582 015b 00       		.byte	0
 8583 015c 00       		.byte	0
 8584 015d 00       		.byte	0
 8585 015e 00       		.byte	0
 8586 015f 30       		.byte	48
 8587 0160 01       		.byte	1
 8588 0161 00       		.byte	0
 8589 0162 00       		.byte	0
 8590 0163 00000000 		.space	5
 8590      00
 8591 0168 00       		.byte	0
 8592 0169 00       		.byte	0
 8593 016a 02       		.byte	2
 8594 016b 00       		.byte	0
 8595 016c 00       		.byte	0
 8596 016d 64       		.byte	100
 8597 016e 00       		.byte	0
 8598 016f 01       		.byte	1
 8599 0170 00       		.byte	0
 8600 0171 03       		.byte	3
 8601 0172 00       		.byte	0
 8602 0173 00       		.byte	0
 8603 0174 00       		.byte	0
 8604 0175 00       		.byte	0
 8605 0176 00       		.byte	0
 8606 0177 30       		.byte	48
 8607 0178 01       		.byte	1
 8608 0179 00       		.byte	0
 8609 017a 00       		.byte	0
 8610 017b 00000000 		.space	5
 8610      00
 8613              	CtrlParArry:
 8614 0180 10       		.byte	16
 8615 0181 10       		.byte	16
 8616 0182 02       		.byte	2
 8617 0183 00       		.byte	0
 8618 0184 00       		.byte	0
 8619 0185 03       		.byte	3
 8620 0186 00       		.byte	0
 8621 0187 01       		.byte	1
 8622 0188 00       		.byte	0
 8623 0189 03       		.byte	3
 8624 018a 00       		.byte	0
 8625 018b 03       		.byte	3
 8626 018c 00       		.byte	0
 8627 018d 03       		.byte	3
 8628 018e 00       		.byte	0
 8629 018f 30       		.byte	48
 8630 0190 01       		.byte	1
 8631 0191 00       		.byte	0
 8632 0192 00       		.byte	0
 8633 0193 00000000 		.space	5
 8633      00
 8634 0198 15       		.byte	21
 8635 0199 15       		.byte	21
 8636 019a 02       		.byte	2
 8637 019b 00       		.byte	0
 8638 019c 00       		.byte	0
 8639 019d FF       		.byte	-1
 8640 019e 00       		.byte	0
 8641 019f 01       		.byte	1
 8642 01a0 00       		.byte	0
 8643 01a1 03       		.byte	3
 8644 01a2 00       		.byte	0
 8645 01a3 76       		.byte	118
 8646 01a4 00       		.byte	0
 8647 01a5 76       		.byte	118
 8648 01a6 C7       		.byte	-57
 8649 01a7 30       		.byte	48
 8650 01a8 01       		.byte	1
 8651 01a9 01       		.byte	1
 8652 01aa 00       		.byte	0
 8653 01ab 00000000 		.space	5
 8653      00
 8654 01b0 02       		.byte	2
 8655 01b1 02       		.byte	2
 8656 01b2 02       		.byte	2
 8657 01b3 00       		.byte	0
 8658 01b4 00       		.byte	0
 8659 01b5 FF       		.byte	-1
 8660 01b6 00       		.byte	0
 8661 01b7 01       		.byte	1
 8662 01b8 00       		.byte	0
 8663 01b9 03       		.byte	3
 8664 01ba 00       		.byte	0
 8665 01bb 70       		.byte	112
 8666 01bc 00       		.byte	0
 8667 01bd 70       		.byte	112
 8668 01be 00       		.byte	0
 8669 01bf C6       		.byte	-58
 8670 01c0 01       		.byte	1
 8671 01c1 01       		.byte	1
 8672 01c2 00       		.byte	0
 8673 01c3 00000000 		.space	5
 8673      00
 8674 01c8 00       		.byte	0
 8675 01c9 00       		.byte	0
 8676 01ca 02       		.byte	2
 8677 01cb 00       		.byte	0
 8678 01cc 00       		.byte	0
 8679 01cd 64       		.byte	100
 8680 01ce 00       		.byte	0
 8681 01cf 01       		.byte	1
 8682 01d0 00       		.byte	0
 8683 01d1 03       		.byte	3
 8684 01d2 00       		.byte	0
 8685 01d3 00       		.byte	0
 8686 01d4 00       		.byte	0
 8687 01d5 00       		.byte	0
 8688 01d6 00       		.byte	0
 8689 01d7 30       		.byte	48
 8690 01d8 01       		.byte	1
 8691 01d9 00       		.byte	0
 8692 01da 00       		.byte	0
 8693 01db 00000000 		.space	5
 8693      00
 8694 01e0 07       		.byte	7
 8695 01e1 07       		.byte	7
 8696 01e2 02       		.byte	2
 8697 01e3 00       		.byte	0
 8698 01e4 00       		.byte	0
 8699 01e5 01       		.byte	1
 8700 01e6 00       		.byte	0
 8701 01e7 01       		.byte	1
 8702 01e8 00       		.byte	0
 8703 01e9 03       		.byte	3
 8704 01ea 00       		.byte	0
 8705 01eb 01       		.byte	1
 8706 01ec 00       		.byte	0
 8707 01ed 01       		.byte	1
 8708 01ee 00       		.byte	0
 8709 01ef 30       		.byte	48
 8710 01f0 01       		.byte	1
 8711 01f1 00       		.byte	0
 8712 01f2 00       		.byte	0
 8713 01f3 00000000 		.space	5
 8713      00
 8714 01f8 DF       		.byte	-33
 8715 01f9 E1       		.byte	-31
 8716 01fa 02       		.byte	2
 8717 01fb 00       		.byte	0
 8718 01fc 00       		.byte	0
 8719 01fd FF       		.byte	-1
 8720 01fe 00       		.byte	0
 8721 01ff 01       		.byte	1
 8722 0200 00       		.byte	0
 8723 0201 03       		.byte	3
 8724 0202 00       		.byte	0
 8725 0203 80       		.byte	-128
 8726 0204 00       		.byte	0
 8727 0205 00       		.byte	0
 8728 0206 00       		.byte	0
 8729 0207 C6       		.byte	-58
 8730 0208 01       		.byte	1
 8731 0209 01       		.byte	1
 8732 020a 00       		.byte	0
 8733 020b 00000000 		.space	5
 8733      00
 8734 0210 85       		.byte	-123
 8735 0211 86       		.byte	-122
 8736 0212 02       		.byte	2
 8737 0213 00       		.byte	0
 8738 0214 00       		.byte	0
 8739 0215 64       		.byte	100
 8740 0216 00       		.byte	0
 8741 0217 01       		.byte	1
 8742 0218 00       		.byte	0
 8743 0219 03       		.byte	3
 8744 021a 00       		.byte	0
 8745 021b 32       		.byte	50
 8746 021c 00       		.byte	0
 8747 021d 32       		.byte	50
 8748 021e 00       		.byte	0
 8749 021f F2       		.byte	-14
 8750 0220 01       		.byte	1
 8751 0221 01       		.byte	1
 8752 0222 00       		.byte	0
 8753 0223 00000000 		.space	5
 8753      00
 8754 0228 06       		.byte	6
 8755 0229 06       		.byte	6
 8756 022a 02       		.byte	2
 8757 022b 00       		.byte	0
 8758 022c 00       		.byte	0
 8759 022d 40       		.byte	64
 8760 022e 00       		.byte	0
 8761 022f 01       		.byte	1
 8762 0230 00       		.byte	0
 8763 0231 03       		.byte	3
 8764 0232 00       		.byte	0
 8765 0233 20       		.byte	32
 8766 0234 00       		.byte	0
 8767 0235 20       		.byte	32
 8768 0236 00       		.byte	0
 8769 0237 30       		.byte	48
 8770 0238 01       		.byte	1
 8771 0239 01       		.byte	1
 8772 023a 00       		.byte	0
 8773 023b 00000000 		.space	5
 8773      00
 8774 0240 00       		.byte	0
 8775 0241 00       		.byte	0
 8776 0242 02       		.byte	2
 8777 0243 00       		.byte	0
 8778 0244 00       		.byte	0
 8779 0245 64       		.byte	100
 8780 0246 00       		.byte	0
 8781 0247 01       		.byte	1
 8782 0248 00       		.byte	0
 8783 0249 03       		.byte	3
 8784 024a 00       		.byte	0
 8785 024b 00       		.byte	0
 8786 024c 00       		.byte	0
 8787 024d 00       		.byte	0
 8788 024e 00       		.byte	0
 8789 024f 30       		.byte	48
 8790 0250 01       		.byte	1
 8791 0251 00       		.byte	0
 8792 0252 00       		.byte	0
 8793 0253 00000000 		.space	5
 8793      00
 8794 0258 08       		.byte	8
 8795 0259 08       		.byte	8
 8796 025a 02       		.byte	2
 8797 025b 00       		.byte	0
 8798 025c 00       		.byte	0
 8799 025d 05       		.byte	5
 8800 025e 00       		.byte	0
 8801 025f 01       		.byte	1
 8802 0260 00       		.byte	0
 8803 0261 03       		.byte	3
 8804 0262 00       		.byte	0
 8805 0263 00       		.byte	0
 8806 0264 00       		.byte	0
 8807 0265 00       		.byte	0
 8808 0266 00       		.byte	0
 8809 0267 30       		.byte	48
 8810 0268 01       		.byte	1
 8811 0269 00       		.byte	0
 8812 026a 00       		.byte	0
 8813 026b 00000000 		.space	5
 8813      00
 8814 0270 00       		.byte	0
 8815 0271 00       		.byte	0
 8816 0272 02       		.byte	2
 8817 0273 00       		.byte	0
 8818 0274 00       		.byte	0
 8819 0275 40       		.byte	64
 8820 0276 00       		.byte	0
 8821 0277 01       		.byte	1
 8822 0278 00       		.byte	0
 8823 0279 03       		.byte	3
 8824 027a 00       		.byte	0
 8825 027b 00       		.byte	0
 8826 027c 00       		.byte	0
 8827 027d 00       		.byte	0
 8828 027e 00       		.byte	0
 8829 027f 30       		.byte	48
 8830 0280 01       		.byte	1
 8831 0281 00       		.byte	0
 8832 0282 00       		.byte	0
 8833 0283 00000000 		.space	5
 8833      00
 8834 0288 09       		.byte	9
 8835 0289 0A       		.byte	10
 8836 028a 04       		.byte	4
 8837 028b 00       		.byte	0
 8838 028c 00       		.byte	0
 8839 028d 40       		.byte	64
 8840 028e 00       		.byte	0
 8841 028f 01       		.byte	1
 8842 0290 00       		.byte	0
 8843 0291 03       		.byte	3
 8844 0292 00       		.byte	0
 8845 0293 20       		.byte	32
 8846 0294 38       		.byte	56
 8847 0295 20       		.byte	32
 8848 0296 38       		.byte	56
 8849 0297 30       		.byte	48
 8850 0298 01       		.byte	1
 8851 0299 00       		.byte	0
 8852 029a 00       		.byte	0
 8853 029b 00000000 		.space	5
 8853      00
 8854 02a0 00       		.byte	0
 8855 02a1 00       		.byte	0
 8856 02a2 02       		.byte	2
 8857 02a3 00       		.byte	0
 8858 02a4 00       		.byte	0
 8859 02a5 64       		.byte	100
 8860 02a6 00       		.byte	0
 8861 02a7 01       		.byte	1
 8862 02a8 00       		.byte	0
 8863 02a9 03       		.byte	3
 8864 02aa 00       		.byte	0
 8865 02ab 00       		.byte	0
 8866 02ac 00       		.byte	0
 8867 02ad 00       		.byte	0
 8868 02ae 00       		.byte	0
 8869 02af 30       		.byte	48
 8870 02b0 01       		.byte	1
 8871 02b1 00       		.byte	0
 8872 02b2 00       		.byte	0
 8873 02b3 00000000 		.space	5
 8873      00
 8874 02b8 00       		.byte	0
 8875 02b9 00       		.byte	0
 8876 02ba 02       		.byte	2
 8877 02bb 00       		.byte	0
 8878 02bc 00       		.byte	0
 8879 02bd 64       		.byte	100
 8880 02be 00       		.byte	0
 8881 02bf 01       		.byte	1
 8882 02c0 00       		.byte	0
 8883 02c1 03       		.byte	3
 8884 02c2 00       		.byte	0
 8885 02c3 00       		.byte	0
 8886 02c4 00       		.byte	0
 8887 02c5 00       		.byte	0
 8888 02c6 00       		.byte	0
 8889 02c7 30       		.byte	48
 8890 02c8 01       		.byte	1
 8891 02c9 00       		.byte	0
 8892 02ca 00       		.byte	0
 8893 02cb 00000000 		.space	5
 8893      00
 8894 02d0 2A       		.byte	42
 8895 02d1 2A       		.byte	42
 8896 02d2 02       		.byte	2
 8897 02d3 00       		.byte	0
 8898 02d4 00       		.byte	0
 8899 02d5 1B       		.byte	27
 8900 02d6 00       		.byte	0
 8901 02d7 01       		.byte	1
 8902 02d8 00       		.byte	0
 8903 02d9 03       		.byte	3
 8904 02da 00       		.byte	0
 8905 02db 00       		.byte	0
 8906 02dc 00       		.byte	0
 8907 02dd 00       		.byte	0
 8908 02de 00       		.byte	0
 8909 02df 30       		.byte	48
 8910 02e0 01       		.byte	1
 8911 02e1 00       		.byte	0
 8912 02e2 00       		.byte	0
 8913 02e3 00000000 		.space	5
 8913      00
 8914 02e8 00       		.byte	0
 8915 02e9 00       		.byte	0
 8916 02ea 02       		.byte	2
 8917 02eb 00       		.byte	0
 8918 02ec 00       		.byte	0
 8919 02ed 64       		.byte	100
 8920 02ee 00       		.byte	0
 8921 02ef 01       		.byte	1
 8922 02f0 00       		.byte	0
 8923 02f1 03       		.byte	3
 8924 02f2 00       		.byte	0
 8925 02f3 00       		.byte	0
 8926 02f4 00       		.byte	0
 8927 02f5 00       		.byte	0
 8928 02f6 00       		.byte	0
 8929 02f7 30       		.byte	48
 8930 02f8 01       		.byte	1
 8931 02f9 00       		.byte	0
 8932 02fa 00       		.byte	0
 8933 02fb 00000000 		.space	5
 8933      00
 8934 0300 00       		.byte	0
 8935 0301 00       		.byte	0
 8936 0302 02       		.byte	2
 8937 0303 00       		.byte	0
 8938 0304 00       		.byte	0
 8939 0305 12       		.byte	18
 8940 0306 00       		.byte	0
 8941 0307 01       		.byte	1
 8942 0308 00       		.byte	0
 8943 0309 03       		.byte	3
 8944 030a 00       		.byte	0
 8945 030b 00       		.byte	0
 8946 030c 00       		.byte	0
 8947 030d 00       		.byte	0
 8948 030e 00       		.byte	0
 8949 030f 30       		.byte	48
 8950 0310 01       		.byte	1
 8951 0311 00       		.byte	0
 8952 0312 00       		.byte	0
 8953 0313 00000000 		.space	5
 8953      00
 8954 0318 01       		.byte	1
 8955 0319 01       		.byte	1
 8956 031a 02       		.byte	2
 8957 031b 00       		.byte	0
 8958 031c 00       		.byte	0
 8959 031d 09       		.byte	9
 8960 031e 00       		.byte	0
 8961 031f 01       		.byte	1
 8962 0320 00       		.byte	0
 8963 0321 03       		.byte	3
 8964 0322 00       		.byte	0
 8965 0323 00       		.byte	0
 8966 0324 00       		.byte	0
 8967 0325 01       		.byte	1
 8968 0326 00       		.byte	0
 8969 0327 30       		.byte	48
 8970 0328 01       		.byte	1
 8971 0329 00       		.byte	0
 8972 032a 00       		.byte	0
 8973 032b 00000000 		.space	5
 8973      00
 8974 0330 05       		.byte	5
 8975 0331 05       		.byte	5
 8976 0332 02       		.byte	2
 8977 0333 00       		.byte	0
 8978 0334 00       		.byte	0
 8979 0335 03       		.byte	3
 8980 0336 00       		.byte	0
 8981 0337 01       		.byte	1
 8982 0338 00       		.byte	0
 8983 0339 03       		.byte	3
 8984 033a 00       		.byte	0
 8985 033b 00       		.byte	0
 8986 033c 00       		.byte	0
 8987 033d 00       		.byte	0
 8988 033e 00       		.byte	0
 8989 033f 30       		.byte	48
 8990 0340 01       		.byte	1
 8991 0341 00       		.byte	0
 8992 0342 00       		.byte	0
 8993 0343 00000000 		.space	5
 8993      00
 8994 0348 18       		.byte	24
 8995 0349 18       		.byte	24
 8996 034a 02       		.byte	2
 8997 034b 00       		.byte	0
 8998 034c 00       		.byte	0
 8999 034d 01       		.byte	1
 9000 034e 00       		.byte	0
 9001 034f 01       		.byte	1
 9002 0350 00       		.byte	0
 9003 0351 03       		.byte	3
 9004 0352 00       		.byte	0
 9005 0353 00       		.byte	0
 9006 0354 00       		.byte	0
 9007 0355 00       		.byte	0
 9008 0356 00       		.byte	0
 9009 0357 30       		.byte	48
 9010 0358 01       		.byte	1
 9011 0359 00       		.byte	0
 9012 035a 00       		.byte	0
 9013 035b 00000000 		.space	5
 9013      00
 9014 0360 19       		.byte	25
 9015 0361 19       		.byte	25
 9016 0362 01       		.byte	1
 9017 0363 00       		.byte	0
 9018 0364 00       		.byte	0
 9019 0365 40       		.byte	64
 9020 0366 00       		.byte	0
 9021 0367 01       		.byte	1
 9022 0368 00       		.byte	0
 9023 0369 03       		.byte	3
 9024 036a 00       		.byte	0
 9025 036b 20       		.byte	32
 9026 036c 00       		.byte	0
 9027 036d 20       		.byte	32
 9028 036e 00       		.byte	0
 9029 036f 30       		.byte	48
 9030 0370 01       		.byte	1
 9031 0371 00       		.byte	0
 9032 0372 00       		.byte	0
 9033 0373 00000000 		.space	5
 9033      00
 9034 0378 20       		.byte	32
 9035 0379 20       		.byte	32
 9036 037a 02       		.byte	2
 9037 037b 00       		.byte	0
 9038 037c 00       		.byte	0
 9039 037d 02       		.byte	2
 9040 037e 00       		.byte	0
 9041 037f 01       		.byte	1
 9042 0380 00       		.byte	0
 9043 0381 03       		.byte	3
 9044 0382 00       		.byte	0
 9045 0383 00       		.byte	0
 9046 0384 00       		.byte	0
 9047 0385 00       		.byte	0
 9048 0386 00       		.byte	0
 9049 0387 30       		.byte	48
 9050 0388 01       		.byte	1
 9051 0389 00       		.byte	0
 9052 038a 00       		.byte	0
 9053 038b 00000000 		.space	5
 9053      00
 9054 0390 22       		.byte	34
 9055 0391 22       		.byte	34
 9056 0392 02       		.byte	2
 9057 0393 00       		.byte	0
 9058 0394 00       		.byte	0
 9059 0395 3F       		.byte	63
 9060 0396 00       		.byte	0
 9061 0397 01       		.byte	1
 9062 0398 00       		.byte	0
 9063 0399 03       		.byte	3
 9064 039a 00       		.byte	0
 9065 039b 00       		.byte	0
 9066 039c 00       		.byte	0
 9067 039d 00       		.byte	0
 9068 039e 00       		.byte	0
 9069 039f 30       		.byte	48
 9070 03a0 01       		.byte	1
 9071 03a1 00       		.byte	0
 9072 03a2 00       		.byte	0
 9073 03a3 00000000 		.space	5
 9073      00
 9074 03a8 23       		.byte	35
 9075 03a9 23       		.byte	35
 9076 03aa 02       		.byte	2
 9077 03ab 00       		.byte	0
 9078 03ac 00       		.byte	0
 9079 03ad 64       		.byte	100
 9080 03ae 00       		.byte	0
 9081 03af 01       		.byte	1
 9082 03b0 00       		.byte	0
 9083 03b1 03       		.byte	3
 9084 03b2 00       		.byte	0
 9085 03b3 10       		.byte	16
 9086 03b4 00       		.byte	0
 9087 03b5 10       		.byte	16
 9088 03b6 00       		.byte	0
 9089 03b7 30       		.byte	48
 9090 03b8 01       		.byte	1
 9091 03b9 00       		.byte	0
 9092 03ba 00       		.byte	0
 9093 03bb 00000000 		.space	5
 9093      00
 9094 03c0 24       		.byte	36
 9095 03c1 24       		.byte	36
 9096 03c2 02       		.byte	2
 9097 03c3 00       		.byte	0
 9098 03c4 00       		.byte	0
 9099 03c5 64       		.byte	100
 9100 03c6 00       		.byte	0
 9101 03c7 01       		.byte	1
 9102 03c8 00       		.byte	0
 9103 03c9 03       		.byte	3
 9104 03ca 00       		.byte	0
 9105 03cb 10       		.byte	16
 9106 03cc 00       		.byte	0
 9107 03cd 10       		.byte	16
 9108 03ce 00       		.byte	0
 9109 03cf 30       		.byte	48
 9110 03d0 01       		.byte	1
 9111 03d1 00       		.byte	0
 9112 03d2 00       		.byte	0
 9113 03d3 00000000 		.space	5
 9113      00
 9114 03d8 02       		.byte	2
 9115 03d9 03       		.byte	3
 9116 03da 04       		.byte	4
 9117 03db 00       		.byte	0
 9118 03dc 00       		.byte	0
 9119 03dd 7F       		.byte	127
 9120 03de 00       		.byte	0
 9121 03df 01       		.byte	1
 9122 03e0 00       		.byte	0
 9123 03e1 03       		.byte	3
 9124 03e2 00       		.byte	0
 9125 03e3 00       		.byte	0
 9126 03e4 20       		.byte	32
 9127 03e5 00       		.byte	0
 9128 03e6 20       		.byte	32
 9129 03e7 30       		.byte	48
 9130 03e8 01       		.byte	1
 9131 03e9 00       		.byte	0
 9132 03ea 00       		.byte	0
 9133 03eb 00000000 		.space	5
 9133      00
 9134 03f0 04       		.byte	4
 9135 03f1 04       		.byte	4
 9136 03f2 02       		.byte	2
 9137 03f3 00       		.byte	0
 9138 03f4 00       		.byte	0
 9139 03f5 40       		.byte	64
 9140 03f6 00       		.byte	0
 9141 03f7 01       		.byte	1
 9142 03f8 00       		.byte	0
 9143 03f9 03       		.byte	3
 9144 03fa 00       		.byte	0
 9145 03fb 20       		.byte	32
 9146 03fc 00       		.byte	0
 9147 03fd 20       		.byte	32
 9148 03fe 00       		.byte	0
 9149 03ff 30       		.byte	48
 9150 0400 01       		.byte	1
 9151 0401 00       		.byte	0
 9152 0402 00       		.byte	0
 9153 0403 00000000 		.space	5
 9153      00
 9154 0408 00       		.byte	0
 9155 0409 00       		.byte	0
 9156 040a 02       		.byte	2
 9157 040b 00       		.byte	0
 9158 040c 00       		.byte	0
 9159 040d 19       		.byte	25
 9160 040e 00       		.byte	0
 9161 040f 01       		.byte	1
 9162 0410 00       		.byte	0
 9163 0411 03       		.byte	3
 9164 0412 00       		.byte	0
 9165 0413 00       		.byte	0
 9166 0414 00       		.byte	0
 9167 0415 00       		.byte	0
 9168 0416 00       		.byte	0
 9169 0417 30       		.byte	48
 9170 0418 01       		.byte	1
 9171 0419 00       		.byte	0
 9172 041a 00       		.byte	0
 9173 041b 00000000 		.space	5
 9173      00
 9174 0420 10       		.byte	16
 9175 0421 10       		.byte	16
 9176 0422 02       		.byte	2
 9177 0423 00       		.byte	0
 9178 0424 00       		.byte	0
 9179 0425 06       		.byte	6
 9180 0426 00       		.byte	0
 9181 0427 01       		.byte	1
 9182 0428 00       		.byte	0
 9183 0429 03       		.byte	3
 9184 042a 00       		.byte	0
 9185 042b 03       		.byte	3
 9186 042c 00       		.byte	0
 9187 042d 03       		.byte	3
 9188 042e 00       		.byte	0
 9189 042f 30       		.byte	48
 9190 0430 01       		.byte	1
 9191 0431 00       		.byte	0
 9192 0432 00       		.byte	0
 9193 0433 00000000 		.space	5
 9193      00
 9194 0438 00       		.byte	0
 9195 0439 00       		.byte	0
 9196 043a 02       		.byte	2
 9197 043b 00       		.byte	0
 9198 043c 00       		.byte	0
 9199 043d 03       		.byte	3
 9200 043e 00       		.byte	0
 9201 043f 01       		.byte	1
 9202 0440 00       		.byte	0
 9203 0441 03       		.byte	3
 9204 0442 00       		.byte	0
 9205 0443 00       		.byte	0
 9206 0444 00       		.byte	0
 9207 0445 00       		.byte	0
 9208 0446 00       		.byte	0
 9209 0447 30       		.byte	48
 9210 0448 01       		.byte	1
 9211 0449 00       		.byte	0
 9212 044a 00       		.byte	0
 9213 044b 00000000 		.space	5
 9213      00
 9214 0450 50       		.byte	80
 9215 0451 50       		.byte	80
 9216 0452 01       		.byte	1
 9217 0453 00       		.byte	0
 9218 0454 00       		.byte	0
 9219 0455 03       		.byte	3
 9220 0456 00       		.byte	0
 9221 0457 01       		.byte	1
 9222 0458 00       		.byte	0
 9223 0459 03       		.byte	3
 9224 045a 00       		.byte	0
 9225 045b 00       		.byte	0
 9226 045c 00       		.byte	0
 9227 045d 00       		.byte	0
 9228 045e 00       		.byte	0
 9229 045f 30       		.byte	48
 9230 0460 01       		.byte	1
 9231 0461 00       		.byte	0
 9232 0462 00       		.byte	0
 9233 0463 00000000 		.space	5
 9233      00
 9234 0468 00       		.byte	0
 9235 0469 00       		.byte	0
 9236 046a 0B       		.byte	11
 9237 046b 00       		.byte	0
 9238 046c 00       		.byte	0
 9239 046d FF       		.byte	-1
 9240 046e FF       		.byte	-1
 9241 046f 01       		.byte	1
 9242 0470 00       		.byte	0
 9243 0471 03       		.byte	3
 9244 0472 00       		.byte	0
 9245 0473 00       		.byte	0
 9246 0474 00       		.byte	0
 9247 0475 00       		.byte	0
 9248 0476 00       		.byte	0
 9249 0477 00       		.byte	0
 9250 0478 01       		.byte	1
 9251 0479 00       		.byte	0
 9252 047a 00       		.byte	0
 9253 047b 00000000 		.space	5
 9253      00
 9256              	glUVCHeader:
 9257 0480 0C       		.byte	12
 9258 0481 8C       		.byte	-116
 9259 0482 00       		.byte	0
 9260 0483 00       		.byte	0
 9261 0484 00       		.byte	0
 9262 0485 00       		.byte	0
 9263 0486 00       		.byte	0
 9264 0487 00       		.byte	0
 9265 0488 00       		.byte	0
 9266 0489 00       		.byte	0
 9267 048a 00       		.byte	0
 9268 048b 00       		.byte	0
 9271              	ROIMode:
 9272 048c 01       		.byte	1
 9273 048d 000000   		.space	3
 9276              	EXTShutter:
 9277 0490 00       		.byte	0
 9278 0491 02       		.byte	2
 9279 0492 02       		.byte	2
 9280 0493 00       		.byte	0
 9281 0494 00       		.byte	0
 9282 0495 08       		.byte	8
 9283 0496 00       		.byte	0
 9284 0497 01       		.byte	1
 9285 0498 00       		.byte	0
 9286 0499 03       		.byte	3
 9287 049a 00       		.byte	0
 9288 049b 00       		.byte	0
 9289 049c 00       		.byte	0
 9290 049d 00       		.byte	0
 9291 049e 00       		.byte	0
 9292 049f 30       		.byte	48
 9293 04a0 01       		.byte	1
 9294 04a1 00       		.byte	0
 9295 04a2 0000     		.space	2
 9298              	EXTShutlev:
 9299 04a4 02       		.byte	2
 9300 04a5 12       		.byte	18
 9301 04a6 02       		.byte	2
 9302 04a7 00       		.byte	0
 9303 04a8 00       		.byte	0
 9304 04a9 FF       		.byte	-1
 9305 04aa 7F       		.byte	127
 9306 04ab 01       		.byte	1
 9307 04ac 00       		.byte	0
 9308 04ad 03       		.byte	3
 9309 04ae 00       		.byte	0
 9310 04af 3F       		.byte	63
 9311 04b0 00       		.byte	0
 9312 04b1 3F       		.byte	63
 9313 04b2 00       		.byte	0
 9314 04b3 30       		.byte	48
 9315 04b4 01       		.byte	1
 9316 04b5 00       		.byte	0
 9317 04b6 0000     		.space	2
 9320              	EXTAexModGainlev:
 9321 04b8 00       		.byte	0
 9322 04b9 03       		.byte	3
 9323 04ba 04       		.byte	4
 9324 04bb 00       		.byte	0
 9325 04bc 00       		.byte	0
 9326 04bd 03       		.byte	3
 9327 04be 7F       		.byte	127
 9328 04bf 01       		.byte	1
 9329 04c0 00       		.byte	0
 9330 04c1 03       		.byte	3
 9331 04c2 00       		.byte	0
 9332 04c3 00       		.byte	0
 9333 04c4 3F       		.byte	63
 9334 04c5 00       		.byte	0
 9335 04c6 3F       		.byte	63
 9336 04c7 30       		.byte	48
 9337 04c8 01       		.byte	1
 9338 04c9 00       		.byte	0
 9339 04ca 0000     		.space	2
 9342              	WBMenuCmpArry:
 9343 04cc 20       		.byte	32
 9344 04cd 0F       		.byte	15
 9345 04ce 38       		.byte	56
 9346 04cf F0       		.byte	-16
 9349              	CTCtrlParArry:
 9350 04d0 00       		.byte	0
 9351 04d1 00       		.byte	0
 9352 04d2 01       		.byte	1
 9353 04d3 00       		.byte	0
 9354 04d4 00       		.byte	0
 9355 04d5 03       		.byte	3
 9356 04d6 00       		.byte	0
 9357 04d7 01       		.byte	1
 9358 04d8 00       		.byte	0
 9359 04d9 03       		.byte	3
 9360 04da 00       		.byte	0
 9361 04db 03       		.byte	3
 9362 04dc 00       		.byte	0
 9363 04dd 03       		.byte	3
 9364 04de 00       		.byte	0
 9365 04df 30       		.byte	48
 9366 04e0 01       		.byte	1
 9367 04e1 00       		.byte	0
 9368 04e2 00       		.byte	0
 9369 04e3 00000000 		.space	5
 9369      00
 9370 04e8 00       		.byte	0
 9371 04e9 00       		.byte	0
 9372 04ea 01       		.byte	1
 9373 04eb 01       		.byte	1
 9374 04ec 00       		.byte	0
 9375 04ed 0F       		.byte	15
 9376 04ee 00       		.byte	0
 9377 04ef 0F       		.byte	15
 9378 04f0 00       		.byte	0
 9379 04f1 03       		.byte	3
 9380 04f2 00       		.byte	0
 9381 04f3 02       		.byte	2
 9382 04f4 00       		.byte	0
 9383 04f5 02       		.byte	2
 9384 04f6 00       		.byte	0
 9385 04f7 30       		.byte	48
 9386 04f8 01       		.byte	1
 9387 04f9 01       		.byte	1
 9388 04fa 00       		.byte	0
 9389 04fb 00000000 		.space	5
 9389      00
 9390 0500 02       		.byte	2
 9391 0501 00       		.byte	0
 9392 0502 01       		.byte	1
 9393 0503 00       		.byte	0
 9394 0504 00       		.byte	0
 9395 0505 01       		.byte	1
 9396 0506 00       		.byte	0
 9397 0507 01       		.byte	1
 9398 0508 00       		.byte	0
 9399 0509 03       		.byte	3
 9400 050a 00       		.byte	0
 9401 050b 00       		.byte	0
 9402 050c 00       		.byte	0
 9403 050d 00       		.byte	0
 9404 050e 00       		.byte	0
 9405 050f 30       		.byte	48
 9406 0510 01       		.byte	1
 9407 0511 01       		.byte	1
 9408 0512 00       		.byte	0
 9409 0513 00000000 		.space	5
 9409      00
 9410 0518 00       		.byte	0
 9411 0519 00       		.byte	0
 9412 051a 04       		.byte	4
 9413 051b 01       		.byte	1
 9414 051c 00       		.byte	0
 9415 051d 38       		.byte	56
 9416 051e 01       		.byte	1
 9417 051f 01       		.byte	1
 9418 0520 00       		.byte	0
 9419 0521 03       		.byte	3
 9420 0522 00       		.byte	0
 9421 0523 4E       		.byte	78
 9422 0524 00       		.byte	0
 9423 0525 4E       		.byte	78
 9424 0526 00       		.byte	0
 9425 0527 30       		.byte	48
 9426 0528 01       		.byte	1
 9427 0529 00       		.byte	0
 9428 052a 00       		.byte	0
 9429 052b 00000000 		.space	5
 9429      00
 9430 0530 04       		.byte	4
 9431 0531 00       		.byte	0
 9432 0532 01       		.byte	1
 9433 0533 00       		.byte	0
 9434 0534 00       		.byte	0
 9435 0535 00       		.byte	0
 9436 0536 00       		.byte	0
 9437 0537 01       		.byte	1
 9438 0538 00       		.byte	0
 9439 0539 03       		.byte	3
 9440 053a 00       		.byte	0
 9441 053b 00       		.byte	0
 9442 053c 00       		.byte	0
 9443 053d 00       		.byte	0
 9444 053e 00       		.byte	0
 9445 053f 30       		.byte	48
 9446 0540 01       		.byte	1
 9447 0541 00       		.byte	0
 9448 0542 00       		.byte	0
 9449 0543 00000000 		.space	5
 9449      00
 9450 0548 05       		.byte	5
 9451 0549 00       		.byte	0
 9452 054a 02       		.byte	2
 9453 054b 00       		.byte	0
 9454 054c 00       		.byte	0
 9455 054d FF       		.byte	-1
 9456 054e 00       		.byte	0
 9457 054f 01       		.byte	1
 9458 0550 00       		.byte	0
 9459 0551 03       		.byte	3
 9460 0552 00       		.byte	0
 9461 0553 01       		.byte	1
 9462 0554 00       		.byte	0
 9463 0555 00       		.byte	0
 9464 0556 00       		.byte	0
 9465 0557 30       		.byte	48
 9466 0558 01       		.byte	1
 9467 0559 01       		.byte	1
 9468 055a 00       		.byte	0
 9469 055b 00000000 		.space	5
 9469      00
 9470 0560 06       		.byte	6
 9471 0561 00       		.byte	0
 9472 0562 02       		.byte	2
 9473 0563 00       		.byte	0
 9474 0564 00       		.byte	0
 9475 0565 00       		.byte	0
 9476 0566 00       		.byte	0
 9477 0567 00       		.byte	0
 9478 0568 00       		.byte	0
 9479 0569 03       		.byte	3
 9480 056a 00       		.byte	0
 9481 056b 00       		.byte	0
 9482 056c 00       		.byte	0
 9483 056d 00       		.byte	0
 9484 056e 00       		.byte	0
 9485 056f 30       		.byte	48
 9486 0570 01       		.byte	1
 9487 0571 01       		.byte	1
 9488 0572 00       		.byte	0
 9489 0573 00000000 		.space	5
 9489      00
 9490 0578 23       		.byte	35
 9491 0579 00       		.byte	0
 9492 057a 02       		.byte	2
 9493 057b 00       		.byte	0
 9494 057c 00       		.byte	0
 9495 057d 30       		.byte	48
 9496 057e 00       		.byte	0
 9497 057f 01       		.byte	1
 9498 0580 00       		.byte	0
 9499 0581 03       		.byte	3
 9500 0582 0A       		.byte	10
 9501 0583 00       		.byte	0
 9502 0584 00       		.byte	0
 9503 0585 0A       		.byte	10
 9504 0586 00       		.byte	0
 9505 0587 30       		.byte	48
 9506 0588 01       		.byte	1
 9507 0589 01       		.byte	1
 9508 058a 00       		.byte	0
 9509 058b 00000000 		.space	5
 9509      00
 9510 0590 08       		.byte	8
 9511 0591 00       		.byte	0
 9512 0592 01       		.byte	1
 9513 0593 00       		.byte	0
 9514 0594 00       		.byte	0
 9515 0595 7F       		.byte	127
 9516 0596 00       		.byte	0
 9517 0597 01       		.byte	1
 9518 0598 00       		.byte	0
 9519 0599 03       		.byte	3
 9520 059a 00       		.byte	0
 9521 059b 00       		.byte	0
 9522 059c 00       		.byte	0
 9523 059d 00       		.byte	0
 9524 059e 00       		.byte	0
 9525 059f 30       		.byte	48
 9526 05a0 01       		.byte	1
 9527 05a1 00       		.byte	0
 9528 05a2 00       		.byte	0
 9529 05a3 00000000 		.space	5
 9529      00
 9530 05a8 09       		.byte	9
 9531 05a9 00       		.byte	0
 9532 05aa 02       		.byte	2
 9533 05ab 00       		.byte	0
 9534 05ac 00       		.byte	0
 9535 05ad 05       		.byte	5
 9536 05ae 00       		.byte	0
 9537 05af 01       		.byte	1
 9538 05b0 00       		.byte	0
 9539 05b1 03       		.byte	3
 9540 05b2 00       		.byte	0
 9541 05b3 00       		.byte	0
 9542 05b4 00       		.byte	0
 9543 05b5 00       		.byte	0
 9544 05b6 00       		.byte	0
 9545 05b7 30       		.byte	48
 9546 05b8 01       		.byte	1
 9547 05b9 00       		.byte	0
 9548 05ba 00       		.byte	0
 9549 05bb 00000000 		.space	5
 9549      00
 9550 05c0 10       		.byte	16
 9551 05c1 00       		.byte	0
 9552 05c2 03       		.byte	3
 9553 05c3 00       		.byte	0
 9554 05c4 00       		.byte	0
 9555 05c5 00       		.byte	0
 9556 05c6 00       		.byte	0
 9557 05c7 00       		.byte	0
 9558 05c8 00       		.byte	0
 9559 05c9 03       		.byte	3
 9560 05ca 00       		.byte	0
 9561 05cb 00       		.byte	0
 9562 05cc 00       		.byte	0
 9563 05cd 00       		.byte	0
 9564 05ce 00       		.byte	0
 9565 05cf 30       		.byte	48
 9566 05d0 01       		.byte	1
 9567 05d1 00       		.byte	0
 9568 05d2 00       		.byte	0
 9569 05d3 00000000 		.space	5
 9569      00
 9570 05d8 00       		.byte	0
 9571 05d9 00       		.byte	0
 9572 05da 02       		.byte	2
 9573 05db 00       		.byte	0
 9574 05dc 00       		.byte	0
 9575 05dd 40       		.byte	64
 9576 05de 00       		.byte	0
 9577 05df 01       		.byte	1
 9578 05e0 00       		.byte	0
 9579 05e1 03       		.byte	3
 9580 05e2 00       		.byte	0
 9581 05e3 0F       		.byte	15
 9582 05e4 11       		.byte	17
 9583 05e5 00       		.byte	0
 9584 05e6 00       		.byte	0
 9585 05e7 30       		.byte	48
 9586 05e8 01       		.byte	1
 9587 05e9 00       		.byte	0
 9588 05ea 00       		.byte	0
 9589 05eb 00000000 		.space	5
 9589      00
 9590 05f0 00       		.byte	0
 9591 05f1 00       		.byte	0
 9592 05f2 02       		.byte	2
 9593 05f3 00       		.byte	0
 9594 05f4 00       		.byte	0
 9595 05f5 64       		.byte	100
 9596 05f6 00       		.byte	0
 9597 05f7 01       		.byte	1
 9598 05f8 00       		.byte	0
 9599 05f9 03       		.byte	3
 9600 05fa 00       		.byte	0
 9601 05fb 00       		.byte	0
 9602 05fc 00       		.byte	0
 9603 05fd 00       		.byte	0
 9604 05fe 00       		.byte	0
 9605 05ff 30       		.byte	48
 9606 0600 01       		.byte	1
 9607 0601 00       		.byte	0
 9608 0602 00       		.byte	0
 9609 0603 00000000 		.space	5
 9609      00
 9610 0608 00       		.byte	0
 9611 0609 00       		.byte	0
 9612 060a 02       		.byte	2
 9613 060b 00       		.byte	0
 9614 060c 00       		.byte	0
 9615 060d 64       		.byte	100
 9616 060e 00       		.byte	0
 9617 060f 01       		.byte	1
 9618 0610 00       		.byte	0
 9619 0611 03       		.byte	3
 9620 0612 00       		.byte	0
 9621 0613 00       		.byte	0
 9622 0614 00       		.byte	0
 9623 0615 00       		.byte	0
 9624 0616 00       		.byte	0
 9625 0617 30       		.byte	48
 9626 0618 01       		.byte	1
 9627 0619 00       		.byte	0
 9628 061a 00       		.byte	0
 9629 061b 00000000 		.space	5
 9629      00
 9630 0620 00       		.byte	0
 9631 0621 00       		.byte	0
 9632 0622 02       		.byte	2
 9633 0623 00       		.byte	0
 9634 0624 00       		.byte	0
 9635 0625 64       		.byte	100
 9636 0626 00       		.byte	0
 9637 0627 01       		.byte	1
 9638 0628 00       		.byte	0
 9639 0629 03       		.byte	3
 9640 062a 00       		.byte	0
 9641 062b 00       		.byte	0
 9642 062c 00       		.byte	0
 9643 062d 00       		.byte	0
 9644 062e 00       		.byte	0
 9645 062f 30       		.byte	48
 9646 0630 01       		.byte	1
 9647 0631 00       		.byte	0
 9648 0632 00       		.byte	0
 9649 0633 00000000 		.space	5
 9649      00
 9650 0638 00       		.byte	0
 9651 0639 00       		.byte	0
 9652 063a 02       		.byte	2
 9653 063b 00       		.byte	0
 9654 063c 00       		.byte	0
 9655 063d 64       		.byte	100
 9656 063e 00       		.byte	0
 9657 063f 01       		.byte	1
 9658 0640 00       		.byte	0
 9659 0641 03       		.byte	3
 9660 0642 00       		.byte	0
 9661 0643 00       		.byte	0
 9662 0644 00       		.byte	0
 9663 0645 00       		.byte	0
 9664 0646 00       		.byte	0
 9665 0647 30       		.byte	48
 9666 0648 01       		.byte	1
 9667 0649 00       		.byte	0
 9668 064a 00       		.byte	0
 9669 064b 00000000 		.space	5
 9669      00
 9672              	glProbeCtrlFull:
 9673 0650 00       		.byte	0
 9674 0651 00       		.byte	0
 9675 0652 01       		.byte	1
 9676 0653 01       		.byte	1
 9677 0654 15       		.byte	21
 9678 0655 16       		.byte	22
 9679 0656 05       		.byte	5
 9680 0657 00       		.byte	0
 9681 0658 00       		.byte	0
 9682 0659 00       		.byte	0
 9683 065a 00       		.byte	0
 9684 065b 00       		.byte	0
 9685 065c 00       		.byte	0
 9686 065d 00       		.byte	0
 9687 065e 00       		.byte	0
 9688 065f 00       		.byte	0
 9689 0660 00       		.byte	0
 9690 0661 00       		.byte	0
 9691 0662 00       		.byte	0
 9692 0663 C6       		.byte	-58
 9693 0664 99       		.byte	-103
 9694 0665 00       		.byte	0
 9695 0666 00       		.byte	0
 9696 0667 40       		.byte	64
 9697 0668 00       		.byte	0
 9698 0669 00       		.byte	0
 9699 066a 0000     		.space	2
 9702              	glProbeCtrl20:
 9703 066c 00       		.byte	0
 9704 066d 00       		.byte	0
 9705 066e 01       		.byte	1
 9706 066f 01       		.byte	1
 9707 0670 80       		.byte	-128
 9708 0671 1A       		.byte	26
 9709 0672 06       		.byte	6
 9710 0673 00       		.byte	0
 9711 0674 00       		.byte	0
 9712 0675 00       		.byte	0
 9713 0676 00       		.byte	0
 9714 0677 00       		.byte	0
 9715 0678 00       		.byte	0
 9716 0679 00       		.byte	0
 9717 067a 00       		.byte	0
 9718 067b 00       		.byte	0
 9719 067c 00       		.byte	0
 9720 067d 00       		.byte	0
 9721 067e 00       		.byte	0
 9722 067f D2       		.byte	-46
 9723 0680 0F       		.byte	15
 9724 0681 00       		.byte	0
 9725 0682 00       		.byte	0
 9726 0683 40       		.byte	64
 9727 0684 00       		.byte	0
 9728 0685 00       		.byte	0
 9729 0686 0000     		.space	2
 9732              	glProbeCtrl:
 9733 0688 00       		.byte	0
 9734 0689 00       		.byte	0
 9735 068a 01       		.byte	1
 9736 068b 01       		.byte	1
 9737 068c 15       		.byte	21
 9738 068d 16       		.byte	22
 9739 068e 05       		.byte	5
 9740 068f 00       		.byte	0
 9741 0690 00       		.byte	0
 9742 0691 00       		.byte	0
 9743 0692 00       		.byte	0
 9744 0693 00       		.byte	0
 9745 0694 00       		.byte	0
 9746 0695 00       		.byte	0
 9747 0696 00       		.byte	0
 9748 0697 00       		.byte	0
 9749 0698 00       		.byte	0
 9750 0699 00       		.byte	0
 9751 069a 00       		.byte	0
 9752 069b 48       		.byte	72
 9753 069c 3F       		.byte	63
 9754 069d 00       		.byte	0
 9755 069e 00       		.byte	0
 9756 069f 40       		.byte	64
 9757 06a0 00       		.byte	0
 9758 06a1 00       		.byte	0
 9759 06a2 0000     		.space	2
 9762              	glProbeStilCtrl:
 9763 06a4 01       		.byte	1
 9764 06a5 02       		.byte	2
 9765 06a6 00       		.byte	0
 9766 06a7 00       		.byte	0
 9767 06a8 C6       		.byte	-58
 9768 06a9 99       		.byte	-103
 9769 06aa 00       		.byte	0
 9770 06ab 00       		.byte	0
 9771 06ac 40       		.byte	64
 9772 06ad 00       		.byte	0
 9773 06ae 00       		.byte	0
 9774 06af 00       		.space	1
 9777              	glProbeStilCtrl20:
 9778 06b0 01       		.byte	1
 9779 06b1 01       		.byte	1
 9780 06b2 00       		.byte	0
 9781 06b3 00       		.byte	0
 9782 06b4 D2       		.byte	-46
 9783 06b5 0F       		.byte	15
 9784 06b6 00       		.byte	0
 9785 06b7 00       		.byte	0
 9786 06b8 40       		.byte	64
 9787 06b9 00       		.byte	0
 9788 06ba 00       		.byte	0
 9791              	snapButFlag:
 9792 06bb 01       		.byte	1
 9795              	CyFxGpifTransition:
 9796 06bc 0000     		.short	0
 9797 06be 5555     		.short	21845
 9798 06c0 8888     		.short	-30584
 9799 06c2 AAAA     		.short	-21846
 9800 06c4 3333     		.short	13107
 9801 06c6 0000     		.space	2
 9804              	CyFxGpifWavedata:
 9805 06c8 0181731E 		.word	510886145
 9806 06cc 00000000 		.word	0
 9807 06d0 00000080 		.word	-2147483648
 9808 06d4 00000000 		.word	0
 9809 06d8 00000000 		.word	0
 9810 06dc 00000000 		.word	0
 9811 06e0 0201702E 		.word	779092226
 9812 06e4 00010000 		.word	256
 9813 06e8 A0000080 		.word	-2147483488
 9814 06ec 00000000 		.word	0
 9815 06f0 00000000 		.word	0
 9816 06f4 00000000 		.word	0
 9817 06f8 0380722E 		.word	779255811
 9818 06fc 02010020 		.word	536871170
 9819 0700 60000080 		.word	-2147483552
 9820 0704 00000000 		.word	0
 9821 0708 00000000 		.word	0
 9822 070c 00000000 		.word	0
 9823 0710 0460722E 		.word	779247620
 9824 0714 02010024 		.word	603980034
 9825 0718 90000080 		.word	-2147483504
 9826 071c 0594731E 		.word	510891013
 9827 0720 06000000 		.word	6
 9828 0724 00000080 		.word	-2147483648
 9829 0728 0380722E 		.word	779255811
 9830 072c 02010020 		.word	536871170
 9831 0730 60000080 		.word	-2147483552
 9832 0734 0693731E 		.word	510890758
 9833 0738 06000000 		.word	6
 9834 073c 00000080 		.word	-2147483648
 9835 0740 0720703E 		.word	1047535623
 9836 0744 08010000 		.word	264
 9837 0748 00000080 		.word	-2147483648
 9838 074c 0820703E 		.word	1047535624
 9839 0750 08010000 		.word	264
 9840 0754 00000080 		.word	-2147483648
 9841 0758 0920703E 		.word	1047535625
 9842 075c 08010000 		.word	264
 9843 0760 00000080 		.word	-2147483648
 9844 0764 0A20703E 		.word	1047535626
 9845 0768 08010000 		.word	264
 9846 076c 00000080 		.word	-2147483648
 9847 0770 0380722E 		.word	779255811
 9848 0774 02010020 		.word	536871170
 9849 0778 60000080 		.word	-2147483552
 9850 077c 0B000000 		.word	11
 9851 0780 00000000 		.word	0
 9852 0784 00010080 		.word	-2147483392
 9853 0788 0460722E 		.word	779247620
 9854 078c 02010024 		.word	603980034
 9855 0790 90000080 		.word	-2147483504
 9856 0794 0D000000 		.word	13
 9857 0798 00000000 		.word	0
 9858 079c 00010080 		.word	-2147483392
 9859 07a0 0460722E 		.word	779247620
 9860 07a4 02010024 		.word	603980034
 9861 07a8 90000080 		.word	-2147483504
 9862 07ac 0C000000 		.word	12
 9863 07b0 00000000 		.word	0
 9864 07b4 00010080 		.word	-2147483392
 9865 07b8 0380722E 		.word	779255811
 9866 07bc 02010020 		.word	536871170
 9867 07c0 60000080 		.word	-2147483552
 9868 07c4 0E000000 		.word	14
 9869 07c8 00000000 		.word	0
 9870 07cc 00010080 		.word	-2147483392
 9871 07d0 00000000 		.word	0
 9872 07d4 00000000 		.word	0
 9873 07d8 00000000 		.word	0
 9874 07dc 00000000 		.word	0
 9875 07e0 00000000 		.word	0
 9876 07e4 00000000 		.word	0
 9879              	CyFxGpifWavedataPosition:
 9880 07e8 00       		.byte	0
 9881 07e9 01       		.byte	1
 9882 07ea 02       		.byte	2
 9883 07eb 03       		.byte	3
 9884 07ec 04       		.byte	4
 9885 07ed 05       		.byte	5
 9886 07ee 06       		.byte	6
 9887 07ef 07       		.byte	7
 9888 07f0 08       		.byte	8
 9889 07f1 09       		.byte	9
 9890 07f2 0A       		.byte	10
 9891 07f3 0B       		.byte	11
 9892 07f4 0B       		.byte	11
 9893 07f5 0B       		.byte	11
 9894 07f6 0B       		.byte	11
 9895 07f7 00       		.space	1
 9898              	CyFxGpifRegValue:
 9899 07f8 08830080 		.word	-2147450104
 9900 07fc 67000000 		.word	103
 9901 0800 00000000 		.word	0
 9902 0804 46000000 		.word	70
 9903 0808 00000000 		.word	0
 9904 080c 00000000 		.word	0
 9905 0810 02000000 		.word	2
 9906 0814 82000000 		.word	130
 9907 0818 82070000 		.word	1922
 9908 081c 40040000 		.word	1088
 9909 0820 FCFF0000 		.word	65532
 9910 0824 28000000 		.word	40
 9911 0828 00000000 		.word	0
 9912 082c 00000000 		.word	0
 9913 0830 00000000 		.word	0
 9914 0834 00000000 		.word	0
 9915 0838 01000000 		.word	1
 9916 083c 00000000 		.word	0
 9917 0840 00000000 		.word	0
 9918 0844 00000000 		.word	0
 9919 0848 00000000 		.word	0
 9920 084c 00000000 		.word	0
 9921 0850 00000000 		.word	0
 9922 0854 00000000 		.word	0
 9923 0858 00000000 		.word	0
 9924 085c 00000000 		.word	0
 9925 0860 00000000 		.word	0
 9926 0864 00000000 		.word	0
 9927 0868 00000000 		.word	0
 9928 086c 06000000 		.word	6
 9929 0870 00000000 		.word	0
 9930 0874 FFFF0000 		.word	65535
 9931 0878 09010000 		.word	265
 9932 087c 00000000 		.word	0
 9933 0880 F71F0000 		.word	8183
 9934 0884 00000000 		.word	0
 9935 0888 FFFF0000 		.word	65535
 9936 088c 09010000 		.word	265
 9937 0890 00000000 		.word	0
 9938 0894 F71F0000 		.word	8183
 9939 0898 00000000 		.word	0
 9940 089c 00000000 		.word	0
 9941 08a0 00000000 		.word	0
 9942 08a4 00000000 		.word	0
 9943 08a8 00000000 		.word	0
 9944 08ac 00000000 		.word	0
 9945 08b0 00000000 		.word	0
 9946 08b4 00000000 		.word	0
 9947 08b8 00000000 		.word	0
 9948 08bc 00000000 		.word	0
 9949 08c0 00000000 		.word	0
 9950 08c4 00000000 		.word	0
 9951 08c8 00000000 		.word	0
 9952 08cc 00000000 		.word	0
 9953 08d0 00000000 		.word	0
 9954 08d4 00000000 		.word	0
 9955 08d8 00000000 		.word	0
 9956 08dc 00000000 		.word	0
 9957 08e0 00000000 		.word	0
 9958 08e4 00000000 		.word	0
 9959 08e8 00000000 		.word	0
 9960 08ec 00000000 		.word	0
 9961 08f0 00000000 		.word	0
 9962 08f4 00040180 		.word	-2147417088
 9963 08f8 01040180 		.word	-2147417087
 9964 08fc 02040180 		.word	-2147417086
 9965 0900 03040180 		.word	-2147417085
 9966 0904 00000000 		.word	0
 9967 0908 00000000 		.word	0
 9968 090c 00000000 		.word	0
 9969 0910 00000000 		.word	0
 9970 0914 00000000 		.word	0
 9971 0918 00000000 		.word	0
 9972 091c 00000000 		.word	0
 9973 0920 00000000 		.word	0
 9974 0924 C1FFFFFF 		.word	-63
 9977              	CyFxGpifTransition_usb2:
 9978 0928 0000     		.short	0
 9979 092a 5555     		.short	21845
 9980 092c AAAA     		.short	-21846
 9981 092e 8888     		.short	-30584
 9982 0930 1111     		.short	4369
 9983 0932 4444     		.short	17476
 9984 0934 3333     		.short	13107
 9985 0936 CCCC     		.short	-13108
 9988              	CyFxGpifWavedata_usb2:
 9989 0938 0181731E 		.word	510886145
 9990 093c 00000000 		.word	0
 9991 0940 00000080 		.word	-2147483648
 9992 0944 00000000 		.word	0
 9993 0948 00000000 		.word	0
 9994 094c 00000000 		.word	0
 9995 0950 0201703E 		.word	1047527682
 9996 0954 00010000 		.word	256
 9997 0958 A00000C0 		.word	-1073741664
 9998 095c 00000000 		.word	0
 9999 0960 00000000 		.word	0
 10000 0964 00000000 		.word	0
 10001 0968 0394731E 		.word	510891011
 10002 096c 04000020 		.word	536870916
 10003 0970 60004080 		.word	-2143289248
 10004 0974 00000000 		.word	0
 10005 0978 00000000 		.word	0
 10006 097c 00000000 		.word	0
 10007 0980 0620702E 		.word	779100166
 10008 0984 0C000000 		.word	12
 10009 0988 00000080 		.word	-2147483648
 10010 098c 0620702E 		.word	779100166
 10011 0990 0C000000 		.word	12
 10012 0994 00000080 		.word	-2147483648
 10013 0998 0394731E 		.word	510891011
 10014 099c 04000020 		.word	536870916
 10015 09a0 60004080 		.word	-2143289248
 10016 09a4 0620702E 		.word	779100166
 10017 09a8 0C000000 		.word	12
 10018 09ac 00000080 		.word	-2147483648
 10019 09b0 0C93731E 		.word	510890764
 10020 09b4 04000024 		.word	603979780
 10021 09b8 90004080 		.word	-2143289200
 10022 09bc 0D20702E 		.word	779100173
 10023 09c0 0C000000 		.word	12
 10024 09c4 00000080 		.word	-2147483648
 10025 09c8 0780724E 		.word	1316126727
 10026 09cc 0A000000 		.word	10
 10027 09d0 00000080 		.word	-2147483648
 10028 09d4 08000000 		.word	8
 10029 09d8 00000000 		.word	0
 10030 09dc 00010080 		.word	-2147483392
 10031 09e0 0920702E 		.word	779100169
 10032 09e4 0C010000 		.word	268
 10033 09e8 00000080 		.word	-2147483648
 10034 09ec 0A01701E 		.word	510656778
 10035 09f0 0E000100 		.word	65550
 10036 09f4 00000080 		.word	-2147483648
 10037 09f8 00000000 		.word	0
 10038 09fc 00000000 		.word	0
 10039 0a00 00000000 		.word	0
 10040 0a04 00000000 		.word	0
 10041 0a08 00000000 		.word	0
 10042 0a0c 00000000 		.word	0
 10043 0a10 0394731E 		.word	510891011
 10044 0a14 04000020 		.word	536870916
 10045 0a18 60004080 		.word	-2143289248
 10046 0a1c 08000000 		.word	8
 10047 0a20 00000000 		.word	0
 10048 0a24 00010080 		.word	-2147483392
 10049 0a28 0B000000 		.word	11
 10050 0a2c 00000000 		.word	0
 10051 0a30 00010080 		.word	-2147483392
 10052 0a34 0C93731E 		.word	510890764
 10053 0a38 04000024 		.word	603979780
 10054 0a3c 90004080 		.word	-2143289200
 10055 0a40 0D20702E 		.word	779100173
 10056 0a44 0C000000 		.word	12
 10057 0a48 00000080 		.word	-2147483648
 10058 0a4c 0D20702E 		.word	779100173
 10059 0a50 0C000000 		.word	12
 10060 0a54 00000080 		.word	-2147483648
 10061 0a58 0E60724E 		.word	1316118542
 10062 0a5c 0A000000 		.word	10
 10063 0a60 00000080 		.word	-2147483648
 10064 0a64 0F000000 		.word	15
 10065 0a68 00000000 		.word	0
 10066 0a6c 00010080 		.word	-2147483392
 10067 0a70 1020702E 		.word	779100176
 10068 0a74 0C010000 		.word	268
 10069 0a78 00000080 		.word	-2147483648
 10070 0a7c 1101701E 		.word	510656785
 10071 0a80 0E000100 		.word	65550
 10072 0a84 00000080 		.word	-2147483648
 10073 0a88 0C93731E 		.word	510890764
 10074 0a8c 04000024 		.word	603979780
 10075 0a90 90004080 		.word	-2143289200
 10076 0a94 0F000000 		.word	15
 10077 0a98 00000000 		.word	0
 10078 0a9c 00010080 		.word	-2147483392
 10079 0aa0 12000000 		.word	18
 10080 0aa4 00000000 		.word	0
 10081 0aa8 00010080 		.word	-2147483392
 10082 0aac 0394731E 		.word	510891011
 10083 0ab0 04000020 		.word	536870916
 10084 0ab4 60004080 		.word	-2143289248
 10085 0ab8 0480732E 		.word	779321348
 10086 0abc 02010000 		.word	258
 10087 0ac0 0000C0C0 		.word	-1061158912
 10088 0ac4 0580732E 		.word	779321349
 10089 0ac8 02010000 		.word	258
 10090 0acc 0000C0C0 		.word	-1061158912
 10091 0ad0 0580732E 		.word	779321349
 10092 0ad4 02010000 		.word	258
 10093 0ad8 0000C0C0 		.word	-1061158912
 10094 0adc 0480732E 		.word	779321348
 10095 0ae0 02010000 		.word	258
 10096 0ae4 0000C0C0 		.word	-1061158912
 10099              	CyFxGpifWavedataPosition_usb2:
 10100 0ae8 00       		.byte	0
 10101 0ae9 01       		.byte	1
 10102 0aea 02       		.byte	2
 10103 0aeb 03       		.byte	3
 10104 0aec 04       		.byte	4
 10105 0aed 05       		.byte	5
 10106 0aee 06       		.byte	6
 10107 0aef 07       		.byte	7
 10108 0af0 08       		.byte	8
 10109 0af1 09       		.byte	9
 10110 0af2 0A       		.byte	10
 10111 0af3 08       		.byte	8
 10112 0af4 0B       		.byte	11
 10113 0af5 0C       		.byte	12
 10114 0af6 0D       		.byte	13
 10115 0af7 08       		.byte	8
 10116 0af8 0E       		.byte	14
 10117 0af9 0F       		.byte	15
 10118 0afa 08       		.byte	8
 10119 0afb 08       		.byte	8
 10120 0afc 08       		.byte	8
 10121 0afd 08       		.byte	8
 10122 0afe 08       		.byte	8
 10123 0aff 08       		.byte	8
 10124 0b00 08       		.byte	8
 10125 0b01 08       		.byte	8
 10126 0b02 08       		.byte	8
 10127 0b03 08       		.byte	8
 10128 0b04 08       		.byte	8
 10129 0b05 08       		.byte	8
 10130 0b06 08       		.byte	8
 10131 0b07 08       		.byte	8
 10132 0b08 08       		.byte	8
 10133 0b09 08       		.byte	8
 10134 0b0a 08       		.byte	8
 10135 0b0b 08       		.byte	8
 10136 0b0c 08       		.byte	8
 10137 0b0d 08       		.byte	8
 10138 0b0e 08       		.byte	8
 10139 0b0f 08       		.byte	8
 10140 0b10 08       		.byte	8
 10141 0b11 08       		.byte	8
 10142 0b12 08       		.byte	8
 10143 0b13 08       		.byte	8
 10144 0b14 08       		.byte	8
 10145 0b15 08       		.byte	8
 10146 0b16 08       		.byte	8
 10147 0b17 08       		.byte	8
 10148 0b18 08       		.byte	8
 10149 0b19 08       		.byte	8
 10150 0b1a 08       		.byte	8
 10151 0b1b 08       		.byte	8
 10152 0b1c 08       		.byte	8
 10153 0b1d 08       		.byte	8
 10154 0b1e 08       		.byte	8
 10155 0b1f 08       		.byte	8
 10156 0b20 08       		.byte	8
 10157 0b21 08       		.byte	8
 10158 0b22 08       		.byte	8
 10159 0b23 08       		.byte	8
 10160 0b24 08       		.byte	8
 10161 0b25 08       		.byte	8
 10162 0b26 08       		.byte	8
 10163 0b27 08       		.byte	8
 10164 0b28 08       		.byte	8
 10165 0b29 08       		.byte	8
 10166 0b2a 08       		.byte	8
 10167 0b2b 08       		.byte	8
 10168 0b2c 08       		.byte	8
 10169 0b2d 08       		.byte	8
 10170 0b2e 08       		.byte	8
 10171 0b2f 08       		.byte	8
 10172 0b30 08       		.byte	8
 10173 0b31 08       		.byte	8
 10174 0b32 08       		.byte	8
 10175 0b33 08       		.byte	8
 10176 0b34 08       		.byte	8
 10177 0b35 08       		.byte	8
 10178 0b36 08       		.byte	8
 10179 0b37 08       		.byte	8
 10180 0b38 08       		.byte	8
 10181 0b39 08       		.byte	8
 10182 0b3a 08       		.byte	8
 10183 0b3b 08       		.byte	8
 10184 0b3c 08       		.byte	8
 10185 0b3d 08       		.byte	8
 10186 0b3e 08       		.byte	8
 10187 0b3f 08       		.byte	8
 10188 0b40 08       		.byte	8
 10189 0b41 08       		.byte	8
 10190 0b42 08       		.byte	8
 10191 0b43 08       		.byte	8
 10192 0b44 08       		.byte	8
 10193 0b45 08       		.byte	8
 10194 0b46 08       		.byte	8
 10195 0b47 08       		.byte	8
 10196 0b48 08       		.byte	8
 10197 0b49 08       		.byte	8
 10198 0b4a 08       		.byte	8
 10199 0b4b 08       		.byte	8
 10200 0b4c 08       		.byte	8
 10201 0b4d 08       		.byte	8
 10202 0b4e 08       		.byte	8
 10203 0b4f 08       		.byte	8
 10204 0b50 08       		.byte	8
 10205 0b51 08       		.byte	8
 10206 0b52 08       		.byte	8
 10207 0b53 08       		.byte	8
 10208 0b54 08       		.byte	8
 10209 0b55 08       		.byte	8
 10210 0b56 08       		.byte	8
 10211 0b57 08       		.byte	8
 10212 0b58 08       		.byte	8
 10213 0b59 08       		.byte	8
 10214 0b5a 08       		.byte	8
 10215 0b5b 08       		.byte	8
 10216 0b5c 08       		.byte	8
 10217 0b5d 08       		.byte	8
 10218 0b5e 08       		.byte	8
 10219 0b5f 08       		.byte	8
 10220 0b60 08       		.byte	8
 10221 0b61 08       		.byte	8
 10222 0b62 08       		.byte	8
 10223 0b63 08       		.byte	8
 10224 0b64 08       		.byte	8
 10225 0b65 08       		.byte	8
 10226 0b66 08       		.byte	8
 10227 0b67 08       		.byte	8
 10228 0b68 00       		.byte	0
 10229 0b69 01       		.byte	1
 10230 0b6a 02       		.byte	2
 10231 0b6b 10       		.byte	16
 10232 0b6c 04       		.byte	4
 10233 0b6d 05       		.byte	5
 10234 0b6e 06       		.byte	6
 10235 0b6f 07       		.byte	7
 10236 0b70 08       		.byte	8
 10237 0b71 09       		.byte	9
 10238 0b72 0A       		.byte	10
 10239 0b73 08       		.byte	8
 10240 0b74 11       		.byte	17
 10241 0b75 0C       		.byte	12
 10242 0b76 0D       		.byte	13
 10243 0b77 08       		.byte	8
 10244 0b78 0E       		.byte	14
 10245 0b79 0F       		.byte	15
 10246 0b7a 08       		.byte	8
 10247 0b7b 00       		.space	1
 10250              	CyFxGpifRegValue_usb2:
 10251 0b7c 08830080 		.word	-2147450104
 10252 0b80 67000000 		.word	103
 10253 0b84 01000000 		.word	1
 10254 0b88 46000000 		.word	70
 10255 0b8c 00000000 		.word	0
 10256 0b90 00000000 		.word	0
 10257 0b94 02000000 		.word	2
 10258 0b98 82000000 		.word	130
 10259 0b9c 82070000 		.word	1922
 10260 0ba0 40040000 		.word	1088
 10261 0ba4 FCFF0000 		.word	65532
 10262 0ba8 28000000 		.word	40
 10263 0bac 00000000 		.word	0
 10264 0bb0 00000000 		.word	0
 10265 0bb4 00000000 		.word	0
 10266 0bb8 00000000 		.word	0
 10267 0bbc 01000000 		.word	1
 10268 0bc0 00000000 		.word	0
 10269 0bc4 00000000 		.word	0
 10270 0bc8 00000000 		.word	0
 10271 0bcc 00000000 		.word	0
 10272 0bd0 00000000 		.word	0
 10273 0bd4 00000000 		.word	0
 10274 0bd8 00000000 		.word	0
 10275 0bdc 00000000 		.word	0
 10276 0be0 00000000 		.word	0
 10277 0be4 00000000 		.word	0
 10278 0be8 00000000 		.word	0
 10279 0bec 00000000 		.word	0
 10280 0bf0 06000000 		.word	6
 10281 0bf4 00000000 		.word	0
 10282 0bf8 FFFF0000 		.word	65535
 10283 0bfc 09010000 		.word	265
 10284 0c00 00000000 		.word	0
 10285 0c04 F71F0000 		.word	8183
 10286 0c08 00000000 		.word	0
 10287 0c0c FFFF0000 		.word	65535
 10288 0c10 09010000 		.word	265
 10289 0c14 00000000 		.word	0
 10290 0c18 F71F0000 		.word	8183
 10291 0c1c 00000000 		.word	0
 10292 0c20 00000000 		.word	0
 10293 0c24 00000000 		.word	0
 10294 0c28 00000000 		.word	0
 10295 0c2c 00000000 		.word	0
 10296 0c30 00000000 		.word	0
 10297 0c34 00000000 		.word	0
 10298 0c38 00000000 		.word	0
 10299 0c3c 00000000 		.word	0
 10300 0c40 00000000 		.word	0
 10301 0c44 00000000 		.word	0
 10302 0c48 00000000 		.word	0
 10303 0c4c 00000000 		.word	0
 10304 0c50 00000000 		.word	0
 10305 0c54 00000000 		.word	0
 10306 0c58 00000000 		.word	0
 10307 0c5c 00000000 		.word	0
 10308 0c60 00000000 		.word	0
 10309 0c64 00000000 		.word	0
 10310 0c68 00000000 		.word	0
 10311 0c6c 00000000 		.word	0
 10312 0c70 00000000 		.word	0
 10313 0c74 00000000 		.word	0
 10314 0c78 00040180 		.word	-2147417088
 10315 0c7c 01040180 		.word	-2147417087
 10316 0c80 02040180 		.word	-2147417086
 10317 0c84 03040180 		.word	-2147417085
 10318 0c88 00000000 		.word	0
 10319 0c8c 00000000 		.word	0
 10320 0c90 00000000 		.word	0
 10321 0c94 00000000 		.word	0
 10322 0c98 00000000 		.word	0
 10323 0c9c 00000000 		.word	0
 10324 0ca0 00000000 		.word	0
 10325 0ca4 00000000 		.word	0
 10326 0ca8 C1FFFFFF 		.word	-63
 10327              		.section	.rodata.str1.4,"aMS",%progbits,1
 10328              		.align	2
 10329              	.LC0:
 10330 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 10330      7065722D 
 10330      74696D65 
 10330      72202564 
 10330      0D0A00
 10331 0013 00       		.space	1
 10332              	.LC1:
 10333 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 10333      636F6D6D 
 10333      616E6420 
 10333      71756575 
 10333      65206973 
 10334 0037 00       		.space	1
 10335              	.LC2:
 10336 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 10336      5420656E 
 10336      636F756E 
 10336      74657265 
 10336      642E2E2E 
 10337              	.LC3:
 10338 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 10338      454E4420 
 10338      656E636F 
 10338      756E7465 
 10338      7265642E 
 10339 007a 0000     		.space	2
 10340              	.LC4:
 10341 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 10341      64697363 
 10341      6F6E6E65 
 10341      63746564 
 10341      2E2E2E30 
 10342 009b 00       		.space	1
 10343              	.LC5:
 10344 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 10344      7220696E 
 10344      206D756C 
 10344      74696368 
 10344      616E6E65 
 10345 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 10345      2025782C 
 10345      20646D61 
 10345      446F6E65 
 10345      20256420 
 10346              	.LC6:
 10347 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 10347      43595F46 
 10347      585F5556 
 10347      435F5649 
 10347      44454F5F 
 10348 011b 0A00     		.ascii	"\012\000"
 10349 011d 000000   		.space	3
 10350              	.LC7:
 10351 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 10351      43595F46 
 10351      585F5556 
 10351      435F5649 
 10351      44454F5F 
 10352 0153 00       		.ascii	"\000"
 10353              	.LC8:
 10354 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 10354      726E6174 
 10354      65207365 
 10354      7474696E 
 10354      6720302E 
 10355              	.LC9:
 10356 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 10356      72206665 
 10356      61747572 
 10356      65207265 
 10356      71756573 
 10357 018f 00       		.space	1
 10358              	.LC10:
 10359 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 10359      6F6D6D69 
 10359      74656F66 
 10359      20737461 
 10359      7465203D 
 10360              	.LC11:
 10361 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 10361      6E656C20 
 10361      53657420 
 10361      57726170 
 10361      55702066 
 10362 01d5 000000   		.space	3
 10363              	.LC12:
 10364 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 10364      72206861 
 10364      6E646C65 
 10364      722E2E2E 
 10364      0D0A00
 10365 01eb 00       		.space	1
 10366              	.LC13:
 10367 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 10367      69742045 
 10367      4F462066 
 10367      61696C65 
 10367      64210D0A 
 10368 0201 000000   		.space	3
 10369              	.LC14:
 10370 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 10370      49324320 
 10370      636F6D6D 
 10370      616E6420 
 10370      69732030 
 10371 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10371      78257820 
 10371      30782578 
 10371      20307825 
 10371      78203078 
 10372              	.LC15:
 10373 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 10373      49324320 
 10373      636F6D6D 
 10373      616E6420 
 10373      73657474 
 10374 0276 0000     		.space	2
 10375              	.LC16:
 10376 0278 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 10376      73687574 
 10376      74657220 
 10376      73657420 
 10376      76616C75 
 10377 02a2 0000     		.space	2
 10378              	.LC17:
 10379 02a4 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 10379      206C6967 
 10379      68742063 
 10379      6F6D7065 
 10379      6E736174 
 10380 02d7 25640D0A 		.ascii	"%d\015\012\000"
 10380      00
 10381              	.LC18:
 10382 02dc 54686520 		.ascii	"The I2C current data is not available. try again. %"
 10382      49324320 
 10382      63757272 
 10382      656E7420 
 10382      64617461 
 10383 030f 64202564 		.ascii	"d %d\015\012\000"
 10383      0D0A00
 10384 0316 0000     		.space	2
 10385              	.LC19:
 10386 0318 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 10386      26414743 
 10386      2073656E 
 10386      7420746F 
 10386      20686F73 
 10387 033e 0000     		.space	2
 10388              	.LC20:
 10389 0340 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 10389      26414743 
 10389      20676F74 
 10389      74656E20 
 10389      66726F6D 
 10390 0371 0A00     		.ascii	"\012\000"
 10391 0373 00       		.space	1
 10392              	.LC21:
 10393 0374 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 10393      74657220 
 10393      6C657665 
 10393      6C20676F 
 10393      7474656E 
 10394 03a7 25640D0A 		.ascii	"%d\015\012\000"
 10394      00
 10395              	.LC22:
 10396 03ac 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 10396      67657420 
 10396      64617461 
 10396      2066726F 
 10396      6D20686F 
 10397 03d9 000000   		.space	3
 10398              	.LC23:
 10399 03dc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 10399      52657175 
 10399      65737420 
 10399      30782578 
 10399      20706172 
 10400 040f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 10400      6E642074 
 10400      6F20686F 
 10400      73742030 
 10400      78257820 
 10401 042a 0000     		.space	2
 10402              	.LC24:
 10403 042c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 10403      204F7020 
 10403      72656365 
 10403      69766573 
 10403      20284354 
 10404 0453 00       		.space	1
 10405              	.LC25:
 10406 0454 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 10406      756C7420 
 10406      73656C65 
 10406      63746F72 
 10406      20284354 
 10407 0476 0000     		.space	2
 10408              	.LC26:
 10409 0478 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 10409      756C7420 
 10409      72657175 
 10409      65737420 
 10409      28435429 
 10410 0499 000000   		.space	3
 10411              	.LC27:
 10412 049c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 10412      52657175 
 10412      65737420 
 10412      30782578 
 10412      20706172 
 10413 04cf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 10413      20307825 
 10413      78202F20 
 10413      73656E64 
 10413      20746F20 
 10414 04fc 00       		.ascii	"\000"
 10415 04fd 000000   		.space	3
 10416              	.LC28:
 10417 0500 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 10417      73706565 
 10417      64203D20 
 10417      25642065 
 10417      76656E66 
 10418 0530 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 10418      71756573 
 10418      74203D20 
 10418      30782578 
 10418      20775661 
 10419 0560 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 10419      203D2030 
 10419      78257820 
 10419      6973666C 
 10419      61672030 
 10420 057a 0000     		.space	2
 10421              	.LC29:
 10422 057c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 10422      64656661 
 10422      756C7420 
 10422      73657475 
 10422      70207265 
 10423              	.LC30:
 10424 05a8 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 10424      6F207374 
 10424      7265616D 
 10424      20474554 
 10424      20726571 
 10425 05cd 000000   		.space	3
 10426              	.LC31:
 10427 05d0 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 10427      43595F46 
 10427      585F5556 
 10427      435F5354 
 10427      5245414D 
 10428 05f6 0000     		.space	2
 10429              	.LC32:
 10430 05f8 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 10430      55564320 
 10430      7374696C 
 10430      6C205072 
 10430      6F622873 
 10431 0623 00       		.space	1
 10432              	.LC33:
 10433 0624 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 10433      7374696C 
 10433      6C20636F 
 10433      6D6D6974 
 10433      20636F6E 
 10434              	.LC34:
 10435 064c 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 10435      55564320 
 10435      7374696C 
 10435      6C207472 
 10435      69676765 
 10436 0675 000000   		.space	3
 10437              	.LC35:
 10438 0678 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 10438      7374696C 
 10438      6C207472 
 10438      69676765 
 10438      7220636F 
 10439 069f 00       		.space	1
 10440              	.LC36:
 10441 06a0 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 10441      65642074 
 10441      6F207365 
 10441      6E642069 
 10441      6E746572 
 10442 06d1 0A00     		.ascii	"\012\000"
 10443 06d3 00       		.space	1
 10444              	.LC37:
 10445 06d4 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 10445      73657420 
 10445      64656620 
 10445      64617461 
 10445      20307825 
 10446 06f3 00       		.space	1
 10447              	.LC38:
 10448 06f4 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 10448      73657420 
 10448      64656620 
 10448      64617461 
 10448      20307825 
 10449 0727 2E0D0A00 		.ascii	".\015\012\000"
 10450 072b 00       		.space	1
 10451              	.LC39:
 10452 072c 55415254 		.ascii	"UART initialization failed!\012\000"
 10452      20696E69 
 10452      7469616C 
 10452      697A6174 
 10452      696F6E20 
 10453 0749 000000   		.space	3
 10454              	.LC40:
 10455 074c 49324320 		.ascii	"I2C initialization failed!\012\000"
 10455      696E6974 
 10455      69616C69 
 10455      7A617469 
 10455      6F6E2066 
 10456              	.LC41:
 10457 0768 49324320 		.ascii	"I2C configuration failed!\012\000"
 10457      636F6E66 
 10457      69677572 
 10457      6174696F 
 10457      6E206661 
 10458 0783 00       		.space	1
 10459              	.LC42:
 10460 0784 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 10460      43726561 
 10460      74652045 
 10460      76656E74 
 10460      20666169 
 10461 07ae 0000     		.space	2
 10462              	.LC43:
 10463 07b0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 10463      20496E69 
 10463      74206661 
 10463      696C6564 
 10463      2C204572 
 10464 07d3 00       		.space	1
 10465              	.LC44:
 10466 07d4 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 10466      204F7665 
 10466      72726964 
 10466      65206661 
 10466      696C6564 
 10467 07fb 00       		.space	1
 10468              	.LC45:
 10469 07fc 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 10469      28323029 
 10469      204F7665 
 10469      72726964 
 10469      65206661 
 10470 0827 00       		.space	1
 10471              	.LC46:
 10472 0828 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 10472      28323429 
 10472      204F7665 
 10472      72726964 
 10472      65206661 
 10473 0853 00       		.space	1
 10474              	.LC47:
 10475 0854 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 10475      20536574 
 10475      20287265 
 10475      73657420 
 10475      32322920 
 10476 0886 00       		.ascii	"\000"
 10477 0887 00       		.space	1
 10478              	.LC48:
 10479 0888 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 10479      20536574 
 10479      2028706F 
 10479      77657220 
 10479      32302920 
 10480 08ba 00       		.ascii	"\000"
 10481 08bb 00       		.space	1
 10482              	.LC49:
 10483 08bc 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 10483      20536574 
 10483      2028736E 
 10483      61702073 
 10483      686F7420 
 10484 08ef 25640A00 		.ascii	"%d\012\000"
 10485 08f3 00       		.space	1
 10486              	.LC50:
 10487 08f4 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 10487      46756E63 
 10487      74696F6E 
 10487      20466169 
 10487      6C656420 
 10488 0923 00       		.space	1
 10489              	.LC51:
 10490 0924 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 10490      46756E63 
 10490      74696F6E 
 10490      20466169 
 10490      6C656420 
 10491 0953 00       		.space	1
 10492              	.LC52:
 10493 0954 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 10493      53657420 
 10493      456E6470 
 10493      6F696E74 
 10493      20636F6E 
 10494 0984 00       		.ascii	"\000"
 10495 0985 000000   		.space	3
 10496              	.LC53:
 10497 0988 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 10497      496E7465 
 10497      72727570 
 10497      74205374 
 10497      61747573 
 10498 09bb 20436F64 		.ascii	" Code = %d\012\000"
 10498      65203D20 
 10498      25640A00 
 10499 09c7 00       		.space	1
 10500              	.LC54:
 10501 09c8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 10501      65642074 
 10501      6F20616C 
 10501      6C6F6361 
 10501      7465206D 
 10502 09fb 65720D0A 		.ascii	"er\015\012\000"
 10502      00
 10503              	.LC55:
 10504 0a00 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 10504      4368616E 
 10504      6E656C20 
 10504      43726561 
 10504      74696F6E 
 10505 0a2e 0000     		.space	2
 10506              	.LC56:
 10507 0a30 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 10507      436F6E6E 
 10507      65637420 
 10507      6661696C 
 10507      65642C20 
 10508 0a55 000000   		.space	3
 10509              	.LC57:
 10510 0a58 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 10510      4368616E 
 10510      6E656C20 
 10510      52657365 
 10510      74204661 
 10511 0a83 00       		.space	1
 10512              	.LC58:
 10513 0a84 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 10513      4368616E 
 10513      6E656C20 
 10513      53657420 
 10513      5472616E 
 10514 0ab5 00       		.ascii	"\000"
 10515 0ab6 0000     		.space	2
 10516              	.LC59:
 10517 0ab8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 10517      4368616E 
 10517      6E656C20 
 10517      53657420 
 10517      5472616E 
 10518 0ae9 0A00     		.ascii	"\012\000"
 10519 0aeb 00       		.space	1
 10520              	.LC60:
 10521 0aec 0D0A2073 		.ascii	"\015\012 super gpif\000"
 10521      75706572 
 10521      20677069 
 10521      6600
 10522 0afa 0000     		.space	2
 10523              	.LC61:
 10524 0afc 0D0A2068 		.ascii	"\015\012 high gpif\000"
 10524      69676820 
 10524      67706966 
 10524      00
 10525 0b09 000000   		.space	3
 10526              	.LC62:
 10527 0b0c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 10527      696E6720 
 10527      47504946 
 10527      20436F6E 
 10527      66696775 
 10528 0b3f 0A00     		.ascii	"\012\000"
 10529 0b41 000000   		.space	3
 10530              	.LC63:
 10531 0b44 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 10531      74696E67 
 10531      20475049 
 10531      46207374 
 10531      61746520 
 10532 0b77 0D0A00   		.ascii	"\015\012\000"
 10533 0b7a 0000     		.space	2
 10534              	.LC64:
 10535 0b7c 33303A55 		.ascii	"30:UVC App Thread\000"
 10535      56432041 
 10535      70702054 
 10535      68726561 
 10535      6400
 10536 0b8e 0000     		.space	2
 10537              	.LC65:
 10538 0b90 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 10538      56432041 
 10538      70702045 
 10538      50302054 
 10538      68726561 
 10539 0ba6 0000     		.space	2
 10540              	.LC66:
 10541 0ba8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 10541      32432041 
 10541      70702043 
 10541      54524C20 
 10541      54687265 
 10542 0bbf 00       		.bss
 10543              		.align	2
 10544              		.set	.LANCHOR0,. + 0
 10547              	glFxUVCEvent:
 10548 0000 00000000 		.space	40
 10548      00000000 
 10548      00000000 
 10548      00000000 
 10548      00000000 
 10551              	gpif_initialized:
 10552 0028 00000000 		.space	4
 10555              	streamingStarted:
 10556 002c 00000000 		.space	4
 10559              	isUsbConnected:
 10560 0030 00000000 		.space	4
 10563              	fb:
 10564 0034 0000     		.space	2
 10567              	pb:
 10568 0036 0000     		.space	2
 10571              	pbc:
 10572 0038 0000     		.space	2
 10575              	stiflag:
 10576 003a 00       		.space	1
 10577 003b 00       		.space	1
 10580              	hitFV:
 10581 003c 00000000 		.space	4
 10584              	prodCount:
 10585 0040 0000     		.space	2
 10588              	consCount:
 10589 0042 0000     		.space	2
 10592              	clearFeatureRqtReceived:
 10593 0044 00000000 		.space	4
 10596              	usbSpeed:
 10597 0048 00       		.space	1
 10598 0049 000000   		.space	3
 10601              	I2CCMDArry:
 10602 004c 00000000 		.space	12
 10602      00000000 
 10602      00000000 
 10605              	is60Hz:
 10606 0058 00000000 		.space	4
 10609              	glEp0Buffer:
 10610 005c 00000000 		.space	32
 10610      00000000 
 10610      00000000 
 10610      00000000 
 10610      00000000 
 10613              	CamMode:
 10614 007c 00       		.space	1
 10617              	setRes:
 10618 007d 00       		.space	1
 10619 007e 0000     		.space	2
 10622              	glCommitCtrl:
 10623 0080 00000000 		.space	32
 10623      00000000 
 10623      00000000 
 10623      00000000 
 10623      00000000 
 10626              	setstilRes:
 10627 00a0 00       		.space	1
 10630              	IMcount.7840:
 10631 00a1 00       		.space	1
 10632 00a2 0000     		.space	2
 10635              	uvcAppThread:
 10636 00a4 00000000 		.space	168
 10636      00000000 
 10636      00000000 
 10636      00000000 
 10636      00000000 
 10639              	uvcAppEP0Thread:
 10640 014c 00000000 		.space	168
 10640      00000000 
 10640      00000000 
 10640      00000000 
 10640      00000000 
 10643              	i2cAppThread:
 10644 01f4 00000000 		.space	168
 10644      00000000 
 10644      00000000 
 10644      00000000 
 10644      00000000 
 10647              	testSnap:
 10648 029c 00       		.space	1
 10649 029d 00       		.space	1
 10652              	fbbak:
 10653 029e 0000     		.space	2
 10656              	pbbak:
 10657 02a0 0000     		.space	2
 10660              	pbcbak:
 10661 02a2 0000     		.space	2
 10664              	pbcpbak:
 10665 02a4 0000     		.space	2
 10666 02a6 0000     		.text
 10667              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:191    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:292    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:306    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:303    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:325    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:329    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:331    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:510    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:519    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:522    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:744    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:754    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:756    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1081   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1097   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1100   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1137   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1150   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1197   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1204   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1222   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1231   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1234   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1462   .text:00000bb8 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1470   .text:00000bcc $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1473   .text:00000bcc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1536   .text:00000c4c getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1559   .text:00000c64 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1572   .text:00000c8c $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1678   .text:00000d80 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1686   .text:00000d94 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1689   .text:00000d94 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1901   .text:00000f3c $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:1939   .text:00000fc8 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:2004   .text:0000104c $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:2040   .text:000010d4 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3360   .text:00001cb0 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3373   .text:00001cd8 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3397   .text:00001d2c $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3692   .text:00001fe4 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3860   .text:00002140 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:3873   .text:00002168 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4368   .text:00002678 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4379   .text:00002698 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4634   .text:00002950 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4647   .text:00002978 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4650   .text:00002978 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4712   .text:000029f4 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:4720   .text:00002a04 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6021   .text:00003540 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6052   .text:000035a8 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6055   .text:000035a8 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6346   .text:00003860 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6353   .text:00003870 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6356   .text:00003870 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6397   .text:000038b4 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6402   .text:000038bc $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6405   .text:000038bc CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6430   .text:000038d8 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6434   .text:000038dc $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:6437   .text:000038dc UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:7846   .text:0000442c $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:7904   .text:00004508 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:7907   .text:00004508 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8064   .text:00004680 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8080   .text:000046b4 $a
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8083   .text:000046b4 main
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9795   .data:000006bc CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9804   .data:000006c8 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9879   .data:000007e8 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9898   .data:000007f8 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8261   .rodata:00000030 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9977   .data:00000928 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9988   .data:00000938 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10099  .data:00000ae8 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10250  .data:00000b7c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8274   .rodata:0000004c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9791   .data:000006bb snapButFlag
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10647  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10563  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10567  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10571  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10652  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10656  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10660  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10664  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10559  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10596  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10592  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10555  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9732   .data:00000688 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9672   .data:00000650 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9762   .data:000006a4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9702   .data:0000066c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9777   .data:000006b0 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9256   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8223   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8227   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8242   .rodata:00000020 ExTime
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8286   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8290   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:8613   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9271   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9276   .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9298   .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9320   .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9342   .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:9349   .data:000004d0 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10328  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10543  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10547  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10551  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10575  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10580  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10584  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10588  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10601  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10605  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10609  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10613  .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10617  .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10622  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10626  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10630  .bss:000000a1 IMcount.7840
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10635  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10639  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\cceMdFqk.s:10643  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
