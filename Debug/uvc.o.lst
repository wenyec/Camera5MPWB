   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 233:../uvc.c      **** 		{0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 0, 3,
 234:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 235:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 236:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 237:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 238:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 239:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 240:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 241:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 242:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 243:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 244:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 245:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 246:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 247:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 248:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 249:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 250:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 251:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 252:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 253:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 254:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 255:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 256:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 257:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 258:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 259:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 260:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 261:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 273:../uvc.c      **** };
 274:../uvc.c      **** 
 275:../uvc.c      **** #ifndef CAM720
 276:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 277:../uvc.c      **** #else
 278:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 279:../uvc.c      **** #endif
 280:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 281:../uvc.c      **** 
 282:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 283:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 284:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 285:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 286:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 287:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 288:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 289:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 290:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 291:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 295:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 296:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 297:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 298:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 299:../uvc.c      **** };
 300:../uvc.c      **** 
 301:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 302:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 303:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 304:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 305:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 306:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 307:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 308:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 309:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 310:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 311:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 312:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 313:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 314:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 315:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 316:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 317:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 318:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 319:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 320:../uvc.c      **** };
 321:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 322:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 323:../uvc.c      **** /*
 324:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 325:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 326:../uvc.c      ****  */
 327:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 328:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 329:../uvc.c      **** };
 330:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 331:../uvc.c      **** 		0
 332:../uvc.c      **** };
 333:../uvc.c      **** 
 334:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 335:../uvc.c      **** 
 336:../uvc.c      **** void I2CCmdHandler(){
 337:../uvc.c      **** 	uint8_t buf[2];
 338:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 340:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 341:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 342:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 343:../uvc.c      **** 	uint8_t i;
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 345:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 346:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 348:../uvc.c      **** 	{
 349:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 351:../uvc.c      **** 			{
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 353:../uvc.c      **** 			}
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 355:../uvc.c      **** 
 356:../uvc.c      **** 	}
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 358:../uvc.c      **** 	{
 359:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 360:../uvc.c      **** #if 0 //for debugging
 361:../uvc.c      **** 		/* test still image operation */
 362:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 363:../uvc.c      **** 			snapButFlag = 0; //press
 364:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 365:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 366:../uvc.c      **** 			snapButFlag = 0xf; //release
 367:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 368:../uvc.c      **** 		}
 369:../uvc.c      **** 
 370:../uvc.c      **** 		/* end of the test */
 371:../uvc.c      **** #endif
 372:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 373:../uvc.c      **** 			/*
 374:../uvc.c      **** 			if(CmdRegLen == 2){
 375:../uvc.c      **** 				SensorRead2B2(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|0x1, 0, I2CCMDArry[4], I2CCMDArry[9]);
 376:../uvc.c      **** 			}
 377:../uvc.c      **** 			else{
 378:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 379:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 380:../uvc.c      **** 				if(CmdDataLen == 2){
 381:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 382:../uvc.c      **** 				}
 383:../uvc.c      **** 			}*/
 384:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 385:../uvc.c      **** 		}else{//not support currently
 386:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 387:../uvc.c      **** 		}
 388:../uvc.c      **** 	}else if(CmdType == 1){
 389:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 390:../uvc.c      **** 			if(CmdRegLen == 2){
 391:../uvc.c      **** 				for(i = 0; i<4; i++)
 392:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 393:../uvc.c      **** 			}
 394:../uvc.c      **** 			else{
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 396:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 397:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 399:../uvc.c      **** 				}
 400:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 401:../uvc.c      **** 			}
 402:../uvc.c      **** 		}else{//not support currently
 403:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 404:../uvc.c      **** 		}
 405:../uvc.c      **** 
 406:../uvc.c      **** 	}
 407:../uvc.c      **** }
 408:../uvc.c      **** 
 409:../uvc.c      **** /************************************
 410:../uvc.c      ****  * set Iris mode
 411:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 412:../uvc.c      ****  */
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 414:../uvc.c      **** 	uint8_t dataIdx;
 415:../uvc.c      **** 	  dataIdx = 0;
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 420:../uvc.c      **** }
 421:../uvc.c      **** 
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 423:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 424:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 425:../uvc.c      ****     uint16_t readCount;
 426:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 427:../uvc.c      ****     uint8_t devAdd;
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 431:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 432:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 433:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 434:../uvc.c      ****     }else{
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 436:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 437:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 438:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 439:../uvc.c      ****     }
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 441:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 442:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 443:../uvc.c      **** #endif
 444:../uvc.c      ****     reqData = bRequest;
 445:../uvc.c      ****     /*
 446:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 447:../uvc.c      ****      */
 448:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 449:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 450:../uvc.c      ****     	goto EndofSet;
 451:../uvc.c      ****     }
 452:../uvc.c      ****     switch (bRequest)
 453:../uvc.c      **** 		 {
 454:../uvc.c      **** 
 455:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 457:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 459:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 460:../uvc.c      **** 			  break;
 461:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 462:../uvc.c      **** 
 463:../uvc.c      **** 			 switch(CtrlID)
 464:../uvc.c      **** 			 {
 465:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 466:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 467:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 468:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 471:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 472:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 473:../uvc.c      **** 			 	 		 break;
 474:../uvc.c      **** 			 	 }
 475:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 476:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 478:../uvc.c      **** 						if(sendData >= 3){
 479:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 480:../uvc.c      **** 							sendData = 0; //set back to default
 481:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 482:../uvc.c      **** 						}
 483:../uvc.c      **** 						sendData += 4;
 484:../uvc.c      **** 					 }
 485:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 486:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 488:../uvc.c      **** 					 break;
 489:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 492:../uvc.c      **** 			 		 }
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 494:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 495:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 496:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 497:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 498:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 499:../uvc.c      **** #endif
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 501:../uvc.c      **** 			 		 {
 502:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 503:../uvc.c      **** 			 		 }
 504:../uvc.c      **** 			 		 break;
 505:../uvc.c      **** 				 case ExtAexModCtlID9:
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 509:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 510:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 511:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 512:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 513:../uvc.c      **** 					 break;
 514:../uvc.c      **** 
 515:../uvc.c      **** 			 	 case BrgtCtlID1:
 516:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 517:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 518:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 519:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 520:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 521:../uvc.c      **** 					 }else{
 522:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 523:../uvc.c      **** 					 }
 524:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 525:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 526:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 527:../uvc.c      **** 					 */
 528:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 529:../uvc.c      **** 					  if(Data0&0x80){
 530:../uvc.c      **** 						  Data0 = ~Data0;
 531:../uvc.c      **** 					  }else{
 532:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 533:../uvc.c      **** 					  }
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 536:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 537:../uvc.c      **** 			 		 break;
 538:../uvc.c      **** 				 case HueCtlID5:
 539:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 542:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 543:../uvc.c      **** 					 break;
 544:../uvc.c      **** 				 case WBTLevCtlID11:
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 548:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 549:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 550:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 551:../uvc.c      **** 					 break;
 552:../uvc.c      **** 				 case SaturCtlID6:
 553:../uvc.c      **** 				 default:
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 556:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 557:../uvc.c      **** 					 break;
 558:../uvc.c      **** 			 }
 559:../uvc.c      **** 
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 561:../uvc.c      **** 
 562:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 563:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 564:../uvc.c      **** #endif
 565:../uvc.c      **** 			  break;
 566:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 567:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 570:../uvc.c      **** 		 	 }
 571:../uvc.c      **** 
 572:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 574:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 575:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 576:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 577:../uvc.c      **** 			 }else
 578:../uvc.c      **** 			 {
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 581:../uvc.c      **** 			 }
 582:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 583:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 584:../uvc.c      **** 			  break;
 585:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 589:../uvc.c      **** 		 	 }
 590:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 592:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 593:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 594:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 595:../uvc.c      **** 			 }else
 596:../uvc.c      **** 			 {
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 599:../uvc.c      **** 			 }
 600:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 601:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 602:../uvc.c      **** 			  break;
 603:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 604:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 606:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 607:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 608:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 609:../uvc.c      **** 		 	 }
 610:../uvc.c      **** 		 	 else{
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 614:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 615:../uvc.c      **** 		 	 }
 616:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 617:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 618:../uvc.c      **** 			  break;
 619:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 620:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 622:../uvc.c      **** 		 	 }
 623:../uvc.c      **** 		 	 else{
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 625:../uvc.c      **** 		 	 }
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 627:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 628:../uvc.c      **** 			  Len = 1;
 629:../uvc.c      **** 			  break;
 630:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 631:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 634:../uvc.c      **** 		 	 }
 635:../uvc.c      **** 
 636:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 640:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 641:../uvc.c      **** 			 }else{
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 644:../uvc.c      **** 			 }
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 646:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 647:../uvc.c      **** 			  break;
 648:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 649:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 650:../uvc.c      **** 				  glEp0Buffer, &readCount);
 651:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 652:../uvc.c      **** 			   {
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 655:../uvc.c      **** 				  getData = glEp0Buffer[0];
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 657:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 658:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 659:../uvc.c      **** #endif
 660:../uvc.c      **** 				  switch(CtrlID)
 661:../uvc.c      **** 					 {
 662:../uvc.c      **** 						 case ExtShutCtlID0:
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 665:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 666:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 668:../uvc.c      **** 									 }else{
 669:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 670:../uvc.c      **** 									 }
 671:../uvc.c      **** 								 }
 672:../uvc.c      **** 							 }else{
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 675:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 677:../uvc.c      **** 									 }else{
 678:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 679:../uvc.c      **** 									 }
 680:../uvc.c      **** 								 }
 681:../uvc.c      **** 								 if(Data1 < 8){
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 684:../uvc.c      **** 								 }else{
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 687:../uvc.c      **** 								 }
 688:../uvc.c      **** 							 }
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 690:../uvc.c      **** 							 dataIdx = 0;
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 693:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 694:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 695:../uvc.c      **** 							 break;
 696:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 700:../uvc.c      **** 							 dataIdx = 0;
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 702:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 703:../uvc.c      **** 							 if(getData != 0){
 704:../uvc.c      **** 								 dataIdx++;
 705:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 706:../uvc.c      **** 							 }
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 709:../uvc.c      **** 							 break;
 710:../uvc.c      **** 						 case ExtCamMCtlID12:
 711:../uvc.c      **** 							 dataIdx = 0;
 712:../uvc.c      **** 							 if(Data0 <= 3){
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 714:../uvc.c      **** 								 Data1 = Data0;
 715:../uvc.c      **** 							 }else{
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 717:../uvc.c      **** 								 Data1 = Data0-4;
 718:../uvc.c      **** 							 }
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 720:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 724:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 725:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 726:../uvc.c      **** 							 break;
 727:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 728:../uvc.c      **** 							 dataIdx = 0;
 729:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 730:../uvc.c      **** 								 Data0 = 1;
 731:../uvc.c      **** 							 }else{ //save current sensor parameters.
 732:../uvc.c      **** 								 Data0 = 0;
 733:../uvc.c      **** 							 }
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 738:../uvc.c      **** 							 break;
 739:../uvc.c      **** 						 case ExtI2CCtlID15:
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 742:../uvc.c      **** 					 		 }
 743:../uvc.c      **** 					 		I2CCmdHandler();
 744:../uvc.c      **** 							 break;
 745:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 746:../uvc.c      **** 							 dataIdx = 0;
 747:../uvc.c      **** #if 0 //seperate version
 748:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 749:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 750:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 751:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 752:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 753:../uvc.c      **** 							 }else{ //disable BLD window
 754:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 755:../uvc.c      **** 							 }
 756:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 757:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 758:../uvc.c      **** 							 dataIdx++;
 759:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 760:../uvc.c      **** 							 dataIdx++;
 761:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 762:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 763:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 764:../uvc.c      **** 							 dataIdx++;
 765:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 766:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 767:../uvc.c      **** #else //combination version
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 770:../uvc.c      **** 						     /* end test */
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 772:../uvc.c      **** 							 dataIdx++;
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 774:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 775:../uvc.c      **** 							 getData1 = Data1;
 776:../uvc.c      **** #endif
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 779:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 780:../uvc.c      **** 							 break;
 781:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 782:../uvc.c      **** 							 dataIdx = 0;
 783:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 785:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 786:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 787:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 788:../uvc.c      **** 							 break;
 789:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 790:../uvc.c      **** 							 dataIdx = 0;
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 793:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 796:../uvc.c      **** 							 break;
 797:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 798:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
 799:../uvc.c      **** 							 dataIdx = 0;
 800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 801:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 802:../uvc.c      **** 							  if(Data0&0x80){
 803:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 804:../uvc.c      **** 							  }else{
 805:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 806:../uvc.c      **** 							  }
 807:../uvc.c      **** 							 Data1 |= ~0x03;
 808:../uvc.c      **** 							 Data1 &= 0xC7;
 809:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 810:../uvc.c      **** 						  	 dataIdx++;
 811:../uvc.c      **** 
 812:../uvc.c      **** 							 Data0 = (Data0 << 2);
 813:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 814:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 815:../uvc.c      **** 
 816:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 817:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 818:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 819:../uvc.c      **** #endif
 820:../uvc.c      **** 							 dataIdx = 0;
 821:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 822:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 823:../uvc.c      **** 							  if(Data0&0x80){
 824:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 825:../uvc.c      **** 							  }else{
 826:../uvc.c      **** 								  Data0 = ~Data0;
 827:../uvc.c      **** 							  }
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 830:../uvc.c      **** 
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 833:../uvc.c      **** 
 834:../uvc.c      **** 
 835:../uvc.c      **** 							 break;
 836:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 837:../uvc.c      **** 							 dataIdx = 0;
 838:../uvc.c      **** 
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 841:../uvc.c      **** 							 dataIdx++;
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 843:../uvc.c      **** 							 dataIdx++;
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 845:../uvc.c      **** 							 dataIdx++;
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 847:../uvc.c      **** 							 dataIdx++;
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 849:../uvc.c      **** 							 dataIdx++;
 850:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 851:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 852:../uvc.c      **** 
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 855:../uvc.c      **** 							 break;
 856:../uvc.c      **** 						 case SaturCtlID6:
 857:../uvc.c      **** 							 dataIdx = 0;
 858:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 861:../uvc.c      **** 							 dataIdx++;
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 865:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 866:../uvc.c      **** 							 break;
 867:../uvc.c      **** 
 868:../uvc.c      **** 						 case WBTLevCtlID11:
 869:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 870:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 871:../uvc.c      **** 							 dataIdx = 0;
 872:../uvc.c      **** 
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 875:../uvc.c      **** 							 dataIdx++;
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 878:../uvc.c      **** 
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 882:../uvc.c      **** 							 break;
 883:../uvc.c      **** 						 case MFreqCtlID4:
 884:../uvc.c      **** 							 dataIdx = 0;
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 887:../uvc.c      **** 							 is60Hz = Data0;
 888:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 889:../uvc.c      **** 							 {
 890:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
 891:../uvc.c      **** 								 is60Hz = CyFalse;
 892:../uvc.c      **** 							 }
 893:../uvc.c      **** 							 else if(Data0 >2)
 894:../uvc.c      **** 							 {
 895:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 897:../uvc.c      **** 							 }
 898:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 900:../uvc.c      **** 							 {
 901:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 902:../uvc.c      **** 			                       switch (setRes)
 903:../uvc.c      **** 			                         {
 904:../uvc.c      **** 			                         	case 1: //1944
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 907:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 908:../uvc.c      **** 			                         		break;
 909:../uvc.c      **** 			                         	case 2: //1080
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 912:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60
 913:../uvc.c      **** 			                         		break;
 914:../uvc.c      **** 			                         	case 3: //720
 915:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 916:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 917:../uvc.c      **** 			                                //CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is
 918:../uvc.c      **** 			                         		break;
 919:../uvc.c      **** 			                         	default:
 920:../uvc.c      **** 			                         		break;
 921:../uvc.c      **** 			                         }
 922:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 923:../uvc.c      **** 							 }
 924:../uvc.c      **** 
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 926:../uvc.c      **** 							 break;
 927:../uvc.c      **** 					 	 case BLCCtlID0:
 928:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 931:../uvc.c      **** 							 {
 932:../uvc.c      **** 								 if(Data0 < 3){
 933:../uvc.c      **** 					 				 Data0 += 4;
 934:../uvc.c      **** 					 			 }else{
 935:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 936:../uvc.c      **** 									Data0 = 4; //set to default.
 937:../uvc.c      **** 					 			 }
 938:../uvc.c      **** 					 		 }
 939:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 940:../uvc.c      **** 							 dataIdx = 0;
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 944:../uvc.c      **** 
 945:../uvc.c      **** 					 		 break;
 946:../uvc.c      **** 						 default:
 947:../uvc.c      **** 							 dataIdx = 0;
 948:../uvc.c      **** 
 949:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 950:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 951:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 952:../uvc.c      **** 
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 955:../uvc.c      **** 							 break;
 956:../uvc.c      **** 					 }
 957:../uvc.c      **** 			   }else{
 958:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 959:../uvc.c      **** 			   }
 960:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 961:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 962:../uvc.c      **** #endif
 963:../uvc.c      **** 
 964:../uvc.c      **** 			  break;
 965:../uvc.c      **** 		  default:
 966:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 967:../uvc.c      **** 			  break;
 968:../uvc.c      **** 		 }
 969:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 970:../uvc.c      **** }
 971:../uvc.c      **** /************** CT control requests handler *************************/
 972:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 973:../uvc.c      **** 
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 975:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 976:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 977:../uvc.c      ****     uint16_t readCount;
 978:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 979:../uvc.c      ****     uint16_t diff, value, diffRd;
 980:../uvc.c      ****     uint8_t i, shutter, index;
 981:../uvc.c      ****     diff = 0xffff;
 982:../uvc.c      ****     shutter = 1;
 983:../uvc.c      ****     index = 1;
 984:../uvc.c      **** 
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 986:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 987:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 988:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 989:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 990:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 991:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 992:../uvc.c      **** #endif
 993:../uvc.c      ****     reqData = bRequest;
 994:../uvc.c      **** 
 995:../uvc.c      ****     switch (bRequest)
 996:../uvc.c      **** 		 {
 997:../uvc.c      **** 
 998:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1002:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1003:../uvc.c      **** 			  break;
1004:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1005:../uvc.c      **** 
1006:../uvc.c      **** 			 switch(CtrlID)
1007:../uvc.c      **** 			 {
1008:../uvc.c      **** 				 default:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1012:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1013:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1014:../uvc.c      **** 					 break;
1015:../uvc.c      **** 			 }
1016:../uvc.c      **** 
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1018:../uvc.c      **** 
1019:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1020:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1021:../uvc.c      **** #endif
1022:../uvc.c      **** 			  break;
1023:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1027:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1028:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1029:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1030:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1031:../uvc.c      **** 			  break;
1032:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1036:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1037:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1038:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1039:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1040:../uvc.c      **** 			  break;
1041:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1045:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1046:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1047:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1048:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1049:../uvc.c      **** 			  break;
1050:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1051:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1053:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1054:../uvc.c      **** 			  Len = 1;
1055:../uvc.c      **** 			  break;
1056:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1060:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1063:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1064:../uvc.c      **** 			  break;
1065:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1066:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1067:../uvc.c      **** 			  glEp0Buffer, &readCount);
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1070:../uvc.c      **** 			  value = Data1;
1071:../uvc.c      **** 
1072:../uvc.c      **** 			  switch(CtrlID)
1073:../uvc.c      **** 			  {
1074:../uvc.c      **** 		  	      case AutoExMCtlID1:
1075:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1076:../uvc.c      **** 
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1079:../uvc.c      **** 				    getData = glEp0Buffer[0];
1080:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1081:../uvc.c      **** 		  		    switch (getData){
1082:../uvc.c      **** 						case 1:
1083:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1084:../uvc.c      **** 							break;
1085:../uvc.c      **** 						case 2:
1086:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1087:../uvc.c      **** 							dataIdx = 0;
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1089:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1090:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1091:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1092:../uvc.c      **** 
1093:../uvc.c      **** 							break;
1094:../uvc.c      **** 						case 4:
1095:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1096:../uvc.c      **** 							break;
1097:../uvc.c      **** 						case 8:
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1099:../uvc.c      **** 			  		    	dataIdx = 0;
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1101:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1102:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1103:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1104:../uvc.c      **** 							break;
1105:../uvc.c      **** 		  		    }
1106:../uvc.c      **** #if 0
1107:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1108:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1109:../uvc.c      **** 						  dataIdx = 0;
1110:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1111:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1112:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1113:../uvc.c      **** 		  		    }
1114:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1115:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1116:../uvc.c      **** 		  		    }
1117:../uvc.c      **** #endif
1118:../uvc.c      **** 				    break;
1119:../uvc.c      **** 
1120:../uvc.c      **** 			  	  case ExTmACtlID3:
1121:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1122:../uvc.c      **** 
1123:../uvc.c      **** 					  value = (value << 8)|Data0;
1124:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1125:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1126:../uvc.c      **** 					  {
1127:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1128:../uvc.c      **** 						  {
1129:../uvc.c      **** 							if(value > ShutValueArry[i]){
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1131:../uvc.c      **** 							}else{
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1133:../uvc.c      **** 							}
1134:../uvc.c      **** 							  if(diff > diffRd){
1135:../uvc.c      **** 								  diff = diffRd;
1136:../uvc.c      **** 								  index = i;
1137:../uvc.c      **** 							  }
1138:../uvc.c      **** 						  }
1139:../uvc.c      **** 						  shutter = shutter+index;
1140:../uvc.c      **** 
1141:../uvc.c      **** 						  dataIdx = 0;
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1143:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1144:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1145:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1146:../uvc.c      **** 
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1151:../uvc.c      **** 					  }else{
1152:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1153:../uvc.c      **** 					  }
1154:../uvc.c      **** 					  getData = glEp0Buffer[0];
1155:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1156:../uvc.c      **** 					  break;
1157:../uvc.c      **** 			  	  case IriACtlID7:
1158:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1159:../uvc.c      **** 					  {
1160:../uvc.c      **** 							 dataIdx = 0;
1161:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1162:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1163:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1164:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1165:../uvc.c      **** 
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1169:../uvc.c      **** 					  }else{
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1171:../uvc.c      **** 					  }
1172:../uvc.c      **** 					  getData = glEp0Buffer[0];
1173:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1174:../uvc.c      **** 
1175:../uvc.c      **** 					  break;
1176:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1177:../uvc.c      **** 					  getData = glEp0Buffer[0];
1178:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1179:../uvc.c      **** #if 1
1180:../uvc.c      **** 					  dataIdx = 0;
1181:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1182:../uvc.c      **** 					  if(getData == 1)
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1184:../uvc.c      **** 					  else if(getData == 0xff)
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1186:../uvc.c      **** 					  else
1187:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1188:../uvc.c      **** 					  //dataIdx++;
1189:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1190:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1191:../uvc.c      **** #endif
1192:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1193:../uvc.c      **** 					  break;
1194:../uvc.c      **** 
1195:../uvc.c      **** 			  	  default:
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1198:../uvc.c      **** 			  		 break;
1199:../uvc.c      **** 			  }
1200:../uvc.c      **** 			  break;
1201:../uvc.c      **** 		  default:
1202:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1203:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1204:../uvc.c      **** 			  break;
1205:../uvc.c      **** 		 }
1206:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1207:../uvc.c      **** 
1208:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1209:../uvc.c      **** }
1210:../uvc.c      **** 
1211:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1212:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1213:../uvc.c      **** {
1214:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1215:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1216:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1217:../uvc.c      **** 
1218:../uvc.c      ****     CtrlID = BrgtCtlID1;
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1221:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1222:../uvc.c      ****     Data1 = Data0;
1223:../uvc.c      **** 
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1225:../uvc.c      ****     if(Data1&0x80){
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1227:../uvc.c      ****     }else{
1228:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1229:../uvc.c      ****     }
1230:../uvc.c      ****     Data0 = (Data0 << 2);
1231:../uvc.c      **** 
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1233:../uvc.c      **** 
1234:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1237:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1239:../uvc.c      **** 
1240:../uvc.c      ****     CtrlID = ConsCtlID2;
1241:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1242:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1243:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1244:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1245:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1247:../uvc.c      **** 
1248:../uvc.c      ****     CtrlID = HueCtlID5;
1249:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1250:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1251:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1260:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1261:../uvc.c      **** 
1262:../uvc.c      ****     CtrlID = SaturCtlID6;
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1266:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1267:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1269:../uvc.c      **** 
1270:../uvc.c      ****     CtrlID = ShapCtlID7;
1271:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1272:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1273:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1274:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1275:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1277:../uvc.c      **** 
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1279:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1280:../uvc.c      **** 	return;
1281:../uvc.c      **** }
1282:../uvc.c      **** 
1283:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1284:../uvc.c      **** void
1285:../uvc.c      **** CyFxUVCAddHeader (
1286:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1287:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1288:../uvc.c      ****         )
1289:../uvc.c      **** {
1290:../uvc.c      ****     /* Copy header to buffer */
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1294:../uvc.c      **** 
1295:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1296:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1297:../uvc.c      ****     {
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1299:../uvc.c      ****     }
1300:../uvc.c      **** }
1301:../uvc.c      **** 
1302:../uvc.c      **** 
1303:../uvc.c      **** /* Application Error Handler */
1304:../uvc.c      **** void
1305:../uvc.c      **** CyFxAppErrorHandler (
1306:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1307:../uvc.c      ****         )
1308:../uvc.c      **** {
1309:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1310:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1311:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1312:../uvc.c      **** 
1313:../uvc.c      ****        This function can be modified to take additional error handling actions such
1314:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1315:../uvc.c      ****      */
1316:../uvc.c      ****     for (;;)
1317:../uvc.c      ****     {
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
1320:../uvc.c      ****     }
1321:../uvc.c      **** }
1322:../uvc.c      **** 
1323:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1324:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1325:../uvc.c      ****  */
1326:../uvc.c      **** static void
1327:../uvc.c      **** CyFxUVCApplnAbortHandler (
1328:../uvc.c      ****         void)
1329:../uvc.c      **** {
1330:../uvc.c      **** 	uint32_t flag;
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1332:../uvc.c      **** 	{
1333:../uvc.c      ****         /* Clear the Video Stream Request Event */
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1335:../uvc.c      **** 
1336:../uvc.c      ****         /* Set Video Stream Abort Event */
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1338:../uvc.c      **** 	}
1339:../uvc.c      **** }
1340:../uvc.c      **** 
1341:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1342:../uvc.c      **** static void
1343:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1344:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1345:../uvc.c      ****         uint16_t             evdata  /* Event data */
1346:../uvc.c      ****         )
1347:../uvc.c      **** {
1348:../uvc.c      ****     switch (evtype)
1349:../uvc.c      ****     {
1350:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1351:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1352:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1353:../uvc.c      ****             gpif_initialized = 0;
1354:../uvc.c      ****             streamingStarted = CyFalse;
1355:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1356:../uvc.c      ****             break;
1357:../uvc.c      **** 
1358:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1359:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1360:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1361:../uvc.c      ****             gpif_initialized = 0;
1362:../uvc.c      ****             streamingStarted = CyFalse;
1363:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1364:../uvc.c      ****             break;
1365:../uvc.c      **** 
1366:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1367:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1368:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1369:../uvc.c      ****             gpif_initialized = 0;
1370:../uvc.c      ****             isUsbConnected = CyFalse;
1371:../uvc.c      ****             streamingStarted = CyFalse;
1372:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1373:../uvc.c      ****             break;
1374:../uvc.c      **** 
1375:../uvc.c      **** #ifdef BACKFLOW_DETECT
1376:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1377:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1378:../uvc.c      ****             break;
1379:../uvc.c      **** #endif
1380:../uvc.c      **** 
1381:../uvc.c      ****         default:
1382:../uvc.c      ****             break;
1383:../uvc.c      ****     }
1384:../uvc.c      **** }
1385:../uvc.c      **** 
1386:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1387:../uvc.c      **** static CyBool_t
1388:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1389:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1390:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1391:../uvc.c      ****         )
1392:../uvc.c      **** {
1393:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1394:../uvc.c      ****     uint32_t status;
1395:../uvc.c      **** 
1396:../uvc.c      ****     /* Obtain Request Type and Request */
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1402:../uvc.c      **** 
1403:../uvc.c      ****     /* Check for UVC Class Requests */
1404:../uvc.c      ****     switch (bmReqType)
1405:../uvc.c      ****     {
1406:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1407:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1408:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1409:../uvc.c      ****             switch (wIndex & 0xFF)
1410:../uvc.c      ****             {
1411:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1412:../uvc.c      ****                     {
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
1414:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1415:../uvc.c      ****                                 CYU3P_EVENT_OR);
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1417:../uvc.c      ****                         {
1418:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1419:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1420:../uvc.c      ****                         }
1421:../uvc.c      ****                     }
1422:../uvc.c      ****                     break;
1423:../uvc.c      **** 
1424:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1425:../uvc.c      ****                     {
1426:../uvc.c      ****                         uvcHandleReq = CyTrue;
1427:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1428:../uvc.c      ****                                 CYU3P_EVENT_OR);
1429:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1430:../uvc.c      ****                         {
1431:../uvc.c      ****                             /* Error handling */
1432:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1433:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1434:../uvc.c      ****                         }
1435:../uvc.c      ****                     }
1436:../uvc.c      ****                     break;
1437:../uvc.c      **** 
1438:../uvc.c      ****                 default:
1439:../uvc.c      ****                     break;
1440:../uvc.c      ****             }
1441:../uvc.c      ****             break;
1442:../uvc.c      **** 
1443:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1444:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1445:../uvc.c      ****             {
1446:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1447:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1449:../uvc.c      ****                 {
1450:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1451:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1452:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1453:../uvc.c      ****                     gpif_initialized = 0;
1454:../uvc.c      ****                     streamingStarted = CyFalse;
1455:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1457:../uvc.c      ****                     CyU3PBusyWait (100);
1458:../uvc.c      **** 
1459:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1460:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1461:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1462:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1463:../uvc.c      ****                     CyU3PBusyWait (100);
1464:../uvc.c      **** 
1465:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1466:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
1468:../uvc.c      ****                     /* Complete Control request handshake */
1469:../uvc.c      ****                     CyU3PUsbAckSetup ();
1470:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1471:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1472:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1473:../uvc.c      **** 
1474:../uvc.c      ****                 }
1475:../uvc.c      ****             }
1476:../uvc.c      ****             break;
1477:../uvc.c      **** 
1478:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1479:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1480:../uvc.c      ****             {
1481:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1482:../uvc.c      ****                 {
1483:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1484:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1485:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1486:../uvc.c      ****                 	 * has started. */
1487:../uvc.c      ****                     if (streamingStarted == CyTrue)
1488:../uvc.c      ****                     {
1489:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1490:../uvc.c      **** 
1491:../uvc.c      ****                         /* Disable the GPIF state machine. */
1492:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1493:../uvc.c      ****                         gpif_initialized = 0;
1494:../uvc.c      ****                         streamingStarted = CyFalse;
1495:../uvc.c      **** 
1496:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1498:../uvc.c      ****                         CyU3PBusyWait (100);
1499:../uvc.c      **** 
1500:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1501:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1502:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1503:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1504:../uvc.c      ****                         CyU3PBusyWait (100);
1505:../uvc.c      **** 
1506:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1507:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1508:../uvc.c      **** 
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
1510:../uvc.c      ****                         /* Complete Control request handshake */
1511:../uvc.c      ****                         CyU3PUsbAckSetup ();
1512:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1513:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1514:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1515:../uvc.c      ****                     }
1516:../uvc.c      ****                     else
1517:../uvc.c      ****                     {
1518:../uvc.c      ****                         uvcHandleReq = CyTrue;
1519:../uvc.c      ****                         CyU3PUsbAckSetup ();
1520:../uvc.c      ****                     }
1521:../uvc.c      ****                 }
1522:../uvc.c      ****             }
1523:../uvc.c      ****             break;
1524:../uvc.c      **** 
1525:../uvc.c      ****         default:
1526:../uvc.c      ****             break;
1527:../uvc.c      ****     }
1528:../uvc.c      **** 
1529:../uvc.c      ****     /* Return status of request handling to the USB driver */
1530:../uvc.c      ****     return uvcHandleReq;
1531:../uvc.c      **** }
1532:../uvc.c      **** 
1533:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1534:../uvc.c      **** 
1535:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1536:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1537:../uvc.c      ****  */
1538:../uvc.c      **** void
1539:../uvc.c      **** CyFxUvcApplnDmaCallback (
1540:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1541:../uvc.c      ****         CyU3PDmaCbType_t      type,
1542:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1543:../uvc.c      ****         )
1544:../uvc.c      **** {
1545:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1546:../uvc.c      **** #if 1
1547:../uvc.c      ****     CyU3PReturnStatus_t status;
1548:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
1549:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
1550:../uvc.c      **** 
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1552:../uvc.c      ****     {
1553:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1554:../uvc.c      ****             {
1555:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
1556:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
1557:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1558:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
1559:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
1560:../uvc.c      ****                 	stiflag = 0x03;
1561:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
1562:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1563:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1564:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1565:../uvc.c      ****                 }
1566:../uvc.c      **** #endif
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
1568:../uvc.c      ****                 fb++;
1569:../uvc.c      ****             }
1570:../uvc.c      ****             else
1571:../uvc.c      ****             {
1572:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1574:../uvc.c      ****                 pb++;
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
1576:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
1577:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
1578:../uvc.c      ****                 //lineCount = 0; //res test
1579:../uvc.c      **** #if 1   //remove the still flag clearing here
1580:../uvc.c      ****                 if(stiflag == 0x0F){
1581:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
1584:../uvc.c      ****                 	stiflag = 0xAA;
1585:../uvc.c      ****                 }
1586:../uvc.c      **** #endif
1587:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
1588:../uvc.c      ****             }
1589:../uvc.c      **** 
1590:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1591:../uvc.c      ****             prodCount++;
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1593:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1594:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1595:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
1596:../uvc.c      ****             {
1597:../uvc.c      ****                 prodCount--;
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
1599:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
1600:../uvc.c      ****             }
1601:../uvc.c      ****     }
1602:../uvc.c      **** #endif
1603:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1604:../uvc.c      ****     {
1605:../uvc.c      ****         consCount++;
1606:../uvc.c      ****         streamingStarted = CyTrue;
1607:../uvc.c      ****     }
1608:../uvc.c      **** }
1609:../uvc.c      **** 
1610:../uvc.c      **** /*
1611:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1612:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1613:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1614:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1615:../uvc.c      ****  * to commit the buffer.
1616:../uvc.c      ****  */
1617:../uvc.c      **** static uint8_t
1618:../uvc.c      **** CyFxUvcAppCommitEOF (
1619:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1620:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1621:../uvc.c      ****         )
1622:../uvc.c      **** {
1623:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1624:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1625:../uvc.c      **** 
1626:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1627:../uvc.c      **** 
1628:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1629:../uvc.c      ****     {
1630:../uvc.c      ****         switch (stateId)
1631:../uvc.c      ****         {
1632:../uvc.c      **** 
1633:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
1634:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1635:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1636:../uvc.c      ****                 break;
1637:../uvc.c      **** 
1638:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1639:../uvc.c      ****                 socket = 0;
1640:../uvc.c      ****                 break;
1641:../uvc.c      **** 
1642:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1643:../uvc.c      ****                 socket = 1;
1644:../uvc.c      ****                 break;
1645:../uvc.c      **** 
1646:../uvc.c      ****             default:
1647:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1648:../uvc.c      ****                 /* Unexpected current state. Return error. */
1649:../uvc.c      ****             	//lineCount++;
1650:../uvc.c      ****             	return 1;
1651:../uvc.c      ****         }
1652:../uvc.c      ****     }
1653:../uvc.c      **** 
1654:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1655:../uvc.c      ****     {
1656:../uvc.c      ****         switch (stateId)
1657:../uvc.c      ****         {
1658:../uvc.c      **** #ifndef CAM720
1659:../uvc.c      **** #ifdef GPIFIIM
1660:../uvc.c      ****             case 13:
1661:../uvc.c      ****             case 24:
1662:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1663:../uvc.c      ****                 break;
1664:../uvc.c      **** 
1665:../uvc.c      ****             case 8:
1666:../uvc.c      ****                 socket = 0;
1667:../uvc.c      ****                 break;
1668:../uvc.c      **** 
1669:../uvc.c      ****             case 20:
1670:../uvc.c      ****                 socket = 1;
1671:../uvc.c      ****                 break;
1672:../uvc.c      **** #else
1673:../uvc.c      ****             case 11:
1674:../uvc.c      ****             case 18:
1675:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1676:../uvc.c      ****                 break;
1677:../uvc.c      **** 
1678:../uvc.c      ****             case 8:
1679:../uvc.c      ****                 socket = 0;
1680:../uvc.c      ****                 break;
1681:../uvc.c      **** 
1682:../uvc.c      ****             case 15:
1683:../uvc.c      ****                 socket = 1;
1684:../uvc.c      ****                 break;
1685:../uvc.c      **** #endif
1686:../uvc.c      **** #else
1687:../uvc.c      ****             case 11:
1688:../uvc.c      ****             case 18:
1689:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1690:../uvc.c      ****                 break;
1691:../uvc.c      **** 
1692:../uvc.c      ****             case 8:
1693:../uvc.c      ****                 socket = 0;
1694:../uvc.c      ****                 break;
1695:../uvc.c      **** 
1696:../uvc.c      ****             case 15:
1697:../uvc.c      ****                 socket = 1;
1698:../uvc.c      ****                 break;
1699:../uvc.c      **** 
1700:../uvc.c      **** #endif
1701:../uvc.c      ****              default:
1702:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1703:../uvc.c      ****                 /* Unexpected current state. Return error. */
1704:../uvc.c      ****                return 1;
1705:../uvc.c      ****         }
1706:../uvc.c      ****     }
1707:../uvc.c      **** 
1708:../uvc.c      ****     if (socket != 0xFF)
1709:../uvc.c      ****     {
1710:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1711:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1712:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1713:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1714:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1715:../uvc.c      ****         {
1716:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1717:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1718:../uvc.c      ****         }
1719:../uvc.c      ****     }
1720:../uvc.c      **** 
1721:../uvc.c      ****     return 0;
1722:../uvc.c      **** }
1723:../uvc.c      **** 
1724:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1725:../uvc.c      **** void
1726:../uvc.c      **** CyFxGpifCB (
1727:../uvc.c      ****         CyU3PGpifEventType event,
1728:../uvc.c      ****         uint8_t currentState
1729:../uvc.c      ****         )
1730:../uvc.c      **** {
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1732:../uvc.c      ****     {
1733:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
1734:../uvc.c      ****     	           in the UVC implementation. */
1735:../uvc.c      ****     	//hitFV = CyTrue;
1736:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
1738:../uvc.c      ****     }
1739:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
1740:../uvc.c      **** }
1741:../uvc.c      **** 
1742:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1743:../uvc.c      **** static void
1744:../uvc.c      **** CyFxUVCApplnDebugInit (
1745:../uvc.c      ****         void)
1746:../uvc.c      **** {
1747:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1748:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1749:../uvc.c      **** 
1750:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1751:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1753:../uvc.c      ****     {
1754:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1755:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1756:../uvc.c      ****     }
1757:../uvc.c      **** 
1758:../uvc.c      ****     /* Set UART Configuration */
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1762:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1763:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1764:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1765:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1766:../uvc.c      **** 
1767:../uvc.c      ****     /* Set the UART configuration */
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1769:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1770:../uvc.c      ****     {
1771:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1772:../uvc.c      ****     }
1773:../uvc.c      **** 
1774:../uvc.c      ****     /* Set the UART transfer */
1775:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1776:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1777:../uvc.c      ****     {
1778:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1779:../uvc.c      ****     }
1780:../uvc.c      **** 
1781:../uvc.c      ****     /* Initialize the Debug logger module. */
1782:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1783:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1784:../uvc.c      ****     {
1785:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1786:../uvc.c      ****     }
1787:../uvc.c      **** 
1788:../uvc.c      ****     /* Disable log message headers. */
1789:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1790:../uvc.c      **** }
1791:../uvc.c      **** 
1792:../uvc.c      **** /* I2C initialization. */
1793:../uvc.c      **** static void
1794:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1795:../uvc.c      **** {
1796:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1797:../uvc.c      ****     CyU3PReturnStatus_t status;
1798:../uvc.c      **** 
1799:../uvc.c      ****     status = CyU3PI2cInit ();
1800:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1801:../uvc.c      ****     {
1802:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1803:../uvc.c      ****         CyFxAppErrorHandler (status);
1804:../uvc.c      ****     }
1805:../uvc.c      **** 
1806:../uvc.c      ****     /*  Set I2C Configuration */
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1810:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1811:../uvc.c      **** 
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1813:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1814:../uvc.c      ****     {
1815:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1816:../uvc.c      ****         CyFxAppErrorHandler (status);
1817:../uvc.c      ****     }
1818:../uvc.c      **** }
1819:../uvc.c      **** 
1820:../uvc.c      **** #ifdef BACKFLOW_DETECT
1821:../uvc.c      **** static void CyFxUvcAppPibCallback (
1822:../uvc.c      ****         CyU3PPibIntrType cbType,
1823:../uvc.c      ****         uint16_t cbArg)
1824:../uvc.c      **** {
1825:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1826:../uvc.c      ****     {
1827:../uvc.c      ****         if (!back_flow_detected)
1828:../uvc.c      ****         {
1829:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1830:../uvc.c      ****             back_flow_detected = 1;
1831:../uvc.c      ****         }
1832:../uvc.c      ****     }
1833:../uvc.c      **** }
1834:../uvc.c      **** #endif
1835:../uvc.c      **** 
1836:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1837:../uvc.c      **** static void
1838:../uvc.c      **** CyFxUvcAppDebugCallback (
1839:../uvc.c      ****         CyU3PDmaChannel   *handle,
1840:../uvc.c      ****         CyU3PDmaCbType_t   type,
1841:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1842:../uvc.c      **** {
1843:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1844:../uvc.c      ****     {
1845:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1846:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1847:../uvc.c      ****     }
1848:../uvc.c      **** }
1849:../uvc.c      **** #endif
1850:../uvc.c      **** 
1851:../uvc.c      **** #if 0
1852:../uvc.c      **** static void CyFxAppIntEpCb(
1853:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1854:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1855:../uvc.c      **** 		uint8_t  ebNum)
1856:../uvc.c      **** 		{
1857:../uvc.c      **** 			//CyBool_t value;
1858:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1859:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1860:../uvc.c      **** 
1861:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1862:../uvc.c      **** 		}
1863:../uvc.c      **** #endif
1864:../uvc.c      **** 
1865:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1866:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1867:../uvc.c      ****    configures the DMA module for the UVC Application */
1868:../uvc.c      **** static void
1869:../uvc.c      **** CyFxUVCApplnInit (void)
1870:../uvc.c      **** {
1871:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1872:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1873:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1874:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1875:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1876:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1877:../uvc.c      **** 
1878:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1879:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1880:../uvc.c      **** 
1881:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1882:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1883:../uvc.c      **** #endif
1884:../uvc.c      **** 
1885:../uvc.c      ****     /* Create UVC event group */
1886:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1887:../uvc.c      ****     if (apiRetStatus != 0)
1888:../uvc.c      ****     {
1889:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1890:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1891:../uvc.c      ****     }
1892:../uvc.c      **** 
1893:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1894:../uvc.c      ****     CyFxUvcAppPTZInit ();
1895:../uvc.c      **** #endif
1896:../uvc.c      **** 
1897:../uvc.c      ****     isUsbConnected = CyFalse;
1898:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* Init the GPIO module */
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1902:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1903:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1905:../uvc.c      ****     gpioClock.halfDiv    = 0;
1906:../uvc.c      **** 
1907:../uvc.c      ****     /* Initialize Gpio interface */
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1909:../uvc.c      ****     if (apiRetStatus != 0)
1910:../uvc.c      ****     {
1911:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1912:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1913:../uvc.c      ****     }
1914:../uvc.c      **** 
1915:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1916:../uvc.c      ****      * must use GpioOverride to configure it */
1917:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1918:../uvc.c      ****     if (apiRetStatus != 0)
1919:../uvc.c      ****     {
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1921:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1922:../uvc.c      ****     }
1923:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1924:../uvc.c      ****     if (apiRetStatus != 0)
1925:../uvc.c      ****     {
1926:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1927:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1928:../uvc.c      ****     }
1929:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1930:../uvc.c      ****     if (apiRetStatus != 0)
1931:../uvc.c      ****     {
1932:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1933:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1934:../uvc.c      ****     }
1935:../uvc.c      **** 
1936:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1938:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1939:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1940:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1941:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1943:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1944:../uvc.c      ****     {
1945:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1946:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1947:../uvc.c      ****     }
1948:../uvc.c      **** 
1949:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1950:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1951:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1952:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1953:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1954:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1955:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1958:../uvc.c      ****     {
1959:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1960:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1961:../uvc.c      ****     }
1962:../uvc.c      **** 
1963:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1964:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1965:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1966:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1967:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1968:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1969:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1971:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1972:../uvc.c      ****     {
1973:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1974:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1975:../uvc.c      ****     }
1976:../uvc.c      **** 
1977:../uvc.c      ****     /* Initialize the P-port. */
1978:../uvc.c      ****     pibclock.clkDiv      = 2;
1979:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1980:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1981:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1982:../uvc.c      **** 
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1985:../uvc.c      ****     {
1986:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1987:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1988:../uvc.c      ****     }
1989:../uvc.c      **** 
1990:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1991:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1992:../uvc.c      **** 
1993:../uvc.c      **** #ifdef BACKFLOW_DETECT
1994:../uvc.c      ****     back_flow_detected = 0;
1995:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1996:../uvc.c      **** #endif
1997:../uvc.c      **** 
1998:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1999:../uvc.c      ****     SensorReset ();
2000:../uvc.c      ****     CyU3PThreadSleep(5000);
2001:../uvc.c      ****     //SensorInit ();
2002:../uvc.c      **** 
2003:../uvc.c      ****     /* USB initialization. */
2004:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2006:../uvc.c      ****     {
2007:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2008:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2009:../uvc.c      ****     }
2010:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2011:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2012:../uvc.c      **** 
2013:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2014:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2015:../uvc.c      **** 
2016:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2017:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2018:../uvc.c      **** 
2019:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2021:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2022:../uvc.c      **** 
2023:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2026:../uvc.c      **** 
2027:../uvc.c      ****     /* Configuration descriptors. */
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2031:../uvc.c      **** 
2032:../uvc.c      ****     /* String Descriptors */
2033:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2034:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2035:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2036:../uvc.c      **** 
2037:../uvc.c      ****     /* Configure the status interrupt endpoint.
2038:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2039:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2040:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2041:../uvc.c      ****      */
2042:../uvc.c      ****     endPointConfig.enable   = 1;
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2046:../uvc.c      ****     endPointConfig.streams  = 0;
2047:../uvc.c      ****     endPointConfig.burstLen = 1;
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2049:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2050:../uvc.c      ****     {
2051:../uvc.c      ****         /* Error Handling */
2052:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2053:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2054:../uvc.c      ****     }
2055:../uvc.c      **** 
2056:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
2058:../uvc.c      ****     dmaInterConfig.count          = 1;
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2061:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2062:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2063:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2064:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2065:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2067:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2069:../uvc.c      ****             &dmaInterConfig);
2070:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2071:../uvc.c      ****     {
2072:../uvc.c      ****         /* Error handling */
2073:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2074:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2075:../uvc.c      ****     }
2076:../uvc.c      **** 
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
2079:../uvc.c      ****     {
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2081:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2082:../uvc.c      ****     }
2083:../uvc.c      **** 
2084:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2085:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2086:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2087:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2089:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2092:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2093:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2095:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2096:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2100:../uvc.c      ****             &dmaMultiConfig);
2101:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2102:../uvc.c      ****     {
2103:../uvc.c      ****         /* Error handling */
2104:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2105:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2106:../uvc.c      ****     }
2107:../uvc.c      **** 
2108:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2109:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2110:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2111:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2112:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2113:../uvc.c      ****      */
2114:../uvc.c      **** 
2115:../uvc.c      ****     endPointConfig.enable   = 1;
2116:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2117:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2118:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2119:../uvc.c      ****     endPointConfig.streams  = 0;
2120:../uvc.c      ****     endPointConfig.burstLen = 1;
2121:../uvc.c      **** 
2122:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2123:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2124:../uvc.c      ****     {
2125:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2126:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2127:../uvc.c      ****     }
2128:../uvc.c      **** 
2129:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2130:../uvc.c      **** 
2131:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2132:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2133:../uvc.c      ****     {
2134:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2135:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2136:../uvc.c      ****     }
2137:../uvc.c      **** 
2138:../uvc.c      ****     channelConfig.size           = 1024;
2139:../uvc.c      ****     channelConfig.count          = 1;
2140:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2141:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2142:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2143:../uvc.c      ****     channelConfig.prodHeader     = 0;
2144:../uvc.c      ****     channelConfig.prodFooter     = 0;
2145:../uvc.c      ****     channelConfig.consHeader     = 0;
2146:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2147:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2148:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2149:../uvc.c      **** 
2150:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2151:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2152:../uvc.c      ****     {
2153:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2154:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2155:../uvc.c      ****     }
2156:../uvc.c      **** 
2157:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2158:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2159:../uvc.c      ****     {
2160:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2161:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2162:../uvc.c      ****     }
2163:../uvc.c      **** 
2164:../uvc.c      ****     channelConfig.size           = 1024;
2165:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2166:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2167:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2168:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2169:../uvc.c      ****     channelConfig.prodHeader     = 0;
2170:../uvc.c      ****     channelConfig.prodFooter     = 0;
2171:../uvc.c      ****     channelConfig.consHeader     = 0;
2172:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2173:../uvc.c      ****     channelConfig.notification   = 0;
2174:../uvc.c      ****     channelConfig.cb             = 0;
2175:../uvc.c      **** 
2176:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2177:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2178:../uvc.c      ****     {
2179:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2180:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2181:../uvc.c      ****     }
2182:../uvc.c      **** 
2183:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2184:../uvc.c      ****     if (glDebugRspBuffer == 0)
2185:../uvc.c      ****     {
2186:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2187:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2188:../uvc.c      ****     }
2189:../uvc.c      **** #endif
2190:../uvc.c      **** 
2191:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2192:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2193:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2194:../uvc.c      ****     {
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2196:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2197:../uvc.c      ****     }
2198:../uvc.c      **** 
2199:../uvc.c      ****     CyU3PBusyWait(100);
2200:../uvc.c      **** 
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2202:../uvc.c      **** 
2203:../uvc.c      ****     endPointConfig.enable   = 1;
2204:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2205:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2206:../uvc.c      ****     {
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2208:../uvc.c      ****     	endPointConfig.burstLen = 16;
2209:../uvc.c      ****     }
2210:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2211:../uvc.c      ****     {
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2213:../uvc.c      ****     	endPointConfig.burstLen = 1;
2214:../uvc.c      ****     }
2215:../uvc.c      ****     endPointConfig.streams  = 0;
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2217:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2218:../uvc.c      ****     {
2219:../uvc.c      ****         /* Error Handling */
2220:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2221:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2222:../uvc.c      ****     }
2223:../uvc.c      **** #if 0    //for still image method 3 using
2224:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2225:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2226:../uvc.c      ****     {
2227:../uvc.c      ****         /* Error Handling */
2228:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2229:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2230:../uvc.c      ****     }
2231:../uvc.c      **** #endif
2232:../uvc.c      **** 
2233:../uvc.c      **** }
2234:../uvc.c      **** 
2235:../uvc.c      **** /*
2236:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2237:../uvc.c      ****  * streaming session is started.
2238:../uvc.c      ****  */
2239:../uvc.c      **** static void
2240:../uvc.c      **** CyFxUvcAppGpifInit (
2241:../uvc.c      ****         void)
2242:../uvc.c      **** {
2243:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2244:../uvc.c      **** 
2245:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2246:../uvc.c      ****     {
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2249:../uvc.c      ****     }
2250:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2251:../uvc.c      ****     {
2252:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2253:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2254:../uvc.c      ****     }
2255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2256:../uvc.c      ****     {
2257:../uvc.c      ****         /* Error Handling */
2258:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2259:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2260:../uvc.c      ****     }
2261:../uvc.c      **** 
2262:../uvc.c      ****     /* Start the state machine from the designated start state. */
2263:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2264:../uvc.c      ****     {
2265:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2266:../uvc.c      ****     }
2267:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2268:../uvc.c      ****     {
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2270:../uvc.c      ****     }
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2272:../uvc.c      ****     {
2273:../uvc.c      ****         /* Error Handling */
2274:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2275:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2276:../uvc.c      ****     }
2277:../uvc.c      **** }
2278:../uvc.c      **** 
2279:../uvc.c      **** /*
2280:../uvc.c      ****  * Entry function for the UVC Application Thread
2281:../uvc.c      ****  */
2282:../uvc.c      **** 
2283:../uvc.c      **** uint32_t posTick;
2284:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2285:../uvc.c      **** 
2286:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2287:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2289:../uvc.c      **** }
2290:../uvc.c      **** 
2291:../uvc.c      **** 
2292:../uvc.c      **** void
2293:../uvc.c      **** UVCAppThread_Entry (
2294:../uvc.c      ****         uint32_t input)
2295:../uvc.c      **** {
2296:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2297:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2298:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2299:../uvc.c      ****     uint8_t i = 0;
2300:../uvc.c      ****     uint32_t flag;
2301:../uvc.c      ****     uint32_t prinflag = 0;
2302:../uvc.c      **** static uint8_t IMcount = 0;
2303:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2304:../uvc.c      ****     uint32_t frameCnt = 0;
2305:../uvc.c      **** #endif
2306:../uvc.c      ****     /* Initialize the Uart Debug Module */
2307:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2308:../uvc.c      **** 
2309:../uvc.c      ****     /* Initialize the I2C interface */
2310:../uvc.c      **** 	while (i++ < 6){
2311:../uvc.c      **** 		CyU3PThreadSleep(500);
2312:../uvc.c      **** 	}
2313:../uvc.c      **** 
2314:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2315:../uvc.c      **** 
2316:../uvc.c      ****     /* Initialize the UVC Application */
2317:../uvc.c      ****     CyFxUVCApplnInit ();
2318:../uvc.c      ****     /*
2319:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2320:../uvc.c      **** 
2321:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2322:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2323:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2324:../uvc.c      **** 
2325:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2326:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2327:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2328:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2329:../uvc.c      **** 
2330:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2331:../uvc.c      ****        of handling the abort request.
2332:../uvc.c      ****      */
2333:../uvc.c      **** 
2334:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2335:../uvc.c      ****     //CyU3PThreadSleep(1000);
2336:../uvc.c      **** 
2337:../uvc.c      ****     for (;;)
2338:../uvc.c      ****     {
2339:../uvc.c      ****         /* Waiting for the Video Stream Event */
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2341:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2342:../uvc.c      ****         {
2343:../uvc.c      **** #if 0 //test for new firmware no video bring up
2344:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2345:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2346:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2347:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2348:../uvc.c      ****             {
2349:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2350:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2351:../uvc.c      ****                 {
2352:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2353:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2354:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2355:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2356:../uvc.c      **** #endif
2357:../uvc.c      **** #endif
2358:../uvc.c      ****                     }
2359:../uvc.c      ****                 else
2360:../uvc.c      ****                 {
2361:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2362:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2363:../uvc.c      **** #ifdef USB_LOWRES_IMG
2364:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2365:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2366:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2367:../uvc.c      **** #endif
2368:../uvc.c      **** #endif
2369:../uvc.c      ****                 }
2370:../uvc.c      **** 
2371:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2372:../uvc.c      ****                 prodCount++;
2373:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2374:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2375:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2376:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2377:../uvc.c      ****                 {
2378:../uvc.c      ****                     prodCount--;
2379:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2380:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2381:../uvc.c      ****                 }
2382:../uvc.c      ****             }
2383:../uvc.c      **** #endif
2384:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2385:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2387:../uvc.c      ****             {
2388:../uvc.c      ****             	if(0&&(prinflag == 0)){
2389:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2390:../uvc.c      ****             		prinflag = 1;
2391:../uvc.c      ****             	}
2392:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2393:../uvc.c      ****             	fb=0;
2394:../uvc.c      ****             	pb=0;
2395:../uvc.c      ****             	pbc=0;
2396:../uvc.c      ****                 prodCount = 0;
2397:../uvc.c      ****                 consCount = 0;
2398:../uvc.c      ****                 hitFV     = CyFalse;
2399:../uvc.c      **** 
2400:../uvc.c      **** #ifdef BACKFLOW_DETECT
2401:../uvc.c      ****                 back_flow_detected = 0;
2402:../uvc.c      **** #endif
2403:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2404:../uvc.c      ****                 frameCnt++;
2405:../uvc.c      **** #endif
2406:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2407:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2408:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2409:../uvc.c      ****                 //}
2410:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2412:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2413:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2415:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2416:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2417:../uvc.c      ****                        	SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*bo
2418:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2419:../uvc.c      ****                 		stiflag = 0xFF;
2420:../uvc.c      ****                 		IMcount = 0;
2421:../uvc.c      ****                 	}
2422:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2423:../uvc.c      **** 
2424:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2426:../uvc.c      ****                 		stiflag = 0x0F;
2427:../uvc.c      ****                 		IMcount = 0;
2428:../uvc.c      ****                 		}
2429:../uvc.c      ****                  		/*if(IMcount > 0x4){
2430:../uvc.c      ****                 			stiflag = 0x0F;
2431:../uvc.c      ****                 			IMcount = 0;
2432:../uvc.c      ****                 		}*/
2433:../uvc.c      **** 
2434:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2435:../uvc.c      ****                     //CyU3PThreadSleep(400);
2436:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2437:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2438:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2439:../uvc.c      **** 
2440:../uvc.c      ****                 	if(IMcount++ >= 0x4)
2441:../uvc.c      ****                 	{
2442:../uvc.c      ****                     switch (setRes)
2443:../uvc.c      ****                      {
2444:../uvc.c      ****                  	case 1: //1944
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2446:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2447:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x64:0xE
2448:../uvc.c      ****                  		break;
2449:../uvc.c      ****                  	case 2: //1080
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2451:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2452:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x54:0xD
2453:../uvc.c      ****                  		break;
2454:../uvc.c      ****                  	case 3: //720
2455:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2456:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2457:../uvc.c      ****                         //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 0x45:0
2458:../uvc.c      ****                  		break;
2459:../uvc.c      ****                  	default:
2460:../uvc.c      ****                  		break;
2461:../uvc.c      ****                      }
2462:../uvc.c      ****                     IMcount = 0;
2463:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2464:../uvc.c      ****                 	stiflag = 0x0;
2465:../uvc.c      ****                 	}
2466:../uvc.c      ****                 }
2467:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2468:../uvc.c      ****                 /* Reset the DMA channel. */
2469:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2470:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2471:../uvc.c      ****                 {
2472:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2473:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2474:../uvc.c      ****                 }
2475:../uvc.c      **** 
2476:../uvc.c      ****                 /* Start Channel Immediately */
2477:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2478:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2479:../uvc.c      ****                 {
2480:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2481:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2482:../uvc.c      ****                 }
2483:../uvc.c      **** 
2484:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2485:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2486:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2487:../uvc.c      ****                 }
2488:../uvc.c      ****         }
2489:../uvc.c      ****         else
2490:../uvc.c      ****         {
2491:../uvc.c      ****             /* If we have a stream abort request pending. */
2492:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2493:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2494:../uvc.c      ****             {
2495:../uvc.c      ****                 hitFV     = CyFalse;
2496:../uvc.c      ****                 prodCount = 0;
2497:../uvc.c      ****                 consCount = 0;
2498:../uvc.c      ****                 if(0&&(prinflag == 0)){
2499:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2500:../uvc.c      ****                 	prinflag = 1;
2501:../uvc.c      ****                 }
2502:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2503:../uvc.c      ****                 fb=0;
2504:../uvc.c      ****                 pb=0;
2505:../uvc.c      ****                 pbc=0;
2506:../uvc.c      **** 
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2508:../uvc.c      ****                 {
2509:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2510:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2511:../uvc.c      ****                     {
2512:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****                     }
2514:../uvc.c      **** 
2515:../uvc.c      ****                     /* Flush the Endpoint memory */
2516:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2517:../uvc.c      ****                 }
2518:../uvc.c      **** 
2519:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2520:../uvc.c      ****             }
2521:../uvc.c      ****             else
2522:../uvc.c      ****             {
2523:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2525:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2526:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2527:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2528:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2529:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2530:../uvc.c      ****                 {
2531:../uvc.c      ****                     /* Error handling */
2532:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2533:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2534:../uvc.c      ****                 }
2535:../uvc.c      **** 
2536:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2537:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2538:../uvc.c      ****                 {
2539:../uvc.c      **** #if 0
2540:../uvc.c      ****                 	//for start up of the AF Lens
2541:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2542:../uvc.c      ****                     CyU3PThreadSleep(500);
2543:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2544:../uvc.c      ****                     CyU3PThreadSleep(500);
2545:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2546:../uvc.c      ****                    	CyU3PThreadSleep(300);
2547:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2548:../uvc.c      ****                     CyU3PThreadSleep(500);
2549:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2550:../uvc.c      ****                     CyU3PThreadSleep(500);
2551:../uvc.c      **** #endif
2552:../uvc.c      **** #if 0
2553:../uvc.c      ****                     switch (setRes)
2554:../uvc.c      ****                     {
2555:../uvc.c      ****                     	case 1: //1944
2556:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2557:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2558:../uvc.c      ****                     		break;
2559:../uvc.c      ****                     	case 2: //1080
2560:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2561:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2562:../uvc.c      ****                     		break;
2563:../uvc.c      ****                     	case 3: //720
2564:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
2565:../uvc.c      ****                     		CyU3PThreadSleep(1000);
2566:../uvc.c      ****                     		break;
2567:../uvc.c      ****                     	default:
2568:../uvc.c      ****                     		break;
2569:../uvc.c      ****                     }
2570:../uvc.c      **** #endif
2571:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2572:../uvc.c      **** 
2573:../uvc.c      ****                     gpif_initialized = CyTrue;
2574:../uvc.c      ****                     CyU3PThreadSleep(200);
2575:../uvc.c      ****                     
2576:../uvc.c      ****                 }
2577:../uvc.c      ****                 else
2578:../uvc.c      ****                 {
2579:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2580:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2581:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2582:../uvc.c      ****                 }
2583:../uvc.c      ****             }
2584:../uvc.c      ****         }
2585:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2586:../uvc.c      **** 
2587:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2588:../uvc.c      ****         CyU3PThreadRelinquish ();
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** 
2592:../uvc.c      **** /*
2593:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2594:../uvc.c      ****  */
2595:../uvc.c      **** 
2596:../uvc.c      **** static void
2597:../uvc.c      **** UVCHandleProcessingUnitRqts (
2598:../uvc.c      ****         void)
2599:../uvc.c      **** {
2600:../uvc.c      ****     uint8_t CtrlAdd;
2601:../uvc.c      **** #ifdef DbgInfo
2602:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2603:../uvc.c      **** #endif
2604:../uvc.c      ****     switch (wValue)
2605:../uvc.c      ****     {
2606:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2607:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2608:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2609:../uvc.c      ****     		break;
2610:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2611:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2612:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2613:../uvc.c      ****     		break;
2614:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2615:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2616:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2617:../uvc.c      **** 			break;
2618:../uvc.c      **** 
2619:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2620:../uvc.c      **** 
2621:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2622:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2623:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2624:../uvc.c      ****       		break;
2625:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2626:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2627:../uvc.c      ****      		ControlHandle(HueCtlID5);
2628:../uvc.c      ****      		break;
2629:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2630:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2631:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2632:../uvc.c      ****           		break;
2633:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2634:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2635:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2636:../uvc.c      ****           		break;
2637:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2638:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2639:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2640:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2641:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2642:../uvc.c      ****     		break;
2643:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2644:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2645:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2646:../uvc.c      ****     		break;
2647:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2648:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2649:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2650:../uvc.c      ****     		break;
2651:../uvc.c      **** 
2652:../uvc.c      ****         default:
2653:../uvc.c      ****             /*
2654:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2655:../uvc.c      ****              * other controls.
2656:../uvc.c      ****              */
2657:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2658:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2659:../uvc.c      ****             break;
2660:../uvc.c      ****     }
2661:../uvc.c      **** }
2662:../uvc.c      **** 
2663:../uvc.c      **** /*
2664:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2665:../uvc.c      ****  */
2666:../uvc.c      **** static void
2667:../uvc.c      **** UVCHandleCameraTerminalRqts (
2668:../uvc.c      ****         void)
2669:../uvc.c      **** {
2670:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2671:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2672:../uvc.c      ****     uint16_t readCount;
2673:../uvc.c      ****     uint16_t zoomVal;
2674:../uvc.c      ****     int32_t  panVal, tiltVal;
2675:../uvc.c      ****     CyBool_t sendData = CyFalse;
2676:../uvc.c      **** #endif
2677:../uvc.c      ****     uint8_t CtrlAdd;
2678:../uvc.c      **** 
2679:../uvc.c      ****     switch (wValue)
2680:../uvc.c      ****     {
2681:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2682:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2683:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2684:../uvc.c      ****     		break;
2685:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2686:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2687:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2688:../uvc.c      ****     		break;
2689:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2690:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2691:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2692:../uvc.c      **** 			break;
2693:../uvc.c      **** 
2694:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2695:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2696:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2697:../uvc.c      **** 			break;
2698:../uvc.c      **** 
2699:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2700:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2701:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2702:../uvc.c      ****       		break;
2703:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2704:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2705:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2706:../uvc.c      ****      		break;
2707:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2708:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2709:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2710:../uvc.c      ****           		break;
2711:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2712:../uvc.c      ****           		break;
2713:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2714:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2715:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2716:../uvc.c      ****      		break;
2717:../uvc.c      **** 
2718:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2719:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2720:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2721:../uvc.c      ****     		break;
2722:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2723:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2724:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2725:../uvc.c      ****     		break;
2726:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2727:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2728:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2729:../uvc.c      ****     		break;
2730:../uvc.c      **** 
2731:../uvc.c      ****         default:
2732:../uvc.c      ****             /*
2733:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2734:../uvc.c      ****              * other controls.
2735:../uvc.c      ****              */
2736:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2737:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2738:../uvc.c      ****             break;
2739:../uvc.c      ****     }
2740:../uvc.c      **** 
2741:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2742:../uvc.c      ****     switch (wValue)
2743:../uvc.c      ****     {
2744:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2745:../uvc.c      ****             switch (bRequest)
2746:../uvc.c      ****             {
2747:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2748:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2749:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2750:../uvc.c      ****                     break;
2751:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2752:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2753:../uvc.c      ****                     sendData = CyTrue;
2754:../uvc.c      ****                     break;
2755:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2756:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2757:../uvc.c      ****                     sendData = CyTrue;
2758:../uvc.c      ****                     break;
2759:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2760:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2761:../uvc.c      ****                     sendData = CyTrue;
2762:../uvc.c      ****                     break;
2763:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2764:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2765:../uvc.c      ****                     sendData = CyTrue;
2766:../uvc.c      ****                     break;
2767:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2768:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2769:../uvc.c      ****                     sendData = CyTrue;
2770:../uvc.c      ****                     break;
2771:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2772:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2773:../uvc.c      ****                             glEp0Buffer, &readCount);
2774:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2775:../uvc.c      ****                     {
2776:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2777:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2778:../uvc.c      ****                     }
2779:../uvc.c      ****                     break;
2780:../uvc.c      ****                 default:
2781:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2782:../uvc.c      ****                     break;
2783:../uvc.c      ****             }
2784:../uvc.c      **** 
2785:../uvc.c      ****             if (sendData)
2786:../uvc.c      ****             {
2787:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2788:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2789:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2790:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2791:../uvc.c      ****             }
2792:../uvc.c      ****             break;
2793:../uvc.c      **** 
2794:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2795:../uvc.c      ****             switch (bRequest)
2796:../uvc.c      ****             {
2797:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2798:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2799:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2800:../uvc.c      ****                     break;
2801:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2802:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2803:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2804:../uvc.c      ****                     sendData = CyTrue;
2805:../uvc.c      ****                     break;
2806:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2807:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2808:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2809:../uvc.c      ****                     sendData = CyTrue;
2810:../uvc.c      ****                     break;
2811:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2812:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2813:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2814:../uvc.c      ****                     sendData = CyTrue;
2815:../uvc.c      ****                     break;
2816:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2817:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2818:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2819:../uvc.c      ****                     sendData = CyTrue;
2820:../uvc.c      ****                     break;
2821:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2822:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2823:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2824:../uvc.c      ****                     sendData = CyTrue;
2825:../uvc.c      ****                     break;
2826:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2827:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2828:../uvc.c      ****                             glEp0Buffer, &readCount);
2829:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2830:../uvc.c      ****                     {
2831:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2832:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2833:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2834:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2835:../uvc.c      **** 
2836:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2837:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2838:../uvc.c      ****                     }
2839:../uvc.c      ****                     break;
2840:../uvc.c      ****                 default:
2841:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2842:../uvc.c      ****                     break;
2843:../uvc.c      ****             }
2844:../uvc.c      **** 
2845:../uvc.c      ****             if (sendData)
2846:../uvc.c      ****             {
2847:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2848:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2849:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2850:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2851:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2852:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2853:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2854:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2855:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2856:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2857:../uvc.c      ****             }
2858:../uvc.c      ****             break;
2859:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2860:../uvc.c      ****         default:
2861:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2862:../uvc.c      ****             break;
2863:../uvc.c      ****     }
2864:../uvc.c      **** #endif
2865:../uvc.c      **** }
2866:../uvc.c      **** 
2867:../uvc.c      **** /*
2868:../uvc.c      ****  * Handler for UVC Interface control requests.
2869:../uvc.c      ****  */
2870:../uvc.c      **** static void
2871:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2872:../uvc.c      ****         void)
2873:../uvc.c      **** {
2874:../uvc.c      **** 
2875:../uvc.c      ****     switch (wValue)
2876:../uvc.c      ****     {
2877:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2878:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2879:../uvc.c      ****     		break;
2880:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2881:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2882:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2883:../uvc.c      ****     		break;
2884:../uvc.c      ****     	default:
2885:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2886:../uvc.c      ****      		break;
2887:../uvc.c      ****     }
2888:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2889:../uvc.c      **** 
2890:../uvc.c      **** }
2891:../uvc.c      **** 
2892:../uvc.c      **** /*
2893:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2894:../uvc.c      ****  */
2895:../uvc.c      **** static void
2896:../uvc.c      **** UVCHandleExtensionUnitRqts (
2897:../uvc.c      ****         void)
2898:../uvc.c      **** {
2899:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2900:../uvc.c      **** 
2901:../uvc.c      **** #ifdef DbgInfo
2902:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2903:../uvc.c      **** #endif
2904:../uvc.c      ****     switch (wValue)
2905:../uvc.c      ****     {
2906:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2907:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2908:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2909:../uvc.c      ****     		break;
2910:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2911:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2912:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2913:../uvc.c      ****     		break;
2914:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2915:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2916:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2917:../uvc.c      ****      		break;
2918:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2919:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2920:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2921:../uvc.c      ****     		break;
2922:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2923:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2924:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2925:../uvc.c      ****     		break;
2926:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2927:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2928:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2929:../uvc.c      ****      		break;
2930:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2931:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2932:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2933:../uvc.c      ****     		break;
2934:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2935:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2936:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2937:../uvc.c      ****     		break;
2938:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2939:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2940:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2941:../uvc.c      ****      		break;
2942:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2943:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
2944:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2945:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2946:../uvc.c      ****     		}else/* no support for 1080p camera */
2947:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2948:../uvc.c      ****     		break;
2949:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2950:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2951:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2952:../uvc.c      ****     		break;
2953:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2954:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2955:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2956:../uvc.c      ****     		break;
2957:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2958:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2959:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2960:../uvc.c      ****     		//break;
2961:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2962:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2963:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2964:../uvc.c      ****     		break;
2965:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2966:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2967:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2968:../uvc.c      ****     		break;
2969:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2970:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2971:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2972:../uvc.c      ****     		break;
2973:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2974:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2975:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2976:../uvc.c      ****     		break;
2977:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2978:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2979:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2980:../uvc.c      ****     		break;
2981:../uvc.c      ****    	default:
2982:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2983:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2984:../uvc.c      ****     		break;
2985:../uvc.c      ****     }
2986:../uvc.c      **** 
2987:../uvc.c      **** }
2988:../uvc.c      **** 
2989:../uvc.c      **** /*
2990:../uvc.c      ****  * Handler for the video streaming control requests.
2991:../uvc.c      ****  */
2992:../uvc.c      **** static void
2993:../uvc.c      **** UVCHandleVideoStreamingRqts (
2994:../uvc.c      ****         void)
2995:../uvc.c      **** {
2996:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2997:../uvc.c      ****     uint16_t readCount;
2998:../uvc.c      **** 
2999:../uvc.c      ****     switch (wValue)
3000:../uvc.c      ****     {
3001:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3002:../uvc.c      ****             switch (bRequest)
3003:../uvc.c      ****             {
3004:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3005:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3006:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3007:../uvc.c      ****                     break;
3008:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3009:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3010:../uvc.c      ****                     glEp0Buffer[1] = 0;
3011:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3012:../uvc.c      ****                     break;
3013:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3014:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3015:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3016:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3017:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3018:../uvc.c      ****                     {
3019:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3020:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3021:../uvc.c      **** 
3022:../uvc.c      ****                     }
3023:../uvc.c      ****                     else
3024:../uvc.c      ****                     {
3025:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3026:../uvc.c      ****                     }
3027:../uvc.c      ****                     break;
3028:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3029:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3030:../uvc.c      ****                             glCommitCtrl, &readCount);
3031:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3032:../uvc.c      ****                     {
3033:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3034:../uvc.c      ****                         {
3035:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3036:../uvc.c      ****                                active data structure. */
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3043:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3044:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3045:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3046:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3047:../uvc.c      **** #if 0
3048:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3049:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3050:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3051:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3052:../uvc.c      **** #endif
3053:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3054:../uvc.c      ****                        }
3055:../uvc.c      ****                     }
3056:../uvc.c      ****                     break;
3057:../uvc.c      ****                 default:
3058:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3059:../uvc.c      ****                     break;
3060:../uvc.c      ****             }
3061:../uvc.c      ****             break;
3062:../uvc.c      **** 
3063:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3064:../uvc.c      ****             switch (bRequest)
3065:../uvc.c      ****             {
3066:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3067:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3069:../uvc.c      ****                     break;
3070:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3071:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3072:../uvc.c      ****                     glEp0Buffer[1] = 0;
3073:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3074:../uvc.c      ****                     break;
3075:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3076:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3077:../uvc.c      ****                     {
3078:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3079:../uvc.c      ****                     }
3080:../uvc.c      ****                     else
3081:../uvc.c      ****                     {
3082:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3083:../uvc.c      ****                     }
3084:../uvc.c      ****                     break;
3085:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3086:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3087:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3088:../uvc.c      ****                        */
3089:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3090:../uvc.c      ****                             glCommitCtrl, &readCount);
3091:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3092:../uvc.c      ****                     {
3093:../uvc.c      ****                         switch (glCommitCtrl[3])
3094:../uvc.c      ****                          {
3095:../uvc.c      ****                          	case 1: //1944
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
3098:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3099:../uvc.c      ****                          		break;
3100:../uvc.c      ****                          	case 2: //1080
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
3103:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 
3104:../uvc.c      ****                          		break;
3105:../uvc.c      ****                          	case 3: //720
3106:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3107:../uvc.c      ****                          		CyU3PThreadSleep(500);
3108:../uvc.c      ****                                 //CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz
3109:../uvc.c      ****                          		break;
3110:../uvc.c      ****                          	default:
3111:../uvc.c      ****                          		break;
3112:../uvc.c      ****                          }
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
3114:../uvc.c      **** #if 0
3115:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3116:../uvc.c      ****                         {
3117:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3118:../uvc.c      ****                         }
3119:../uvc.c      ****                         else
3120:../uvc.c      ****                         {
3121:../uvc.c      ****                             SensorScaling_VGA ();
3122:../uvc.c      ****                         }
3123:../uvc.c      **** #endif
3124:../uvc.c      ****                         /* We can start streaming video now. */
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3126:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3127:../uvc.c      ****                         {
3128:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3129:../uvc.c      ****                         }
3130:../uvc.c      ****                     }
3131:../uvc.c      ****                     break;
3132:../uvc.c      **** 
3133:../uvc.c      ****                 default:
3134:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3135:../uvc.c      ****                     break;
3136:../uvc.c      ****             }
3137:../uvc.c      ****             break;
3138:../uvc.c      **** 
3139:../uvc.c      **** /* still image streaming handler */
3140:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3141:../uvc.c      ****                 switch (bRequest)
3142:../uvc.c      ****                 {
3143:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3144:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3145:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3146:../uvc.c      ****                         break;
3147:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3148:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3149:../uvc.c      ****                         glEp0Buffer[1] = 0;
3150:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3151:../uvc.c      ****                         break;
3152:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3153:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3154:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3155:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3156:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3157:../uvc.c      ****                         {
3158:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3159:../uvc.c      ****                         }
3160:../uvc.c      ****                         else
3161:../uvc.c      ****                         {
3162:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3163:../uvc.c      ****                         }
3164:../uvc.c      ****                         break;
3165:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3166:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3167:../uvc.c      ****                                 glCommitCtrl, &readCount);
3168:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3169:../uvc.c      ****                         {
3170:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3171:../uvc.c      ****                             {
3172:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3173:../uvc.c      ****                                    active data structure. */
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3180:../uvc.c      ****                             }
3181:../uvc.c      ****                             //CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", r
3182:../uvc.c      ****                         }
3183:../uvc.c      ****                         break;
3184:../uvc.c      ****                     default:
3185:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3186:../uvc.c      ****                         break;
3187:../uvc.c      ****                 }
3188:../uvc.c      ****                 break;
3189:../uvc.c      **** 
3190:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3191:../uvc.c      ****                 switch (bRequest)
3192:../uvc.c      ****                 {
3193:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3194:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3196:../uvc.c      ****                         break;
3197:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3198:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3199:../uvc.c      ****                         glEp0Buffer[1] = 0;
3200:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3201:../uvc.c      ****                         break;
3202:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3204:../uvc.c      ****                         {
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3206:../uvc.c      ****                         }
3207:../uvc.c      ****                         else
3208:../uvc.c      ****                         {
3209:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3210:../uvc.c      ****                         }
3211:../uvc.c      ****                         break;
3212:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3213:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3214:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3215:../uvc.c      ****                            */
3216:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3217:../uvc.c      ****                                 glCommitCtrl, &readCount);
3218:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3219:../uvc.c      ****                         {
3220:../uvc.c      ****     #if 0
3221:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3222:../uvc.c      ****                             {
3223:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3224:../uvc.c      ****                             }
3225:../uvc.c      ****                             else
3226:../uvc.c      ****                             {
3227:../uvc.c      ****                                 SensorScaling_VGA ();
3228:../uvc.c      ****                             }
3229:../uvc.c      ****     #endif
3230:../uvc.c      ****                             /* We can start streaming video now. */
3231:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3232:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3233:../uvc.c      ****                             {
3234:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3235:../uvc.c      ****                             }
3236:../uvc.c      ****                         	//CyU3PDebugPrint (4, "UVC still commit control %d %d %d\r\n", readCount, 
3237:../uvc.c      **** 
3238:../uvc.c      ****                         }
3239:../uvc.c      ****                         break;
3240:../uvc.c      **** 
3241:../uvc.c      ****                     default:
3242:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3243:../uvc.c      ****                         break;
3244:../uvc.c      ****                 }
3245:../uvc.c      ****                 break;
3246:../uvc.c      **** 
3247:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3248:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3249:../uvc.c      ****             	switch (bRequest)
3250:../uvc.c      ****                 {
3251:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3252:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3253:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3254:../uvc.c      ****                         break;
3255:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3256:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3257:../uvc.c      ****                         glEp0Buffer[1] = 0;
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3259:../uvc.c      ****                         break;
3260:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3261:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3262:../uvc.c      ****                         {
3263:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3264:../uvc.c      ****                         }
3265:../uvc.c      ****                         else
3266:../uvc.c      ****                         {
3267:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3268:../uvc.c      ****                         }
3269:../uvc.c      ****                         break;
3270:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3271:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3272:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3273:../uvc.c      ****                            */
3274:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3275:../uvc.c      ****                                 glCommitCtrl, &readCount);
3276:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3277:../uvc.c      ****                         {
3278:../uvc.c      ****     #if 1
3279:../uvc.c      ****                             /* We can start still streaming video now. */
3280:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3282:../uvc.c      ****                             {
3283:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3284:../uvc.c      ****                             }
3285:../uvc.c      ****     #endif
3286:../uvc.c      ****                             else{
3287:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3288:../uvc.c      ****                             //stillcont = 0;
3289:../uvc.c      ****                             }
3290:../uvc.c      ****                             //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", rea
3291:../uvc.c      ****                         }else{
3292:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3293:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3294:../uvc.c      ****                         }
3295:../uvc.c      ****                         break;
3296:../uvc.c      **** 
3297:../uvc.c      ****                     default:
3298:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3299:../uvc.c      ****                         break;
3300:../uvc.c      ****                 }
3301:../uvc.c      ****                 break;
3302:../uvc.c      **** 
3303:../uvc.c      ****         default:
3304:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3305:../uvc.c      ****             break;
3306:../uvc.c      ****     }
3307:../uvc.c      **** }
3308:../uvc.c      **** 
3309:../uvc.c      **** /*
3310:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3311:../uvc.c      ****  */
3312:../uvc.c      **** void
3313:../uvc.c      **** UVCAppEP0Thread_Entry (
3314:../uvc.c      ****         uint32_t input)
3315:../uvc.c      **** {
3316:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3317:../uvc.c      ****     uint32_t eventFlag;
3318:../uvc.c      **** 	CyBool_t value;
3319:../uvc.c      **** 	CyBool_t *valueptr = &value;
3320:../uvc.c      **** 
3321:../uvc.c      **** 
3322:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3323:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3324:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3325:../uvc.c      **** 
3326:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3327:../uvc.c      **** #endif
3328:../uvc.c      **** 
3329:../uvc.c      ****     /* for interrupt status test */
3330:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3331:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3332:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3333:../uvc.c      **** 
3334:../uvc.c      ****     for (;;)
3335:../uvc.c      ****     {
3336:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3337:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3338:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3339:../uvc.c      ****         {
3340:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3341:../uvc.c      ****             if (!isUsbConnected)
3342:../uvc.c      ****             {
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3344:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3345:../uvc.c      ****                 {
3346:../uvc.c      ****                     isUsbConnected = CyTrue;
3347:../uvc.c      ****                 }
3348:../uvc.c      ****             }
3349:../uvc.c      **** //#ifdef DbgInfo
3350:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3351:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3352:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3353:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3354:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3355:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3356:../uvc.c      **** //#endif
3357:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3358:../uvc.c      ****             {
3359:../uvc.c      ****             	switch ((wIndex >> 8))
3360:../uvc.c      ****                 {
3361:../uvc.c      **** 
3362:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3363:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3364:../uvc.c      ****                         break;
3365:../uvc.c      **** 
3366:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3367:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3368:../uvc.c      ****                         break;
3369:../uvc.c      **** 
3370:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3371:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3372:../uvc.c      ****                         break;
3373:../uvc.c      **** 
3374:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3375:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3376:../uvc.c      ****                         break;
3377:../uvc.c      **** 
3378:../uvc.c      ****                     default:
3379:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3380:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3381:../uvc.c      ****                         break;
3382:../uvc.c      ****                 }
3383:../uvc.c      ****             }
3384:../uvc.c      **** 
3385:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3386:../uvc.c      ****             {
3387:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3388:../uvc.c      **** 
3389:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3390:../uvc.c      ****                 {
3391:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3392:../uvc.c      ****                 }
3393:../uvc.c      ****                 else
3394:../uvc.c      ****                 {
3395:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3396:../uvc.c      ****                 }
3397:../uvc.c      ****             }
3398:../uvc.c      **** 
3399:../uvc.c      ****             /* handle interrupt status event */
3400:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3401:../uvc.c      ****             {
3402:../uvc.c      **** 
3403:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3404:../uvc.c      ****             	/** preparing interrupt status data **/
3405:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3406:../uvc.c      **** 
3407:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3408:../uvc.c      **** 
3409:../uvc.c      **** #if 0 //for real button
3410:../uvc.c      **** 				if(value&&(!snapButFlag)){
3411:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3412:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3413:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3414:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3415:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3416:../uvc.c      **** 
3417:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3418:../uvc.c      **** 					interStabuf.size   = 1024;
3419:../uvc.c      **** 					interStabuf.status = 0;
3420:../uvc.c      **** 
3421:../uvc.c      **** 					interStabuf.count = 4;
3422:../uvc.c      **** 
3423:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3424:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3425:../uvc.c      **** 
3426:../uvc.c      **** 					/** send a interrupt status data **/
3427:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3428:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3429:../uvc.c      **** 					{
3430:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3431:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3432:../uvc.c      **** 					}
3433:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3434:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3435:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3436:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3437:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3438:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3439:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3440:../uvc.c      **** 
3441:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3442:../uvc.c      **** 					interStabuf.size   = 1024;
3443:../uvc.c      **** 					interStabuf.status = 0;
3444:../uvc.c      **** 
3445:../uvc.c      **** 					interStabuf.count = 4;
3446:../uvc.c      **** 
3447:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3448:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3449:../uvc.c      **** 
3450:../uvc.c      **** 					/** send a interrupt status data **/
3451:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3452:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3453:../uvc.c      **** 					{
3454:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3455:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3456:../uvc.c      **** 					}
3457:../uvc.c      **** 
3458:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3459:../uvc.c      **** 					stiflag = 0xFF;
3460:../uvc.c      **** 				}
3461:../uvc.c      **** #else			//for botton simulation
3462:../uvc.c      **** 				if(snapButFlag == 0x0f){
3463:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3464:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3465:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3466:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3468:../uvc.c      **** 
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3470:../uvc.c      **** 					interStabuf.size   = 1024;
3471:../uvc.c      **** 					interStabuf.status = 0;
3472:../uvc.c      **** 
3473:../uvc.c      **** 					interStabuf.count = 4;
3474:../uvc.c      **** 
3475:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3477:../uvc.c      **** 
3478:../uvc.c      **** 					/** send a interrupt status data **/
3479:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3480:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3481:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3482:../uvc.c      **** 					{
3483:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3484:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3485:../uvc.c      **** 					}
3486:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3487:../uvc.c      **** 
3488:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3489:../uvc.c      **** 				}else if(!snapButFlag){
3490:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3491:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3492:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3495:../uvc.c      **** 
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3497:../uvc.c      **** 					interStabuf.size   = 1024;
3498:../uvc.c      **** 					interStabuf.status = 0;
3499:../uvc.c      **** 
3500:../uvc.c      **** 					interStabuf.count = 4;
3501:../uvc.c      **** 
3502:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3504:../uvc.c      **** 
3505:../uvc.c      **** 					/** send a interrupt status data **/
3506:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3507:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3508:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3509:../uvc.c      **** 					{
3510:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3511:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3512:../uvc.c      **** 					}
3513:../uvc.c      **** 
3514:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3515:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3516:../uvc.c      **** 				}
3517:../uvc.c      **** #endif
3518:../uvc.c      **** 
3519:../uvc.c      ****             }
3520:../uvc.c      **** 
3521:../uvc.c      **** 
3522:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3523:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3524:../uvc.c      ****             {
3525:../uvc.c      ****                 /* Get the command buffer */
3526:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3527:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3528:../uvc.c      ****                 {
3529:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3530:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3531:../uvc.c      ****                 }
3532:../uvc.c      **** 
3533:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3534:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3535:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3536:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3537:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3538:../uvc.c      ****                  * register value high byte and register value low byte.
3539:../uvc.c      ****                  */
3540:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3541:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3542:../uvc.c      ****                 {
3543:../uvc.c      ****                     if (dmaInfo.count == 3)
3544:../uvc.c      ****                     {
3545:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3546:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3547:../uvc.c      ****                         dmaInfo.count = 3;
3548:../uvc.c      ****                     }
3549:../uvc.c      ****                     else if (dmaInfo.count == 4)
3550:../uvc.c      ****                     {
3551:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3552:../uvc.c      ****                         {
3553:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3554:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3555:../uvc.c      ****                         }
3556:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3557:../uvc.c      ****                     }
3558:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3559:../uvc.c      ****                 }
3560:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3561:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3562:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3563:../uvc.c      ****                  */
3564:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3565:../uvc.c      ****                 {
3566:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3567:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3568:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3569:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3570:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3571:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3572:../uvc.c      ****                         	break;
3573:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3574:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3575:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3576:../uvc.c      ****                         	break;*/
3577:../uvc.c      ****                     dmaInfo.count -= 2;
3578:../uvc.c      ****                 }
3579:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3580:../uvc.c      ****                 else
3581:../uvc.c      ****                 {
3582:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3583:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3584:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3585:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3586:../uvc.c      ****                 }
3587:../uvc.c      **** 
3588:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3589:../uvc.c      ****                 dmaInfo.size   = 1024;
3590:../uvc.c      ****                 dmaInfo.status = 0;
3591:../uvc.c      **** 
3592:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3593:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3594:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3595:../uvc.c      ****                 {
3596:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3597:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3598:../uvc.c      ****                 }
3599:../uvc.c      **** 
3600:../uvc.c      ****                 /* Wait until the response has gone out. */
3601:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3602:../uvc.c      **** 
3603:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3604:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3605:../uvc.c      ****                 {
3606:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3607:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3608:../uvc.c      ****                 }
3609:../uvc.c      ****             }
3610:../uvc.c      **** #endif
3611:../uvc.c      ****         }
3612:../uvc.c      ****         /* Allow other ready threads to run. */
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
3614:../uvc.c      ****     }
3615:../uvc.c      **** }
3616:../uvc.c      **** 
3617:../uvc.c      **** /*
3618:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3619:../uvc.c      ****  * added 10/2013
3620:../uvc.c      ****  */
3621:../uvc.c      **** /*
3622:../uvc.c      **** static uint8_t timeDelay[64] = {
3623:../uvc.c      **** 
3624:../uvc.c      **** };
3625:../uvc.c      **** */
3626:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3626 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3627:../uvc.c      **** 
3628:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3629:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3630:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3631:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3632:../uvc.c      **** 	VdstateDes *lcStaDes;
3633:../uvc.c      **** 	uint32_t flag = 0;
3634:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3635:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3636:../uvc.c      **** 	uint8_t i;
3637:../uvc.c      **** 	uint16_t delaytime;
3638:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3639:../uvc.c      **** 
3640:../uvc.c      **** #if 0 //for test the command queue
3641:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3642:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3643:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3644:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3645:../uvc.c      **** 		lcCmdDes += 1;
3646:../uvc.c      **** 	}
3647:../uvc.c      **** #endif
3648:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3649:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3649 0
  36 0004 10229FE5 		ldr	r2, .L22
3633:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3633 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3626:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3626 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3649 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3633:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3633 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3649 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3650:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3650 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3651:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3651 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3652:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3652 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3653:../uvc.c      **** 
3654:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3654 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3655:../uvc.c      ****         /* Allow other ready threads to run. */
3656:../uvc.c      **** 
3657:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3657 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3654:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3654 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3658:../uvc.c      **** 	}
3659:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3659 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3660:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3661:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3662:../uvc.c      **** 	//CyU3PThreadSleep(100);
3663:../uvc.c      **** 	//SetCurCmd();
3664:../uvc.c      **** 	/*********** the loop of the thread ***********/
3665:../uvc.c      **** 	for(;;){
3666:../uvc.c      **** 
3667:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3667 0
 101 0098 0060E0E3 		mvn	r6, #0
3668:../uvc.c      **** /*  // for test GPIO output
3669:../uvc.c      **** 		if(trigger)
3670:../uvc.c      **** 		{
3671:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3672:../uvc.c      **** 			{
3673:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3674:../uvc.c      **** 			}
3675:../uvc.c      **** 
3676:../uvc.c      **** 		}else{
3677:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3678:../uvc.c      **** 			{
3679:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3680:../uvc.c      **** 			}
3681:../uvc.c      **** 
3682:../uvc.c      **** 		}
3683:../uvc.c      **** */
3684:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3685:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3686:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3687:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3688:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3689:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3690:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3691:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3692:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3693:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3694:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3695:../uvc.c      **** #endif
3696:../uvc.c      **** 				}
3697:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3698:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3699:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3700:../uvc.c      **** 			}
3701:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3702:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3703:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3704:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3705:../uvc.c      **** 
3706:../uvc.c      **** 				/*
3707:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3708:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3709:../uvc.c      **** 				*/
3710:../uvc.c      **** 
3711:../uvc.c      **** 				/* find a available command */
3712:../uvc.c      **** 				i = 0;
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3713 0
 103 009c 0090A0E3 		mov	r9, #0
3714:../uvc.c      **** 					i++;
3715:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3716:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3717:../uvc.c      **** 				}
3718:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3719:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
3720:../uvc.c      **** 					i = lcCmdDes->curNum;
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3722:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3723:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3724:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3725:../uvc.c      **** #if 1
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3727:../uvc.c      **** 						case 20:
3728:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3729:../uvc.c      **** 							delaytime = 500;
3730:../uvc.c      **** 							break;
3731:../uvc.c      **** 						case 21:
3732:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3733:../uvc.c      **** 							delaytime = 500;
3734:../uvc.c      **** 							break;
3735:../uvc.c      **** 						case 22:
3736:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3737:../uvc.c      **** 							delaytime = 300;
3738:../uvc.c      **** 							break;
3739:../uvc.c      **** 						case 23:
3740:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3741:../uvc.c      **** 							delaytime = 300;
3742:../uvc.c      **** 							break;
3743:../uvc.c      **** 						default:
3744:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3745:../uvc.c      **** 							break;
3746:../uvc.c      **** 					}
3747:../uvc.c      **** #endif
3748:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3749:../uvc.c      **** 					/** timer's ticket modify **/
3750:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
3751:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3752:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3753:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3754:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3755:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3756:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3757:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3758:../uvc.c      **** #endif
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3760:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3763:../uvc.c      **** 						}else{
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3765:../uvc.c      **** 						}
3766:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3767:../uvc.c      **** 					}else{
3768:../uvc.c      **** 						lcCmdDes->curNum ++;
3769:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3769 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3667:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3667 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3684:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3684 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3701:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3701 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3703:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3703 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3704:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3704 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3713 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3715:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3715 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3714:../uvc.c      **** 					i++;
 140              		.loc 1 3714 0
 141 00f4 011083E2 		add	r1, r3, #1
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3713 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3714:../uvc.c      **** 					i++;
 144              		.loc 1 3714 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3713:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3713 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3719:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 154              		.loc 1 3719 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3721 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3726 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3721 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3726 0
 166 0128 14C042E2 		sub	ip, r2, #20
3721:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3721 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3722:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3722 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3723:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3723 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3724:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3724 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3726:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3726 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3740:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3740 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3742:../uvc.c      **** 							break;
 193              		.loc 1 3742 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3751:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3751 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3752:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3752 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3759 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3768:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3768 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3769 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3759:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3759 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3770:../uvc.c      **** 					}
3771:../uvc.c      **** 				}else{
3772:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3773:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3774:../uvc.c      **** 				}
3775:../uvc.c      **** 			}
3776:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3776 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3777:../uvc.c      **** /*
3778:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3779:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3780:../uvc.c      **** */
3781:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3782:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3783:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3784:../uvc.c      **** #endif
3785:../uvc.c      **** 
3786:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3787:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3788:../uvc.c      **** #if 0
3789:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3790:../uvc.c      **** 
3791:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3792:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3793:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3794:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3795:../uvc.c      **** 			    i = 0;
3796:../uvc.c      **** 				 switch(cmdCopyIdx)
3797:../uvc.c      **** 				 {
3798:../uvc.c      **** 					 case BrgtCtlID1:
3799:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3800:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3801:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3802:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3803:../uvc.c      **** 							 i++;
3804:../uvc.c      **** 						 }
3805:../uvc.c      **** 						 else{
3806:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3807:../uvc.c      **** 						 }
3808:../uvc.c      **** 
3809:../uvc.c      **** 						 CyU3PBusyWait(500);
3810:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3811:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3812:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3813:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3814:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3815:../uvc.c      **** 						 }
3816:../uvc.c      **** 						 else{
3817:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3818:../uvc.c      **** 						 }
3819:../uvc.c      **** 						 break;
3820:../uvc.c      **** 					 case HueCtlID5:
3821:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3822:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3823:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3824:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3825:../uvc.c      **** 						 }
3826:../uvc.c      **** 						 else{
3827:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3828:../uvc.c      **** 						 }
3829:../uvc.c      **** 						 break;
3830:../uvc.c      **** 					 case SaturCtlID6:
3831:../uvc.c      **** 					 case WBTLevCtlID10:
3832:../uvc.c      **** 					 default:
3833:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3834:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3835:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3836:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3837:../uvc.c      **** 						 }
3838:../uvc.c      **** 						 else{
3839:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3840:../uvc.c      **** 						 }
3841:../uvc.c      **** 						 break;
3842:../uvc.c      **** 				 }
3843:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3844:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3845:../uvc.c      **** 			}
3846:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3847:../uvc.c      **** #endif
3848:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3849:../uvc.c      **** 		/* Allow other ready threads to run. */
3850:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3851:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3851 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3852:../uvc.c      **** 		}
 224              		.loc 1 3852 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3732:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3732 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3734:../uvc.c      **** 							break;
 232              		.loc 1 3734 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3744:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3744 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3745:../uvc.c      **** 							break;
 241              		.loc 1 3745 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3728:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3728 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3730:../uvc.c      **** 							break;
 249              		.loc 1 3730 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3772:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3772 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3773:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3773 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3761 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3760:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3760 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3761:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3761 0
 269 01f0 1F005CE3 		cmp	ip, #31
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3762 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3764 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3762 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3764 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3762:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3762 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3764:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3764 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3766:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3766 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2286:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2286 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2288 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2289:../uvc.c      **** }
 318              		.loc 1 2289 0
2288:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2288 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 330              	CyFxUVCApplnUSBEventCB:
 331              	.LFB8:
1347:../uvc.c      **** {
 332              		.loc 1 1347 0
 333              		.cfi_startproc
 334              		@ args = 0, pretend = 0, frame = 8
 335              		@ frame_needed = 0, uses_anonymous_args = 0
 336              	.LVL31:
1348:../uvc.c      ****     switch (evtype)
 337              		.loc 1 1348 0
 338 0250 020050E3 		cmp	r0, #2
1347:../uvc.c      **** {
 339              		.loc 1 1347 0
 340 0254 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 341              	.LCFI2:
 342              		.cfi_def_cfa_offset 16
 343 0258 0130A0E1 		mov	r3, r1
 344 025c 10D04DE2 		sub	sp, sp, #16
 345              	.LCFI3:
 346              		.cfi_def_cfa_offset 32
1347:../uvc.c      **** {
 347              		.loc 1 1347 0
 348 0260 0040A0E1 		mov	r4, r0
 349              		.cfi_offset 14, -4
 350              		.cfi_offset 6, -8
 351              		.cfi_offset 5, -12
 352              		.cfi_offset 4, -16
1348:../uvc.c      ****     switch (evtype)
 353              		.loc 1 1348 0
 354 0264 3600000A 		beq	.L30
 355 0268 040050E3 		cmp	r0, #4
 356 026c 1F00000A 		beq	.L31
 357 0270 010050E3 		cmp	r0, #1
 358 0274 0100000A 		beq	.L33
 359              	.LVL32:
 360              	.L27:
1384:../uvc.c      **** }
 361              		.loc 1 1384 0
 362 0278 10D08DE2 		add	sp, sp, #16
 363 027c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 364              	.LVL33:
 365              	.L33:
1369:../uvc.c      ****             gpif_initialized = 0;
 366              		.loc 1 1369 0
 367 0280 28519FE5 		ldr	r5, .L34
1367:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 368              		.loc 1 1367 0
 369 0284 0020A0E1 		mov	r2, r0
 370 0288 24119FE5 		ldr	r1, .L34+4
 371              	.LVL34:
 372 028c 0400A0E3 		mov	r0, #4
 373              	.LVL35:
 374 0290 FEFFFFEB 		bl	CyU3PDebugPrint
1368:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 375              		.loc 1 1368 0
 376 0294 0400A0E1 		mov	r0, r4
 377 0298 FEFFFFEB 		bl	CyU3PGpifDisable
1369:../uvc.c      ****             gpif_initialized = 0;
 378              		.loc 1 1369 0
 379 029c 00C0A0E3 		mov	ip, #0
 380              	.LBB16:
 381              	.LBB17:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 382              		.loc 1 1331 0
 383 02a0 0410A0E1 		mov	r1, r4
 384 02a4 0500A0E1 		mov	r0, r5
 385 02a8 0220A0E3 		mov	r2, #2
 386 02ac 0C308DE2 		add	r3, sp, #12
 387              	.LBE17:
 388              	.LBE16:
1369:../uvc.c      ****             gpif_initialized = 0;
 389              		.loc 1 1369 0
 390 02b0 28C085E5 		str	ip, [r5, #40]
1370:../uvc.c      ****             isUsbConnected = CyFalse;
 391              		.loc 1 1370 0
 392 02b4 30C085E5 		str	ip, [r5, #48]
1371:../uvc.c      ****             streamingStarted = CyFalse;
 393              		.loc 1 1371 0
 394 02b8 2CC085E5 		str	ip, [r5, #44]
 395              	.LBB19:
 396              	.LBB18:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 397              		.loc 1 1331 0
 398 02bc 00C08DE5 		str	ip, [sp, #0]
 399 02c0 FEFFFFEB 		bl	_txe_event_flags_get
 400 02c4 004050E2 		subs	r4, r0, #0
 401 02c8 EAFFFF1A 		bne	.L27
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 402              		.loc 1 1334 0
 403 02cc 0110E0E3 		mvn	r1, #1
 404 02d0 0220A0E3 		mov	r2, #2
 405 02d4 0500A0E1 		mov	r0, r5
 406              	.L32:
 407 02d8 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 408              		.loc 1 1337 0
 409 02dc 0500A0E1 		mov	r0, r5
 410 02e0 0210A0E3 		mov	r1, #2
 411 02e4 0420A0E1 		mov	r2, r4
 412 02e8 FEFFFFEB 		bl	_txe_event_flags_set
 413 02ec E1FFFFEA 		b	.L27
 414              	.LVL36:
 415              	.L31:
 416              	.LBE18:
 417              	.LBE19:
1353:../uvc.c      ****             gpif_initialized = 0;
 418              		.loc 1 1353 0
 419 02f0 B8509FE5 		ldr	r5, .L34
1351:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 420              		.loc 1 1351 0
 421 02f4 BC109FE5 		ldr	r1, .L34+8
 422              	.LVL37:
 423 02f8 0020A0E1 		mov	r2, r0
 424 02fc FEFFFFEB 		bl	CyU3PDebugPrint
 425              	.LVL38:
1352:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 426              		.loc 1 1352 0
 427 0300 0100A0E3 		mov	r0, #1
 428 0304 FEFFFFEB 		bl	CyU3PGpifDisable
1353:../uvc.c      ****             gpif_initialized = 0;
 429              		.loc 1 1353 0
 430 0308 00C0A0E3 		mov	ip, #0
 431              	.LBB20:
 432              	.LBB21:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 433              		.loc 1 1331 0
 434 030c 0110A0E3 		mov	r1, #1
 435 0310 0220A0E3 		mov	r2, #2
 436 0314 0500A0E1 		mov	r0, r5
 437 0318 0C308DE2 		add	r3, sp, #12
 438              	.LBE21:
 439              	.LBE20:
1353:../uvc.c      ****             gpif_initialized = 0;
 440              		.loc 1 1353 0
 441 031c 28C085E5 		str	ip, [r5, #40]
1354:../uvc.c      ****             streamingStarted = CyFalse;
 442              		.loc 1 1354 0
 443 0320 2CC085E5 		str	ip, [r5, #44]
 444              	.LBB23:
 445              	.LBB22:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 446              		.loc 1 1331 0
 447 0324 00C08DE5 		str	ip, [sp, #0]
 448 0328 FEFFFFEB 		bl	_txe_event_flags_get
 449 032c 004050E2 		subs	r4, r0, #0
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 450              		.loc 1 1334 0
 451 0330 0500A001 		moveq	r0, r5
 452 0334 0110E003 		mvneq	r1, #1
 453 0338 0220A003 		moveq	r2, #2
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 454              		.loc 1 1331 0
 455 033c CDFFFF1A 		bne	.L27
 456 0340 E4FFFFEA 		b	.L32
 457              	.LVL39:
 458              	.L30:
 459              	.LBE22:
 460              	.LBE23:
1361:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1361 0
 462 0344 64509FE5 		ldr	r5, .L34
1359:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 463              		.loc 1 1359 0
 464 0348 0020A0E1 		mov	r2, r0
 465 034c 68109FE5 		ldr	r1, .L34+12
 466              	.LVL40:
 467 0350 0400A0E3 		mov	r0, #4
 468              	.LVL41:
 469 0354 FEFFFFEB 		bl	CyU3PDebugPrint
1360:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 470              		.loc 1 1360 0
 471 0358 0100A0E3 		mov	r0, #1
 472 035c FEFFFFEB 		bl	CyU3PGpifDisable
1361:../uvc.c      ****             gpif_initialized = 0;
 473              		.loc 1 1361 0
 474 0360 0060A0E3 		mov	r6, #0
 475              	.LBB24:
 476              	.LBB25:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 477              		.loc 1 1331 0
 478 0364 0500A0E1 		mov	r0, r5
 479 0368 0110A0E3 		mov	r1, #1
 480 036c 0420A0E1 		mov	r2, r4
 481 0370 0C308DE2 		add	r3, sp, #12
 482              	.LBE25:
 483              	.LBE24:
1361:../uvc.c      ****             gpif_initialized = 0;
 484              		.loc 1 1361 0
 485 0374 286085E5 		str	r6, [r5, #40]
1362:../uvc.c      ****             streamingStarted = CyFalse;
 486              		.loc 1 1362 0
 487 0378 2C6085E5 		str	r6, [r5, #44]
 488              	.LBB27:
 489              	.LBB26:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 490              		.loc 1 1331 0
 491 037c 00608DE5 		str	r6, [sp, #0]
 492 0380 FEFFFFEB 		bl	_txe_event_flags_get
 493 0384 006050E2 		subs	r6, r0, #0
 494 0388 BAFFFF1A 		bne	.L27
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 495              		.loc 1 1334 0
 496 038c 0420A0E1 		mov	r2, r4
 497 0390 0500A0E1 		mov	r0, r5
 498 0394 0110E0E3 		mvn	r1, #1
 499 0398 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 500              		.loc 1 1337 0
 501 039c 0500A0E1 		mov	r0, r5
 502 03a0 0410A0E1 		mov	r1, r4
 503 03a4 0620A0E1 		mov	r2, r6
 504 03a8 FEFFFFEB 		bl	_txe_event_flags_set
 505 03ac B1FFFFEA 		b	.L27
 506              	.L35:
 507              		.align	2
 508              	.L34:
 509 03b0 00000000 		.word	.LANCHOR0
 510 03b4 7C000000 		.word	.LC4
 511 03b8 38000000 		.word	.LC2
 512 03bc 58000000 		.word	.LC3
 513              	.LBE26:
 514              	.LBE27:
 515              		.cfi_endproc
 516              	.LFE8:
 518              		.align	2
 519              		.global	CyFxUvcApplnDmaCallback
 521              	CyFxUvcApplnDmaCallback:
 522              	.LFB10:
1544:../uvc.c      **** {
 523              		.loc 1 1544 0
 524              		.cfi_startproc
 525              		@ args = 0, pretend = 0, frame = 0
 526              		@ frame_needed = 0, uses_anonymous_args = 0
 527              	.LVL42:
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 528              		.loc 1 1551 0
 529 03c0 080051E3 		cmp	r1, #8
1544:../uvc.c      **** {
 530              		.loc 1 1544 0
 531 03c4 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 532              	.LCFI4:
 533              		.cfi_def_cfa_offset 20
 534 03c8 0250A0E1 		mov	r5, r2
 535              		.cfi_offset 14, -4
 536              		.cfi_offset 7, -8
 537              		.cfi_offset 6, -12
 538              		.cfi_offset 5, -16
 539              		.cfi_offset 4, -20
 540 03cc 0CD04DE2 		sub	sp, sp, #12
 541              	.LCFI5:
 542              		.cfi_def_cfa_offset 32
1551:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 543              		.loc 1 1551 0
 544 03d0 0B00000A 		beq	.L42
1603:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 545              		.loc 1 1603 0
 546 03d4 100051E3 		cmp	r1, #16
 547 03d8 0700001A 		bne	.L36
1605:../uvc.c      ****         consCount++;
 548              		.loc 1 1605 0
 549 03dc 7C319FE5 		ldr	r3, .L45
1606:../uvc.c      ****         streamingStarted = CyTrue;
 550              		.loc 1 1606 0
 551 03e0 0120A0E3 		mov	r2, #1
 552              	.LVL43:
1605:../uvc.c      ****         consCount++;
 553              		.loc 1 1605 0
 554 03e4 B204D3E1 		ldrh	r0, [r3, #66]
 555              	.LVL44:
1606:../uvc.c      ****         streamingStarted = CyTrue;
 556              		.loc 1 1606 0
 557 03e8 2C2083E5 		str	r2, [r3, #44]
1605:../uvc.c      ****         consCount++;
 558              		.loc 1 1605 0
 559 03ec 02C080E0 		add	ip, r0, r2
 560 03f0 0C18A0E1 		mov	r1, ip, asl #16
 561              	.LVL45:
 562 03f4 2128A0E1 		mov	r2, r1, lsr #16
 563 03f8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 564              	.L36:
1608:../uvc.c      **** }
 565              		.loc 1 1608 0
 566 03fc 0CD08DE2 		add	sp, sp, #12
 567 0400 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 568              	.LVL46:
 569              	.L42:
1553:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 570              		.loc 1 1553 0
 571 0404 B420D2E1 		ldrh	r2, [r2, #4]
 572 0408 54319FE5 		ldr	r3, .L45+4
 573 040c 030052E1 		cmp	r2, r3
 574 0410 3500000A 		beq	.L43
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 575              		.loc 1 1573 0
 576 0414 006095E5 		ldr	r6, [r5, #0]
 577              	.LBB32:
 578              	.LBB34:
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 579              		.loc 1 1292 0
 580 0418 48719FE5 		ldr	r7, .L45+8
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 581              		.loc 1 1291 0
 582 041c 0010E0E3 		mvn	r1, #0
 583              	.LVL47:
 584              	.LBE34:
 585              	.LBE32:
1573:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 586              		.loc 1 1573 0
 587 0420 0C4046E2 		sub	r4, r6, #12
 588              	.LVL48:
 589              	.LBB36:
 590              	.LBB33:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 591              		.loc 1 1291 0
 592 0424 40019FE5 		ldr	r0, .L45+12
 593              	.LVL49:
 594 0428 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 595              		.loc 1 1292 0
 596 042c 0400A0E1 		mov	r0, r4
 597 0430 121D87E2 		add	r1, r7, #1152
 598 0434 0C20A0E3 		mov	r2, #12
 599 0438 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 600              		.loc 1 1293 0
 601 043c 28019FE5 		ldr	r0, .L45+12
 602 0440 FEFFFFEB 		bl	_txe_mutex_put
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 603              		.loc 1 1298 0
 604 0444 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 605              	.LBE33:
 606              	.LBE36:
1574:../uvc.c      ****                 pb++;
 607              		.loc 1 1574 0
 608 0448 10419FE5 		ldr	r4, .L45
 609              	.LVL50:
 610              	.LBB37:
 611              	.LBB35:
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 612              		.loc 1 1298 0
 613 044c 02108CE3 		orr	r1, ip, #2
 614 0450 0B1046E5 		strb	r1, [r6, #-11]
 615              	.LBE35:
 616              	.LBE37:
1574:../uvc.c      ****                 pb++;
 617              		.loc 1 1574 0
 618 0454 B603D4E1 		ldrh	r0, [r4, #54]
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 619              		.loc 1 1580 0
 620 0458 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
 621              		.loc 1 1575 0
 622 045c B410D5E1 		ldrh	r1, [r5, #4]
1574:../uvc.c      ****                 pb++;
 623              		.loc 1 1574 0
 624 0460 013080E2 		add	r3, r0, #1
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 625              		.loc 1 1580 0
 626 0464 0F0052E3 		cmp	r2, #15
1574:../uvc.c      ****                 pb++;
 627              		.loc 1 1574 0
 628 0468 B633C4E1 		strh	r3, [r4, #54]	@ movhi
1575:../uvc.c      ****                 pbc = input->buffer_p.count;
 629              		.loc 1 1575 0
 630 046c B813C4E1 		strh	r1, [r4, #56]	@ movhi
1580:../uvc.c      ****                 if(stiflag == 0x0F){
 631              		.loc 1 1580 0
 632 0470 2E00000A 		beq	.L44
 633              	.L40:
1587:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 634              		.loc 1 1587 0
 635 0474 01E0A0E3 		mov	lr, #1
 636 0478 3CE084E5 		str	lr, [r4, #60]
 637              	.LVL51:
 638              	.L39:
1591:../uvc.c      ****             prodCount++;
 639              		.loc 1 1591 0
 640 047c B0E4D4E1 		ldrh	lr, [r4, #64]
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 641              		.loc 1 1592 0
 642 0480 0C1081E2 		add	r1, r1, #12
1591:../uvc.c      ****             prodCount++;
 643              		.loc 1 1591 0
 644 0484 01308EE2 		add	r3, lr, #1
 645 0488 0308A0E1 		mov	r0, r3, asl #16
 646 048c 20C8A0E1 		mov	ip, r0, lsr #16
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 647              		.loc 1 1592 0
 648 0490 0128A0E1 		mov	r2, r1, asl #16
 649 0494 2218A0E1 		mov	r1, r2, lsr #16
 650 0498 D0009FE5 		ldr	r0, .L45+16
 651 049c 0020A0E3 		mov	r2, #0
1591:../uvc.c      ****             prodCount++;
 652              		.loc 1 1591 0
 653 04a0 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
1592:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 654              		.loc 1 1592 0
 655 04a4 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 656              	.LVL52:
1591:../uvc.c      ****             prodCount++;
 657              		.loc 1 1591 0
 658 04a8 B0109FE5 		ldr	r1, .L45
1595:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 659              		.loc 1 1595 0
 660 04ac 002050E2 		subs	r2, r0, #0
 661 04b0 D1FFFF0A 		beq	.L36
1597:../uvc.c      ****                 prodCount--;
 662              		.loc 1 1597 0
 663 04b4 B004D1E1 		ldrh	r0, [r1, #64]
 664              	.LVL53:
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 665              		.loc 1 1598 0
 666 04b8 B430D5E1 		ldrh	r3, [r5, #4]
1597:../uvc.c      ****                 prodCount--;
 667              		.loc 1 1597 0
 668 04bc 01E040E2 		sub	lr, r0, #1
 669 04c0 0EC8A0E1 		mov	ip, lr, asl #16
 670 04c4 2C08A0E1 		mov	r0, ip, lsr #16
 671 04c8 B004C1E1 		strh	r0, [r1, #64]	@ movhi
1598:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 672              		.loc 1 1598 0
 673 04cc B0E4D1E1 		ldrh	lr, [r1, #64]
 674 04d0 B2C4D1E1 		ldrh	ip, [r1, #66]
 675 04d4 0400A0E3 		mov	r0, #4
 676 04d8 94109FE5 		ldr	r1, .L45+20
 677 04dc 00E08DE5 		str	lr, [sp, #0]
 678 04e0 04C08DE5 		str	ip, [sp, #4]
 679 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL54:
 681 04e8 C3FFFFEA 		b	.L36
 682              	.LVL55:
 683              	.L43:
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 684              		.loc 1 1567 0
 685 04ec 006095E5 		ldr	r6, [r5, #0]
 686              	.LBB38:
 687              	.LBB39:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 688              		.loc 1 1291 0
 689 04f0 0010E0E3 		mvn	r1, #0
 690              	.LVL56:
 691              	.LBE39:
 692              	.LBE38:
1568:../uvc.c      ****                 fb++;
 693              		.loc 1 1568 0
 694 04f4 64409FE5 		ldr	r4, .L45
1567:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 695              		.loc 1 1567 0
 696 04f8 0C6046E2 		sub	r6, r6, #12
 697              	.LVL57:
 698              	.LBB41:
 699              	.LBB40:
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 700              		.loc 1 1291 0
 701 04fc 68009FE5 		ldr	r0, .L45+12
 702              	.LVL58:
 703 0500 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 704              		.loc 1 1292 0
 705 0504 6C109FE5 		ldr	r1, .L45+24
 706 0508 0600A0E1 		mov	r0, r6
 707 050c 0C20A0E3 		mov	r2, #12
 708 0510 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 709              		.loc 1 1293 0
 710 0514 50009FE5 		ldr	r0, .L45+12
 711 0518 FEFFFFEB 		bl	_txe_mutex_put
 712              	.LBE40:
 713              	.LBE41:
1568:../uvc.c      ****                 fb++;
 714              		.loc 1 1568 0
 715 051c B4C3D4E1 		ldrh	ip, [r4, #52]
 716 0520 B410D5E1 		ldrh	r1, [r5, #4]
 717 0524 01008CE2 		add	r0, ip, #1
 718 0528 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 719 052c D2FFFFEA 		b	.L39
 720              	.LVL59:
 721              	.L44:
1581:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 722              		.loc 1 1581 0
 723 0530 0010E0E3 		mvn	r1, #0
 724 0534 30009FE5 		ldr	r0, .L45+12
 725 0538 FEFFFFEB 		bl	_txe_mutex_get
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 726              		.loc 1 1582 0
 727 053c 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 728              		.loc 1 1583 0
 729 0540 24009FE5 		ldr	r0, .L45+12
1582:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 730              		.loc 1 1582 0
 731 0544 DF2001E2 		and	r2, r1, #223
 732 0548 8124C7E5 		strb	r2, [r7, #1153]
1583:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 733              		.loc 1 1583 0
 734 054c FEFFFFEB 		bl	_txe_mutex_put
1584:../uvc.c      ****                 	stiflag = 0xAA;
 735              		.loc 1 1584 0
 736 0550 5530E0E3 		mvn	r3, #85
 737 0554 3A30C4E5 		strb	r3, [r4, #58]
 738 0558 B410D5E1 		ldrh	r1, [r5, #4]
 739 055c C4FFFFEA 		b	.L40
 740              	.L46:
 741              		.align	2
 742              	.L45:
 743 0560 00000000 		.word	.LANCHOR0
 744 0564 F03F0000 		.word	16368
 745 0568 00000000 		.word	.LANCHOR1
 746 056c 00000000 		.word	imgHdMux
 747 0570 00000000 		.word	glChHandleUVCStream
 748 0574 9C000000 		.word	.LC5
 749 0578 80040000 		.word	.LANCHOR1+1152
 750              		.cfi_endproc
 751              	.LFE10:
 753              		.align	2
 755              	CyFxUVCApplnUSBSetupCB:
 756              	.LFB9:
1392:../uvc.c      **** {
 757              		.loc 1 1392 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 8
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL60:
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 762              		.loc 1 1397 0
 763 057c C0329FE5 		ldr	r3, .L72
1392:../uvc.c      **** {
 764              		.loc 1 1392 0
 765 0580 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 766              	.LCFI6:
 767              		.cfi_def_cfa_offset 24
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 768              		.loc 1 1398 0
 769 0584 BCC29FE5 		ldr	ip, .L72+4
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 770              		.loc 1 1397 0
 771 0588 FF4000E2 		and	r4, r0, #255
 772              		.cfi_offset 14, -4
 773              		.cfi_offset 8, -8
 774              		.cfi_offset 7, -12
 775              		.cfi_offset 6, -16
 776              		.cfi_offset 5, -20
 777              		.cfi_offset 4, -24
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 778              		.loc 1 1398 0
 779 058c FF8C00E2 		and	r8, r0, #65280
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 780              		.loc 1 1399 0
 781 0590 2078A0E1 		mov	r7, r0, lsr #16
1397:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 782              		.loc 1 1397 0
 783 0594 0040C3E5 		strb	r4, [r3, #0]
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 784              		.loc 1 1399 0
 785 0598 AC229FE5 		ldr	r2, .L72+8
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 786              		.loc 1 1400 0
 787 059c AC029FE5 		ldr	r0, .L72+12
 788              	.LVL61:
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 789              		.loc 1 1401 0
 790 05a0 AC329FE5 		ldr	r3, .L72+16
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 791              		.loc 1 1400 0
 792 05a4 0158A0E1 		mov	r5, r1, asl #16
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 793              		.loc 1 1398 0
 794 05a8 2884A0E1 		mov	r8, r8, lsr #8
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 795              		.loc 1 1400 0
 796 05ac 2558A0E1 		mov	r5, r5, lsr #16
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 797              		.loc 1 1401 0
 798 05b0 2118A0E1 		mov	r1, r1, lsr #16
 799              	.LVL62:
1404:../uvc.c      ****     switch (bmReqType)
 800              		.loc 1 1404 0
 801 05b4 020054E3 		cmp	r4, #2
1392:../uvc.c      **** {
 802              		.loc 1 1392 0
 803 05b8 10D04DE2 		sub	sp, sp, #16
 804              	.LCFI7:
 805              		.cfi_def_cfa_offset 40
1398:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 806              		.loc 1 1398 0
 807 05bc 0080CCE5 		strb	r8, [ip, #0]
1399:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 808              		.loc 1 1399 0
 809 05c0 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1400:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 810              		.loc 1 1400 0
 811 05c4 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1401:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 812              		.loc 1 1401 0
 813 05c8 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1404:../uvc.c      ****     switch (bmReqType)
 814              		.loc 1 1404 0
 815 05cc 4F00000A 		beq	.L50
 816 05d0 0600009A 		bls	.L68
 817 05d4 210054E3 		cmp	r4, #33
 818 05d8 3A00000A 		beq	.L51
 819 05dc A10054E3 		cmp	r4, #161
 820 05e0 3800000A 		beq	.L51
 821              	.L65:
1393:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 822              		.loc 1 1393 0
 823 05e4 0000A0E3 		mov	r0, #0
 824              	.LVL63:
 825              	.L48:
1531:../uvc.c      **** }
 826              		.loc 1 1531 0
 827 05e8 10D08DE2 		add	sp, sp, #16
 828 05ec F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 829              	.LVL64:
 830              	.L68:
1404:../uvc.c      ****     switch (bmReqType)
 831              		.loc 1 1404 0
 832 05f0 010054E3 		cmp	r4, #1
 833 05f4 FAFFFF1A 		bne	.L65
1444:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 834              		.loc 1 1444 0
 835 05f8 0B0058E3 		cmp	r8, #11
 836 05fc F8FFFF1A 		bne	.L65
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 837              		.loc 1 1448 0
 838 0600 010055E3 		cmp	r5, #1
 839 0604 F6FFFF1A 		bne	.L65
1448:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 840              		.loc 1 1448 0 is_stmt 0 discriminator 1
 841 0608 000057E3 		cmp	r7, #0
 842 060c F4FFFF1A 		bne	.L65
1453:../uvc.c      ****                     gpif_initialized = 0;
 843              		.loc 1 1453 0 is_stmt 1
 844 0610 40429FE5 		ldr	r4, .L72+20
1451:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 845              		.loc 1 1451 0
 846 0614 40129FE5 		ldr	r1, .L72+24
 847 0618 0400A0E3 		mov	r0, #4
 848 061c FEFFFFEB 		bl	CyU3PDebugPrint
1452:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 849              		.loc 1 1452 0
 850 0620 0500A0E1 		mov	r0, r5
 851 0624 FEFFFFEB 		bl	CyU3PGpifDisable
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 852              		.loc 1 1456 0
 853 0628 0510A0E1 		mov	r1, r5
 854 062c 8300A0E3 		mov	r0, #131
1453:../uvc.c      ****                     gpif_initialized = 0;
 855              		.loc 1 1453 0
 856 0630 287084E5 		str	r7, [r4, #40]
1454:../uvc.c      ****                     streamingStarted = CyFalse;
 857              		.loc 1 1454 0
 858 0634 2C7084E5 		str	r7, [r4, #44]
1456:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 859              		.loc 1 1456 0
 860 0638 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1457:../uvc.c      ****                     CyU3PBusyWait (100);
 861              		.loc 1 1457 0
 862 063c 6400A0E3 		mov	r0, #100
 863 0640 FEFFFFEB 		bl	CyU3PBusyWait
1460:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 864              		.loc 1 1460 0
 865 0644 14029FE5 		ldr	r0, .L72+28
 866 0648 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1461:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 867              		.loc 1 1461 0
 868 064c 8300A0E3 		mov	r0, #131
 869 0650 FEFFFFEB 		bl	CyU3PUsbFlushEp
1462:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 870              		.loc 1 1462 0
 871 0654 0710A0E1 		mov	r1, r7
 872 0658 8300A0E3 		mov	r0, #131
 873 065c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1463:../uvc.c      ****                     CyU3PBusyWait (100);
 874              		.loc 1 1463 0
 875 0660 6400A0E3 		mov	r0, #100
 876 0664 FEFFFFEB 		bl	CyU3PBusyWait
1466:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 877              		.loc 1 1466 0
 878 0668 0710A0E1 		mov	r1, r7
 879 066c 0520A0E1 		mov	r2, r5
 880 0670 8300A0E3 		mov	r0, #131
 881 0674 FEFFFFEB 		bl	CyU3PUsbStall
 882              	.LVL65:
1469:../uvc.c      ****                     CyU3PUsbAckSetup ();
 883              		.loc 1 1469 0
 884 0678 FEFFFFEB 		bl	CyU3PUsbAckSetup
1471:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 885              		.loc 1 1471 0
 886 067c 445084E5 		str	r5, [r4, #68]
 887              	.LBB46:
 888              	.LBB47:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 889              		.loc 1 1331 0
 890 0680 0400A0E1 		mov	r0, r4
 891 0684 0510A0E1 		mov	r1, r5
 892 0688 0220A0E3 		mov	r2, #2
 893 068c 0C308DE2 		add	r3, sp, #12
 894 0690 00708DE5 		str	r7, [sp, #0]
 895 0694 FEFFFFEB 		bl	_txe_event_flags_get
 896 0698 006050E2 		subs	r6, r0, #0
 897 069c 2E00001A 		bne	.L63
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 898              		.loc 1 1334 0
 899 06a0 0110E0E3 		mvn	r1, #1
 900 06a4 0220A0E3 		mov	r2, #2
 901 06a8 0400A0E1 		mov	r0, r4
 902 06ac FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 903              		.loc 1 1337 0
 904 06b0 0400A0E1 		mov	r0, r4
 905 06b4 0210A0E3 		mov	r1, #2
 906 06b8 0620A0E1 		mov	r2, r6
 907 06bc FEFFFFEB 		bl	_txe_event_flags_set
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
 908              		.loc 1 1467 0
 909 06c0 0500A0E1 		mov	r0, r5
 910 06c4 C7FFFFEA 		b	.L48
 911              	.LVL66:
 912              	.L51:
 913              	.LBE47:
 914              	.LBE46:
1409:../uvc.c      ****             switch (wIndex & 0xFF)
 915              		.loc 1 1409 0
 916 06c8 FF5015E2 		ands	r5, r5, #255
 917 06cc 1A00001A 		bne	.L69
 918              	.LVL67:
1414:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 919              		.loc 1 1414 0
 920 06d0 0520A0E1 		mov	r2, r5
 921 06d4 7C019FE5 		ldr	r0, .L72+20
 922 06d8 0410A0E3 		mov	r1, #4
 923 06dc FEFFFFEB 		bl	_txe_event_flags_set
 924              	.LVL68:
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 925              		.loc 1 1416 0
 926 06e0 002050E2 		subs	r2, r0, #0
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
 927              		.loc 1 1413 0
 928 06e4 0100A003 		moveq	r0, #1
 929              	.LVL69:
1416:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 930              		.loc 1 1416 0
 931 06e8 BEFFFF0A 		beq	.L48
1418:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 932              		.loc 1 1418 0
 933 06ec 70119FE5 		ldr	r1, .L72+32
 934 06f0 0400A0E3 		mov	r0, #4
 935 06f4 FEFFFFEB 		bl	CyU3PDebugPrint
 936              	.LVL70:
1419:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 937              		.loc 1 1419 0
 938 06f8 0500A0E1 		mov	r0, r5
 939 06fc 0110A0E3 		mov	r1, #1
 940 0700 0520A0E1 		mov	r2, r5
 941 0704 FEFFFFEB 		bl	CyU3PUsbStall
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
 942              		.loc 1 1413 0
 943 0708 0100A0E3 		mov	r0, #1
 944 070c B5FFFFEA 		b	.L48
 945              	.LVL71:
 946              	.L50:
1479:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 947              		.loc 1 1479 0
 948 0710 010058E3 		cmp	r8, #1
 949 0714 B2FFFF1A 		bne	.L65
1481:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 950              		.loc 1 1481 0
 951 0718 830055E3 		cmp	r5, #131
 952 071c B0FFFF1A 		bne	.L65
1487:../uvc.c      ****                     if (streamingStarted == CyTrue)
 953              		.loc 1 1487 0
 954 0720 30719FE5 		ldr	r7, .L72+20
 955 0724 2C6097E5 		ldr	r6, [r7, #44]
 956 0728 010056E3 		cmp	r6, #1
 957 072c 1500000A 		beq	.L70
 958              	.LVL72:
1519:../uvc.c      ****                         CyU3PUsbAckSetup ();
 959              		.loc 1 1519 0
 960 0730 FEFFFFEB 		bl	CyU3PUsbAckSetup
1518:../uvc.c      ****                         uvcHandleReq = CyTrue;
 961              		.loc 1 1518 0
 962 0734 0800A0E1 		mov	r0, r8
 963 0738 AAFFFFEA 		b	.L48
 964              	.LVL73:
 965              	.L69:
1409:../uvc.c      ****             switch (wIndex & 0xFF)
 966              		.loc 1 1409 0
 967 073c 010055E3 		cmp	r5, #1
 968 0740 A7FFFF1A 		bne	.L65
 969              	.LVL74:
1427:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 970              		.loc 1 1427 0
 971 0744 0020A0E3 		mov	r2, #0
 972 0748 08019FE5 		ldr	r0, .L72+20
 973 074c 0810A0E3 		mov	r1, #8
 974 0750 FEFFFFEB 		bl	_txe_event_flags_set
 975              	.LVL75:
1429:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 976              		.loc 1 1429 0
 977 0754 002050E2 		subs	r2, r0, #0
 978 0758 0100001A 		bne	.L71
 979              	.LVL76:
 980              	.L63:
 981              	.LBB49:
 982              	.LBB48:
1467:../uvc.c      ****                     uvcHandleReq = CyTrue;
 983              		.loc 1 1467 0
 984 075c 0500A0E1 		mov	r0, r5
 985 0760 A0FFFFEA 		b	.L48
 986              	.LVL77:
 987              	.L71:
 988              	.LBE48:
 989              	.LBE49:
1432:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 990              		.loc 1 1432 0
 991 0764 FC109FE5 		ldr	r1, .L72+36
 992 0768 0400A0E3 		mov	r0, #4
 993              	.LVL78:
 994 076c FEFFFFEB 		bl	CyU3PDebugPrint
 995              	.LVL79:
1433:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 996              		.loc 1 1433 0
 997 0770 0000A0E3 		mov	r0, #0
 998 0774 0510A0E1 		mov	r1, r5
 999 0778 0020A0E1 		mov	r2, r0
 1000 077c FEFFFFEB 		bl	CyU3PUsbStall
1426:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1001              		.loc 1 1426 0
 1002 0780 0500A0E1 		mov	r0, r5
 1003 0784 97FFFFEA 		b	.L48
 1004              	.LVL80:
 1005              	.L70:
1489:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1006              		.loc 1 1489 0
 1007 0788 DC109FE5 		ldr	r1, .L72+40
 1008 078c 0400A0E3 		mov	r0, #4
 1009 0790 FEFFFFEB 		bl	CyU3PDebugPrint
1493:../uvc.c      ****                         gpif_initialized = 0;
 1010              		.loc 1 1493 0
 1011 0794 0080A0E3 		mov	r8, #0
1492:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1012              		.loc 1 1492 0
 1013 0798 0600A0E1 		mov	r0, r6
 1014 079c FEFFFFEB 		bl	CyU3PGpifDisable
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1015              		.loc 1 1497 0
 1016 07a0 0610A0E1 		mov	r1, r6
 1017 07a4 0500A0E1 		mov	r0, r5
1493:../uvc.c      ****                         gpif_initialized = 0;
 1018              		.loc 1 1493 0
 1019 07a8 288087E5 		str	r8, [r7, #40]
1494:../uvc.c      ****                         streamingStarted = CyFalse;
 1020              		.loc 1 1494 0
 1021 07ac 2C8087E5 		str	r8, [r7, #44]
1497:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1022              		.loc 1 1497 0
 1023 07b0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1498:../uvc.c      ****                         CyU3PBusyWait (100);
 1024              		.loc 1 1498 0
 1025 07b4 6400A0E3 		mov	r0, #100
 1026 07b8 FEFFFFEB 		bl	CyU3PBusyWait
1501:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1027              		.loc 1 1501 0
 1028 07bc 9C009FE5 		ldr	r0, .L72+28
 1029 07c0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1502:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1030              		.loc 1 1502 0
 1031 07c4 0500A0E1 		mov	r0, r5
 1032 07c8 FEFFFFEB 		bl	CyU3PUsbFlushEp
1503:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1033              		.loc 1 1503 0
 1034 07cc 0810A0E1 		mov	r1, r8
 1035 07d0 0500A0E1 		mov	r0, r5
 1036 07d4 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1504:../uvc.c      ****                         CyU3PBusyWait (100);
 1037              		.loc 1 1504 0
 1038 07d8 6400A0E3 		mov	r0, #100
 1039 07dc FEFFFFEB 		bl	CyU3PBusyWait
1507:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1040              		.loc 1 1507 0
 1041 07e0 0810A0E1 		mov	r1, r8
 1042 07e4 0620A0E1 		mov	r2, r6
 1043 07e8 0500A0E1 		mov	r0, r5
 1044 07ec FEFFFFEB 		bl	CyU3PUsbStall
 1045              	.LVL81:
1511:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 1511 0
 1047 07f0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1513:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1048              		.loc 1 1513 0
 1049 07f4 446087E5 		str	r6, [r7, #68]
 1050              	.LBB50:
 1051              	.LBB51:
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1052              		.loc 1 1331 0
 1053 07f8 0700A0E1 		mov	r0, r7
 1054 07fc 0610A0E1 		mov	r1, r6
 1055 0800 0420A0E1 		mov	r2, r4
 1056 0804 0C308DE2 		add	r3, sp, #12
 1057 0808 00808DE5 		str	r8, [sp, #0]
 1058 080c FEFFFFEB 		bl	_txe_event_flags_get
 1059 0810 005050E2 		subs	r5, r0, #0
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1060              		.loc 1 1509 0
 1061 0814 0600A011 		movne	r0, r6
1331:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1062              		.loc 1 1331 0
 1063 0818 72FFFF1A 		bne	.L48
1334:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1064              		.loc 1 1334 0
 1065 081c 0110E0E3 		mvn	r1, #1
 1066 0820 0420A0E1 		mov	r2, r4
 1067 0824 0700A0E1 		mov	r0, r7
 1068 0828 FEFFFFEB 		bl	_txe_event_flags_set
1337:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1069              		.loc 1 1337 0
 1070 082c 0700A0E1 		mov	r0, r7
 1071 0830 0410A0E1 		mov	r1, r4
 1072 0834 0520A0E1 		mov	r2, r5
 1073 0838 FEFFFFEB 		bl	_txe_event_flags_set
1509:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1074              		.loc 1 1509 0
 1075 083c 0600A0E1 		mov	r0, r6
 1076 0840 68FFFFEA 		b	.L48
 1077              	.L73:
 1078              		.align	2
 1079              	.L72:
 1080 0844 00000000 		.word	bmReqType
 1081 0848 00000000 		.word	bRequest
 1082 084c 00000000 		.word	wValue
 1083 0850 00000000 		.word	wIndex
 1084 0854 00000000 		.word	wLength
 1085 0858 00000000 		.word	.LANCHOR0
 1086 085c 54010000 		.word	.LC8
 1087 0860 00000000 		.word	glChHandleUVCStream
 1088 0864 E8000000 		.word	.LC6
 1089 0868 20010000 		.word	.LC7
 1090 086c 6C010000 		.word	.LC9
 1091              	.LBE51:
 1092              	.LBE50:
 1093              		.cfi_endproc
 1094              	.LFE9:
 1096              		.align	2
 1097              		.global	CyFxGpifCB
 1099              	CyFxGpifCB:
 1100              	.LFB12:
1730:../uvc.c      **** {
 1101              		.loc 1 1730 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL82:
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1106              		.loc 1 1731 0
 1107 0870 010050E3 		cmp	r0, #1
1730:../uvc.c      **** {
 1108              		.loc 1 1730 0
 1109 0874 10402DE9 		stmfd	sp!, {r4, lr}
 1110              	.LCFI8:
 1111              		.cfi_def_cfa_offset 8
1730:../uvc.c      **** {
 1112              		.loc 1 1730 0
 1113 0878 0120A0E1 		mov	r2, r1
1731:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1114              		.loc 1 1731 0
 1115 087c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1116              		.cfi_offset 14, -4
 1117              		.cfi_offset 4, -8
 1118              	.LVL83:
 1119              	.LBB56:
 1120              	.LBB57:
1628:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1121              		.loc 1 1628 0
 1122 0880 CC309FE5 		ldr	r3, .L89
 1123 0884 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1124 0888 030053E3 		cmp	r3, #3
 1125 088c 2100000A 		beq	.L88
1654:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1126              		.loc 1 1654 0
 1127 0890 020053E3 		cmp	r3, #2
 1128 0894 1080BD18 		ldmnefd	sp!, {r4, pc}
1656:../uvc.c      ****         switch (stateId)
 1129              		.loc 1 1656 0
 1130 0898 080041E2 		sub	r0, r1, #8
 1131              	.LVL84:
 1132 089c 0A0050E3 		cmp	r0, #10
 1133 08a0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1134 08a4 230000EA 		b	.L81
 1135              	.L83:
 1136 08a8 D8080000 		.word	.L78
 1137 08ac 38090000 		.word	.L81
 1138 08b0 38090000 		.word	.L81
 1139 08b4 D4080000 		.word	.L74
 1140 08b8 38090000 		.word	.L81
 1141 08bc 38090000 		.word	.L81
 1142 08c0 38090000 		.word	.L81
 1143 08c4 10090000 		.word	.L87
 1144 08c8 38090000 		.word	.L81
 1145 08cc 38090000 		.word	.L81
 1146 08d0 D4080000 		.word	.L74
 1147              	.LVL85:
 1148              	.L74:
 1149 08d4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1150              	.LVL86:
 1151              	.L78:
1639:../uvc.c      ****                 socket = 0;
 1152              		.loc 1 1639 0
 1153 08d8 0010A0E3 		mov	r1, #0
 1154              	.LVL87:
 1155              	.L79:
1713:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1156              		.loc 1 1713 0
 1157 08dc 74009FE5 		ldr	r0, .L89+4
 1158 08e0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1159              	.LVL88:
1714:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1160              		.loc 1 1714 0
 1161 08e4 002050E2 		subs	r2, r0, #0
 1162 08e8 F9FFFF0A 		beq	.L74
1716:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1163              		.loc 1 1716 0
 1164 08ec 0400A0E3 		mov	r0, #4
 1165              	.LVL89:
 1166 08f0 64109FE5 		ldr	r1, .L89+8
 1167 08f4 FEFFFFEB 		bl	CyU3PDebugPrint
 1168              	.LVL90:
 1169              	.L84:
 1170              	.LBB58:
 1171              	.LBB59:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1172              		.loc 1 1318 0
 1173 08f8 60109FE5 		ldr	r1, .L89+12
 1174 08fc 0400A0E3 		mov	r0, #4
 1175 0900 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 1176              		.loc 1 1319 0
 1177 0904 FA0FA0E3 		mov	r0, #1000
 1178 0908 FEFFFFEB 		bl	_tx_thread_sleep
 1179 090c F9FFFFEA 		b	.L84
 1180              	.LVL91:
 1181              	.L87:
 1182              	.LBE59:
 1183              	.LBE58:
1683:../uvc.c      ****                 socket = 1;
 1184              		.loc 1 1683 0
 1185 0910 0110A0E3 		mov	r1, #1
 1186              	.LVL92:
 1187 0914 F0FFFFEA 		b	.L79
 1188              	.LVL93:
 1189              	.L88:
1630:../uvc.c      ****         switch (stateId)
 1190              		.loc 1 1630 0
 1191 0918 0B2041E2 		sub	r2, r1, #11
 1192 091c 030052E3 		cmp	r2, #3
 1193 0920 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1194 0924 060000EA 		b	.L77
 1195              	.L80:
 1196 0928 D8080000 		.word	.L78
 1197 092c 10090000 		.word	.L87
 1198 0930 D4080000 		.word	.L74
 1199 0934 D4080000 		.word	.L74
 1200              	.LVL94:
 1201              	.L81:
1702:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1202              		.loc 1 1702 0
 1203 0938 24109FE5 		ldr	r1, .L89+16
 1204              	.LVL95:
 1205 093c 0100A0E3 		mov	r0, #1
 1206 0940 FEFFFFEB 		bl	CyU3PDebugPrint
 1207              	.LVL96:
 1208              	.L77:
 1209              	.LBE57:
 1210              	.LBE56:
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1211              		.loc 1 1737 0
 1212 0944 1C109FE5 		ldr	r1, .L89+20
 1213 0948 0400A0E3 		mov	r0, #4
1740:../uvc.c      **** }
 1214              		.loc 1 1740 0
 1215 094c 1040BDE8 		ldmfd	sp!, {r4, lr}
1737:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1216              		.loc 1 1737 0
 1217 0950 FEFFFFEA 		b	CyU3PDebugPrint
 1218              	.L90:
 1219              		.align	2
 1220              	.L89:
 1221 0954 00000000 		.word	.LANCHOR0
 1222 0958 00000000 		.word	glChHandleUVCStream
 1223 095c A8010000 		.word	.LC11
 1224 0960 D8010000 		.word	.LC12
 1225 0964 90010000 		.word	.LC10
 1226 0968 EC010000 		.word	.LC13
 1227              		.cfi_endproc
 1228              	.LFE12:
 1230              		.align	2
 1231              		.global	I2CCmdHandler
 1233              	I2CCmdHandler:
 1234              	.LFB0:
 336:../uvc.c      **** void I2CCmdHandler(){
 1235              		.loc 1 336 0
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 8
 1238              		@ frame_needed = 0, uses_anonymous_args = 0
 1239 096c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1240              	.LCFI9:
 1241              		.cfi_def_cfa_offset 36
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1242              		.loc 1 339 0
 1243 0970 FC419FE5 		ldr	r4, .L104
 1244              		.cfi_offset 14, -4
 1245              		.cfi_offset 11, -8
 1246              		.cfi_offset 10, -12
 1247              		.cfi_offset 9, -16
 1248              		.cfi_offset 8, -20
 1249              		.cfi_offset 7, -24
 1250              		.cfi_offset 6, -28
 1251              		.cfi_offset 5, -32
 1252              		.cfi_offset 4, -36
 336:../uvc.c      **** void I2CCmdHandler(){
 1253              		.loc 1 336 0
 1254 0974 34D04DE2 		sub	sp, sp, #52
 1255              	.LCFI10:
 1256              		.cfi_def_cfa_offset 88
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1257              		.loc 1 344 0
 1258 0978 5410D4E5 		ldrb	r1, [r4, #84]	@ zero_extendqisi2
 339:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1259              		.loc 1 339 0
 1260 097c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1261              	.LVL97:
 340:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1262              		.loc 1 340 0
 1263 0980 4D60D4E5 		ldrb	r6, [r4, #77]	@ zero_extendqisi2
 1264              	.LVL98:
 344:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1265              		.loc 1 344 0
 1266 0984 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1267 0988 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1268 098c 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1269 0990 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1270 0994 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1271 0998 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1272 099c 18108DE5 		str	r1, [sp, #24]
 1273 09a0 5530D4E5 		ldrb	r3, [r4, #85]	@ zero_extendqisi2
 1274 09a4 0400A0E3 		mov	r0, #4
 1275 09a8 1C308DE5 		str	r3, [sp, #28]
 1276 09ac 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1277 09b0 0630A0E1 		mov	r3, r6
 1278 09b4 BC119FE5 		ldr	r1, .L104+4
 1279 09b8 0520A0E1 		mov	r2, r5
 1280 09bc 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1281 09c0 08808DE5 		str	r8, [sp, #8]
 1282 09c4 0CA08DE5 		str	sl, [sp, #12]
 1283 09c8 10908DE5 		str	r9, [sp, #16]
 1284 09cc 14B08DE5 		str	fp, [sp, #20]
 1285 09d0 20C08DE5 		str	ip, [sp, #32]
 1286 09d4 FEFFFFEB 		bl	CyU3PDebugPrint
 1287              	.LVL99:
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1288              		.loc 1 347 0
 1289 09d8 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1290 09dc 520053E3 		cmp	r3, #82
 1291 09e0 1A00000A 		beq	.L101
 1292              	.L92:
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1293              		.loc 1 357 0
 1294 09e4 000055E3 		cmp	r5, #0
 384:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1295              		.loc 1 384 0
 1296 09e8 0030E003 		mvneq	r3, #0
 1297 09ec 5730C405 		streqb	r3, [r4, #87]
 357:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1298              		.loc 1 357 0
 1299 09f0 0100000A 		beq	.L91
 388:../uvc.c      **** 	}else if(CmdType == 1){
 1300              		.loc 1 388 0
 1301 09f4 010055E3 		cmp	r5, #1
 1302 09f8 0100000A 		beq	.L102
 1303              	.LVL100:
 1304              	.L91:
 407:../uvc.c      **** }
 1305              		.loc 1 407 0
 1306 09fc 34D08DE2 		add	sp, sp, #52
 1307 0a00 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1308              	.LVL101:
 1309              	.L102:
 390:../uvc.c      **** 			if(CmdRegLen == 2){
 1310              		.loc 1 390 0
 1311 0a04 020056E3 		cmp	r6, #2
 1312 0a08 2300000A 		beq	.L103
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1313              		.loc 1 395 0
 1314 0a0c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1315 0a10 5C319FE5 		ldr	r3, .L104
 1316 0a14 FE1001E2 		and	r1, r1, #254
 1317 0a18 820051E3 		cmp	r1, #130
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1318              		.loc 1 398 0
 1319 0a1c 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1320              	.LVL102:
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1321              		.loc 1 395 0
 1322 0a20 0200001A 		bne	.L100
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1323              		.loc 1 395 0 is_stmt 0 discriminator 1
 1324 0a24 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1325 0a28 300055E3 		cmp	r5, #48
 1326 0a2c 3B00000A 		beq	.L98
 1327              	.L100:
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1328              		.loc 1 398 0 is_stmt 1
 1329 0a30 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1330              	.L99:
 400:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1331              		.loc 1 400 0
 1332 0a34 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1333 0a38 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1334 0a3c FE0002E2 		and	r0, r2, #254
 1335 0a40 0520A0E1 		mov	r2, r5
 1336 0a44 00E08DE5 		str	lr, [sp, #0]
 1337 0a48 FEFFFFEB 		bl	SensorWrite2B
 1338 0a4c EAFFFFEA 		b	.L91
 1339              	.LVL103:
 1340              	.L101:
 347:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1341              		.loc 1 347 0 discriminator 1
 1342 0a50 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1343 0a54 300053E3 		cmp	r3, #48
 1344 0a58 E1FFFF1A 		bne	.L92
 1345 0a5c 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1346 0a60 010053E3 		cmp	r3, #1
 1347 0a64 DEFFFF1A 		bne	.L92
 349:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1348              		.loc 1 349 0
 1349 0a68 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1350 0a6c 08019FE5 		ldr	r0, .L104+8
 1351 0a70 03E002E2 		and	lr, r2, #3
 1352 0a74 8CE4C0E5 		strb	lr, [r0, #1164]
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 1353              		.loc 1 350 0
 1354 0a78 58C094E5 		ldr	ip, [r4, #88]
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1355              		.loc 1 354 0
 1356 0a7c FC109FE5 		ldr	r1, .L104+12
 350:../uvc.c      **** 		if(is60Hz==CyFalse)
 1357              		.loc 1 350 0
 1358 0a80 00005CE3 		cmp	ip, #0
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1359              		.loc 1 352 0
 1360 0a84 80208203 		orreq	r2, r2, #128
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1361              		.loc 1 354 0
 1362 0a88 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 352:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1363              		.loc 1 352 0
 1364 0a8c 5520C405 		streqb	r2, [r4, #85]
 354:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1365              		.loc 1 354 0
 1366 0a90 0400A0E3 		mov	r0, #4
 1367 0a94 FEFFFFEB 		bl	CyU3PDebugPrint
 1368 0a98 D1FFFFEA 		b	.L92
 1369              	.L103:
 392:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1370              		.loc 1 392 0
 1371 0a9c 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1372 0aa0 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1373 0aa4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1374 0aa8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1375 0aac 0020A0E3 		mov	r2, #0
 1376 0ab0 FE0000E2 		and	r0, r0, #254
 1377 0ab4 00E08DE5 		str	lr, [sp, #0]
 1378 0ab8 FEFFFFEB 		bl	SensorWrite2B2
 1379 0abc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1380 0ac0 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1381 0ac4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1382 0ac8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1383 0acc FE0002E2 		and	r0, r2, #254
 1384 0ad0 0020A0E3 		mov	r2, #0
 1385 0ad4 00C08DE5 		str	ip, [sp, #0]
 1386 0ad8 FEFFFFEB 		bl	SensorWrite2B2
 1387              	.LVL104:
 1388 0adc 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1389 0ae0 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1390 0ae4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1391 0ae8 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1392 0aec 0020A0E3 		mov	r2, #0
 1393 0af0 FE0000E2 		and	r0, r0, #254
 1394 0af4 00C08DE5 		str	ip, [sp, #0]
 1395 0af8 FEFFFFEB 		bl	SensorWrite2B2
 1396 0afc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1397 0b00 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1398 0b04 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1399 0b08 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1400 0b0c FE0002E2 		and	r0, r2, #254
 1401 0b10 0020A0E3 		mov	r2, #0
 1402 0b14 00C08DE5 		str	ip, [sp, #0]
 1403 0b18 FEFFFFEB 		bl	SensorWrite2B2
 1404 0b1c B6FFFFEA 		b	.L91
 1405              	.LVL105:
 1406              	.L98:
 395:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1407              		.loc 1 395 0 discriminator 1
 1408 0b20 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1409 0b24 100053E3 		cmp	r3, #16
 1410 0b28 C1FFFF1A 		bne	.L99
 396:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1411              		.loc 1 396 0
 1412 0b2c 50409FE5 		ldr	r4, .L104+16
 1413 0b30 0010E0E3 		mvn	r1, #0
 1414 0b34 1C0094E5 		ldr	r0, [r4, #28]
 1415 0b38 2C308DE5 		str	r3, [sp, #44]
 1416 0b3c FEFFFFEB 		bl	_txe_mutex_get
 397:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1417              		.loc 1 397 0
 1418 0b40 2C309DE5 		ldr	r3, [sp, #44]
 1419 0b44 00C0A0E3 		mov	ip, #0
 1420 0b48 0320A0E1 		mov	r2, r3
 1421 0b4c 0400A0E1 		mov	r0, r4
 1422 0b50 1710A0E3 		mov	r1, #23
 1423 0b54 0530A0E1 		mov	r3, r5
 1424 0b58 00C08DE5 		str	ip, [sp, #0]
 1425 0b5c 04C08DE5 		str	ip, [sp, #4]
 1426 0b60 FEFFFFEB 		bl	cmdSet
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1427              		.loc 1 398 0
 1428 0b64 1C0094E5 		ldr	r0, [r4, #28]
 407:../uvc.c      **** }
 1429              		.loc 1 407 0
 1430 0b68 34D08DE2 		add	sp, sp, #52
 1431 0b6c F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 398:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1432              		.loc 1 398 0
 1433 0b70 FEFFFFEA 		b	_txe_mutex_put
 1434              	.L105:
 1435              		.align	2
 1436              	.L104:
 1437 0b74 00000000 		.word	.LANCHOR0
 1438 0b78 04020000 		.word	.LC14
 1439 0b7c 00000000 		.word	.LANCHOR1
 1440 0b80 50020000 		.word	.LC15
 1441 0b84 00000000 		.word	cmdQu
 1442              		.cfi_endproc
 1443              	.LFE0:
 1445              		.align	2
 1446              		.global	setIrisauto
 1448              	setIrisauto:
 1449              	.LFB1:
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1450              		.loc 1 413 0
 1451              		.cfi_startproc
 1452              		@ args = 0, pretend = 0, frame = 0
 1453              		@ frame_needed = 0, uses_anonymous_args = 0
 1454              	.LVL106:
 1455 0b88 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1456              	.LCFI11:
 1457              		.cfi_def_cfa_offset 16
 1458 0b8c 0160A0E1 		mov	r6, r1
 1459              		.cfi_offset 14, -4
 1460              		.cfi_offset 6, -8
 1461              		.cfi_offset 5, -12
 1462              		.cfi_offset 4, -16
 1463 0b90 08D04DE2 		sub	sp, sp, #8
 1464              	.LCFI12:
 1465              		.cfi_def_cfa_offset 24
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1466              		.loc 1 417 0
 1467 0b94 0050A0E3 		mov	r5, #0
 413:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1468              		.loc 1 413 0
 1469 0b98 0040A0E1 		mov	r4, r0
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1470              		.loc 1 416 0
 1471 0b9c 0010E0E3 		mvn	r1, #0
 1472              	.LVL107:
 1473 0ba0 1C0090E5 		ldr	r0, [r0, #28]
 1474              	.LVL108:
 1475 0ba4 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1476              		.loc 1 417 0
 1477 0ba8 060065E0 		rsb	r0, r5, r6
 1478 0bac 00C070E2 		rsbs	ip, r0, #0
 1479 0bb0 00C0ACE0 		adc	ip, ip, r0
 1480 0bb4 1410A0E3 		mov	r1, #20
 1481 0bb8 2720A0E3 		mov	r2, #39
 1482 0bbc 3030A0E3 		mov	r3, #48
 1483 0bc0 0400A0E1 		mov	r0, r4
 1484 0bc4 00C08DE5 		str	ip, [sp, #0]
 1485 0bc8 04508DE5 		str	r5, [sp, #4]
 1486 0bcc FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1487              		.loc 1 418 0
 1488 0bd0 050056E1 		cmp	r6, r5
 1489 0bd4 0260A003 		moveq	r6, #2
 1490 0bd8 0560A011 		movne	r6, r5
 1491 0bdc 0400A0E1 		mov	r0, r4
 1492 0be0 1510A0E3 		mov	r1, #21
 1493 0be4 2520A0E3 		mov	r2, #37
 1494 0be8 3030A0E3 		mov	r3, #48
 1495 0bec 00608DE5 		str	r6, [sp, #0]
 1496 0bf0 04508DE5 		str	r5, [sp, #4]
 1497 0bf4 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1498              		.loc 1 419 0
 1499 0bf8 1C0094E5 		ldr	r0, [r4, #28]
 420:../uvc.c      **** }
 1500              		.loc 1 420 0
 1501 0bfc 08D08DE2 		add	sp, sp, #8
 1502 0c00 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1503              		.loc 1 419 0
 1504 0c04 FEFFFFEA 		b	_txe_mutex_put
 1505              		.cfi_endproc
 1506              	.LFE1:
 1508              		.align	2
 1509              		.global	ControlHandle
 1511              	ControlHandle:
 1512              	.LFB2:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1513              		.loc 1 422 0
 1514              		.cfi_startproc
 1515              		@ args = 0, pretend = 0, frame = 24
 1516              		@ frame_needed = 0, uses_anonymous_args = 0
 1517              	.LVL109:
 1518 0c08 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1519              	.LCFI13:
 1520              		.cfi_def_cfa_offset 36
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1521              		.loc 1 429 0
 1522 0c0c 1F0050E3 		cmp	r0, #31
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1523              		.loc 1 428 0
 1524 0c10 207040E2 		sub	r7, r0, #32
 1525              		.cfi_offset 14, -4
 1526              		.cfi_offset 11, -8
 1527              		.cfi_offset 10, -12
 1528              		.cfi_offset 9, -16
 1529              		.cfi_offset 8, -20
 1530              		.cfi_offset 7, -24
 1531              		.cfi_offset 6, -28
 1532              		.cfi_offset 5, -32
 1533              		.cfi_offset 4, -36
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1534              		.loc 1 422 0
 1535 0c14 2CD04DE2 		sub	sp, sp, #44
 1536              	.LCFI14:
 1537              		.cfi_def_cfa_offset 80
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1538              		.loc 1 422 0
 1539 0c18 0040A0E1 		mov	r4, r0
 428:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1540              		.loc 1 428 0
 1541 0c1c FF7007E2 		and	r7, r7, #255
 1542              	.LVL110:
 429:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1543              		.loc 1 429 0
 1544 0c20 2300009A 		bls	.L110
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1545              		.loc 1 430 0
 1546 0c24 E46E9FE5 		ldr	r6, .L228
 1547 0c28 872087E0 		add	r2, r7, r7, asl #1
 1548 0c2c 8221A0E1 		mov	r2, r2, asl #3
 1549 0c30 023086E0 		add	r3, r6, r2
 431:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1550              		.loc 1 431 0
 1551 0c34 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 432:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1552              		.loc 1 432 0
 1553 0c38 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 433:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1554              		.loc 1 433 0
 1555 0c3c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 444:../uvc.c      ****     reqData = bRequest;
 1556              		.loc 1 444 0
 1557 0c40 CC3E9FE5 		ldr	r3, .L228+4
 430:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1558              		.loc 1 430 0
 1559 0c44 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1560              	.LVL111:
 444:../uvc.c      ****     reqData = bRequest;
 1561              		.loc 1 444 0
 1562 0c48 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1563              	.LVL112:
 452:../uvc.c      ****     switch (bRequest)
 1564              		.loc 1 452 0
 1565 0c4c 830055E3 		cmp	r5, #131
 1566 0c50 2200000A 		beq	.L116
 1567              	.LVL113:
 1568              	.L222:
 1569 0c54 2B00009A 		bls	.L220
 1570 0c58 850055E3 		cmp	r5, #133
 1571 0c5c 8400000A 		beq	.L118
 1572 0c60 7200003A 		bcc	.L117
 1573 0c64 860055E3 		cmp	r5, #134
 1574 0c68 BD00000A 		beq	.L119
 1575 0c6c 870055E3 		cmp	r5, #135
 1576 0c70 B100000A 		beq	.L221
 1577              	.L112:
 966:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1578              		.loc 1 966 0
 1579 0c74 0000A0E3 		mov	r0, #0
 1580 0c78 0110A0E3 		mov	r1, #1
 1581 0c7c 0020A0E1 		mov	r2, r0
 1582 0c80 FEFFFFEB 		bl	CyU3PUsbStall
 967:../uvc.c      **** 			  break;
 1583              		.loc 1 967 0
 1584 0c84 FFE0A0E3 		mov	lr, #255
 1585 0c88 0E40A0E1 		mov	r4, lr
 1586 0c8c 0EC0A0E1 		mov	ip, lr
 1587 0c90 0E30A0E1 		mov	r3, lr
 1588              	.LVL114:
 1589              	.L122:
 969:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1590              		.loc 1 969 0
 1591 0c94 7C1E9FE5 		ldr	r1, .L228+8
 1592 0c98 0520A0E1 		mov	r2, r5
 1593 0c9c 0400A0E3 		mov	r0, #4
 1594 0ca0 00C08DE5 		str	ip, [sp, #0]
 1595 0ca4 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1596 0ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 970:../uvc.c      **** }
 1597              		.loc 1 970 0
 1598 0cac 2CD08DE2 		add	sp, sp, #44
 1599 0cb0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1600              	.LVL115:
 1601              	.L110:
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1602              		.loc 1 435 0
 1603 0cb4 546E9FE5 		ldr	r6, .L228
 444:../uvc.c      ****     reqData = bRequest;
 1604              		.loc 1 444 0
 1605 0cb8 543E9FE5 		ldr	r3, .L228+4
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1606              		.loc 1 435 0
 1607 0cbc 805080E0 		add	r5, r0, r0, asl #1
 1608 0cc0 850186E0 		add	r0, r6, r5, asl #3
 1609              	.LVL116:
 444:../uvc.c      ****     reqData = bRequest;
 1610              		.loc 1 444 0
 1611 0cc4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 435:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1612              		.loc 1 435 0
 1613 0cc8 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1614              	.LVL117:
 452:../uvc.c      ****     switch (bRequest)
 1615              		.loc 1 452 0
 1616 0ccc 830055E3 		cmp	r5, #131
 436:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1617              		.loc 1 436 0
 1618 0cd0 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1619              	.LVL118:
 437:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1620              		.loc 1 437 0
 1621 0cd4 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1622              	.LVL119:
 438:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1623              		.loc 1 438 0
 1624 0cd8 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1625              	.LVL120:
 452:../uvc.c      ****     switch (bRequest)
 1626              		.loc 1 452 0
 1627 0cdc DCFFFF1A 		bne	.L222
 1628              	.LVL121:
 1629              	.L116:
 586:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1630              		.loc 1 586 0
 1631 0ce0 1F0054E3 		cmp	r4, #31
 1632 0ce4 BC00009A 		bls	.L147
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1633              		.loc 1 587 0
 1634 0ce8 877087E0 		add	r7, r7, r7, asl #1
 1635              	.LVL122:
 1636 0cec 876186E0 		add	r6, r6, r7, asl #3
 1637 0cf0 24AE9FE5 		ldr	sl, .L228+12
 1638 0cf4 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1639              		.loc 1 588 0
 1640 0cf8 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 587:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1641              		.loc 1 587 0
 1642 0cfc 5C00CAE5 		strb	r0, [sl, #92]
 588:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1643              		.loc 1 588 0
 1644 0d00 5DC0CAE5 		strb	ip, [sl, #93]
 1645 0d04 0B0000EA 		b	.L155
 1646              	.LVL123:
 1647              	.L220:
 452:../uvc.c      ****     switch (bRequest)
 1648              		.loc 1 452 0
 1649 0d08 810055E3 		cmp	r5, #129
 1650 0d0c 6400000A 		beq	.L114
 1651 0d10 1000009A 		bls	.L223
 567:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1652              		.loc 1 567 0
 1653 0d14 1F0054E3 		cmp	r4, #31
 1654 0d18 A300009A 		bls	.L144
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1655              		.loc 1 568 0
 1656 0d1c 877087E0 		add	r7, r7, r7, asl #1
 1657              	.LVL124:
 1658 0d20 876186E0 		add	r6, r6, r7, asl #3
 1659 0d24 F0AD9FE5 		ldr	sl, .L228+12
 1660 0d28 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1661              		.loc 1 569 0
 1662 0d2c 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 568:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1663              		.loc 1 568 0
 1664 0d30 5C20CAE5 		strb	r2, [sl, #92]
 569:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1665              		.loc 1 569 0
 1666 0d34 5DE0CAE5 		strb	lr, [sl, #93]
 1667              	.L155:
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1668              		.loc 1 645 0
 1669 0d38 0800A0E1 		mov	r0, r8
 1670 0d3c DC1D9FE5 		ldr	r1, .L228+16
 1671 0d40 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1672              	.LVL125:
 647:../uvc.c      **** 			  break;
 1673              		.loc 1 647 0
 1674 0d44 FFE0A0E3 		mov	lr, #255
 645:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1675              		.loc 1 645 0
 1676 0d48 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 647:../uvc.c      **** 			  break;
 1677              		.loc 1 647 0
 1678 0d4c 0EC0A0E1 		mov	ip, lr
 1679 0d50 0E30A0E1 		mov	r3, lr
 1680 0d54 CEFFFFEA 		b	.L122
 1681              	.LVL126:
 1682              	.L223:
 452:../uvc.c      ****     switch (bRequest)
 1683              		.loc 1 452 0
 1684 0d58 010055E3 		cmp	r5, #1
 1685 0d5c C4FFFF1A 		bne	.L112
 649:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1686              		.loc 1 649 0
 1687 0d60 B41D9FE5 		ldr	r1, .L228+12
 1688 0d64 26208DE2 		add	r2, sp, #38
 1689 0d68 2000A0E3 		mov	r0, #32
 1690 0d6c 5C1081E2 		add	r1, r1, #92
 1691 0d70 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1692              	.LVL127:
 651:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1693              		.loc 1 651 0
 1694 0d74 002050E2 		subs	r2, r0, #0
 1695 0d78 0103001A 		bne	.L157
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1696              		.loc 1 653 0
 1697 0d7c 98ED9FE5 		ldr	lr, .L228+12
 1698 0d80 5C30DEE5 		ldrb	r3, [lr, #92]	@ zero_extendqisi2
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1699              		.loc 1 654 0
 1700 0d84 90ED9FE5 		ldr	lr, .L228+12
 653:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1701              		.loc 1 653 0
 1702 0d88 18308DE5 		str	r3, [sp, #24]
 1703              	.LVL128:
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1704              		.loc 1 656 0
 1705 0d8c 5E00DEE5 		ldrb	r0, [lr, #94]	@ zero_extendqisi2
 1706              	.LVL129:
 654:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1707              		.loc 1 654 0
 1708 0d90 5DC0DEE5 		ldrb	ip, [lr, #93]	@ zero_extendqisi2
 1709              	.LVL130:
 656:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1710              		.loc 1 656 0
 1711 0d94 1C008DE5 		str	r0, [sp, #28]
 1712              	.LVL131:
 660:../uvc.c      **** 				  switch(CtrlID)
 1713              		.loc 1 660 0
 1714 0d98 220054E3 		cmp	r4, #34
 1715 0d9c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1716 0da0 C90200EA 		b	.L158
 1717              	.L173:
 1718 0da4 34190000 		.word	.L159
 1719 0da8 64180000 		.word	.L160
 1720 0dac CC180000 		.word	.L158
 1721 0db0 CC180000 		.word	.L158
 1722 0db4 14180000 		.word	.L161
 1723 0db8 D0160000 		.word	.L162
 1724 0dbc 54160000 		.word	.L163
 1725 0dc0 CC180000 		.word	.L158
 1726 0dc4 CC180000 		.word	.L158
 1727 0dc8 CC180000 		.word	.L158
 1728 0dcc CC180000 		.word	.L158
 1729 0dd0 CC150000 		.word	.L164
 1730 0dd4 CC180000 		.word	.L158
 1731 0dd8 CC180000 		.word	.L158
 1732 0ddc CC180000 		.word	.L158
 1733 0de0 CC180000 		.word	.L158
 1734 0de4 D4140000 		.word	.L165
 1735 0de8 CC180000 		.word	.L158
 1736 0dec CC180000 		.word	.L158
 1737 0df0 CC180000 		.word	.L158
 1738 0df4 CC180000 		.word	.L158
 1739 0df8 CC180000 		.word	.L158
 1740 0dfc CC180000 		.word	.L158
 1741 0e00 CC180000 		.word	.L158
 1742 0e04 CC180000 		.word	.L158
 1743 0e08 18140000 		.word	.L166
 1744 0e0c CC180000 		.word	.L158
 1745 0e10 CC180000 		.word	.L158
 1746 0e14 5C150000 		.word	.L167
 1747 0e18 CC180000 		.word	.L158
 1748 0e1c BC130000 		.word	.L168
 1749 0e20 38130000 		.word	.L169
 1750 0e24 A0120000 		.word	.L170
 1751 0e28 88120000 		.word	.L171
 1752 0e2c 24120000 		.word	.L172
 1753              	.LVL132:
 1754              	.L117:
 604:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1755              		.loc 1 604 0
 1756 0e30 1F0054E3 		cmp	r4, #31
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1757              		.loc 1 605 0
 1758 0e34 87708780 		addhi	r7, r7, r7, asl #1
 1759              	.LVL133:
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1760              		.loc 1 611 0
 1761 0e38 84408490 		addls	r4, r4, r4, asl #1
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1762              		.loc 1 605 0
 1763 0e3c 87618680 		addhi	r6, r6, r7, asl #3
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1764              		.loc 1 611 0
 1765 0e40 84618690 		addls	r6, r6, r4, asl #3
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1766              		.loc 1 605 0
 1767 0e44 D0AC9F85 		ldrhi	sl, .L228+12
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1768              		.loc 1 611 0
 1769 0e48 CCAC9F95 		ldrls	sl, .L228+12
 605:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1770              		.loc 1 605 0
 1771 0e4c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 606:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1772              		.loc 1 606 0
 1773 0e50 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1774              		.loc 1 611 0
 1775 0e54 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1776              		.loc 1 612 0
 1777 0e58 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1778              		.loc 1 613 0
 1779 0e5c 0030A0E3 		mov	r3, #0
 611:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1780              		.loc 1 611 0
 1781 0e60 5C10CAE5 		strb	r1, [sl, #92]
 612:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1782              		.loc 1 612 0
 1783 0e64 5D20CAE5 		strb	r2, [sl, #93]
 613:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1784              		.loc 1 613 0
 1785 0e68 5E30CAE5 		strb	r3, [sl, #94]
 614:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1786              		.loc 1 614 0
 1787 0e6c 5F30CAE5 		strb	r3, [sl, #95]
 1788 0e70 B0FFFFEA 		b	.L155
 1789              	.LVL134:
 1790              	.L118:
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1791              		.loc 1 456 0
 1792 0e74 A04C9FE5 		ldr	r4, .L228+12
 457:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1793              		.loc 1 457 0
 1794 0e78 00C0A0E3 		mov	ip, #0
 1795 0e7c 5DC0C4E5 		strb	ip, [r4, #93]
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1796              		.loc 1 458 0
 1797 0e80 5C1084E2 		add	r1, r4, #92
 456:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1798              		.loc 1 456 0
 1799 0e84 5C80C4E5 		strb	r8, [r4, #92]
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1800              		.loc 1 458 0
 1801 0e88 0200A0E3 		mov	r0, #2
 1802 0e8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1803              	.LVL135:
 460:../uvc.c      **** 			  break;
 1804              		.loc 1 460 0
 1805 0e90 FFE0A0E3 		mov	lr, #255
 458:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1806              		.loc 1 458 0
 1807 0e94 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 460:../uvc.c      **** 			  break;
 1808              		.loc 1 460 0
 1809 0e98 0EC0A0E1 		mov	ip, lr
 1810 0e9c 0E30A0E1 		mov	r3, lr
 1811 0ea0 7BFFFFEA 		b	.L122
 1812              	.LVL136:
 1813              	.L114:
 463:../uvc.c      **** 			 switch(CtrlID)
 1814              		.loc 1 463 0
 1815 0ea4 011044E2 		sub	r1, r4, #1
 1816 0ea8 210051E3 		cmp	r1, #33
 1817 0eac 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1818 0eb0 D20000EA 		b	.L123
 1819              	.L131:
 1820 0eb4 D4110000 		.word	.L124
 1821 0eb8 00120000 		.word	.L123
 1822 0ebc 00120000 		.word	.L123
 1823 0ec0 00120000 		.word	.L123
 1824 0ec4 B4110000 		.word	.L125
 1825 0ec8 00120000 		.word	.L123
 1826 0ecc 00120000 		.word	.L123
 1827 0ed0 00120000 		.word	.L123
 1828 0ed4 00120000 		.word	.L123
 1829 0ed8 00120000 		.word	.L123
 1830 0edc 90110000 		.word	.L126
 1831 0ee0 00120000 		.word	.L123
 1832 0ee4 00120000 		.word	.L123
 1833 0ee8 00120000 		.word	.L123
 1834 0eec 00120000 		.word	.L123
 1835 0ef0 00120000 		.word	.L123
 1836 0ef4 00120000 		.word	.L123
 1837 0ef8 00120000 		.word	.L123
 1838 0efc 00120000 		.word	.L123
 1839 0f00 00120000 		.word	.L123
 1840 0f04 00120000 		.word	.L123
 1841 0f08 00120000 		.word	.L123
 1842 0f0c 00120000 		.word	.L123
 1843 0f10 00120000 		.word	.L123
 1844 0f14 54110000 		.word	.L127
 1845 0f18 00120000 		.word	.L123
 1846 0f1c 00120000 		.word	.L123
 1847 0f20 2C110000 		.word	.L128
 1848 0f24 00120000 		.word	.L123
 1849 0f28 00120000 		.word	.L123
 1850 0f2c 90100000 		.word	.L129
 1851 0f30 58100000 		.word	.L130
 1852 0f34 58100000 		.word	.L130
 1853 0f38 58100000 		.word	.L130
 1854              	.L221:
 631:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1855              		.loc 1 631 0
 1856 0f3c 1F0054E3 		cmp	r4, #31
 1857 0f40 3100009A 		bls	.L154
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1858              		.loc 1 632 0
 1859 0f44 877087E0 		add	r7, r7, r7, asl #1
 1860              	.LVL137:
 1861 0f48 876186E0 		add	r6, r6, r7, asl #3
 1862 0f4c C8AB9FE5 		ldr	sl, .L228+12
 1863 0f50 0B10D6E5 		ldrb	r1, [r6, #11]	@ zero_extendqisi2
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1864              		.loc 1 633 0
 1865 0f54 0C40D6E5 		ldrb	r4, [r6, #12]	@ zero_extendqisi2
 632:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1866              		.loc 1 632 0
 1867 0f58 5C10CAE5 		strb	r1, [sl, #92]
 633:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1868              		.loc 1 633 0
 1869 0f5c 5D40CAE5 		strb	r4, [sl, #93]
 1870 0f60 74FFFFEA 		b	.L155
 1871              	.LVL138:
 1872              	.L119:
 620:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1873              		.loc 1 620 0
 1874 0f64 1F0054E3 		cmp	r4, #31
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1875              		.loc 1 624 0
 1876 0f68 84408490 		addls	r4, r4, r4, asl #1
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1877              		.loc 1 621 0
 1878 0f6c 87708780 		addhi	r7, r7, r7, asl #1
 1879              	.LVL139:
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1880              		.loc 1 624 0
 1881 0f70 84618690 		addls	r6, r6, r4, asl #3
 621:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1882              		.loc 1 621 0
 1883 0f74 87618680 		addhi	r6, r6, r7, asl #3
 1884 0f78 9C8B9F85 		ldrhi	r8, .L228+12
 1885 0f7c 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1886              		.loc 1 624 0
 1887 0f80 948B9F95 		ldrls	r8, .L228+12
 1888 0f84 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1889              		.loc 1 626 0
 1890 0f88 0100A0E3 		mov	r0, #1
 624:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1891              		.loc 1 624 0
 1892 0f8c 5C30C8E5 		strb	r3, [r8, #92]
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1893              		.loc 1 626 0
 1894 0f90 881B9FE5 		ldr	r1, .L228+16
 1895 0f94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1896              	.LVL140:
 629:../uvc.c      **** 			  break;
 1897              		.loc 1 629 0
 1898 0f98 FFE0A0E3 		mov	lr, #255
 626:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1899              		.loc 1 626 0
 1900 0f9c 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 629:../uvc.c      **** 			  break;
 1901              		.loc 1 629 0
 1902 0fa0 0EC0A0E1 		mov	ip, lr
 1903 0fa4 0E30A0E1 		mov	r3, lr
 1904 0fa8 39FFFFEA 		b	.L122
 1905              	.LVL141:
 1906              	.L144:
 572:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1907              		.loc 1 572 0
 1908 0fac 0B0054E3 		cmp	r4, #11
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1909              		.loc 1 579 0
 1910 0fb0 84408410 		addne	r4, r4, r4, asl #1
 1911 0fb4 84618610 		addne	r6, r6, r4, asl #3
 1912 0fb8 5CAB9F15 		ldrne	sl, .L228+12
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1913              		.loc 1 573 0
 1914 0fbc 58AB9F05 		ldreq	sl, .L228+12
 1915 0fc0 5C3B9F05 		ldreq	r3, .L228+20
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1916              		.loc 1 579 0
 1917 0fc4 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1918              		.loc 1 580 0
 1919 0fc8 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 573:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1920              		.loc 1 573 0
 1921 0fcc 5C308A05 		streq	r3, [sl, #92]
 579:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1922              		.loc 1 579 0
 1923 0fd0 5C20CA15 		strneb	r2, [sl, #92]
 580:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1924              		.loc 1 580 0
 1925 0fd4 5D30CA15 		strneb	r3, [sl, #93]
 1926 0fd8 56FFFFEA 		b	.L155
 1927              	.L147:
 590:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1928              		.loc 1 590 0
 1929 0fdc 0B0054E3 		cmp	r4, #11
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1930              		.loc 1 597 0
 1931 0fe0 84408410 		addne	r4, r4, r4, asl #1
 1932 0fe4 84618610 		addne	r6, r6, r4, asl #3
 1933 0fe8 2CAB9F15 		ldrne	sl, .L228+12
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1934              		.loc 1 591 0
 1935 0fec 28AB9F05 		ldreq	sl, .L228+12
 1936 0ff0 303B9F05 		ldreq	r3, .L228+24
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1937              		.loc 1 597 0
 1938 0ff4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1939              		.loc 1 598 0
 1940 0ff8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 591:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1941              		.loc 1 591 0
 1942 0ffc 5C308A05 		streq	r3, [sl, #92]
 597:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1943              		.loc 1 597 0
 1944 1000 5C20CA15 		strneb	r2, [sl, #92]
 598:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1945              		.loc 1 598 0
 1946 1004 5D30CA15 		strneb	r3, [sl, #93]
 1947 1008 4AFFFFEA 		b	.L155
 1948              	.L154:
 636:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1949              		.loc 1 636 0
 1950 100c 0B0054E3 		cmp	r4, #11
 1951 1010 0700000A 		beq	.L224
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1952              		.loc 1 642 0
 1953 1014 84A084E0 		add	sl, r4, r4, asl #1
 1954 1018 8A6186E0 		add	r6, r6, sl, asl #3
 1955 101c 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1956 1020 F4AA9FE5 		ldr	sl, .L228+12
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1957              		.loc 1 643 0
 1958 1024 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 642:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1959              		.loc 1 642 0
 1960 1028 5C30CAE5 		strb	r3, [sl, #92]
 643:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1961              		.loc 1 643 0
 1962 102c 5D00CAE5 		strb	r0, [sl, #93]
 1963 1030 40FFFFEA 		b	.L155
 1964              	.L224:
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1965              		.loc 1 637 0
 1966 1034 E0AA9FE5 		ldr	sl, .L228+12
 1967 1038 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1968              		.loc 1 639 0
 1969 103c 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1970              		.loc 1 638 0
 1971 1040 00E0A0E3 		mov	lr, #0
 637:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1972              		.loc 1 637 0
 1973 1044 5CC0CAE5 		strb	ip, [sl, #92]
 638:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1974              		.loc 1 638 0
 1975 1048 5DE0CAE5 		strb	lr, [sl, #93]
 639:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1976              		.loc 1 639 0
 1977 104c 5E20CAE5 		strb	r2, [sl, #94]
 640:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1978              		.loc 1 640 0
 1979 1050 5FE0CAE5 		strb	lr, [sl, #95]
 1980 1054 37FFFFEA 		b	.L155
 1981              	.L130:
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1982              		.loc 1 469 0
 1983 1058 877087E0 		add	r7, r7, r7, asl #1
 1984              	.LVL142:
 1985 105c 876186E0 		add	r6, r6, r7, asl #3
 1986 1060 B4EA9FE5 		ldr	lr, .L228+12
 1987 1064 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1988              		.loc 1 470 0
 1989 1068 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 469:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1990              		.loc 1 469 0
 1991 106c 5C40CEE5 		strb	r4, [lr, #92]
 470:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1992              		.loc 1 470 0
 1993 1070 5D60CEE5 		strb	r6, [lr, #93]
 1994              	.LVL143:
 1995              	.L134:
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1996              		.loc 1 560 0
 1997 1074 0800A0E1 		mov	r0, r8
 1998 1078 A01A9FE5 		ldr	r1, .L228+16
 1999 107c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 565:../uvc.c      **** 			  break;
 2000              		.loc 1 565 0
 2001 1080 FFC0A0E3 		mov	ip, #255
 560:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2002              		.loc 1 560 0
 2003 1084 06E0A0E1 		mov	lr, r6
 565:../uvc.c      **** 			  break;
 2004              		.loc 1 565 0
 2005 1088 0C30A0E1 		mov	r3, ip
 2006 108c 00FFFFEA 		b	.L122
 2007              	.LVL144:
 2008              	.L129:
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2009              		.loc 1 490 0 discriminator 1
 2010 1090 000058E3 		cmp	r8, #0
 2011 1094 8002000A 		beq	.L216
 488:../uvc.c      **** 					 break;
 2012              		.loc 1 488 0
 2013 1098 28E1A0E1 		mov	lr, r8, lsr #2
 2014 109c 00005EE3 		cmp	lr, #0
 2015 10a0 03005813 		cmpne	r8, #3
 2016 10a4 0020A083 		movhi	r2, #0
 2017 10a8 0120A093 		movls	r2, #1
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2018              		.loc 1 422 0
 2019 10ac 0E31A0E1 		mov	r3, lr, asl #2
 488:../uvc.c      **** 					 break;
 2020              		.loc 1 488 0
 2021 10b0 9302009A 		bls	.L201
 2022 10b4 641A9FE5 		ldr	r1, .L228+16
 2023 10b8 100041E2 		sub	r0, r1, #16
 2024              	.LVL145:
 2025              	.L139:
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2026              		.loc 1 491 0 discriminator 2
 2027 10bc 044090E4 		ldr	r4, [r0], #4
 2028 10c0 01C082E2 		add	ip, r2, #1
 2029 10c4 FF200CE2 		and	r2, ip, #255
 2030 10c8 02005EE1 		cmp	lr, r2
 2031 10cc 044081E4 		str	r4, [r1], #4
 2032 10d0 F9FFFF8A 		bhi	.L139
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2033              		.loc 1 491 0 is_stmt 0
 2034 10d4 030058E1 		cmp	r8, r3
 2035 10d8 3C0A9F15 		ldrne	r0, .L228+12
 2036 10dc 6E02000A 		beq	.L216
 2037              	.L208:
 2038 10e0 03E080E0 		add	lr, r0, r3
 2039 10e4 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2040              		.loc 1 490 0 is_stmt 1
 2041 10e8 016083E2 		add	r6, r3, #1
 2042 10ec FF3006E2 		and	r3, r6, #255
 2043              	.LVL146:
 2044 10f0 030058E1 		cmp	r8, r3
 491:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2045              		.loc 1 491 0
 2046 10f4 5C10CEE5 		strb	r1, [lr, #92]
 490:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2047              		.loc 1 490 0
 2048 10f8 F8FFFF8A 		bhi	.L208
 2049              	.LVL147:
 2050              	.L133:
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2051              		.loc 1 500 0
 2052 10fc 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2053              		.loc 1 493 0
 2054 1100 143A9FE5 		ldr	r3, .L228+12
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2055              		.loc 1 500 0
 2056 1104 FF0052E3 		cmp	r2, #255
 493:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2057              		.loc 1 493 0
 2058 1108 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2059              	.LVL148:
 494:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2060              		.loc 1 494 0
 2061 110c 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2062              	.LVL149:
 500:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2063              		.loc 1 500 0
 2064 1110 D7FFFF0A 		beq	.L134
 502:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2065              		.loc 1 502 0
 2066 1114 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2067 1118 0C1A9FE5 		ldr	r1, .L228+28
 2068 111c 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2069 1120 0400A0E3 		mov	r0, #4
 2070 1124 FEFFFFEB 		bl	CyU3PDebugPrint
 2071 1128 D1FFFFEA 		b	.L134
 2072              	.LVL150:
 2073              	.L128:
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 2074              		.loc 1 477 0
 2075 112c E8799FE5 		ldr	r7, .L228+12
 2076              	.LVL151:
 476:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2077              		.loc 1 476 0
 2078 1130 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2079              	.LVL152:
 477:../uvc.c      **** 					 if(CamMode == 1){//720p
 2080              		.loc 1 477 0
 2081 1134 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2082 1138 010052E3 		cmp	r2, #1
 2083 113c 1802000A 		beq	.L225
 2084              	.LVL153:
 2085              	.L135:
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2086              		.loc 1 487 0
 2087 1140 0000A0E3 		mov	r0, #0
 486:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2088              		.loc 1 486 0
 2089 1144 5C40C7E5 		strb	r4, [r7, #92]
 487:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2090              		.loc 1 487 0
 2091 1148 5D00C7E5 		strb	r0, [r7, #93]
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2092              		.loc 1 440 0
 2093 114c FF60A0E3 		mov	r6, #255
 488:../uvc.c      **** 					 break;
 2094              		.loc 1 488 0
 2095 1150 C7FFFFEA 		b	.L134
 2096              	.LVL154:
 2097              	.L127:
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2098              		.loc 1 506 0
 2099 1154 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 2100 1158 BCC99FE5 		ldr	ip, .L228+12
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2101              		.loc 1 508 0
 2102 115c E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2103              		.loc 1 507 0
 2104 1160 00E0A0E3 		mov	lr, #0
 506:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 2105              		.loc 1 506 0
 2106 1164 5C40CCE5 		strb	r4, [ip, #92]
 507:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2107              		.loc 1 507 0
 2108 1168 5DE0CCE5 		strb	lr, [ip, #93]
 508:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2109              		.loc 1 508 0
 2110 116c 5E60CCE5 		strb	r6, [ip, #94]
 509:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2111              		.loc 1 509 0
 2112 1170 5FE0CCE5 		strb	lr, [ip, #95]
 2113              	.LVL155:
 512:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2114              		.loc 1 512 0
 2115 1174 B4199FE5 		ldr	r1, .L228+32
 2116 1178 0420A0E1 		mov	r2, r4
 2117 117c 0E30A0E1 		mov	r3, lr
 2118 1180 0400A0E3 		mov	r0, #4
 2119 1184 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2120 1188 FEFFFFEB 		bl	CyU3PDebugPrint
 513:../uvc.c      **** 					 break;
 2121              		.loc 1 513 0
 2122 118c B8FFFFEA 		b	.L134
 2123              	.LVL156:
 2124              	.L126:
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2125              		.loc 1 545 0
 2126 1190 84C99FE5 		ldr	ip, .L228+12
 2127 1194 9044D6E5 		ldrb	r4, [r6, #1168]	@ zero_extendqisi2
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2128              		.loc 1 547 0
 2129 1198 9264D6E5 		ldrb	r6, [r6, #1170]	@ zero_extendqisi2
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2130              		.loc 1 546 0
 2131 119c 00E0A0E3 		mov	lr, #0
 545:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2132              		.loc 1 545 0
 2133 11a0 5C40CCE5 		strb	r4, [ip, #92]
 546:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2134              		.loc 1 546 0
 2135 11a4 5DE0CCE5 		strb	lr, [ip, #93]
 547:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2136              		.loc 1 547 0
 2137 11a8 5E60CCE5 		strb	r6, [ip, #94]
 548:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2138              		.loc 1 548 0
 2139 11ac 5FE0CCE5 		strb	lr, [ip, #95]
 2140              	.LVL157:
 551:../uvc.c      **** 					 break;
 2141              		.loc 1 551 0
 2142 11b0 AFFFFFEA 		b	.L134
 2143              	.LVL158:
 2144              	.L125:
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2145              		.loc 1 540 0
 2146 11b4 0522D6E5 		ldrb	r2, [r6, #517]	@ zero_extendqisi2
 2147 11b8 5C699FE5 		ldr	r6, .L228+12
 2148 11bc 804022E2 		eor	r4, r2, #128
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2149              		.loc 1 541 0
 2150 11c0 0010A0E3 		mov	r1, #0
 540:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2151              		.loc 1 540 0
 2152 11c4 5C40C6E5 		strb	r4, [r6, #92]
 541:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2153              		.loc 1 541 0
 2154 11c8 5D10C6E5 		strb	r1, [r6, #93]
 2155              	.LVL159:
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2156              		.loc 1 440 0
 2157 11cc FF60A0E3 		mov	r6, #255
 543:../uvc.c      **** 					 break;
 2158              		.loc 1 543 0
 2159 11d0 A7FFFFEA 		b	.L134
 2160              	.LVL160:
 2161              	.L124:
 528:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2162              		.loc 1 528 0
 2163 11d4 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2164              	.LVL161:
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2165              		.loc 1 534 0
 2166 11d8 3C399FE5 		ldr	r3, .L228+12
 529:../uvc.c      **** 					  if(Data0&0x80){
 2167              		.loc 1 529 0
 2168 11dc 800014E3 		tst	r4, #128
 530:../uvc.c      **** 						  Data0 = ~Data0;
 2169              		.loc 1 530 0
 2170 11e0 0440E011 		mvnne	r4, r4
 2171              	.LVL162:
 532:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2172              		.loc 1 532 0
 2173 11e4 80404402 		subeq	r4, r4, #128
 2174 11e8 FF4004E2 		and	r4, r4, #255
 2175              	.LVL163:
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2176              		.loc 1 535 0
 2177 11ec 0000A0E3 		mov	r0, #0
 534:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2178              		.loc 1 534 0
 2179 11f0 5C40C3E5 		strb	r4, [r3, #92]
 535:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2180              		.loc 1 535 0
 2181 11f4 5D00C3E5 		strb	r0, [r3, #93]
 2182              	.LVL164:
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2183              		.loc 1 440 0
 2184 11f8 FF60A0E3 		mov	r6, #255
 537:../uvc.c      **** 			 		 break;
 2185              		.loc 1 537 0
 2186 11fc 9CFFFFEA 		b	.L134
 2187              	.LVL165:
 2188              	.L123:
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2189              		.loc 1 554 0
 2190 1200 841084E0 		add	r1, r4, r4, asl #1
 2191 1204 814186E0 		add	r4, r6, r1, asl #3
 2192 1208 0C399FE5 		ldr	r3, .L228+12
 2193 120c 8D41D4E5 		ldrb	r4, [r4, #397]	@ zero_extendqisi2
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2194              		.loc 1 555 0
 2195 1210 0000A0E3 		mov	r0, #0
 440:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2196              		.loc 1 440 0
 2197 1214 FF60A0E3 		mov	r6, #255
 554:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2198              		.loc 1 554 0
 2199 1218 5C40C3E5 		strb	r4, [r3, #92]
 555:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2200              		.loc 1 555 0
 2201 121c 5D00C3E5 		strb	r0, [r3, #93]
 2202              	.LVL166:
 557:../uvc.c      **** 					 break;
 2203              		.loc 1 557 0
 2204 1220 93FFFFEA 		b	.L134
 2205              	.LVL167:
 2206              	.L172:
 791:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2207              		.loc 1 791 0
 2208 1224 08499FE5 		ldr	r4, .L228+36
 2209 1228 0010E0E3 		mvn	r1, #0
 2210 122c 1C0094E5 		ldr	r0, [r4, #28]
 2211 1230 FEFFFFEB 		bl	_txe_mutex_get
 2212              	.LVL168:
 792:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2213              		.loc 1 792 0
 2214 1234 2210A0E3 		mov	r1, #34
 2215              	.L219:
 2216 1238 18C09DE5 		ldr	ip, [sp, #24]
 2217 123c 00E0A0E3 		mov	lr, #0
 2218 1240 0A30A0E1 		mov	r3, sl
 2219 1244 0920A0E1 		mov	r2, r9
 2220 1248 0400A0E1 		mov	r0, r4
 2221 124c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2222 1250 FEFFFFEB 		bl	cmdSet
 793:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2223              		.loc 1 793 0
 2224 1254 1C0094E5 		ldr	r0, [r4, #28]
 2225 1258 FEFFFFEB 		bl	_txe_mutex_put
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2226              		.loc 1 794 0
 2227 125c 18109DE5 		ldr	r1, [sp, #24]
 2228 1260 877087E0 		add	r7, r7, r7, asl #1
 2229              	.LVL169:
 2230 1264 876186E0 		add	r6, r6, r7, asl #3
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2231              		.loc 1 795 0
 2232 1268 0130A0E3 		mov	r3, #1
 796:../uvc.c      **** 							 break;
 2233              		.loc 1 796 0
 2234 126c FFE0A0E3 		mov	lr, #255
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2235              		.loc 1 795 0
 2236 1270 1030C6E5 		strb	r3, [r6, #16]
 794:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2237              		.loc 1 794 0
 2238 1274 0D10C6E5 		strb	r1, [r6, #13]
 795:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2239              		.loc 1 795 0
 2240 1278 0130A0E1 		mov	r3, r1
 2241 127c 1CC09DE5 		ldr	ip, [sp, #28]
 796:../uvc.c      **** 							 break;
 2242              		.loc 1 796 0
 2243 1280 0E40A0E1 		mov	r4, lr
 2244 1284 82FEFFEA 		b	.L122
 2245              	.LVL170:
 2246              	.L171:
 783:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2247              		.loc 1 783 0
 2248 1288 A4489FE5 		ldr	r4, .L228+36
 2249 128c 0010E0E3 		mvn	r1, #0
 2250 1290 1C0094E5 		ldr	r0, [r4, #28]
 2251 1294 FEFFFFEB 		bl	_txe_mutex_get
 2252              	.LVL171:
 784:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2253              		.loc 1 784 0
 2254 1298 2110A0E3 		mov	r1, #33
 2255 129c E5FFFFEA 		b	.L219
 2256              	.LVL172:
 2257              	.L170:
 769:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2258              		.loc 1 769 0
 2259 12a0 8C489FE5 		ldr	r4, .L228+36
 2260 12a4 0010E0E3 		mvn	r1, #0
 2261 12a8 1C0094E5 		ldr	r0, [r4, #28]
 2262 12ac 14C08DE5 		str	ip, [sp, #20]
 2263 12b0 FEFFFFEB 		bl	_txe_mutex_get
 2264              	.LVL173:
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2265              		.loc 1 768 0
 2266 12b4 18209DE5 		ldr	r2, [sp, #24]
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2267              		.loc 1 771 0
 2268 12b8 00E0A0E3 		mov	lr, #0
 768:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2269              		.loc 1 768 0
 2270 12bc 7F8002E2 		and	r8, r2, #127
 2271 12c0 1C808DE5 		str	r8, [sp, #28]
 2272              	.LVL174:
 771:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2273              		.loc 1 771 0
 2274 12c4 1CC09DE5 		ldr	ip, [sp, #28]
 2275 12c8 2010A0E3 		mov	r1, #32
 2276 12cc 0920A0E1 		mov	r2, r9
 2277 12d0 0A30A0E1 		mov	r3, sl
 2278 12d4 0400A0E1 		mov	r0, r4
 2279 12d8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2280 12dc FEFFFFEB 		bl	cmdSet
 2281              	.LVL175:
 773:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2282              		.loc 1 773 0
 2283 12e0 14C09DE5 		ldr	ip, [sp, #20]
 2284 12e4 0A30A0E1 		mov	r3, sl
 2285 12e8 0180A0E3 		mov	r8, #1
 2286 12ec 2010A0E3 		mov	r1, #32
 2287 12f0 0B20A0E1 		mov	r2, fp
 2288 12f4 0400A0E1 		mov	r0, r4
 2289 12f8 00C08DE5 		str	ip, [sp, #0]
 2290 12fc 04808DE5 		str	r8, [sp, #4]
 2291 1300 FEFFFFEB 		bl	cmdSet
 774:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2292              		.loc 1 774 0
 2293 1304 1C0094E5 		ldr	r0, [r4, #28]
 2294 1308 FEFFFFEB 		bl	_txe_mutex_put
 2295              	.LVL176:
 777:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2296              		.loc 1 777 0
 2297 130c 1C009DE5 		ldr	r0, [sp, #28]
 2298 1310 877087E0 		add	r7, r7, r7, asl #1
 2299              	.LVL177:
 2300 1314 876186E0 		add	r6, r6, r7, asl #3
 2301 1318 0D00C6E5 		strb	r0, [r6, #13]
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2302              		.loc 1 778 0
 2303 131c 14C09DE5 		ldr	ip, [sp, #20]
 780:../uvc.c      **** 							 break;
 2304              		.loc 1 780 0
 2305 1320 FFE0A0E3 		mov	lr, #255
 778:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2306              		.loc 1 778 0
 2307 1324 0EC0C6E5 		strb	ip, [r6, #14]
 779:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2308              		.loc 1 779 0
 2309 1328 1080C6E5 		strb	r8, [r6, #16]
 2310 132c 18309DE5 		ldr	r3, [sp, #24]
 780:../uvc.c      **** 							 break;
 2311              		.loc 1 780 0
 2312 1330 0E40A0E1 		mov	r4, lr
 2313 1334 56FEFFEA 		b	.L122
 2314              	.LVL178:
 2315              	.L169:
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2316              		.loc 1 740 0 discriminator 1
 2317 1338 000058E3 		cmp	r8, #0
 2318 133c 1800000A 		beq	.L175
 738:../uvc.c      **** 							 break;
 2319              		.loc 1 738 0
 2320 1340 28E1A0E1 		mov	lr, r8, lsr #2
 2321 1344 00005EE3 		cmp	lr, #0
 2322 1348 03005813 		cmpne	r8, #3
 2323 134c 0020A083 		movhi	r2, #0
 2324 1350 0120A093 		movls	r2, #1
 2325              	.LVL179:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2326              		.loc 1 422 0
 2327 1354 0E31A0E1 		mov	r3, lr, asl #2
 738:../uvc.c      **** 							 break;
 2328              		.loc 1 738 0
 2329 1358 E701009A 		bls	.L202
 2330 135c D4179FE5 		ldr	r1, .L228+40
 2331 1360 100081E2 		add	r0, r1, #16
 2332              	.LVL180:
 2333              	.L186:
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2334              		.loc 1 741 0 discriminator 2
 2335 1364 044090E4 		ldr	r4, [r0], #4
 2336 1368 012082E2 		add	r2, r2, #1
 2337 136c FF2002E2 		and	r2, r2, #255
 2338 1370 02005EE1 		cmp	lr, r2
 2339 1374 044081E4 		str	r4, [r1], #4
 2340 1378 F9FFFF8A 		bhi	.L186
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2341              		.loc 1 741 0 is_stmt 0
 2342 137c 030058E1 		cmp	r8, r3
 2343 1380 0700000A 		beq	.L175
 2344              	.LVL181:
 2345              	.L209:
 2346 1384 90C79FE5 		ldr	ip, .L228+12
 2347 1388 03E08CE0 		add	lr, ip, r3
 2348 138c 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2349              		.loc 1 740 0 is_stmt 1
 2350 1390 013083E2 		add	r3, r3, #1
 2351 1394 FF3003E2 		and	r3, r3, #255
 2352              	.LVL182:
 2353 1398 030058E1 		cmp	r8, r3
 741:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2354              		.loc 1 741 0
 2355 139c 4C10CEE5 		strb	r1, [lr, #76]
 740:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2356              		.loc 1 740 0
 2357 13a0 F7FFFF8A 		bhi	.L209
 2358              	.LVL183:
 2359              	.L175:
 743:../uvc.c      **** 					 		I2CCmdHandler();
 2360              		.loc 1 743 0
 2361 13a4 FEFFFFEB 		bl	I2CCmdHandler
 744:../uvc.c      **** 							 break;
 2362              		.loc 1 744 0
 2363 13a8 FFE0A0E3 		mov	lr, #255
 743:../uvc.c      **** 					 		I2CCmdHandler();
 2364              		.loc 1 743 0
 2365 13ac 18309DE5 		ldr	r3, [sp, #24]
 2366 13b0 1CC09DE5 		ldr	ip, [sp, #28]
 744:../uvc.c      **** 							 break;
 2367              		.loc 1 744 0
 2368 13b4 0E40A0E1 		mov	r4, lr
 2369 13b8 35FEFFEA 		b	.L122
 2370              	.LVL184:
 2371              	.L168:
 734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2372              		.loc 1 734 0
 2373 13bc 70479FE5 		ldr	r4, .L228+36
 2374 13c0 0010E0E3 		mvn	r1, #0
 2375 13c4 1C0094E5 		ldr	r0, [r4, #28]
 2376 13c8 FEFFFFEB 		bl	_txe_mutex_get
 2377              	.LVL185:
 735:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2378              		.loc 1 735 0
 2379 13cc 18009DE5 		ldr	r0, [sp, #24]
 2380 13d0 00E0A0E3 		mov	lr, #0
 2381 13d4 01C070E2 		rsbs	ip, r0, #1
 2382 13d8 00C0A033 		movcc	ip, #0
 2383 13dc 0A30A0E1 		mov	r3, sl
 2384 13e0 1E10A0E3 		mov	r1, #30
 2385 13e4 0920A0E1 		mov	r2, r9
 2386 13e8 0400A0E1 		mov	r0, r4
 2387 13ec 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2388 13f0 FEFFFFEB 		bl	cmdSet
 736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2389              		.loc 1 736 0
 2390 13f4 1C0094E5 		ldr	r0, [r4, #28]
 2391 13f8 FEFFFFEB 		bl	_txe_mutex_put
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2392              		.loc 1 737 0
 2393 13fc 0130A0E3 		mov	r3, #1
 738:../uvc.c      **** 							 break;
 2394              		.loc 1 738 0
 2395 1400 FFE0A0E3 		mov	lr, #255
 737:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2396              		.loc 1 737 0
 2397 1404 6034C6E5 		strb	r3, [r6, #1120]
 2398 1408 1CC09DE5 		ldr	ip, [sp, #28]
 2399 140c 18309DE5 		ldr	r3, [sp, #24]
 738:../uvc.c      **** 							 break;
 2400              		.loc 1 738 0
 2401 1410 0E40A0E1 		mov	r4, lr
 2402 1414 1EFEFFEA 		b	.L122
 2403              	.LVL186:
 2404              	.L166:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2405              		.loc 1 701 0
 2406 1418 14479FE5 		ldr	r4, .L228+36
 697:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2407              		.loc 1 697 0
 2408 141c E533C6E5 		strb	r3, [r6, #997]
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2409              		.loc 1 698 0
 2410 1420 1C309DE5 		ldr	r3, [sp, #28]
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2411              		.loc 1 699 0
 2412 1424 0170A0E3 		mov	r7, #1
 2413              	.LVL187:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2414              		.loc 1 701 0
 2415 1428 0010E0E3 		mvn	r1, #0
 698:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2416              		.loc 1 698 0
 2417 142c E633C6E5 		strb	r3, [r6, #998]
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2418              		.loc 1 701 0
 2419 1430 1C0094E5 		ldr	r0, [r4, #28]
 699:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2420              		.loc 1 699 0
 2421 1434 E873C6E5 		strb	r7, [r6, #1000]
 2422              	.LVL188:
 701:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2423              		.loc 1 701 0
 2424 1438 FEFFFFEB 		bl	_txe_mutex_get
 2425              	.LVL189:
 702:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2426              		.loc 1 702 0
 2427 143c 18C09DE5 		ldr	ip, [sp, #24]
 2428 1440 0400A0E1 		mov	r0, r4
 2429 1444 00C08DE5 		str	ip, [sp, #0]
 2430 1448 1910A0E3 		mov	r1, #25
 2431 144c 00C0A0E3 		mov	ip, #0
 2432 1450 0920A0E1 		mov	r2, r9
 2433 1454 0A30A0E1 		mov	r3, sl
 2434 1458 04C08DE5 		str	ip, [sp, #4]
 2435 145c FEFFFFEB 		bl	cmdSet
 703:../uvc.c      **** 							 if(getData != 0){
 2436              		.loc 1 703 0
 2437 1460 18009DE5 		ldr	r0, [sp, #24]
 2438 1464 000050E3 		cmp	r0, #0
 2439 1468 0700000A 		beq	.L182
 2440              	.LVL190:
 705:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2441              		.loc 1 705 0
 2442 146c 1CE09DE5 		ldr	lr, [sp, #28]
 2443 1470 0400A0E1 		mov	r0, r4
 2444 1474 1910A0E3 		mov	r1, #25
 2445 1478 0B20A0E1 		mov	r2, fp
 2446 147c 0A30A0E1 		mov	r3, sl
 2447 1480 00E08DE5 		str	lr, [sp, #0]
 2448 1484 04708DE5 		str	r7, [sp, #4]
 2449 1488 FEFFFFEB 		bl	cmdSet
 2450              	.LVL191:
 2451              	.L182:
 707:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2452              		.loc 1 707 0
 2453 148c 1C0094E5 		ldr	r0, [r4, #28]
 2454 1490 FEFFFFEB 		bl	_txe_mutex_put
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2455              		.loc 1 708 0
 2456 1494 80069FE5 		ldr	r0, .L228+12
 2457 1498 7C169FE5 		ldr	r1, .L228+12
 2458 149c 5EC0D0E5 		ldrb	ip, [r0, #94]	@ zero_extendqisi2
 2459 14a0 5F40D1E5 		ldrb	r4, [r1, #95]	@ zero_extendqisi2
 2460 14a4 5D30D0E5 		ldrb	r3, [r0, #93]	@ zero_extendqisi2
 2461 14a8 5C20D0E5 		ldrb	r2, [r0, #92]	@ zero_extendqisi2
 2462 14ac 88169FE5 		ldr	r1, .L228+44
 2463 14b0 0400A0E3 		mov	r0, #4
 2464 14b4 00C08DE5 		str	ip, [sp, #0]
 2465 14b8 04408DE5 		str	r4, [sp, #4]
 2466 14bc FEFFFFEB 		bl	CyU3PDebugPrint
 709:../uvc.c      **** 							 break;
 2467              		.loc 1 709 0
 2468 14c0 FFE0A0E3 		mov	lr, #255
 708:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2469              		.loc 1 708 0
 2470 14c4 18309DE5 		ldr	r3, [sp, #24]
 2471 14c8 1CC09DE5 		ldr	ip, [sp, #28]
 709:../uvc.c      **** 							 break;
 2472              		.loc 1 709 0
 2473 14cc 0E40A0E1 		mov	r4, lr
 2474 14d0 EFFDFFEA 		b	.L122
 2475              	.LVL192:
 2476              	.L165:
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2477              		.loc 1 664 0
 2478 14d4 001053E2 		subs	r1, r3, #0
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2479              		.loc 1 663 0
 2480 14d8 0D13C6E5 		strb	r1, [r6, #781]
 2481 14dc 2C369FE5 		ldr	r3, .L228
 664:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2482              		.loc 1 664 0
 2483 14e0 3C01001A 		bne	.L176
 665:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2484              		.loc 1 665 0
 2485 14e4 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2486              	.LVL193:
 2487 14e8 020052E3 		cmp	r2, #2
 2488 14ec 08005213 		cmpne	r2, #8
 2489 14f0 0300000A 		beq	.L177
 666:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2490              		.loc 1 666 0
 2491 14f4 010052E3 		cmp	r2, #1
 667:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2492              		.loc 1 667 0
 2493 14f8 07208202 		addeq	r2, r2, #7
 669:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2494              		.loc 1 669 0
 2495 14fc 0220A013 		movne	r2, #2
 2496 1500 B924C3E5 		strb	r2, [r3, #1209]
 2497              	.LVL194:
 2498              	.L177:
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2499              		.loc 1 691 0
 2500 1504 28469FE5 		ldr	r4, .L228+36
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2501              		.loc 1 689 0
 2502 1508 0120A0E3 		mov	r2, #1
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2503              		.loc 1 691 0
 2504 150c 0010E0E3 		mvn	r1, #0
 689:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2505              		.loc 1 689 0
 2506 1510 1023C6E5 		strb	r2, [r6, #784]
 2507              	.LVL195:
 691:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2508              		.loc 1 691 0
 2509 1514 1C0094E5 		ldr	r0, [r4, #28]
 2510 1518 FEFFFFEB 		bl	_txe_mutex_get
 692:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2511              		.loc 1 692 0
 2512 151c 18C09DE5 		ldr	ip, [sp, #24]
 2513 1520 1010A0E3 		mov	r1, #16
 2514 1524 00C08DE5 		str	ip, [sp, #0]
 2515 1528 0920A0E1 		mov	r2, r9
 2516 152c 0A30A0E1 		mov	r3, sl
 2517 1530 0400A0E1 		mov	r0, r4
 2518 1534 00C0A0E3 		mov	ip, #0
 2519              	.LVL196:
 2520              	.L218:
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2521              		.loc 1 942 0
 2522 1538 04C08DE5 		str	ip, [sp, #4]
 2523 153c FEFFFFEB 		bl	cmdSet
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2524              		.loc 1 943 0
 2525 1540 1C0094E5 		ldr	r0, [r4, #28]
 2526 1544 FEFFFFEB 		bl	_txe_mutex_put
 945:../uvc.c      **** 					 		 break;
 2527              		.loc 1 945 0
 2528 1548 FFE0A0E3 		mov	lr, #255
 943:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2529              		.loc 1 943 0
 2530 154c 18309DE5 		ldr	r3, [sp, #24]
 2531 1550 1CC09DE5 		ldr	ip, [sp, #28]
 945:../uvc.c      **** 					 		 break;
 2532              		.loc 1 945 0
 2533 1554 0E40A0E1 		mov	r4, lr
 2534 1558 CDFDFFEA 		b	.L122
 2535              	.LVL197:
 2536              	.L167:
 712:../uvc.c      **** 							 if(Data0 <= 3){
 2537              		.loc 1 712 0
 2538 155c 030053E3 		cmp	r3, #3
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2539              		.loc 1 713 0
 2540 1560 B4259F95 		ldrls	r2, .L228+12
 2541              	.LVL198:
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2542              		.loc 1 716 0
 2543 1564 B0E59F85 		ldrhi	lr, .L228+12
 2544 1568 0340A0E1 		mov	r4, r3
 2545              	.LVL199:
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2546              		.loc 1 713 0
 2547 156c 0030A093 		movls	r3, #0
 2548 1570 7C30C295 		strlsb	r3, [r2, #124]
 2549              	.LVL200:
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2550              		.loc 1 716 0
 2551 1574 0120A083 		movhi	r2, #1
 2552 1578 18209D95 		ldrls	r2, [sp, #24]
 713:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2553              		.loc 1 713 0
 2554 157c 0430A091 		movls	r3, r4
 716:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2555              		.loc 1 716 0
 2556 1580 7C20CE85 		strhib	r2, [lr, #124]
 2557 1584 0420A081 		movhi	r2, r4
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2558              		.loc 1 722 0
 2559 1588 A4459FE5 		ldr	r4, .L228+36
 717:../uvc.c      **** 								 Data1 = Data0-4;
 2560              		.loc 1 717 0
 2561 158c 04304382 		subhi	r3, r3, #4
 2562              	.LVL201:
 719:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2563              		.loc 1 719 0
 2564 1590 2D24C6E5 		strb	r2, [r6, #1069]
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2565              		.loc 1 721 0
 2566 1594 0120A0E3 		mov	r2, #1
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2567              		.loc 1 722 0
 2568 1598 0010E0E3 		mvn	r1, #0
 720:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2569              		.loc 1 720 0
 2570 159c 8D31C6E5 		strb	r3, [r6, #397]
 721:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2571              		.loc 1 721 0
 2572 15a0 3024C6E5 		strb	r2, [r6, #1072]
 722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2573              		.loc 1 722 0
 2574 15a4 1C0094E5 		ldr	r0, [r4, #28]
 2575 15a8 FEFFFFEB 		bl	_txe_mutex_get
 2576              	.LVL202:
 723:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2577              		.loc 1 723 0
 2578 15ac 18C09DE5 		ldr	ip, [sp, #24]
 2579 15b0 1C10A0E3 		mov	r1, #28
 2580 15b4 00C08DE5 		str	ip, [sp, #0]
 2581 15b8 0920A0E1 		mov	r2, r9
 2582 15bc 0A30A0E1 		mov	r3, sl
 2583 15c0 0400A0E1 		mov	r0, r4
 2584 15c4 00C0A0E3 		mov	ip, #0
 2585 15c8 DAFFFFEA 		b	.L218
 2586              	.LVL203:
 2587              	.L164:
 873:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2588              		.loc 1 873 0
 2589 15cc 60459FE5 		ldr	r4, .L228+36
 2590 15d0 0010E0E3 		mvn	r1, #0
 2591 15d4 1C0094E5 		ldr	r0, [r4, #28]
 2592 15d8 FEFFFFEB 		bl	_txe_mutex_get
 2593              	.LVL204:
 874:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2594              		.loc 1 874 0
 2595 15dc 18C09DE5 		ldr	ip, [sp, #24]
 2596 15e0 0B10A0E3 		mov	r1, #11
 2597 15e4 0920A0E1 		mov	r2, r9
 2598 15e8 0A30A0E1 		mov	r3, sl
 2599 15ec 0400A0E1 		mov	r0, r4
 2600 15f0 00C08DE5 		str	ip, [sp, #0]
 2601 15f4 00C0A0E3 		mov	ip, #0
 2602 15f8 04C08DE5 		str	ip, [sp, #4]
 2603 15fc FEFFFFEB 		bl	cmdSet
 2604              	.LVL205:
 876:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2605              		.loc 1 876 0
 2606 1600 1CE09DE5 		ldr	lr, [sp, #28]
 2607 1604 0B10A0E3 		mov	r1, #11
 2608 1608 0B20A0E1 		mov	r2, fp
 2609 160c 0A30A0E1 		mov	r3, sl
 2610 1610 0170A0E3 		mov	r7, #1
 2611              	.LVL206:
 2612 1614 0400A0E1 		mov	r0, r4
 2613 1618 00E08DE5 		str	lr, [sp, #0]
 2614 161c 04708DE5 		str	r7, [sp, #4]
 2615 1620 FEFFFFEB 		bl	cmdSet
 877:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2616              		.loc 1 877 0
 2617 1624 1C0094E5 		ldr	r0, [r4, #28]
 2618 1628 FEFFFFEB 		bl	_txe_mutex_put
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2619              		.loc 1 879 0
 2620 162c 18109DE5 		ldr	r1, [sp, #24]
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2621              		.loc 1 880 0
 2622 1630 1C209DE5 		ldr	r2, [sp, #28]
 882:../uvc.c      **** 							 break;
 2623              		.loc 1 882 0
 2624 1634 FFE0A0E3 		mov	lr, #255
 879:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2625              		.loc 1 879 0
 2626 1638 9014C6E5 		strb	r1, [r6, #1168]
 880:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2627              		.loc 1 880 0
 2628 163c 9224C6E5 		strb	r2, [r6, #1170]
 881:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2629              		.loc 1 881 0
 2630 1640 9872C6E5 		strb	r7, [r6, #664]
 2631 1644 0130A0E1 		mov	r3, r1
 2632 1648 02C0A0E1 		mov	ip, r2
 882:../uvc.c      **** 							 break;
 2633              		.loc 1 882 0
 2634 164c 0E40A0E1 		mov	r4, lr
 2635 1650 8FFDFFEA 		b	.L122
 2636              	.LVL207:
 2637              	.L163:
 859:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2638              		.loc 1 859 0
 2639 1654 D8449FE5 		ldr	r4, .L228+36
 2640 1658 0010E0E3 		mvn	r1, #0
 2641 165c 1C0094E5 		ldr	r0, [r4, #28]
 2642 1660 FEFFFFEB 		bl	_txe_mutex_get
 2643              	.LVL208:
 860:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2644              		.loc 1 860 0
 2645 1664 18C09DE5 		ldr	ip, [sp, #24]
 2646 1668 00E0A0E3 		mov	lr, #0
 2647 166c 0610A0E3 		mov	r1, #6
 2648 1670 0920A0E1 		mov	r2, r9
 2649 1674 0A30A0E1 		mov	r3, sl
 2650 1678 0400A0E1 		mov	r0, r4
 2651 167c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2652 1680 FEFFFFEB 		bl	cmdSet
 2653              	.LVL209:
 862:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2654              		.loc 1 862 0
 2655 1684 18C09DE5 		ldr	ip, [sp, #24]
 2656 1688 0A30A0E1 		mov	r3, sl
 2657 168c 0170A0E3 		mov	r7, #1
 2658              	.LVL210:
 2659 1690 0610A0E3 		mov	r1, #6
 2660 1694 0B20A0E1 		mov	r2, fp
 2661 1698 0400A0E1 		mov	r0, r4
 2662 169c 00C08DE5 		str	ip, [sp, #0]
 2663 16a0 04708DE5 		str	r7, [sp, #4]
 2664 16a4 FEFFFFEB 		bl	cmdSet
 863:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2665              		.loc 1 863 0
 2666 16a8 1C0094E5 		ldr	r0, [r4, #28]
 2667 16ac FEFFFFEB 		bl	_txe_mutex_put
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2668              		.loc 1 864 0
 2669 16b0 18409DE5 		ldr	r4, [sp, #24]
 866:../uvc.c      **** 							 break;
 2670              		.loc 1 866 0
 2671 16b4 FFE0A0E3 		mov	lr, #255
 864:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2672              		.loc 1 864 0
 2673 16b8 1D42C6E5 		strb	r4, [r6, #541]
 865:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2674              		.loc 1 865 0
 2675 16bc 0430A0E1 		mov	r3, r4
 2676 16c0 2072C6E5 		strb	r7, [r6, #544]
 2677 16c4 1CC09DE5 		ldr	ip, [sp, #28]
 866:../uvc.c      **** 							 break;
 2678              		.loc 1 866 0
 2679 16c8 0E40A0E1 		mov	r4, lr
 2680 16cc 70FDFFEA 		b	.L122
 2681              	.LVL211:
 2682              	.L162:
 839:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2683              		.loc 1 839 0
 2684 16d0 5C449FE5 		ldr	r4, .L228+36
 2685 16d4 0010E0E3 		mvn	r1, #0
 2686 16d8 1C0094E5 		ldr	r0, [r4, #28]
 2687 16dc FEFFFFEB 		bl	_txe_mutex_get
 2688              	.LVL212:
 840:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2689              		.loc 1 840 0
 2690 16e0 18009DE5 		ldr	r0, [sp, #24]
 2691 16e4 00C0A0E3 		mov	ip, #0
 2692 16e8 803040E2 		sub	r3, r0, #128
 2693 16ec FF7003E2 		and	r7, r3, #255
 2694              	.LVL213:
 2695 16f0 0510A0E3 		mov	r1, #5
 2696 16f4 0920A0E1 		mov	r2, r9
 2697 16f8 0A30A0E1 		mov	r3, sl
 2698 16fc 0400A0E1 		mov	r0, r4
 2699 1700 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2700 1704 FEFFFFEB 		bl	cmdSet
 2701              	.LVL214:
 842:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2702              		.loc 1 842 0
 2703 1708 18109DE5 		ldr	r1, [sp, #24]
 2704 170c DC20A0E3 		mov	r2, #220
 2705 1710 767041E2 		sub	r7, r1, #118
 2706 1714 FFE007E2 		and	lr, r7, #255
 2707 1718 0510A0E3 		mov	r1, #5
 2708 171c 0170A0E3 		mov	r7, #1
 2709 1720 0A30A0E1 		mov	r3, sl
 2710 1724 0400A0E1 		mov	r0, r4
 2711 1728 00E08DE5 		str	lr, [sp, #0]
 2712 172c 04708DE5 		str	r7, [sp, #4]
 2713 1730 FEFFFFEB 		bl	cmdSet
 2714              	.LVL215:
 844:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2715              		.loc 1 844 0
 2716 1734 18209DE5 		ldr	r2, [sp, #24]
 2717 1738 0510A0E3 		mov	r1, #5
 2718 173c 7E0082E2 		add	r0, r2, #126
 2719 1740 FFC000E2 		and	ip, r0, #255
 2720 1744 DE20A0E3 		mov	r2, #222
 2721 1748 0A30A0E1 		mov	r3, sl
 2722 174c 0400A0E1 		mov	r0, r4
 2723 1750 00C08DE5 		str	ip, [sp, #0]
 2724 1754 02C0A0E3 		mov	ip, #2
 2725 1758 04C08DE5 		str	ip, [sp, #4]
 2726 175c FEFFFFEB 		bl	cmdSet
 2727              	.LVL216:
 846:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2728              		.loc 1 846 0
 2729 1760 18309DE5 		ldr	r3, [sp, #24]
 2730 1764 E020A0E3 		mov	r2, #224
 2731 1768 721083E2 		add	r1, r3, #114
 2732 176c FFC001E2 		and	ip, r1, #255
 2733 1770 0A30A0E1 		mov	r3, sl
 2734 1774 0510A0E3 		mov	r1, #5
 2735 1778 0400A0E1 		mov	r0, r4
 2736 177c 00C08DE5 		str	ip, [sp, #0]
 2737 1780 03C0A0E3 		mov	ip, #3
 2738 1784 04C08DE5 		str	ip, [sp, #4]
 2739 1788 FEFFFFEB 		bl	cmdSet
 2740              	.LVL217:
 848:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2741              		.loc 1 848 0
 2742 178c 18209DE5 		ldr	r2, [sp, #24]
 2743 1790 0510A0E3 		mov	r1, #5
 2744 1794 6F0042E2 		sub	r0, r2, #111
 2745 1798 FFC000E2 		and	ip, r0, #255
 2746 179c DD20A0E3 		mov	r2, #221
 2747 17a0 0A30A0E1 		mov	r3, sl
 2748 17a4 0400A0E1 		mov	r0, r4
 2749 17a8 00C08DE5 		str	ip, [sp, #0]
 2750 17ac 04C0A0E3 		mov	ip, #4
 2751 17b0 04C08DE5 		str	ip, [sp, #4]
 2752 17b4 FEFFFFEB 		bl	cmdSet
 2753              	.LVL218:
 850:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2754              		.loc 1 850 0
 2755 17b8 5C339FE5 		ldr	r3, .L228+12
 2756 17bc 05E0A0E3 		mov	lr, #5
 2757 17c0 5C10D3E5 		ldrb	r1, [r3, #92]	@ zero_extendqisi2
 2758 17c4 0400A0E1 		mov	r0, r4
 2759 17c8 7F2081E2 		add	r2, r1, #127
 2760 17cc FFC002E2 		and	ip, r2, #255
 2761 17d0 0E10A0E1 		mov	r1, lr
 2762 17d4 0A30A0E1 		mov	r3, sl
 2763 17d8 0B20A0E1 		mov	r2, fp
 2764 17dc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2765 17e0 FEFFFFEB 		bl	cmdSet
 851:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2766              		.loc 1 851 0
 2767 17e4 1C0094E5 		ldr	r0, [r4, #28]
 2768 17e8 FEFFFFEB 		bl	_txe_mutex_put
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2769              		.loc 1 853 0
 2770 17ec 28039FE5 		ldr	r0, .L228+12
 855:../uvc.c      **** 							 break;
 2771              		.loc 1 855 0
 2772 17f0 FFE0A0E3 		mov	lr, #255
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2773              		.loc 1 853 0
 2774 17f4 5C30D0E5 		ldrb	r3, [r0, #92]	@ zero_extendqisi2
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2775              		.loc 1 854 0
 2776 17f8 0872C6E5 		strb	r7, [r6, #520]
 853:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2777              		.loc 1 853 0
 2778 17fc 801043E2 		sub	r1, r3, #128
 2779 1800 0512C6E5 		strb	r1, [r6, #517]
 854:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2780              		.loc 1 854 0
 2781 1804 18309DE5 		ldr	r3, [sp, #24]
 2782 1808 1CC09DE5 		ldr	ip, [sp, #28]
 855:../uvc.c      **** 							 break;
 2783              		.loc 1 855 0
 2784 180c 0E40A0E1 		mov	r4, lr
 2785 1810 1FFDFFEA 		b	.L122
 2786              	.LVL219:
 2787              	.L161:
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 2788              		.loc 1 886 0
 2789 1814 011043E2 		sub	r1, r3, #1
 2790 1818 0300A0E1 		mov	r0, r3
 2791              	.LVL220:
 887:../uvc.c      **** 							 is60Hz = Data0;
 2792              		.loc 1 887 0
 2793 181c F8229FE5 		ldr	r2, .L228+12
 2794              	.LVL221:
 886:../uvc.c      **** 							 Data0 = Data0 - 1;
 2795              		.loc 1 886 0
 2796 1820 FF3001E2 		and	r3, r1, #255
 2797              	.LVL222:
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2798              		.loc 1 899 0
 2799 1824 F0E29FE5 		ldr	lr, .L228+12
 893:../uvc.c      **** 							 else if(Data0 >2)
 2800              		.loc 1 893 0
 2801 1828 020053E3 		cmp	r3, #2
 885:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2802              		.loc 1 885 0
 2803 182c ED01C6E5 		strb	r0, [r6, #493]
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 2804              		.loc 1 896 0
 2805 1830 0100A083 		movhi	r0, #1
 887:../uvc.c      **** 							 is60Hz = Data0;
 2806              		.loc 1 887 0
 2807 1834 583082E5 		str	r3, [r2, #88]
 2808              	.LVL223:
 896:../uvc.c      **** 								 is60Hz = CyTrue;
 2809              		.loc 1 896 0
 2810 1838 58008285 		strhi	r0, [r2, #88]
 899:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 2811              		.loc 1 899 0
 2812 183c 28009EE5 		ldr	r0, [lr, #40]
 2813 1840 010050E3 		cmp	r0, #1
 2814 1844 8200000A 		beq	.L226
 2815              	.LVL224:
 2816              	.L192:
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2817              		.loc 1 925 0
 2818 1848 01C0A0E3 		mov	ip, #1
 926:../uvc.c      **** 							 break;
 2819              		.loc 1 926 0
 2820 184c FFE0A0E3 		mov	lr, #255
 925:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2821              		.loc 1 925 0
 2822 1850 F0C1C6E5 		strb	ip, [r6, #496]
 2823 1854 18309DE5 		ldr	r3, [sp, #24]
 2824 1858 1CC09DE5 		ldr	ip, [sp, #28]
 926:../uvc.c      **** 							 break;
 2825              		.loc 1 926 0
 2826 185c 0E40A0E1 		mov	r4, lr
 2827 1860 0BFDFFEA 		b	.L122
 2828              	.LVL225:
 2829              	.L160:
 821:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2830              		.loc 1 821 0
 2831 1864 C8429FE5 		ldr	r4, .L228+36
 2832 1868 0010E0E3 		mvn	r1, #0
 2833 186c 1C0094E5 		ldr	r0, [r4, #28]
 2834 1870 FEFFFFEB 		bl	_txe_mutex_get
 2835              	.LVL226:
 823:../uvc.c      **** 							  if(Data0&0x80){
 2836              		.loc 1 823 0
 2837 1874 18209DE5 		ldr	r2, [sp, #24]
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2838              		.loc 1 828 0
 2839 1878 00C0A0E3 		mov	ip, #0
 823:../uvc.c      **** 							  if(Data0&0x80){
 2840              		.loc 1 823 0
 2841 187c 800012E3 		tst	r2, #128
 824:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 2842              		.loc 1 824 0
 2843 1880 80704212 		subne	r7, r2, #128
 2844              	.LVL227:
 826:../uvc.c      **** 								  Data0 = ~Data0;
 2845              		.loc 1 826 0
 2846 1884 0270E001 		mvneq	r7, r2
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2847              		.loc 1 828 0
 2848 1888 0A30A0E1 		mov	r3, sl
 826:../uvc.c      **** 								  Data0 = ~Data0;
 2849              		.loc 1 826 0
 2850 188c FF7007E2 		and	r7, r7, #255
 2851              	.LVL228:
 828:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 2852              		.loc 1 828 0
 2853 1890 0110A0E3 		mov	r1, #1
 2854 1894 0B20A0E1 		mov	r2, fp
 2855 1898 94029FE5 		ldr	r0, .L228+36
 2856 189c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2857 18a0 FEFFFFEB 		bl	cmdSet
 829:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2858              		.loc 1 829 0
 2859 18a4 1C0094E5 		ldr	r0, [r4, #28]
 2860 18a8 FEFFFFEB 		bl	_txe_mutex_put
 835:../uvc.c      **** 							 break;
 2861              		.loc 1 835 0
 2862 18ac FFE0A0E3 		mov	lr, #255
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2863              		.loc 1 832 0
 2864 18b0 0100A0E3 		mov	r0, #1
 831:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2865              		.loc 1 831 0
 2866 18b4 A571C6E5 		strb	r7, [r6, #421]
 832:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2867              		.loc 1 832 0
 2868 18b8 A801C6E5 		strb	r0, [r6, #424]
 2869 18bc 18309DE5 		ldr	r3, [sp, #24]
 2870 18c0 1CC09DE5 		ldr	ip, [sp, #28]
 835:../uvc.c      **** 							 break;
 2871              		.loc 1 835 0
 2872 18c4 0E40A0E1 		mov	r4, lr
 2873 18c8 F1FCFFEA 		b	.L122
 2874              	.LVL229:
 2875              	.L158:
 949:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2876              		.loc 1 949 0
 2877 18cc 60729FE5 		ldr	r7, .L228+36
 2878              	.LVL230:
 2879 18d0 0010E0E3 		mvn	r1, #0
 2880 18d4 1C0097E5 		ldr	r0, [r7, #28]
 2881 18d8 FEFFFFEB 		bl	_txe_mutex_get
 2882              	.LVL231:
 950:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2883              		.loc 1 950 0
 2884 18dc 18C09DE5 		ldr	ip, [sp, #24]
 2885 18e0 0410A0E1 		mov	r1, r4
 2886 18e4 0A30A0E1 		mov	r3, sl
 2887 18e8 0920A0E1 		mov	r2, r9
 2888 18ec 00C08DE5 		str	ip, [sp, #0]
 2889 18f0 0700A0E1 		mov	r0, r7
 2890 18f4 00C0A0E3 		mov	ip, #0
 2891 18f8 04C08DE5 		str	ip, [sp, #4]
 2892 18fc FEFFFFEB 		bl	cmdSet
 951:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2893              		.loc 1 951 0
 2894 1900 1C0097E5 		ldr	r0, [r7, #28]
 2895 1904 FEFFFFEB 		bl	_txe_mutex_put
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2896              		.loc 1 953 0
 2897 1908 18109DE5 		ldr	r1, [sp, #24]
 2898 190c 844084E0 		add	r4, r4, r4, asl #1
 2899 1910 846186E0 		add	r6, r6, r4, asl #3
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2900              		.loc 1 954 0
 2901 1914 0130A0E3 		mov	r3, #1
 955:../uvc.c      **** 							 break;
 2902              		.loc 1 955 0
 2903 1918 FFE0A0E3 		mov	lr, #255
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2904              		.loc 1 954 0
 2905 191c 9031C6E5 		strb	r3, [r6, #400]
 953:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2906              		.loc 1 953 0
 2907 1920 8D11C6E5 		strb	r1, [r6, #397]
 954:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2908              		.loc 1 954 0
 2909 1924 0130A0E1 		mov	r3, r1
 2910 1928 1CC09DE5 		ldr	ip, [sp, #28]
 955:../uvc.c      **** 							 break;
 2911              		.loc 1 955 0
 2912 192c 0E40A0E1 		mov	r4, lr
 2913 1930 D7FCFFEA 		b	.L122
 2914              	.LVL232:
 2915              	.L159:
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2916              		.loc 1 930 0
 2917 1934 E0219FE5 		ldr	r2, .L228+12
 2918              	.LVL233:
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2919              		.loc 1 929 0
 2920 1938 0100A0E3 		mov	r0, #1
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2921              		.loc 1 930 0
 2922 193c 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 928:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2923              		.loc 1 928 0
 2924 1940 8D31C6E5 		strb	r3, [r6, #397]
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2925              		.loc 1 930 0
 2926 1944 010052E3 		cmp	r2, #1
 929:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2927              		.loc 1 929 0
 2928 1948 9001C6E5 		strb	r0, [r6, #400]
 2929 194c 0370A011 		movne	r7, r3
 2930              	.LVL234:
 930:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2931              		.loc 1 930 0
 2932 1950 3500000A 		beq	.L227
 2933              	.LVL235:
 2934              	.L199:
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2935              		.loc 1 941 0
 2936 1954 D8419FE5 		ldr	r4, .L228+36
 2937 1958 0010E0E3 		mvn	r1, #0
 2938 195c 1C0094E5 		ldr	r0, [r4, #28]
 939:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2939              		.loc 1 939 0
 2940 1960 2D74C6E5 		strb	r7, [r6, #1069]
 2941              	.LVL236:
 941:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2942              		.loc 1 941 0
 2943 1964 FEFFFFEB 		bl	_txe_mutex_get
 942:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2944              		.loc 1 942 0
 2945 1968 00C0A0E3 		mov	ip, #0
 2946 196c 0C10A0E1 		mov	r1, ip
 2947 1970 0920A0E1 		mov	r2, r9
 2948 1974 0A30A0E1 		mov	r3, sl
 2949 1978 0400A0E1 		mov	r0, r4
 2950 197c 00708DE5 		str	r7, [sp, #0]
 2951 1980 ECFEFFEA 		b	.L218
 2952              	.LVL237:
 2953              	.L157:
 958:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2954              		.loc 1 958 0
 2955 1984 0400A0E3 		mov	r0, #4
 2956              	.LVL238:
 2957 1988 B0119FE5 		ldr	r1, .L228+48
 2958 198c FEFFFFEB 		bl	CyU3PDebugPrint
 2959              	.LVL239:
 2960 1990 FFE0A0E3 		mov	lr, #255
 2961 1994 0E40A0E1 		mov	r4, lr
 2962 1998 0EC0A0E1 		mov	ip, lr
 2963 199c 0E30A0E1 		mov	r3, lr
 2964 19a0 BBFCFFEA 		b	.L122
 2965              	.LVL240:
 2966              	.L225:
 478:../uvc.c      **** 						if(sendData >= 3){
 2967              		.loc 1 478 0
 2968 19a4 020054E3 		cmp	r4, #2
 2969 19a8 04408492 		addls	r4, r4, #4
 2970              	.LVL241:
 2971 19ac FF400492 		andls	r4, r4, #255
 2972 19b0 E2FDFF9A 		bls	.L135
 479:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2973              		.loc 1 479 0
 2974 19b4 0430A0E1 		mov	r3, r4
 2975 19b8 0400A0E3 		mov	r0, #4
 2976 19bc 80119FE5 		ldr	r1, .L228+52
 2977 19c0 FEFFFFEB 		bl	CyU3PDebugPrint
 2978              	.LVL242:
 481:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2979              		.loc 1 481 0
 2980 19c4 44319FE5 		ldr	r3, .L228
 2981 19c8 0020A0E3 		mov	r2, #0
 2982 19cc 0440A0E3 		mov	r4, #4
 2983 19d0 2D24C3E5 		strb	r2, [r3, #1069]
 2984              	.LVL243:
 2985 19d4 D9FDFFEA 		b	.L135
 2986              	.LVL244:
 2987              	.L176:
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2988              		.loc 1 674 0
 2989 19d8 B924D3E5 		ldrb	r2, [r3, #1209]	@ zero_extendqisi2
 2990              	.LVL245:
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 2991              		.loc 1 673 0
 2992 19dc 014041E2 		sub	r4, r1, #1
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2993              		.loc 1 674 0
 2994 19e0 040052E3 		cmp	r2, #4
 2995 19e4 01005213 		cmpne	r2, #1
 673:../uvc.c      **** 								 Data1 = Data0 - 1;
 2996              		.loc 1 673 0
 2997 19e8 FF1004E2 		and	r1, r4, #255
 2998              	.LVL246:
 674:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2999              		.loc 1 674 0
 3000 19ec 0300000A 		beq	.L179
 675:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 3001              		.loc 1 675 0
 3002 19f0 080052E3 		cmp	r2, #8
 676:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 3003              		.loc 1 676 0
 3004 19f4 0120A003 		moveq	r2, #1
 678:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 3005              		.loc 1 678 0
 3006 19f8 0420A013 		movne	r2, #4
 3007 19fc B924C3E5 		strb	r2, [r3, #1209]
 3008              	.L179:
 681:../uvc.c      **** 								 if(Data1 < 8){
 3009              		.loc 1 681 0
 3010 1a00 070051E3 		cmp	r1, #7
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3011              		.loc 1 682 0
 3012 1a04 3C319F95 		ldrls	r3, .L228+56
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3013              		.loc 1 685 0
 3014 1a08 0130A083 		movhi	r3, #1
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3015              		.loc 1 683 0
 3016 1a0c 81008390 		addls	r0, r3, r1, asl #1
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3017              		.loc 1 682 0
 3018 1a10 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 683:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 3019              		.loc 1 683 0
 3020 1a14 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 685:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 3021              		.loc 1 685 0
 3022 1a18 E934C685 		strhib	r3, [r6, #1257]
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3023              		.loc 1 686 0
 3024 1a1c 0030A083 		movhi	r3, #0
 682:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 3025              		.loc 1 682 0
 3026 1a20 E924C695 		strlsb	r2, [r6, #1257]
 686:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 3027              		.loc 1 686 0
 3028 1a24 EA34C6E5 		strb	r3, [r6, #1258]
 3029 1a28 B5FEFFEA 		b	.L177
 3030              	.LVL247:
 3031              	.L227:
 932:../uvc.c      **** 								 if(Data0 < 3){
 3032              		.loc 1 932 0
 3033 1a2c 020053E3 		cmp	r3, #2
 933:../uvc.c      **** 					 				 Data0 += 4;
 3034              		.loc 1 933 0
 3035 1a30 04708392 		addls	r7, r3, #4
 3036 1a34 FF700792 		andls	r7, r7, #255
 932:../uvc.c      **** 								 if(Data0 < 3){
 3037              		.loc 1 932 0
 3038 1a38 C5FFFF9A 		bls	.L199
 935:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3039              		.loc 1 935 0
 3040 1a3c 0400A0E3 		mov	r0, #4
 3041 1a40 FC109FE5 		ldr	r1, .L228+52
 3042 1a44 18309DE5 		ldr	r3, [sp, #24]
 3043 1a48 FEFFFFEB 		bl	CyU3PDebugPrint
 3044              	.LVL248:
 936:../uvc.c      **** 									Data0 = 4; //set to default.
 3045              		.loc 1 936 0
 3046 1a4c 0470A0E3 		mov	r7, #4
 3047 1a50 BFFFFFEA 		b	.L199
 3048              	.LVL249:
 3049              	.L226:
 902:../uvc.c      **** 			                       switch (setRes)
 3050              		.loc 1 902 0
 3051 1a54 7D10DEE5 		ldrb	r1, [lr, #125]	@ zero_extendqisi2
 3052 1a58 020051E3 		cmp	r1, #2
 3053 1a5c 1C00000A 		beq	.L194
 3054 1a60 030051E3 		cmp	r1, #3
 3055 1a64 0E00000A 		beq	.L195
 3056 1a68 010051E3 		cmp	r1, #1
 3057 1a6c 75FFFF1A 		bne	.L192
 905:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3058              		.loc 1 905 0
 3059 1a70 58209EE5 		ldr	r2, [lr, #88]
 3060 1a74 0100A0E1 		mov	r0, r1
 3061 1a78 000052E3 		cmp	r2, #0
 3062 1a7c 2F1081E2 		add	r1, r1, #47
 3063 1a80 E420A003 		moveq	r2, #228
 3064 1a84 6420A013 		movne	r2, #100
 3065 1a88 5230A0E3 		mov	r3, #82
 3066 1a8c FEFFFFEB 		bl	SensorSetIrisControl
 3067              	.LVL250:
 906:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3068              		.loc 1 906 0
 3069 1a90 7D0FA0E3 		mov	r0, #500
 3070 1a94 FEFFFFEB 		bl	_tx_thread_sleep
 908:../uvc.c      **** 			                         		break;
 3071              		.loc 1 908 0
 3072 1a98 6AFFFFEA 		b	.L192
 3073              	.LVL251:
 3074              	.L216:
 3075 1a9c 78009FE5 		ldr	r0, .L228+12
 3076 1aa0 95FDFFEA 		b	.L133
 3077              	.LVL252:
 3078              	.L195:
 915:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3079              		.loc 1 915 0
 3080 1aa4 58409EE5 		ldr	r4, [lr, #88]
 3081 1aa8 8CE4D6E5 		ldrb	lr, [r6, #1164]	@ zero_extendqisi2
 3082 1aac 000054E3 		cmp	r4, #0
 3083 1ab0 C440A003 		moveq	r4, #196
 3084 1ab4 4440A013 		movne	r4, #68
 3085 1ab8 3010A0E3 		mov	r1, #48
 3086 1abc 0E2084E1 		orr	r2, r4, lr
 3087 1ac0 5230A0E3 		mov	r3, #82
 3088 1ac4 FEFFFFEB 		bl	SensorSetIrisControl
 3089              	.LVL253:
 916:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3090              		.loc 1 916 0
 3091 1ac8 7D0FA0E3 		mov	r0, #500
 3092 1acc FEFFFFEB 		bl	_tx_thread_sleep
 918:../uvc.c      **** 			                         		break;
 3093              		.loc 1 918 0
 3094 1ad0 5CFFFFEA 		b	.L192
 3095              	.LVL254:
 3096              	.L194:
 910:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3097              		.loc 1 910 0
 3098 1ad4 58209EE5 		ldr	r2, [lr, #88]
 3099 1ad8 3010A0E3 		mov	r1, #48
 3100 1adc 000052E3 		cmp	r2, #0
 3101 1ae0 D420A003 		moveq	r2, #212
 3102 1ae4 5420A013 		movne	r2, #84
 3103 1ae8 5230A0E3 		mov	r3, #82
 3104 1aec FEFFFFEB 		bl	SensorSetIrisControl
 3105              	.LVL255:
 911:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3106              		.loc 1 911 0
 3107 1af0 7D0FA0E3 		mov	r0, #500
 3108 1af4 FEFFFFEB 		bl	_tx_thread_sleep
 913:../uvc.c      **** 			                         		break;
 3109              		.loc 1 913 0
 3110 1af8 52FFFFEA 		b	.L192
 3111              	.LVL256:
 3112              	.L202:
 422:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3113              		.loc 1 422 0
 3114 1afc 0030A0E3 		mov	r3, #0
 3115 1b00 1FFEFFEA 		b	.L209
 3116              	.LVL257:
 3117              	.L201:
 3118 1b04 10009FE5 		ldr	r0, .L228+12
 3119 1b08 0030A0E3 		mov	r3, #0
 3120 1b0c 73FDFFEA 		b	.L208
 3121              	.L229:
 3122              		.align	2
 3123              	.L228:
 3124 1b10 00000000 		.word	.LANCHOR1
 3125 1b14 00000000 		.word	bRequest
 3126 1b18 70030000 		.word	.LC21
 3127 1b1c 00000000 		.word	.LANCHOR0
 3128 1b20 5C000000 		.word	.LANCHOR0+92
 3129 1b24 01000100 		.word	65537
 3130 1b28 FF00FF00 		.word	16711935
 3131 1b2c B0020000 		.word	.LC17
 3132 1b30 EC020000 		.word	.LC18
 3133 1b34 00000000 		.word	cmdQu
 3134 1b38 4C000000 		.word	.LANCHOR0+76
 3135 1b3c 14030000 		.word	.LC19
 3136 1b40 40030000 		.word	.LC20
 3137 1b44 78020000 		.word	.LC16
 3138 1b48 00000000 		.word	.LANCHOR2
 3139              		.cfi_endproc
 3140              	.LFE2:
 3142              		.align	2
 3143              		.global	CTControlHandle
 3145              	CTControlHandle:
 3146              	.LFB3:
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3147              		.loc 1 974 0
 3148              		.cfi_startproc
 3149              		@ args = 0, pretend = 0, frame = 64
 3150              		@ frame_needed = 0, uses_anonymous_args = 0
 3151              	.LVL258:
 3152 1b4c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3153              	.LCFI15:
 3154              		.cfi_def_cfa_offset 36
 993:../uvc.c      ****     reqData = bRequest;
 3155              		.loc 1 993 0
 3156 1b50 60A99FE5 		ldr	sl, .L315
 3157              		.cfi_offset 14, -4
 3158              		.cfi_offset 11, -8
 3159              		.cfi_offset 10, -12
 3160              		.cfi_offset 9, -16
 3161              		.cfi_offset 8, -20
 3162              		.cfi_offset 7, -24
 3163              		.cfi_offset 6, -28
 3164              		.cfi_offset 5, -32
 3165              		.cfi_offset 4, -36
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3166              		.loc 1 985 0
 3167 1b54 60899FE5 		ldr	r8, .L315+4
 993:../uvc.c      ****     reqData = bRequest;
 3168              		.loc 1 993 0
 3169 1b58 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3170              		.loc 1 985 0
 3171 1b5c 8090A0E1 		mov	r9, r0, asl #1
 3172 1b60 002089E0 		add	r2, r9, r0
 3173 1b64 822188E0 		add	r2, r8, r2, asl #3
 995:../uvc.c      ****     switch (bRequest)
 3174              		.loc 1 995 0
 3175 1b68 830055E3 		cmp	r5, #131
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3176              		.loc 1 974 0
 3177 1b6c 5CD04DE2 		sub	sp, sp, #92
 3178              	.LCFI16:
 3179              		.cfi_def_cfa_offset 128
 974:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3180              		.loc 1 974 0
 3181 1b70 0060A0E1 		mov	r6, r0
 985:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3182              		.loc 1 985 0
 3183 1b74 A334D2E5 		ldrb	r3, [r2, #1187]	@ zero_extendqisi2
 3184              	.LVL259:
 986:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3185              		.loc 1 986 0
 3186 1b78 94B4D2E5 		ldrb	fp, [r2, #1172]	@ zero_extendqisi2
 3187              	.LVL260:
 988:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3188              		.loc 1 988 0
 3189 1b7c 9674D2E5 		ldrb	r7, [r2, #1174]	@ zero_extendqisi2
 3190              	.LVL261:
 995:../uvc.c      ****     switch (bRequest)
 3191              		.loc 1 995 0
 3192 1b80 7600000A 		beq	.L235
 3193 1b84 2100009A 		bls	.L310
 3194 1b88 850055E3 		cmp	r5, #133
 3195 1b8c 5900000A 		beq	.L237
 3196 1b90 4E00003A 		bcc	.L236
 3197 1b94 860055E3 		cmp	r5, #134
 3198 1b98 8000000A 		beq	.L238
 3199 1b9c 870055E3 		cmp	r5, #135
 3200 1ba0 7600000A 		beq	.L311
 3201              	.L231:
1202:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3202              		.loc 1 1202 0
 3203 1ba4 0000A0E3 		mov	r0, #0
 3204              	.LVL262:
 3205 1ba8 0110A0E3 		mov	r1, #1
 3206 1bac 0020A0E1 		mov	r2, r0
 3207 1bb0 FEFFFFEB 		bl	CyU3PUsbStall
 3208              	.LVL263:
 3209 1bb4 04499FE5 		ldr	r4, .L315+8
1203:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3210              		.loc 1 1203 0
 3211 1bb8 0620A0E1 		mov	r2, r6
 3212 1bbc 0400A0E3 		mov	r0, #4
 3213 1bc0 FC189FE5 		ldr	r1, .L315+12
 3214 1bc4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3215 1bc8 FEFFFFEB 		bl	CyU3PDebugPrint
1204:../uvc.c      **** 			  break;
 3216              		.loc 1 1204 0
 3217 1bcc FFC0A0E3 		mov	ip, #255
 3218 1bd0 0C60A0E1 		mov	r6, ip
 3219 1bd4 0C80A0E1 		mov	r8, ip
 3220              	.LVL264:
 3221              	.L241:
1208:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3222              		.loc 1 1208 0
 3223 1bd8 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 3224 1bdc 08C08DE5 		str	ip, [sp, #8]
 3225 1be0 E0189FE5 		ldr	r1, .L315+16
 3226 1be4 FFC0A0E3 		mov	ip, #255
 3227 1be8 0520A0E1 		mov	r2, r5
 3228 1bec 0830A0E1 		mov	r3, r8
 3229 1bf0 0400A0E3 		mov	r0, #4
 3230 1bf4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3231 1bf8 0CC08DE5 		str	ip, [sp, #12]
 3232 1bfc 10E08DE5 		str	lr, [sp, #16]
 3233 1c00 14708DE5 		str	r7, [sp, #20]
 3234 1c04 FEFFFFEB 		bl	CyU3PDebugPrint
1209:../uvc.c      **** }
 3235              		.loc 1 1209 0
 3236 1c08 5CD08DE2 		add	sp, sp, #92
 3237 1c0c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3238              	.LVL265:
 3239              	.L310:
 995:../uvc.c      ****     switch (bRequest)
 3240              		.loc 1 995 0
 3241 1c10 810055E3 		cmp	r5, #129
 3242 1c14 4200000A 		beq	.L233
 3243 1c18 1100009A 		bls	.L312
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3244              		.loc 1 1024 0
 3245 1c1c 9C489FE5 		ldr	r4, .L315+8
 3246 1c20 9714D2E5 		ldrb	r1, [r2, #1175]	@ zero_extendqisi2
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3247              		.loc 1 1025 0
 3248 1c24 9864D2E5 		ldrb	r6, [r2, #1176]	@ zero_extendqisi2
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3249              		.loc 1 1026 0
 3250 1c28 0A0050E3 		cmp	r0, #10
1024:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3251              		.loc 1 1024 0
 3252 1c2c 5C10C4E5 		strb	r1, [r4, #92]
1025:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3253              		.loc 1 1025 0
 3254 1c30 5D60C4E5 		strb	r6, [r4, #93]
1026:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3255              		.loc 1 1026 0
 3256 1c34 2C00000A 		beq	.L309
 3257              	.LVL266:
 3258              	.L248:
1060:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3259              		.loc 1 1060 0
 3260 1c38 00E0A0E3 		mov	lr, #0
 3261 1c3c 5EE0C4E5 		strb	lr, [r4, #94]
 3262              	.L249:
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3263              		.loc 1 1061 0
 3264 1c40 0030A0E3 		mov	r3, #0
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3265              		.loc 1 1062 0
 3266 1c44 0700A0E1 		mov	r0, r7
 3267              	.LVL267:
 3268 1c48 7C189FE5 		ldr	r1, .L315+20
1064:../uvc.c      **** 			  break;
 3269              		.loc 1 1064 0
 3270 1c4c FF60A0E3 		mov	r6, #255
1061:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3271              		.loc 1 1061 0
 3272 1c50 5F30C4E5 		strb	r3, [r4, #95]
1064:../uvc.c      **** 			  break;
 3273              		.loc 1 1064 0
 3274 1c54 0680A0E1 		mov	r8, r6
1062:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3275              		.loc 1 1062 0
 3276 1c58 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3277              	.LVL268:
 3278 1c5c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1064:../uvc.c      **** 			  break;
 3279              		.loc 1 1064 0
 3280 1c60 DCFFFFEA 		b	.L241
 3281              	.LVL269:
 3282              	.L312:
 995:../uvc.c      ****     switch (bRequest)
 3283              		.loc 1 995 0
 3284 1c64 010055E3 		cmp	r5, #1
 3285 1c68 CDFFFF1A 		bne	.L231
1066:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3286              		.loc 1 1066 0
 3287 1c6c 4C489FE5 		ldr	r4, .L315+8
 3288 1c70 56208DE2 		add	r2, sp, #86
 3289 1c74 2000A0E3 		mov	r0, #32
 3290              	.LVL270:
 3291 1c78 5C1084E2 		add	r1, r4, #92
 3292 1c7c 2C308DE5 		str	r3, [sp, #44]
 3293 1c80 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3294              	.LVL271:
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3295              		.loc 1 1068 0
 3296 1c84 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3297              		.loc 1 1069 0
 3298 1c88 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1072:../uvc.c      **** 			  switch(CtrlID)
 3299              		.loc 1 1072 0
 3300 1c8c 012046E2 		sub	r2, r6, #1
1068:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3301              		.loc 1 1068 0
 3302 1c90 30008DE5 		str	r0, [sp, #48]
 3303              	.LVL272:
1069:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3304              		.loc 1 1069 0
 3305 1c94 34C08DE5 		str	ip, [sp, #52]
 3306              	.LVL273:
1072:../uvc.c      **** 			  switch(CtrlID)
 3307              		.loc 1 1072 0
 3308 1c98 2C309DE5 		ldr	r3, [sp, #44]
 3309 1c9c 090052E3 		cmp	r2, #9
 3310 1ca0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3311 1ca4 550100EA 		b	.L250
 3312              	.L255:
 3313 1ca8 BC210000 		.word	.L251
 3314 1cac 00220000 		.word	.L250
 3315 1cb0 CC1E0000 		.word	.L252
 3316 1cb4 00220000 		.word	.L250
 3317 1cb8 00220000 		.word	.L250
 3318 1cbc 00220000 		.word	.L250
 3319 1cc0 481E0000 		.word	.L253
 3320 1cc4 00220000 		.word	.L250
 3321 1cc8 00220000 		.word	.L250
 3322 1ccc CC1D0000 		.word	.L254
 3323              	.LVL274:
 3324              	.L236:
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3325              		.loc 1 1042 0
 3326 1cd0 E8479FE5 		ldr	r4, .L315+8
 3327 1cd4 9B84D2E5 		ldrb	r8, [r2, #1179]	@ zero_extendqisi2
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3328              		.loc 1 1043 0
 3329 1cd8 9C24D2E5 		ldrb	r2, [r2, #1180]	@ zero_extendqisi2
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3330              		.loc 1 1044 0
 3331 1cdc 0A0050E3 		cmp	r0, #10
1042:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3332              		.loc 1 1042 0
 3333 1ce0 5C80C4E5 		strb	r8, [r4, #92]
1043:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3334              		.loc 1 1043 0
 3335 1ce4 5D20C4E5 		strb	r2, [r4, #93]
1044:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3336              		.loc 1 1044 0
 3337 1ce8 D2FFFF1A 		bne	.L248
 3338              	.LVL275:
 3339              	.L309:
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3340              		.loc 1 1059 0 discriminator 1
 3341 1cec 0110A0E3 		mov	r1, #1
 3342 1cf0 5E10C4E5 		strb	r1, [r4, #94]
 3343 1cf4 D1FFFFEA 		b	.L249
 3344              	.LVL276:
 3345              	.L237:
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3346              		.loc 1 999 0
 3347 1cf8 C0479FE5 		ldr	r4, .L315+8
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3348              		.loc 1 1000 0
 3349 1cfc 0030A0E3 		mov	r3, #0
 3350              	.LVL277:
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3351              		.loc 1 1001 0
 3352 1d00 0200A0E3 		mov	r0, #2
 3353              	.LVL278:
 3354 1d04 5C1084E2 		add	r1, r4, #92
1003:../uvc.c      **** 			  break;
 3355              		.loc 1 1003 0
 3356 1d08 FF60A0E3 		mov	r6, #255
 999:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3357              		.loc 1 999 0
 3358 1d0c 5C70C4E5 		strb	r7, [r4, #92]
1000:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3359              		.loc 1 1000 0
 3360 1d10 5D30C4E5 		strb	r3, [r4, #93]
1003:../uvc.c      **** 			  break;
 3361              		.loc 1 1003 0
 3362 1d14 0680A0E1 		mov	r8, r6
1001:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3363              		.loc 1 1001 0
 3364 1d18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3365              	.LVL279:
 3366 1d1c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1003:../uvc.c      **** 			  break;
 3367              		.loc 1 1003 0
 3368 1d20 ACFFFFEA 		b	.L241
 3369              	.LVL280:
 3370              	.L233:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3371              		.loc 1 1009 0
 3372 1d24 94479FE5 		ldr	r4, .L315+8
 3373 1d28 A1A4D2E5 		ldrb	sl, [r2, #1185]	@ zero_extendqisi2
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3374              		.loc 1 1010 0
 3375 1d2c A2C4D2E5 		ldrb	ip, [r2, #1186]	@ zero_extendqisi2
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3376              		.loc 1 1011 0
 3377 1d30 0080A0E3 		mov	r8, #0
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3378              		.loc 1 1017 0
 3379 1d34 0700A0E1 		mov	r0, r7
 3380              	.LVL281:
 3381 1d38 5C1084E2 		add	r1, r4, #92
1022:../uvc.c      **** 			  break;
 3382              		.loc 1 1022 0
 3383 1d3c FF60A0E3 		mov	r6, #255
1010:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3384              		.loc 1 1010 0
 3385 1d40 5DC0C4E5 		strb	ip, [r4, #93]
1011:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3386              		.loc 1 1011 0
 3387 1d44 5E80C4E5 		strb	r8, [r4, #94]
1012:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3388              		.loc 1 1012 0
 3389 1d48 5F80C4E5 		strb	r8, [r4, #95]
 3390              	.LVL282:
1009:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3391              		.loc 1 1009 0
 3392 1d4c 5CA0C4E5 		strb	sl, [r4, #92]
1022:../uvc.c      **** 			  break;
 3393              		.loc 1 1022 0
 3394 1d50 0680A0E1 		mov	r8, r6
1017:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3395              		.loc 1 1017 0
 3396 1d54 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3397              	.LVL283:
 3398 1d58 0AC0A0E1 		mov	ip, sl
1022:../uvc.c      **** 			  break;
 3399              		.loc 1 1022 0
 3400 1d5c 9DFFFFEA 		b	.L241
 3401              	.LVL284:
 3402              	.L235:
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3403              		.loc 1 1033 0
 3404 1d60 58479FE5 		ldr	r4, .L315+8
 3405 1d64 9934D2E5 		ldrb	r3, [r2, #1177]	@ zero_extendqisi2
 3406              	.LVL285:
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3407              		.loc 1 1034 0
 3408 1d68 9AE4D2E5 		ldrb	lr, [r2, #1178]	@ zero_extendqisi2
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3409              		.loc 1 1035 0
 3410 1d6c 0A0050E3 		cmp	r0, #10
1033:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3411              		.loc 1 1033 0
 3412 1d70 5C30C4E5 		strb	r3, [r4, #92]
1034:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3413              		.loc 1 1034 0
 3414 1d74 5DE0C4E5 		strb	lr, [r4, #93]
1035:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3415              		.loc 1 1035 0
 3416 1d78 AEFFFF1A 		bne	.L248
 3417 1d7c DAFFFFEA 		b	.L309
 3418              	.LVL286:
 3419              	.L311:
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3420              		.loc 1 1057 0
 3421 1d80 38479FE5 		ldr	r4, .L315+8
 3422 1d84 9F64D2E5 		ldrb	r6, [r2, #1183]	@ zero_extendqisi2
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3423              		.loc 1 1058 0
 3424 1d88 A0C4D2E5 		ldrb	ip, [r2, #1184]	@ zero_extendqisi2
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3425              		.loc 1 1059 0
 3426 1d8c 0A0050E3 		cmp	r0, #10
1057:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3427              		.loc 1 1057 0
 3428 1d90 5C60C4E5 		strb	r6, [r4, #92]
1058:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3429              		.loc 1 1058 0
 3430 1d94 5DC0C4E5 		strb	ip, [r4, #93]
1059:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3431              		.loc 1 1059 0
 3432 1d98 A6FFFF1A 		bne	.L248
 3433 1d9c D2FFFFEA 		b	.L309
 3434              	.L238:
1051:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3435              		.loc 1 1051 0
 3436 1da0 18479FE5 		ldr	r4, .L315+8
 3437 1da4 9D04D2E5 		ldrb	r0, [r2, #1181]	@ zero_extendqisi2
 3438              	.LVL287:
 3439 1da8 0410A0E1 		mov	r1, r4
 3440 1dac 5C00E1E5 		strb	r0, [r1, #92]!
1055:../uvc.c      **** 			  break;
 3441              		.loc 1 1055 0
 3442 1db0 FF60A0E3 		mov	r6, #255
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3443              		.loc 1 1052 0
 3444 1db4 0100A0E3 		mov	r0, #1
 3445 1db8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3446              	.LVL288:
1055:../uvc.c      **** 			  break;
 3447              		.loc 1 1055 0
 3448 1dbc 0680A0E1 		mov	r8, r6
1052:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3449              		.loc 1 1052 0
 3450 1dc0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1055:../uvc.c      **** 			  break;
 3451              		.loc 1 1055 0
 3452 1dc4 0170A0E3 		mov	r7, #1
 3453 1dc8 82FFFFEA 		b	.L241
 3454              	.LVL289:
 3455              	.L254:
1181:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3456              		.loc 1 1181 0
 3457 1dcc FC669FE5 		ldr	r6, .L315+24
 3458 1dd0 0010E0E3 		mvn	r1, #0
 3459 1dd4 1C0096E5 		ldr	r0, [r6, #28]
 3460 1dd8 2C308DE5 		str	r3, [sp, #44]
 3461 1ddc FEFFFFEB 		bl	_txe_mutex_get
1182:../uvc.c      **** 					  if(getData == 1)
 3462              		.loc 1 1182 0
 3463 1de0 30E09DE5 		ldr	lr, [sp, #48]
 3464 1de4 2C309DE5 		ldr	r3, [sp, #44]
 3465 1de8 01005EE3 		cmp	lr, #1
 3466 1dec A901000A 		beq	.L313
1184:../uvc.c      **** 					  else if(getData == 0xff)
 3467              		.loc 1 1184 0
 3468 1df0 FF005EE3 		cmp	lr, #255
 3469 1df4 9E01000A 		beq	.L314
1187:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3470              		.loc 1 1187 0
 3471 1df8 0080A0E3 		mov	r8, #0
 3472 1dfc 0600A0E1 		mov	r0, r6
 3473 1e00 1710A0E3 		mov	r1, #23
 3474 1e04 0B20A0E1 		mov	r2, fp
 3475 1e08 00808DE5 		str	r8, [sp, #0]
 3476 1e0c 04808DE5 		str	r8, [sp, #4]
 3477 1e10 FEFFFFEB 		bl	cmdSet
 3478              	.L307:
1190:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3479              		.loc 1 1190 0
 3480 1e14 1C0096E5 		ldr	r0, [r6, #28]
 3481 1e18 FEFFFFEB 		bl	_txe_mutex_put
1192:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3482              		.loc 1 1192 0
 3483 1e1c 30809DE5 		ldr	r8, [sp, #48]
 3484 1e20 34609DE5 		ldr	r6, [sp, #52]
 3485 1e24 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 3486 1e28 0400A0E3 		mov	r0, #4
 3487 1e2c A0169FE5 		ldr	r1, .L315+28
 3488 1e30 0820A0E1 		mov	r2, r8
 3489 1e34 0630A0E1 		mov	r3, r6
 3490 1e38 00C08DE5 		str	ip, [sp, #0]
 3491 1e3c FEFFFFEB 		bl	CyU3PDebugPrint
1193:../uvc.c      **** 					  break;
 3492              		.loc 1 1193 0
 3493 1e40 FFC0A0E3 		mov	ip, #255
 3494 1e44 63FFFFEA 		b	.L241
 3495              	.LVL290:
 3496              	.L253:
1158:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3497              		.loc 1 1158 0
 3498 1e48 B984D8E5 		ldrb	r8, [r8, #1209]	@ zero_extendqisi2
 3499 1e4c 010058E3 		cmp	r8, #1
 3500 1e50 08005813 		cmpne	r8, #8
 3501 1e54 0000A013 		movne	r0, #0
 3502 1e58 0100A003 		moveq	r0, #1
 3503 1e5c 8001001A 		bne	.L304
 3504              	.LVL291:
1161:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3505              		.loc 1 1161 0
 3506 1e60 68869FE5 		ldr	r8, .L315+24
 3507 1e64 0010E0E3 		mvn	r1, #0
 3508 1e68 1C0098E5 		ldr	r0, [r8, #28]
 3509 1e6c 2C308DE5 		str	r3, [sp, #44]
 3510 1e70 FEFFFFEB 		bl	_txe_mutex_get
1162:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3511              		.loc 1 1162 0
 3512 1e74 30A09DE5 		ldr	sl, [sp, #48]
 3513 1e78 1610A0E3 		mov	r1, #22
 3514 1e7c 0B20A0E1 		mov	r2, fp
 3515 1e80 2C309DE5 		ldr	r3, [sp, #44]
 3516 1e84 00C0A0E3 		mov	ip, #0
 3517 1e88 0800A0E1 		mov	r0, r8
 3518 1e8c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3519 1e90 FEFFFFEB 		bl	cmdSet
1163:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3520              		.loc 1 1163 0
 3521 1e94 1C0098E5 		ldr	r0, [r8, #28]
 3522 1e98 FEFFFFEB 		bl	_txe_mutex_put
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3523              		.loc 1 1166 0
 3524 1e9c 18069FE5 		ldr	r0, .L315+4
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3525              		.loc 1 1167 0
 3526 1ea0 34209DE5 		ldr	r2, [sp, #52]
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3527              		.loc 1 1166 0
 3528 1ea4 061089E0 		add	r1, r9, r6
 3529 1ea8 813180E0 		add	r3, r0, r1, asl #3
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3530              		.loc 1 1168 0
 3531 1eac 0160A0E3 		mov	r6, #1
1166:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3532              		.loc 1 1166 0
 3533 1eb0 A1A4C3E5 		strb	sl, [r3, #1185]
1167:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3534              		.loc 1 1167 0
 3535 1eb4 A224C3E5 		strb	r2, [r3, #1186]
1168:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3536              		.loc 1 1168 0
 3537 1eb8 A464C3E5 		strb	r6, [r3, #1188]
 3538              	.LVL292:
 3539              	.L305:
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3540              		.loc 1 1170 0
 3541 1ebc 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 3542 1ec0 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1175:../uvc.c      **** 					  break;
 3543              		.loc 1 1175 0
 3544 1ec4 FFC0A0E3 		mov	ip, #255
 3545 1ec8 42FFFFEA 		b	.L241
 3546              	.LVL293:
 3547              	.L252:
1124:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3548              		.loc 1 1124 0
 3549 1ecc B904D8E5 		ldrb	r0, [r8, #1209]	@ zero_extendqisi2
 3550 1ed0 010050E3 		cmp	r0, #1
 3551 1ed4 04005013 		cmpne	r0, #4
 3552 1ed8 5C01001A 		bne	.L262
1123:../uvc.c      **** 					  value = (value << 8)|Data0;
 3553              		.loc 1 1123 0
 3554 1edc 30109DE5 		ldr	r1, [sp, #48]
 3555 1ee0 34E09DE5 		ldr	lr, [sp, #52]
 3556 1ee4 0E2481E1 		orr	r2, r1, lr, asl #8
1125:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3557              		.loc 1 1125 0
 3558 1ee8 F90052E3 		cmp	r2, #249
 3559 1eec 5701008A 		bhi	.L262
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3560              		.loc 1 1130 0
 3561 1ef0 C8A042E2 		sub	sl, r2, #200
 3562 1ef4 0AC8A0E1 		mov	ip, sl, asl #16
 3563 1ef8 3CC08DE5 		str	ip, [sp, #60]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3564              		.loc 1 1132 0
 3565 1efc 27A062E2 		rsb	sl, r2, #39
 3566 1f00 38A08DE5 		str	sl, [sp, #56]
 3567 1f04 3CA09DE5 		ldr	sl, [sp, #60]
 3568 1f08 C81062E2 		rsb	r1, r2, #200
 3569 1f0c C80052E3 		cmp	r2, #200
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3570              		.loc 1 1130 0
 3571 1f10 640042E2 		sub	r0, r2, #100
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3572              		.loc 1 1132 0
 3573 1f14 0118A0E1 		mov	r1, r1, asl #16
 3574 1f18 64E062E2 		rsb	lr, r2, #100
 3575 1f1c 2A18A081 		movhi	r1, sl, lsr #16
 3576 1f20 2118A091 		movls	r1, r1, lsr #16
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3577              		.loc 1 1130 0
 3578 1f24 00C8A0E1 		mov	ip, r0, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3579              		.loc 1 1132 0
 3580 1f28 640052E3 		cmp	r2, #100
 3581 1f2c 0E08A0E1 		mov	r0, lr, asl #16
 3582 1f30 2C08A081 		movhi	r0, ip, lsr #16
 3583 1f34 38C09DE5 		ldr	ip, [sp, #56]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3584              		.loc 1 1130 0
 3585 1f38 14A042E2 		sub	sl, r2, #20
 3586 1f3c 38A08DE5 		str	sl, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3587              		.loc 1 1132 0
 3588 1f40 2008A091 		movls	r0, r0, lsr #16
 3589 1f44 14A062E2 		rsb	sl, r2, #20
 3590 1f48 3CA08DE5 		str	sl, [sp, #60]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3591              		.loc 1 1130 0
 3592 1f4c 27E042E2 		sub	lr, r2, #39
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3593              		.loc 1 1132 0
 3594 1f50 000051E1 		cmp	r1, r0
 3595 1f54 01A0A031 		movcc	sl, r1
 3596 1f58 00A0A021 		movcs	sl, r0
 3597 1f5c 0CC8A0E1 		mov	ip, ip, asl #16
 3598 1f60 270052E3 		cmp	r2, #39
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3599              		.loc 1 1130 0
 3600 1f64 0EE8A0E1 		mov	lr, lr, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3601              		.loc 1 1132 0
 3602 1f68 2CE8A091 		movls	lr, ip, lsr #16
 3603 1f6c 64C59FE5 		ldr	ip, .L315+32
 3604 1f70 20A08DE5 		str	sl, [sp, #32]
 3605 1f74 01A06CE0 		rsb	sl, ip, r1
 3606 1f78 2EE8A081 		movhi	lr, lr, lsr #16
 3607 1f7c 00C07AE2 		rsbs	ip, sl, #0
 3608 1f80 0AC0ACE0 		adc	ip, ip, sl
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3609              		.loc 1 1130 0
 3610 1f84 38A09DE5 		ldr	sl, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3611              		.loc 1 1132 0
 3612 1f88 44C08DE5 		str	ip, [sp, #68]
 3613              	.LVL294:
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3614              		.loc 1 1130 0
 3615 1f8c 0AC8A0E1 		mov	ip, sl, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3616              		.loc 1 1132 0
 3617 1f90 3CA09DE5 		ldr	sl, [sp, #60]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3618              		.loc 1 1130 0
 3619 1f94 4CC08DE5 		str	ip, [sp, #76]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3620              		.loc 1 1132 0
 3621 1f98 0AC8A0E1 		mov	ip, sl, asl #16
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3622              		.loc 1 1130 0
 3623 1f9c 0AA042E2 		sub	sl, r2, #10
 3624 1fa0 48A08DE5 		str	sl, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3625              		.loc 1 1132 0
 3626 1fa4 20A09DE5 		ldr	sl, [sp, #32]
 3627 1fa8 3CC08DE5 		str	ip, [sp, #60]
 3628 1fac 0A005EE1 		cmp	lr, sl
 3629 1fb0 0EA0A031 		movcc	sl, lr
 3630 1fb4 0AC062E2 		rsb	ip, r2, #10
 3631 1fb8 40C08DE5 		str	ip, [sp, #64]
 3632 1fbc 38A08DE5 		str	sl, [sp, #56]
 3633 1fc0 3CC09DE5 		ldr	ip, [sp, #60]
 3634 1fc4 4CA09DE5 		ldr	sl, [sp, #76]
 3635 1fc8 140052E3 		cmp	r2, #20
 3636 1fcc 2CA8A091 		movls	sl, ip, lsr #16
 3637 1fd0 2AA8A081 		movhi	sl, sl, lsr #16
 3638 1fd4 44C09DE5 		ldr	ip, [sp, #68]
 3639 1fd8 010050E1 		cmp	r0, r1
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3640              		.loc 1 1130 0
 3641 1fdc 48109DE5 		ldr	r1, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3642              		.loc 1 1132 0
 3643 1fe0 01C0A033 		movcc	ip, #1
 3644 1fe4 3CA08DE5 		str	sl, [sp, #60]
 3645 1fe8 24C08DE5 		str	ip, [sp, #36]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3646              		.loc 1 1130 0
 3647 1fec 01A8A0E1 		mov	sl, r1, asl #16
 3648 1ff0 05C042E2 		sub	ip, r2, #5
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3649              		.loc 1 1132 0
 3650 1ff4 051062E2 		rsb	r1, r2, #5
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3651              		.loc 1 1130 0
 3652 1ff8 48A08DE5 		str	sl, [sp, #72]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3653              		.loc 1 1132 0
 3654 1ffc 40009DE5 		ldr	r0, [sp, #64]
 3655 2000 38A09DE5 		ldr	sl, [sp, #56]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3656              		.loc 1 1130 0
 3657 2004 40C08DE5 		str	ip, [sp, #64]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3658              		.loc 1 1132 0
 3659 2008 3CC09DE5 		ldr	ip, [sp, #60]
 3660 200c 4C108DE5 		str	r1, [sp, #76]
 3661 2010 48109DE5 		ldr	r1, [sp, #72]
 3662 2014 0008A0E1 		mov	r0, r0, asl #16
 3663 2018 0A005CE1 		cmp	ip, sl
 3664 201c 0AC0A021 		movcs	ip, sl
 3665 2020 0A0052E3 		cmp	r2, #10
 3666 2024 20A09DE5 		ldr	sl, [sp, #32]
 3667 2028 2108A081 		movhi	r0, r1, lsr #16
 3668 202c 2008A091 		movls	r0, r0, lsr #16
 3669 2030 48008DE5 		str	r0, [sp, #72]
 3670 2034 24009DE5 		ldr	r0, [sp, #36]
 3671 2038 0A005EE1 		cmp	lr, sl
 3672 203c 0200A033 		movcc	r0, #2
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3673              		.loc 1 1130 0
 3674 2040 02E042E2 		sub	lr, r2, #2
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3675              		.loc 1 1132 0
 3676 2044 44C08DE5 		str	ip, [sp, #68]
 3677 2048 24008DE5 		str	r0, [sp, #36]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3678              		.loc 1 1130 0
 3679 204c 40C09DE5 		ldr	ip, [sp, #64]
 3680 2050 1CE08DE5 		str	lr, [sp, #28]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3681              		.loc 1 1132 0
 3682 2054 44009DE5 		ldr	r0, [sp, #68]
 3683 2058 48E09DE5 		ldr	lr, [sp, #72]
 3684 205c 4C109DE5 		ldr	r1, [sp, #76]
 3685 2060 02A062E2 		rsb	sl, r2, #2
 3686 2064 00005EE1 		cmp	lr, r0
 3687 2068 00E0A021 		movcs	lr, r0
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3688              		.loc 1 1130 0
 3689 206c 0CC8A0E1 		mov	ip, ip, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3690              		.loc 1 1132 0
 3691 2070 050052E3 		cmp	r2, #5
 3692 2074 40A08DE5 		str	sl, [sp, #64]
 3693 2078 0118A0E1 		mov	r1, r1, asl #16
 3694 207c 3CA09DE5 		ldr	sl, [sp, #60]
 3695 2080 2C18A081 		movhi	r1, ip, lsr #16
 3696 2084 38C09DE5 		ldr	ip, [sp, #56]
 3697 2088 4CE08DE5 		str	lr, [sp, #76]
 3698 208c 24009DE5 		ldr	r0, [sp, #36]
 3699 2090 40E09DE5 		ldr	lr, [sp, #64]
 3700 2094 2118A091 		movls	r1, r1, lsr #16
 3701 2098 0C005AE1 		cmp	sl, ip
 3702 209c 20108DE5 		str	r1, [sp, #32]
 3703 20a0 0300A033 		movcc	r0, #3
 3704 20a4 38008DE5 		str	r0, [sp, #56]
 3705 20a8 4CA09DE5 		ldr	sl, [sp, #76]
 3706 20ac 0E08A0E1 		mov	r0, lr, asl #16
 3707 20b0 20E09DE5 		ldr	lr, [sp, #32]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3708              		.loc 1 1130 0
 3709 20b4 1C109DE5 		ldr	r1, [sp, #28]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3710              		.loc 1 1132 0
 3711 20b8 0A005EE1 		cmp	lr, sl
 3712 20bc 0AE0A021 		movcs	lr, sl
 3713 20c0 44C09DE5 		ldr	ip, [sp, #68]
 3714 20c4 48A09DE5 		ldr	sl, [sp, #72]
 3715 20c8 020052E3 		cmp	r2, #2
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3716              		.loc 1 1130 0
 3717 20cc 0118A0E1 		mov	r1, r1, asl #16
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3718              		.loc 1 1132 0
 3719 20d0 2018A091 		movls	r1, r0, lsr #16
 3720 20d4 38009DE5 		ldr	r0, [sp, #56]
 3721 20d8 2118A081 		movhi	r1, r1, lsr #16
 3722 20dc 0C005AE1 		cmp	sl, ip
 3723 20e0 0400A033 		movcc	r0, #4
 3724 20e4 40008DE5 		str	r0, [sp, #64]
1130:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3725              		.loc 1 1130 0
 3726 20e8 010042E2 		sub	r0, r2, #1
 3727 20ec 38008DE5 		str	r0, [sp, #56]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3728              		.loc 1 1132 0
 3729 20f0 4CA09DE5 		ldr	sl, [sp, #76]
 3730 20f4 20009DE5 		ldr	r0, [sp, #32]
 3731 20f8 01C062E2 		rsb	ip, r2, #1
 3732 20fc 3CC08DE5 		str	ip, [sp, #60]
 3733 2100 0A0050E1 		cmp	r0, sl
1139:../uvc.c      **** 						  shutter = shutter+index;
 3734              		.loc 1 1139 0
 3735 2104 38A09DE5 		ldr	sl, [sp, #56]
 3736 2108 3C009DE5 		ldr	r0, [sp, #60]
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3737              		.loc 1 1132 0
 3738 210c 40C09DE5 		ldr	ip, [sp, #64]
 3739 2110 05C0A033 		movcc	ip, #5
1139:../uvc.c      **** 						  shutter = shutter+index;
 3740              		.loc 1 1139 0
 3741 2114 010052E3 		cmp	r2, #1
 3742 2118 0028A091 		movls	r2, r0, asl #16
 3743 211c 0A28A081 		movhi	r2, sl, asl #16
 3744 2120 0E0051E1 		cmp	r1, lr
 3745 2124 01A0A031 		movcc	sl, r1
 3746 2128 0EA0A021 		movcs	sl, lr
1132:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3747              		.loc 1 1132 0
 3748 212c 0E0051E1 		cmp	r1, lr
 3749 2130 0C10A021 		movcs	r1, ip
 3750 2134 0610A033 		movcc	r1, #6
1139:../uvc.c      **** 						  shutter = shutter+index;
 3751              		.loc 1 1139 0
 3752 2138 22085AE1 		cmp	sl, r2, lsr #16
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3753              		.loc 1 1142 0
 3754 213c 8CA39FE5 		ldr	sl, .L315+24
1139:../uvc.c      **** 						  shutter = shutter+index;
 3755              		.loc 1 1139 0
 3756 2140 0120A091 		movls	r2, r1
 3757 2144 0720A083 		movhi	r2, #7
 3758 2148 012082E2 		add	r2, r2, #1
 3759 214c FFE002E2 		and	lr, r2, #255
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3760              		.loc 1 1142 0
 3761 2150 0010E0E3 		mvn	r1, #0
 3762 2154 1C009AE5 		ldr	r0, [sl, #28]
1139:../uvc.c      **** 						  shutter = shutter+index;
 3763              		.loc 1 1139 0
 3764 2158 38E08DE5 		str	lr, [sp, #56]
 3765              	.LVL295:
1142:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3766              		.loc 1 1142 0
 3767 215c 2C308DE5 		str	r3, [sp, #44]
 3768 2160 FEFFFFEB 		bl	_txe_mutex_get
1143:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3769              		.loc 1 1143 0
 3770 2164 38C09DE5 		ldr	ip, [sp, #56]
 3771 2168 0310A0E3 		mov	r1, #3
 3772 216c 0B20A0E1 		mov	r2, fp
 3773 2170 2C309DE5 		ldr	r3, [sp, #44]
 3774 2174 00C08DE5 		str	ip, [sp, #0]
 3775 2178 0A00A0E1 		mov	r0, sl
 3776 217c 00C0A0E3 		mov	ip, #0
 3777 2180 04C08DE5 		str	ip, [sp, #4]
 3778 2184 FEFFFFEB 		bl	cmdSet
1144:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3779              		.loc 1 1144 0
 3780 2188 1C009AE5 		ldr	r0, [sl, #28]
 3781 218c FEFFFFEB 		bl	_txe_mutex_put
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3782              		.loc 1 1147 0
 3783 2190 30009DE5 		ldr	r0, [sp, #48]
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3784              		.loc 1 1148 0
 3785 2194 34C09DE5 		ldr	ip, [sp, #52]
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3786              		.loc 1 1150 0
 3787 2198 38309DE5 		ldr	r3, [sp, #56]
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3788              		.loc 1 1147 0
 3789 219c 061089E0 		add	r1, r9, r6
 3790 21a0 816188E0 		add	r6, r8, r1, asl #3
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3791              		.loc 1 1149 0
 3792 21a4 0120A0E3 		mov	r2, #1
1147:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3793              		.loc 1 1147 0
 3794 21a8 A104C6E5 		strb	r0, [r6, #1185]
1148:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3795              		.loc 1 1148 0
 3796 21ac A2C4C6E5 		strb	ip, [r6, #1186]
1149:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3797              		.loc 1 1149 0
 3798 21b0 A424C6E5 		strb	r2, [r6, #1188]
1150:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3799              		.loc 1 1150 0
 3800 21b4 0D33C8E5 		strb	r3, [r8, #781]
 3801 21b8 3FFFFFEA 		b	.L305
 3802              	.LVL296:
 3803              	.L251:
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3804              		.loc 1 1077 0
 3805 21bc 062089E0 		add	r2, r9, r6
 3806 21c0 826188E0 		add	r6, r8, r2, asl #3
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3807              		.loc 1 1078 0
 3808 21c4 0110A0E3 		mov	r1, #1
1081:../uvc.c      **** 		  		    switch (getData){
 3809              		.loc 1 1081 0
 3810 21c8 01E040E2 		sub	lr, r0, #1
1077:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3811              		.loc 1 1077 0
 3812 21cc A104C6E5 		strb	r0, [r6, #1185]
1078:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3813              		.loc 1 1078 0
 3814 21d0 A414C6E5 		strb	r1, [r6, #1188]
 3815              	.LVL297:
1081:../uvc.c      **** 		  		    switch (getData){
 3816              		.loc 1 1081 0
 3817 21d4 07005EE3 		cmp	lr, #7
 3818 21d8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3819 21dc 970000EA 		b	.L256
 3820              	.L261:
 3821 21e0 D4230000 		.word	.L257
 3822 21e4 38230000 		.word	.L258
 3823 21e8 40240000 		.word	.L256
 3824 21ec D4220000 		.word	.L259
 3825 21f0 40240000 		.word	.L256
 3826 21f4 40240000 		.word	.L256
 3827 21f8 40240000 		.word	.L256
 3828 21fc 34220000 		.word	.L260
 3829              	.LVL298:
 3830              	.L250:
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3831              		.loc 1 1197 0
 3832 2200 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3833              		.loc 1 1196 0
 3834 2204 30A09DE5 		ldr	sl, [sp, #48]
 3835 2208 069089E0 		add	r9, r9, r6
 3836 220c 89E188E0 		add	lr, r8, r9, asl #3
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3837              		.loc 1 1197 0
 3838 2210 0620A0E1 		mov	r2, r6
 3839 2214 0400A0E3 		mov	r0, #4
 3840 2218 BC129FE5 		ldr	r1, .L315+36
1196:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3841              		.loc 1 1196 0
 3842 221c A1A4CEE5 		strb	sl, [lr, #1185]
1197:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3843              		.loc 1 1197 0
 3844 2220 FEFFFFEB 		bl	CyU3PDebugPrint
1198:../uvc.c      **** 			  		 break;
 3845              		.loc 1 1198 0
 3846 2224 FFC0A0E3 		mov	ip, #255
 3847 2228 0C60A0E1 		mov	r6, ip
 3848 222c 0C80A0E1 		mov	r8, ip
 3849 2230 68FEFFEA 		b	.L241
 3850              	.LVL299:
 3851              	.L260:
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3852              		.loc 1 1100 0
 3853 2234 94629FE5 		ldr	r6, .L315+24
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3854              		.loc 1 1098 0
 3855 2238 00A0A0E3 		mov	sl, #0
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3856              		.loc 1 1100 0
 3857 223c 1C0096E5 		ldr	r0, [r6, #28]
1098:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3858              		.loc 1 1098 0
 3859 2240 0DA3C8E5 		strb	sl, [r8, #781]
 3860              	.LVL300:
1100:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3861              		.loc 1 1100 0
 3862 2244 0010E0E3 		mvn	r1, #0
 3863 2248 2C308DE5 		str	r3, [sp, #44]
 3864 224c FEFFFFEB 		bl	_txe_mutex_get
1101:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3865              		.loc 1 1101 0
 3866 2250 0B20A0E1 		mov	r2, fp
 3867 2254 2C309DE5 		ldr	r3, [sp, #44]
 3868 2258 1010A0E3 		mov	r1, #16
 3869 225c 0600A0E1 		mov	r0, r6
 3870 2260 00A08DE5 		str	sl, [sp, #0]
 3871 2264 04A08DE5 		str	sl, [sp, #4]
 3872 2268 FEFFFFEB 		bl	cmdSet
1102:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3873              		.loc 1 1102 0
 3874 226c 1C0096E5 		ldr	r0, [r6, #28]
 3875 2270 FEFFFFEB 		bl	_txe_mutex_put
 3876              	.LVL301:
 3877              	.LBB68:
 3878              	.LBB69:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3879              		.loc 1 416 0
 3880 2274 0010E0E3 		mvn	r1, #0
 3881 2278 1C0096E5 		ldr	r0, [r6, #28]
 3882 227c FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3883              		.loc 1 417 0
 3884 2280 0180A0E3 		mov	r8, #1
 3885 2284 1410A0E3 		mov	r1, #20
 3886 2288 2720A0E3 		mov	r2, #39
 3887 228c 3030A0E3 		mov	r3, #48
 3888 2290 0600A0E1 		mov	r0, r6
 3889 2294 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3890 2298 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3891              		.loc 1 418 0
 3892 229c 02C0A0E3 		mov	ip, #2
 3893 22a0 1510A0E3 		mov	r1, #21
 3894 22a4 2520A0E3 		mov	r2, #37
 3895 22a8 3030A0E3 		mov	r3, #48
 3896 22ac 0600A0E1 		mov	r0, r6
 3897 22b0 00C08DE5 		str	ip, [sp, #0]
 3898 22b4 04A08DE5 		str	sl, [sp, #4]
 3899 22b8 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3900              		.loc 1 419 0
 3901 22bc 1C0096E5 		ldr	r0, [r6, #28]
 3902 22c0 FEFFFFEB 		bl	_txe_mutex_put
 3903              	.LBE69:
 3904              	.LBE68:
1104:../uvc.c      **** 							break;
 3905              		.loc 1 1104 0
 3906 22c4 FFC0A0E3 		mov	ip, #255
 3907 22c8 0C60A0E1 		mov	r6, ip
 3908 22cc 0880A0E3 		mov	r8, #8
 3909 22d0 40FEFFEA 		b	.L241
 3910              	.LVL302:
 3911              	.L259:
 3912              	.LBB70:
 3913              	.LBB71:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3914              		.loc 1 416 0
 3915 22d4 F4819FE5 		ldr	r8, .L315+24
 3916 22d8 0010E0E3 		mvn	r1, #0
 3917 22dc 1C0098E5 		ldr	r0, [r8, #28]
 3918 22e0 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3919              		.loc 1 417 0
 3920 22e4 0060A0E3 		mov	r6, #0
 3921 22e8 1410A0E3 		mov	r1, #20
 3922 22ec 2720A0E3 		mov	r2, #39
 3923 22f0 3030A0E3 		mov	r3, #48
 3924 22f4 0800A0E1 		mov	r0, r8
 3925 22f8 00608DE5 		str	r6, [sp, #0]
 3926 22fc 04608DE5 		str	r6, [sp, #4]
 3927 2300 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3928              		.loc 1 418 0
 3929 2304 1510A0E3 		mov	r1, #21
 3930 2308 2520A0E3 		mov	r2, #37
 3931 230c 3030A0E3 		mov	r3, #48
 3932 2310 0800A0E1 		mov	r0, r8
 3933 2314 00608DE5 		str	r6, [sp, #0]
 3934 2318 04608DE5 		str	r6, [sp, #4]
 3935 231c FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3936              		.loc 1 419 0
 3937 2320 1C0098E5 		ldr	r0, [r8, #28]
 3938 2324 FEFFFFEB 		bl	_txe_mutex_put
 3939 2328 FFC0A0E3 		mov	ip, #255
 3940 232c 0C60A0E1 		mov	r6, ip
 3941 2330 0480A0E3 		mov	r8, #4
 3942 2334 27FEFFEA 		b	.L241
 3943              	.LVL303:
 3944              	.L258:
 3945              	.LBE71:
 3946              	.LBE70:
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3947              		.loc 1 1088 0
 3948 2338 90A19FE5 		ldr	sl, .L315+24
1086:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3949              		.loc 1 1086 0
 3950 233c 0060A0E3 		mov	r6, #0
 3951 2340 0D63C8E5 		strb	r6, [r8, #781]
 3952              	.LVL304:
1088:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3953              		.loc 1 1088 0
 3954 2344 0010E0E3 		mvn	r1, #0
 3955 2348 1C009AE5 		ldr	r0, [sl, #28]
 3956 234c 2C308DE5 		str	r3, [sp, #44]
 3957 2350 FEFFFFEB 		bl	_txe_mutex_get
1089:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3958              		.loc 1 1089 0
 3959 2354 0B20A0E1 		mov	r2, fp
 3960 2358 2C309DE5 		ldr	r3, [sp, #44]
 3961 235c 1010A0E3 		mov	r1, #16
 3962 2360 0A00A0E1 		mov	r0, sl
 3963 2364 00608DE5 		str	r6, [sp, #0]
 3964 2368 04608DE5 		str	r6, [sp, #4]
 3965 236c FEFFFFEB 		bl	cmdSet
1090:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3966              		.loc 1 1090 0
 3967 2370 1C009AE5 		ldr	r0, [sl, #28]
 3968 2374 FEFFFFEB 		bl	_txe_mutex_put
 3969              	.LVL305:
 3970              	.LBB72:
 3971              	.LBB73:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3972              		.loc 1 416 0
 3973 2378 0010E0E3 		mvn	r1, #0
 3974 237c 1C009AE5 		ldr	r0, [sl, #28]
 3975 2380 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3976              		.loc 1 417 0
 3977 2384 1410A0E3 		mov	r1, #20
 3978 2388 2720A0E3 		mov	r2, #39
 3979 238c 3030A0E3 		mov	r3, #48
 3980 2390 0A00A0E1 		mov	r0, sl
 3981 2394 00608DE5 		str	r6, [sp, #0]
 3982 2398 04608DE5 		str	r6, [sp, #4]
 3983 239c FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3984              		.loc 1 418 0
 3985 23a0 1510A0E3 		mov	r1, #21
 3986 23a4 2520A0E3 		mov	r2, #37
 3987 23a8 3030A0E3 		mov	r3, #48
 3988 23ac 0A00A0E1 		mov	r0, sl
 3989 23b0 00608DE5 		str	r6, [sp, #0]
 3990 23b4 04608DE5 		str	r6, [sp, #4]
 3991 23b8 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3992              		.loc 1 419 0
 3993 23bc 1C009AE5 		ldr	r0, [sl, #28]
 3994 23c0 FEFFFFEB 		bl	_txe_mutex_put
 3995 23c4 FFC0A0E3 		mov	ip, #255
 3996 23c8 0C60A0E1 		mov	r6, ip
 3997 23cc 0280A0E3 		mov	r8, #2
 3998 23d0 00FEFFEA 		b	.L241
 3999              	.LVL306:
 4000              	.L257:
 4001              	.LBE73:
 4002              	.LBE72:
 4003              	.LBB74:
 4004              	.LBB75:
 416:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4005              		.loc 1 416 0
 4006 23d4 F4609FE5 		ldr	r6, .L315+24
 4007 23d8 0010E0E3 		mvn	r1, #0
 4008 23dc 1C0096E5 		ldr	r0, [r6, #28]
 4009 23e0 FEFFFFEB 		bl	_txe_mutex_get
 417:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 4010              		.loc 1 417 0
 4011 23e4 0080A0E3 		mov	r8, #0
 4012 23e8 01A0A0E3 		mov	sl, #1
 4013 23ec 1410A0E3 		mov	r1, #20
 4014 23f0 2720A0E3 		mov	r2, #39
 4015 23f4 3030A0E3 		mov	r3, #48
 4016 23f8 0600A0E1 		mov	r0, r6
 4017 23fc 04808DE5 		str	r8, [sp, #4]
 4018 2400 00A08DE5 		str	sl, [sp, #0]
 4019 2404 FEFFFFEB 		bl	cmdSet
 418:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 4020              		.loc 1 418 0
 4021 2408 02C0A0E3 		mov	ip, #2
 4022 240c 1510A0E3 		mov	r1, #21
 4023 2410 2520A0E3 		mov	r2, #37
 4024 2414 3030A0E3 		mov	r3, #48
 4025 2418 0600A0E1 		mov	r0, r6
 4026 241c 00C08DE5 		str	ip, [sp, #0]
 4027 2420 04808DE5 		str	r8, [sp, #4]
 4028 2424 FEFFFFEB 		bl	cmdSet
 419:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4029              		.loc 1 419 0
 4030 2428 1C0096E5 		ldr	r0, [r6, #28]
 4031 242c FEFFFFEB 		bl	_txe_mutex_put
 4032              	.LBE75:
 4033              	.LBE74:
1084:../uvc.c      **** 							break;
 4034              		.loc 1 1084 0
 4035 2430 FFC0A0E3 		mov	ip, #255
 4036 2434 0C60A0E1 		mov	r6, ip
 4037 2438 0A80A0E1 		mov	r8, sl
 4038 243c E5FDFFEA 		b	.L241
 4039              	.LVL307:
 4040              	.L256:
1081:../uvc.c      **** 		  		    switch (getData){
 4041              		.loc 1 1081 0
 4042 2440 FFC0A0E3 		mov	ip, #255
 4043 2444 0080A0E1 		mov	r8, r0
 4044 2448 0C60A0E1 		mov	r6, ip
 4045 244c E1FDFFEA 		b	.L241
 4046              	.LVL308:
 4047              	.L262:
1152:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4048              		.loc 1 1152 0
 4049 2450 0000A0E3 		mov	r0, #0
 4050 2454 0110A0E3 		mov	r1, #1
 4051 2458 0020A0E1 		mov	r2, r0
 4052 245c FEFFFFEB 		bl	CyU3PUsbStall
 4053              	.LVL309:
 4054 2460 95FEFFEA 		b	.L305
 4055              	.LVL310:
 4056              	.L304:
1170:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4057              		.loc 1 1170 0
 4058 2464 0110A0E3 		mov	r1, #1
 4059 2468 0020A0E1 		mov	r2, r0
 4060 246c FEFFFFEB 		bl	CyU3PUsbStall
 4061 2470 91FEFFEA 		b	.L305
 4062              	.LVL311:
 4063              	.L314:
1185:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4064              		.loc 1 1185 0
 4065 2474 08E0A0E3 		mov	lr, #8
 4066 2478 00C0A0E3 		mov	ip, #0
 4067 247c 0600A0E1 		mov	r0, r6
 4068 2480 1710A0E3 		mov	r1, #23
 4069 2484 0B20A0E1 		mov	r2, fp
 4070 2488 00E08DE5 		str	lr, [sp, #0]
 4071 248c 04C08DE5 		str	ip, [sp, #4]
 4072 2490 FEFFFFEB 		bl	cmdSet
 4073 2494 5EFEFFEA 		b	.L307
 4074              	.L313:
1183:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4075              		.loc 1 1183 0
 4076 2498 0480A0E3 		mov	r8, #4
 4077 249c 00E0A0E3 		mov	lr, #0
 4078 24a0 0600A0E1 		mov	r0, r6
 4079 24a4 1710A0E3 		mov	r1, #23
 4080 24a8 0B20A0E1 		mov	r2, fp
 4081 24ac 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4082 24b0 FEFFFFEB 		bl	cmdSet
 4083 24b4 56FEFFEA 		b	.L307
 4084              	.L316:
 4085              		.align	2
 4086              	.L315:
 4087 24b8 00000000 		.word	bRequest
 4088 24bc 00000000 		.word	.LANCHOR1
 4089 24c0 00000000 		.word	.LANCHOR0
 4090 24c4 0C040000 		.word	.LC24
 4091 24c8 30040000 		.word	.LC25
 4092 24cc 5C000000 		.word	.LANCHOR0+92
 4093 24d0 00000000 		.word	cmdQu
 4094 24d4 C0030000 		.word	.LC22
 4095 24d8 FFFF0000 		.word	65535
 4096 24dc E8030000 		.word	.LC23
 4097              		.cfi_endproc
 4098              	.LFE3:
 4100              		.align	2
 4101              		.global	UVCAppEP0Thread_Entry
 4103              	UVCAppEP0Thread_Entry:
 4104              	.LFB24:
3315:../uvc.c      **** {
 4105              		.loc 1 3315 0
 4106              		.cfi_startproc
 4107              		@ args = 0, pretend = 0, frame = 24
 4108              		@ frame_needed = 0, uses_anonymous_args = 0
 4109              	.LVL312:
 4110 24e0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4111              	.LCFI17:
 4112              		.cfi_def_cfa_offset 36
 4113 24e4 C44A9FE5 		ldr	r4, .L477
 4114              		.cfi_offset 14, -4
 4115              		.cfi_offset 11, -8
 4116              		.cfi_offset 10, -12
 4117              		.cfi_offset 9, -16
 4118              		.cfi_offset 8, -20
 4119              		.cfi_offset 7, -24
 4120              		.cfi_offset 6, -28
 4121              		.cfi_offset 5, -32
 4122              		.cfi_offset 4, -36
 4123 24e8 C46A9FE5 		ldr	r6, .L477+4
 4124 24ec C48A9FE5 		ldr	r8, .L477+8
 4125 24f0 C4AA9FE5 		ldr	sl, .L477+12
 4126 24f4 C4BA9FE5 		ldr	fp, .L477+16
 4127 24f8 C47A9FE5 		ldr	r7, .L477+20
 4128 24fc 34D04DE2 		sub	sp, sp, #52
 4129              	.LCFI18:
 4130              		.cfi_def_cfa_offset 88
 4131              	.LVL313:
3337:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4132              		.loc 1 3337 0
 4133 2500 0450A0E1 		mov	r5, r4
 4134              	.LVL314:
 4135              	.L449:
 4136 2504 00C0E0E3 		mvn	ip, #0
 4137 2508 A00A9FE5 		ldr	r0, .L477
 4138 250c 4C10A0E3 		mov	r1, #76
 4139 2510 0120A0E3 		mov	r2, #1
 4140 2514 28308DE2 		add	r3, sp, #40
 4141 2518 00C08DE5 		str	ip, [sp, #0]
 4142 251c FEFFFFEB 		bl	_txe_event_flags_get
 4143 2520 000050E3 		cmp	r0, #0
 4144 2524 3000001A 		bne	.L318
3341:../uvc.c      ****             if (!isUsbConnected)
 4145              		.loc 1 3341 0
 4146 2528 303095E5 		ldr	r3, [r5, #48]
 4147 252c 000053E3 		cmp	r3, #0
 4148 2530 8C00000A 		beq	.L466
 4149              	.L319:
3350:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4150              		.loc 1 3350 0
 4151 2534 28309DE5 		ldr	r3, [sp, #40]
 4152 2538 0C0013E3 		tst	r3, #12
 4153 253c 7500001A 		bne	.L467
 4154              	.L320:
3357:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4155              		.loc 1 3357 0
 4156 2540 040013E3 		tst	r3, #4
 4157 2544 1C00000A 		beq	.L321
3359:../uvc.c      ****             	switch ((wIndex >> 8))
 4158              		.loc 1 3359 0
 4159 2548 B0E0DBE1 		ldrh	lr, [fp, #0]
 4160 254c 2E24A0E1 		mov	r2, lr, lsr #8
 4161 2550 030052E3 		cmp	r2, #3
 4162 2554 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4163 2558 120000EA 		b	.L322
 4164              	.L327:
 4165 255c A8250000 		.word	.L322
 4166 2560 98260000 		.word	.L324
 4167 2564 6C250000 		.word	.L325
 4168 2568 D4260000 		.word	.L326
 4169              	.L325:
 4170              	.LBB90:
 4171              	.LBB93:
2604:../uvc.c      ****     switch (wValue)
 4172              		.loc 1 2604 0
 4173 256c B020DAE1 		ldrh	r2, [sl, #0]
 4174 2570 060C52E3 		cmp	r2, #1536
 4175 2574 6B02000A 		beq	.L333
 4176 2578 D300008A 		bhi	.L339
 4177 257c 030C52E3 		cmp	r2, #768
 4178 2580 6402000A 		beq	.L331
 4179 2584 A401008A 		bhi	.L340
 4180 2588 010C52E3 		cmp	r2, #256
 4181 258c 5D02000A 		beq	.L329
 4182 2590 020C52E3 		cmp	r2, #512
 4183 2594 5702000A 		beq	.L468
 4184              	.L342:
 4185              	.LBE93:
 4186              	.LBE90:
 4187              	.LBB97:
 4188              	.LBB102:
2736:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4189              		.loc 1 2736 0
 4190 2598 281A9FE5 		ldr	r1, .L477+24
 4191 259c 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4192 25a0 0400A0E3 		mov	r0, #4
 4193 25a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4194              	.L322:
 4195              	.LBE102:
 4196              	.LBE97:
3380:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4197              		.loc 1 3380 0
 4198 25a8 0000A0E3 		mov	r0, #0
 4199 25ac 0110A0E3 		mov	r1, #1
 4200 25b0 0020A0E1 		mov	r2, r0
 4201 25b4 FEFFFFEB 		bl	CyU3PUsbStall
 4202 25b8 28309DE5 		ldr	r3, [sp, #40]
 4203              	.L321:
3385:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4204              		.loc 1 3385 0
 4205 25bc 080013E3 		tst	r3, #8
 4206 25c0 0700000A 		beq	.L383
3389:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4207              		.loc 1 3389 0
 4208 25c4 B030DBE1 		ldrh	r3, [fp, #0]
 4209 25c8 010053E3 		cmp	r3, #1
 4210 25cc 6B00000A 		beq	.L384
 4211              	.L385:
 4212              	.LBB107:
 4213              	.LBB112:
3304:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4214              		.loc 1 3304 0
 4215 25d0 0000A0E3 		mov	r0, #0
 4216 25d4 0110A0E3 		mov	r1, #1
 4217 25d8 0020A0E1 		mov	r2, r0
 4218 25dc FEFFFFEB 		bl	CyU3PUsbStall
 4219              	.L455:
 4220 25e0 28309DE5 		ldr	r3, [sp, #40]
 4221              	.L383:
 4222              	.LBE112:
 4223              	.LBE107:
3400:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4224              		.loc 1 3400 0
 4225 25e4 400013E3 		tst	r3, #64
 4226 25e8 0100001A 		bne	.L469
 4227              	.L318:
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4228              		.loc 1 3613 0
 4229 25ec FEFFFFEB 		bl	_txe_thread_relinquish
3614:../uvc.c      ****     }
 4230              		.loc 1 3614 0
 4231 25f0 C3FFFFEA 		b	.L449
 4232              	.L469:
3405:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4233              		.loc 1 3405 0
 4234 25f4 1800A0E3 		mov	r0, #24
 4235 25f8 24108DE2 		add	r1, sp, #36
 4236 25fc FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3462:../uvc.c      **** 				if(snapButFlag == 0x0f){
 4237              		.loc 1 3462 0
 4238 2600 7F36D6E5 		ldrb	r3, [r6, #1663]	@ zero_extendqisi2
 4239 2604 0F0053E3 		cmp	r3, #15
 4240 2608 8E00000A 		beq	.L470
3489:../uvc.c      **** 				}else if(!snapButFlag){
 4241              		.loc 1 3489 0
 4242 260c 000053E3 		cmp	r3, #0
 4243 2610 F5FFFF1A 		bne	.L318
3491:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4244              		.loc 1 3491 0
 4245 2614 00C097E5 		ldr	ip, [r7, #0]
 4246 2618 0290A0E3 		mov	r9, #2
 4247 261c 0090CCE5 		strb	r9, [ip, #0]
3492:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4248              		.loc 1 3492 0
 4249 2620 001097E5 		ldr	r1, [r7, #0]
 4250 2624 0190A0E3 		mov	r9, #1
 4251 2628 0190C1E5 		strb	r9, [r1, #1]
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4252              		.loc 1 3493 0
 4253 262c 000097E5 		ldr	r0, [r7, #0]
3497:../uvc.c      **** 					interStabuf.size   = 1024;
 4254              		.loc 1 3497 0
 4255 2630 012BA0E3 		mov	r2, #1024	@ movhi
3493:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4256              		.loc 1 3493 0
 4257 2634 0230C0E5 		strb	r3, [r0, #2]
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4258              		.loc 1 3494 0
 4259 2638 00E097E5 		ldr	lr, [r7, #0]
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4260              		.loc 1 3503 0
 4261 263c 0010E0E3 		mvn	r1, #0
3494:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4262              		.loc 1 3494 0
 4263 2640 0390CEE5 		strb	r9, [lr, #3]
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4264              		.loc 1 3496 0
 4265 2644 00C097E5 		ldr	ip, [r7, #0]
3500:../uvc.c      **** 					interStabuf.count = 4;
 4266              		.loc 1 3500 0
 4267 2648 04E0A0E3 		mov	lr, #4	@ movhi
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4268              		.loc 1 3503 0
 4269 264c 78099FE5 		ldr	r0, .L477+28
3497:../uvc.c      **** 					interStabuf.size   = 1024;
 4270              		.loc 1 3497 0
 4271 2650 BE21CDE1 		strh	r2, [sp, #30]	@ movhi
3496:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4272              		.loc 1 3496 0
 4273 2654 18C08DE5 		str	ip, [sp, #24]
3498:../uvc.c      **** 					interStabuf.status = 0;
 4274              		.loc 1 3498 0
 4275 2658 B032CDE1 		strh	r3, [sp, #32]	@ movhi
3500:../uvc.c      **** 					interStabuf.count = 4;
 4276              		.loc 1 3500 0
 4277 265c BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
3503:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4278              		.loc 1 3503 0
 4279 2660 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3506:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4280              		.loc 1 3506 0
 4281 2664 60099FE5 		ldr	r0, .L477+28
 4282 2668 18108DE2 		add	r1, sp, #24
 4283 266c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4284              	.LVL315:
3508:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4285              		.loc 1 3508 0
 4286 2670 002050E2 		subs	r2, r0, #0
 4287 2674 4801001A 		bne	.L471
3514:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 4288              		.loc 1 3514 0
 4289 2678 3010A0E3 		mov	r1, #48
 4290 267c 0920A0E1 		mov	r2, r9
 4291 2680 0500A0E3 		mov	r0, #5
 4292              	.LVL316:
 4293 2684 FEFFFFEB 		bl	SensorSetControl
3515:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 4294              		.loc 1 3515 0
 4295 2688 24399FE5 		ldr	r3, .L477+4
 4296 268c 7F96C3E5 		strb	r9, [r3, #1663]
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4297              		.loc 1 3613 0
 4298 2690 FEFFFFEB 		bl	_txe_thread_relinquish
 4299 2694 9AFFFFEA 		b	.L449
 4300              	.L324:
 4301              	.LBB118:
 4302              	.LBB101:
2679:../uvc.c      ****     switch (wValue)
 4303              		.loc 1 2679 0
 4304 2698 B020DAE1 		ldrh	r2, [sl, #0]
 4305 269c 060C52E3 		cmp	r2, #1536
 4306 26a0 1002000A 		beq	.L348
 4307 26a4 9300008A 		bhi	.L354
 4308 26a8 030C52E3 		cmp	r2, #768
 4309 26ac 0902000A 		beq	.L345
 4310 26b0 4701008A 		bhi	.L355
 4311 26b4 010C52E3 		cmp	r2, #256
 4312 26b8 0202000A 		beq	.L343
 4313 26bc 020C52E3 		cmp	r2, #512
 4314 26c0 B4FFFF1A 		bne	.L342
 4315              	.LVL317:
2687:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4316              		.loc 1 2687 0
 4317 26c4 0100A0E3 		mov	r0, #1
 4318 26c8 FEFFFFEB 		bl	CTControlHandle
 4319              	.LVL318:
 4320 26cc 28309DE5 		ldr	r3, [sp, #40]
 4321 26d0 B9FFFFEA 		b	.L321
 4322              	.L326:
 4323              	.LBE101:
 4324              	.LBE118:
 4325              	.LBB119:
 4326              	.LBB125:
2904:../uvc.c      ****     switch (wValue)
 4327              		.loc 1 2904 0
 4328 26d4 B030DAE1 		ldrh	r3, [sl, #0]
 4329 26d8 090C53E3 		cmp	r3, #2304
 4330 26dc 1D02000A 		beq	.L369
 4331 26e0 8C00008A 		bhi	.L378
 4332 26e4 010B53E3 		cmp	r3, #1024
 4333 26e8 1602000A 		beq	.L364
 4334 26ec 5B01008A 		bhi	.L379
 4335 26f0 020C53E3 		cmp	r3, #512
 4336 26f4 0F02000A 		beq	.L362
 4337 26f8 030C53E3 		cmp	r3, #768
 4338 26fc 1902000A 		beq	.L363
 4339 2700 010C53E3 		cmp	r3, #256
 4340 2704 A7FFFF1A 		bne	.L322
 4341              	.LVL319:
2908:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4342              		.loc 1 2908 0
 4343 2708 1000A0E3 		mov	r0, #16
 4344 270c FEFFFFEB 		bl	ControlHandle
 4345              	.LVL320:
 4346 2710 28309DE5 		ldr	r3, [sp, #40]
 4347 2714 A8FFFFEA 		b	.L321
 4348              	.L467:
 4349              	.LBE125:
 4350              	.LBE119:
3351:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4351              		.loc 1 3351 0
 4352 2718 B0C0DAE1 		ldrh	ip, [sl, #0]
 4353 271c AC989FE5 		ldr	r9, .L477+32
 4354 2720 AC189FE5 		ldr	r1, .L477+36
 4355 2724 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 4356 2728 08C08DE5 		str	ip, [sp, #8]
 4357 272c B000DBE1 		ldrh	r0, [fp, #0]
 4358 2730 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4359 2734 0C008DE5 		str	r0, [sp, #12]
 4360 2738 B0C0D1E1 		ldrh	ip, [r1, #0]
 4361 273c 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4362 2740 04908DE5 		str	r9, [sp, #4]
 4363 2744 0400A0E3 		mov	r0, #4
 4364 2748 88189FE5 		ldr	r1, .L477+40
 4365 274c 0090A0E3 		mov	r9, #0
 4366 2750 00E08DE5 		str	lr, [sp, #0]
 4367 2754 10C08DE5 		str	ip, [sp, #16]
 4368 2758 14908DE5 		str	r9, [sp, #20]
 4369 275c FEFFFFEB 		bl	CyU3PDebugPrint
 4370 2760 28309DE5 		ldr	r3, [sp, #40]
 4371 2764 75FFFFEA 		b	.L320
 4372              	.L466:
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4373              		.loc 1 3343 0
 4374 2768 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3344:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4375              		.loc 1 3344 0
 4376 276c 000050E3 		cmp	r0, #0
3343:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4377              		.loc 1 3343 0
 4378 2770 4800C5E5 		strb	r0, [r5, #72]
3346:../uvc.c      ****                     isUsbConnected = CyTrue;
 4379              		.loc 1 3346 0
 4380 2774 0100A013 		movne	r0, #1
 4381 2778 30008515 		strne	r0, [r5, #48]
 4382 277c 6CFFFFEA 		b	.L319
 4383              	.L384:
 4384              	.LVL321:
 4385              	.LBB131:
 4386              	.LBB113:
2999:../uvc.c      ****     switch (wValue)
 4387              		.loc 1 2999 0
 4388 2780 B020DAE1 		ldrh	r2, [sl, #0]
 4389 2784 030C52E3 		cmp	r2, #768
 4390 2788 8100000A 		beq	.L388
 4391 278c 0F00008A 		bhi	.L391
 4392 2790 010C52E3 		cmp	r2, #256
 4393 2794 8B00000A 		beq	.L386
 4394 2798 020C52E3 		cmp	r2, #512
 4395 279c 8BFFFF1A 		bne	.L385
3064:../uvc.c      ****             switch (bRequest)
 4396              		.loc 1 3064 0
 4397 27a0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4398 27a4 810053E3 		cmp	r3, #129
 4399 27a8 F201000A 		beq	.L437
 4400 27ac CB00008A 		bhi	.L406
 4401 27b0 010053E3 		cmp	r3, #1
 4402 27b4 6D01000A 		beq	.L472
 4403              	.L426:
3242:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4404              		.loc 1 3242 0
 4405 27b8 0000A0E3 		mov	r0, #0
 4406 27bc 0110A0E3 		mov	r1, #1
 4407 27c0 0020A0E1 		mov	r2, r0
 4408 27c4 FEFFFFEB 		bl	CyU3PUsbStall
 4409 27c8 28309DE5 		ldr	r3, [sp, #40]
 4410 27cc 84FFFFEA 		b	.L383
 4411              	.L391:
2999:../uvc.c      ****     switch (wValue)
 4412              		.loc 1 2999 0
 4413 27d0 010B52E3 		cmp	r2, #1024
 4414 27d4 5C00000A 		beq	.L389
 4415 27d8 050C52E3 		cmp	r2, #1280
 4416 27dc 7BFFFF1A 		bne	.L385
3249:../uvc.c      ****             	switch (bRequest)
 4417              		.loc 1 3249 0
 4418 27e0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4419 27e4 810052E3 		cmp	r2, #129
 4420 27e8 E201000A 		beq	.L437
 4421 27ec F300008A 		bhi	.L440
 4422 27f0 010052E3 		cmp	r2, #1
 4423 27f4 75FFFF1A 		bne	.L385
3274:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4424              		.loc 1 3274 0
 4425 27f8 2000A0E3 		mov	r0, #32
 4426 27fc D8179FE5 		ldr	r1, .L477+44
 4427 2800 2E208DE2 		add	r2, sp, #46
 4428 2804 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4429              	.LVL322:
3276:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4430              		.loc 1 3276 0
 4431 2808 000050E3 		cmp	r0, #0
 4432 280c E101001A 		bne	.L442
3280:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 4433              		.loc 1 3280 0
 4434 2810 0020A0E3 		mov	r2, #0
 4435 2814 94079FE5 		ldr	r0, .L477
 4436              	.LVL323:
 4437 2818 8010A0E3 		mov	r1, #128
 4438 281c FEFFFFEB 		bl	_txe_event_flags_set
 4439              	.LVL324:
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4440              		.loc 1 3281 0
 4441 2820 002050E2 		subs	r2, r0, #0
3287:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 4442              		.loc 1 3287 0
 4443 2824 0F30E003 		mvneq	r3, #15
 4444 2828 3A30C505 		streqb	r3, [r5, #58]
 4445 282c 28309D05 		ldreq	r3, [sp, #40]
3281:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4446              		.loc 1 3281 0
 4447 2830 6BFFFF0A 		beq	.L383
 4448              	.L456:
3283:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 4449              		.loc 1 3283 0
 4450 2834 0400A0E3 		mov	r0, #4
 4451              	.LVL325:
 4452 2838 A0179FE5 		ldr	r1, .L477+48
 4453 283c FEFFFFEB 		bl	CyU3PDebugPrint
 4454              	.LVL326:
 4455 2840 28309DE5 		ldr	r3, [sp, #40]
 4456 2844 66FFFFEA 		b	.L383
 4457              	.L470:
 4458              	.LBE113:
 4459              	.LBE131:
3464:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4460              		.loc 1 3464 0
 4461 2848 00C097E5 		ldr	ip, [r7, #0]
 4462 284c 0290A0E3 		mov	r9, #2
 4463 2850 0090CCE5 		strb	r9, [ip, #0]
3465:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4464              		.loc 1 3465 0
 4465 2854 003097E5 		ldr	r3, [r7, #0]
 4466 2858 0190A0E3 		mov	r9, #1
 4467 285c 0190C3E5 		strb	r9, [r3, #1]
3466:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4468              		.loc 1 3466 0
 4469 2860 001097E5 		ldr	r1, [r7, #0]
 4470 2864 00C0A0E3 		mov	ip, #0
 4471 2868 02C0C1E5 		strb	ip, [r1, #2]
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4472              		.loc 1 3467 0
 4473 286c 000097E5 		ldr	r0, [r7, #0]
3470:../uvc.c      **** 					interStabuf.size   = 1024;
 4474              		.loc 1 3470 0
 4475 2870 01EBA0E3 		mov	lr, #1024	@ movhi
3467:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4476              		.loc 1 3467 0
 4477 2874 03C0C0E5 		strb	ip, [r0, #3]
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4478              		.loc 1 3469 0
 4479 2878 002097E5 		ldr	r2, [r7, #0]
3473:../uvc.c      **** 					interStabuf.count = 4;
 4480              		.loc 1 3473 0
 4481 287c 0430A0E3 		mov	r3, #4	@ movhi
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4482              		.loc 1 3476 0
 4483 2880 0010E0E3 		mvn	r1, #0
 4484 2884 40079FE5 		ldr	r0, .L477+28
3469:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4485              		.loc 1 3469 0
 4486 2888 18208DE5 		str	r2, [sp, #24]
3470:../uvc.c      **** 					interStabuf.size   = 1024;
 4487              		.loc 1 3470 0
 4488 288c BEE1CDE1 		strh	lr, [sp, #30]	@ movhi
3471:../uvc.c      **** 					interStabuf.status = 0;
 4489              		.loc 1 3471 0
 4490 2890 B0C2CDE1 		strh	ip, [sp, #32]	@ movhi
3473:../uvc.c      **** 					interStabuf.count = 4;
 4491              		.loc 1 3473 0
 4492 2894 BC31CDE1 		strh	r3, [sp, #28]	@ movhi
3476:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4493              		.loc 1 3476 0
 4494 2898 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3479:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4495              		.loc 1 3479 0
 4496 289c 28079FE5 		ldr	r0, .L477+28
 4497 28a0 18108DE2 		add	r1, sp, #24
 4498 28a4 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4499              	.LVL327:
3481:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4500              		.loc 1 3481 0
 4501 28a8 002050E2 		subs	r2, r0, #0
 4502 28ac E200001A 		bne	.L473
3486:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 4503              		.loc 1 3486 0
 4504 28b0 3010A0E3 		mov	r1, #48
 4505 28b4 0500A0E3 		mov	r0, #5
 4506              	.LVL328:
 4507 28b8 FEFFFFEB 		bl	SensorSetControl
 4508              	.LVL329:
3488:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 4509              		.loc 1 3488 0
 4510 28bc F0269FE5 		ldr	r2, .L477+4
 4511 28c0 7F96C2E5 		strb	r9, [r2, #1663]
3613:../uvc.c      ****         CyU3PThreadRelinquish ();
 4512              		.loc 1 3613 0
 4513 28c4 FEFFFFEB 		bl	_txe_thread_relinquish
 4514 28c8 0DFFFFEA 		b	.L449
 4515              	.L339:
 4516              	.LBB132:
 4517              	.LBB94:
2604:../uvc.c      ****     switch (wValue)
 4518              		.loc 1 2604 0
 4519 28cc 0A0C52E3 		cmp	r2, #2560
 4520 28d0 2201000A 		beq	.L336
 4521 28d4 C600008A 		bhi	.L341
 4522 28d8 070C52E3 		cmp	r2, #1792
 4523 28dc 1B01000A 		beq	.L334
 4524 28e0 020B52E3 		cmp	r2, #2048
 4525 28e4 2BFFFF1A 		bne	.L342
 4526              	.LVL330:
2635:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4527              		.loc 1 2635 0
 4528 28e8 0700A0E3 		mov	r0, #7
 4529 28ec FEFFFFEB 		bl	ControlHandle
 4530              	.LVL331:
 4531 28f0 28309DE5 		ldr	r3, [sp, #40]
 4532 28f4 30FFFFEA 		b	.L321
 4533              	.L354:
 4534              	.LBE94:
 4535              	.LBE132:
 4536              	.LBB133:
 4537              	.LBB103:
2679:../uvc.c      ****     switch (wValue)
 4538              		.loc 1 2679 0
 4539 28f8 090C52E3 		cmp	r2, #2304
 4540 28fc 0F01000A 		beq	.L350
 4541 2900 DF00008A 		bhi	.L356
 4542 2904 070C52E3 		cmp	r2, #1792
 4543 2908 0801000A 		beq	.L349
 4544 290c 020B52E3 		cmp	r2, #2048
 4545 2910 20FFFF1A 		bne	.L342
 4546 2914 28FFFFEA 		b	.L321
 4547              	.L378:
 4548              	.LBE103:
 4549              	.LBE133:
 4550              	.LBB134:
 4551              	.LBB124:
2904:../uvc.c      ****     switch (wValue)
 4552              		.loc 1 2904 0
 4553 2918 0F0C53E3 		cmp	r3, #3840
 4554 291c FF00000A 		beq	.L373
 4555 2920 3500008A 		bhi	.L381
 4556 2924 0B0C53E3 		cmp	r3, #2816
 4557 2928 F800000A 		beq	.L371
 4558 292c 0D0C53E3 		cmp	r3, #3328
 4559 2930 F200000A 		beq	.L372
 4560 2934 0A0C53E3 		cmp	r3, #2560
 4561 2938 1AFFFF1A 		bne	.L322
 4562              	.LVL332:
2945:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 4563              		.loc 1 2945 0
 4564 293c 1900A0E3 		mov	r0, #25
 4565 2940 FEFFFFEB 		bl	ControlHandle
 4566              	.LVL333:
 4567 2944 28309DE5 		ldr	r3, [sp, #40]
 4568 2948 1BFFFFEA 		b	.L321
 4569              	.LVL334:
 4570              	.L389:
 4571              	.LBE124:
 4572              	.LBE134:
 4573              	.LBB135:
 4574              	.LBB111:
3191:../uvc.c      ****                 switch (bRequest)
 4575              		.loc 1 3191 0
 4576 294c 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 4577 2950 810059E3 		cmp	r9, #129
 4578 2954 1300000A 		beq	.L428
 4579 2958 6600008A 		bhi	.L431
 4580 295c 010059E3 		cmp	r9, #1
 4581 2960 94FFFF1A 		bne	.L426
3216:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4582              		.loc 1 3216 0
 4583 2964 2E208DE2 		add	r2, sp, #46
 4584 2968 2000A0E3 		mov	r0, #32
 4585 296c 68169FE5 		ldr	r1, .L477+44
 4586 2970 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4587              	.LVL335:
3218:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4588              		.loc 1 3218 0
 4589 2974 002050E2 		subs	r2, r0, #0
 4590 2978 18FFFF1A 		bne	.L455
3231:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4591              		.loc 1 3231 0
 4592 297c 2C069FE5 		ldr	r0, .L477
 4593              	.LVL336:
 4594 2980 0910A0E1 		mov	r1, r9
 4595 2984 FEFFFFEB 		bl	_txe_event_flags_set
 4596              	.LVL337:
3232:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4597              		.loc 1 3232 0
 4598 2988 002050E2 		subs	r2, r0, #0
 4599 298c 13FFFF0A 		beq	.L455
 4600 2990 A7FFFFEA 		b	.L456
 4601              	.LVL338:
 4602              	.L388:
3141:../uvc.c      ****                 switch (bRequest)
 4603              		.loc 1 3141 0
 4604 2994 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4605 2998 830052E3 		cmp	r2, #131
 4606 299c 7900008A 		bhi	.L422
 4607 29a0 810052E3 		cmp	r2, #129
 4608 29a4 5E00003A 		bcc	.L474
 4609              	.L428:
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4610              		.loc 1 3203 0
 4611 29a8 4890D4E5 		ldrb	r9, [r4, #72]	@ zero_extendqisi2
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4612              		.loc 1 3205 0
 4613 29ac 0B00A0E3 		mov	r0, #11
3203:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4614              		.loc 1 3203 0
 4615 29b0 030059E3 		cmp	r9, #3
3205:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4616              		.loc 1 3205 0
 4617 29b4 28169F05 		ldreq	r1, .L477+52
3209:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4618              		.loc 1 3209 0
 4619 29b8 28169F15 		ldrne	r1, .L477+56
 4620 29bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4621 29c0 28309DE5 		ldr	r3, [sp, #40]
 4622 29c4 06FFFFEA 		b	.L383
 4623              	.L386:
3002:../uvc.c      ****             switch (bRequest)
 4624              		.loc 1 3002 0
 4625 29c8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4626 29cc 830052E3 		cmp	r2, #131
 4627 29d0 2B00008A 		bhi	.L397
 4628 29d4 810052E3 		cmp	r2, #129
 4629 29d8 1000003A 		bcc	.L475
 4630              	.L394:
3017:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 4631              		.loc 1 3017 0
 4632 29dc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 4633 29e0 030053E3 		cmp	r3, #3
 4634 29e4 BC00000A 		beq	.L476
 4635              	.L441:
3267:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4636              		.loc 1 3267 0
 4637 29e8 1A00A0E3 		mov	r0, #26
 4638 29ec F8159FE5 		ldr	r1, .L477+60
 4639 29f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4640 29f4 28309DE5 		ldr	r3, [sp, #40]
 4641 29f8 F9FEFFEA 		b	.L383
 4642              	.LVL339:
 4643              	.L381:
 4644              	.LBE111:
 4645              	.LBE135:
 4646              	.LBB136:
 4647              	.LBB126:
2904:../uvc.c      ****     switch (wValue)
 4648              		.loc 1 2904 0
 4649 29fc 110C53E3 		cmp	r3, #4352
 4650 2a00 B100000A 		beq	.L375
 4651 2a04 2D00008A 		bhi	.L382
 4652 2a08 010A53E3 		cmp	r3, #4096
 4653 2a0c E5FEFF1A 		bne	.L322
 4654              	.LVL340:
2967:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4655              		.loc 1 2967 0
 4656 2a10 1F00A0E3 		mov	r0, #31
 4657 2a14 FEFFFFEB 		bl	ControlHandle
 4658              	.LVL341:
 4659 2a18 28309DE5 		ldr	r3, [sp, #40]
 4660 2a1c E6FEFFEA 		b	.L321
 4661              	.LVL342:
 4662              	.L475:
 4663              	.LBE126:
 4664              	.LBE136:
 4665              	.LBB137:
 4666              	.LBB114:
3002:../uvc.c      ****             switch (bRequest)
 4667              		.loc 1 3002 0
 4668 2a20 010052E3 		cmp	r2, #1
 4669 2a24 63FFFF1A 		bne	.L426
3029:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4670              		.loc 1 3029 0
 4671 2a28 2000A0E3 		mov	r0, #32
 4672 2a2c A8159FE5 		ldr	r1, .L477+44
 4673 2a30 2E208DE2 		add	r2, sp, #46
 4674 2a34 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4675              	.LVL343:
3031:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4676              		.loc 1 3031 0
 4677 2a38 000050E3 		cmp	r0, #0
 4678 2a3c E7FEFF1A 		bne	.L455
3033:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4679              		.loc 1 3033 0
 4680 2a40 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4681 2a44 030051E3 		cmp	r1, #3
 4682 2a48 E4FEFF1A 		bne	.L455
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4683              		.loc 1 3040 0
 4684 2a4c 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4685              		.loc 1 3037 0
 4686 2a50 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4687              		.loc 1 3038 0
 4688 2a54 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4689              		.loc 1 3039 0
 4690 2a58 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 4691              	.LVL344:
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4692              		.loc 1 3041 0
 4693 2a5c 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4694              		.loc 1 3042 0
 4695 2a60 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3040:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 4696              		.loc 1 3040 0
 4697 2a64 1936C6E5 		strb	r3, [r6, #1561]
3037:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 4698              		.loc 1 3037 0
 4699 2a68 16E6C6E5 		strb	lr, [r6, #1558]
3038:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 4700              		.loc 1 3038 0
 4701 2a6c 17C6C6E5 		strb	ip, [r6, #1559]
3039:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 4702              		.loc 1 3039 0
 4703 2a70 1806C6E5 		strb	r0, [r6, #1560]
3041:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 4704              		.loc 1 3041 0
 4705 2a74 1A26C6E5 		strb	r2, [r6, #1562]
3042:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 4706              		.loc 1 3042 0
 4707 2a78 1B96C6E5 		strb	r9, [r6, #1563]
 4708 2a7c 28309DE5 		ldr	r3, [sp, #40]
 4709 2a80 D7FEFFEA 		b	.L383
 4710              	.LVL345:
 4711              	.L397:
3002:../uvc.c      ****             switch (bRequest)
 4712              		.loc 1 3002 0
 4713 2a84 860052E3 		cmp	r2, #134
 4714 2a88 1E00000A 		beq	.L460
 4715 2a8c 870052E3 		cmp	r2, #135
 4716 2a90 D1FFFF0A 		beq	.L394
 4717              	.L465:
3141:../uvc.c      ****                 switch (bRequest)
 4718              		.loc 1 3141 0
 4719 2a94 850052E3 		cmp	r2, #133
 4720 2a98 46FFFF1A 		bne	.L426
 4721              	.L429:
3200:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4722              		.loc 1 3200 0
 4723 2a9c 4C159FE5 		ldr	r1, .L477+64
 4724 2aa0 0200A0E3 		mov	r0, #2
3198:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4725              		.loc 1 3198 0
 4726 2aa4 1A30A0E3 		mov	r3, #26
 4727              	.L457:
3257:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4728              		.loc 1 3257 0
 4729 2aa8 0020A0E3 		mov	r2, #0
3256:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4730              		.loc 1 3256 0
 4731 2aac 5C30C4E5 		strb	r3, [r4, #92]
3257:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4732              		.loc 1 3257 0
 4733 2ab0 5D20C4E5 		strb	r2, [r4, #93]
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4734              		.loc 1 3258 0
 4735 2ab4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4736 2ab8 28309DE5 		ldr	r3, [sp, #40]
 4737 2abc C8FEFFEA 		b	.L383
 4738              	.LVL346:
 4739              	.L382:
 4740              	.LBE114:
 4741              	.LBE137:
 4742              	.LBB138:
 4743              	.LBB123:
2904:../uvc.c      ****     switch (wValue)
 4744              		.loc 1 2904 0
 4745 2ac0 120C53E3 		cmp	r3, #4608
 4746 2ac4 FB00000A 		beq	.L376
 4747 2ac8 130C53E3 		cmp	r3, #4864
 4748 2acc B5FEFF1A 		bne	.L322
 4749              	.LVL347:
2979:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4750              		.loc 1 2979 0
 4751 2ad0 2200A0E3 		mov	r0, #34
 4752 2ad4 FEFFFFEB 		bl	ControlHandle
 4753              	.LVL348:
 4754 2ad8 28309DE5 		ldr	r3, [sp, #40]
 4755 2adc B6FEFFEA 		b	.L321
 4756              	.LVL349:
 4757              	.L406:
 4758              	.LBE123:
 4759              	.LBE138:
 4760              	.LBB139:
 4761              	.LBB110:
3064:../uvc.c      ****             switch (bRequest)
 4762              		.loc 1 3064 0
 4763 2ae0 850053E3 		cmp	r3, #133
 4764 2ae4 ECFFFF0A 		beq	.L429
 4765 2ae8 860053E3 		cmp	r3, #134
 4766 2aec 31FFFF1A 		bne	.L426
 4767              	.L461:
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4768              		.loc 1 3068 0
 4769 2af0 0100A0E3 		mov	r0, #1
 4770 2af4 040000EA 		b	.L454
 4771              	.L431:
3191:../uvc.c      ****                 switch (bRequest)
 4772              		.loc 1 3191 0
 4773 2af8 850059E3 		cmp	r9, #133
 4774 2afc E6FFFF0A 		beq	.L429
 4775 2b00 860059E3 		cmp	r9, #134
 4776 2b04 2BFFFF1A 		bne	.L426
 4777              	.L460:
3195:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4778              		.loc 1 3195 0
 4779 2b08 0300A0E1 		mov	r0, r3
 4780              	.L454:
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4781              		.loc 1 3068 0
 4782 2b0c DC149FE5 		ldr	r1, .L477+64
3067:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4783              		.loc 1 3067 0
 4784 2b10 0390A0E3 		mov	r9, #3
 4785 2b14 5C90C4E5 		strb	r9, [r4, #92]
3068:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4786              		.loc 1 3068 0
 4787 2b18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4788 2b1c 28309DE5 		ldr	r3, [sp, #40]
 4789 2b20 AFFEFFEA 		b	.L383
 4790              	.L474:
3141:../uvc.c      ****                 switch (bRequest)
 4791              		.loc 1 3141 0
 4792 2b24 010052E3 		cmp	r2, #1
 4793 2b28 22FFFF1A 		bne	.L426
3166:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4794              		.loc 1 3166 0
 4795 2b2c 2000A0E3 		mov	r0, #32
 4796 2b30 A4149FE5 		ldr	r1, .L477+44
 4797 2b34 2E208DE2 		add	r2, sp, #46
 4798 2b38 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4799              	.LVL350:
3168:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4800              		.loc 1 3168 0
 4801 2b3c 000050E3 		cmp	r0, #0
 4802 2b40 A6FEFF1A 		bne	.L455
3170:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4803              		.loc 1 3170 0
 4804 2b44 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4805 2b48 030051E3 		cmp	r1, #3
 4806 2b4c A3FEFF1A 		bne	.L455
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4807              		.loc 1 3177 0
 4808 2b50 8430D5E5 		ldrb	r3, [r5, #132]	@ zero_extendqisi2
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4809              		.loc 1 3174 0
 4810 2b54 81E0D5E5 		ldrb	lr, [r5, #129]	@ zero_extendqisi2
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4811              		.loc 1 3175 0
 4812 2b58 82C0D5E5 		ldrb	ip, [r5, #130]	@ zero_extendqisi2
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4813              		.loc 1 3176 0
 4814 2b5c 8300D5E5 		ldrb	r0, [r5, #131]	@ zero_extendqisi2
 4815              	.LVL351:
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4816              		.loc 1 3178 0
 4817 2b60 8520D5E5 		ldrb	r2, [r5, #133]	@ zero_extendqisi2
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4818              		.loc 1 3179 0
 4819 2b64 8690D5E5 		ldrb	r9, [r5, #134]	@ zero_extendqisi2
3177:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4820              		.loc 1 3177 0
 4821 2b68 6C36C6E5 		strb	r3, [r6, #1644]
3174:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4822              		.loc 1 3174 0
 4823 2b6c 69E6C6E5 		strb	lr, [r6, #1641]
3175:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4824              		.loc 1 3175 0
 4825 2b70 6AC6C6E5 		strb	ip, [r6, #1642]
3176:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4826              		.loc 1 3176 0
 4827 2b74 6B06C6E5 		strb	r0, [r6, #1643]
3178:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4828              		.loc 1 3178 0
 4829 2b78 6D26C6E5 		strb	r2, [r6, #1645]
3179:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4830              		.loc 1 3179 0
 4831 2b7c 6E96C6E5 		strb	r9, [r6, #1646]
 4832 2b80 28309DE5 		ldr	r3, [sp, #40]
 4833 2b84 96FEFFEA 		b	.L383
 4834              	.LVL352:
 4835              	.L422:
3141:../uvc.c      ****                 switch (bRequest)
 4836              		.loc 1 3141 0
 4837 2b88 860052E3 		cmp	r2, #134
 4838 2b8c DDFFFF0A 		beq	.L460
 4839 2b90 870052E3 		cmp	r2, #135
 4840 2b94 BEFFFF1A 		bne	.L465
 4841 2b98 82FFFFEA 		b	.L428
 4842              	.LVL353:
 4843              	.L471:
 4844              	.LBE110:
 4845              	.LBE139:
3510:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4846              		.loc 1 3510 0
 4847 2b9c 0400A0E3 		mov	r0, #4
 4848              	.LVL354:
 4849 2ba0 4C149FE5 		ldr	r1, .L477+68
 4850 2ba4 FEFFFFEB 		bl	CyU3PDebugPrint
 4851              	.LVL355:
 4852              	.L448:
 4853              	.LBB140:
 4854              	.LBB141:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4855              		.loc 1 1318 0
 4856 2ba8 48149FE5 		ldr	r1, .L477+72
 4857 2bac 0400A0E3 		mov	r0, #4
 4858 2bb0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 4859              		.loc 1 1319 0
 4860 2bb4 FA0FA0E3 		mov	r0, #1000
 4861 2bb8 FEFFFFEB 		bl	_tx_thread_sleep
 4862 2bbc F9FFFFEA 		b	.L448
 4863              	.LVL356:
 4864              	.L440:
 4865              	.LBE141:
 4866              	.LBE140:
 4867              	.LBB142:
 4868              	.LBB115:
3249:../uvc.c      ****             	switch (bRequest)
 4869              		.loc 1 3249 0
 4870 2bc0 850052E3 		cmp	r2, #133
 4871 2bc4 B800000A 		beq	.L438
 4872 2bc8 860052E3 		cmp	r2, #134
 4873 2bcc 7FFEFF1A 		bne	.L385
 4874 2bd0 C6FFFFEA 		b	.L461
 4875              	.LVL357:
 4876              	.L355:
 4877              	.LBE115:
 4878              	.LBE142:
 4879              	.LBB143:
 4880              	.LBB100:
2679:../uvc.c      ****     switch (wValue)
 4881              		.loc 1 2679 0
 4882 2bd4 010B52E3 		cmp	r2, #1024
 4883 2bd8 AF00000A 		beq	.L346
 4884 2bdc 050C52E3 		cmp	r2, #1280
 4885 2be0 6CFEFF1A 		bne	.L342
 4886              	.LVL358:
2701:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4887              		.loc 1 2701 0
 4888 2be4 0400A0E3 		mov	r0, #4
 4889 2be8 FEFFFFEB 		bl	CTControlHandle
 4890              	.LVL359:
 4891 2bec 28309DE5 		ldr	r3, [sp, #40]
 4892 2bf0 71FEFFEA 		b	.L321
 4893              	.L341:
 4894              	.LBE100:
 4895              	.LBE143:
 4896              	.LBB144:
 4897              	.LBB92:
2604:../uvc.c      ****     switch (wValue)
 4898              		.loc 1 2604 0
 4899 2bf4 0D0C52E3 		cmp	r2, #3328
 4900 2bf8 5800000A 		beq	.L336
 4901 2bfc 0E0C52E3 		cmp	r2, #3584
 4902 2c00 A100000A 		beq	.L338
 4903 2c04 030B52E3 		cmp	r2, #3072
 4904 2c08 62FEFF1A 		bne	.L342
 4905              	.LVL360:
2645:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4906              		.loc 1 2645 0
 4907 2c0c 0B00A0E3 		mov	r0, #11
 4908 2c10 FEFFFFEB 		bl	ControlHandle
 4909              	.LVL361:
 4910 2c14 28309DE5 		ldr	r3, [sp, #40]
 4911 2c18 67FEFFEA 		b	.L321
 4912              	.L340:
2604:../uvc.c      ****     switch (wValue)
 4913              		.loc 1 2604 0
 4914 2c1c 010B52E3 		cmp	r2, #1024
 4915 2c20 65FEFF0A 		beq	.L321
 4916 2c24 050C52E3 		cmp	r2, #1280
 4917 2c28 5AFEFF1A 		bne	.L342
 4918              	.LVL362:
2623:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4919              		.loc 1 2623 0
 4920 2c2c 0400A0E3 		mov	r0, #4
 4921 2c30 FEFFFFEB 		bl	ControlHandle
 4922              	.LVL363:
 4923 2c34 28309DE5 		ldr	r3, [sp, #40]
 4924 2c38 5FFEFFEA 		b	.L321
 4925              	.LVL364:
 4926              	.L473:
 4927              	.LBE92:
 4928              	.LBE144:
3483:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4929              		.loc 1 3483 0
 4930 2c3c 0400A0E3 		mov	r0, #4
 4931              	.LVL365:
 4932 2c40 AC139FE5 		ldr	r1, .L477+68
 4933 2c44 FEFFFFEB 		bl	CyU3PDebugPrint
 4934              	.LVL366:
 4935              	.L446:
 4936              	.LBB145:
 4937              	.LBB146:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4938              		.loc 1 1318 0
 4939 2c48 A8139FE5 		ldr	r1, .L477+72
 4940 2c4c 0400A0E3 		mov	r0, #4
 4941 2c50 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 4942              		.loc 1 1319 0
 4943 2c54 FA0FA0E3 		mov	r0, #1000
 4944 2c58 FEFFFFEB 		bl	_tx_thread_sleep
 4945 2c5c F9FFFFEA 		b	.L446
 4946              	.L379:
 4947              	.LBE146:
 4948              	.LBE145:
 4949              	.LBB147:
 4950              	.LBB127:
2904:../uvc.c      ****     switch (wValue)
 4951              		.loc 1 2904 0
 4952 2c60 060C53E3 		cmp	r3, #1536
 4953 2c64 8400000A 		beq	.L366
 4954 2c68 0F00008A 		bhi	.L380
 4955 2c6c 050C53E3 		cmp	r3, #1280
 4956 2c70 4CFEFF1A 		bne	.L322
 4957              	.LVL367:
2924:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4958              		.loc 1 2924 0
 4959 2c74 1400A0E3 		mov	r0, #20
 4960 2c78 FEFFFFEB 		bl	ControlHandle
 4961              	.LVL368:
 4962 2c7c 28309DE5 		ldr	r3, [sp, #40]
 4963 2c80 4DFEFFEA 		b	.L321
 4964              	.L356:
 4965              	.LBE127:
 4966              	.LBE147:
 4967              	.LBB148:
 4968              	.LBB104:
2679:../uvc.c      ****     switch (wValue)
 4969              		.loc 1 2679 0
 4970 2c84 0B0C52E3 		cmp	r2, #2816
 4971 2c88 7700000A 		beq	.L352
 4972 2c8c 030B52E3 		cmp	r2, #3072
 4973 2c90 7100000A 		beq	.L353
 4974 2c94 0A0C52E3 		cmp	r2, #2560
 4975 2c98 3EFEFF1A 		bne	.L342
 4976              	.LVL369:
2720:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4977              		.loc 1 2720 0
 4978 2c9c 0800A0E3 		mov	r0, #8
 4979 2ca0 FEFFFFEB 		bl	CTControlHandle
 4980              	.LVL370:
 4981 2ca4 28309DE5 		ldr	r3, [sp, #40]
 4982 2ca8 43FEFFEA 		b	.L321
 4983              	.L380:
 4984              	.LBE104:
 4985              	.LBE148:
 4986              	.LBB149:
 4987              	.LBB122:
2904:../uvc.c      ****     switch (wValue)
 4988              		.loc 1 2904 0
 4989 2cac 070C53E3 		cmp	r3, #1792
 4990 2cb0 6500000A 		beq	.L367
 4991 2cb4 020B53E3 		cmp	r3, #2048
 4992 2cb8 3AFEFF1A 		bne	.L322
 4993              	.LVL371:
2936:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4994              		.loc 1 2936 0
 4995 2cbc 1700A0E3 		mov	r0, #23
 4996 2cc0 FEFFFFEB 		bl	ControlHandle
 4997              	.LVL372:
 4998 2cc4 28309DE5 		ldr	r3, [sp, #40]
 4999 2cc8 3BFEFFEA 		b	.L321
 5000              	.L375:
 5001              	.LVL373:
2971:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5002              		.loc 1 2971 0
 5003 2ccc 2000A0E3 		mov	r0, #32
 5004 2cd0 FEFFFFEB 		bl	ControlHandle
 5005              	.LVL374:
 5006 2cd4 28309DE5 		ldr	r3, [sp, #40]
 5007 2cd8 37FEFFEA 		b	.L321
 5008              	.LVL375:
 5009              	.L476:
 5010              	.LBE122:
 5011              	.LBE149:
 5012              	.LBB150:
 5013              	.LBB109:
3019:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5014              		.loc 1 3019 0
 5015 2cdc 18139FE5 		ldr	r1, .L477+76
 5016 2ce0 1A00A0E3 		mov	r0, #26
 5017 2ce4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3020:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5018              		.loc 1 3020 0
 5019 2ce8 0400A0E3 		mov	r0, #4
 5020 2cec 0C139FE5 		ldr	r1, .L477+80
 5021 2cf0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5022 2cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 5023 2cf8 28309DE5 		ldr	r3, [sp, #40]
 5024 2cfc 38FEFFEA 		b	.L383
 5025              	.LVL376:
 5026              	.L372:
 5027              	.LBE109:
 5028              	.LBE150:
 5029              	.LBB151:
 5030              	.LBB128:
2955:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5031              		.loc 1 2955 0
 5032 2d00 1C00A0E3 		mov	r0, #28
 5033 2d04 FEFFFFEB 		bl	ControlHandle
 5034              	.LVL377:
 5035 2d08 28309DE5 		ldr	r3, [sp, #40]
 5036 2d0c 2AFEFFEA 		b	.L321
 5037              	.L371:
 5038              	.LVL378:
2951:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5039              		.loc 1 2951 0
 5040 2d10 1A00A0E3 		mov	r0, #26
 5041 2d14 FEFFFFEB 		bl	ControlHandle
 5042              	.LVL379:
 5043 2d18 28309DE5 		ldr	r3, [sp, #40]
 5044 2d1c 26FEFFEA 		b	.L321
 5045              	.L373:
 5046              	.LVL380:
2963:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5047              		.loc 1 2963 0
 5048 2d20 1E00A0E3 		mov	r0, #30
 5049 2d24 FEFFFFEB 		bl	ControlHandle
 5050              	.LVL381:
 5051 2d28 28309DE5 		ldr	r3, [sp, #40]
 5052 2d2c 22FEFFEA 		b	.L321
 5053              	.L349:
 5054              	.LVL382:
 5055              	.LBE128:
 5056              	.LBE151:
 5057              	.LBB152:
 5058              	.LBB99:
2709:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 5059              		.loc 1 2709 0
 5060 2d30 0600A0E3 		mov	r0, #6
 5061 2d34 FEFFFFEB 		bl	CTControlHandle
 5062              	.LVL383:
 5063 2d38 28309DE5 		ldr	r3, [sp, #40]
 5064 2d3c 1EFEFFEA 		b	.L321
 5065              	.L350:
 5066              	.LVL384:
2715:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5067              		.loc 1 2715 0
 5068 2d40 0700A0E3 		mov	r0, #7
 5069 2d44 FEFFFFEB 		bl	CTControlHandle
 5070              	.LVL385:
 5071 2d48 28309DE5 		ldr	r3, [sp, #40]
 5072 2d4c 1AFEFFEA 		b	.L321
 5073              	.L334:
 5074              	.LVL386:
 5075              	.LBE99:
 5076              	.LBE152:
 5077              	.LBB153:
 5078              	.LBB95:
2631:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5079              		.loc 1 2631 0
 5080 2d50 0600A0E3 		mov	r0, #6
 5081 2d54 FEFFFFEB 		bl	ControlHandle
 5082              	.LVL387:
 5083 2d58 28309DE5 		ldr	r3, [sp, #40]
 5084 2d5c 16FEFFEA 		b	.L321
 5085              	.L336:
 5086              	.LVL388:
2641:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5087              		.loc 1 2641 0
 5088 2d60 0900A0E3 		mov	r0, #9
 5089 2d64 FEFFFFEB 		bl	ControlHandle
 5090              	.LVL389:
 5091 2d68 28309DE5 		ldr	r3, [sp, #40]
 5092 2d6c 12FEFFEA 		b	.L321
 5093              	.LVL390:
 5094              	.L472:
 5095              	.LBE95:
 5096              	.LBE153:
 5097              	.LBB154:
 5098              	.LBB116:
3089:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5099              		.loc 1 3089 0
 5100 2d70 2000A0E3 		mov	r0, #32
 5101 2d74 60129FE5 		ldr	r1, .L477+44
 5102 2d78 2E208DE2 		add	r2, sp, #46
 5103 2d7c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5104              	.LVL391:
3091:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5105              		.loc 1 3091 0
 5106 2d80 000050E3 		cmp	r0, #0
 5107 2d84 15FEFF1A 		bne	.L455
3093:../uvc.c      ****                         switch (glCommitCtrl[3])
 5108              		.loc 1 3093 0
 5109 2d88 8300D4E5 		ldrb	r0, [r4, #131]	@ zero_extendqisi2
 5110              	.LVL392:
 5111 2d8c 020050E3 		cmp	r0, #2
 5112 2d90 2200000A 		beq	.L411
 5113 2d94 030050E3 		cmp	r0, #3
 5114 2d98 1300000A 		beq	.L412
 5115 2d9c 010050E3 		cmp	r0, #1
 5116 2da0 0800001A 		bne	.L409
3096:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 5117              		.loc 1 3096 0
 5118 2da4 582095E5 		ldr	r2, [r5, #88]
 5119 2da8 3010A0E3 		mov	r1, #48
 5120 2dac 000052E3 		cmp	r2, #0
 5121 2db0 E420A003 		moveq	r2, #228
 5122 2db4 6420A013 		movne	r2, #100
 5123 2db8 5230A0E3 		mov	r3, #82
 5124 2dbc FEFFFFEB 		bl	SensorSetIrisControl
3097:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5125              		.loc 1 3097 0
 5126 2dc0 7D0FA0E3 		mov	r0, #500
 5127 2dc4 FEFFFFEB 		bl	_tx_thread_sleep
 5128              	.L409:
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5129              		.loc 1 3113 0
 5130 2dc8 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5131              		.loc 1 3125 0
 5132 2dcc 0020A0E3 		mov	r2, #0
 5133 2dd0 D8019FE5 		ldr	r0, .L477
 5134 2dd4 0110A0E3 		mov	r1, #1
3113:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5135              		.loc 1 3113 0
 5136 2dd8 7DC0C4E5 		strb	ip, [r4, #125]
3125:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5137              		.loc 1 3125 0
 5138 2ddc FEFFFFEB 		bl	_txe_event_flags_set
 5139              	.LVL393:
3126:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5140              		.loc 1 3126 0
 5141 2de0 002050E2 		subs	r2, r0, #0
 5142 2de4 FDFDFF0A 		beq	.L455
 5143 2de8 91FEFFEA 		b	.L456
 5144              	.LVL394:
 5145              	.L412:
3106:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5146              		.loc 1 3106 0
 5147 2dec 582095E5 		ldr	r2, [r5, #88]
 5148 2df0 8C34D6E5 		ldrb	r3, [r6, #1164]	@ zero_extendqisi2
 5149 2df4 000052E3 		cmp	r2, #0
 5150 2df8 C420A003 		moveq	r2, #196
 5151 2dfc 4420A013 		movne	r2, #68
 5152 2e00 032082E1 		orr	r2, r2, r3
 5153 2e04 3010A0E3 		mov	r1, #48
 5154 2e08 5230A0E3 		mov	r3, #82
 5155 2e0c 0100A0E3 		mov	r0, #1
 5156 2e10 FEFFFFEB 		bl	SensorSetIrisControl
3107:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5157              		.loc 1 3107 0
 5158 2e14 7D0FA0E3 		mov	r0, #500
 5159 2e18 FEFFFFEB 		bl	_tx_thread_sleep
 5160 2e1c E9FFFFEA 		b	.L409
 5161              	.L411:
3101:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 5162              		.loc 1 3101 0
 5163 2e20 582095E5 		ldr	r2, [r5, #88]
 5164 2e24 3010A0E3 		mov	r1, #48
 5165 2e28 000052E3 		cmp	r2, #0
 5166 2e2c D420A003 		moveq	r2, #212
 5167 2e30 5420A013 		movne	r2, #84
 5168 2e34 5230A0E3 		mov	r3, #82
 5169 2e38 0100A0E3 		mov	r0, #1
 5170 2e3c FEFFFFEB 		bl	SensorSetIrisControl
3102:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5171              		.loc 1 3102 0
 5172 2e40 7D0FA0E3 		mov	r0, #500
 5173 2e44 FEFFFFEB 		bl	_tx_thread_sleep
 5174 2e48 DEFFFFEA 		b	.L409
 5175              	.L367:
 5176              	.LVL395:
 5177              	.LBE116:
 5178              	.LBE154:
 5179              	.LBB155:
 5180              	.LBB121:
2932:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5181              		.loc 1 2932 0
 5182 2e4c 1600A0E3 		mov	r0, #22
 5183 2e50 FEFFFFEB 		bl	ControlHandle
 5184              	.LVL396:
 5185 2e54 28309DE5 		ldr	r3, [sp, #40]
 5186 2e58 D7FDFFEA 		b	.L321
 5187              	.L353:
 5188              	.LVL397:
 5189              	.LBE121:
 5190              	.LBE155:
 5191              	.LBB156:
 5192              	.LBB105:
2728:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5193              		.loc 1 2728 0
 5194 2e5c 0A00A0E3 		mov	r0, #10
 5195 2e60 FEFFFFEB 		bl	CTControlHandle
 5196              	.LVL398:
 5197 2e64 28309DE5 		ldr	r3, [sp, #40]
 5198 2e68 D3FDFFEA 		b	.L321
 5199              	.L352:
 5200              	.LVL399:
2724:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5201              		.loc 1 2724 0
 5202 2e6c 0900A0E3 		mov	r0, #9
 5203 2e70 FEFFFFEB 		bl	CTControlHandle
 5204              	.LVL400:
 5205 2e74 28309DE5 		ldr	r3, [sp, #40]
 5206 2e78 CFFDFFEA 		b	.L321
 5207              	.L366:
 5208              	.LVL401:
 5209              	.LBE105:
 5210              	.LBE156:
 5211              	.LBB157:
 5212              	.LBB129:
2928:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5213              		.loc 1 2928 0
 5214 2e7c 1500A0E3 		mov	r0, #21
 5215 2e80 FEFFFFEB 		bl	ControlHandle
 5216              	.LVL402:
 5217 2e84 28309DE5 		ldr	r3, [sp, #40]
 5218 2e88 CBFDFFEA 		b	.L321
 5219              	.L338:
 5220              	.LVL403:
 5221              	.LBE129:
 5222              	.LBE157:
 5223              	.LBB158:
 5224              	.LBB91:
2649:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 5225              		.loc 1 2649 0
 5226 2e8c 0E00A0E3 		mov	r0, #14
 5227 2e90 FEFFFFEB 		bl	ControlHandle
 5228              	.LVL404:
 5229 2e94 28309DE5 		ldr	r3, [sp, #40]
 5230 2e98 C7FDFFEA 		b	.L321
 5231              	.L346:
 5232              	.LVL405:
 5233              	.LBE91:
 5234              	.LBE158:
 5235              	.LBB159:
 5236              	.LBB98:
2696:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 5237              		.loc 1 2696 0
 5238 2e9c 0300A0E3 		mov	r0, #3
 5239 2ea0 FEFFFFEB 		bl	CTControlHandle
 5240              	.LVL406:
 5241 2ea4 28309DE5 		ldr	r3, [sp, #40]
 5242 2ea8 C3FDFFEA 		b	.L321
 5243              	.LVL407:
 5244              	.L438:
 5245              	.LBE98:
 5246              	.LBE159:
 5247              	.LBB160:
 5248              	.LBB108:
3258:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5249              		.loc 1 3258 0
 5250 2eac 0200A0E3 		mov	r0, #2
 5251 2eb0 38119FE5 		ldr	r1, .L477+64
 5252 2eb4 FBFEFFEA 		b	.L457
 5253              	.LVL408:
 5254              	.L376:
 5255              	.LBE108:
 5256              	.LBE160:
 5257              	.LBB161:
 5258              	.LBB120:
2975:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5259              		.loc 1 2975 0
 5260 2eb8 2100A0E3 		mov	r0, #33
 5261 2ebc FEFFFFEB 		bl	ControlHandle
 5262              	.LVL409:
 5263 2ec0 28309DE5 		ldr	r3, [sp, #40]
 5264 2ec4 BCFDFFEA 		b	.L321
 5265              	.L343:
 5266              	.LVL410:
 5267              	.LBE120:
 5268              	.LBE161:
 5269              	.LBB162:
 5270              	.LBB106:
2683:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 5271              		.loc 1 2683 0
 5272 2ec8 0000A0E3 		mov	r0, #0
 5273 2ecc FEFFFFEB 		bl	CTControlHandle
 5274              	.LVL411:
 5275 2ed0 28309DE5 		ldr	r3, [sp, #40]
 5276 2ed4 B8FDFFEA 		b	.L321
 5277              	.L345:
 5278              	.LVL412:
2691:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 5279              		.loc 1 2691 0
 5280 2ed8 0200A0E3 		mov	r0, #2
 5281 2edc FEFFFFEB 		bl	CTControlHandle
 5282              	.LVL413:
 5283 2ee0 28309DE5 		ldr	r3, [sp, #40]
 5284 2ee4 B4FDFFEA 		b	.L321
 5285              	.L348:
 5286              	.LVL414:
2705:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 5287              		.loc 1 2705 0
 5288 2ee8 0500A0E3 		mov	r0, #5
 5289 2eec FEFFFFEB 		bl	CTControlHandle
 5290              	.LVL415:
 5291 2ef0 28309DE5 		ldr	r3, [sp, #40]
 5292 2ef4 B0FDFFEA 		b	.L321
 5293              	.L468:
 5294              	.LVL416:
 5295              	.LBE106:
 5296              	.LBE162:
 5297              	.LBB163:
 5298              	.LBB96:
2612:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5299              		.loc 1 2612 0
 5300 2ef8 0100A0E3 		mov	r0, #1
 5301 2efc FEFFFFEB 		bl	ControlHandle
 5302              	.LVL417:
 5303 2f00 28309DE5 		ldr	r3, [sp, #40]
 5304 2f04 ACFDFFEA 		b	.L321
 5305              	.L329:
 5306              	.LVL418:
2608:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 5307              		.loc 1 2608 0
 5308 2f08 0000A0E3 		mov	r0, #0
 5309 2f0c FEFFFFEB 		bl	ControlHandle
 5310              	.LVL419:
 5311 2f10 28309DE5 		ldr	r3, [sp, #40]
 5312 2f14 A8FDFFEA 		b	.L321
 5313              	.L331:
 5314              	.LVL420:
2616:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 5315              		.loc 1 2616 0
 5316 2f18 0200A0E3 		mov	r0, #2
 5317 2f1c FEFFFFEB 		bl	ControlHandle
 5318              	.LVL421:
 5319 2f20 28309DE5 		ldr	r3, [sp, #40]
 5320 2f24 A4FDFFEA 		b	.L321
 5321              	.L333:
 5322              	.LVL422:
2627:../uvc.c      ****      		ControlHandle(HueCtlID5);
 5323              		.loc 1 2627 0
 5324 2f28 0500A0E3 		mov	r0, #5
 5325 2f2c FEFFFFEB 		bl	ControlHandle
 5326              	.LVL423:
 5327 2f30 28309DE5 		ldr	r3, [sp, #40]
 5328 2f34 A0FDFFEA 		b	.L321
 5329              	.L362:
 5330              	.LVL424:
 5331              	.LBE96:
 5332              	.LBE163:
 5333              	.LBB164:
 5334              	.LBB130:
2912:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5335              		.loc 1 2912 0
 5336 2f38 1100A0E3 		mov	r0, #17
 5337 2f3c FEFFFFEB 		bl	ControlHandle
 5338              	.LVL425:
 5339 2f40 28309DE5 		ldr	r3, [sp, #40]
 5340 2f44 9CFDFFEA 		b	.L321
 5341              	.L364:
 5342              	.LVL426:
2920:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5343              		.loc 1 2920 0
 5344 2f48 1300A0E3 		mov	r0, #19
 5345 2f4c FEFFFFEB 		bl	ControlHandle
 5346              	.LVL427:
 5347 2f50 28309DE5 		ldr	r3, [sp, #40]
 5348 2f54 98FDFFEA 		b	.L321
 5349              	.L369:
 5350              	.LVL428:
2940:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5351              		.loc 1 2940 0
 5352 2f58 1800A0E3 		mov	r0, #24
 5353 2f5c FEFFFFEB 		bl	ControlHandle
 5354              	.LVL429:
 5355 2f60 28309DE5 		ldr	r3, [sp, #40]
 5356 2f64 94FDFFEA 		b	.L321
 5357              	.L363:
 5358              	.LVL430:
2916:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5359              		.loc 1 2916 0
 5360 2f68 1200A0E3 		mov	r0, #18
 5361 2f6c FEFFFFEB 		bl	ControlHandle
 5362              	.LVL431:
 5363 2f70 28309DE5 		ldr	r3, [sp, #40]
 5364 2f74 90FDFFEA 		b	.L321
 5365              	.LVL432:
 5366              	.L437:
 5367              	.LBE130:
 5368              	.LBE164:
 5369              	.LBB165:
 5370              	.LBB117:
3261:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5371              		.loc 1 3261 0
 5372 2f78 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5373 2f7c 030051E3 		cmp	r1, #3
 5374 2f80 98FEFF1A 		bne	.L441
3263:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5375              		.loc 1 3263 0
 5376 2f84 1A00A0E3 		mov	r0, #26
 5377 2f88 74109FE5 		ldr	r1, .L477+84
 5378 2f8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5379 2f90 28309DE5 		ldr	r3, [sp, #40]
 5380 2f94 92FDFFEA 		b	.L383
 5381              	.LVL433:
 5382              	.L442:
3292:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5383              		.loc 1 3292 0
 5384 2f98 68109FE5 		ldr	r1, .L477+88
 5385 2f9c BE22DDE1 		ldrh	r2, [sp, #46]
 5386 2fa0 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5387 2fa4 0400A0E3 		mov	r0, #4
 5388              	.LVL434:
 5389 2fa8 FEFFFFEB 		bl	CyU3PDebugPrint
 5390 2fac 87FDFFEA 		b	.L385
 5391              	.L478:
 5392              		.align	2
 5393              	.L477:
 5394 2fb0 00000000 		.word	.LANCHOR0
 5395 2fb4 00000000 		.word	.LANCHOR1
 5396 2fb8 00000000 		.word	bRequest
 5397 2fbc 00000000 		.word	wValue
 5398 2fc0 00000000 		.word	wIndex
 5399 2fc4 00000000 		.word	glInterStaBuffer
 5400 2fc8 10050000 		.word	.LC27
 5401 2fcc 00000000 		.word	glChHandleInterStat
 5402 2fd0 00000000 		.word	bmReqType
 5403 2fd4 00000000 		.word	wLength
 5404 2fd8 94040000 		.word	.LC26
 5405 2fdc 80000000 		.word	.LANCHOR0+128
 5406 2fe0 64050000 		.word	.LC29
 5407 2fe4 68060000 		.word	.LANCHOR1+1640
 5408 2fe8 74060000 		.word	.LANCHOR1+1652
 5409 2fec 30060000 		.word	.LANCHOR1+1584
 5410 2ff0 5C000000 		.word	.LANCHOR0+92
 5411 2ff4 B4050000 		.word	.LC31
 5412 2ff8 D8010000 		.word	.LC12
 5413 2ffc 14060000 		.word	.LANCHOR1+1556
 5414 3000 3C050000 		.word	.LC28
 5415 3004 4C060000 		.word	.LANCHOR1+1612
 5416 3008 8C050000 		.word	.LC30
 5417              	.LBE117:
 5418              	.LBE165:
 5419              		.cfi_endproc
 5420              	.LFE24:
 5422              		.align	2
 5423              		.global	CamDefSet
 5425              	CamDefSet:
 5426              	.LFB4:
1213:../uvc.c      **** {
 5427              		.loc 1 1213 0
 5428              		.cfi_startproc
 5429              		@ args = 0, pretend = 0, frame = 24
 5430              		@ frame_needed = 0, uses_anonymous_args = 0
 5431              	.LVL435:
 5432 300c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5433              	.LCFI19:
 5434              		.cfi_def_cfa_offset 36
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5435              		.loc 1 1219 0
 5436 3010 AC429FE5 		ldr	r4, .L482
 5437              		.cfi_offset 14, -4
 5438              		.cfi_offset 11, -8
 5439              		.cfi_offset 10, -12
 5440              		.cfi_offset 9, -16
 5441              		.cfi_offset 8, -20
 5442              		.cfi_offset 7, -24
 5443              		.cfi_offset 6, -28
 5444              		.cfi_offset 5, -32
 5445              		.cfi_offset 4, -36
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5446              		.loc 1 1224 0
 5447 3014 AC229FE5 		ldr	r2, .L482+4
1221:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5448              		.loc 1 1221 0
 5449 3018 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1213:../uvc.c      **** {
 5450              		.loc 1 1213 0
 5451 301c 2CD04DE2 		sub	sp, sp, #44
 5452              	.LCFI20:
 5453              		.cfi_def_cfa_offset 80
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5454              		.loc 1 1224 0
 5455 3020 1C0092E5 		ldr	r0, [r2, #28]
 5456 3024 0010E0E3 		mvn	r1, #0
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5457              		.loc 1 1226 0
 5458 3028 2963A0E1 		mov	r6, r9, lsr #6
1220:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5459              		.loc 1 1220 0
 5460 302c A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1219:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5461              		.loc 1 1219 0
 5462 3030 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5463              	.LVL436:
1224:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5464              		.loc 1 1224 0
 5465 3034 FEFFFFEB 		bl	_txe_mutex_get
1225:../uvc.c      ****     if(Data1&0x80){
 5466              		.loc 1 1225 0
 5467 3038 800019E3 		tst	r9, #128
1226:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5468              		.loc 1 1226 0
 5469 303c 01600612 		andne	r6, r6, #1
 5470 3040 0660E011 		mvnne	r6, r6
 5471 3044 3B600612 		andne	r6, r6, #59
 5472 3048 0660E011 		mvnne	r6, r6
 5473 304c FF600612 		andne	r6, r6, #255
 5474              	.LVL437:
1228:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5475              		.loc 1 1228 0
 5476 3050 C6608603 		orreq	r6, r6, #198
 5477              	.LVL438:
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5478              		.loc 1 1232 0
 5479 3054 0080A0E3 		mov	r8, #0
 5480 3058 0A20A0E1 		mov	r2, sl
 5481 305c 0730A0E1 		mov	r3, r7
 5482 3060 0110A0E3 		mov	r1, #1
1230:../uvc.c      ****     Data0 = (Data0 << 2);
 5483              		.loc 1 1230 0
 5484 3064 0951A0E1 		mov	r5, r9, asl #2
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5485              		.loc 1 1232 0
 5486 3068 58029FE5 		ldr	r0, .L482+4
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5487              		.loc 1 1235 0
 5488 306c 0190A0E3 		mov	r9, #1
 5489              	.LVL439:
1230:../uvc.c      ****     Data0 = (Data0 << 2);
 5490              		.loc 1 1230 0
 5491 3070 FF5005E2 		and	r5, r5, #255
 5492              	.LVL440:
1232:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5493              		.loc 1 1232 0
 5494 3074 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5495 3078 FEFFFFEB 		bl	cmdSet
 5496              	.LVL441:
1235:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5497              		.loc 1 1235 0
 5498 307c 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5499 3080 0910A0E1 		mov	r1, r9
 5500 3084 0730A0E1 		mov	r3, r7
 5501 3088 38029FE5 		ldr	r0, .L482+4
 5502 308c 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5503 3090 FEFFFFEB 		bl	cmdSet
 5504              	.LVL442:
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5505              		.loc 1 1238 0
 5506 3094 0620A0E1 		mov	r2, r6
 5507 3098 0530A0E1 		mov	r3, r5
 5508 309c 28129FE5 		ldr	r1, .L482+8
 5509 30a0 0400A0E3 		mov	r0, #4
1237:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5510              		.loc 1 1237 0
 5511 30a4 A661C4E5 		strb	r6, [r4, #422]
1236:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5512              		.loc 1 1236 0
 5513 30a8 A551C4E5 		strb	r5, [r4, #421]
1238:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5514              		.loc 1 1238 0
 5515 30ac FEFFFFEB 		bl	CyU3PDebugPrint
 5516              	.LVL443:
1243:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5517              		.loc 1 1243 0
 5518 30b0 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5519              	.LVL444:
1244:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5520              		.loc 1 1244 0
 5521 30b4 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5522 30b8 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5523 30bc 0210A0E3 		mov	r1, #2
 5524 30c0 00029FE5 		ldr	r0, .L482+4
 5525 30c4 00B08DE5 		str	fp, [sp, #0]
 5526 30c8 04808DE5 		str	r8, [sp, #4]
 5527 30cc FEFFFFEB 		bl	cmdSet
 5528              	.LVL445:
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5529              		.loc 1 1246 0
 5530 30d0 0B20A0E1 		mov	r2, fp
 5531 30d4 0530A0E1 		mov	r3, r5
 5532 30d8 EC119FE5 		ldr	r1, .L482+8
 5533 30dc 0400A0E3 		mov	r0, #4
1245:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5534              		.loc 1 1245 0
 5535 30e0 BD51C4E5 		strb	r5, [r4, #445]
1246:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5536              		.loc 1 1246 0
 5537 30e4 FEFFFFEB 		bl	CyU3PDebugPrint
 5538              	.LVL446:
1251:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5539              		.loc 1 1251 0
 5540 30e8 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1250:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5541              		.loc 1 1250 0
 5542 30ec 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5543              	.LVL447:
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5544              		.loc 1 1252 0
 5545 30f0 80B047E2 		sub	fp, r7, #128
 5546 30f4 FF100BE2 		and	r1, fp, #255
 5547 30f8 14108DE5 		str	r1, [sp, #20]
 5548 30fc 14C09DE5 		ldr	ip, [sp, #20]
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5549              		.loc 1 1253 0
 5550 3100 760047E2 		sub	r0, r7, #118
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5551              		.loc 1 1254 0
 5552 3104 7EE087E2 		add	lr, r7, #126
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5553              		.loc 1 1252 0
 5554 3108 0630A0E1 		mov	r3, r6
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5555              		.loc 1 1253 0
 5556 310c 18008DE5 		str	r0, [sp, #24]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5557              		.loc 1 1252 0
 5558 3110 0510A0E3 		mov	r1, #5
 5559 3114 DF20A0E3 		mov	r2, #223
 5560 3118 A8019FE5 		ldr	r0, .L482+4
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5561              		.loc 1 1254 0
 5562 311c 1CE08DE5 		str	lr, [sp, #28]
1252:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5563              		.loc 1 1252 0
 5564 3120 00C08DE5 		str	ip, [sp, #0]
 5565 3124 04808DE5 		str	r8, [sp, #4]
 5566 3128 FEFFFFEB 		bl	cmdSet
 5567              	.LVL448:
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5568              		.loc 1 1253 0
 5569 312c 18A09DE5 		ldr	sl, [sp, #24]
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5570              		.loc 1 1255 0
 5571 3130 72E087E2 		add	lr, r7, #114
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5572              		.loc 1 1253 0
 5573 3134 FFC00AE2 		and	ip, sl, #255
 5574 3138 0630A0E1 		mov	r3, r6
 5575 313c 0510A0E3 		mov	r1, #5
 5576 3140 DC20A0E3 		mov	r2, #220
 5577 3144 7C019FE5 		ldr	r0, .L482+4
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5578              		.loc 1 1255 0
 5579 3148 20E08DE5 		str	lr, [sp, #32]
1253:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5580              		.loc 1 1253 0
 5581 314c 00C08DE5 		str	ip, [sp, #0]
 5582 3150 04908DE5 		str	r9, [sp, #4]
 5583 3154 FEFFFFEB 		bl	cmdSet
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5584              		.loc 1 1254 0
 5585 3158 1C009DE5 		ldr	r0, [sp, #28]
 5586 315c 02E0A0E3 		mov	lr, #2
 5587 3160 FFC000E2 		and	ip, r0, #255
 5588 3164 0630A0E1 		mov	r3, r6
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5589              		.loc 1 1256 0
 5590 3168 6FA047E2 		sub	sl, r7, #111
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5591              		.loc 1 1254 0
 5592 316c 0510A0E3 		mov	r1, #5
 5593 3170 DE20A0E3 		mov	r2, #222
 5594 3174 4C019FE5 		ldr	r0, .L482+4
 5595 3178 04E08DE5 		str	lr, [sp, #4]
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5596              		.loc 1 1256 0
 5597 317c 24A08DE5 		str	sl, [sp, #36]
1254:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5598              		.loc 1 1254 0
 5599 3180 00C08DE5 		str	ip, [sp, #0]
 5600 3184 FEFFFFEB 		bl	cmdSet
1255:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5601              		.loc 1 1255 0
 5602 3188 20A09DE5 		ldr	sl, [sp, #32]
 5603 318c 0630A0E1 		mov	r3, r6
 5604 3190 FFC00AE2 		and	ip, sl, #255
 5605 3194 00C08DE5 		str	ip, [sp, #0]
 5606 3198 0510A0E3 		mov	r1, #5
 5607 319c 03C0A0E3 		mov	ip, #3
 5608 31a0 E020A0E3 		mov	r2, #224
 5609 31a4 1C019FE5 		ldr	r0, .L482+4
 5610 31a8 04C08DE5 		str	ip, [sp, #4]
 5611 31ac FEFFFFEB 		bl	cmdSet
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5612              		.loc 1 1256 0
 5613 31b0 24009DE5 		ldr	r0, [sp, #36]
 5614 31b4 04A0A0E3 		mov	sl, #4
 5615 31b8 FFC000E2 		and	ip, r0, #255
 5616 31bc 0630A0E1 		mov	r3, r6
 5617 31c0 0510A0E3 		mov	r1, #5
 5618 31c4 DD20A0E3 		mov	r2, #221
 5619 31c8 F8009FE5 		ldr	r0, .L482+4
 5620 31cc 00C08DE5 		str	ip, [sp, #0]
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5621              		.loc 1 1257 0
 5622 31d0 7F7087E2 		add	r7, r7, #127
 5623              	.LVL449:
1256:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5624              		.loc 1 1256 0
 5625 31d4 04A08DE5 		str	sl, [sp, #4]
 5626 31d8 FEFFFFEB 		bl	cmdSet
1257:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5627              		.loc 1 1257 0
 5628 31dc 05E0A0E3 		mov	lr, #5
 5629 31e0 0E10A0E1 		mov	r1, lr
 5630 31e4 0630A0E1 		mov	r3, r6
 5631 31e8 E120A0E3 		mov	r2, #225
 5632 31ec FF6007E2 		and	r6, r7, #255
 5633              	.LVL450:
 5634 31f0 D0009FE5 		ldr	r0, .L482+4
 5635 31f4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5636 31f8 FEFFFFEB 		bl	cmdSet
 5637              	.LVL451:
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5638              		.loc 1 1258 0
 5639 31fc 14C09DE5 		ldr	ip, [sp, #20]
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5640              		.loc 1 1259 0
 5641 3200 24E09DE5 		ldr	lr, [sp, #36]
 5642 3204 1C609DE5 		ldr	r6, [sp, #28]
1258:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5643              		.loc 1 1258 0
 5644 3208 05C2C4E5 		strb	ip, [r4, #517]
1259:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5645              		.loc 1 1259 0
 5646 320c 20C09DE5 		ldr	ip, [sp, #32]
 5647 3210 0B20A0E1 		mov	r2, fp
 5648 3214 18309DE5 		ldr	r3, [sp, #24]
 5649 3218 B0109FE5 		ldr	r1, .L482+12
 5650 321c 0A00A0E1 		mov	r0, sl
 5651 3220 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5652 3224 0C708DE5 		str	r7, [sp, #12]
 5653 3228 FEFFFFEB 		bl	CyU3PDebugPrint
 5654              	.LVL452:
1263:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5655              		.loc 1 1263 0
 5656 322c 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5657              	.LVL453:
1264:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5658              		.loc 1 1264 0
 5659 3230 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5660              	.LVL454:
1265:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5661              		.loc 1 1265 0
 5662 3234 0730A0E1 		mov	r3, r7
 5663 3238 0610A0E3 		mov	r1, #6
 5664 323c 8520A0E3 		mov	r2, #133
 5665 3240 80009FE5 		ldr	r0, .L482+4
 5666 3244 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5667 3248 FEFFFFEB 		bl	cmdSet
1266:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5668              		.loc 1 1266 0
 5669 324c 0730A0E1 		mov	r3, r7
 5670 3250 0610A0E3 		mov	r1, #6
 5671 3254 8620A0E3 		mov	r2, #134
 5672 3258 68009FE5 		ldr	r0, .L482+4
 5673 325c 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5674 3260 FEFFFFEB 		bl	cmdSet
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5675              		.loc 1 1268 0
 5676 3264 0620A0E1 		mov	r2, r6
 5677 3268 0530A0E1 		mov	r3, r5
 5678 326c 58109FE5 		ldr	r1, .L482+8
 5679 3270 0A00A0E1 		mov	r0, sl
1267:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5680              		.loc 1 1267 0
 5681 3274 1D62C4E5 		strb	r6, [r4, #541]
1268:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5682              		.loc 1 1268 0
 5683 3278 FEFFFFEB 		bl	CyU3PDebugPrint
 5684              	.LVL455:
1273:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5685              		.loc 1 1273 0
 5686 327c 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5687              	.LVL456:
1274:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5688              		.loc 1 1274 0
 5689 3280 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5690 3284 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5691 3288 0710A0E3 		mov	r1, #7
 5692 328c 34009FE5 		ldr	r0, .L482+4
 5693 3290 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5694 3294 FEFFFFEB 		bl	cmdSet
 5695              	.LVL457:
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5696              		.loc 1 1276 0
 5697 3298 0530A0E1 		mov	r3, r5
 5698 329c 0A00A0E1 		mov	r0, sl
 5699 32a0 24109FE5 		ldr	r1, .L482+8
 5700 32a4 0620A0E1 		mov	r2, r6
1275:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5701              		.loc 1 1275 0
 5702 32a8 3552C4E5 		strb	r5, [r4, #565]
1276:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5703              		.loc 1 1276 0
 5704 32ac FEFFFFEB 		bl	CyU3PDebugPrint
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5705              		.loc 1 1278 0
 5706 32b0 10309FE5 		ldr	r3, .L482+4
 5707 32b4 1C0093E5 		ldr	r0, [r3, #28]
1281:../uvc.c      **** }
 5708              		.loc 1 1281 0
 5709 32b8 2CD08DE2 		add	sp, sp, #44
 5710 32bc F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1278:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5711              		.loc 1 1278 0
 5712 32c0 FEFFFFEA 		b	_txe_mutex_put
 5713              	.L483:
 5714              		.align	2
 5715              	.L482:
 5716 32c4 00000000 		.word	.LANCHOR1
 5717 32c8 00000000 		.word	cmdQu
 5718 32cc E8050000 		.word	.LC32
 5719 32d0 08060000 		.word	.LC33
 5720              		.cfi_endproc
 5721              	.LFE4:
 5723              		.align	2
 5724              		.global	CyFxUVCAddHeader
 5726              	CyFxUVCAddHeader:
 5727              	.LFB5:
1289:../uvc.c      **** {
 5728              		.loc 1 1289 0
 5729              		.cfi_startproc
 5730              		@ args = 0, pretend = 0, frame = 0
 5731              		@ frame_needed = 0, uses_anonymous_args = 0
 5732              	.LVL458:
 5733 32d4 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5734              	.LCFI21:
 5735              		.cfi_def_cfa_offset 16
1289:../uvc.c      **** {
 5736              		.loc 1 1289 0
 5737 32d8 0040A0E1 		mov	r4, r0
 5738              		.cfi_offset 14, -4
 5739              		.cfi_offset 5, -8
 5740              		.cfi_offset 4, -12
 5741              		.cfi_offset 3, -16
 5742 32dc 0150A0E1 		mov	r5, r1
1291:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 5743              		.loc 1 1291 0
 5744 32e0 30009FE5 		ldr	r0, .L486
 5745              	.LVL459:
 5746 32e4 0010E0E3 		mvn	r1, #0
 5747              	.LVL460:
 5748 32e8 FEFFFFEB 		bl	_txe_mutex_get
1292:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5749              		.loc 1 1292 0
 5750 32ec 0400A0E1 		mov	r0, r4
 5751 32f0 24109FE5 		ldr	r1, .L486+4
 5752 32f4 0C20A0E3 		mov	r2, #12
 5753 32f8 FEFFFFEB 		bl	CyU3PMemCopy
1293:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 5754              		.loc 1 1293 0
 5755 32fc 14009FE5 		ldr	r0, .L486
 5756 3300 FEFFFFEB 		bl	_txe_mutex_put
1296:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5757              		.loc 1 1296 0
 5758 3304 020015E3 		tst	r5, #2
1298:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5759              		.loc 1 1298 0
 5760 3308 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5761 330c 02308313 		orrne	r3, r3, #2
 5762 3310 0130C415 		strneb	r3, [r4, #1]
 5763 3314 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5764              	.L487:
 5765              		.align	2
 5766              	.L486:
 5767 3318 00000000 		.word	imgHdMux
 5768 331c 80040000 		.word	.LANCHOR1+1152
 5769              		.cfi_endproc
 5770              	.LFE5:
 5772              		.align	2
 5773              		.global	CyFxAppErrorHandler
 5775              	CyFxAppErrorHandler:
 5776              	.LFB6:
1308:../uvc.c      **** {
 5777              		.loc 1 1308 0
 5778              		.cfi_startproc
 5779              		@ args = 0, pretend = 0, frame = 0
 5780              		@ frame_needed = 0, uses_anonymous_args = 0
 5781              	.LVL461:
 5782 3320 08402DE9 		stmfd	sp!, {r3, lr}
 5783              	.LCFI22:
 5784              		.cfi_def_cfa_offset 8
 5785              	.LVL462:
 5786              	.L489:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5787              		.loc 1 1318 0 discriminator 1
 5788 3324 10109FE5 		ldr	r1, .L490
 5789 3328 0400A0E3 		mov	r0, #4
 5790              		.cfi_offset 14, -4
 5791              		.cfi_offset 3, -8
 5792 332c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 5793              		.loc 1 1319 0 discriminator 1
 5794 3330 FA0FA0E3 		mov	r0, #1000
 5795 3334 FEFFFFEB 		bl	_tx_thread_sleep
 5796 3338 F9FFFFEA 		b	.L489
 5797              	.L491:
 5798              		.align	2
 5799              	.L490:
 5800 333c D8010000 		.word	.LC12
 5801              		.cfi_endproc
 5802              	.LFE6:
 5804              		.align	2
 5805              		.global	UVCAppThread_Entry
 5807              	UVCAppThread_Entry:
 5808              	.LFB18:
2295:../uvc.c      **** {
 5809              		.loc 1 2295 0
 5810              		.cfi_startproc
 5811              		@ args = 0, pretend = 0, frame = 176
 5812              		@ frame_needed = 0, uses_anonymous_args = 0
 5813              	.LVL463:
 5814 3340 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5815              	.LCFI23:
 5816              		.cfi_def_cfa_offset 28
 5817 3344 BCD04DE2 		sub	sp, sp, #188
 5818              	.LCFI24:
 5819              		.cfi_def_cfa_offset 216
 5820              	.LBB218:
 5821              	.LBB219:
1751:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5822              		.loc 1 1751 0
 5823              		.cfi_offset 14, -4
 5824              		.cfi_offset 10, -8
 5825              		.cfi_offset 8, -12
 5826              		.cfi_offset 7, -16
 5827              		.cfi_offset 6, -20
 5828              		.cfi_offset 5, -24
 5829              		.cfi_offset 4, -28
 5830 3348 FEFFFFEB 		bl	CyU3PUartInit
 5831              	.LVL464:
1752:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5832              		.loc 1 1752 0
 5833 334c 004050E2 		subs	r4, r0, #0
 5834 3350 0400000A 		beq	.L493
1754:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5835              		.loc 1 1754 0
 5836 3354 0400A0E3 		mov	r0, #4
 5837              	.LVL465:
 5838 3358 501B9FE5 		ldr	r1, .L599
 5839 335c FEFFFFEB 		bl	CyU3PDebugPrint
1755:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5840              		.loc 1 1755 0
 5841 3360 0400A0E1 		mov	r0, r4
 5842 3364 FEFFFFEB 		bl	CyFxAppErrorHandler
 5843              	.L493:
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5844              		.loc 1 1759 0
 5845 3368 44CB9FE5 		ldr	ip, .L599+4
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5846              		.loc 1 1761 0
 5847 336c 0030A0E3 		mov	r3, #0
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5848              		.loc 1 1760 0
 5849 3370 0120A0E3 		mov	r2, #1
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5850              		.loc 1 1768 0
 5851 3374 50008DE2 		add	r0, sp, #80
 5852 3378 0310A0E1 		mov	r1, r3
1759:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5853              		.loc 1 1759 0
 5854 337c 60C08DE5 		str	ip, [sp, #96]
1760:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5855              		.loc 1 1760 0
 5856 3380 6420CDE5 		strb	r2, [sp, #100]
1761:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5857              		.loc 1 1761 0
 5858 3384 6530CDE5 		strb	r3, [sp, #101]
1762:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5859              		.loc 1 1762 0
 5860 3388 50208DE5 		str	r2, [sp, #80]
1763:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5861              		.loc 1 1763 0
 5862 338c 54308DE5 		str	r3, [sp, #84]
1764:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5863              		.loc 1 1764 0
 5864 3390 58308DE5 		str	r3, [sp, #88]
1765:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5865              		.loc 1 1765 0
 5866 3394 5C208DE5 		str	r2, [sp, #92]
1768:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5867              		.loc 1 1768 0
 5868 3398 FEFFFFEB 		bl	CyU3PUartSetConfig
 5869              	.LVL466:
1769:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5870              		.loc 1 1769 0
 5871 339c 000050E3 		cmp	r0, #0
 5872 33a0 0000000A 		beq	.L494
1771:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5873              		.loc 1 1771 0
 5874 33a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5875              	.LVL467:
 5876              	.L494:
1775:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5877              		.loc 1 1775 0
 5878 33a8 0000E0E3 		mvn	r0, #0
 5879 33ac FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5880              	.LVL468:
1776:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5881              		.loc 1 1776 0
 5882 33b0 000050E3 		cmp	r0, #0
 5883 33b4 0000000A 		beq	.L495
1778:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5884              		.loc 1 1778 0
 5885 33b8 FEFFFFEB 		bl	CyFxAppErrorHandler
 5886              	.LVL469:
 5887              	.L495:
1782:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5888              		.loc 1 1782 0
 5889 33bc 0300A0E3 		mov	r0, #3
 5890 33c0 0410A0E3 		mov	r1, #4
 5891 33c4 FEFFFFEB 		bl	CyU3PDebugInit
 5892              	.LVL470:
1783:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5893              		.loc 1 1783 0
 5894 33c8 000050E3 		cmp	r0, #0
 5895 33cc 0000000A 		beq	.L496
1785:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5896              		.loc 1 1785 0
 5897 33d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 5898              	.LVL471:
 5899              	.L496:
1789:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5900              		.loc 1 1789 0
 5901 33d4 0000A0E3 		mov	r0, #0
 5902 33d8 FEFFFFEB 		bl	CyU3PDebugPreamble
 5903              	.LVL472:
 5904              	.LBE219:
 5905              	.LBE218:
2311:../uvc.c      **** 		CyU3PThreadSleep(500);
 5906              		.loc 1 2311 0
 5907 33dc 7D0FA0E3 		mov	r0, #500
 5908 33e0 FEFFFFEB 		bl	_tx_thread_sleep
 5909              	.LVL473:
 5910 33e4 7D0FA0E3 		mov	r0, #500
 5911 33e8 FEFFFFEB 		bl	_tx_thread_sleep
 5912 33ec 7D0FA0E3 		mov	r0, #500
 5913 33f0 FEFFFFEB 		bl	_tx_thread_sleep
 5914 33f4 7D0FA0E3 		mov	r0, #500
 5915 33f8 FEFFFFEB 		bl	_tx_thread_sleep
 5916 33fc 7D0FA0E3 		mov	r0, #500
 5917 3400 FEFFFFEB 		bl	_tx_thread_sleep
 5918 3404 7D0FA0E3 		mov	r0, #500
 5919 3408 FEFFFFEB 		bl	_tx_thread_sleep
 5920              	.LBB220:
 5921              	.LBB221:
1799:../uvc.c      ****     status = CyU3PI2cInit ();
 5922              		.loc 1 1799 0
 5923 340c FEFFFFEB 		bl	CyU3PI2cInit
 5924              	.LVL474:
1800:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5925              		.loc 1 1800 0
 5926 3410 004050E2 		subs	r4, r0, #0
 5927 3414 0400000A 		beq	.L497
1802:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5928              		.loc 1 1802 0
 5929 3418 0400A0E3 		mov	r0, #4
 5930              	.LVL475:
 5931 341c 941A9FE5 		ldr	r1, .L599+8
 5932 3420 FEFFFFEB 		bl	CyU3PDebugPrint
1803:../uvc.c      ****         CyFxAppErrorHandler (status);
 5933              		.loc 1 1803 0
 5934 3424 0400A0E1 		mov	r0, r4
 5935 3428 FEFFFFEB 		bl	CyFxAppErrorHandler
 5936              	.L497:
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5937              		.loc 1 1807 0
 5938 342c 886A9FE5 		ldr	r6, .L599+12
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5939              		.loc 1 1808 0
 5940 3430 0050A0E3 		mov	r5, #0
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5941              		.loc 1 1809 0
 5942 3434 0040E0E3 		mvn	r4, #0
 5943              	.LVL476:
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5944              		.loc 1 1812 0
 5945 3438 8C008DE2 		add	r0, sp, #140
 5946 343c 0510A0E1 		mov	r1, r5
1809:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5947              		.loc 1 1809 0
 5948 3440 94408DE5 		str	r4, [sp, #148]
1810:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5949              		.loc 1 1810 0
 5950 3444 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1807:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5951              		.loc 1 1807 0
 5952 3448 8C608DE5 		str	r6, [sp, #140]
1808:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5953              		.loc 1 1808 0
 5954 344c 90508DE5 		str	r5, [sp, #144]
1812:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5955              		.loc 1 1812 0
 5956 3450 FEFFFFEB 		bl	CyU3PI2cSetConfig
 5957              	.LVL477:
1813:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5958              		.loc 1 1813 0
 5959 3454 004050E2 		subs	r4, r0, #0
 5960 3458 0400000A 		beq	.L498
1815:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 5961              		.loc 1 1815 0
 5962 345c 0400A0E3 		mov	r0, #4
 5963              	.LVL478:
 5964 3460 581A9FE5 		ldr	r1, .L599+16
 5965 3464 FEFFFFEB 		bl	CyU3PDebugPrint
1816:../uvc.c      ****         CyFxAppErrorHandler (status);
 5966              		.loc 1 1816 0
 5967 3468 0400A0E1 		mov	r0, r4
 5968 346c FEFFFFEB 		bl	CyFxAppErrorHandler
 5969              	.L498:
 5970              	.LBE221:
 5971              	.LBE220:
 5972              	.LBB222:
 5973              	.LBB225:
1886:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5974              		.loc 1 1886 0
 5975 3470 4C4A9FE5 		ldr	r4, .L599+20
 5976              	.LVL479:
 5977 3474 2820A0E3 		mov	r2, #40
 5978 3478 0010A0E3 		mov	r1, #0
 5979 347c 0400A0E1 		mov	r0, r4
 5980 3480 FEFFFFEB 		bl	_txe_event_flags_create
 5981              	.LVL480:
1887:../uvc.c      ****     if (apiRetStatus != 0)
 5982              		.loc 1 1887 0
 5983 3484 002050E2 		subs	r2, r0, #0
 5984 3488 F800001A 		bne	.L573
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5985              		.loc 1 1901 0
 5986 348c 0260A0E3 		mov	r6, #2
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5987              		.loc 1 1908 0
 5988 3490 0210A0E1 		mov	r1, r2
1897:../uvc.c      ****     isUsbConnected = CyFalse;
 5989              		.loc 1 1897 0
 5990 3494 302084E5 		str	r2, [r4, #48]
1898:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5991              		.loc 1 1898 0
 5992 3498 442084E5 		str	r2, [r4, #68]
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5993              		.loc 1 1904 0
 5994 349c 0370A0E3 		mov	r7, #3
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5995              		.loc 1 1908 0
 5996 34a0 9C008DE2 		add	r0, sp, #156
 5997              	.LVL481:
1903:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5998              		.loc 1 1903 0
 5999 34a4 A420CDE5 		strb	r2, [sp, #164]
1905:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6000              		.loc 1 1905 0
 6001 34a8 A0208DE5 		str	r2, [sp, #160]
1901:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 6002              		.loc 1 1901 0
 6003 34ac 9C60CDE5 		strb	r6, [sp, #156]
1902:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6004              		.loc 1 1902 0
 6005 34b0 9D60CDE5 		strb	r6, [sp, #157]
1904:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6006              		.loc 1 1904 0
 6007 34b4 A570CDE5 		strb	r7, [sp, #165]
1908:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 6008              		.loc 1 1908 0
 6009 34b8 FEFFFFEB 		bl	CyU3PGpioInit
 6010              	.LVL482:
1909:../uvc.c      ****     if (apiRetStatus != 0)
 6011              		.loc 1 1909 0
 6012 34bc 002050E2 		subs	r2, r0, #0
 6013 34c0 FC00001A 		bne	.L574
1917:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 6014              		.loc 1 1917 0
 6015 34c4 1600A0E3 		mov	r0, #22
 6016              	.LVL483:
 6017 34c8 0110A0E3 		mov	r1, #1
 6018 34cc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6019              	.LVL484:
1918:../uvc.c      ****     if (apiRetStatus != 0)
 6020              		.loc 1 1918 0
 6021 34d0 002050E2 		subs	r2, r0, #0
 6022 34d4 EE00001A 		bne	.L575
1923:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 6023              		.loc 1 1923 0
 6024 34d8 1400A0E3 		mov	r0, #20
 6025              	.LVL485:
 6026 34dc 0110A0E3 		mov	r1, #1
 6027 34e0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6028              	.LVL486:
1924:../uvc.c      ****     if (apiRetStatus != 0)
 6029              		.loc 1 1924 0
 6030 34e4 002050E2 		subs	r2, r0, #0
 6031 34e8 FB00001A 		bne	.L576
1929:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 6032              		.loc 1 1929 0
 6033 34ec 1800A0E3 		mov	r0, #24
 6034              	.LVL487:
 6035 34f0 0110A0E3 		mov	r1, #1
 6036 34f4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6037              	.LVL488:
1930:../uvc.c      ****     if (apiRetStatus != 0)
 6038              		.loc 1 1930 0
 6039 34f8 002050E2 		subs	r2, r0, #0
 6040 34fc D601001A 		bne	.L577
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6041              		.loc 1 1937 0
 6042 3500 0150A0E3 		mov	r5, #1
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6043              		.loc 1 1942 0
 6044 3504 1600A0E3 		mov	r0, #22
 6045              	.LVL489:
 6046 3508 68108DE2 		add	r1, sp, #104
1940:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6047              		.loc 1 1940 0
 6048 350c 74208DE5 		str	r2, [sp, #116]
1941:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6049              		.loc 1 1941 0
 6050 3510 7820CDE5 		strb	r2, [sp, #120]
1937:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6051              		.loc 1 1937 0
 6052 3514 68508DE5 		str	r5, [sp, #104]
1938:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6053              		.loc 1 1938 0
 6054 3518 6C508DE5 		str	r5, [sp, #108]
1939:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6055              		.loc 1 1939 0
 6056 351c 70508DE5 		str	r5, [sp, #112]
1942:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6057              		.loc 1 1942 0
 6058 3520 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6059              	.LVL490:
1943:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6060              		.loc 1 1943 0
 6061 3524 002050E2 		subs	r2, r0, #0
 6062 3528 C201001A 		bne	.L578
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6063              		.loc 1 1956 0
 6064 352c 1400A0E3 		mov	r0, #20
 6065              	.LVL491:
 6066 3530 68108DE2 		add	r1, sp, #104
1954:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6067              		.loc 1 1954 0
 6068 3534 74208DE5 		str	r2, [sp, #116]
1955:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6069              		.loc 1 1955 0
 6070 3538 7820CDE5 		strb	r2, [sp, #120]
1951:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 6071              		.loc 1 1951 0
 6072 353c 68508DE5 		str	r5, [sp, #104]
1952:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6073              		.loc 1 1952 0
 6074 3540 6C508DE5 		str	r5, [sp, #108]
1953:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6075              		.loc 1 1953 0
 6076 3544 70508DE5 		str	r5, [sp, #112]
1956:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6077              		.loc 1 1956 0
 6078 3548 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6079              	.LVL492:
1957:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6080              		.loc 1 1957 0
 6081 354c 002050E2 		subs	r2, r0, #0
 6082 3550 CA01001A 		bne	.L579
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6083              		.loc 1 1970 0
 6084 3554 1800A0E3 		mov	r0, #24
 6085              	.LVL493:
 6086 3558 68108DE2 		add	r1, sp, #104
1965:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 6087              		.loc 1 1965 0
 6088 355c 68208DE5 		str	r2, [sp, #104]
1966:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6089              		.loc 1 1966 0
 6090 3560 6C208DE5 		str	r2, [sp, #108]
1967:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6091              		.loc 1 1967 0
 6092 3564 70208DE5 		str	r2, [sp, #112]
1969:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6093              		.loc 1 1969 0
 6094 3568 7820CDE5 		strb	r2, [sp, #120]
1968:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6095              		.loc 1 1968 0
 6096 356c 74508DE5 		str	r5, [sp, #116]
1970:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6097              		.loc 1 1970 0
 6098 3570 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6099              	.LVL494:
1971:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6100              		.loc 1 1971 0
 6101 3574 002050E2 		subs	r2, r0, #0
 6102 3578 A501001A 		bne	.L580
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6103              		.loc 1 1983 0
 6104 357c 0500A0E1 		mov	r0, r5
 6105              	.LVL495:
 6106 3580 7C108DE2 		add	r1, sp, #124
1980:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6107              		.loc 1 1980 0
 6108 3584 84208DE5 		str	r2, [sp, #132]
1981:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6109              		.loc 1 1981 0
 6110 3588 80208DE5 		str	r2, [sp, #128]
1978:../uvc.c      ****     pibclock.clkDiv      = 2;
 6111              		.loc 1 1978 0
 6112 358c BC67CDE1 		strh	r6, [sp, #124]	@ movhi
1979:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6113              		.loc 1 1979 0
 6114 3590 8870CDE5 		strb	r7, [sp, #136]
1983:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 6115              		.loc 1 1983 0
 6116 3594 FEFFFFEB 		bl	CyU3PPibInit
 6117              	.LVL496:
1984:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6118              		.loc 1 1984 0
 6119 3598 002050E2 		subs	r2, r0, #0
 6120 359c 9301001A 		bne	.L581
1991:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 6121              		.loc 1 1991 0
 6122 35a0 20099FE5 		ldr	r0, .L599+24
 6123              	.LVL497:
 6124 35a4 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6125              	.LVL498:
1999:../uvc.c      ****     SensorReset ();
 6126              		.loc 1 1999 0
 6127 35a8 FEFFFFEB 		bl	SensorReset
2000:../uvc.c      ****     CyU3PThreadSleep(5000);
 6128              		.loc 1 2000 0
 6129 35ac 18099FE5 		ldr	r0, .L599+28
 6130 35b0 FEFFFFEB 		bl	_tx_thread_sleep
2004:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 6131              		.loc 1 2004 0
 6132 35b4 FEFFFFEB 		bl	CyU3PUsbStart
 6133              	.LVL499:
2005:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6134              		.loc 1 2005 0
 6135 35b8 002050E2 		subs	r2, r0, #0
 6136 35bc 8201001A 		bne	.L582
2011:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 6137              		.loc 1 2011 0
 6138 35c0 0010A0E3 		mov	r1, #0
 6139 35c4 04099FE5 		ldr	r0, .L599+32
 6140              	.LVL500:
 6141 35c8 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6142              	.LVL501:
2014:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 6143              		.loc 1 2014 0
 6144 35cc 00099FE5 		ldr	r0, .L599+36
 6145 35d0 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2020:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 6146              		.loc 1 2020 0
 6147 35d4 0010A0E3 		mov	r1, #0
 6148 35d8 F8289FE5 		ldr	r2, .L599+40
 6149 35dc 0100A0E3 		mov	r0, #1
 6150 35e0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2021:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6151              		.loc 1 2021 0
 6152 35e4 0000A0E3 		mov	r0, #0
 6153 35e8 0010A0E1 		mov	r1, r0
 6154 35ec E8289FE5 		ldr	r2, .L599+44
 6155 35f0 FEFFFFEB 		bl	CyU3PUsbSetDesc
2024:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 6156              		.loc 1 2024 0
 6157 35f4 0010A0E3 		mov	r1, #0
 6158 35f8 E0289FE5 		ldr	r2, .L599+48
 6159 35fc 0200A0E3 		mov	r0, #2
 6160 3600 FEFFFFEB 		bl	CyU3PUsbSetDesc
2025:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6161              		.loc 1 2025 0
 6162 3604 0010A0E3 		mov	r1, #0
 6163 3608 D4289FE5 		ldr	r2, .L599+52
 6164 360c 0700A0E3 		mov	r0, #7
 6165 3610 FEFFFFEB 		bl	CyU3PUsbSetDesc
2028:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 6166              		.loc 1 2028 0
 6167 3614 0010A0E3 		mov	r1, #0
 6168 3618 C8289FE5 		ldr	r2, .L599+56
 6169 361c 0400A0E3 		mov	r0, #4
 6170 3620 FEFFFFEB 		bl	CyU3PUsbSetDesc
2029:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6171              		.loc 1 2029 0
 6172 3624 0010A0E3 		mov	r1, #0
 6173 3628 BC289FE5 		ldr	r2, .L599+60
 6174 362c 0300A0E3 		mov	r0, #3
 6175 3630 FEFFFFEB 		bl	CyU3PUsbSetDesc
2030:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6176              		.loc 1 2030 0
 6177 3634 0010A0E3 		mov	r1, #0
 6178 3638 B0289FE5 		ldr	r2, .L599+64
 6179 363c 0600A0E3 		mov	r0, #6
 6180 3640 FEFFFFEB 		bl	CyU3PUsbSetDesc
2033:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 6181              		.loc 1 2033 0
 6182 3644 0010A0E3 		mov	r1, #0
 6183 3648 A4289FE5 		ldr	r2, .L599+68
 6184 364c 0500A0E3 		mov	r0, #5
 6185 3650 FEFFFFEB 		bl	CyU3PUsbSetDesc
2034:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6186              		.loc 1 2034 0
 6187 3654 0110A0E3 		mov	r1, #1
 6188 3658 98289FE5 		ldr	r2, .L599+72
 6189 365c 0500A0E3 		mov	r0, #5
 6190 3660 FEFFFFEB 		bl	CyU3PUsbSetDesc
2035:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6191              		.loc 1 2035 0
 6192 3664 0210A0E3 		mov	r1, #2
 6193 3668 8C289FE5 		ldr	r2, .L599+76
 6194 366c 0500A0E3 		mov	r0, #5
 6195 3670 FEFFFFEB 		bl	CyU3PUsbSetDesc
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6196              		.loc 1 2045 0
 6197 3674 0080A0E3 		mov	r8, #0
2042:../uvc.c      ****     endPointConfig.enable   = 1;
 6198              		.loc 1 2042 0
 6199 3678 0150A0E3 		mov	r5, #1
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6200              		.loc 1 2044 0
 6201 367c 4070A0E3 		mov	r7, #64	@ movhi
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6202              		.loc 1 2048 0
 6203 3680 8200A0E3 		mov	r0, #130
 6204 3684 A8108DE2 		add	r1, sp, #168
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6205              		.loc 1 2043 0
 6206 3688 03A0A0E3 		mov	sl, #3
2044:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6207              		.loc 1 2044 0
 6208 368c B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2042:../uvc.c      ****     endPointConfig.enable   = 1;
 6209              		.loc 1 2042 0
 6210 3690 A8508DE5 		str	r5, [sp, #168]
2043:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6211              		.loc 1 2043 0
 6212 3694 ACA0CDE5 		strb	sl, [sp, #172]
2045:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6213              		.loc 1 2045 0
 6214 3698 B380CDE5 		strb	r8, [sp, #179]
2046:../uvc.c      ****     endPointConfig.streams  = 0;
 6215              		.loc 1 2046 0
 6216 369c BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2047:../uvc.c      ****     endPointConfig.burstLen = 1;
 6217              		.loc 1 2047 0
 6218 36a0 B250CDE5 		strb	r5, [sp, #178]
2048:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6219              		.loc 1 2048 0
 6220 36a4 FEFFFFEB 		bl	CyU3PSetEpConfig
 6221              	.LVL502:
2046:../uvc.c      ****     endPointConfig.streams  = 0;
 6222              		.loc 1 2046 0
 6223 36a8 0870A0E1 		mov	r7, r8	@ movhi
2049:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6224              		.loc 1 2049 0
 6225 36ac 003050E2 		subs	r3, r0, #0
 6226 36b0 3B01001A 		bne	.L583
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6227              		.loc 1 2059 0
 6228 36b4 44C89FE5 		ldr	ip, .L599+80
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6229              		.loc 1 2060 0
 6230 36b8 44E89FE5 		ldr	lr, .L599+84
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6231              		.loc 1 2057 0
 6232 36bc 016BA0E3 		mov	r6, #1024	@ movhi
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6233              		.loc 1 2066 0
 6234 36c0 1080A0E3 		mov	r8, #16
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6235              		.loc 1 2068 0
 6236 36c4 3C089FE5 		ldr	r0, .L599+88
 6237              	.LVL503:
 6238 36c8 0410A0E3 		mov	r1, #4
 6239 36cc 34208DE2 		add	r2, sp, #52
2057:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6240              		.loc 1 2057 0
 6241 36d0 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2058:../uvc.c      ****     dmaInterConfig.count          = 1;
 6242              		.loc 1 2058 0
 6243 36d4 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2059:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6244              		.loc 1 2059 0
 6245 36d8 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2060:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6246              		.loc 1 2060 0
 6247 36dc BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2061:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6248              		.loc 1 2061 0
 6249 36e0 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2062:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6250              		.loc 1 2062 0
 6251 36e4 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2063:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6252              		.loc 1 2063 0
 6253 36e8 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2064:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6254              		.loc 1 2064 0
 6255 36ec B234CDE1 		strh	r3, [sp, #66]	@ movhi
2065:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6256              		.loc 1 2065 0
 6257 36f0 4470CDE5 		strb	r7, [sp, #68]
2066:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6258              		.loc 1 2066 0
 6259 36f4 48808DE5 		str	r8, [sp, #72]
2067:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6260              		.loc 1 2067 0
 6261 36f8 4C308DE5 		str	r3, [sp, #76]
2068:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6262              		.loc 1 2068 0
 6263 36fc FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6264              	.LVL504:
2070:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6265              		.loc 1 2070 0
 6266 3700 006050E2 		subs	r6, r0, #0
 6267 3704 DF00001A 		bne	.L584
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6268              		.loc 1 2077 0
 6269 3708 010BA0E3 		mov	r0, #1024
 6270              	.LVL505:
 6271 370c FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6272 3710 F4179FE5 		ldr	r1, .L599+92
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
 6273              		.loc 1 2078 0
 6274 3714 000050E3 		cmp	r0, #0
2077:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6275              		.loc 1 2077 0
 6276 3718 000081E5 		str	r0, [r1, #0]
2078:../uvc.c      ****     if (glInterStaBuffer == 0)
 6277              		.loc 1 2078 0
 6278 371c D000000A 		beq	.L585
2085:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 6279              		.loc 1 2085 0
 6280 3720 0610A0E1 		mov	r1, r6
 6281 3724 0620A0E1 		mov	r2, r6
 6282 3728 3830A0E3 		mov	r3, #56
 6283 372c DC079FE5 		ldr	r0, .L599+96
 6284 3730 FEFFFFEB 		bl	_txe_mutex_create
2087:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6285              		.loc 1 2087 0
 6286 3734 0430A0E3 		mov	r3, #4	@ movhi
 6287 3738 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6288              		.loc 1 2090 0
 6289 373c D0379FE5 		ldr	r3, .L599+100
2086:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6290              		.loc 1 2086 0
 6291 3740 01C9A0E3 		mov	ip, #16384	@ movhi
 6292 3744 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2089:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6293              		.loc 1 2089 0
 6294 3748 01CCA0E3 		mov	ip, #256	@ movhi
 6295 374c B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2090:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6296              		.loc 1 2090 0
 6297 3750 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6298              		.loc 1 2091 0
 6299 3754 BCC79FE5 		ldr	ip, .L599+104
2093:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6300              		.loc 1 2093 0
 6301 3758 0C30A0E3 		mov	r3, #12	@ movhi
 6302 375c B432CDE1 		strh	r3, [sp, #36]	@ movhi
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6303              		.loc 1 2098 0
 6304 3760 B4379FE5 		ldr	r3, .L599+108
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6305              		.loc 1 2099 0
 6306 3764 0C208DE2 		add	r2, sp, #12
2091:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6307              		.loc 1 2091 0
 6308 3768 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2096:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6309              		.loc 1 2096 0
 6310 376c 2A70CDE5 		strb	r7, [sp, #42]
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6311              		.loc 1 2094 0
 6312 3770 04C0A0E3 		mov	ip, #4	@ movhi
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6313              		.loc 1 2088 0
 6314 3774 02A0A0E3 		mov	sl, #2	@ movhi
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6315              		.loc 1 2099 0
 6316 3778 A0079FE5 		ldr	r0, .L599+112
 6317 377c 0710A0E3 		mov	r1, #7
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6318              		.loc 1 2097 0
 6319 3780 1870A0E3 		mov	r7, #24
2088:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6320              		.loc 1 2088 0
 6321 3784 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2092:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6322              		.loc 1 2092 0
 6323 3788 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2094:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6324              		.loc 1 2094 0
 6325 378c B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2095:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6326              		.loc 1 2095 0
 6327 3790 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2097:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6328              		.loc 1 2097 0
 6329 3794 2C708DE5 		str	r7, [sp, #44]
2098:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6330              		.loc 1 2098 0
 6331 3798 30308DE5 		str	r3, [sp, #48]
2099:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6332              		.loc 1 2099 0
 6333 379c FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6334              	.LVL506:
2101:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6335              		.loc 1 2101 0
 6336 37a0 002050E2 		subs	r2, r0, #0
 6337 37a4 A500001A 		bne	.L586
2192:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6338              		.loc 1 2192 0
 6339 37a8 0500A0E1 		mov	r0, r5
 6340              	.LVL507:
 6341 37ac 0510A0E1 		mov	r1, r5
 6342 37b0 FEFFFFEB 		bl	CyU3PConnectState
 6343              	.LVL508:
2193:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6344              		.loc 1 2193 0
 6345 37b4 002050E2 		subs	r2, r0, #0
 6346 37b8 9700001A 		bne	.L587
2199:../uvc.c      ****     CyU3PBusyWait(100);
 6347              		.loc 1 2199 0
 6348 37bc 6400A0E3 		mov	r0, #100
 6349              	.LVL509:
 6350 37c0 FEFFFFEB 		bl	CyU3PBusyWait
 6351              	.LVL510:
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6352              		.loc 1 2201 0
 6353 37c4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2215:../uvc.c      ****     endPointConfig.streams  = 0;
 6354              		.loc 1 2215 0
 6355 37c8 0020A0E3 		mov	r2, #0	@ movhi
2204:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6356              		.loc 1 2204 0
 6357 37cc ACA0CDE5 		strb	sl, [sp, #172]
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6358              		.loc 1 2216 0
 6359 37d0 A8108DE2 		add	r1, sp, #168
2215:../uvc.c      ****     endPointConfig.streams  = 0;
 6360              		.loc 1 2215 0
 6361 37d4 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2203:../uvc.c      ****     endPointConfig.enable   = 1;
 6362              		.loc 1 2203 0
 6363 37d8 A8508DE5 		str	r5, [sp, #168]
2205:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6364              		.loc 1 2205 0
 6365 37dc 030050E3 		cmp	r0, #3
2201:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6366              		.loc 1 2201 0
 6367 37e0 4800C4E5 		strb	r0, [r4, #72]
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6368              		.loc 1 2212 0
 6369 37e4 020CA013 		movne	r0, #512	@ movhi
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6370              		.loc 1 2207 0
 6371 37e8 01ABA003 		moveq	sl, #1024	@ movhi
2212:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6372              		.loc 1 2212 0
 6373 37ec B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6374              		.loc 1 2216 0
 6375 37f0 8300A0E3 		mov	r0, #131
2207:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6376              		.loc 1 2207 0
 6377 37f4 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2208:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6378              		.loc 1 2208 0
 6379 37f8 B280CD05 		streqb	r8, [sp, #178]
2213:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6380              		.loc 1 2213 0
 6381 37fc B250CD15 		strneb	r5, [sp, #178]
2216:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6382              		.loc 1 2216 0
 6383 3800 FEFFFFEB 		bl	CyU3PSetEpConfig
 6384              	.LVL511:
2217:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6385              		.loc 1 2217 0
 6386 3804 002050E2 		subs	r2, r0, #0
 6387 3808 4F00001A 		bne	.L570
 6388 380c 10779FE5 		ldr	r7, .L599+116
 6389              	.LBE225:
 6390              	.LBE222:
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6391              		.loc 1 2340 0
 6392 3810 AC569FE5 		ldr	r5, .L599+20
 6393 3814 0260A0E1 		mov	r6, r2
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6394              		.loc 1 2524 0
 6395 3818 0080E0E3 		mvn	r8, #0
 6396              	.LVL512:
 6397              	.L531:
2340:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6398              		.loc 1 2340 0
 6399 381c A0069FE5 		ldr	r0, .L599+20
 6400 3820 0110A0E3 		mov	r1, #1
 6401 3824 0220A0E3 		mov	r2, #2
 6402 3828 B4308DE2 		add	r3, sp, #180
 6403 382c 00608DE5 		str	r6, [sp, #0]
 6404 3830 FEFFFFEB 		bl	_txe_event_flags_get
 6405 3834 000050E3 		cmp	r0, #0
 6406 3838 3000001A 		bne	.L533
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6407              		.loc 1 2386 0
 6408 383c 3CE095E5 		ldr	lr, [r5, #60]
 6409 3840 00005EE3 		cmp	lr, #0
 6410 3844 0300000A 		beq	.L534
2386:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6411              		.loc 1 2386 0 is_stmt 0 discriminator 1
 6412 3848 B014D5E1 		ldrh	r1, [r5, #64]
 6413 384c B234D5E1 		ldrh	r3, [r5, #66]
 6414 3850 030051E1 		cmp	r1, r3
 6415 3854 1201000A 		beq	.L588
 6416              	.L534:
2585:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6417              		.loc 1 2585 0 is_stmt 1
 6418 3858 4010A0E3 		mov	r1, #64
 6419 385c 0020A0E3 		mov	r2, #0
 6420 3860 5C069FE5 		ldr	r0, .L599+20
 6421 3864 FEFFFFEB 		bl	_txe_event_flags_set
2588:../uvc.c      ****         CyU3PThreadRelinquish ();
 6422              		.loc 1 2588 0
 6423 3868 FEFFFFEB 		bl	_txe_thread_relinquish
2589:../uvc.c      ****     }
 6424              		.loc 1 2589 0
 6425 386c EAFFFFEA 		b	.L531
 6426              	.LVL513:
 6427              	.L573:
 6428              	.LBB260:
 6429              	.LBB224:
1889:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6430              		.loc 1 1889 0
 6431 3870 0400A0E3 		mov	r0, #4
 6432              	.LVL514:
 6433 3874 AC169FE5 		ldr	r1, .L599+120
 6434 3878 FEFFFFEB 		bl	CyU3PDebugPrint
 6435              	.LVL515:
 6436              	.L500:
 6437              	.LBB240:
 6438              	.LBB241:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6439              		.loc 1 1318 0
 6440 387c A8169FE5 		ldr	r1, .L599+124
 6441 3880 0400A0E3 		mov	r0, #4
 6442 3884 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6443              		.loc 1 1319 0
 6444 3888 FA0FA0E3 		mov	r0, #1000
 6445 388c FEFFFFEB 		bl	_tx_thread_sleep
 6446 3890 F9FFFFEA 		b	.L500
 6447              	.LVL516:
 6448              	.L575:
 6449              	.LBE241:
 6450              	.LBE240:
1920:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6451              		.loc 1 1920 0
 6452 3894 0400A0E3 		mov	r0, #4
 6453              	.LVL517:
 6454 3898 90169FE5 		ldr	r1, .L599+128
 6455 389c FEFFFFEB 		bl	CyU3PDebugPrint
 6456              	.LVL518:
 6457              	.L504:
 6458              	.LBB238:
 6459              	.LBB239:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6460              		.loc 1 1318 0
 6461 38a0 84169FE5 		ldr	r1, .L599+124
 6462 38a4 0400A0E3 		mov	r0, #4
 6463 38a8 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6464              		.loc 1 1319 0
 6465 38ac FA0FA0E3 		mov	r0, #1000
 6466 38b0 FEFFFFEB 		bl	_tx_thread_sleep
 6467 38b4 F9FFFFEA 		b	.L504
 6468              	.LVL519:
 6469              	.L574:
 6470              	.LBE239:
 6471              	.LBE238:
1911:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6472              		.loc 1 1911 0
 6473 38b8 0400A0E3 		mov	r0, #4
 6474              	.LVL520:
 6475 38bc 70169FE5 		ldr	r1, .L599+132
 6476 38c0 FEFFFFEB 		bl	CyU3PDebugPrint
 6477              	.LVL521:
 6478              	.L502:
 6479              	.LBB236:
 6480              	.LBB237:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6481              		.loc 1 1318 0
 6482 38c4 60169FE5 		ldr	r1, .L599+124
 6483 38c8 0400A0E3 		mov	r0, #4
 6484 38cc FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6485              		.loc 1 1319 0
 6486 38d0 FA0FA0E3 		mov	r0, #1000
 6487 38d4 FEFFFFEB 		bl	_tx_thread_sleep
 6488 38d8 F9FFFFEA 		b	.L502
 6489              	.LVL522:
 6490              	.L576:
 6491              	.LBE237:
 6492              	.LBE236:
1926:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6493              		.loc 1 1926 0
 6494 38dc 0400A0E3 		mov	r0, #4
 6495              	.LVL523:
 6496 38e0 50169FE5 		ldr	r1, .L599+136
 6497 38e4 FEFFFFEB 		bl	CyU3PDebugPrint
 6498              	.LVL524:
 6499              	.L506:
 6500              	.LBB234:
 6501              	.LBB235:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6502              		.loc 1 1318 0
 6503 38e8 3C169FE5 		ldr	r1, .L599+124
 6504 38ec 0400A0E3 		mov	r0, #4
 6505 38f0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6506              		.loc 1 1319 0
 6507 38f4 FA0FA0E3 		mov	r0, #1000
 6508 38f8 FEFFFFEB 		bl	_tx_thread_sleep
 6509 38fc F9FFFFEA 		b	.L506
 6510              	.LVL525:
 6511              	.L533:
 6512              	.LBE235:
 6513              	.LBE234:
 6514              	.LBE224:
 6515              	.LBE260:
2492:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6516              		.loc 1 2492 0
 6517 3900 BC059FE5 		ldr	r0, .L599+20
 6518 3904 0210A0E3 		mov	r1, #2
 6519 3908 0320A0E3 		mov	r2, #3
 6520 390c B4308DE2 		add	r3, sp, #180
 6521 3910 00608DE5 		str	r6, [sp, #0]
 6522 3914 FEFFFFEB 		bl	_txe_event_flags_get
 6523 3918 000050E3 		cmp	r0, #0
 6524 391c 2500001A 		bne	.L550
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6525              		.loc 1 2507 0
 6526 3920 441095E5 		ldr	r1, [r5, #68]
2495:../uvc.c      ****                 hitFV     = CyFalse;
 6527              		.loc 1 2495 0
 6528 3924 3C6085E5 		str	r6, [r5, #60]
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6529              		.loc 1 2507 0
 6530 3928 000051E3 		cmp	r1, #0
2496:../uvc.c      ****                 prodCount = 0;
 6531              		.loc 1 2496 0
 6532 392c B064C5E1 		strh	r6, [r5, #64]	@ movhi
2503:../uvc.c      ****                 fb=0;
 6533              		.loc 1 2503 0
 6534 3930 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2497:../uvc.c      ****                 consCount = 0;
 6535              		.loc 1 2497 0
 6536 3934 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2504:../uvc.c      ****                 pb=0;
 6537              		.loc 1 2504 0
 6538 3938 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2505:../uvc.c      ****                 pbc=0;
 6539              		.loc 1 2505 0
 6540 393c B863C5E1 		strh	r6, [r5, #56]	@ movhi
2507:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6541              		.loc 1 2507 0
 6542 3940 0A00000A 		beq	.L589
 6543              	.L551:
2519:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6544              		.loc 1 2519 0
 6545 3944 446084E5 		str	r6, [r4, #68]
 6546 3948 C2FFFFEA 		b	.L534
 6547              	.LVL526:
 6548              	.L570:
 6549              	.LBB261:
 6550              	.LBB258:
2220:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6551              		.loc 1 2220 0
 6552 394c 0400A0E3 		mov	r0, #4
 6553              	.LVL527:
 6554 3950 E4159FE5 		ldr	r1, .L599+140
 6555 3954 FEFFFFEB 		bl	CyU3PDebugPrint
 6556              	.LVL528:
 6557              	.L532:
 6558              	.LBB242:
 6559              	.LBB243:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6560              		.loc 1 1318 0
 6561 3958 CC159FE5 		ldr	r1, .L599+124
 6562 395c 0400A0E3 		mov	r0, #4
 6563 3960 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6564              		.loc 1 1319 0
 6565 3964 FA0FA0E3 		mov	r0, #1000
 6566 3968 FEFFFFEB 		bl	_tx_thread_sleep
 6567 396c F9FFFFEA 		b	.L532
 6568              	.LVL529:
 6569              	.L589:
 6570              	.LBE243:
 6571              	.LBE242:
 6572              	.LBE258:
 6573              	.LBE261:
2509:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6574              		.loc 1 2509 0
 6575 3970 A8059FE5 		ldr	r0, .L599+112
 6576 3974 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6577              	.LVL530:
2510:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6578              		.loc 1 2510 0
 6579 3978 000050E3 		cmp	r0, #0
 6580 397c 0200001A 		bne	.L571
2516:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6581              		.loc 1 2516 0
 6582 3980 8300A0E3 		mov	r0, #131
 6583              	.LVL531:
 6584 3984 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6585 3988 EDFFFFEA 		b	.L551
 6586              	.L571:
 6587              	.LBB262:
 6588              	.LBB263:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6589              		.loc 1 1318 0
 6590 398c 98159FE5 		ldr	r1, .L599+124
 6591 3990 0400A0E3 		mov	r0, #4
 6592 3994 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6593              		.loc 1 1319 0
 6594 3998 FA0FA0E3 		mov	r0, #1000
 6595 399c FEFFFFEB 		bl	_tx_thread_sleep
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6596              		.loc 1 1318 0
 6597 39a0 84159FE5 		ldr	r1, .L599+124
 6598 39a4 0400A0E3 		mov	r0, #4
 6599 39a8 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6600              		.loc 1 1319 0
 6601 39ac FA0FA0E3 		mov	r0, #1000
 6602 39b0 FEFFFFEB 		bl	_tx_thread_sleep
 6603 39b4 F4FFFFEA 		b	.L571
 6604              	.L550:
 6605              	.LBE263:
 6606              	.LBE262:
2524:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6607              		.loc 1 2524 0
 6608 39b8 0110A0E3 		mov	r1, #1
 6609 39bc 0220A0E3 		mov	r2, #2
 6610 39c0 B4308DE2 		add	r3, sp, #180
 6611 39c4 F8049FE5 		ldr	r0, .L599+20
 6612 39c8 00808DE5 		str	r8, [sp, #0]
 6613 39cc FEFFFFEB 		bl	_txe_event_flags_get
2528:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6614              		.loc 1 2528 0
 6615 39d0 0620A0E1 		mov	r2, r6
 6616 39d4 44059FE5 		ldr	r0, .L599+112
 6617 39d8 0610A0E1 		mov	r1, r6
 6618 39dc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6619              	.LVL532:
2529:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6620              		.loc 1 2529 0
 6621 39e0 002050E2 		subs	r2, r0, #0
 6622 39e4 6500001A 		bne	.L590
2537:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6623              		.loc 1 2537 0
 6624 39e8 282095E5 		ldr	r2, [r5, #40]
 6625 39ec 000052E3 		cmp	r2, #0
 6626 39f0 5A00001A 		bne	.L556
 6627              	.LVL533:
 6628              	.LBB264:
 6629              	.LBB265:
2245:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6630              		.loc 1 2245 0
 6631 39f4 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 6632 39f8 030053E3 		cmp	r3, #3
 6633 39fc 4700000A 		beq	.L591
2250:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6634              		.loc 1 2250 0
 6635 3a00 020053E3 		cmp	r3, #2
 6636 3a04 2900000A 		beq	.L592
 6637              	.LVL534:
 6638              	.L559:
 6639              	.LBE265:
 6640              	.LBE264:
2573:../uvc.c      ****                     gpif_initialized = CyTrue;
 6641              		.loc 1 2573 0
 6642 3a08 01E0A0E3 		mov	lr, #1
 6643 3a0c 28E084E5 		str	lr, [r4, #40]
2574:../uvc.c      ****                     CyU3PThreadSleep(200);
 6644              		.loc 1 2574 0
 6645 3a10 C800A0E3 		mov	r0, #200
 6646 3a14 FEFFFFEB 		bl	_tx_thread_sleep
 6647 3a18 8EFFFFEA 		b	.L534
 6648              	.LVL535:
 6649              	.L587:
 6650              	.LBB271:
 6651              	.LBB223:
2195:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6652              		.loc 1 2195 0
 6653 3a1c 0400A0E3 		mov	r0, #4
 6654              	.LVL536:
 6655 3a20 18159FE5 		ldr	r1, .L599+144
 6656 3a24 FEFFFFEB 		bl	CyU3PDebugPrint
 6657              	.LVL537:
 6658              	.L528:
 6659              	.LBB232:
 6660              	.LBB233:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6661              		.loc 1 1318 0
 6662 3a28 FC149FE5 		ldr	r1, .L599+124
 6663 3a2c 0400A0E3 		mov	r0, #4
 6664 3a30 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6665              		.loc 1 1319 0
 6666 3a34 FA0FA0E3 		mov	r0, #1000
 6667 3a38 FEFFFFEB 		bl	_tx_thread_sleep
 6668 3a3c F9FFFFEA 		b	.L528
 6669              	.LVL538:
 6670              	.L586:
 6671              	.LBE233:
 6672              	.LBE232:
2104:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6673              		.loc 1 2104 0
 6674 3a40 0400A0E3 		mov	r0, #4
 6675              	.LVL539:
 6676 3a44 F8149FE5 		ldr	r1, .L599+148
 6677 3a48 FEFFFFEB 		bl	CyU3PDebugPrint
 6678              	.LVL540:
 6679              	.L526:
 6680              	.LBB230:
 6681              	.LBB231:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6682              		.loc 1 1318 0
 6683 3a4c D8149FE5 		ldr	r1, .L599+124
 6684 3a50 0400A0E3 		mov	r0, #4
 6685 3a54 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6686              		.loc 1 1319 0
 6687 3a58 FA0FA0E3 		mov	r0, #1000
 6688 3a5c FEFFFFEB 		bl	_tx_thread_sleep
 6689 3a60 F9FFFFEA 		b	.L526
 6690              	.LVL541:
 6691              	.L585:
 6692              	.LBE231:
 6693              	.LBE230:
2080:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6694              		.loc 1 2080 0
 6695 3a64 040080E2 		add	r0, r0, #4
 6696 3a68 D8149FE5 		ldr	r1, .L599+152
 6697 3a6c FEFFFFEB 		bl	CyU3PDebugPrint
 6698              	.LVL542:
 6699              	.L524:
 6700              	.LBB228:
 6701              	.LBB229:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6702              		.loc 1 1318 0
 6703 3a70 B4149FE5 		ldr	r1, .L599+124
 6704 3a74 0400A0E3 		mov	r0, #4
 6705 3a78 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6706              		.loc 1 1319 0
 6707 3a7c FA0FA0E3 		mov	r0, #1000
 6708 3a80 FEFFFFEB 		bl	_tx_thread_sleep
 6709 3a84 F9FFFFEA 		b	.L524
 6710              	.LVL543:
 6711              	.L584:
 6712              	.LBE229:
 6713              	.LBE228:
2073:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6714              		.loc 1 2073 0
 6715 3a88 0400A0E3 		mov	r0, #4
 6716 3a8c B8149FE5 		ldr	r1, .L599+156
 6717 3a90 0620A0E1 		mov	r2, r6
 6718 3a94 FEFFFFEB 		bl	CyU3PDebugPrint
 6719              	.L522:
 6720              	.LBB226:
 6721              	.LBB227:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6722              		.loc 1 1318 0
 6723 3a98 8C149FE5 		ldr	r1, .L599+124
 6724 3a9c 0400A0E3 		mov	r0, #4
 6725 3aa0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6726              		.loc 1 1319 0
 6727 3aa4 FA0FA0E3 		mov	r0, #1000
 6728 3aa8 FEFFFFEB 		bl	_tx_thread_sleep
 6729 3aac F9FFFFEA 		b	.L522
 6730              	.LVL544:
 6731              	.L592:
 6732              	.LBE227:
 6733              	.LBE226:
 6734              	.LBE223:
 6735              	.LBE271:
 6736              	.LBB272:
 6737              	.LBB270:
2252:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6738              		.loc 1 2252 0
 6739 3ab0 98149FE5 		ldr	r1, .L599+160
 6740 3ab4 0100A0E3 		mov	r0, #1
 6741              	.LVL545:
 6742 3ab8 FEFFFFEB 		bl	CyU3PDebugPrint
2253:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6743              		.loc 1 2253 0
 6744 3abc 90049FE5 		ldr	r0, .L599+164
 6745 3ac0 FEFFFFEB 		bl	CyU3PGpifLoad
 6746 3ac4 0020A0E1 		mov	r2, r0
 6747              	.LVL546:
 6748              	.L558:
2255:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6749              		.loc 1 2255 0
 6750 3ac8 000052E3 		cmp	r2, #0
 6751 3acc 1A00001A 		bne	.L593
2263:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6752              		.loc 1 2263 0
 6753 3ad0 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6754 3ad4 030053E3 		cmp	r3, #3
 6755 3ad8 0100000A 		beq	.L572
2267:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6756              		.loc 1 2267 0
 6757 3adc 020053E3 		cmp	r3, #2
 6758 3ae0 C8FFFF1A 		bne	.L559
 6759              	.L572:
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6760              		.loc 1 2269 0
 6761 3ae4 0200A0E1 		mov	r0, r2
 6762              	.LVL547:
 6763 3ae8 0210A0E1 		mov	r1, r2
 6764 3aec FEFFFFEB 		bl	CyU3PGpifSMStart
 6765              	.LVL548:
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6766              		.loc 1 2271 0
 6767 3af0 000050E3 		cmp	r0, #0
2269:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6768              		.loc 1 2269 0
 6769 3af4 0020A0E1 		mov	r2, r0
 6770              	.LVL549:
2271:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6771              		.loc 1 2271 0
 6772 3af8 C2FFFF0A 		beq	.L559
2274:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6773              		.loc 1 2274 0
 6774 3afc 0400A0E3 		mov	r0, #4
 6775              	.LVL550:
 6776 3b00 50149FE5 		ldr	r1, .L599+168
 6777 3b04 FEFFFFEB 		bl	CyU3PDebugPrint
 6778              	.LVL551:
 6779              	.L564:
 6780              	.LBB266:
 6781              	.LBB267:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6782              		.loc 1 1318 0
 6783 3b08 1C149FE5 		ldr	r1, .L599+124
 6784 3b0c 0400A0E3 		mov	r0, #4
 6785 3b10 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6786              		.loc 1 1319 0
 6787 3b14 FA0FA0E3 		mov	r0, #1000
 6788 3b18 FEFFFFEB 		bl	_tx_thread_sleep
 6789 3b1c F9FFFFEA 		b	.L564
 6790              	.LVL552:
 6791              	.L591:
 6792              	.LBE267:
 6793              	.LBE266:
2247:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6794              		.loc 1 2247 0
 6795 3b20 34149FE5 		ldr	r1, .L599+172
 6796 3b24 0100A0E3 		mov	r0, #1
 6797              	.LVL553:
 6798 3b28 FEFFFFEB 		bl	CyU3PDebugPrint
2248:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6799              		.loc 1 2248 0
 6800 3b2c 2C049FE5 		ldr	r0, .L599+176
 6801 3b30 FEFFFFEB 		bl	CyU3PGpifLoad
 6802 3b34 0020A0E1 		mov	r2, r0
 6803              	.LVL554:
 6804 3b38 E2FFFFEA 		b	.L558
 6805              	.L593:
2258:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6806              		.loc 1 2258 0
 6807 3b3c 0400A0E3 		mov	r0, #4
 6808              	.LVL555:
 6809 3b40 1C149FE5 		ldr	r1, .L599+180
 6810 3b44 FEFFFFEB 		bl	CyU3PDebugPrint
 6811              	.LVL556:
 6812              	.L561:
 6813              	.LBB268:
 6814              	.LBB269:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6815              		.loc 1 1318 0
 6816 3b48 DC139FE5 		ldr	r1, .L599+124
 6817 3b4c 0400A0E3 		mov	r0, #4
 6818 3b50 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6819              		.loc 1 1319 0
 6820 3b54 FA0FA0E3 		mov	r0, #1000
 6821 3b58 FEFFFFEB 		bl	_tx_thread_sleep
 6822 3b5c F9FFFFEA 		b	.L561
 6823              	.LVL557:
 6824              	.L556:
 6825              	.LBE269:
 6826              	.LBE268:
 6827              	.LBE270:
 6828              	.LBE272:
2581:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6829              		.loc 1 2581 0
 6830 3b60 AC039FE5 		ldr	r0, .L599+100
 6831              	.LVL558:
 6832 3b64 02C0A0E3 		mov	ip, #2
 6833 3b68 0610A0E1 		mov	r1, r6
 6834 3b6c 0020A0E1 		mov	r2, r0
 6835 3b70 0630A0E1 		mov	r3, r6
 6836 3b74 00C08DE5 		str	ip, [sp, #0]
 6837 3b78 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6838 3b7c 35FFFFEA 		b	.L534
 6839              	.LVL559:
 6840              	.L590:
2532:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6841              		.loc 1 2532 0
 6842 3b80 0400A0E3 		mov	r0, #4
 6843              	.LVL560:
 6844 3b84 DC139FE5 		ldr	r1, .L599+184
 6845 3b88 FEFFFFEB 		bl	CyU3PDebugPrint
 6846              	.LVL561:
 6847              	.L555:
 6848              	.LBB273:
 6849              	.LBB274:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6850              		.loc 1 1318 0
 6851 3b8c 98139FE5 		ldr	r1, .L599+124
 6852 3b90 0400A0E3 		mov	r0, #4
 6853 3b94 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6854              		.loc 1 1319 0
 6855 3b98 FA0FA0E3 		mov	r0, #1000
 6856 3b9c FEFFFFEB 		bl	_tx_thread_sleep
 6857 3ba0 F9FFFFEA 		b	.L555
 6858              	.LVL562:
 6859              	.L583:
 6860              	.LBE274:
 6861              	.LBE273:
 6862              	.LBB275:
 6863              	.LBB259:
2052:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6864              		.loc 1 2052 0
 6865 3ba4 0400A0E3 		mov	r0, #4
 6866              	.LVL563:
 6867 3ba8 8C139FE5 		ldr	r1, .L599+140
 6868 3bac 0320A0E1 		mov	r2, r3
 6869 3bb0 FEFFFFEB 		bl	CyU3PDebugPrint
 6870              	.LVL564:
 6871              	.L520:
 6872              	.LBB244:
 6873              	.LBB245:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6874              		.loc 1 1318 0
 6875 3bb4 70139FE5 		ldr	r1, .L599+124
 6876 3bb8 0400A0E3 		mov	r0, #4
 6877 3bbc FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6878              		.loc 1 1319 0
 6879 3bc0 FA0FA0E3 		mov	r0, #1000
 6880 3bc4 FEFFFFEB 		bl	_tx_thread_sleep
 6881 3bc8 F9FFFFEA 		b	.L520
 6882              	.LVL565:
 6883              	.L582:
 6884              	.LBE245:
 6885              	.LBE244:
2007:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6886              		.loc 1 2007 0
 6887 3bcc 0400A0E3 		mov	r0, #4
 6888              	.LVL566:
 6889 3bd0 94139FE5 		ldr	r1, .L599+188
 6890 3bd4 FEFFFFEB 		bl	CyU3PDebugPrint
 6891              	.LVL567:
 6892              	.L518:
 6893              	.LBB246:
 6894              	.LBB247:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6895              		.loc 1 1318 0
 6896 3bd8 4C139FE5 		ldr	r1, .L599+124
 6897 3bdc 0400A0E3 		mov	r0, #4
 6898 3be0 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6899              		.loc 1 1319 0
 6900 3be4 FA0FA0E3 		mov	r0, #1000
 6901 3be8 FEFFFFEB 		bl	_tx_thread_sleep
 6902 3bec F9FFFFEA 		b	.L518
 6903              	.LVL568:
 6904              	.L581:
 6905              	.LBE247:
 6906              	.LBE246:
1986:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6907              		.loc 1 1986 0
 6908 3bf0 0400A0E3 		mov	r0, #4
 6909              	.LVL569:
 6910 3bf4 74139FE5 		ldr	r1, .L599+192
 6911 3bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 6912              	.LVL570:
 6913              	.L516:
 6914              	.LBB248:
 6915              	.LBB249:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6916              		.loc 1 1318 0
 6917 3bfc 28139FE5 		ldr	r1, .L599+124
 6918 3c00 0400A0E3 		mov	r0, #4
 6919 3c04 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6920              		.loc 1 1319 0
 6921 3c08 FA0FA0E3 		mov	r0, #1000
 6922 3c0c FEFFFFEB 		bl	_tx_thread_sleep
 6923 3c10 F9FFFFEA 		b	.L516
 6924              	.LVL571:
 6925              	.L580:
 6926              	.LBE249:
 6927              	.LBE248:
1973:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6928              		.loc 1 1973 0
 6929 3c14 0400A0E3 		mov	r0, #4
 6930              	.LVL572:
 6931 3c18 54139FE5 		ldr	r1, .L599+196
 6932 3c1c FEFFFFEB 		bl	CyU3PDebugPrint
 6933              	.LVL573:
 6934              	.L514:
 6935              	.LBB250:
 6936              	.LBB251:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6937              		.loc 1 1318 0
 6938 3c20 04139FE5 		ldr	r1, .L599+124
 6939 3c24 0400A0E3 		mov	r0, #4
 6940 3c28 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6941              		.loc 1 1319 0
 6942 3c2c FA0FA0E3 		mov	r0, #1000
 6943 3c30 FEFFFFEB 		bl	_tx_thread_sleep
 6944 3c34 F9FFFFEA 		b	.L514
 6945              	.LVL574:
 6946              	.L578:
 6947              	.LBE251:
 6948              	.LBE250:
1945:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6949              		.loc 1 1945 0
 6950 3c38 0400A0E3 		mov	r0, #4
 6951              	.LVL575:
 6952 3c3c 34139FE5 		ldr	r1, .L599+200
 6953 3c40 FEFFFFEB 		bl	CyU3PDebugPrint
 6954              	.LVL576:
 6955              	.L510:
 6956              	.LBB252:
 6957              	.LBB253:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6958              		.loc 1 1318 0
 6959 3c44 E0129FE5 		ldr	r1, .L599+124
 6960 3c48 0400A0E3 		mov	r0, #4
 6961 3c4c FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6962              		.loc 1 1319 0
 6963 3c50 FA0FA0E3 		mov	r0, #1000
 6964 3c54 FEFFFFEB 		bl	_tx_thread_sleep
 6965 3c58 F9FFFFEA 		b	.L510
 6966              	.LVL577:
 6967              	.L577:
 6968              	.LBE253:
 6969              	.LBE252:
1932:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6970              		.loc 1 1932 0
 6971 3c5c 0400A0E3 		mov	r0, #4
 6972              	.LVL578:
 6973 3c60 14139FE5 		ldr	r1, .L599+204
 6974 3c64 FEFFFFEB 		bl	CyU3PDebugPrint
 6975              	.LVL579:
 6976              	.L508:
 6977              	.LBB254:
 6978              	.LBB255:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6979              		.loc 1 1318 0
 6980 3c68 BC129FE5 		ldr	r1, .L599+124
 6981 3c6c 0400A0E3 		mov	r0, #4
 6982 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 6983              		.loc 1 1319 0
 6984 3c74 FA0FA0E3 		mov	r0, #1000
 6985 3c78 FEFFFFEB 		bl	_tx_thread_sleep
 6986 3c7c F9FFFFEA 		b	.L508
 6987              	.LVL580:
 6988              	.L579:
 6989              	.LBE255:
 6990              	.LBE254:
1959:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6991              		.loc 1 1959 0
 6992 3c80 0400A0E3 		mov	r0, #4
 6993              	.LVL581:
 6994 3c84 F4129FE5 		ldr	r1, .L599+208
 6995 3c88 FEFFFFEB 		bl	CyU3PDebugPrint
 6996              	.LVL582:
 6997              	.L512:
 6998              	.LBB256:
 6999              	.LBB257:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7000              		.loc 1 1318 0
 7001 3c8c 98129FE5 		ldr	r1, .L599+124
 7002 3c90 0400A0E3 		mov	r0, #4
 7003 3c94 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7004              		.loc 1 1319 0
 7005 3c98 FA0FA0E3 		mov	r0, #1000
 7006 3c9c FEFFFFEB 		bl	_tx_thread_sleep
 7007 3ca0 F9FFFFEA 		b	.L512
 7008              	.LVL583:
 7009              	.L588:
 7010              	.LBE257:
 7011              	.LBE256:
 7012              	.LBE259:
 7013              	.LBE275:
2396:../uvc.c      ****                 prodCount = 0;
 7014              		.loc 1 2396 0
 7015 3ca4 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7016              		.loc 1 2411 0
 7017 3ca8 60029FE5 		ldr	r0, .L599+96
2397:../uvc.c      ****                 consCount = 0;
 7018              		.loc 1 2397 0
 7019 3cac B264C5E1 		strh	r6, [r5, #66]	@ movhi
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7020              		.loc 1 2411 0
 7021 3cb0 0010E0E3 		mvn	r1, #0
2393:../uvc.c      ****             	fb=0;
 7022              		.loc 1 2393 0
 7023 3cb4 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2394:../uvc.c      ****             	pb=0;
 7024              		.loc 1 2394 0
 7025 3cb8 B663C5E1 		strh	r6, [r5, #54]	@ movhi
2395:../uvc.c      ****             	pbc=0;
 7026              		.loc 1 2395 0
 7027 3cbc B863C5E1 		strh	r6, [r5, #56]	@ movhi
2398:../uvc.c      ****                 hitFV     = CyFalse;
 7028              		.loc 1 2398 0
 7029 3cc0 3C6085E5 		str	r6, [r5, #60]
2411:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7030              		.loc 1 2411 0
 7031 3cc4 FEFFFFEB 		bl	_txe_mutex_get
2412:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7032              		.loc 1 2412 0
 7033 3cc8 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 7034 3ccc 012020E2 		eor	r2, r0, #1
 7035 3cd0 8124C7E5 		strb	r2, [r7, #1153]
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7036              		.loc 1 2414 0
 7037 3cd4 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 7038 3cd8 F0005CE3 		cmp	ip, #240
 7039 3cdc 1800000A 		beq	.L594
 7040              	.L535:
2422:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 7041              		.loc 1 2422 0
 7042 3ce0 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 7043 3ce4 FF005AE3 		cmp	sl, #255
 7044 3ce8 6400000A 		beq	.L595
2434:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 7045              		.loc 1 2434 0
 7046 3cec 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 7047 3cf0 AA0050E3 		cmp	r0, #170
 7048 3cf4 3700000A 		beq	.L596
 7049              	.L537:
2467:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 7050              		.loc 1 2467 0
 7051 3cf8 10029FE5 		ldr	r0, .L599+96
 7052 3cfc FEFFFFEB 		bl	_txe_mutex_put
2469:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7053              		.loc 1 2469 0
 7054 3d00 18029FE5 		ldr	r0, .L599+112
 7055 3d04 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7056              	.LVL584:
2470:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7057              		.loc 1 2470 0
 7058 3d08 002050E2 		subs	r2, r0, #0
 7059 3d0c 2800001A 		bne	.L597
2477:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7060              		.loc 1 2477 0
 7061 3d10 0210A0E1 		mov	r1, r2
 7062 3d14 04029FE5 		ldr	r0, .L599+112
 7063              	.LVL585:
 7064 3d18 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7065              	.LVL586:
2478:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7066              		.loc 1 2478 0
 7067 3d1c 002050E2 		subs	r2, r0, #0
 7068 3d20 1A00001A 		bne	.L598
2486:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7069              		.loc 1 2486 0
 7070 3d24 E8019FE5 		ldr	r0, .L599+100
 7071              	.LVL587:
 7072 3d28 0210A0E1 		mov	r1, r2
 7073 3d2c 02A0A0E3 		mov	sl, #2
 7074 3d30 0020A0E1 		mov	r2, r0
 7075              	.LVL588:
 7076 3d34 0130A0E1 		mov	r3, r1
 7077 3d38 00A08DE5 		str	sl, [sp, #0]
 7078 3d3c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7079              	.LVL589:
 7080 3d40 C4FEFFEA 		b	.L534
 7081              	.L594:
2414:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 7082              		.loc 1 2414 0 discriminator 1
 7083 3d44 78019FE5 		ldr	r0, .L599+20
 7084 3d48 8010A0E3 		mov	r1, #128
 7085 3d4c 0320A0E3 		mov	r2, #3
 7086 3d50 B4308DE2 		add	r3, sp, #180
 7087 3d54 00608DE5 		str	r6, [sp, #0]
 7088 3d58 FEFFFFEB 		bl	_txe_event_flags_get
 7089 3d5c 000050E3 		cmp	r0, #0
 7090 3d60 DEFFFF1A 		bne	.L535
2417:../uvc.c      ****                        	SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*bo
 7091              		.loc 1 2417 0
 7092 3d64 582095E5 		ldr	r2, [r5, #88]
 7093 3d68 010080E2 		add	r0, r0, #1
 7094 3d6c 000052E3 		cmp	r2, #0
 7095 3d70 3010A0E3 		mov	r1, #48
 7096 3d74 E420A003 		moveq	r2, #228
 7097 3d78 6420A013 		movne	r2, #100
 7098 3d7c 5230A0E3 		mov	r3, #82
 7099 3d80 FEFFFFEB 		bl	SensorSetIrisControl
2419:../uvc.c      ****                 		stiflag = 0xFF;
 7100              		.loc 1 2419 0
 7101 3d84 3A80C4E5 		strb	r8, [r4, #58]
2420:../uvc.c      ****                 		IMcount = 0;
 7102              		.loc 1 2420 0
 7103 3d88 A060C4E5 		strb	r6, [r4, #160]
 7104 3d8c D9FFFFEA 		b	.L537
 7105              	.LVL590:
 7106              	.L598:
2480:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 7107              		.loc 1 2480 0
 7108 3d90 0400A0E3 		mov	r0, #4
 7109              	.LVL591:
 7110 3d94 E8119FE5 		ldr	r1, .L599+212
 7111 3d98 FEFFFFEB 		bl	CyU3PDebugPrint
 7112              	.LVL592:
 7113              	.L549:
 7114              	.LBB276:
 7115              	.LBB277:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7116              		.loc 1 1318 0
 7117 3d9c 88119FE5 		ldr	r1, .L599+124
 7118 3da0 0400A0E3 		mov	r0, #4
 7119 3da4 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7120              		.loc 1 1319 0
 7121 3da8 FA0FA0E3 		mov	r0, #1000
 7122 3dac FEFFFFEB 		bl	_tx_thread_sleep
 7123 3db0 F9FFFFEA 		b	.L549
 7124              	.LVL593:
 7125              	.L597:
 7126              	.LBE277:
 7127              	.LBE276:
2472:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 7128              		.loc 1 2472 0
 7129 3db4 0400A0E3 		mov	r0, #4
 7130              	.LVL594:
 7131 3db8 C8119FE5 		ldr	r1, .L599+216
 7132 3dbc FEFFFFEB 		bl	CyU3PDebugPrint
 7133              	.LVL595:
 7134              	.L547:
 7135              	.LBB278:
 7136              	.LBB279:
1318:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7137              		.loc 1 1318 0
 7138 3dc0 64119FE5 		ldr	r1, .L599+124
 7139 3dc4 0400A0E3 		mov	r0, #4
 7140 3dc8 FEFFFFEB 		bl	CyU3PDebugPrint
1319:../uvc.c      ****         CyU3PThreadSleep (1000);
 7141              		.loc 1 1319 0
 7142 3dcc FA0FA0E3 		mov	r0, #1000
 7143 3dd0 FEFFFFEB 		bl	_tx_thread_sleep
 7144 3dd4 F9FFFFEA 		b	.L547
 7145              	.L596:
 7146              	.LBE279:
 7147              	.LBE278:
2440:../uvc.c      ****                 	if(IMcount++ >= 0x4)
 7148              		.loc 1 2440 0
 7149 3dd8 A0E0D5E5 		ldrb	lr, [r5, #160]	@ zero_extendqisi2
 7150 3ddc 01A08EE2 		add	sl, lr, #1
 7151 3de0 03005EE3 		cmp	lr, #3
 7152 3de4 A0A0C5E5 		strb	sl, [r5, #160]
 7153 3de8 C2FFFF9A 		bls	.L537
2442:../uvc.c      ****                     switch (setRes)
 7154              		.loc 1 2442 0
 7155 3dec 7D00D5E5 		ldrb	r0, [r5, #125]	@ zero_extendqisi2
 7156 3df0 020050E3 		cmp	r0, #2
 7157 3df4 1800000A 		beq	.L541
 7158 3df8 030050E3 		cmp	r0, #3
 7159 3dfc 0B00000A 		beq	.L542
 7160 3e00 010050E3 		cmp	r0, #1
 7161 3e04 0600001A 		bne	.L539
2445:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 7162              		.loc 1 2445 0
 7163 3e08 582095E5 		ldr	r2, [r5, #88]
 7164 3e0c 3010A0E3 		mov	r1, #48
 7165 3e10 000052E3 		cmp	r2, #0
 7166 3e14 E420A003 		moveq	r2, #228
 7167 3e18 6420A013 		movne	r2, #100
 7168 3e1c 5230A0E3 		mov	r3, #82
 7169 3e20 FEFFFFEB 		bl	SensorSetIrisControl
 7170              	.L539:
2462:../uvc.c      ****                     IMcount = 0;
 7171              		.loc 1 2462 0
 7172 3e24 A060C4E5 		strb	r6, [r4, #160]
2464:../uvc.c      ****                 	stiflag = 0x0;
 7173              		.loc 1 2464 0
 7174 3e28 3A60C4E5 		strb	r6, [r4, #58]
 7175 3e2c B1FFFFEA 		b	.L537
 7176              	.L542:
2455:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 7177              		.loc 1 2455 0
 7178 3e30 58C095E5 		ldr	ip, [r5, #88]
 7179 3e34 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 7180 3e38 00005CE3 		cmp	ip, #0
 7181 3e3c C4C0A003 		moveq	ip, #196
 7182 3e40 44C0A013 		movne	ip, #68
 7183 3e44 03208CE1 		orr	r2, ip, r3
 7184 3e48 3010A0E3 		mov	r1, #48
 7185 3e4c 5230A0E3 		mov	r3, #82
 7186 3e50 0100A0E3 		mov	r0, #1
 7187 3e54 FEFFFFEB 		bl	SensorSetIrisControl
2458:../uvc.c      ****                  		break;
 7188              		.loc 1 2458 0
 7189 3e58 F1FFFFEA 		b	.L539
 7190              	.L541:
2450:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 7191              		.loc 1 2450 0
 7192 3e5c 582095E5 		ldr	r2, [r5, #88]
 7193 3e60 3010A0E3 		mov	r1, #48
 7194 3e64 000052E3 		cmp	r2, #0
 7195 3e68 D420A003 		moveq	r2, #212
 7196 3e6c 5420A013 		movne	r2, #84
 7197 3e70 5230A0E3 		mov	r3, #82
 7198 3e74 0100A0E3 		mov	r0, #1
 7199 3e78 FEFFFFEB 		bl	SensorSetIrisControl
2453:../uvc.c      ****                  		break;
 7200              		.loc 1 2453 0
 7201 3e7c E8FFFFEA 		b	.L539
 7202              	.L595:
2424:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 7203              		.loc 1 2424 0
 7204 3e80 A010D5E5 		ldrb	r1, [r5, #160]	@ zero_extendqisi2
 7205 3e84 01E081E2 		add	lr, r1, #1
 7206 3e88 020051E3 		cmp	r1, #2
 7207 3e8c A0E0C5E5 		strb	lr, [r5, #160]
 7208 3e90 98FFFF9A 		bls	.L537
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7209              		.loc 1 2425 0
 7210 3e94 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2426:../uvc.c      ****                 		stiflag = 0x0F;
 7211              		.loc 1 2426 0
 7212 3e98 0F30A0E3 		mov	r3, #15
2425:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7213              		.loc 1 2425 0
 7214 3e9c 20C082E3 		orr	ip, r2, #32
 7215 3ea0 81C4C7E5 		strb	ip, [r7, #1153]
2427:../uvc.c      ****                 		IMcount = 0;
 7216              		.loc 1 2427 0
 7217 3ea4 A060C5E5 		strb	r6, [r5, #160]
2426:../uvc.c      ****                 		stiflag = 0x0F;
 7218              		.loc 1 2426 0
 7219 3ea8 3A30C5E5 		strb	r3, [r5, #58]
 7220 3eac 91FFFFEA 		b	.L537
 7221              	.L600:
 7222              		.align	2
 7223              	.L599:
 7224 3eb0 40060000 		.word	.LC34
 7225 3eb4 00C20100 		.word	115200
 7226 3eb8 60060000 		.word	.LC35
 7227 3ebc A0860100 		.word	100000
 7228 3ec0 7C060000 		.word	.LC36
 7229 3ec4 00000000 		.word	.LANCHOR0
 7230 3ec8 00000000 		.word	CyFxGpifCB
 7231 3ecc 88130000 		.word	5000
 7232 3ed0 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7233 3ed4 00000000 		.word	CyFxUVCApplnUSBEventCB
 7234 3ed8 00000000 		.word	CyFxUSBDeviceDscr
 7235 3edc 00000000 		.word	CyFxUSBDeviceDscrSS
 7236 3ee0 00000000 		.word	CyFxUSBDeviceQualDscr
 7237 3ee4 00000000 		.word	CyFxUSBBOSDscr
 7238 3ee8 00000000 		.word	CyFxUSBHSConfigDscr
 7239 3eec 00000000 		.word	CyFxUSBFSConfigDscr
 7240 3ef0 00000000 		.word	CyFxUSBSSConfigDscr
 7241 3ef4 00000000 		.word	CyFxUSBStringLangIDDscr
 7242 3ef8 00000000 		.word	CyFxUSBManufactureDscr
 7243 3efc 00000000 		.word	CyFxUSBProductDscr
 7244 3f00 013F0000 		.word	16129
 7245 3f04 02030000 		.word	770
 7246 3f08 00000000 		.word	glChHandleInterStat
 7247 3f0c 00000000 		.word	glInterStaBuffer
 7248 3f10 00000000 		.word	imgHdMux
 7249 3f14 01010000 		.word	257
 7250 3f18 03030000 		.word	771
 7251 3f1c 00000000 		.word	CyFxUvcApplnDmaCallback
 7252 3f20 00000000 		.word	glChHandleUVCStream
 7253 3f24 00000000 		.word	.LANCHOR1
 7254 3f28 98060000 		.word	.LC37
 7255 3f2c D8010000 		.word	.LC12
 7256 3f30 E8060000 		.word	.LC39
 7257 3f34 C4060000 		.word	.LC38
 7258 3f38 10070000 		.word	.LC40
 7259 3f3c 68080000 		.word	.LC47
 7260 3f40 44090000 		.word	.LC51
 7261 3f44 14090000 		.word	.LC50
 7262 3f48 DC080000 		.word	.LC49
 7263 3f4c 9C080000 		.word	.LC48
 7264 3f50 100A0000 		.word	.LC56
 7265 3f54 2C000000 		.word	.LANCHOR2+44
 7266 3f58 580A0000 		.word	.LC58
 7267 3f5c 000A0000 		.word	.LC55
 7268 3f60 10000000 		.word	.LANCHOR2+16
 7269 3f64 200A0000 		.word	.LC57
 7270 3f68 CC090000 		.word	.LC54
 7271 3f6c 38080000 		.word	.LC46
 7272 3f70 08080000 		.word	.LC45
 7273 3f74 D0070000 		.word	.LC44
 7274 3f78 68070000 		.word	.LC42
 7275 3f7c 3C070000 		.word	.LC41
 7276 3f80 9C070000 		.word	.LC43
 7277 3f84 98090000 		.word	.LC53
 7278 3f88 6C090000 		.word	.LC52
 7279              		.cfi_endproc
 7280              	.LFE18:
 7282              		.align	2
 7283              		.global	CyFxApplicationDefine
 7285              	CyFxApplicationDefine:
 7286              	.LFB26:
3853:../uvc.c      **** }
3854:../uvc.c      **** 
3855:../uvc.c      **** 
3856:../uvc.c      **** /*
3857:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3858:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3859:../uvc.c      ****  */
3860:../uvc.c      **** void
3861:../uvc.c      **** CyFxApplicationDefine (
3862:../uvc.c      ****         void)
3863:../uvc.c      **** {
 7287              		.loc 1 3863 0
 7288              		.cfi_startproc
 7289              		@ args = 0, pretend = 0, frame = 40
 7290              		@ frame_needed = 0, uses_anonymous_args = 0
 7291              	.LVL596:
 7292 3f8c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7293              	.LCFI25:
 7294              		.cfi_def_cfa_offset 36
3864:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3865:../uvc.c      ****     uint32_t retThrdCreate;
3866:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3867:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3868:../uvc.c      **** 
3869:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3870:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7295              		.loc 1 3870 0
 7296 3f90 010AA0E3 		mov	r0, #4096
3863:../uvc.c      **** {
 7297              		.loc 1 3863 0
 7298 3f94 4CD04DE2 		sub	sp, sp, #76
 7299              	.LCFI26:
 7300              		.cfi_def_cfa_offset 112
 7301              		.loc 1 3870 0
 7302              		.cfi_offset 14, -4
 7303              		.cfi_offset 11, -8
 7304              		.cfi_offset 10, -12
 7305              		.cfi_offset 9, -16
 7306              		.cfi_offset 8, -20
 7307              		.cfi_offset 7, -24
 7308              		.cfi_offset 6, -28
 7309              		.cfi_offset 5, -32
 7310              		.cfi_offset 4, -36
 7311 3f98 FEFFFFEB 		bl	CyU3PMemAlloc
 7312 3f9c 00A0A0E1 		mov	sl, r0
 7313              	.LVL597:
3871:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7314              		.loc 1 3871 0
 7315 3fa0 010AA0E3 		mov	r0, #4096
 7316              	.LVL598:
 7317 3fa4 FEFFFFEB 		bl	CyU3PMemAlloc
 7318 3fa8 00B0A0E1 		mov	fp, r0
 7319              	.LVL599:
3872:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7320              		.loc 1 3872 0
 7321 3fac 010AA0E3 		mov	r0, #4096
 7322              	.LVL600:
 7323 3fb0 FEFFFFEB 		bl	CyU3PMemAlloc
3873:../uvc.c      **** 
3874:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7324              		.loc 1 3874 0
 7325 3fb4 00005AE3 		cmp	sl, #0
 7326 3fb8 00005B13 		cmpne	fp, #0
 7327 3fbc 0090A013 		movne	r9, #0
 7328 3fc0 0190A003 		moveq	r9, #1
3872:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7329              		.loc 1 3872 0
 7330 3fc4 24008DE5 		str	r0, [sp, #36]
 7331              	.LVL601:
 7332              		.loc 1 3874 0
 7333 3fc8 0000001A 		bne	.L605
 7334              	.LVL602:
 7335              	.L602:
 7336              	.L604:
 7337 3fcc FEFFFFEA 		b	.L604
 7338              	.L605:
 7339              		.loc 1 3874 0 is_stmt 0 discriminator 1
 7340 3fd0 000050E3 		cmp	r0, #0
 7341 3fd4 FCFFFF0A 		beq	.L602
3875:../uvc.c      ****         goto fatalErrorHandler;
3876:../uvc.c      **** 
3877:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7342              		.loc 1 3878 0 is_stmt 1
 7343 3fd8 28408DE2 		add	r4, sp, #40
 7344 3fdc 0400A0E1 		mov	r0, r4
 7345 3fe0 4010A0E3 		mov	r1, #64
 7346 3fe4 18219FE5 		ldr	r2, .L606
 7347 3fe8 FEFFFFEB 		bl	cmdbufCreate
 7348 3fec 0450A0E1 		mov	r5, r4
 7349 3ff0 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7350 3ff4 0C719FE5 		ldr	r7, .L606+4
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7351              		.loc 1 3879 0
 7352 3ff8 0C819FE5 		ldr	r8, .L606+8
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7353              		.loc 1 3878 0
 7354 3ffc 07C0A0E1 		mov	ip, r7
 7355 4000 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7356 4004 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3880:../uvc.c      **** 
3881:../uvc.c      **** 	/****** initialize command descriptor ***********/
3882:../uvc.c      **** 	cmdquInit(cmdQuptr);
3883:../uvc.c      **** 	cmdquInit(statQuptr);
3884:../uvc.c      **** 
3885:../uvc.c      ****     /* Create the UVC application thread. */
3886:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7357              		.loc 1 3886 0
 7358 4008 0860A0E3 		mov	r6, #8
3878:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7359              		.loc 1 3878 0
 7360 400c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7361              		.loc 1 3879 0
 7362 4010 F8209FE5 		ldr	r2, .L606+12
 7363 4014 0400A0E1 		mov	r0, r4
 7364 4018 2010A0E3 		mov	r1, #32
 7365 401c FEFFFFEB 		bl	cmdbufCreate
 7366 4020 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7367 4024 08C0A0E1 		mov	ip, r8
 7368 4028 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7369 402c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7370              		.loc 1 3886 0
 7371 4030 0140A0E3 		mov	r4, #1
3879:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7372              		.loc 1 3879 0
 7373 4034 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3882:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7374              		.loc 1 3882 0
 7375 4038 0700A0E1 		mov	r0, r7
 7376 403c FEFFFFEB 		bl	cmdquInit
3883:../uvc.c      **** 	cmdquInit(statQuptr);
 7377              		.loc 1 3883 0
 7378 4040 0800A0E1 		mov	r0, r8
 7379 4044 FEFFFFEB 		bl	cmdquInit
 7380              		.loc 1 3886 0
 7381 4048 A850A0E3 		mov	r5, #168
 7382 404c 01CAA0E3 		mov	ip, #4096
 7383 4050 BC009FE5 		ldr	r0, .L606+16
 7384 4054 BC109FE5 		ldr	r1, .L606+20
 7385 4058 BC209FE5 		ldr	r2, .L606+24
 7386 405c 0930A0E1 		mov	r3, r9
 7387 4060 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7388 4064 08608DE5 		str	r6, [sp, #8]
 7389 4068 0C608DE5 		str	r6, [sp, #12]
 7390 406c 10908DE5 		str	r9, [sp, #16]
 7391 4070 14408DE5 		str	r4, [sp, #20]
 7392 4074 18508DE5 		str	r5, [sp, #24]
 7393 4078 FEFFFFEB 		bl	_txe_thread_create
 7394              	.LVL603:
3887:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3888:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3889:../uvc.c      ****             0,                                          /* No input parameter to thread */
3890:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3891:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3892:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3893:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3894:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3895:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3896:../uvc.c      ****             );
3897:../uvc.c      ****     if (retThrdCreate != 0)
 7395              		.loc 1 3897 0
 7396 407c 00C050E2 		subs	ip, r0, #0
 7397 4080 D1FFFF1A 		bne	.L602
3898:../uvc.c      ****     {
3899:../uvc.c      ****         goto fatalErrorHandler;
3900:../uvc.c      ****     }
3901:../uvc.c      **** 
3902:../uvc.c      ****     /* Create the control request handling thread. */
3903:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7398              		.loc 1 3903 0
 7399 4084 0C30A0E1 		mov	r3, ip
 7400 4088 027BA0E3 		mov	r7, #2048
 7401 408c 8C009FE5 		ldr	r0, .L606+28
 7402              	.LVL604:
 7403 4090 8C109FE5 		ldr	r1, .L606+32
 7404 4094 8C209FE5 		ldr	r2, .L606+36
 7405 4098 10C08DE5 		str	ip, [sp, #16]
 7406 409c 00B08DE5 		str	fp, [sp, #0]
 7407 40a0 04708DE5 		str	r7, [sp, #4]
 7408 40a4 08608DE5 		str	r6, [sp, #8]
 7409 40a8 0C608DE5 		str	r6, [sp, #12]
 7410 40ac 14408DE5 		str	r4, [sp, #20]
 7411 40b0 18508DE5 		str	r5, [sp, #24]
 7412 40b4 FEFFFFEB 		bl	_txe_thread_create
 7413              	.LVL605:
3904:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3905:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3906:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3907:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3908:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3909:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3910:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3911:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3912:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3913:../uvc.c      ****             );
3914:../uvc.c      ****     if (retThrdCreate != 0)
 7414              		.loc 1 3914 0
 7415 40b8 00C050E2 		subs	ip, r0, #0
 7416 40bc C2FFFF1A 		bne	.L602
3915:../uvc.c      ****     {
3916:../uvc.c      ****         goto fatalErrorHandler;
3917:../uvc.c      ****     }
3918:../uvc.c      **** #if 1
3919:../uvc.c      ****     /* Create the I2C control command handling thread. */
3920:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7417              		.loc 1 3920 0
 7418 40c0 24E09DE5 		ldr	lr, [sp, #36]
 7419 40c4 60009FE5 		ldr	r0, .L606+40
 7420              	.LVL606:
 7421 40c8 60109FE5 		ldr	r1, .L606+44
 7422 40cc 60209FE5 		ldr	r2, .L606+48
 7423 40d0 0C30A0E1 		mov	r3, ip
 7424 40d4 00E08DE5 		str	lr, [sp, #0]
 7425 40d8 04708DE5 		str	r7, [sp, #4]
 7426 40dc 08608DE5 		str	r6, [sp, #8]
 7427 40e0 0C608DE5 		str	r6, [sp, #12]
 7428 40e4 10C08DE5 		str	ip, [sp, #16]
 7429 40e8 14408DE5 		str	r4, [sp, #20]
 7430 40ec 18508DE5 		str	r5, [sp, #24]
 7431 40f0 FEFFFFEB 		bl	_txe_thread_create
 7432              	.LVL607:
3921:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3922:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3923:../uvc.c      ****             0,                                          /* No input parameter to thread */
3924:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3925:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3926:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3927:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3928:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3929:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3930:../uvc.c      ****             );
3931:../uvc.c      ****     if (retThrdCreate != 0)
 7433              		.loc 1 3931 0
 7434 40f4 000050E3 		cmp	r0, #0
 7435 40f8 B3FFFF1A 		bne	.L602
3932:../uvc.c      ****     {
3933:../uvc.c      ****         goto fatalErrorHandler;
3934:../uvc.c      ****     }
3935:../uvc.c      **** #endif
3936:../uvc.c      **** 
3937:../uvc.c      ****     return;
3938:../uvc.c      **** 
3939:../uvc.c      **** fatalErrorHandler:
3940:../uvc.c      ****     /* Add custom recovery or debug actions here */
3941:../uvc.c      ****     /* Loop indefinitely */
3942:../uvc.c      ****     while (1);
3943:../uvc.c      **** }
 7436              		.loc 1 3943 0
 7437 40fc 4CD08DE2 		add	sp, sp, #76
 7438 4100 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7439              	.L607:
 7440              		.align	2
 7441              	.L606:
 7442 4104 00000000 		.word	cmdQuMux
 7443 4108 00000000 		.word	cmdQu
 7444 410c 00000000 		.word	statQu
 7445 4110 00000000 		.word	staQuMux
 7446 4114 A4000000 		.word	.LANCHOR0+164
 7447 4118 900A0000 		.word	.LC59
 7448 411c 00000000 		.word	UVCAppThread_Entry
 7449 4120 4C010000 		.word	.LANCHOR0+332
 7450 4124 A40A0000 		.word	.LC60
 7451 4128 00000000 		.word	UVCAppEP0Thread_Entry
 7452 412c F4010000 		.word	.LANCHOR0+500
 7453 4130 BC0A0000 		.word	.LC61
 7454 4134 00000000 		.word	I2cAppThread_Entry
 7455              		.cfi_endproc
 7456              	.LFE26:
 7458              		.align	2
 7459              		.global	main
 7461              	main:
 7462              	.LFB27:
3944:../uvc.c      **** 
3945:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3946:../uvc.c      ****  * the ThreadX RTOS here.
3947:../uvc.c      ****  */
3948:../uvc.c      **** int
3949:../uvc.c      **** main (
3950:../uvc.c      ****         void)
3951:../uvc.c      **** {
 7463              		.loc 1 3951 0
 7464              		.cfi_startproc
 7465              		@ args = 0, pretend = 0, frame = 56
 7466              		@ frame_needed = 0, uses_anonymous_args = 0
 7467 4138 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7468              	.LCFI27:
 7469              		.cfi_def_cfa_offset 12
3952:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3953:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3954:../uvc.c      **** 
3955:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3958:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3959:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3960:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7470              		.loc 1 3960 0
 7471 413c 0010A0E3 		mov	r1, #0
3951:../uvc.c      **** {
 7472              		.loc 1 3951 0
 7473 4140 3CD04DE2 		sub	sp, sp, #60
 7474              	.LCFI28:
 7475              		.cfi_def_cfa_offset 72
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7476              		.loc 1 3957 0
 7477 4144 0220A0E3 		mov	r2, #2
3961:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7478              		.loc 1 3961 0
 7479 4148 033081E2 		add	r3, r1, #3
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7480              		.loc 1 3956 0
 7481 414c 0150A0E3 		mov	r5, #1
 7482              		.cfi_offset 14, -4
 7483              		.cfi_offset 5, -8
 7484              		.cfi_offset 4, -12
3962:../uvc.c      **** 
3963:../uvc.c      ****     /* Initialize the device */
3964:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7485              		.loc 1 3964 0
 7486 4150 28008DE2 		add	r0, sp, #40
3956:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7487              		.loc 1 3956 0
 7488 4154 28508DE5 		str	r5, [sp, #40]
3957:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7489              		.loc 1 3957 0
 7490 4158 2C20CDE5 		strb	r2, [sp, #44]
3958:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7491              		.loc 1 3958 0
 7492 415c 2D20CDE5 		strb	r2, [sp, #45]
3959:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7493              		.loc 1 3959 0
 7494 4160 2E20CDE5 		strb	r2, [sp, #46]
3960:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7495              		.loc 1 3960 0
 7496 4164 30108DE5 		str	r1, [sp, #48]
3961:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7497              		.loc 1 3961 0
 7498 4168 3430CDE5 		strb	r3, [sp, #52]
 7499              		.loc 1 3964 0
 7500 416c FEFFFFEB 		bl	CyU3PDeviceInit
 7501              	.LVL608:
3965:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7502              		.loc 1 3965 0
 7503 4170 004050E2 		subs	r4, r0, #0
 7504 4174 0000000A 		beq	.L611
 7505              	.L609:
 7506              	.L610:
 7507 4178 FEFFFFEA 		b	.L610
 7508              	.L611:
3966:../uvc.c      ****     {
3967:../uvc.c      ****         goto handle_fatal_error;
3968:../uvc.c      ****     }
3969:../uvc.c      **** 
3970:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3971:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7509              		.loc 1 3971 0
 7510 417c 0410A0E1 		mov	r1, r4
 7511 4180 0420A0E1 		mov	r2, r4
 7512 4184 0500A0E1 		mov	r0, r5
 7513              	.LVL609:
 7514 4188 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7515              	.LVL610:
3972:../uvc.c      **** 
3973:../uvc.c      ****     /* Configure the IO matrix for the device. */
3974:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3975:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3976:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3977:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3978:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3979:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3980:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3981:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3982:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3983:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3984:../uvc.c      **** 
3985:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7516              		.loc 1 3985 0
 7517 418c 0D00A0E1 		mov	r0, sp
3975:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7518              		.loc 1 3975 0
 7519 4190 1640CDE5 		strb	r4, [sp, #22]
3976:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7520              		.loc 1 3976 0
 7521 4194 18408DE5 		str	r4, [sp, #24]
3977:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7522              		.loc 1 3977 0
 7523 4198 1C408DE5 		str	r4, [sp, #28]
3978:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7524              		.loc 1 3978 0
 7525 419c 20408DE5 		str	r4, [sp, #32]
3979:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7526              		.loc 1 3979 0
 7527 41a0 24408DE5 		str	r4, [sp, #36]
3982:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7528              		.loc 1 3982 0
 7529 41a4 0C408DE5 		str	r4, [sp, #12]
3983:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7530              		.loc 1 3983 0
 7531 41a8 10408DE5 		str	r4, [sp, #16]
3974:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7532              		.loc 1 3974 0
 7533 41ac 00508DE5 		str	r5, [sp, #0]
3980:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7534              		.loc 1 3980 0
 7535 41b0 04508DE5 		str	r5, [sp, #4]
3981:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7536              		.loc 1 3981 0
 7537 41b4 08508DE5 		str	r5, [sp, #8]
 7538              		.loc 1 3985 0
 7539 41b8 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7540              	.LVL611:
3986:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7541              		.loc 1 3986 0
 7542 41bc 004050E2 		subs	r4, r0, #0
 7543 41c0 ECFFFF1A 		bne	.L609
3987:../uvc.c      ****     {
3988:../uvc.c      ****         goto handle_fatal_error;
3989:../uvc.c      ****     }
3990:../uvc.c      **** 
3991:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3992:../uvc.c      ****     CyU3PKernelEntry ();
 7544              		.loc 1 3992 0
 7545 41c4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7546              	.LVL612:
3993:../uvc.c      **** 
3994:../uvc.c      ****     /* Dummy return to make the compiler happy */
3995:../uvc.c      ****     return 0;
3996:../uvc.c      **** 
3997:../uvc.c      **** handle_fatal_error:
3998:../uvc.c      ****     /* Cannot recover from this error. */
3999:../uvc.c      ****     while (1);
4000:../uvc.c      **** }
 7547              		.loc 1 4000 0
 7548 41c8 0400A0E1 		mov	r0, r4
 7549 41cc 3CD08DE2 		add	sp, sp, #60
 7550 41d0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7551              		.cfi_endproc
 7552              	.LFE27:
 7554              		.global	CyFxGpifTransition
 7555              		.global	CyFxGpifWavedata
 7556              		.global	CyFxGpifWavedataPosition
 7557              		.global	CyFxGpifRegValue
 7558              		.global	CyFxGpifConfig
 7559              		.global	CyFxGpifTransition_usb2
 7560              		.global	CyFxGpifWavedata_usb2
 7561              		.global	CyFxGpifWavedataPosition_usb2
 7562              		.global	CyFxGpifRegValue_usb2
 7563              		.global	CyFxGpifConfig_usb2
 7564              		.global	snapButFlag
 7565              		.global	testSnap
 7566              		.global	fb
 7567              		.global	pb
 7568              		.global	pbc
 7569              		.global	fbbak
 7570              		.global	pbbak
 7571              		.global	pbcbak
 7572              		.global	pbcpbak
 7573              		.global	isUsbConnected
 7574              		.global	usbSpeed
 7575              		.global	clearFeatureRqtReceived
 7576              		.global	streamingStarted
 7577              		.global	glProbeCtrl
 7578              		.global	glProbeCtrlFull
 7579              		.global	glProbeStilCtrl
 7580              		.global	glProbeCtrl20
 7581              		.global	glProbeStilCtrl20
 7582              		.global	glUVCHeader
 7583              		.comm	glChHandleUVCStream,220,4
 7584              		.comm	glChHandleStillStream,220,4
 7585              		.comm	glChHandleInterStat,160,4
 7586              		.comm	glInterStaBuffer,4,4
 7587              		.comm	cmdQu,32,4
 7588              		.comm	statQu,32,4
 7589              		.comm	cmdQuMux,56,4
 7590              		.comm	staQuMux,56,4
 7591              		.comm	timMux,56,4
 7592              		.comm	imgHdMux,56,4
 7593              		.comm	bmReqType,1,1
 7594              		.comm	bRequest,1,1
 7595              		.comm	wValue,2,2
 7596              		.comm	wIndex,2,2
 7597              		.comm	wLength,2,2
 7598              		.comm	posTick,4,4
 7599              		.comm	I2CCmdTimer,44,4
 7600              		.section	.rodata
 7601              		.align	2
 7602              		.set	.LANCHOR2,. + 0
 7605              	ExTime:
 7606 0000 9C       		.byte	-100
 7607 0001 00       		.byte	0
 7608 0002 4E       		.byte	78
 7609 0003 00       		.byte	0
 7610 0004 27       		.byte	39
 7611 0005 00       		.byte	0
 7612 0006 14       		.byte	20
 7613 0007 00       		.byte	0
 7614 0008 0A       		.byte	10
 7615 0009 00       		.byte	0
 7616 000a 05       		.byte	5
 7617 000b 00       		.byte	0
 7618 000c 02       		.byte	2
 7619 000d 00       		.byte	0
 7620 000e 01       		.byte	1
 7621 000f 00       		.byte	0
 7624              	CyFxGpifConfig:
 7625 0010 0F00     		.short	15
 7626 0012 0000     		.space	2
 7627 0014 00000000 		.word	CyFxGpifWavedata
 7628 0018 00000000 		.word	CyFxGpifWavedataPosition
 7629 001c 0500     		.short	5
 7630 001e 0000     		.space	2
 7631 0020 00000000 		.word	CyFxGpifTransition
 7632 0024 4C00     		.short	76
 7633 0026 0000     		.space	2
 7634 0028 00000000 		.word	CyFxGpifRegValue
 7637              	CyFxGpifConfig_usb2:
 7638 002c 9300     		.short	147
 7639 002e 0000     		.space	2
 7640 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7641 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7642 0038 0800     		.short	8
 7643 003a 0000     		.space	2
 7644 003c 00000000 		.word	CyFxGpifTransition_usb2
 7645 0040 4C00     		.short	76
 7646 0042 0000     		.space	2
 7647 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7648              		.data
 7649              		.align	2
 7650              		.set	.LANCHOR1,. + 0
 7653              	ExUCtrlParArry:
 7654 0000 13       		.byte	19
 7655 0001 14       		.byte	20
 7656 0002 02       		.byte	2
 7657 0003 01       		.byte	1
 7658 0004 00       		.byte	0
 7659 0005 03       		.byte	3
 7660 0006 00       		.byte	0
 7661 0007 01       		.byte	1
 7662 0008 00       		.byte	0
 7663 0009 03       		.byte	3
 7664 000a 00       		.byte	0
 7665 000b 23       		.byte	35
 7666 000c 37       		.byte	55
 7667 000d 23       		.byte	35
 7668 000e 37       		.byte	55
 7669 000f 30       		.byte	48
 7670 0010 01       		.byte	1
 7671 0011 00       		.byte	0
 7672 0012 00       		.byte	0
 7673 0013 00000000 		.space	5
 7673      00
 7674 0018 11       		.byte	17
 7675 0019 00       		.byte	0
 7676 001a 02       		.byte	2
 7677 001b 01       		.byte	1
 7678 001c 00       		.byte	0
 7679 001d 03       		.byte	3
 7680 001e 00       		.byte	0
 7681 001f 01       		.byte	1
 7682 0020 00       		.byte	0
 7683 0021 03       		.byte	3
 7684 0022 00       		.byte	0
 7685 0023 01       		.byte	1
 7686 0024 00       		.byte	0
 7687 0025 01       		.byte	1
 7688 0026 00       		.byte	0
 7689 0027 30       		.byte	48
 7690 0028 01       		.byte	1
 7691 0029 01       		.byte	1
 7692 002a 00       		.byte	0
 7693 002b 00000000 		.space	5
 7693      00
 7694 0030 17       		.byte	23
 7695 0031 00       		.byte	0
 7696 0032 01       		.byte	1
 7697 0033 01       		.byte	1
 7698 0034 00       		.byte	0
 7699 0035 02       		.byte	2
 7700 0036 00       		.byte	0
 7701 0037 01       		.byte	1
 7702 0038 00       		.byte	0
 7703 0039 03       		.byte	3
 7704 003a 00       		.byte	0
 7705 003b 00       		.byte	0
 7706 003c 00       		.byte	0
 7707 003d 00       		.byte	0
 7708 003e 00       		.byte	0
 7709 003f 30       		.byte	48
 7710 0040 01       		.byte	1
 7711 0041 01       		.byte	1
 7712 0042 00       		.byte	0
 7713 0043 00000000 		.space	5
 7713      00
 7714 0048 00       		.byte	0
 7715 0049 00       		.byte	0
 7716 004a 04       		.byte	4
 7717 004b 01       		.byte	1
 7718 004c 00       		.byte	0
 7719 004d 38       		.byte	56
 7720 004e 01       		.byte	1
 7721 004f 01       		.byte	1
 7722 0050 00       		.byte	0
 7723 0051 03       		.byte	3
 7724 0052 00       		.byte	0
 7725 0053 4E       		.byte	78
 7726 0054 00       		.byte	0
 7727 0055 4E       		.byte	78
 7728 0056 00       		.byte	0
 7729 0057 30       		.byte	48
 7730 0058 01       		.byte	1
 7731 0059 00       		.byte	0
 7732 005a 00       		.byte	0
 7733 005b 00000000 		.space	5
 7733      00
 7734 0060 00       		.byte	0
 7735 0061 00       		.byte	0
 7736 0062 01       		.byte	1
 7737 0063 00       		.byte	0
 7738 0064 00       		.byte	0
 7739 0065 00       		.byte	0
 7740 0066 00       		.byte	0
 7741 0067 01       		.byte	1
 7742 0068 00       		.byte	0
 7743 0069 03       		.byte	3
 7744 006a 00       		.byte	0
 7745 006b 00       		.byte	0
 7746 006c 00       		.byte	0
 7747 006d 00       		.byte	0
 7748 006e 00       		.byte	0
 7749 006f 30       		.byte	48
 7750 0070 01       		.byte	1
 7751 0071 00       		.byte	0
 7752 0072 00       		.byte	0
 7753 0073 00000000 		.space	5
 7753      00
 7754 0078 00       		.byte	0
 7755 0079 00       		.byte	0
 7756 007a 02       		.byte	2
 7757 007b 00       		.byte	0
 7758 007c 00       		.byte	0
 7759 007d FF       		.byte	-1
 7760 007e 00       		.byte	0
 7761 007f 01       		.byte	1
 7762 0080 00       		.byte	0
 7763 0081 03       		.byte	3
 7764 0082 00       		.byte	0
 7765 0083 01       		.byte	1
 7766 0084 00       		.byte	0
 7767 0085 00       		.byte	0
 7768 0086 00       		.byte	0
 7769 0087 30       		.byte	48
 7770 0088 01       		.byte	1
 7771 0089 01       		.byte	1
 7772 008a 00       		.byte	0
 7773 008b 00000000 		.space	5
 7773      00
 7774 0090 00       		.byte	0
 7775 0091 00       		.byte	0
 7776 0092 02       		.byte	2
 7777 0093 00       		.byte	0
 7778 0094 00       		.byte	0
 7779 0095 00       		.byte	0
 7780 0096 00       		.byte	0
 7781 0097 00       		.byte	0
 7782 0098 00       		.byte	0
 7783 0099 03       		.byte	3
 7784 009a 00       		.byte	0
 7785 009b 00       		.byte	0
 7786 009c 00       		.byte	0
 7787 009d 00       		.byte	0
 7788 009e 00       		.byte	0
 7789 009f 30       		.byte	48
 7790 00a0 01       		.byte	1
 7791 00a1 01       		.byte	1
 7792 00a2 00       		.byte	0
 7793 00a3 00000000 		.space	5
 7793      00
 7794 00a8 00       		.byte	0
 7795 00a9 00       		.byte	0
 7796 00aa 02       		.byte	2
 7797 00ab 00       		.byte	0
 7798 00ac 00       		.byte	0
 7799 00ad 30       		.byte	48
 7800 00ae 00       		.byte	0
 7801 00af 01       		.byte	1
 7802 00b0 00       		.byte	0
 7803 00b1 03       		.byte	3
 7804 00b2 0A       		.byte	10
 7805 00b3 00       		.byte	0
 7806 00b4 00       		.byte	0
 7807 00b5 0A       		.byte	10
 7808 00b6 00       		.byte	0
 7809 00b7 30       		.byte	48
 7810 00b8 01       		.byte	1
 7811 00b9 01       		.byte	1
 7812 00ba 00       		.byte	0
 7813 00bb 00000000 		.space	5
 7813      00
 7814 00c0 00       		.byte	0
 7815 00c1 00       		.byte	0
 7816 00c2 01       		.byte	1
 7817 00c3 00       		.byte	0
 7818 00c4 00       		.byte	0
 7819 00c5 7F       		.byte	127
 7820 00c6 00       		.byte	0
 7821 00c7 01       		.byte	1
 7822 00c8 00       		.byte	0
 7823 00c9 03       		.byte	3
 7824 00ca 00       		.byte	0
 7825 00cb 00       		.byte	0
 7826 00cc 00       		.byte	0
 7827 00cd 00       		.byte	0
 7828 00ce 00       		.byte	0
 7829 00cf 30       		.byte	48
 7830 00d0 01       		.byte	1
 7831 00d1 00       		.byte	0
 7832 00d2 00       		.byte	0
 7833 00d3 00000000 		.space	5
 7833      00
 7834 00d8 00       		.byte	0
 7835 00d9 00       		.byte	0
 7836 00da 02       		.byte	2
 7837 00db 00       		.byte	0
 7838 00dc 00       		.byte	0
 7839 00dd 05       		.byte	5
 7840 00de 00       		.byte	0
 7841 00df 01       		.byte	1
 7842 00e0 00       		.byte	0
 7843 00e1 03       		.byte	3
 7844 00e2 00       		.byte	0
 7845 00e3 00       		.byte	0
 7846 00e4 00       		.byte	0
 7847 00e5 00       		.byte	0
 7848 00e6 00       		.byte	0
 7849 00e7 30       		.byte	48
 7850 00e8 01       		.byte	1
 7851 00e9 00       		.byte	0
 7852 00ea 00       		.byte	0
 7853 00eb 00000000 		.space	5
 7853      00
 7854 00f0 00       		.byte	0
 7855 00f1 00       		.byte	0
 7856 00f2 03       		.byte	3
 7857 00f3 00       		.byte	0
 7858 00f4 00       		.byte	0
 7859 00f5 0A       		.byte	10
 7860 00f6 00       		.byte	0
 7861 00f7 01       		.byte	1
 7862 00f8 00       		.byte	0
 7863 00f9 03       		.byte	3
 7864 00fa 00       		.byte	0
 7865 00fb 00       		.byte	0
 7866 00fc 00       		.byte	0
 7867 00fd 00       		.byte	0
 7868 00fe 00       		.byte	0
 7869 00ff 30       		.byte	48
 7870 0100 01       		.byte	1
 7871 0101 00       		.byte	0
 7872 0102 00       		.byte	0
 7873 0103 00000000 		.space	5
 7873      00
 7874 0108 00       		.byte	0
 7875 0109 00       		.byte	0
 7876 010a 02       		.byte	2
 7877 010b 00       		.byte	0
 7878 010c 00       		.byte	0
 7879 010d 40       		.byte	64
 7880 010e 00       		.byte	0
 7881 010f 01       		.byte	1
 7882 0110 00       		.byte	0
 7883 0111 03       		.byte	3
 7884 0112 00       		.byte	0
 7885 0113 0F       		.byte	15
 7886 0114 11       		.byte	17
 7887 0115 00       		.byte	0
 7888 0116 00       		.byte	0
 7889 0117 30       		.byte	48
 7890 0118 01       		.byte	1
 7891 0119 00       		.byte	0
 7892 011a 00       		.byte	0
 7893 011b 00000000 		.space	5
 7893      00
 7894 0120 00       		.byte	0
 7895 0121 00       		.byte	0
 7896 0122 02       		.byte	2
 7897 0123 00       		.byte	0
 7898 0124 00       		.byte	0
 7899 0125 64       		.byte	100
 7900 0126 00       		.byte	0
 7901 0127 01       		.byte	1
 7902 0128 00       		.byte	0
 7903 0129 03       		.byte	3
 7904 012a 00       		.byte	0
 7905 012b 00       		.byte	0
 7906 012c 00       		.byte	0
 7907 012d 00       		.byte	0
 7908 012e 00       		.byte	0
 7909 012f 30       		.byte	48
 7910 0130 01       		.byte	1
 7911 0131 00       		.byte	0
 7912 0132 00       		.byte	0
 7913 0133 00000000 		.space	5
 7913      00
 7914 0138 00       		.byte	0
 7915 0139 00       		.byte	0
 7916 013a 02       		.byte	2
 7917 013b 00       		.byte	0
 7918 013c 00       		.byte	0
 7919 013d 64       		.byte	100
 7920 013e 00       		.byte	0
 7921 013f 01       		.byte	1
 7922 0140 00       		.byte	0
 7923 0141 03       		.byte	3
 7924 0142 00       		.byte	0
 7925 0143 00       		.byte	0
 7926 0144 00       		.byte	0
 7927 0145 00       		.byte	0
 7928 0146 00       		.byte	0
 7929 0147 30       		.byte	48
 7930 0148 01       		.byte	1
 7931 0149 00       		.byte	0
 7932 014a 00       		.byte	0
 7933 014b 00000000 		.space	5
 7933      00
 7934 0150 00       		.byte	0
 7935 0151 00       		.byte	0
 7936 0152 02       		.byte	2
 7937 0153 00       		.byte	0
 7938 0154 00       		.byte	0
 7939 0155 64       		.byte	100
 7940 0156 00       		.byte	0
 7941 0157 01       		.byte	1
 7942 0158 00       		.byte	0
 7943 0159 03       		.byte	3
 7944 015a 00       		.byte	0
 7945 015b 00       		.byte	0
 7946 015c 00       		.byte	0
 7947 015d 00       		.byte	0
 7948 015e 00       		.byte	0
 7949 015f 30       		.byte	48
 7950 0160 01       		.byte	1
 7951 0161 00       		.byte	0
 7952 0162 00       		.byte	0
 7953 0163 00000000 		.space	5
 7953      00
 7954 0168 00       		.byte	0
 7955 0169 00       		.byte	0
 7956 016a 02       		.byte	2
 7957 016b 00       		.byte	0
 7958 016c 00       		.byte	0
 7959 016d 64       		.byte	100
 7960 016e 00       		.byte	0
 7961 016f 01       		.byte	1
 7962 0170 00       		.byte	0
 7963 0171 03       		.byte	3
 7964 0172 00       		.byte	0
 7965 0173 00       		.byte	0
 7966 0174 00       		.byte	0
 7967 0175 00       		.byte	0
 7968 0176 00       		.byte	0
 7969 0177 30       		.byte	48
 7970 0178 01       		.byte	1
 7971 0179 00       		.byte	0
 7972 017a 00       		.byte	0
 7973 017b 00000000 		.space	5
 7973      00
 7976              	CtrlParArry:
 7977 0180 10       		.byte	16
 7978 0181 10       		.byte	16
 7979 0182 02       		.byte	2
 7980 0183 00       		.byte	0
 7981 0184 00       		.byte	0
 7982 0185 03       		.byte	3
 7983 0186 00       		.byte	0
 7984 0187 01       		.byte	1
 7985 0188 00       		.byte	0
 7986 0189 03       		.byte	3
 7987 018a 00       		.byte	0
 7988 018b 03       		.byte	3
 7989 018c 00       		.byte	0
 7990 018d 03       		.byte	3
 7991 018e 00       		.byte	0
 7992 018f 30       		.byte	48
 7993 0190 01       		.byte	1
 7994 0191 00       		.byte	0
 7995 0192 00       		.byte	0
 7996 0193 00000000 		.space	5
 7996      00
 7997 0198 15       		.byte	21
 7998 0199 15       		.byte	21
 7999 019a 02       		.byte	2
 8000 019b 00       		.byte	0
 8001 019c 00       		.byte	0
 8002 019d FF       		.byte	-1
 8003 019e 00       		.byte	0
 8004 019f 01       		.byte	1
 8005 01a0 00       		.byte	0
 8006 01a1 03       		.byte	3
 8007 01a2 00       		.byte	0
 8008 01a3 76       		.byte	118
 8009 01a4 00       		.byte	0
 8010 01a5 76       		.byte	118
 8011 01a6 C7       		.byte	-57
 8012 01a7 30       		.byte	48
 8013 01a8 01       		.byte	1
 8014 01a9 01       		.byte	1
 8015 01aa 00       		.byte	0
 8016 01ab 00000000 		.space	5
 8016      00
 8017 01b0 02       		.byte	2
 8018 01b1 02       		.byte	2
 8019 01b2 02       		.byte	2
 8020 01b3 00       		.byte	0
 8021 01b4 00       		.byte	0
 8022 01b5 FF       		.byte	-1
 8023 01b6 00       		.byte	0
 8024 01b7 01       		.byte	1
 8025 01b8 00       		.byte	0
 8026 01b9 03       		.byte	3
 8027 01ba 00       		.byte	0
 8028 01bb 70       		.byte	112
 8029 01bc 00       		.byte	0
 8030 01bd 70       		.byte	112
 8031 01be 00       		.byte	0
 8032 01bf C6       		.byte	-58
 8033 01c0 01       		.byte	1
 8034 01c1 01       		.byte	1
 8035 01c2 00       		.byte	0
 8036 01c3 00000000 		.space	5
 8036      00
 8037 01c8 00       		.byte	0
 8038 01c9 00       		.byte	0
 8039 01ca 02       		.byte	2
 8040 01cb 00       		.byte	0
 8041 01cc 00       		.byte	0
 8042 01cd 64       		.byte	100
 8043 01ce 00       		.byte	0
 8044 01cf 01       		.byte	1
 8045 01d0 00       		.byte	0
 8046 01d1 03       		.byte	3
 8047 01d2 00       		.byte	0
 8048 01d3 00       		.byte	0
 8049 01d4 00       		.byte	0
 8050 01d5 00       		.byte	0
 8051 01d6 00       		.byte	0
 8052 01d7 30       		.byte	48
 8053 01d8 01       		.byte	1
 8054 01d9 00       		.byte	0
 8055 01da 00       		.byte	0
 8056 01db 00000000 		.space	5
 8056      00
 8057 01e0 07       		.byte	7
 8058 01e1 07       		.byte	7
 8059 01e2 02       		.byte	2
 8060 01e3 00       		.byte	0
 8061 01e4 00       		.byte	0
 8062 01e5 01       		.byte	1
 8063 01e6 00       		.byte	0
 8064 01e7 01       		.byte	1
 8065 01e8 00       		.byte	0
 8066 01e9 03       		.byte	3
 8067 01ea 00       		.byte	0
 8068 01eb 01       		.byte	1
 8069 01ec 00       		.byte	0
 8070 01ed 01       		.byte	1
 8071 01ee 00       		.byte	0
 8072 01ef 30       		.byte	48
 8073 01f0 01       		.byte	1
 8074 01f1 00       		.byte	0
 8075 01f2 00       		.byte	0
 8076 01f3 00000000 		.space	5
 8076      00
 8077 01f8 DF       		.byte	-33
 8078 01f9 E1       		.byte	-31
 8079 01fa 02       		.byte	2
 8080 01fb 00       		.byte	0
 8081 01fc 00       		.byte	0
 8082 01fd FF       		.byte	-1
 8083 01fe 00       		.byte	0
 8084 01ff 01       		.byte	1
 8085 0200 00       		.byte	0
 8086 0201 03       		.byte	3
 8087 0202 00       		.byte	0
 8088 0203 80       		.byte	-128
 8089 0204 00       		.byte	0
 8090 0205 00       		.byte	0
 8091 0206 00       		.byte	0
 8092 0207 C6       		.byte	-58
 8093 0208 01       		.byte	1
 8094 0209 01       		.byte	1
 8095 020a 00       		.byte	0
 8096 020b 00000000 		.space	5
 8096      00
 8097 0210 85       		.byte	-123
 8098 0211 86       		.byte	-122
 8099 0212 02       		.byte	2
 8100 0213 00       		.byte	0
 8101 0214 00       		.byte	0
 8102 0215 64       		.byte	100
 8103 0216 00       		.byte	0
 8104 0217 01       		.byte	1
 8105 0218 00       		.byte	0
 8106 0219 03       		.byte	3
 8107 021a 00       		.byte	0
 8108 021b 32       		.byte	50
 8109 021c 00       		.byte	0
 8110 021d 32       		.byte	50
 8111 021e 00       		.byte	0
 8112 021f F2       		.byte	-14
 8113 0220 01       		.byte	1
 8114 0221 01       		.byte	1
 8115 0222 00       		.byte	0
 8116 0223 00000000 		.space	5
 8116      00
 8117 0228 06       		.byte	6
 8118 0229 06       		.byte	6
 8119 022a 02       		.byte	2
 8120 022b 00       		.byte	0
 8121 022c 00       		.byte	0
 8122 022d 40       		.byte	64
 8123 022e 00       		.byte	0
 8124 022f 01       		.byte	1
 8125 0230 00       		.byte	0
 8126 0231 03       		.byte	3
 8127 0232 00       		.byte	0
 8128 0233 20       		.byte	32
 8129 0234 00       		.byte	0
 8130 0235 20       		.byte	32
 8131 0236 00       		.byte	0
 8132 0237 30       		.byte	48
 8133 0238 01       		.byte	1
 8134 0239 01       		.byte	1
 8135 023a 00       		.byte	0
 8136 023b 00000000 		.space	5
 8136      00
 8137 0240 00       		.byte	0
 8138 0241 00       		.byte	0
 8139 0242 02       		.byte	2
 8140 0243 00       		.byte	0
 8141 0244 00       		.byte	0
 8142 0245 64       		.byte	100
 8143 0246 00       		.byte	0
 8144 0247 01       		.byte	1
 8145 0248 00       		.byte	0
 8146 0249 03       		.byte	3
 8147 024a 00       		.byte	0
 8148 024b 00       		.byte	0
 8149 024c 00       		.byte	0
 8150 024d 00       		.byte	0
 8151 024e 00       		.byte	0
 8152 024f 30       		.byte	48
 8153 0250 01       		.byte	1
 8154 0251 00       		.byte	0
 8155 0252 00       		.byte	0
 8156 0253 00000000 		.space	5
 8156      00
 8157 0258 08       		.byte	8
 8158 0259 08       		.byte	8
 8159 025a 02       		.byte	2
 8160 025b 00       		.byte	0
 8161 025c 00       		.byte	0
 8162 025d 05       		.byte	5
 8163 025e 00       		.byte	0
 8164 025f 01       		.byte	1
 8165 0260 00       		.byte	0
 8166 0261 03       		.byte	3
 8167 0262 00       		.byte	0
 8168 0263 00       		.byte	0
 8169 0264 00       		.byte	0
 8170 0265 00       		.byte	0
 8171 0266 00       		.byte	0
 8172 0267 30       		.byte	48
 8173 0268 01       		.byte	1
 8174 0269 00       		.byte	0
 8175 026a 00       		.byte	0
 8176 026b 00000000 		.space	5
 8176      00
 8177 0270 00       		.byte	0
 8178 0271 00       		.byte	0
 8179 0272 02       		.byte	2
 8180 0273 00       		.byte	0
 8181 0274 00       		.byte	0
 8182 0275 40       		.byte	64
 8183 0276 00       		.byte	0
 8184 0277 01       		.byte	1
 8185 0278 00       		.byte	0
 8186 0279 03       		.byte	3
 8187 027a 00       		.byte	0
 8188 027b 00       		.byte	0
 8189 027c 00       		.byte	0
 8190 027d 00       		.byte	0
 8191 027e 00       		.byte	0
 8192 027f 30       		.byte	48
 8193 0280 01       		.byte	1
 8194 0281 00       		.byte	0
 8195 0282 00       		.byte	0
 8196 0283 00000000 		.space	5
 8196      00
 8197 0288 09       		.byte	9
 8198 0289 0A       		.byte	10
 8199 028a 04       		.byte	4
 8200 028b 00       		.byte	0
 8201 028c 00       		.byte	0
 8202 028d 40       		.byte	64
 8203 028e 00       		.byte	0
 8204 028f 01       		.byte	1
 8205 0290 00       		.byte	0
 8206 0291 03       		.byte	3
 8207 0292 00       		.byte	0
 8208 0293 20       		.byte	32
 8209 0294 38       		.byte	56
 8210 0295 20       		.byte	32
 8211 0296 38       		.byte	56
 8212 0297 30       		.byte	48
 8213 0298 01       		.byte	1
 8214 0299 00       		.byte	0
 8215 029a 00       		.byte	0
 8216 029b 00000000 		.space	5
 8216      00
 8217 02a0 00       		.byte	0
 8218 02a1 00       		.byte	0
 8219 02a2 02       		.byte	2
 8220 02a3 00       		.byte	0
 8221 02a4 00       		.byte	0
 8222 02a5 64       		.byte	100
 8223 02a6 00       		.byte	0
 8224 02a7 01       		.byte	1
 8225 02a8 00       		.byte	0
 8226 02a9 03       		.byte	3
 8227 02aa 00       		.byte	0
 8228 02ab 00       		.byte	0
 8229 02ac 00       		.byte	0
 8230 02ad 00       		.byte	0
 8231 02ae 00       		.byte	0
 8232 02af 30       		.byte	48
 8233 02b0 01       		.byte	1
 8234 02b1 00       		.byte	0
 8235 02b2 00       		.byte	0
 8236 02b3 00000000 		.space	5
 8236      00
 8237 02b8 00       		.byte	0
 8238 02b9 00       		.byte	0
 8239 02ba 02       		.byte	2
 8240 02bb 00       		.byte	0
 8241 02bc 00       		.byte	0
 8242 02bd 64       		.byte	100
 8243 02be 00       		.byte	0
 8244 02bf 01       		.byte	1
 8245 02c0 00       		.byte	0
 8246 02c1 03       		.byte	3
 8247 02c2 00       		.byte	0
 8248 02c3 00       		.byte	0
 8249 02c4 00       		.byte	0
 8250 02c5 00       		.byte	0
 8251 02c6 00       		.byte	0
 8252 02c7 30       		.byte	48
 8253 02c8 01       		.byte	1
 8254 02c9 00       		.byte	0
 8255 02ca 00       		.byte	0
 8256 02cb 00000000 		.space	5
 8256      00
 8257 02d0 2A       		.byte	42
 8258 02d1 2A       		.byte	42
 8259 02d2 02       		.byte	2
 8260 02d3 00       		.byte	0
 8261 02d4 00       		.byte	0
 8262 02d5 1B       		.byte	27
 8263 02d6 00       		.byte	0
 8264 02d7 01       		.byte	1
 8265 02d8 00       		.byte	0
 8266 02d9 03       		.byte	3
 8267 02da 00       		.byte	0
 8268 02db 00       		.byte	0
 8269 02dc 00       		.byte	0
 8270 02dd 00       		.byte	0
 8271 02de 00       		.byte	0
 8272 02df 30       		.byte	48
 8273 02e0 01       		.byte	1
 8274 02e1 00       		.byte	0
 8275 02e2 00       		.byte	0
 8276 02e3 00000000 		.space	5
 8276      00
 8277 02e8 00       		.byte	0
 8278 02e9 00       		.byte	0
 8279 02ea 02       		.byte	2
 8280 02eb 00       		.byte	0
 8281 02ec 00       		.byte	0
 8282 02ed 64       		.byte	100
 8283 02ee 00       		.byte	0
 8284 02ef 01       		.byte	1
 8285 02f0 00       		.byte	0
 8286 02f1 03       		.byte	3
 8287 02f2 00       		.byte	0
 8288 02f3 00       		.byte	0
 8289 02f4 00       		.byte	0
 8290 02f5 00       		.byte	0
 8291 02f6 00       		.byte	0
 8292 02f7 30       		.byte	48
 8293 02f8 01       		.byte	1
 8294 02f9 00       		.byte	0
 8295 02fa 00       		.byte	0
 8296 02fb 00000000 		.space	5
 8296      00
 8297 0300 00       		.byte	0
 8298 0301 00       		.byte	0
 8299 0302 02       		.byte	2
 8300 0303 00       		.byte	0
 8301 0304 00       		.byte	0
 8302 0305 12       		.byte	18
 8303 0306 00       		.byte	0
 8304 0307 01       		.byte	1
 8305 0308 00       		.byte	0
 8306 0309 03       		.byte	3
 8307 030a 00       		.byte	0
 8308 030b 00       		.byte	0
 8309 030c 00       		.byte	0
 8310 030d 00       		.byte	0
 8311 030e 00       		.byte	0
 8312 030f 30       		.byte	48
 8313 0310 01       		.byte	1
 8314 0311 00       		.byte	0
 8315 0312 00       		.byte	0
 8316 0313 00000000 		.space	5
 8316      00
 8317 0318 01       		.byte	1
 8318 0319 01       		.byte	1
 8319 031a 02       		.byte	2
 8320 031b 00       		.byte	0
 8321 031c 00       		.byte	0
 8322 031d 09       		.byte	9
 8323 031e 00       		.byte	0
 8324 031f 01       		.byte	1
 8325 0320 00       		.byte	0
 8326 0321 03       		.byte	3
 8327 0322 00       		.byte	0
 8328 0323 00       		.byte	0
 8329 0324 00       		.byte	0
 8330 0325 01       		.byte	1
 8331 0326 00       		.byte	0
 8332 0327 30       		.byte	48
 8333 0328 01       		.byte	1
 8334 0329 00       		.byte	0
 8335 032a 00       		.byte	0
 8336 032b 00000000 		.space	5
 8336      00
 8337 0330 05       		.byte	5
 8338 0331 05       		.byte	5
 8339 0332 02       		.byte	2
 8340 0333 00       		.byte	0
 8341 0334 00       		.byte	0
 8342 0335 03       		.byte	3
 8343 0336 00       		.byte	0
 8344 0337 01       		.byte	1
 8345 0338 00       		.byte	0
 8346 0339 03       		.byte	3
 8347 033a 00       		.byte	0
 8348 033b 00       		.byte	0
 8349 033c 00       		.byte	0
 8350 033d 02       		.byte	2
 8351 033e 00       		.byte	0
 8352 033f 30       		.byte	48
 8353 0340 01       		.byte	1
 8354 0341 00       		.byte	0
 8355 0342 00       		.byte	0
 8356 0343 00000000 		.space	5
 8356      00
 8357 0348 18       		.byte	24
 8358 0349 18       		.byte	24
 8359 034a 02       		.byte	2
 8360 034b 00       		.byte	0
 8361 034c 00       		.byte	0
 8362 034d 01       		.byte	1
 8363 034e 00       		.byte	0
 8364 034f 01       		.byte	1
 8365 0350 00       		.byte	0
 8366 0351 03       		.byte	3
 8367 0352 00       		.byte	0
 8368 0353 00       		.byte	0
 8369 0354 00       		.byte	0
 8370 0355 00       		.byte	0
 8371 0356 00       		.byte	0
 8372 0357 30       		.byte	48
 8373 0358 01       		.byte	1
 8374 0359 00       		.byte	0
 8375 035a 00       		.byte	0
 8376 035b 00000000 		.space	5
 8376      00
 8377 0360 19       		.byte	25
 8378 0361 19       		.byte	25
 8379 0362 01       		.byte	1
 8380 0363 00       		.byte	0
 8381 0364 00       		.byte	0
 8382 0365 40       		.byte	64
 8383 0366 00       		.byte	0
 8384 0367 01       		.byte	1
 8385 0368 00       		.byte	0
 8386 0369 03       		.byte	3
 8387 036a 00       		.byte	0
 8388 036b 20       		.byte	32
 8389 036c 00       		.byte	0
 8390 036d 20       		.byte	32
 8391 036e 00       		.byte	0
 8392 036f 30       		.byte	48
 8393 0370 01       		.byte	1
 8394 0371 00       		.byte	0
 8395 0372 00       		.byte	0
 8396 0373 00000000 		.space	5
 8396      00
 8397 0378 20       		.byte	32
 8398 0379 20       		.byte	32
 8399 037a 02       		.byte	2
 8400 037b 00       		.byte	0
 8401 037c 00       		.byte	0
 8402 037d 02       		.byte	2
 8403 037e 00       		.byte	0
 8404 037f 01       		.byte	1
 8405 0380 00       		.byte	0
 8406 0381 03       		.byte	3
 8407 0382 00       		.byte	0
 8408 0383 00       		.byte	0
 8409 0384 00       		.byte	0
 8410 0385 00       		.byte	0
 8411 0386 00       		.byte	0
 8412 0387 30       		.byte	48
 8413 0388 01       		.byte	1
 8414 0389 00       		.byte	0
 8415 038a 00       		.byte	0
 8416 038b 00000000 		.space	5
 8416      00
 8417 0390 22       		.byte	34
 8418 0391 22       		.byte	34
 8419 0392 02       		.byte	2
 8420 0393 00       		.byte	0
 8421 0394 00       		.byte	0
 8422 0395 3F       		.byte	63
 8423 0396 00       		.byte	0
 8424 0397 01       		.byte	1
 8425 0398 00       		.byte	0
 8426 0399 03       		.byte	3
 8427 039a 00       		.byte	0
 8428 039b 00       		.byte	0
 8429 039c 00       		.byte	0
 8430 039d 00       		.byte	0
 8431 039e 00       		.byte	0
 8432 039f 30       		.byte	48
 8433 03a0 01       		.byte	1
 8434 03a1 00       		.byte	0
 8435 03a2 00       		.byte	0
 8436 03a3 00000000 		.space	5
 8436      00
 8437 03a8 23       		.byte	35
 8438 03a9 23       		.byte	35
 8439 03aa 02       		.byte	2
 8440 03ab 00       		.byte	0
 8441 03ac 00       		.byte	0
 8442 03ad 64       		.byte	100
 8443 03ae 00       		.byte	0
 8444 03af 01       		.byte	1
 8445 03b0 00       		.byte	0
 8446 03b1 03       		.byte	3
 8447 03b2 00       		.byte	0
 8448 03b3 10       		.byte	16
 8449 03b4 00       		.byte	0
 8450 03b5 10       		.byte	16
 8451 03b6 00       		.byte	0
 8452 03b7 30       		.byte	48
 8453 03b8 01       		.byte	1
 8454 03b9 00       		.byte	0
 8455 03ba 00       		.byte	0
 8456 03bb 00000000 		.space	5
 8456      00
 8457 03c0 24       		.byte	36
 8458 03c1 24       		.byte	36
 8459 03c2 02       		.byte	2
 8460 03c3 00       		.byte	0
 8461 03c4 00       		.byte	0
 8462 03c5 64       		.byte	100
 8463 03c6 00       		.byte	0
 8464 03c7 01       		.byte	1
 8465 03c8 00       		.byte	0
 8466 03c9 03       		.byte	3
 8467 03ca 00       		.byte	0
 8468 03cb 10       		.byte	16
 8469 03cc 00       		.byte	0
 8470 03cd 10       		.byte	16
 8471 03ce 00       		.byte	0
 8472 03cf 30       		.byte	48
 8473 03d0 01       		.byte	1
 8474 03d1 00       		.byte	0
 8475 03d2 00       		.byte	0
 8476 03d3 00000000 		.space	5
 8476      00
 8477 03d8 02       		.byte	2
 8478 03d9 03       		.byte	3
 8479 03da 04       		.byte	4
 8480 03db 00       		.byte	0
 8481 03dc 00       		.byte	0
 8482 03dd 7F       		.byte	127
 8483 03de 00       		.byte	0
 8484 03df 01       		.byte	1
 8485 03e0 00       		.byte	0
 8486 03e1 03       		.byte	3
 8487 03e2 00       		.byte	0
 8488 03e3 00       		.byte	0
 8489 03e4 20       		.byte	32
 8490 03e5 00       		.byte	0
 8491 03e6 20       		.byte	32
 8492 03e7 30       		.byte	48
 8493 03e8 01       		.byte	1
 8494 03e9 00       		.byte	0
 8495 03ea 00       		.byte	0
 8496 03eb 00000000 		.space	5
 8496      00
 8497 03f0 04       		.byte	4
 8498 03f1 04       		.byte	4
 8499 03f2 02       		.byte	2
 8500 03f3 00       		.byte	0
 8501 03f4 00       		.byte	0
 8502 03f5 40       		.byte	64
 8503 03f6 00       		.byte	0
 8504 03f7 01       		.byte	1
 8505 03f8 00       		.byte	0
 8506 03f9 03       		.byte	3
 8507 03fa 00       		.byte	0
 8508 03fb 20       		.byte	32
 8509 03fc 00       		.byte	0
 8510 03fd 20       		.byte	32
 8511 03fe 00       		.byte	0
 8512 03ff 30       		.byte	48
 8513 0400 01       		.byte	1
 8514 0401 00       		.byte	0
 8515 0402 00       		.byte	0
 8516 0403 00000000 		.space	5
 8516      00
 8517 0408 00       		.byte	0
 8518 0409 00       		.byte	0
 8519 040a 02       		.byte	2
 8520 040b 00       		.byte	0
 8521 040c 00       		.byte	0
 8522 040d 19       		.byte	25
 8523 040e 00       		.byte	0
 8524 040f 01       		.byte	1
 8525 0410 00       		.byte	0
 8526 0411 03       		.byte	3
 8527 0412 00       		.byte	0
 8528 0413 00       		.byte	0
 8529 0414 00       		.byte	0
 8530 0415 00       		.byte	0
 8531 0416 00       		.byte	0
 8532 0417 30       		.byte	48
 8533 0418 01       		.byte	1
 8534 0419 00       		.byte	0
 8535 041a 00       		.byte	0
 8536 041b 00000000 		.space	5
 8536      00
 8537 0420 10       		.byte	16
 8538 0421 10       		.byte	16
 8539 0422 02       		.byte	2
 8540 0423 00       		.byte	0
 8541 0424 00       		.byte	0
 8542 0425 06       		.byte	6
 8543 0426 00       		.byte	0
 8544 0427 01       		.byte	1
 8545 0428 00       		.byte	0
 8546 0429 03       		.byte	3
 8547 042a 00       		.byte	0
 8548 042b 03       		.byte	3
 8549 042c 00       		.byte	0
 8550 042d 03       		.byte	3
 8551 042e 00       		.byte	0
 8552 042f 30       		.byte	48
 8553 0430 01       		.byte	1
 8554 0431 00       		.byte	0
 8555 0432 00       		.byte	0
 8556 0433 00000000 		.space	5
 8556      00
 8557 0438 00       		.byte	0
 8558 0439 00       		.byte	0
 8559 043a 02       		.byte	2
 8560 043b 00       		.byte	0
 8561 043c 00       		.byte	0
 8562 043d 03       		.byte	3
 8563 043e 00       		.byte	0
 8564 043f 01       		.byte	1
 8565 0440 00       		.byte	0
 8566 0441 03       		.byte	3
 8567 0442 00       		.byte	0
 8568 0443 00       		.byte	0
 8569 0444 00       		.byte	0
 8570 0445 00       		.byte	0
 8571 0446 00       		.byte	0
 8572 0447 30       		.byte	48
 8573 0448 01       		.byte	1
 8574 0449 00       		.byte	0
 8575 044a 00       		.byte	0
 8576 044b 00000000 		.space	5
 8576      00
 8577 0450 50       		.byte	80
 8578 0451 50       		.byte	80
 8579 0452 01       		.byte	1
 8580 0453 00       		.byte	0
 8581 0454 00       		.byte	0
 8582 0455 03       		.byte	3
 8583 0456 00       		.byte	0
 8584 0457 01       		.byte	1
 8585 0458 00       		.byte	0
 8586 0459 03       		.byte	3
 8587 045a 00       		.byte	0
 8588 045b 00       		.byte	0
 8589 045c 00       		.byte	0
 8590 045d 00       		.byte	0
 8591 045e 00       		.byte	0
 8592 045f 30       		.byte	48
 8593 0460 01       		.byte	1
 8594 0461 00       		.byte	0
 8595 0462 00       		.byte	0
 8596 0463 00000000 		.space	5
 8596      00
 8597 0468 00       		.byte	0
 8598 0469 00       		.byte	0
 8599 046a 0B       		.byte	11
 8600 046b 00       		.byte	0
 8601 046c 00       		.byte	0
 8602 046d FF       		.byte	-1
 8603 046e FF       		.byte	-1
 8604 046f 01       		.byte	1
 8605 0470 00       		.byte	0
 8606 0471 03       		.byte	3
 8607 0472 00       		.byte	0
 8608 0473 00       		.byte	0
 8609 0474 00       		.byte	0
 8610 0475 00       		.byte	0
 8611 0476 00       		.byte	0
 8612 0477 00       		.byte	0
 8613 0478 01       		.byte	1
 8614 0479 00       		.byte	0
 8615 047a 00       		.byte	0
 8616 047b 00000000 		.space	5
 8616      00
 8619              	glUVCHeader:
 8620 0480 0C       		.byte	12
 8621 0481 8C       		.byte	-116
 8622 0482 00       		.byte	0
 8623 0483 00       		.byte	0
 8624 0484 00       		.byte	0
 8625 0485 00       		.byte	0
 8626 0486 00       		.byte	0
 8627 0487 00       		.byte	0
 8628 0488 00       		.byte	0
 8629 0489 00       		.byte	0
 8630 048a 00       		.byte	0
 8631 048b 00       		.byte	0
 8634              	ROIMode:
 8635 048c 01       		.byte	1
 8636 048d 000000   		.space	3
 8639              	WBMenuCmpArry:
 8640 0490 20       		.byte	32
 8641 0491 0F       		.byte	15
 8642 0492 38       		.byte	56
 8643 0493 F0       		.byte	-16
 8646              	CTCtrlParArry:
 8647 0494 00       		.byte	0
 8648 0495 00       		.byte	0
 8649 0496 01       		.byte	1
 8650 0497 00       		.byte	0
 8651 0498 00       		.byte	0
 8652 0499 03       		.byte	3
 8653 049a 00       		.byte	0
 8654 049b 01       		.byte	1
 8655 049c 00       		.byte	0
 8656 049d 03       		.byte	3
 8657 049e 00       		.byte	0
 8658 049f 03       		.byte	3
 8659 04a0 00       		.byte	0
 8660 04a1 03       		.byte	3
 8661 04a2 00       		.byte	0
 8662 04a3 30       		.byte	48
 8663 04a4 01       		.byte	1
 8664 04a5 00       		.byte	0
 8665 04a6 00       		.byte	0
 8666 04a7 00000000 		.space	5
 8666      00
 8667 04ac 00       		.byte	0
 8668 04ad 00       		.byte	0
 8669 04ae 01       		.byte	1
 8670 04af 01       		.byte	1
 8671 04b0 00       		.byte	0
 8672 04b1 0F       		.byte	15
 8673 04b2 00       		.byte	0
 8674 04b3 0F       		.byte	15
 8675 04b4 00       		.byte	0
 8676 04b5 03       		.byte	3
 8677 04b6 00       		.byte	0
 8678 04b7 02       		.byte	2
 8679 04b8 00       		.byte	0
 8680 04b9 02       		.byte	2
 8681 04ba 00       		.byte	0
 8682 04bb 30       		.byte	48
 8683 04bc 01       		.byte	1
 8684 04bd 01       		.byte	1
 8685 04be 00       		.byte	0
 8686 04bf 00000000 		.space	5
 8686      00
 8687 04c4 02       		.byte	2
 8688 04c5 00       		.byte	0
 8689 04c6 01       		.byte	1
 8690 04c7 00       		.byte	0
 8691 04c8 00       		.byte	0
 8692 04c9 01       		.byte	1
 8693 04ca 00       		.byte	0
 8694 04cb 01       		.byte	1
 8695 04cc 00       		.byte	0
 8696 04cd 03       		.byte	3
 8697 04ce 00       		.byte	0
 8698 04cf 00       		.byte	0
 8699 04d0 00       		.byte	0
 8700 04d1 00       		.byte	0
 8701 04d2 00       		.byte	0
 8702 04d3 30       		.byte	48
 8703 04d4 01       		.byte	1
 8704 04d5 01       		.byte	1
 8705 04d6 00       		.byte	0
 8706 04d7 00000000 		.space	5
 8706      00
 8707 04dc 00       		.byte	0
 8708 04dd 00       		.byte	0
 8709 04de 04       		.byte	4
 8710 04df 01       		.byte	1
 8711 04e0 00       		.byte	0
 8712 04e1 38       		.byte	56
 8713 04e2 01       		.byte	1
 8714 04e3 01       		.byte	1
 8715 04e4 00       		.byte	0
 8716 04e5 03       		.byte	3
 8717 04e6 00       		.byte	0
 8718 04e7 4E       		.byte	78
 8719 04e8 00       		.byte	0
 8720 04e9 4E       		.byte	78
 8721 04ea 00       		.byte	0
 8722 04eb 30       		.byte	48
 8723 04ec 01       		.byte	1
 8724 04ed 00       		.byte	0
 8725 04ee 00       		.byte	0
 8726 04ef 00000000 		.space	5
 8726      00
 8727 04f4 04       		.byte	4
 8728 04f5 00       		.byte	0
 8729 04f6 01       		.byte	1
 8730 04f7 00       		.byte	0
 8731 04f8 00       		.byte	0
 8732 04f9 00       		.byte	0
 8733 04fa 00       		.byte	0
 8734 04fb 01       		.byte	1
 8735 04fc 00       		.byte	0
 8736 04fd 03       		.byte	3
 8737 04fe 00       		.byte	0
 8738 04ff 00       		.byte	0
 8739 0500 00       		.byte	0
 8740 0501 00       		.byte	0
 8741 0502 00       		.byte	0
 8742 0503 30       		.byte	48
 8743 0504 01       		.byte	1
 8744 0505 00       		.byte	0
 8745 0506 00       		.byte	0
 8746 0507 00000000 		.space	5
 8746      00
 8747 050c 05       		.byte	5
 8748 050d 00       		.byte	0
 8749 050e 02       		.byte	2
 8750 050f 00       		.byte	0
 8751 0510 00       		.byte	0
 8752 0511 FF       		.byte	-1
 8753 0512 00       		.byte	0
 8754 0513 01       		.byte	1
 8755 0514 00       		.byte	0
 8756 0515 03       		.byte	3
 8757 0516 00       		.byte	0
 8758 0517 01       		.byte	1
 8759 0518 00       		.byte	0
 8760 0519 00       		.byte	0
 8761 051a 00       		.byte	0
 8762 051b 30       		.byte	48
 8763 051c 01       		.byte	1
 8764 051d 01       		.byte	1
 8765 051e 00       		.byte	0
 8766 051f 00000000 		.space	5
 8766      00
 8767 0524 06       		.byte	6
 8768 0525 00       		.byte	0
 8769 0526 02       		.byte	2
 8770 0527 00       		.byte	0
 8771 0528 00       		.byte	0
 8772 0529 00       		.byte	0
 8773 052a 00       		.byte	0
 8774 052b 00       		.byte	0
 8775 052c 00       		.byte	0
 8776 052d 03       		.byte	3
 8777 052e 00       		.byte	0
 8778 052f 00       		.byte	0
 8779 0530 00       		.byte	0
 8780 0531 00       		.byte	0
 8781 0532 00       		.byte	0
 8782 0533 30       		.byte	48
 8783 0534 01       		.byte	1
 8784 0535 01       		.byte	1
 8785 0536 00       		.byte	0
 8786 0537 00000000 		.space	5
 8786      00
 8787 053c 23       		.byte	35
 8788 053d 00       		.byte	0
 8789 053e 02       		.byte	2
 8790 053f 00       		.byte	0
 8791 0540 00       		.byte	0
 8792 0541 30       		.byte	48
 8793 0542 00       		.byte	0
 8794 0543 01       		.byte	1
 8795 0544 00       		.byte	0
 8796 0545 03       		.byte	3
 8797 0546 0A       		.byte	10
 8798 0547 00       		.byte	0
 8799 0548 00       		.byte	0
 8800 0549 0A       		.byte	10
 8801 054a 00       		.byte	0
 8802 054b 30       		.byte	48
 8803 054c 01       		.byte	1
 8804 054d 01       		.byte	1
 8805 054e 00       		.byte	0
 8806 054f 00000000 		.space	5
 8806      00
 8807 0554 08       		.byte	8
 8808 0555 00       		.byte	0
 8809 0556 01       		.byte	1
 8810 0557 00       		.byte	0
 8811 0558 00       		.byte	0
 8812 0559 7F       		.byte	127
 8813 055a 00       		.byte	0
 8814 055b 01       		.byte	1
 8815 055c 00       		.byte	0
 8816 055d 03       		.byte	3
 8817 055e 00       		.byte	0
 8818 055f 00       		.byte	0
 8819 0560 00       		.byte	0
 8820 0561 00       		.byte	0
 8821 0562 00       		.byte	0
 8822 0563 30       		.byte	48
 8823 0564 01       		.byte	1
 8824 0565 00       		.byte	0
 8825 0566 00       		.byte	0
 8826 0567 00000000 		.space	5
 8826      00
 8827 056c 09       		.byte	9
 8828 056d 00       		.byte	0
 8829 056e 02       		.byte	2
 8830 056f 00       		.byte	0
 8831 0570 00       		.byte	0
 8832 0571 05       		.byte	5
 8833 0572 00       		.byte	0
 8834 0573 01       		.byte	1
 8835 0574 00       		.byte	0
 8836 0575 03       		.byte	3
 8837 0576 00       		.byte	0
 8838 0577 00       		.byte	0
 8839 0578 00       		.byte	0
 8840 0579 00       		.byte	0
 8841 057a 00       		.byte	0
 8842 057b 30       		.byte	48
 8843 057c 01       		.byte	1
 8844 057d 00       		.byte	0
 8845 057e 00       		.byte	0
 8846 057f 00000000 		.space	5
 8846      00
 8847 0584 10       		.byte	16
 8848 0585 00       		.byte	0
 8849 0586 03       		.byte	3
 8850 0587 00       		.byte	0
 8851 0588 00       		.byte	0
 8852 0589 00       		.byte	0
 8853 058a 00       		.byte	0
 8854 058b 00       		.byte	0
 8855 058c 00       		.byte	0
 8856 058d 03       		.byte	3
 8857 058e 00       		.byte	0
 8858 058f 00       		.byte	0
 8859 0590 00       		.byte	0
 8860 0591 00       		.byte	0
 8861 0592 00       		.byte	0
 8862 0593 30       		.byte	48
 8863 0594 01       		.byte	1
 8864 0595 00       		.byte	0
 8865 0596 00       		.byte	0
 8866 0597 00000000 		.space	5
 8866      00
 8867 059c 00       		.byte	0
 8868 059d 00       		.byte	0
 8869 059e 02       		.byte	2
 8870 059f 00       		.byte	0
 8871 05a0 00       		.byte	0
 8872 05a1 40       		.byte	64
 8873 05a2 00       		.byte	0
 8874 05a3 01       		.byte	1
 8875 05a4 00       		.byte	0
 8876 05a5 03       		.byte	3
 8877 05a6 00       		.byte	0
 8878 05a7 0F       		.byte	15
 8879 05a8 11       		.byte	17
 8880 05a9 00       		.byte	0
 8881 05aa 00       		.byte	0
 8882 05ab 30       		.byte	48
 8883 05ac 01       		.byte	1
 8884 05ad 00       		.byte	0
 8885 05ae 00       		.byte	0
 8886 05af 00000000 		.space	5
 8886      00
 8887 05b4 00       		.byte	0
 8888 05b5 00       		.byte	0
 8889 05b6 02       		.byte	2
 8890 05b7 00       		.byte	0
 8891 05b8 00       		.byte	0
 8892 05b9 64       		.byte	100
 8893 05ba 00       		.byte	0
 8894 05bb 01       		.byte	1
 8895 05bc 00       		.byte	0
 8896 05bd 03       		.byte	3
 8897 05be 00       		.byte	0
 8898 05bf 00       		.byte	0
 8899 05c0 00       		.byte	0
 8900 05c1 00       		.byte	0
 8901 05c2 00       		.byte	0
 8902 05c3 30       		.byte	48
 8903 05c4 01       		.byte	1
 8904 05c5 00       		.byte	0
 8905 05c6 00       		.byte	0
 8906 05c7 00000000 		.space	5
 8906      00
 8907 05cc 00       		.byte	0
 8908 05cd 00       		.byte	0
 8909 05ce 02       		.byte	2
 8910 05cf 00       		.byte	0
 8911 05d0 00       		.byte	0
 8912 05d1 64       		.byte	100
 8913 05d2 00       		.byte	0
 8914 05d3 01       		.byte	1
 8915 05d4 00       		.byte	0
 8916 05d5 03       		.byte	3
 8917 05d6 00       		.byte	0
 8918 05d7 00       		.byte	0
 8919 05d8 00       		.byte	0
 8920 05d9 00       		.byte	0
 8921 05da 00       		.byte	0
 8922 05db 30       		.byte	48
 8923 05dc 01       		.byte	1
 8924 05dd 00       		.byte	0
 8925 05de 00       		.byte	0
 8926 05df 00000000 		.space	5
 8926      00
 8927 05e4 00       		.byte	0
 8928 05e5 00       		.byte	0
 8929 05e6 02       		.byte	2
 8930 05e7 00       		.byte	0
 8931 05e8 00       		.byte	0
 8932 05e9 64       		.byte	100
 8933 05ea 00       		.byte	0
 8934 05eb 01       		.byte	1
 8935 05ec 00       		.byte	0
 8936 05ed 03       		.byte	3
 8937 05ee 00       		.byte	0
 8938 05ef 00       		.byte	0
 8939 05f0 00       		.byte	0
 8940 05f1 00       		.byte	0
 8941 05f2 00       		.byte	0
 8942 05f3 30       		.byte	48
 8943 05f4 01       		.byte	1
 8944 05f5 00       		.byte	0
 8945 05f6 00       		.byte	0
 8946 05f7 00000000 		.space	5
 8946      00
 8947 05fc 00       		.byte	0
 8948 05fd 00       		.byte	0
 8949 05fe 02       		.byte	2
 8950 05ff 00       		.byte	0
 8951 0600 00       		.byte	0
 8952 0601 64       		.byte	100
 8953 0602 00       		.byte	0
 8954 0603 01       		.byte	1
 8955 0604 00       		.byte	0
 8956 0605 03       		.byte	3
 8957 0606 00       		.byte	0
 8958 0607 00       		.byte	0
 8959 0608 00       		.byte	0
 8960 0609 00       		.byte	0
 8961 060a 00       		.byte	0
 8962 060b 30       		.byte	48
 8963 060c 01       		.byte	1
 8964 060d 00       		.byte	0
 8965 060e 00       		.byte	0
 8966 060f 00000000 		.space	5
 8966      00
 8969              	glProbeCtrlFull:
 8970 0614 00       		.byte	0
 8971 0615 00       		.byte	0
 8972 0616 01       		.byte	1
 8973 0617 01       		.byte	1
 8974 0618 15       		.byte	21
 8975 0619 16       		.byte	22
 8976 061a 05       		.byte	5
 8977 061b 00       		.byte	0
 8978 061c 00       		.byte	0
 8979 061d 00       		.byte	0
 8980 061e 00       		.byte	0
 8981 061f 00       		.byte	0
 8982 0620 00       		.byte	0
 8983 0621 00       		.byte	0
 8984 0622 00       		.byte	0
 8985 0623 00       		.byte	0
 8986 0624 00       		.byte	0
 8987 0625 00       		.byte	0
 8988 0626 00       		.byte	0
 8989 0627 C6       		.byte	-58
 8990 0628 99       		.byte	-103
 8991 0629 00       		.byte	0
 8992 062a 00       		.byte	0
 8993 062b 40       		.byte	64
 8994 062c 00       		.byte	0
 8995 062d 00       		.byte	0
 8996 062e 0000     		.space	2
 8999              	glProbeCtrl20:
 9000 0630 00       		.byte	0
 9001 0631 00       		.byte	0
 9002 0632 01       		.byte	1
 9003 0633 01       		.byte	1
 9004 0634 80       		.byte	-128
 9005 0635 1A       		.byte	26
 9006 0636 06       		.byte	6
 9007 0637 00       		.byte	0
 9008 0638 00       		.byte	0
 9009 0639 00       		.byte	0
 9010 063a 00       		.byte	0
 9011 063b 00       		.byte	0
 9012 063c 00       		.byte	0
 9013 063d 00       		.byte	0
 9014 063e 00       		.byte	0
 9015 063f 00       		.byte	0
 9016 0640 00       		.byte	0
 9017 0641 00       		.byte	0
 9018 0642 00       		.byte	0
 9019 0643 D2       		.byte	-46
 9020 0644 0F       		.byte	15
 9021 0645 00       		.byte	0
 9022 0646 00       		.byte	0
 9023 0647 40       		.byte	64
 9024 0648 00       		.byte	0
 9025 0649 00       		.byte	0
 9026 064a 0000     		.space	2
 9029              	glProbeCtrl:
 9030 064c 00       		.byte	0
 9031 064d 00       		.byte	0
 9032 064e 01       		.byte	1
 9033 064f 01       		.byte	1
 9034 0650 15       		.byte	21
 9035 0651 16       		.byte	22
 9036 0652 05       		.byte	5
 9037 0653 00       		.byte	0
 9038 0654 00       		.byte	0
 9039 0655 00       		.byte	0
 9040 0656 00       		.byte	0
 9041 0657 00       		.byte	0
 9042 0658 00       		.byte	0
 9043 0659 00       		.byte	0
 9044 065a 00       		.byte	0
 9045 065b 00       		.byte	0
 9046 065c 00       		.byte	0
 9047 065d 00       		.byte	0
 9048 065e 00       		.byte	0
 9049 065f 48       		.byte	72
 9050 0660 3F       		.byte	63
 9051 0661 00       		.byte	0
 9052 0662 00       		.byte	0
 9053 0663 40       		.byte	64
 9054 0664 00       		.byte	0
 9055 0665 00       		.byte	0
 9056 0666 0000     		.space	2
 9059              	glProbeStilCtrl:
 9060 0668 01       		.byte	1
 9061 0669 02       		.byte	2
 9062 066a 00       		.byte	0
 9063 066b 00       		.byte	0
 9064 066c C6       		.byte	-58
 9065 066d 99       		.byte	-103
 9066 066e 00       		.byte	0
 9067 066f 00       		.byte	0
 9068 0670 40       		.byte	64
 9069 0671 00       		.byte	0
 9070 0672 00       		.byte	0
 9071 0673 00       		.space	1
 9074              	glProbeStilCtrl20:
 9075 0674 01       		.byte	1
 9076 0675 01       		.byte	1
 9077 0676 00       		.byte	0
 9078 0677 00       		.byte	0
 9079 0678 D2       		.byte	-46
 9080 0679 0F       		.byte	15
 9081 067a 00       		.byte	0
 9082 067b 00       		.byte	0
 9083 067c 40       		.byte	64
 9084 067d 00       		.byte	0
 9085 067e 00       		.byte	0
 9088              	snapButFlag:
 9089 067f 01       		.byte	1
 9092              	CyFxGpifTransition:
 9093 0680 0000     		.short	0
 9094 0682 5555     		.short	21845
 9095 0684 8888     		.short	-30584
 9096 0686 AAAA     		.short	-21846
 9097 0688 3333     		.short	13107
 9098 068a 0000     		.space	2
 9101              	CyFxGpifWavedata:
 9102 068c 0181731E 		.word	510886145
 9103 0690 00000000 		.word	0
 9104 0694 00000080 		.word	-2147483648
 9105 0698 00000000 		.word	0
 9106 069c 00000000 		.word	0
 9107 06a0 00000000 		.word	0
 9108 06a4 0201702E 		.word	779092226
 9109 06a8 00010000 		.word	256
 9110 06ac A0000080 		.word	-2147483488
 9111 06b0 00000000 		.word	0
 9112 06b4 00000000 		.word	0
 9113 06b8 00000000 		.word	0
 9114 06bc 0380722E 		.word	779255811
 9115 06c0 02010020 		.word	536871170
 9116 06c4 60000080 		.word	-2147483552
 9117 06c8 00000000 		.word	0
 9118 06cc 00000000 		.word	0
 9119 06d0 00000000 		.word	0
 9120 06d4 0460722E 		.word	779247620
 9121 06d8 02010024 		.word	603980034
 9122 06dc 90000080 		.word	-2147483504
 9123 06e0 0594731E 		.word	510891013
 9124 06e4 06000000 		.word	6
 9125 06e8 00000080 		.word	-2147483648
 9126 06ec 0380722E 		.word	779255811
 9127 06f0 02010020 		.word	536871170
 9128 06f4 60000080 		.word	-2147483552
 9129 06f8 0693731E 		.word	510890758
 9130 06fc 06000000 		.word	6
 9131 0700 00000080 		.word	-2147483648
 9132 0704 0720703E 		.word	1047535623
 9133 0708 08010000 		.word	264
 9134 070c 00000080 		.word	-2147483648
 9135 0710 0820703E 		.word	1047535624
 9136 0714 08010000 		.word	264
 9137 0718 00000080 		.word	-2147483648
 9138 071c 0920703E 		.word	1047535625
 9139 0720 08010000 		.word	264
 9140 0724 00000080 		.word	-2147483648
 9141 0728 0A20703E 		.word	1047535626
 9142 072c 08010000 		.word	264
 9143 0730 00000080 		.word	-2147483648
 9144 0734 0380722E 		.word	779255811
 9145 0738 02010020 		.word	536871170
 9146 073c 60000080 		.word	-2147483552
 9147 0740 0B000000 		.word	11
 9148 0744 00000000 		.word	0
 9149 0748 00010080 		.word	-2147483392
 9150 074c 0460722E 		.word	779247620
 9151 0750 02010024 		.word	603980034
 9152 0754 90000080 		.word	-2147483504
 9153 0758 0D000000 		.word	13
 9154 075c 00000000 		.word	0
 9155 0760 00010080 		.word	-2147483392
 9156 0764 0460722E 		.word	779247620
 9157 0768 02010024 		.word	603980034
 9158 076c 90000080 		.word	-2147483504
 9159 0770 0C000000 		.word	12
 9160 0774 00000000 		.word	0
 9161 0778 00010080 		.word	-2147483392
 9162 077c 0380722E 		.word	779255811
 9163 0780 02010020 		.word	536871170
 9164 0784 60000080 		.word	-2147483552
 9165 0788 0E000000 		.word	14
 9166 078c 00000000 		.word	0
 9167 0790 00010080 		.word	-2147483392
 9168 0794 00000000 		.word	0
 9169 0798 00000000 		.word	0
 9170 079c 00000000 		.word	0
 9171 07a0 00000000 		.word	0
 9172 07a4 00000000 		.word	0
 9173 07a8 00000000 		.word	0
 9176              	CyFxGpifWavedataPosition:
 9177 07ac 00       		.byte	0
 9178 07ad 01       		.byte	1
 9179 07ae 02       		.byte	2
 9180 07af 03       		.byte	3
 9181 07b0 04       		.byte	4
 9182 07b1 05       		.byte	5
 9183 07b2 06       		.byte	6
 9184 07b3 07       		.byte	7
 9185 07b4 08       		.byte	8
 9186 07b5 09       		.byte	9
 9187 07b6 0A       		.byte	10
 9188 07b7 0B       		.byte	11
 9189 07b8 0B       		.byte	11
 9190 07b9 0B       		.byte	11
 9191 07ba 0B       		.byte	11
 9192 07bb 00       		.space	1
 9195              	CyFxGpifRegValue:
 9196 07bc 08830080 		.word	-2147450104
 9197 07c0 67000000 		.word	103
 9198 07c4 00000000 		.word	0
 9199 07c8 46000000 		.word	70
 9200 07cc 00000000 		.word	0
 9201 07d0 00000000 		.word	0
 9202 07d4 02000000 		.word	2
 9203 07d8 82000000 		.word	130
 9204 07dc 82070000 		.word	1922
 9205 07e0 40040000 		.word	1088
 9206 07e4 FCFF0000 		.word	65532
 9207 07e8 28000000 		.word	40
 9208 07ec 00000000 		.word	0
 9209 07f0 00000000 		.word	0
 9210 07f4 00000000 		.word	0
 9211 07f8 00000000 		.word	0
 9212 07fc 01000000 		.word	1
 9213 0800 00000000 		.word	0
 9214 0804 00000000 		.word	0
 9215 0808 00000000 		.word	0
 9216 080c 00000000 		.word	0
 9217 0810 00000000 		.word	0
 9218 0814 00000000 		.word	0
 9219 0818 00000000 		.word	0
 9220 081c 00000000 		.word	0
 9221 0820 00000000 		.word	0
 9222 0824 00000000 		.word	0
 9223 0828 00000000 		.word	0
 9224 082c 00000000 		.word	0
 9225 0830 06000000 		.word	6
 9226 0834 00000000 		.word	0
 9227 0838 FFFF0000 		.word	65535
 9228 083c 09010000 		.word	265
 9229 0840 00000000 		.word	0
 9230 0844 F71F0000 		.word	8183
 9231 0848 00000000 		.word	0
 9232 084c FFFF0000 		.word	65535
 9233 0850 09010000 		.word	265
 9234 0854 00000000 		.word	0
 9235 0858 F71F0000 		.word	8183
 9236 085c 00000000 		.word	0
 9237 0860 00000000 		.word	0
 9238 0864 00000000 		.word	0
 9239 0868 00000000 		.word	0
 9240 086c 00000000 		.word	0
 9241 0870 00000000 		.word	0
 9242 0874 00000000 		.word	0
 9243 0878 00000000 		.word	0
 9244 087c 00000000 		.word	0
 9245 0880 00000000 		.word	0
 9246 0884 00000000 		.word	0
 9247 0888 00000000 		.word	0
 9248 088c 00000000 		.word	0
 9249 0890 00000000 		.word	0
 9250 0894 00000000 		.word	0
 9251 0898 00000000 		.word	0
 9252 089c 00000000 		.word	0
 9253 08a0 00000000 		.word	0
 9254 08a4 00000000 		.word	0
 9255 08a8 00000000 		.word	0
 9256 08ac 00000000 		.word	0
 9257 08b0 00000000 		.word	0
 9258 08b4 00000000 		.word	0
 9259 08b8 00040180 		.word	-2147417088
 9260 08bc 01040180 		.word	-2147417087
 9261 08c0 02040180 		.word	-2147417086
 9262 08c4 03040180 		.word	-2147417085
 9263 08c8 00000000 		.word	0
 9264 08cc 00000000 		.word	0
 9265 08d0 00000000 		.word	0
 9266 08d4 00000000 		.word	0
 9267 08d8 00000000 		.word	0
 9268 08dc 00000000 		.word	0
 9269 08e0 00000000 		.word	0
 9270 08e4 00000000 		.word	0
 9271 08e8 C1FFFFFF 		.word	-63
 9274              	CyFxGpifTransition_usb2:
 9275 08ec 0000     		.short	0
 9276 08ee 5555     		.short	21845
 9277 08f0 AAAA     		.short	-21846
 9278 08f2 8888     		.short	-30584
 9279 08f4 1111     		.short	4369
 9280 08f6 4444     		.short	17476
 9281 08f8 3333     		.short	13107
 9282 08fa CCCC     		.short	-13108
 9285              	CyFxGpifWavedata_usb2:
 9286 08fc 0181731E 		.word	510886145
 9287 0900 00000000 		.word	0
 9288 0904 00000080 		.word	-2147483648
 9289 0908 00000000 		.word	0
 9290 090c 00000000 		.word	0
 9291 0910 00000000 		.word	0
 9292 0914 0201703E 		.word	1047527682
 9293 0918 00010000 		.word	256
 9294 091c A00000C0 		.word	-1073741664
 9295 0920 00000000 		.word	0
 9296 0924 00000000 		.word	0
 9297 0928 00000000 		.word	0
 9298 092c 0394731E 		.word	510891011
 9299 0930 04000020 		.word	536870916
 9300 0934 60004080 		.word	-2143289248
 9301 0938 00000000 		.word	0
 9302 093c 00000000 		.word	0
 9303 0940 00000000 		.word	0
 9304 0944 0620702E 		.word	779100166
 9305 0948 0C000000 		.word	12
 9306 094c 00000080 		.word	-2147483648
 9307 0950 0620702E 		.word	779100166
 9308 0954 0C000000 		.word	12
 9309 0958 00000080 		.word	-2147483648
 9310 095c 0394731E 		.word	510891011
 9311 0960 04000020 		.word	536870916
 9312 0964 60004080 		.word	-2143289248
 9313 0968 0620702E 		.word	779100166
 9314 096c 0C000000 		.word	12
 9315 0970 00000080 		.word	-2147483648
 9316 0974 0C93731E 		.word	510890764
 9317 0978 04000024 		.word	603979780
 9318 097c 90004080 		.word	-2143289200
 9319 0980 0D20702E 		.word	779100173
 9320 0984 0C000000 		.word	12
 9321 0988 00000080 		.word	-2147483648
 9322 098c 0780724E 		.word	1316126727
 9323 0990 0A000000 		.word	10
 9324 0994 00000080 		.word	-2147483648
 9325 0998 08000000 		.word	8
 9326 099c 00000000 		.word	0
 9327 09a0 00010080 		.word	-2147483392
 9328 09a4 0920702E 		.word	779100169
 9329 09a8 0C010000 		.word	268
 9330 09ac 00000080 		.word	-2147483648
 9331 09b0 0A01701E 		.word	510656778
 9332 09b4 0E000100 		.word	65550
 9333 09b8 00000080 		.word	-2147483648
 9334 09bc 00000000 		.word	0
 9335 09c0 00000000 		.word	0
 9336 09c4 00000000 		.word	0
 9337 09c8 00000000 		.word	0
 9338 09cc 00000000 		.word	0
 9339 09d0 00000000 		.word	0
 9340 09d4 0394731E 		.word	510891011
 9341 09d8 04000020 		.word	536870916
 9342 09dc 60004080 		.word	-2143289248
 9343 09e0 08000000 		.word	8
 9344 09e4 00000000 		.word	0
 9345 09e8 00010080 		.word	-2147483392
 9346 09ec 0B000000 		.word	11
 9347 09f0 00000000 		.word	0
 9348 09f4 00010080 		.word	-2147483392
 9349 09f8 0C93731E 		.word	510890764
 9350 09fc 04000024 		.word	603979780
 9351 0a00 90004080 		.word	-2143289200
 9352 0a04 0D20702E 		.word	779100173
 9353 0a08 0C000000 		.word	12
 9354 0a0c 00000080 		.word	-2147483648
 9355 0a10 0D20702E 		.word	779100173
 9356 0a14 0C000000 		.word	12
 9357 0a18 00000080 		.word	-2147483648
 9358 0a1c 0E60724E 		.word	1316118542
 9359 0a20 0A000000 		.word	10
 9360 0a24 00000080 		.word	-2147483648
 9361 0a28 0F000000 		.word	15
 9362 0a2c 00000000 		.word	0
 9363 0a30 00010080 		.word	-2147483392
 9364 0a34 1020702E 		.word	779100176
 9365 0a38 0C010000 		.word	268
 9366 0a3c 00000080 		.word	-2147483648
 9367 0a40 1101701E 		.word	510656785
 9368 0a44 0E000100 		.word	65550
 9369 0a48 00000080 		.word	-2147483648
 9370 0a4c 0C93731E 		.word	510890764
 9371 0a50 04000024 		.word	603979780
 9372 0a54 90004080 		.word	-2143289200
 9373 0a58 0F000000 		.word	15
 9374 0a5c 00000000 		.word	0
 9375 0a60 00010080 		.word	-2147483392
 9376 0a64 12000000 		.word	18
 9377 0a68 00000000 		.word	0
 9378 0a6c 00010080 		.word	-2147483392
 9379 0a70 0394731E 		.word	510891011
 9380 0a74 04000020 		.word	536870916
 9381 0a78 60004080 		.word	-2143289248
 9382 0a7c 0480732E 		.word	779321348
 9383 0a80 02010000 		.word	258
 9384 0a84 0000C0C0 		.word	-1061158912
 9385 0a88 0580732E 		.word	779321349
 9386 0a8c 02010000 		.word	258
 9387 0a90 0000C0C0 		.word	-1061158912
 9388 0a94 0580732E 		.word	779321349
 9389 0a98 02010000 		.word	258
 9390 0a9c 0000C0C0 		.word	-1061158912
 9391 0aa0 0480732E 		.word	779321348
 9392 0aa4 02010000 		.word	258
 9393 0aa8 0000C0C0 		.word	-1061158912
 9396              	CyFxGpifWavedataPosition_usb2:
 9397 0aac 00       		.byte	0
 9398 0aad 01       		.byte	1
 9399 0aae 02       		.byte	2
 9400 0aaf 03       		.byte	3
 9401 0ab0 04       		.byte	4
 9402 0ab1 05       		.byte	5
 9403 0ab2 06       		.byte	6
 9404 0ab3 07       		.byte	7
 9405 0ab4 08       		.byte	8
 9406 0ab5 09       		.byte	9
 9407 0ab6 0A       		.byte	10
 9408 0ab7 08       		.byte	8
 9409 0ab8 0B       		.byte	11
 9410 0ab9 0C       		.byte	12
 9411 0aba 0D       		.byte	13
 9412 0abb 08       		.byte	8
 9413 0abc 0E       		.byte	14
 9414 0abd 0F       		.byte	15
 9415 0abe 08       		.byte	8
 9416 0abf 08       		.byte	8
 9417 0ac0 08       		.byte	8
 9418 0ac1 08       		.byte	8
 9419 0ac2 08       		.byte	8
 9420 0ac3 08       		.byte	8
 9421 0ac4 08       		.byte	8
 9422 0ac5 08       		.byte	8
 9423 0ac6 08       		.byte	8
 9424 0ac7 08       		.byte	8
 9425 0ac8 08       		.byte	8
 9426 0ac9 08       		.byte	8
 9427 0aca 08       		.byte	8
 9428 0acb 08       		.byte	8
 9429 0acc 08       		.byte	8
 9430 0acd 08       		.byte	8
 9431 0ace 08       		.byte	8
 9432 0acf 08       		.byte	8
 9433 0ad0 08       		.byte	8
 9434 0ad1 08       		.byte	8
 9435 0ad2 08       		.byte	8
 9436 0ad3 08       		.byte	8
 9437 0ad4 08       		.byte	8
 9438 0ad5 08       		.byte	8
 9439 0ad6 08       		.byte	8
 9440 0ad7 08       		.byte	8
 9441 0ad8 08       		.byte	8
 9442 0ad9 08       		.byte	8
 9443 0ada 08       		.byte	8
 9444 0adb 08       		.byte	8
 9445 0adc 08       		.byte	8
 9446 0add 08       		.byte	8
 9447 0ade 08       		.byte	8
 9448 0adf 08       		.byte	8
 9449 0ae0 08       		.byte	8
 9450 0ae1 08       		.byte	8
 9451 0ae2 08       		.byte	8
 9452 0ae3 08       		.byte	8
 9453 0ae4 08       		.byte	8
 9454 0ae5 08       		.byte	8
 9455 0ae6 08       		.byte	8
 9456 0ae7 08       		.byte	8
 9457 0ae8 08       		.byte	8
 9458 0ae9 08       		.byte	8
 9459 0aea 08       		.byte	8
 9460 0aeb 08       		.byte	8
 9461 0aec 08       		.byte	8
 9462 0aed 08       		.byte	8
 9463 0aee 08       		.byte	8
 9464 0aef 08       		.byte	8
 9465 0af0 08       		.byte	8
 9466 0af1 08       		.byte	8
 9467 0af2 08       		.byte	8
 9468 0af3 08       		.byte	8
 9469 0af4 08       		.byte	8
 9470 0af5 08       		.byte	8
 9471 0af6 08       		.byte	8
 9472 0af7 08       		.byte	8
 9473 0af8 08       		.byte	8
 9474 0af9 08       		.byte	8
 9475 0afa 08       		.byte	8
 9476 0afb 08       		.byte	8
 9477 0afc 08       		.byte	8
 9478 0afd 08       		.byte	8
 9479 0afe 08       		.byte	8
 9480 0aff 08       		.byte	8
 9481 0b00 08       		.byte	8
 9482 0b01 08       		.byte	8
 9483 0b02 08       		.byte	8
 9484 0b03 08       		.byte	8
 9485 0b04 08       		.byte	8
 9486 0b05 08       		.byte	8
 9487 0b06 08       		.byte	8
 9488 0b07 08       		.byte	8
 9489 0b08 08       		.byte	8
 9490 0b09 08       		.byte	8
 9491 0b0a 08       		.byte	8
 9492 0b0b 08       		.byte	8
 9493 0b0c 08       		.byte	8
 9494 0b0d 08       		.byte	8
 9495 0b0e 08       		.byte	8
 9496 0b0f 08       		.byte	8
 9497 0b10 08       		.byte	8
 9498 0b11 08       		.byte	8
 9499 0b12 08       		.byte	8
 9500 0b13 08       		.byte	8
 9501 0b14 08       		.byte	8
 9502 0b15 08       		.byte	8
 9503 0b16 08       		.byte	8
 9504 0b17 08       		.byte	8
 9505 0b18 08       		.byte	8
 9506 0b19 08       		.byte	8
 9507 0b1a 08       		.byte	8
 9508 0b1b 08       		.byte	8
 9509 0b1c 08       		.byte	8
 9510 0b1d 08       		.byte	8
 9511 0b1e 08       		.byte	8
 9512 0b1f 08       		.byte	8
 9513 0b20 08       		.byte	8
 9514 0b21 08       		.byte	8
 9515 0b22 08       		.byte	8
 9516 0b23 08       		.byte	8
 9517 0b24 08       		.byte	8
 9518 0b25 08       		.byte	8
 9519 0b26 08       		.byte	8
 9520 0b27 08       		.byte	8
 9521 0b28 08       		.byte	8
 9522 0b29 08       		.byte	8
 9523 0b2a 08       		.byte	8
 9524 0b2b 08       		.byte	8
 9525 0b2c 00       		.byte	0
 9526 0b2d 01       		.byte	1
 9527 0b2e 02       		.byte	2
 9528 0b2f 10       		.byte	16
 9529 0b30 04       		.byte	4
 9530 0b31 05       		.byte	5
 9531 0b32 06       		.byte	6
 9532 0b33 07       		.byte	7
 9533 0b34 08       		.byte	8
 9534 0b35 09       		.byte	9
 9535 0b36 0A       		.byte	10
 9536 0b37 08       		.byte	8
 9537 0b38 11       		.byte	17
 9538 0b39 0C       		.byte	12
 9539 0b3a 0D       		.byte	13
 9540 0b3b 08       		.byte	8
 9541 0b3c 0E       		.byte	14
 9542 0b3d 0F       		.byte	15
 9543 0b3e 08       		.byte	8
 9544 0b3f 00       		.space	1
 9547              	CyFxGpifRegValue_usb2:
 9548 0b40 08830080 		.word	-2147450104
 9549 0b44 67000000 		.word	103
 9550 0b48 01000000 		.word	1
 9551 0b4c 46000000 		.word	70
 9552 0b50 00000000 		.word	0
 9553 0b54 00000000 		.word	0
 9554 0b58 02000000 		.word	2
 9555 0b5c 82000000 		.word	130
 9556 0b60 82070000 		.word	1922
 9557 0b64 40040000 		.word	1088
 9558 0b68 FCFF0000 		.word	65532
 9559 0b6c 28000000 		.word	40
 9560 0b70 00000000 		.word	0
 9561 0b74 00000000 		.word	0
 9562 0b78 00000000 		.word	0
 9563 0b7c 00000000 		.word	0
 9564 0b80 01000000 		.word	1
 9565 0b84 00000000 		.word	0
 9566 0b88 00000000 		.word	0
 9567 0b8c 00000000 		.word	0
 9568 0b90 00000000 		.word	0
 9569 0b94 00000000 		.word	0
 9570 0b98 00000000 		.word	0
 9571 0b9c 00000000 		.word	0
 9572 0ba0 00000000 		.word	0
 9573 0ba4 00000000 		.word	0
 9574 0ba8 00000000 		.word	0
 9575 0bac 00000000 		.word	0
 9576 0bb0 00000000 		.word	0
 9577 0bb4 06000000 		.word	6
 9578 0bb8 00000000 		.word	0
 9579 0bbc FFFF0000 		.word	65535
 9580 0bc0 09010000 		.word	265
 9581 0bc4 00000000 		.word	0
 9582 0bc8 F71F0000 		.word	8183
 9583 0bcc 00000000 		.word	0
 9584 0bd0 FFFF0000 		.word	65535
 9585 0bd4 09010000 		.word	265
 9586 0bd8 00000000 		.word	0
 9587 0bdc F71F0000 		.word	8183
 9588 0be0 00000000 		.word	0
 9589 0be4 00000000 		.word	0
 9590 0be8 00000000 		.word	0
 9591 0bec 00000000 		.word	0
 9592 0bf0 00000000 		.word	0
 9593 0bf4 00000000 		.word	0
 9594 0bf8 00000000 		.word	0
 9595 0bfc 00000000 		.word	0
 9596 0c00 00000000 		.word	0
 9597 0c04 00000000 		.word	0
 9598 0c08 00000000 		.word	0
 9599 0c0c 00000000 		.word	0
 9600 0c10 00000000 		.word	0
 9601 0c14 00000000 		.word	0
 9602 0c18 00000000 		.word	0
 9603 0c1c 00000000 		.word	0
 9604 0c20 00000000 		.word	0
 9605 0c24 00000000 		.word	0
 9606 0c28 00000000 		.word	0
 9607 0c2c 00000000 		.word	0
 9608 0c30 00000000 		.word	0
 9609 0c34 00000000 		.word	0
 9610 0c38 00000000 		.word	0
 9611 0c3c 00040180 		.word	-2147417088
 9612 0c40 01040180 		.word	-2147417087
 9613 0c44 02040180 		.word	-2147417086
 9614 0c48 03040180 		.word	-2147417085
 9615 0c4c 00000000 		.word	0
 9616 0c50 00000000 		.word	0
 9617 0c54 00000000 		.word	0
 9618 0c58 00000000 		.word	0
 9619 0c5c 00000000 		.word	0
 9620 0c60 00000000 		.word	0
 9621 0c64 00000000 		.word	0
 9622 0c68 00000000 		.word	0
 9623 0c6c C1FFFFFF 		.word	-63
 9624              		.section	.rodata.str1.4,"aMS",%progbits,1
 9625              		.align	2
 9626              	.LC0:
 9627 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9627      7065722D 
 9627      74696D65 
 9627      72202564 
 9627      0D0A00
 9628 0013 00       		.space	1
 9629              	.LC1:
 9630 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9630      636F6D6D 
 9630      616E6420 
 9630      71756575 
 9630      65206973 
 9631 0037 00       		.space	1
 9632              	.LC2:
 9633 0038 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9633      5420656E 
 9633      636F756E 
 9633      74657265 
 9633      642E2E2E 
 9634              	.LC3:
 9635 0058 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9635      454E4420 
 9635      656E636F 
 9635      756E7465 
 9635      7265642E 
 9636 007a 0000     		.space	2
 9637              	.LC4:
 9638 007c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9638      64697363 
 9638      6F6E6E65 
 9638      63746564 
 9638      2E2E2E30 
 9639 009b 00       		.space	1
 9640              	.LC5:
 9641 009c 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 9641      7220696E 
 9641      206D756C 
 9641      74696368 
 9641      616E6E65 
 9642 00cf 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 9642      2025782C 
 9642      20646D61 
 9642      446F6E65 
 9642      20256420 
 9643              	.LC6:
 9644 00e8 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9644      43595F46 
 9644      585F5556 
 9644      435F5649 
 9644      44454F5F 
 9645 011b 0A00     		.ascii	"\012\000"
 9646 011d 000000   		.space	3
 9647              	.LC7:
 9648 0120 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9648      43595F46 
 9648      585F5556 
 9648      435F5649 
 9648      44454F5F 
 9649 0153 00       		.ascii	"\000"
 9650              	.LC8:
 9651 0154 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9651      726E6174 
 9651      65207365 
 9651      7474696E 
 9651      6720302E 
 9652              	.LC9:
 9653 016c 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9653      72206665 
 9653      61747572 
 9653      65207265 
 9653      71756573 
 9654 018f 00       		.space	1
 9655              	.LC10:
 9656 0190 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9656      6F6D6D69 
 9656      74656F66 
 9656      20737461 
 9656      7465203D 
 9657              	.LC11:
 9658 01a8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9658      6E656C20 
 9658      53657420 
 9658      57726170 
 9658      55702066 
 9659 01d5 000000   		.space	3
 9660              	.LC12:
 9661 01d8 4572726F 		.ascii	"Error handler...\015\012\000"
 9661      72206861 
 9661      6E646C65 
 9661      722E2E2E 
 9661      0D0A00
 9662 01eb 00       		.space	1
 9663              	.LC13:
 9664 01ec 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 9664      69742045 
 9664      4F462066 
 9664      61696C65 
 9664      64210D0A 
 9665 0201 000000   		.space	3
 9666              	.LC14:
 9667 0204 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9667      49324320 
 9667      636F6D6D 
 9667      616E6420 
 9667      69732030 
 9668 0237 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9668      78257820 
 9668      30782578 
 9668      20307825 
 9668      78203078 
 9669              	.LC15:
 9670 0250 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 9670      49324320 
 9670      636F6D6D 
 9670      616E6420 
 9670      73657474 
 9671 0276 0000     		.space	2
 9672              	.LC16:
 9673 0278 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9673      206C6967 
 9673      68742063 
 9673      6F6D7065 
 9673      6E736174 
 9674 02ab 25640D0A 		.ascii	"%d\015\012\000"
 9674      00
 9675              	.LC17:
 9676 02b0 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9676      49324320 
 9676      63757272 
 9676      656E7420 
 9676      64617461 
 9677 02e3 64202564 		.ascii	"d %d\015\012\000"
 9677      0D0A00
 9678 02ea 0000     		.space	2
 9679              	.LC18:
 9680 02ec 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9680      26414743 
 9680      2073656E 
 9680      7420746F 
 9680      20686F73 
 9681 0312 0000     		.space	2
 9682              	.LC19:
 9683 0314 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9683      26414743 
 9683      20676F74 
 9683      74656E20 
 9683      66726F6D 
 9684 033e 0000     		.space	2
 9685              	.LC20:
 9686 0340 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9686      67657420 
 9686      64617461 
 9686      2066726F 
 9686      6D20686F 
 9687 036d 000000   		.space	3
 9688              	.LC21:
 9689 0370 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9689      52657175 
 9689      65737420 
 9689      30782578 
 9689      20706172 
 9690 03a3 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9690      6E642074 
 9690      6F20686F 
 9690      73742030 
 9690      78257820 
 9691 03be 0000     		.space	2
 9692              	.LC22:
 9693 03c0 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9693      204F7020 
 9693      72656365 
 9693      69766573 
 9693      20284354 
 9694 03e7 00       		.space	1
 9695              	.LC23:
 9696 03e8 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9696      756C7420 
 9696      73656C65 
 9696      63746F72 
 9696      20284354 
 9697 040a 0000     		.space	2
 9698              	.LC24:
 9699 040c 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9699      756C7420 
 9699      72657175 
 9699      65737420 
 9699      28435429 
 9700 042d 000000   		.space	3
 9701              	.LC25:
 9702 0430 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9702      52657175 
 9702      65737420 
 9702      30782578 
 9702      20706172 
 9703 0463 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9703      20307825 
 9703      78202F20 
 9703      73656E64 
 9703      20746F20 
 9704 0490 00       		.ascii	"\000"
 9705 0491 000000   		.space	3
 9706              	.LC26:
 9707 0494 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9707      73706565 
 9707      64203D20 
 9707      25642065 
 9707      76656E66 
 9708 04c4 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9708      71756573 
 9708      74203D20 
 9708      30782578 
 9708      20775661 
 9709 04f4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9709      203D2030 
 9709      78257820 
 9709      6973666C 
 9709      61672030 
 9710 050e 0000     		.space	2
 9711              	.LC27:
 9712 0510 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9712      64656661 
 9712      756C7420 
 9712      73657475 
 9712      70207265 
 9713              	.LC28:
 9714 053c 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 9714      6F207374 
 9714      7265616D 
 9714      20474554 
 9714      20726571 
 9715 0561 000000   		.space	3
 9716              	.LC29:
 9717 0564 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9717      43595F46 
 9717      585F5556 
 9717      435F5354 
 9717      5245414D 
 9718 058a 0000     		.space	2
 9719              	.LC30:
 9720 058c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9720      7374696C 
 9720      6C207472 
 9720      69676765 
 9720      7220636F 
 9721 05b3 00       		.space	1
 9722              	.LC31:
 9723 05b4 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9723      65642074 
 9723      6F207365 
 9723      6E642069 
 9723      6E746572 
 9724 05e5 0A00     		.ascii	"\012\000"
 9725 05e7 00       		.space	1
 9726              	.LC32:
 9727 05e8 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9727      73657420 
 9727      64656620 
 9727      64617461 
 9727      20307825 
 9728 0607 00       		.space	1
 9729              	.LC33:
 9730 0608 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9730      73657420 
 9730      64656620 
 9730      64617461 
 9730      20307825 
 9731 063b 2E0D0A00 		.ascii	".\015\012\000"
 9732 063f 00       		.space	1
 9733              	.LC34:
 9734 0640 55415254 		.ascii	"UART initialization failed!\012\000"
 9734      20696E69 
 9734      7469616C 
 9734      697A6174 
 9734      696F6E20 
 9735 065d 000000   		.space	3
 9736              	.LC35:
 9737 0660 49324320 		.ascii	"I2C initialization failed!\012\000"
 9737      696E6974 
 9737      69616C69 
 9737      7A617469 
 9737      6F6E2066 
 9738              	.LC36:
 9739 067c 49324320 		.ascii	"I2C configuration failed!\012\000"
 9739      636F6E66 
 9739      69677572 
 9739      6174696F 
 9739      6E206661 
 9740 0697 00       		.space	1
 9741              	.LC37:
 9742 0698 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9742      43726561 
 9742      74652045 
 9742      76656E74 
 9742      20666169 
 9743 06c2 0000     		.space	2
 9744              	.LC38:
 9745 06c4 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9745      20496E69 
 9745      74206661 
 9745      696C6564 
 9745      2C204572 
 9746 06e7 00       		.space	1
 9747              	.LC39:
 9748 06e8 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9748      204F7665 
 9748      72726964 
 9748      65206661 
 9748      696C6564 
 9749 070f 00       		.space	1
 9750              	.LC40:
 9751 0710 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9751      28323029 
 9751      204F7665 
 9751      72726964 
 9751      65206661 
 9752 073b 00       		.space	1
 9753              	.LC41:
 9754 073c 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9754      28323429 
 9754      204F7665 
 9754      72726964 
 9754      65206661 
 9755 0767 00       		.space	1
 9756              	.LC42:
 9757 0768 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9757      20536574 
 9757      20287265 
 9757      73657420 
 9757      32322920 
 9758 079a 00       		.ascii	"\000"
 9759 079b 00       		.space	1
 9760              	.LC43:
 9761 079c 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9761      20536574 
 9761      2028706F 
 9761      77657220 
 9761      32302920 
 9762 07ce 00       		.ascii	"\000"
 9763 07cf 00       		.space	1
 9764              	.LC44:
 9765 07d0 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9765      20536574 
 9765      2028736E 
 9765      61702073 
 9765      686F7420 
 9766 0803 25640A00 		.ascii	"%d\012\000"
 9767 0807 00       		.space	1
 9768              	.LC45:
 9769 0808 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9769      46756E63 
 9769      74696F6E 
 9769      20466169 
 9769      6C656420 
 9770 0837 00       		.space	1
 9771              	.LC46:
 9772 0838 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9772      46756E63 
 9772      74696F6E 
 9772      20466169 
 9772      6C656420 
 9773 0867 00       		.space	1
 9774              	.LC47:
 9775 0868 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9775      53657420 
 9775      456E6470 
 9775      6F696E74 
 9775      20636F6E 
 9776 0898 00       		.ascii	"\000"
 9777 0899 000000   		.space	3
 9778              	.LC48:
 9779 089c 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9779      496E7465 
 9779      72727570 
 9779      74205374 
 9779      61747573 
 9780 08cf 20436F64 		.ascii	" Code = %d\012\000"
 9780      65203D20 
 9780      25640A00 
 9781 08db 00       		.space	1
 9782              	.LC49:
 9783 08dc 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9783      65642074 
 9783      6F20616C 
 9783      6C6F6361 
 9783      7465206D 
 9784 090f 65720D0A 		.ascii	"er\015\012\000"
 9784      00
 9785              	.LC50:
 9786 0914 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9786      4368616E 
 9786      6E656C20 
 9786      43726561 
 9786      74696F6E 
 9787 0942 0000     		.space	2
 9788              	.LC51:
 9789 0944 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9789      436F6E6E 
 9789      65637420 
 9789      6661696C 
 9789      65642C20 
 9790 0969 000000   		.space	3
 9791              	.LC52:
 9792 096c 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9792      4368616E 
 9792      6E656C20 
 9792      52657365 
 9792      74204661 
 9793 0997 00       		.space	1
 9794              	.LC53:
 9795 0998 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9795      4368616E 
 9795      6E656C20 
 9795      53657420 
 9795      5472616E 
 9796 09c9 00       		.ascii	"\000"
 9797 09ca 0000     		.space	2
 9798              	.LC54:
 9799 09cc 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9799      4368616E 
 9799      6E656C20 
 9799      53657420 
 9799      5472616E 
 9800 09fd 0A00     		.ascii	"\012\000"
 9801 09ff 00       		.space	1
 9802              	.LC55:
 9803 0a00 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9803      75706572 
 9803      20677069 
 9803      6600
 9804 0a0e 0000     		.space	2
 9805              	.LC56:
 9806 0a10 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9806      69676820 
 9806      67706966 
 9806      00
 9807 0a1d 000000   		.space	3
 9808              	.LC57:
 9809 0a20 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9809      696E6720 
 9809      47504946 
 9809      20436F6E 
 9809      66696775 
 9810 0a53 0A00     		.ascii	"\012\000"
 9811 0a55 000000   		.space	3
 9812              	.LC58:
 9813 0a58 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9813      74696E67 
 9813      20475049 
 9813      46207374 
 9813      61746520 
 9814 0a8b 0D0A00   		.ascii	"\015\012\000"
 9815 0a8e 0000     		.space	2
 9816              	.LC59:
 9817 0a90 33303A55 		.ascii	"30:UVC App Thread\000"
 9817      56432041 
 9817      70702054 
 9817      68726561 
 9817      6400
 9818 0aa2 0000     		.space	2
 9819              	.LC60:
 9820 0aa4 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9820      56432041 
 9820      70702045 
 9820      50302054 
 9820      68726561 
 9821 0aba 0000     		.space	2
 9822              	.LC61:
 9823 0abc 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9823      32432041 
 9823      70702043 
 9823      54524C20 
 9823      54687265 
 9824 0ad3 00       		.bss
 9825              		.align	2
 9826              		.set	.LANCHOR0,. + 0
 9829              	glFxUVCEvent:
 9830 0000 00000000 		.space	40
 9830      00000000 
 9830      00000000 
 9830      00000000 
 9830      00000000 
 9833              	gpif_initialized:
 9834 0028 00000000 		.space	4
 9837              	streamingStarted:
 9838 002c 00000000 		.space	4
 9841              	isUsbConnected:
 9842 0030 00000000 		.space	4
 9845              	fb:
 9846 0034 0000     		.space	2
 9849              	pb:
 9850 0036 0000     		.space	2
 9853              	pbc:
 9854 0038 0000     		.space	2
 9857              	stiflag:
 9858 003a 00       		.space	1
 9859 003b 00       		.space	1
 9862              	hitFV:
 9863 003c 00000000 		.space	4
 9866              	prodCount:
 9867 0040 0000     		.space	2
 9870              	consCount:
 9871 0042 0000     		.space	2
 9874              	clearFeatureRqtReceived:
 9875 0044 00000000 		.space	4
 9878              	usbSpeed:
 9879 0048 00       		.space	1
 9880 0049 000000   		.space	3
 9883              	I2CCMDArry:
 9884 004c 00000000 		.space	12
 9884      00000000 
 9884      00000000 
 9887              	is60Hz:
 9888 0058 00000000 		.space	4
 9891              	glEp0Buffer:
 9892 005c 00000000 		.space	32
 9892      00000000 
 9892      00000000 
 9892      00000000 
 9892      00000000 
 9895              	CamMode:
 9896 007c 00       		.space	1
 9899              	setRes:
 9900 007d 00       		.space	1
 9901 007e 0000     		.space	2
 9904              	glCommitCtrl:
 9905 0080 00000000 		.space	32
 9905      00000000 
 9905      00000000 
 9905      00000000 
 9905      00000000 
 9908              	IMcount.7788:
 9909 00a0 00       		.space	1
 9910 00a1 000000   		.space	3
 9913              	uvcAppThread:
 9914 00a4 00000000 		.space	168
 9914      00000000 
 9914      00000000 
 9914      00000000 
 9914      00000000 
 9917              	uvcAppEP0Thread:
 9918 014c 00000000 		.space	168
 9918      00000000 
 9918      00000000 
 9918      00000000 
 9918      00000000 
 9921              	i2cAppThread:
 9922 01f4 00000000 		.space	168
 9922      00000000 
 9922      00000000 
 9922      00000000 
 9922      00000000 
 9925              	testSnap:
 9926 029c 00       		.space	1
 9927 029d 00       		.space	1
 9930              	fbbak:
 9931 029e 0000     		.space	2
 9934              	pbbak:
 9935 02a0 0000     		.space	2
 9938              	pbcbak:
 9939 02a2 0000     		.space	2
 9942              	pbcpbak:
 9943 02a4 0000     		.space	2
 9944 02a6 0000     		.text
 9945              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:330    .text:00000250 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:509    .text:000003b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:518    .text:000003c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:521    .text:000003c0 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:743    .text:00000560 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:753    .text:0000057c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:755    .text:0000057c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1080   .text:00000844 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1096   .text:00000870 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1099   .text:00000870 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1136   .text:000008a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1149   .text:000008d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1196   .text:00000928 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1203   .text:00000938 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1221   .text:00000954 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1230   .text:0000096c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1233   .text:0000096c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1437   .text:00000b74 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1445   .text:00000b88 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1448   .text:00000b88 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1511   .text:00000c08 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1718   .text:00000da4 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1756   .text:00000e30 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1820   .text:00000eb4 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:1856   .text:00000f3c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3124   .text:00001b10 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3142   .text:00001b4c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3145   .text:00001b4c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3313   .text:00001ca8 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3326   .text:00001cd0 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3821   .text:000021e0 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:3832   .text:00002200 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:4087   .text:000024b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:4100   .text:000024e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:4103   .text:000024e0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:4165   .text:0000255c $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:4173   .text:0000256c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5394   .text:00002fb0 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5422   .text:0000300c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5425   .text:0000300c CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5716   .text:000032c4 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5723   .text:000032d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5726   .text:000032d4 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5767   .text:00003318 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5772   .text:00003320 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5775   .text:00003320 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5800   .text:0000333c $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5804   .text:00003340 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:5807   .text:00003340 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7224   .text:00003eb0 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7282   .text:00003f8c $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7285   .text:00003f8c CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7442   .text:00004104 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7458   .text:00004138 $a
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7461   .text:00004138 main
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9092   .data:00000680 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9101   .data:0000068c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9176   .data:000007ac CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9195   .data:000007bc CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7624   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9274   .data:000008ec CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9285   .data:000008fc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9396   .data:00000aac CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9547   .data:00000b40 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7637   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9088   .data:0000067f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9925   .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9845   .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9849   .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9853   .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9930   .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9934   .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9938   .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9942   .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9841   .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9878   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9874   .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9837   .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9029   .data:0000064c glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8969   .data:00000614 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9059   .data:00000668 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8999   .data:00000630 glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9074   .data:00000674 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8619   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7601   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7605   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7649   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7653   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:7976   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8634   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8639   .data:00000490 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:8646   .data:00000494 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9625   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9825   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9829   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9833   .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9857   .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9862   .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9866   .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9870   .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9883   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9887   .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9891   .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9895   .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9899   .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9904   .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9908   .bss:000000a0 IMcount.7788
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9913   .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9917   .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccw98428.s:9921   .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
