   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2CCmdCb
  24              	I2CCmdCb:
  25              	.LFB18:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      **** CyBool_t        streamingRecove = CyFalse;              /* start streaming again */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static CyBool_t stream_start = CyFalse;
 214:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 215:../uvc.c      ****                                                            the current video frame. */
 216:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 217:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 218:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 219:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 220:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 221:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 222:../uvc.c      **** 
 223:../uvc.c      **** /************ control parameters array ***********
 224:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 225:../uvc.c      ****  *    e.g.
 226:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 227:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 228:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 229:../uvc.c      ****  **************************************************/
 230:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 231:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 232:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 233:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 234:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 236:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 237:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 238:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 239:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 240:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 241:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 244:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 245:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 249:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 254:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 256:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 258:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 259:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 260:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 261:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 262:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 264:../uvc.c      **** 		/**********************************
 265:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 266:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 267:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 268:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 269:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 270:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 271:../uvc.c      **** 		 *
 272:../uvc.c      **** 		 *********************************/
 273:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 274:../uvc.c      **** };
 275:../uvc.c      **** #if 1 // the new control structure
 276:../uvc.c      **** /* the processing unit control request */
 277:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 278:../uvc.c      **** 
 279:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 280:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 281:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 282:../uvc.c      **** 		 2,					//UVCLn: the command length
 283:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 284:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 285:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 286:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 287:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 288:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 289:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 290:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 291:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 292:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 293:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 294:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 295:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 296:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 297:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 298:../uvc.c      **** 		}; //
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 301:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 302:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 303:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 304:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 305:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 306:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 307:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 308:../uvc.c      **** 		 2,					//UVCLn: the command length
 309:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 310:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 311:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 312:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 313:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 314:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 315:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 316:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 317:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 318:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 319:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 320:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 321:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 322:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 323:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 324:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 325:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 326:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 327:../uvc.c      **** 
 328:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 329:../uvc.c      **** 	&PUCBLC,
 330:../uvc.c      **** 	0, //&PUCBright,
 331:../uvc.c      **** 	0, //&PUCContrast,
 332:../uvc.c      **** 	0, //&PUCGain (AGC?)
 333:../uvc.c      **** 	0, //&PUCPLFreq,
 334:../uvc.c      **** 	0, //&PUCHueC,
 335:../uvc.c      **** 	0, //&PUCSaturation,
 336:../uvc.c      **** 	&PUCSharp,
 337:../uvc.c      **** 	0, //&PUCGamGain,
 338:../uvc.c      **** 	0, //&PUCWBMd,
 339:../uvc.c      **** 	0, //UVCCtlID10,
 340:../uvc.c      **** 	0, //&PUCWBLC,
 341:../uvc.c      **** 	0, //UVCCtlID12,
 342:../uvc.c      **** 	0, //UVCCtlID13,
 343:../uvc.c      **** 	0, //&PUCDZoom,
 344:../uvc.c      **** 	0 //UVCCtlID15
 345:../uvc.c      **** };
 346:../uvc.c      **** 
 347:../uvc.c      **** /* the Camera terminal control request */
 348:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 349:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 350:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 351:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 352:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 353:../uvc.c      **** 
 354:../uvc.c      **** /* the Extentsion control request */
 355:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 356:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 357:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 358:../uvc.c      **** 		 2,					//UVCLn: the command length
 359:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 360:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 361:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 362:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 363:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 364:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 365:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 366:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 367:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 368:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 369:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 370:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 371:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 372:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 373:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 374:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 375:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 376:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 377:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 378:../uvc.c      **** 		 2,					//UVCLn: the command length
 379:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 380:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 381:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 382:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 383:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 384:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 385:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 386:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 387:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 388:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 389:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 390:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 391:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 392:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 393:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 394:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 395:../uvc.c      **** */
 396:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 397:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 398:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 399:../uvc.c      **** 		 2,					//UVCLn: the command length
 400:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 401:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 402:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 403:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 404:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 405:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 406:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 407:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 408:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 409:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 410:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 411:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 412:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 413:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 414:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 415:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 416:../uvc.c      **** */
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 418:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 421:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 422:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 423:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 424:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 425:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 426:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 427:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 428:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 429:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 430:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 431:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 432:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 433:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 434:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 435:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 436:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 437:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 438:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 439:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 440:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 441:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 442:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 443:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 444:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 445:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 447:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 448:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 449:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 450:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 451:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 452:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 453:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 454:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 456:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 457:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 458:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 459:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 460:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 461:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 462:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 464:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 465:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 466:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 467:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 468:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 469:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 470:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 471:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 472:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 473:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 474:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 475:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 476:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 477:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 478:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 479:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 480:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 481:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 482:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 483:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 484:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 485:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 486:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 487:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 488:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 489:../uvc.c      **** 		}; //
 490:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 491:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 492:../uvc.c      **** 
 493:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 494:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 495:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 496:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 497:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 498:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 499:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 500:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 501:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 502:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 503:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 504:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 505:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 506:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 507:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 508:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 509:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 510:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 511:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 512:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 513:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 514:../uvc.c      **** 
 515:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 516:../uvc.c      **** 		&EXTShutter,
 517:../uvc.c      **** 		0, //&EXTSensUp,
 518:../uvc.c      **** 		0, //&EXTMirror,
 519:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 520:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 521:../uvc.c      **** 		0, //&EXTDayNightMode,
 522:../uvc.c      **** 		0, //&EXTDayNightdely,
 523:../uvc.c      **** 		0, //&EXTDayNightlev,
 524:../uvc.c      **** 		0, //&EXTNightDaylev,
 525:../uvc.c      **** 		&EXTAexModGainlev,
 526:../uvc.c      **** 		0, //&EXTExpReflev,
 527:../uvc.c      **** 		&EXTShutlev,
 528:../uvc.c      **** 		0, //&EXTCamMode,
 529:../uvc.c      **** 		0, //&EXTSnapshot,
 530:../uvc.c      **** 		0, //&EXTSensorPare,
 531:../uvc.c      **** 		0, //&EXTI2Ccmd,
 532:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 533:../uvc.c      **** 		0, //&Ext1CtlID1,
 534:../uvc.c      **** 		0, //&Ext1CtlID2,
 535:../uvc.c      **** 		0, //&Ext1CtlID3,
 536:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 537:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 538:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 539:../uvc.c      **** 		0
 540:../uvc.c      **** };
 541:../uvc.c      **** 
 542:../uvc.c      **** #endif //end of the new control structure
 543:../uvc.c      **** 
 544:../uvc.c      **** #ifndef CAM720
 545:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 546:../uvc.c      **** #else
 547:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 548:../uvc.c      **** #endif
 549:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 550:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 551:../uvc.c      **** 
 552:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 553:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 554:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 555:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 556:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 557:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 558:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 559:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 560:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 561:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 564:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 565:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 569:../uvc.c      **** };
 570:../uvc.c      **** 
 571:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 572:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 573:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 574:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 575:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 576:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 577:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 578:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 579:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 580:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 581:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 582:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 590:../uvc.c      **** };
 591:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 592:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 593:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 594:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 595:../uvc.c      **** 
 596:../uvc.c      **** static uint8_t debugData[16]={0};
 597:../uvc.c      **** /*
 598:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 599:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 600:../uvc.c      ****  */
 601:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 602:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 603:../uvc.c      **** };
 604:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 605:../uvc.c      **** 		0 //bit0:0-read; 1-write. bit1:number of addr. bit2:device addr. bit3:board addr. bit4:DSP addr. 
 606:../uvc.c      **** 			//bit8:number of data. bit9:data0. bit10:data1. ......
 607:../uvc.c      **** };
 608:../uvc.c      **** 
 609:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 610:../uvc.c      **** 
 611:../uvc.c      **** void I2CCmdHandler(){
 612:../uvc.c      **** 	uint8_t buf[2];
 613:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 614:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 615:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 616:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 617:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 618:../uvc.c      **** 	uint8_t i;
 619:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 620:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 621:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 622:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 623:../uvc.c      **** 	{
 624:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 625:../uvc.c      **** 		if(is60Hz==CyFalse)
 626:../uvc.c      **** 			{
 627:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 628:../uvc.c      **** 			}
 629:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 630:../uvc.c      **** 
 631:../uvc.c      **** 	}
 632:../uvc.c      **** 	else{//for get debug data
 633:../uvc.c      **** 		if(CmdType == 0){ //read
 634:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 635:../uvc.c      **** 		if(I2CCMDArry[2] == 0){
 636:../uvc.c      **** 			I2CCMDArry[10] = debugData[0]; //number of frame
 637:../uvc.c      **** 			I2CCMDArry[9] = debugData[1];  // stream status
 638:../uvc.c      **** 		}
 639:../uvc.c      **** 		else if (I2CCMDArry[2] == 1){
 640:../uvc.c      **** 			I2CCMDArry[9] = debugData[2];  // stream status
 641:../uvc.c      **** 			I2CCMDArry[10] = debugData[3]; //abort code
 642:../uvc.c      **** 		}
 643:../uvc.c      **** 		else if(I2CCMDArry[2] == 2){
 644:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 645:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 646:../uvc.c      **** 
 647:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
 648:../uvc.c      ****             {
 649:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 650:../uvc.c      ****             }
 651:../uvc.c      **** 
 652:../uvc.c      **** 		}
 653:../uvc.c      **** 		I2CCMDArry[11] = 0xff;
 654:../uvc.c      **** 		//CmdType = 0xf;//end the routine
 655:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 656:../uvc.c      **** 			debugData[0] = 0x00;  //
 657:../uvc.c      **** 			debugData[1] = 0x00;  //
 658:../uvc.c      **** 			debugData[2] = 0x00;
 659:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 660:../uvc.c      **** 		}
 661:../uvc.c      **** 		CmdType = 0xf;//end the routine
 662:../uvc.c      **** 	}
 663:../uvc.c      **** 	if(CmdType == 0)//I2C read
 664:../uvc.c      **** 	{
 665:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 666:../uvc.c      **** #if 0 //for debugging
 667:../uvc.c      **** 		/* test still image operation */
 668:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 669:../uvc.c      **** 			snapButFlag = 0; //press
 670:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 671:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 672:../uvc.c      **** 			snapButFlag = 0xf; //release
 673:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 674:../uvc.c      **** 		}
 675:../uvc.c      **** 
 676:../uvc.c      **** 		/* end of the test */
 677:../uvc.c      **** #endif
 678:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 679:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 680:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 681:../uvc.c      **** 				if(CmdDataLen == 2){
 682:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 683:../uvc.c      **** 				}
 684:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 685:../uvc.c      **** 		}else{//not support currently
 686:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 687:../uvc.c      **** 		}
 688:../uvc.c      **** 	}else if(CmdType == 1){
 689:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 690:../uvc.c      **** 			if(CmdRegLen == 2){
 691:../uvc.c      **** 				for(i = 0; i<4; i++)
 692:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 693:../uvc.c      **** 			}
 694:../uvc.c      **** 			else{
 695:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 696:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 697:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 698:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 699:../uvc.c      **** 				}
 700:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 701:../uvc.c      **** 				if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 702:../uvc.c      **** 			}
 703:../uvc.c      **** 		}else{//not support currently
 704:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 705:../uvc.c      **** 		}
 706:../uvc.c      **** 
 707:../uvc.c      **** 	}
 708:../uvc.c      **** }
 709:../uvc.c      **** 
 710:../uvc.c      **** /************************************
 711:../uvc.c      ****  * set Iris mode
 712:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 713:../uvc.c      ****  */
 714:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 715:../uvc.c      **** 	uint8_t dataIdx = 0;
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 720:../uvc.c      **** }
 721:../uvc.c      **** 
 722:../uvc.c      **** 
 723:../uvc.c      **** 
 724:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 725:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 726:../uvc.c      **** 	uint16_t NumLn;
 727:../uvc.c      **** 	uint16_t fRate, shutTm;
 728:../uvc.c      **** 	uint8_t LnVal;
 729:../uvc.c      **** 	switch (Data){
 730:../uvc.c      **** 	case 1:
 731:../uvc.c      **** 	case 2:
 732:../uvc.c      **** 	case 3:
 733:../uvc.c      **** 	case 4:
 734:../uvc.c      **** 	case 5:
 735:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 736:../uvc.c      **** 		fRate = 30;
 737:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 738:../uvc.c      **** 		if(NumLn > 1944)
 739:../uvc.c      **** 			NumLn =1944;
 740:../uvc.c      **** 		else if(NumLn < 8)
 741:../uvc.c      **** 			NumLn = 8;
 742:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 743:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 744:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 745:../uvc.c      **** 		break;
 746:../uvc.c      **** 	case 6:
 747:../uvc.c      **** 	case 7:
 748:../uvc.c      **** 	case 8:
 749:../uvc.c      **** 	case 9:
 750:../uvc.c      **** 	case 10:
 751:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 752:../uvc.c      **** 		fRate = 30;
 753:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 754:../uvc.c      **** 		if(NumLn > 1944)
 755:../uvc.c      **** 			NumLn =1944;
 756:../uvc.c      **** 		else if(NumLn < 8)
 757:../uvc.c      **** 			NumLn = 8;
 758:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 759:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 760:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 761:../uvc.c      **** 		break;
 762:../uvc.c      **** 	case 0: //auto
 763:../uvc.c      **** 	default:
 764:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 765:../uvc.c      **** 		LnVal = 1;
 766:../uvc.c      **** 		break;
 767:../uvc.c      **** 	}
 768:../uvc.c      **** 	return LnVal;
 769:../uvc.c      **** }
 770:../uvc.c      **** 
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 772:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 773:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 774:../uvc.c      ****     uint16_t readCount;
 775:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 776:../uvc.c      ****     uint8_t devAdd;
 777:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 778:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 779:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 780:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 781:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 782:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 783:../uvc.c      ****     }else{
 784:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 785:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 786:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 787:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 788:../uvc.c      ****     }
 789:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 790:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 791:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 792:../uvc.c      **** #endif
 793:../uvc.c      ****     reqData = bRequest;
 794:../uvc.c      ****     /*
 795:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 796:../uvc.c      ****      */
 797:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 798:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 799:../uvc.c      ****     	goto EndofSet;
 800:../uvc.c      ****     }
 801:../uvc.c      ****     switch (bRequest)
 802:../uvc.c      **** 		 {
 803:../uvc.c      **** 
 804:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 805:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 806:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 807:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 808:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 809:../uvc.c      **** 			  break;
 810:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 811:../uvc.c      **** 
 812:../uvc.c      **** 			 switch(CtrlID)
 813:../uvc.c      **** 			 {
 814:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 815:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 816:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 817:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 818:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 819:../uvc.c      **** 			 	 		 }else{
 820:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 821:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 823:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 824:../uvc.c      **** 			 	 		 }
 825:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 826:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 827:../uvc.c      **** 						 break;
 828:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 829:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 830:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 831:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 832:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 833:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 834:../uvc.c      **** 			 	 		 }else{
 835:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 836:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 837:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 838:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 839:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 840:../uvc.c      **** 			 	 		 }
 841:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 842:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 843:../uvc.c      **** 			 	 		 break;
 844:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 845:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 846:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 847:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 848:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 849:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 850:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 851:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 852:../uvc.c      **** 			 	 		 }else{
 853:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 854:../uvc.c      **** 			 	 			if(Data0&0x80)
 855:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 856:../uvc.c      **** 			 	 			else
 857:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 858:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 859:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 860:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 861:../uvc.c      **** 			 	 		 }
 862:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 863:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 864:../uvc.c      **** 			 	 		 break;
 865:../uvc.c      **** 			 	 }
 866:../uvc.c      **** 			 	 case ExtShutCtlID0:
 867:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 868:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 869:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 870:../uvc.c      **** 
 871:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 872:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 873:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 874:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 875:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 876:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 877:../uvc.c      **** 		 	 		 }else{
 878:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 879:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 880:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 881:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 882:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 883:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 884:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 885:../uvc.c      **** 
 886:../uvc.c      **** 		 	 		 }
 887:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 888:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 889:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 890:../uvc.c      **** 			 		 break;
 891:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 892:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 893:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 894:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 895:../uvc.c      **** 
 896:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 897:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 898:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 899:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 900:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 901:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 902:../uvc.c      **** 		 	 		 }else{
 903:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 904:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 905:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 906:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 907:../uvc.c      **** 		 	 		 }
 908:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 909:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 910:../uvc.c      **** 			 		 break;
 911:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 912:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 913:../uvc.c      **** 
 914:../uvc.c      **** 					 if(CamMode == 1){//720p
 915:../uvc.c      **** 						if(sendData >= 3){
 916:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 917:../uvc.c      **** 							sendData = 0; //set back to default
 918:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 919:../uvc.c      **** 						}
 920:../uvc.c      **** 						sendData += 4;
 921:../uvc.c      **** 					 }
 922:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 923:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 924:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 925:../uvc.c      **** 					 break;
 926:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 927:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 928:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 929:../uvc.c      **** 			 		 }
 930:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 931:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 932:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 933:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 934:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 935:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 936:../uvc.c      **** #endif
 937:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 938:../uvc.c      **** 			 		 {
 939:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 940:../uvc.c      **** 			 		 }
 941:../uvc.c      **** 			 		 break;
 942:../uvc.c      **** 				 case ExtAexModCtlID9:
 943:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 944:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 945:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 946:../uvc.c      **** 
 947:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 948:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 949:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 950:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 951:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 952:../uvc.c      **** 		 	 		 }else{
 953:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 954:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 955:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 956:../uvc.c      **** 
 957:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 958:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 959:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 960:../uvc.c      **** 		 	 		 }
 961:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 962:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 963:../uvc.c      **** 
 964:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 966:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 967:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 968:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 969:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 970:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 971:../uvc.c      **** 					 break;
 972:../uvc.c      **** 
 973:../uvc.c      **** 			 	 case BrgtCtlID1:
 974:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 975:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 976:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 977:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 978:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 979:../uvc.c      **** 					 }else{
 980:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 981:../uvc.c      **** 					 }
 982:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 983:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 984:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 985:../uvc.c      **** 					 */
 986:../uvc.c      **** 
 987:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 988:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 989:../uvc.c      **** 		 	 		 }else{
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 991:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 992:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 993:../uvc.c      **** 		 	 		 }
 994:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
 995:../uvc.c      **** 					  if(Data0&0x80){
 996:../uvc.c      **** 						  Data0 = ~Data0;
 997:../uvc.c      **** 					  }else{
 998:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 999:../uvc.c      **** 					  }
1000:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1001:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1002:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1003:../uvc.c      **** 			 		 break;
1004:../uvc.c      **** 				 case HueCtlID5:
1005:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1006:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1007:../uvc.c      **** 		 	 		 }else{
1008:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1009:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1010:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1011:../uvc.c      **** 		 	 		 }
1012:../uvc.c      **** 
1013:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1014:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1015:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1016:../uvc.c      **** 					 break;
1017:../uvc.c      **** 				 case WBTLevCtlID11:
1018:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1019:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1020:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1021:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1022:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1023:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1024:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1025:../uvc.c      **** 		 	 		 }else{
1026:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1027:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1028:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1029:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1030:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1031:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1032:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1033:../uvc.c      **** 		 	 		 }
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1035:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1036:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1037:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1038:../uvc.c      **** 					 break;
1039:../uvc.c      **** 				 case BLCCtlID0:
1040:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1041:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1042:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1043:../uvc.c      **** 		 	 		 }else{
1044:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1045:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1046:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1048:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1049:../uvc.c      **** 		 	 		 }
1050:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1051:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1052:../uvc.c      **** 					 break;
1053:../uvc.c      **** 				 case ShapCtlID7:
1054:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1055:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1056:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1057:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1058:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1059:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1060:../uvc.c      **** 		 	 		 }else{
1061:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1062:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1063:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1064:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1065:../uvc.c      **** 		 	 		 }
1066:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1067:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1068:../uvc.c      **** 					 break;
1069:../uvc.c      **** 				 case ExtExRefCtlID10:
1070:../uvc.c      **** 				 case ConsCtlID2:
1071:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1072:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1073:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1074:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1075:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1077:../uvc.c      **** 		 	 		 }else{
1078:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1079:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1080:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1081:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1082:../uvc.c      **** 		 	 		 }
1083:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1084:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1085:../uvc.c      **** 					 break;
1086:../uvc.c      **** 				 case WBTMdCtlID9:
1087:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1088:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1089:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1090:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1091:../uvc.c      **** 		 	 		 }else{
1092:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1093:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1094:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1095:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1096:../uvc.c      **** 
1097:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1098:../uvc.c      **** 		 	 		 }
1099:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1100:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1101:../uvc.c      **** 					 break;
1102:../uvc.c      **** 				 case MFreqCtlID4:
1103:../uvc.c      **** 
1104:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1105:../uvc.c      **** 
1106:../uvc.c      **** 		 	 			 if(is60Hz)
1107:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1108:../uvc.c      **** 		 	 			 else
1109:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1110:../uvc.c      **** 
1111:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1112:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1113:../uvc.c      **** 		 	 		 }else{
1114:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1115:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1116:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1117:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1118:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1119:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1120:../uvc.c      **** 		 	 		 }
1121:../uvc.c      **** 
1122:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1123:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1124:../uvc.c      **** 					 break;
1125:../uvc.c      **** 				 case SaturCtlID6:
1126:../uvc.c      **** 				 default:
1127:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1128:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1129:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1130:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1131:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1132:../uvc.c      **** 		 	 		 }else{
1133:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1134:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1135:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1136:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1137:../uvc.c      **** 		 	 		 }
1138:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1139:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1140:../uvc.c      **** 
1141:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1142:../uvc.c      **** 					 break;
1143:../uvc.c      **** 			 }
1144:../uvc.c      **** 
1145:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1146:../uvc.c      **** 
1147:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1148:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1149:../uvc.c      **** #endif
1150:../uvc.c      **** 			  break;
1151:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1152:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1153:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1155:../uvc.c      **** 		 	 }
1156:../uvc.c      **** 
1157:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1158:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1159:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1160:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1161:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1162:../uvc.c      **** 			 }else
1163:../uvc.c      **** 			 {
1164:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1165:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1166:../uvc.c      **** 			 }
1167:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1168:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1169:../uvc.c      **** 			  break;
1170:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1171:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1172:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1173:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1174:../uvc.c      **** 		 	 }
1175:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1176:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1177:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1178:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1179:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1180:../uvc.c      **** 			 }else
1181:../uvc.c      **** 			 {
1182:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1183:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1184:../uvc.c      **** 			 }
1185:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1186:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1187:../uvc.c      **** 			  break;
1188:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1189:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1190:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1191:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1192:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1193:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1194:../uvc.c      **** 		 	 }
1195:../uvc.c      **** 		 	 else{
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1197:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1198:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1199:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1200:../uvc.c      **** 		 	 }
1201:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1202:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1203:../uvc.c      **** 			  break;
1204:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1205:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1206:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1207:../uvc.c      **** 		 	 }
1208:../uvc.c      **** 		 	 else{
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1210:../uvc.c      **** 		 	 }
1211:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1212:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1213:../uvc.c      **** 			  Len = 1;
1214:../uvc.c      **** 			  break;
1215:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1216:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1217:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1218:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1219:../uvc.c      **** 		 	 }
1220:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1221:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1222:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1223:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1224:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1225:../uvc.c      **** 			 }else{
1226:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1227:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1228:../uvc.c      **** 			 }
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1230:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1231:../uvc.c      **** 			  break;
1232:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1233:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1234:../uvc.c      **** 				  glEp0Buffer, &readCount);
1235:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1236:../uvc.c      **** 			   {
1237:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1238:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1239:../uvc.c      **** 				  getData = glEp0Buffer[0];
1240:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1241:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1242:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1243:../uvc.c      **** #endif
1244:../uvc.c      **** 				  switch(CtrlID)
1245:../uvc.c      **** 					 {
1246:../uvc.c      **** 						 case ExtShutCtlID0:
1247:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1248:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1249:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1250:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1251:../uvc.c      **** #if 1	// register setting directly
1252:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1253:../uvc.c      **** 						     {
1254:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1255:../uvc.c      **** 						    	 dataIdx = 0;
1256:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1257:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1258:../uvc.c      **** 								 dataIdx++;
1259:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1260:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1261:../uvc.c      **** 						     }
1262:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1263:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1264:../uvc.c      **** 						     break;
1265:../uvc.c      **** #else	// old fashion
1266:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1267:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1268:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1269:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1270:../uvc.c      **** 									 }else{
1271:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1272:../uvc.c      **** 									 }
1273:../uvc.c      **** 								 }
1274:../uvc.c      **** 							 }else{
1275:../uvc.c      **** 								 Data1 = Data0 - 1;
1276:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1277:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1278:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1279:../uvc.c      **** 									 }else{
1280:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1281:../uvc.c      **** 									 }
1282:../uvc.c      **** 								 }
1283:../uvc.c      **** 								 if(Data1 < 8){
1284:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1285:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1286:../uvc.c      **** 								 }else{
1287:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1288:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1289:../uvc.c      **** 								 }
1290:../uvc.c      **** 							 }
1291:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1292:../uvc.c      **** 							 dataIdx = 0;
1293:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1294:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1295:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1296:../uvc.c      **** 							 if(AxMode){
1297:../uvc.c      **** 								 dataIdx++;
1298:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1299:../uvc.c      **** 								 dataIdx++;
1300:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1301:../uvc.c      **** 							 }
1302:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1303:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1304:../uvc.c      **** 							 break;
1305:../uvc.c      **** #endif
1306:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1307:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1308:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1309:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1310:../uvc.c      **** 						     dataIdx = 0;
1311:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1312:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1313:../uvc.c      **** 							 {
1314:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1315:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1316:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1317:../uvc.c      **** 								 /*
1318:../uvc.c      **** 								 dataIdx++;
1319:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1320:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1321:../uvc.c      **** 									 dataIdx++;
1322:../uvc.c      **** 								 }else{
1323:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1324:../uvc.c      **** 									 dataIdx++;
1325:../uvc.c      **** 								 }
1326:../uvc.c      **** 								 */
1327:../uvc.c      **** 							 }
1328:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1329:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1330:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1331:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1332:../uvc.c      **** 								 }
1333:../uvc.c      **** 							 }
1334:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1335:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1336:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1337:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1338:../uvc.c      **** 							 break;
1339:../uvc.c      **** 
1340:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1341:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1342:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1343:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1344:../uvc.c      **** 						     dataIdx = 0;
1345:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1346:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1347:../uvc.c      **** 							 {
1348:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1349:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1350:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1351:../uvc.c      **** 								 dataIdx++;
1352:../uvc.c      **** 							 }
1353:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1354:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1355:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1356:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1357:../uvc.c      **** 									 dataIdx++;
1358:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1359:../uvc.c      **** 								 }
1360:../uvc.c      **** 							 }
1361:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1362:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1364:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1365:../uvc.c      **** 							 break;
1366:../uvc.c      **** 						 case ExtCamMCtlID12:
1367:../uvc.c      **** 							 dataIdx = 0;
1368:../uvc.c      **** 							 if(Data0 <= 3){
1369:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1370:../uvc.c      **** 								 Data1 = Data0;
1371:../uvc.c      **** 							 }else{
1372:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1373:../uvc.c      **** 								 Data1 = Data0-4;
1374:../uvc.c      **** 							 }
1375:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1376:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1377:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1378:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1379:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1380:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1381:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1382:../uvc.c      **** 							 break;
1383:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1384:../uvc.c      **** 							 dataIdx = 0;
1385:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1386:../uvc.c      **** 								 Data0 = 1;
1387:../uvc.c      **** 							 }else{ //save current sensor parameters.
1388:../uvc.c      **** 								 Data0 = 0;
1389:../uvc.c      **** 							 }
1390:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1391:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1392:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1393:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1394:../uvc.c      **** 							 break;
1395:../uvc.c      **** 						 case ExtI2CCtlID15:
1396:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1397:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1398:../uvc.c      **** 					 		 }
1399:../uvc.c      **** 					 		I2CCmdHandler();
1400:../uvc.c      **** 							 break;
1401:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1402:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1403:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1404:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1405:../uvc.c      **** 
1406:../uvc.c      **** 							 dataIdx = 0;
1407:../uvc.c      **** #if 0 //seperate version
1408:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1409:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1411:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1412:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1413:../uvc.c      **** 							 }else{ //disable BLD window
1414:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1415:../uvc.c      **** 							 }
1416:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1417:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1418:../uvc.c      **** 							 dataIdx++;
1419:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1420:../uvc.c      **** 							 dataIdx++;
1421:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1422:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1423:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1424:../uvc.c      **** 							 dataIdx++;
1425:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1426:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1427:../uvc.c      **** #else //combination version
1428:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1430:../uvc.c      **** 						     /* end test */
1431:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1432:../uvc.c      **** 							 dataIdx++;
1433:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1434:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1435:../uvc.c      **** 							 getData1 = Data1;
1436:../uvc.c      **** #endif
1437:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1438:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1439:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1440:../uvc.c      **** 							 break;
1441:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1442:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1443:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1444:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1445:../uvc.c      **** 
1446:../uvc.c      **** 							 dataIdx = 0;
1447:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1448:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1449:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1450:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1451:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1452:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1453:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1454:../uvc.c      **** 							 break;
1455:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1456:../uvc.c      **** 							 dataIdx = 0;
1457:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1458:../uvc.c      **** 							 if(Data0 == 1){
1459:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1460:../uvc.c      **** 							 }else{
1461:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1462:../uvc.c      **** 							 }
1463:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1464:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1466:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1467:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1468:../uvc.c      **** 							 break;
1469:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1470:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1471:../uvc.c      **** 							 dataIdx = 0;
1472:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1473:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1474:../uvc.c      **** 							  if(Data0&0x80){
1475:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1476:../uvc.c      **** 							  }else{
1477:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1478:../uvc.c      **** 							  }
1479:../uvc.c      **** 							 Data1 |= ~0x03;
1480:../uvc.c      **** 							 Data1 &= 0xC7;
1481:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1482:../uvc.c      **** 						  	 dataIdx++;
1483:../uvc.c      **** 
1484:../uvc.c      **** 							 Data0 = (Data0 << 2);
1485:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1486:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1487:../uvc.c      **** 
1488:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1490:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1491:../uvc.c      **** #endif
1492:../uvc.c      **** 							 dataIdx = 0;
1493:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1494:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1495:../uvc.c      **** 							  if(Data0&0x80){
1496:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1497:../uvc.c      **** 							  }else{
1498:../uvc.c      **** 								  Data0 = ~Data0;
1499:../uvc.c      **** 							  }
1500:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1501:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1502:../uvc.c      **** 
1503:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1504:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1505:../uvc.c      **** 
1506:../uvc.c      **** 
1507:../uvc.c      **** 							 break;
1508:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1509:../uvc.c      **** 							 dataIdx = 0;
1510:../uvc.c      **** 
1511:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1512:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1513:../uvc.c      **** 							 dataIdx++;
1514:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1515:../uvc.c      **** 							 dataIdx++;
1516:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1517:../uvc.c      **** 							 dataIdx++;
1518:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1519:../uvc.c      **** 							 dataIdx++;
1520:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1521:../uvc.c      **** 							 dataIdx++;
1522:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1523:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1524:../uvc.c      **** 
1525:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1526:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1527:../uvc.c      **** 							 break;
1528:../uvc.c      **** 						 case SaturCtlID6:
1529:../uvc.c      **** 							 dataIdx = 0;
1530:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1533:../uvc.c      **** 							 dataIdx++;
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1535:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1536:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1537:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1538:../uvc.c      **** 							 break;
1539:../uvc.c      **** 
1540:../uvc.c      **** 						 case WBTLevCtlID11:
1541:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1542:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1543:../uvc.c      **** 							 dataIdx = 0;
1544:../uvc.c      **** 
1545:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1546:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1547:../uvc.c      **** 							 dataIdx++;
1548:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1549:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1550:../uvc.c      **** 
1551:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1552:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1553:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1554:../uvc.c      **** 							 break;
1555:../uvc.c      **** 						 case MFreqCtlID4:
1556:../uvc.c      **** 							 dataIdx = 0;
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1558:../uvc.c      **** 							 Data0 = Data0 - 1;
1559:../uvc.c      **** 							 is60Hz = Data0;
1560:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1561:../uvc.c      **** 							 {
1562:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1563:../uvc.c      **** 								 is60Hz = CyFalse;
1564:../uvc.c      **** 							 }
1565:../uvc.c      **** 							 else if(Data0 >2)
1566:../uvc.c      **** 							 {
1567:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1568:../uvc.c      **** 								 is60Hz = CyTrue;
1569:../uvc.c      **** 							 }
1570:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1571:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1572:../uvc.c      **** 							 {
1573:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1574:../uvc.c      **** 			                       switch (setRes)
1575:../uvc.c      **** 			                         {
1576:../uvc.c      **** 			                         	case 1: //1944
1577:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1578:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1579:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1580:../uvc.c      **** 			                         		break;
1581:../uvc.c      **** 			                         	case 2: //1080
1582:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1583:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1584:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1585:../uvc.c      **** 			                         		break;
1586:../uvc.c      **** 			                         	case 3: //720
1587:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1588:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1589:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1590:../uvc.c      **** 			                         		break;
1591:../uvc.c      **** 			                         	case 4: //VGA
1592:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1593:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1594:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1595:../uvc.c      **** 			                         	default:
1596:../uvc.c      **** 			                         		break;
1597:../uvc.c      **** 			                         }
1598:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1599:../uvc.c      **** 							 }
1600:../uvc.c      **** 
1601:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1602:../uvc.c      **** 							 break;
1603:../uvc.c      **** 					 	 case BLCCtlID0:
1604:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1605:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1606:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1607:../uvc.c      **** 						     dataIdx = 0;
1608:../uvc.c      **** 
1609:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1610:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1611:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1612:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1613:../uvc.c      **** 
1614:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1615:../uvc.c      **** 							 {
1616:../uvc.c      **** 								 if(Data0 < 3){
1617:../uvc.c      **** 					 				 Data0 += 4;
1618:../uvc.c      **** 					 			 }else{
1619:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1620:../uvc.c      **** 									Data0 = 4; //set to default.
1621:../uvc.c      **** 					 			 }
1622:../uvc.c      **** 					 		 }
1623:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1624:../uvc.c      **** 							 dataIdx = 0;
1625:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1626:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1627:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1628:../uvc.c      **** 
1629:../uvc.c      **** 					 		 break;
1630:../uvc.c      **** 					 	 case ShapCtlID7:
1631:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1632:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1633:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1634:../uvc.c      **** 						     dataIdx = 0;
1635:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1636:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1637:../uvc.c      **** 							 if(Data0 != 0){
1638:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1639:../uvc.c      **** #ifdef COLOR
1640:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1641:../uvc.c      **** #else
1642:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1643:../uvc.c      **** 								 dataIdx++;
1644:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1645:../uvc.c      **** #endif
1646:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1647:../uvc.c      **** 							 }else{
1648:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1649:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1650:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1651:../uvc.c      **** 
1652:../uvc.c      **** 							 }
1653:../uvc.c      **** 							 break;
1654:../uvc.c      **** 						 case ExtExRefCtlID10:
1655:../uvc.c      **** 						 case ConsCtlID2:
1656:../uvc.c      **** 							 dataIdx = 0;
1657:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1658:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1659:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1660:../uvc.c      **** 
1661:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1662:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1663:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1664:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1665:../uvc.c      **** 
1666:../uvc.c      **** 							 break;
1667:../uvc.c      **** 						 default:
1668:../uvc.c      **** 							 dataIdx = 0;
1669:../uvc.c      **** 
1670:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1671:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1672:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1673:../uvc.c      **** 
1674:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1676:../uvc.c      **** 							 break;
1677:../uvc.c      **** 					 }
1678:../uvc.c      **** 			   }else{
1679:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1680:../uvc.c      **** 			   }
1681:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1682:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1683:../uvc.c      **** #endif
1684:../uvc.c      **** 
1685:../uvc.c      **** 			  break;
1686:../uvc.c      **** 		  default:
1687:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1688:../uvc.c      **** 			  break;
1689:../uvc.c      **** 		 }
1690:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1691:../uvc.c      **** }
1692:../uvc.c      **** /************** CT control requests handler *************************/
1693:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1694:../uvc.c      **** 
1695:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1696:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1697:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1698:../uvc.c      ****     uint16_t readCount;
1699:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1700:../uvc.c      ****     uint16_t diff, value, diffRd;
1701:../uvc.c      ****     uint8_t i, shutter, index;
1702:../uvc.c      ****     diff = 0xffff;
1703:../uvc.c      ****     shutter = 1;
1704:../uvc.c      ****     index = 1;
1705:../uvc.c      **** 
1706:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1707:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1708:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1709:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1710:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1711:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1712:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1713:../uvc.c      **** #endif
1714:../uvc.c      ****     reqData = bRequest;
1715:../uvc.c      **** 
1716:../uvc.c      ****     switch (bRequest)
1717:../uvc.c      **** 		 {
1718:../uvc.c      **** 
1719:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1720:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1721:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1724:../uvc.c      **** 			  break;
1725:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1726:../uvc.c      **** 
1727:../uvc.c      **** 			 switch(CtrlID)
1728:../uvc.c      **** 			 {
1729:../uvc.c      **** 				 default:
1730:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1731:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1732:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1733:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1734:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1735:../uvc.c      **** 					 break;
1736:../uvc.c      **** 			 }
1737:../uvc.c      **** 
1738:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1739:../uvc.c      **** 
1740:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1741:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1742:../uvc.c      **** #endif
1743:../uvc.c      **** 			  break;
1744:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1745:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1746:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1747:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1748:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1749:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1750:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1751:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1752:../uvc.c      **** 			  break;
1753:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1754:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1755:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1756:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1757:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1758:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1759:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1760:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1761:../uvc.c      **** 			  break;
1762:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1763:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1764:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1765:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1766:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1767:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1768:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1769:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1770:../uvc.c      **** 			  break;
1771:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1772:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1773:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1774:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1775:../uvc.c      **** 			  Len = 1;
1776:../uvc.c      **** 			  break;
1777:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1778:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1779:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1780:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1781:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1782:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1783:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1784:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1785:../uvc.c      **** 			  break;
1786:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1787:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1788:../uvc.c      **** 			  glEp0Buffer, &readCount);
1789:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1790:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1791:../uvc.c      **** 			  value = Data1;
1792:../uvc.c      **** 
1793:../uvc.c      **** 			  switch(CtrlID)
1794:../uvc.c      **** 			  {
1795:../uvc.c      **** 		  	      case AutoExMCtlID1:
1796:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1797:../uvc.c      **** 
1798:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1799:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1800:../uvc.c      **** 				    getData = glEp0Buffer[0];
1801:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1802:../uvc.c      **** 		  		    switch (getData){
1803:../uvc.c      **** 						case 1:
1804:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1805:../uvc.c      **** 							break;
1806:../uvc.c      **** 						case 2:
1807:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1808:../uvc.c      **** 							dataIdx = 0;
1809:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1810:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1811:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1812:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1813:../uvc.c      **** 
1814:../uvc.c      **** 							break;
1815:../uvc.c      **** 						case 4:
1816:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1817:../uvc.c      **** 							break;
1818:../uvc.c      **** 						case 8:
1819:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1820:../uvc.c      **** 			  		    	dataIdx = 0;
1821:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1822:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1823:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1824:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1825:../uvc.c      **** 							break;
1826:../uvc.c      **** 		  		    }
1827:../uvc.c      **** #if 0
1828:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1829:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1830:../uvc.c      **** 						  dataIdx = 0;
1831:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1832:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1833:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1834:../uvc.c      **** 		  		    }
1835:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1836:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1837:../uvc.c      **** 		  		    }
1838:../uvc.c      **** #endif
1839:../uvc.c      **** 				    break;
1840:../uvc.c      **** 
1841:../uvc.c      **** 			  	  case ExTmACtlID3:
1842:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1843:../uvc.c      **** 
1844:../uvc.c      **** 					  value = (value << 8)|Data0;
1845:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1846:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1847:../uvc.c      **** 					  {
1848:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1849:../uvc.c      **** 						  {
1850:../uvc.c      **** 							if(value > ShutValueArry[i]){
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1852:../uvc.c      **** 							}else{
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1854:../uvc.c      **** 							}
1855:../uvc.c      **** 							  if(diff > diffRd){
1856:../uvc.c      **** 								  diff = diffRd;
1857:../uvc.c      **** 								  index = i;
1858:../uvc.c      **** 							  }
1859:../uvc.c      **** 						  }
1860:../uvc.c      **** 						  shutter = shutter+index;
1861:../uvc.c      **** 
1862:../uvc.c      **** 						  dataIdx = 0;
1863:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1864:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1865:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1866:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1867:../uvc.c      **** 
1868:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1869:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1870:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1871:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1872:../uvc.c      **** 					  }else{
1873:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1874:../uvc.c      **** 					  }
1875:../uvc.c      **** 					  getData = glEp0Buffer[0];
1876:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1877:../uvc.c      **** 					  break;
1878:../uvc.c      **** 			  	  case IriACtlID7:
1879:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1880:../uvc.c      **** 					  {
1881:../uvc.c      **** 							 dataIdx = 0;
1882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1883:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1885:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1886:../uvc.c      **** 
1887:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1888:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1889:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1890:../uvc.c      **** 					  }else{
1891:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1892:../uvc.c      **** 					  }
1893:../uvc.c      **** 					  getData = glEp0Buffer[0];
1894:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1895:../uvc.c      **** 
1896:../uvc.c      **** 					  break;
1897:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1898:../uvc.c      **** 					  getData = glEp0Buffer[0];
1899:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1900:../uvc.c      **** #if 1
1901:../uvc.c      **** 					  dataIdx = 0;
1902:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1903:../uvc.c      **** 					  if(getData == 1)
1904:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1905:../uvc.c      **** 					  else if(getData == 0xff)
1906:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1907:../uvc.c      **** 					  else
1908:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1909:../uvc.c      **** 					  //dataIdx++;
1910:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1911:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1912:../uvc.c      **** #endif
1913:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1914:../uvc.c      **** 					  break;
1915:../uvc.c      **** 
1916:../uvc.c      **** 			  	  default:
1917:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1918:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1919:../uvc.c      **** 			  		 break;
1920:../uvc.c      **** 			  }
1921:../uvc.c      **** 			  break;
1922:../uvc.c      **** 		  default:
1923:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1924:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1925:../uvc.c      **** 			  break;
1926:../uvc.c      **** 		 }
1927:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1928:../uvc.c      **** 
1929:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1930:../uvc.c      **** }
1931:../uvc.c      **** 
1932:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1933:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1934:../uvc.c      **** {
1935:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1936:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1937:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1938:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1939:../uvc.c      **** 
1940:../uvc.c      ****     CtrlID = BrgtCtlID1;
1941:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1942:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1943:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1944:../uvc.c      ****     Data1 = Data0;
1945:../uvc.c      **** 
1946:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1947:../uvc.c      ****     if(Data1&0x80){
1948:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1949:../uvc.c      ****     }else{
1950:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1951:../uvc.c      ****     }
1952:../uvc.c      ****     Data0 = (Data0 << 2);
1953:../uvc.c      **** 
1954:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1955:../uvc.c      **** 
1956:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1957:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1958:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1959:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1960:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1961:../uvc.c      **** 
1962:../uvc.c      ****     CtrlID = ConsCtlID2;
1963:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1964:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1965:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1966:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1967:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1968:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1969:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1970:../uvc.c      **** 
1971:../uvc.c      ****     CtrlID = HueCtlID5;
1972:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1973:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1974:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1975:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1978:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1979:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1980:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1981:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1982:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1983:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1984:../uvc.c      **** 
1985:../uvc.c      ****     CtrlID = SaturCtlID6;
1986:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1987:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1988:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1989:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1990:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1991:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1992:../uvc.c      **** 
1993:../uvc.c      ****     CtrlID = ShapCtlID7;
1994:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1995:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1996:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1997:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1998:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1999:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2000:../uvc.c      **** 
2001:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2002:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2003:../uvc.c      **** 	return;
2004:../uvc.c      **** }
2005:../uvc.c      **** 
2006:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2007:../uvc.c      **** void
2008:../uvc.c      **** CyFxUVCAddHeader (
2009:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2010:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2011:../uvc.c      ****         )
2012:../uvc.c      **** {
2013:../uvc.c      ****     /* Copy header to buffer */
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2015:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2016:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2017:../uvc.c      **** 
2018:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2019:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2020:../uvc.c      ****     {
2021:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2022:../uvc.c      ****     }
2023:../uvc.c      **** }
2024:../uvc.c      **** 
2025:../uvc.c      **** 
2026:../uvc.c      **** /* Application Error Handler */
2027:../uvc.c      **** void
2028:../uvc.c      **** CyFxAppErrorHandler (
2029:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2030:../uvc.c      ****         )
2031:../uvc.c      **** {
2032:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2033:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2034:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2035:../uvc.c      **** 
2036:../uvc.c      ****        This function can be modified to take additional error handling actions such
2037:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2038:../uvc.c      ****      */
2039:../uvc.c      ****     for (;;)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
2043:../uvc.c      ****     }
2044:../uvc.c      **** }
2045:../uvc.c      **** 
2046:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2047:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2048:../uvc.c      ****  */
2049:../uvc.c      **** static void
2050:../uvc.c      **** CyFxUVCApplnAbortHandler (
2051:../uvc.c      ****         void)
2052:../uvc.c      **** {
2053:../uvc.c      **** 	uint32_t flag;
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2055:../uvc.c      **** 	{
2056:../uvc.c      ****         /* Clear the Video Stream Request Event */
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2058:../uvc.c      **** 
2059:../uvc.c      ****         /* Set Video Stream Abort Event */
2060:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2061:../uvc.c      **** 	}
2062:../uvc.c      **** }
2063:../uvc.c      **** 
2064:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2065:../uvc.c      **** static void
2066:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2067:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2068:../uvc.c      ****         uint16_t             evdata  /* Event data */
2069:../uvc.c      ****         )
2070:../uvc.c      **** {
2071:../uvc.c      ****     switch (evtype)
2072:../uvc.c      ****     {
2073:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2074:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2075:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2076:../uvc.c      ****             debugData[2] = debugData[2]|0x01; //set bit0
2077:../uvc.c      ****             gpif_initialized = 0;
2078:../uvc.c      ****             streamingStarted = CyFalse;
2079:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2080:../uvc.c      ****             break;
2081:../uvc.c      **** 
2082:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2083:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2084:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2085:../uvc.c      ****             debugData[2] = debugData[2]|0x02; //set bit1
2086:../uvc.c      ****             gpif_initialized = 0;
2087:../uvc.c      ****             streamingStarted = CyFalse;
2088:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2089:../uvc.c      ****             break;
2090:../uvc.c      **** 
2091:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2092:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2093:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2094:../uvc.c      ****             debugData[2] = debugData[2]|0x04; //set bit2
2095:../uvc.c      ****             gpif_initialized = 0;
2096:../uvc.c      ****             isUsbConnected = CyFalse;
2097:../uvc.c      ****             streamingStarted = CyFalse;
2098:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2099:../uvc.c      ****             break;
2100:../uvc.c      **** 
2101:../uvc.c      **** #ifdef BACKFLOW_DETECT
2102:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2103:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2104:../uvc.c      ****             break;
2105:../uvc.c      **** #endif
2106:../uvc.c      **** 
2107:../uvc.c      ****         default:
2108:../uvc.c      ****             break;
2109:../uvc.c      ****     }
2110:../uvc.c      **** }
2111:../uvc.c      **** 
2112:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2113:../uvc.c      **** static CyBool_t
2114:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2115:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2116:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2117:../uvc.c      ****         )
2118:../uvc.c      **** {
2119:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2120:../uvc.c      ****     uint32_t status;
2121:../uvc.c      **** 
2122:../uvc.c      ****     /* Obtain Request Type and Request */
2123:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2124:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2125:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2126:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2127:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2128:../uvc.c      **** 
2129:../uvc.c      ****     /* Check for UVC Class Requests */
2130:../uvc.c      ****     switch (bmReqType)
2131:../uvc.c      ****     {
2132:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2133:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2134:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2135:../uvc.c      ****             switch (wIndex & 0xFF)
2136:../uvc.c      ****             {
2137:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2138:../uvc.c      ****                     {
2139:../uvc.c      ****                         uvcHandleReq = CyTrue;
2140:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2141:../uvc.c      ****                                 CYU3P_EVENT_OR);
2142:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2143:../uvc.c      ****                         {
2144:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2145:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2146:../uvc.c      ****                         }
2147:../uvc.c      ****                     }
2148:../uvc.c      ****                     break;
2149:../uvc.c      **** 
2150:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2151:../uvc.c      ****                     {
2152:../uvc.c      ****                         uvcHandleReq = CyTrue;
2153:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2154:../uvc.c      ****                                 CYU3P_EVENT_OR);
2155:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2156:../uvc.c      ****                         {
2157:../uvc.c      ****                             /* Error handling */
2158:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2159:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2160:../uvc.c      ****                         }
2161:../uvc.c      ****                     }
2162:../uvc.c      ****                     break;
2163:../uvc.c      **** 
2164:../uvc.c      ****                 default:
2165:../uvc.c      ****                     break;
2166:../uvc.c      ****             }
2167:../uvc.c      ****             break;
2168:../uvc.c      **** 
2169:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2170:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2171:../uvc.c      ****             {
2172:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2173:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2174:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2175:../uvc.c      ****                 {
2176:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2177:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2178:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2179:../uvc.c      ****                     gpif_initialized = 0;
2180:../uvc.c      ****                     streamingStarted = CyFalse;
2181:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2182:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2183:../uvc.c      ****                     CyU3PBusyWait (100);
2184:../uvc.c      **** 
2185:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2186:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2187:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2188:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2189:../uvc.c      ****                     CyU3PBusyWait (100);
2190:../uvc.c      **** 
2191:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2192:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2193:../uvc.c      ****                     uvcHandleReq = CyTrue;
2194:../uvc.c      ****                     /* Complete Control request handshake */
2195:../uvc.c      ****                     CyU3PUsbAckSetup ();
2196:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2197:../uvc.c      ****                     debugData[2] = debugData[2]|0x08; //set bit3
2198:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2199:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2200:../uvc.c      **** 
2201:../uvc.c      ****                 }
2202:../uvc.c      ****             }
2203:../uvc.c      ****             break;
2204:../uvc.c      **** 
2205:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2206:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2207:../uvc.c      ****             {
2208:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2209:../uvc.c      ****                 {
2210:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2211:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2212:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2213:../uvc.c      ****                 	 * has started. */
2214:../uvc.c      ****                     if (streamingStarted == CyTrue)
2215:../uvc.c      ****                     {
2216:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2217:../uvc.c      **** 
2218:../uvc.c      ****                         /* Disable the GPIF state machine. */
2219:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2220:../uvc.c      ****                         gpif_initialized = 0;
2221:../uvc.c      ****                         streamingStarted = CyFalse;
2222:../uvc.c      **** 
2223:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2224:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2225:../uvc.c      ****                         CyU3PBusyWait (100);
2226:../uvc.c      **** 
2227:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2228:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2229:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2230:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2231:../uvc.c      ****                         CyU3PBusyWait (100);
2232:../uvc.c      **** 
2233:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2234:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2235:../uvc.c      **** 
2236:../uvc.c      ****                         uvcHandleReq = CyTrue;
2237:../uvc.c      ****                         /* Complete Control request handshake */
2238:../uvc.c      ****                         CyU3PUsbAckSetup ();
2239:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2240:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2241:../uvc.c      ****                         debugData[2] = debugData[2]|0x10; //set bit0
2242:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2243:../uvc.c      ****                     }
2244:../uvc.c      ****                     else
2245:../uvc.c      ****                     {
2246:../uvc.c      ****                         uvcHandleReq = CyTrue;
2247:../uvc.c      ****                         CyU3PUsbAckSetup ();
2248:../uvc.c      ****                     }
2249:../uvc.c      ****                 }
2250:../uvc.c      ****             }
2251:../uvc.c      ****             break;
2252:../uvc.c      **** 
2253:../uvc.c      ****         default:
2254:../uvc.c      ****             break;
2255:../uvc.c      ****     }
2256:../uvc.c      **** 
2257:../uvc.c      ****     /* Return status of request handling to the USB driver */
2258:../uvc.c      ****     return uvcHandleReq;
2259:../uvc.c      **** }
2260:../uvc.c      **** 
2261:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2262:../uvc.c      **** 
2263:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2264:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2265:../uvc.c      ****  */
2266:../uvc.c      **** void
2267:../uvc.c      **** CyFxUvcApplnDmaCallback (
2268:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2269:../uvc.c      ****         CyU3PDmaCbType_t      type,
2270:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2271:../uvc.c      ****         )
2272:../uvc.c      **** {
2273:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2274:../uvc.c      **** #if 1
2275:../uvc.c      ****     CyU3PReturnStatus_t status;
2276:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2277:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2278:../uvc.c      **** 
2279:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2280:../uvc.c      ****     {
2281:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2282:../uvc.c      ****             {
2283:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2284:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2285:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2286:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2287:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2288:../uvc.c      ****                 	stiflag = 0x03;
2289:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2290:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2291:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2292:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2293:../uvc.c      ****                 }
2294:../uvc.c      **** #endif
2295:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2296:../uvc.c      ****                 fb++;
2297:../uvc.c      ****             }
2298:../uvc.c      ****             else
2299:../uvc.c      ****             {
2300:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2301:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2302:../uvc.c      ****                 pb++;
2303:../uvc.c      ****                 pbc = input->buffer_p.count;
2304:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2305:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2306:../uvc.c      ****                 //lineCount = 0; //res test
2307:../uvc.c      **** #if 1   //remove the still flag clearing here
2308:../uvc.c      ****                 if(stiflag == 0x0F){
2309:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2310:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2311:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2312:../uvc.c      ****                 	stiflag = 0xAA;
2313:../uvc.c      ****                 }
2314:../uvc.c      **** #endif
2315:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2316:../uvc.c      ****             }
2317:../uvc.c      **** 
2318:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2319:../uvc.c      ****             prodCount++;
2320:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2321:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2322:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2323:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2324:../uvc.c      ****             {
2325:../uvc.c      ****                 prodCount--;
2326:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2327:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2328:../uvc.c      ****             }
2329:../uvc.c      ****     }
2330:../uvc.c      **** #endif
2331:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2332:../uvc.c      ****     {
2333:../uvc.c      ****         consCount++;
2334:../uvc.c      ****         streamingStarted = CyTrue;
2335:../uvc.c      ****     }
2336:../uvc.c      **** }
2337:../uvc.c      **** 
2338:../uvc.c      **** /*
2339:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2340:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2341:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2342:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2343:../uvc.c      ****  * to commit the buffer.
2344:../uvc.c      ****  */
2345:../uvc.c      **** static uint8_t
2346:../uvc.c      **** CyFxUvcAppCommitEOF (
2347:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2348:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2349:../uvc.c      ****         )
2350:../uvc.c      **** {
2351:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2352:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2353:../uvc.c      **** 
2354:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2355:../uvc.c      **** 
2356:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2357:../uvc.c      ****     {
2358:../uvc.c      ****         switch (stateId)
2359:../uvc.c      ****         {
2360:../uvc.c      **** 
2361:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2362:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2363:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2364:../uvc.c      ****                 break;
2365:../uvc.c      **** 
2366:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2367:../uvc.c      ****                 socket = 0;
2368:../uvc.c      ****                 break;
2369:../uvc.c      **** 
2370:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2371:../uvc.c      ****                 socket = 1;
2372:../uvc.c      ****                 break;
2373:../uvc.c      **** 
2374:../uvc.c      ****             default:
2375:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2376:../uvc.c      ****                 /* Unexpected current state. Return error. */
2377:../uvc.c      ****             	//lineCount++;
2378:../uvc.c      ****             	return 1;
2379:../uvc.c      ****         }
2380:../uvc.c      ****     }
2381:../uvc.c      **** 
2382:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2383:../uvc.c      ****     {
2384:../uvc.c      ****         switch (stateId)
2385:../uvc.c      ****         {
2386:../uvc.c      **** #ifndef CAM720
2387:../uvc.c      **** #ifdef GPIFIIM
2388:../uvc.c      ****             case 13:
2389:../uvc.c      ****             case 24:
2390:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2391:../uvc.c      ****                 break;
2392:../uvc.c      **** 
2393:../uvc.c      ****             case 8:
2394:../uvc.c      ****                 socket = 0;
2395:../uvc.c      ****                 break;
2396:../uvc.c      **** 
2397:../uvc.c      ****             case 20:
2398:../uvc.c      ****                 socket = 1;
2399:../uvc.c      ****                 break;
2400:../uvc.c      **** #else
2401:../uvc.c      ****             case 11:
2402:../uvc.c      ****             case 18:
2403:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2404:../uvc.c      ****                 break;
2405:../uvc.c      **** 
2406:../uvc.c      ****             case 8:
2407:../uvc.c      ****                 socket = 0;
2408:../uvc.c      ****                 break;
2409:../uvc.c      **** 
2410:../uvc.c      ****             case 15:
2411:../uvc.c      ****                 socket = 1;
2412:../uvc.c      ****                 break;
2413:../uvc.c      **** #endif
2414:../uvc.c      **** #else
2415:../uvc.c      ****             case 11:
2416:../uvc.c      ****             case 18:
2417:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2418:../uvc.c      ****                 break;
2419:../uvc.c      **** 
2420:../uvc.c      ****             case 8:
2421:../uvc.c      ****                 socket = 0;
2422:../uvc.c      ****                 break;
2423:../uvc.c      **** 
2424:../uvc.c      ****             case 15:
2425:../uvc.c      ****                 socket = 1;
2426:../uvc.c      ****                 break;
2427:../uvc.c      **** 
2428:../uvc.c      **** #endif
2429:../uvc.c      ****              default:
2430:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2431:../uvc.c      ****                 /* Unexpected current state. Return error. */
2432:../uvc.c      ****                return 1;
2433:../uvc.c      ****         }
2434:../uvc.c      ****     }
2435:../uvc.c      **** 
2436:../uvc.c      ****     if (socket != 0xFF)
2437:../uvc.c      ****     {
2438:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2439:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2440:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2441:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2442:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2443:../uvc.c      ****         {
2444:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2445:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2446:../uvc.c      ****         }
2447:../uvc.c      ****     }
2448:../uvc.c      **** 
2449:../uvc.c      ****     return 0;
2450:../uvc.c      **** }
2451:../uvc.c      **** 
2452:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2453:../uvc.c      **** void
2454:../uvc.c      **** CyFxGpifCB (
2455:../uvc.c      ****         CyU3PGpifEventType event,
2456:../uvc.c      ****         uint8_t currentState
2457:../uvc.c      ****         )
2458:../uvc.c      **** {
2459:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2460:../uvc.c      ****     {
2461:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2462:../uvc.c      ****     	           in the UVC implementation. */
2463:../uvc.c      ****     	//hitFV = CyTrue;
2464:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2465:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2466:../uvc.c      ****     }
2467:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2468:../uvc.c      **** }
2469:../uvc.c      **** 
2470:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2471:../uvc.c      **** static void
2472:../uvc.c      **** CyFxUVCApplnDebugInit (
2473:../uvc.c      ****         void)
2474:../uvc.c      **** {
2475:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2476:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2477:../uvc.c      **** 
2478:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2479:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2480:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2481:../uvc.c      ****     {
2482:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2483:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2484:../uvc.c      ****     }
2485:../uvc.c      **** 
2486:../uvc.c      ****     /* Set UART Configuration */
2487:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2488:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2489:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2490:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2491:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2492:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2493:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2494:../uvc.c      **** 
2495:../uvc.c      ****     /* Set the UART configuration */
2496:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2497:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2498:../uvc.c      ****     {
2499:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2500:../uvc.c      ****     }
2501:../uvc.c      **** 
2502:../uvc.c      ****     /* Set the UART transfer */
2503:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2504:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2505:../uvc.c      ****     {
2506:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2507:../uvc.c      ****     }
2508:../uvc.c      **** 
2509:../uvc.c      ****     /* Initialize the Debug logger module. */
2510:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2511:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2512:../uvc.c      ****     {
2513:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2514:../uvc.c      ****     }
2515:../uvc.c      **** 
2516:../uvc.c      ****     /* Disable log message headers. */
2517:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2518:../uvc.c      **** }
2519:../uvc.c      **** 
2520:../uvc.c      **** /* I2C initialization. */
2521:../uvc.c      **** static void
2522:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2523:../uvc.c      **** {
2524:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2525:../uvc.c      ****     CyU3PReturnStatus_t status;
2526:../uvc.c      **** 
2527:../uvc.c      ****     status = CyU3PI2cInit ();
2528:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2529:../uvc.c      ****     {
2530:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2531:../uvc.c      ****         CyFxAppErrorHandler (status);
2532:../uvc.c      ****     }
2533:../uvc.c      **** 
2534:../uvc.c      ****     /*  Set I2C Configuration */
2535:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2536:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2537:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2538:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2539:../uvc.c      **** 
2540:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2541:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2542:../uvc.c      ****     {
2543:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2544:../uvc.c      ****         CyFxAppErrorHandler (status);
2545:../uvc.c      ****     }
2546:../uvc.c      **** }
2547:../uvc.c      **** 
2548:../uvc.c      **** #ifdef BACKFLOW_DETECT
2549:../uvc.c      **** static void CyFxUvcAppPibCallback (
2550:../uvc.c      ****         CyU3PPibIntrType cbType,
2551:../uvc.c      ****         uint16_t cbArg)
2552:../uvc.c      **** {
2553:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2554:../uvc.c      ****     {
2555:../uvc.c      ****         if (!back_flow_detected)
2556:../uvc.c      ****         {
2557:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2558:../uvc.c      ****             back_flow_detected = 1;
2559:../uvc.c      ****         }
2560:../uvc.c      ****     }
2561:../uvc.c      **** }
2562:../uvc.c      **** #endif
2563:../uvc.c      **** 
2564:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2565:../uvc.c      **** static void
2566:../uvc.c      **** CyFxUvcAppDebugCallback (
2567:../uvc.c      ****         CyU3PDmaChannel   *handle,
2568:../uvc.c      ****         CyU3PDmaCbType_t   type,
2569:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2570:../uvc.c      **** {
2571:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2572:../uvc.c      ****     {
2573:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2574:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2575:../uvc.c      ****     }
2576:../uvc.c      **** }
2577:../uvc.c      **** #endif
2578:../uvc.c      **** 
2579:../uvc.c      **** #if 0
2580:../uvc.c      **** static void CyFxAppIntEpCb(
2581:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2582:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2583:../uvc.c      **** 		uint8_t  ebNum)
2584:../uvc.c      **** 		{
2585:../uvc.c      **** 			//CyBool_t value;
2586:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2587:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2588:../uvc.c      **** 
2589:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2590:../uvc.c      **** 		}
2591:../uvc.c      **** #endif
2592:../uvc.c      **** 
2593:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2594:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2595:../uvc.c      ****    configures the DMA module for the UVC Application */
2596:../uvc.c      **** static void
2597:../uvc.c      **** CyFxUVCApplnInit (void)
2598:../uvc.c      **** {
2599:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2600:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2601:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2602:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2603:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2604:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2605:../uvc.c      **** 
2606:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2607:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2608:../uvc.c      **** 
2609:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2610:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2611:../uvc.c      **** #endif
2612:../uvc.c      **** 
2613:../uvc.c      ****     /* Create UVC event group */
2614:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2615:../uvc.c      ****     if (apiRetStatus != 0)
2616:../uvc.c      ****     {
2617:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2618:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2619:../uvc.c      ****     }
2620:../uvc.c      **** 
2621:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2622:../uvc.c      ****     CyFxUvcAppPTZInit ();
2623:../uvc.c      **** #endif
2624:../uvc.c      **** 
2625:../uvc.c      ****     isUsbConnected = CyFalse;
2626:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2627:../uvc.c      **** 
2628:../uvc.c      ****     /* Init the GPIO module */
2629:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2630:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2631:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2632:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2633:../uvc.c      ****     gpioClock.halfDiv    = 0;
2634:../uvc.c      **** 
2635:../uvc.c      ****     /* Initialize Gpio interface */
2636:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2637:../uvc.c      ****     if (apiRetStatus != 0)
2638:../uvc.c      ****     {
2639:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2640:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2641:../uvc.c      ****     }
2642:../uvc.c      **** 
2643:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2644:../uvc.c      ****      * must use GpioOverride to configure it */
2645:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2646:../uvc.c      ****     if (apiRetStatus != 0)
2647:../uvc.c      ****     {
2648:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2649:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2650:../uvc.c      ****     }
2651:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2652:../uvc.c      ****     if (apiRetStatus != 0)
2653:../uvc.c      ****     {
2654:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2655:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2656:../uvc.c      ****     }
2657:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2658:../uvc.c      ****     if (apiRetStatus != 0)
2659:../uvc.c      ****     {
2660:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2661:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2662:../uvc.c      ****     }
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2665:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2666:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2667:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2668:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2669:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2670:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2672:../uvc.c      ****     {
2673:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2674:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2675:../uvc.c      ****     }
2676:../uvc.c      **** 
2677:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2678:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2679:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2680:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2681:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2682:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2683:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2684:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2685:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2686:../uvc.c      ****     {
2687:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2688:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2689:../uvc.c      ****     }
2690:../uvc.c      **** 
2691:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2692:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2693:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2694:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2695:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2696:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2697:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2698:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2699:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2700:../uvc.c      ****     {
2701:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2702:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2703:../uvc.c      ****     }
2704:../uvc.c      **** 
2705:../uvc.c      ****     /* Initialize the P-port. */
2706:../uvc.c      ****     pibclock.clkDiv      = 2;
2707:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2708:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2709:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2710:../uvc.c      **** 
2711:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2712:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2713:../uvc.c      ****     {
2714:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2715:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2716:../uvc.c      ****     }
2717:../uvc.c      **** 
2718:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2719:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2720:../uvc.c      **** 
2721:../uvc.c      **** #ifdef BACKFLOW_DETECT
2722:../uvc.c      ****     back_flow_detected = 0;
2723:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2724:../uvc.c      **** #endif
2725:../uvc.c      **** 
2726:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2727:../uvc.c      ****     SensorReset ();
2728:../uvc.c      ****     CyU3PThreadSleep(5000);
2729:../uvc.c      ****     //SensorInit ();
2730:../uvc.c      **** 
2731:../uvc.c      ****     /* USB initialization. */
2732:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2733:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2734:../uvc.c      ****     {
2735:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2736:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2737:../uvc.c      ****     }
2738:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2739:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2740:../uvc.c      **** 
2741:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2742:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2743:../uvc.c      **** 
2744:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2745:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2746:../uvc.c      **** 
2747:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2748:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2749:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2750:../uvc.c      **** 
2751:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2752:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2753:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2754:../uvc.c      **** 
2755:../uvc.c      ****     /* Configuration descriptors. */
2756:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2757:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2758:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2759:../uvc.c      **** 
2760:../uvc.c      ****     /* String Descriptors */
2761:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2762:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2763:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2764:../uvc.c      **** 
2765:../uvc.c      ****     /* Configure the status interrupt endpoint.
2766:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2767:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2768:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2769:../uvc.c      ****      */
2770:../uvc.c      ****     endPointConfig.enable   = 1;
2771:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2772:../uvc.c      ****     endPointConfig.pcktSize = 64;
2773:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2774:../uvc.c      ****     endPointConfig.streams  = 0;
2775:../uvc.c      ****     endPointConfig.burstLen = 1;
2776:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2777:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2778:../uvc.c      ****     {
2779:../uvc.c      ****         /* Error Handling */
2780:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2781:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2782:../uvc.c      ****     }
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2785:../uvc.c      ****     dmaInterConfig.size           = 1024;
2786:../uvc.c      ****     dmaInterConfig.count          = 1;
2787:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2788:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2789:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2790:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2791:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2792:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2793:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2794:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2795:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2796:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2797:../uvc.c      ****             &dmaInterConfig);
2798:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2799:../uvc.c      ****     {
2800:../uvc.c      ****         /* Error handling */
2801:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2802:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2803:../uvc.c      ****     }
2804:../uvc.c      **** 
2805:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2806:../uvc.c      ****     if (glInterStaBuffer == 0)
2807:../uvc.c      ****     {
2808:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2809:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2810:../uvc.c      ****     }
2811:../uvc.c      **** 
2812:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2813:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2814:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2815:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2816:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2817:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2818:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2819:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2820:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2821:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2822:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2823:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2824:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2825:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2826:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2827:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2828:../uvc.c      ****             &dmaMultiConfig);
2829:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2830:../uvc.c      ****     {
2831:../uvc.c      ****         /* Error handling */
2832:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2833:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2834:../uvc.c      ****     }
2835:../uvc.c      **** 
2836:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2837:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2838:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2839:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2840:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2841:../uvc.c      ****      */
2842:../uvc.c      **** 
2843:../uvc.c      ****     endPointConfig.enable   = 1;
2844:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2845:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2846:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2847:../uvc.c      ****     endPointConfig.streams  = 0;
2848:../uvc.c      ****     endPointConfig.burstLen = 1;
2849:../uvc.c      **** 
2850:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2851:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2852:../uvc.c      ****     {
2853:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2854:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2855:../uvc.c      ****     }
2856:../uvc.c      **** 
2857:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2858:../uvc.c      **** 
2859:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2860:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2861:../uvc.c      ****     {
2862:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2863:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2864:../uvc.c      ****     }
2865:../uvc.c      **** 
2866:../uvc.c      ****     channelConfig.size           = 1024;
2867:../uvc.c      ****     channelConfig.count          = 1;
2868:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2869:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2870:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2871:../uvc.c      ****     channelConfig.prodHeader     = 0;
2872:../uvc.c      ****     channelConfig.prodFooter     = 0;
2873:../uvc.c      ****     channelConfig.consHeader     = 0;
2874:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2875:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2876:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2877:../uvc.c      **** 
2878:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2880:../uvc.c      ****     {
2881:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2883:../uvc.c      ****     }
2884:../uvc.c      **** 
2885:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2886:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2887:../uvc.c      ****     {
2888:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2889:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2890:../uvc.c      ****     }
2891:../uvc.c      **** 
2892:../uvc.c      ****     channelConfig.size           = 1024;
2893:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2894:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2895:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2896:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2897:../uvc.c      ****     channelConfig.prodHeader     = 0;
2898:../uvc.c      ****     channelConfig.prodFooter     = 0;
2899:../uvc.c      ****     channelConfig.consHeader     = 0;
2900:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2901:../uvc.c      ****     channelConfig.notification   = 0;
2902:../uvc.c      ****     channelConfig.cb             = 0;
2903:../uvc.c      **** 
2904:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2905:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2906:../uvc.c      ****     {
2907:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2909:../uvc.c      ****     }
2910:../uvc.c      **** 
2911:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2912:../uvc.c      ****     if (glDebugRspBuffer == 0)
2913:../uvc.c      ****     {
2914:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2915:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2916:../uvc.c      ****     }
2917:../uvc.c      **** #endif
2918:../uvc.c      **** 
2919:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2920:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2921:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2922:../uvc.c      ****     {
2923:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2924:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2925:../uvc.c      ****     }
2926:../uvc.c      **** 
2927:../uvc.c      ****     CyU3PBusyWait(100);
2928:../uvc.c      **** 
2929:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2930:../uvc.c      **** 
2931:../uvc.c      ****     endPointConfig.enable   = 1;
2932:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2933:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2934:../uvc.c      ****     {
2935:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2936:../uvc.c      ****     	endPointConfig.burstLen = 16;
2937:../uvc.c      ****     }
2938:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2939:../uvc.c      ****     {
2940:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2941:../uvc.c      ****     	endPointConfig.burstLen = 1;
2942:../uvc.c      ****     }
2943:../uvc.c      ****     endPointConfig.streams  = 0;
2944:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2946:../uvc.c      ****     {
2947:../uvc.c      ****         /* Error Handling */
2948:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2949:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2950:../uvc.c      ****     }
2951:../uvc.c      **** #if 0    //for still image method 3 using
2952:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2953:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2954:../uvc.c      ****     {
2955:../uvc.c      ****         /* Error Handling */
2956:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2957:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2958:../uvc.c      ****     }
2959:../uvc.c      **** #endif
2960:../uvc.c      **** 
2961:../uvc.c      **** }
2962:../uvc.c      **** 
2963:../uvc.c      **** /*
2964:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2965:../uvc.c      ****  * streaming session is started.
2966:../uvc.c      ****  */
2967:../uvc.c      **** static void
2968:../uvc.c      **** CyFxUvcAppGpifInit (
2969:../uvc.c      ****         void)
2970:../uvc.c      **** {
2971:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2972:../uvc.c      **** 
2973:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2974:../uvc.c      ****     {
2975:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2976:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2977:../uvc.c      ****     }
2978:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2979:../uvc.c      ****     {
2980:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2981:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2982:../uvc.c      ****     }
2983:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2984:../uvc.c      ****     {
2985:../uvc.c      ****         /* Error Handling */
2986:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2987:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2988:../uvc.c      ****     }
2989:../uvc.c      **** 
2990:../uvc.c      ****     /* Start the state machine from the designated start state. */
2991:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2992:../uvc.c      ****     {
2993:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2994:../uvc.c      ****     }
2995:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2996:../uvc.c      ****     {
2997:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2998:../uvc.c      ****     }
2999:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3000:../uvc.c      ****     {
3001:../uvc.c      ****         /* Error Handling */
3002:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3003:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3004:../uvc.c      ****     }
3005:../uvc.c      **** }
3006:../uvc.c      **** 
3007:../uvc.c      **** /*
3008:../uvc.c      ****  * Entry function for the UVC Application Thread
3009:../uvc.c      ****  */
3010:../uvc.c      **** 
3011:../uvc.c      **** uint32_t posTick;
3012:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3013:../uvc.c      **** 
3014:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  27              		.loc 1 3014 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
3015:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  32              		.loc 1 3015 0
  33 0000 28209FE5 		ldr	r2, .L2
3014:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  34              		.loc 1 3014 0
  35 0004 0030A0E1 		mov	r3, r0
  36 0008 10402DE9 		stmfd	sp!, {r4, lr}
  37              	.LCFI0:
  38              		.cfi_def_cfa_offset 8
  39              		.loc 1 3015 0
  40 000c 20109FE5 		ldr	r1, .L2+4
  41 0010 002092E5 		ldr	r2, [r2, #0]
  42 0014 0400A0E3 		mov	r0, #4
  43              	.LVL1:
  44              		.cfi_offset 14, -4
  45              		.cfi_offset 4, -8
  46 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  47              	.LVL2:
3016:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  48              		.loc 1 3016 0
  49 001c 14009FE5 		ldr	r0, .L2+8
  50 0020 2010A0E3 		mov	r1, #32
  51 0024 0020A0E3 		mov	r2, #0
3017:../uvc.c      **** }
  52              		.loc 1 3017 0
  53 0028 1040BDE8 		ldmfd	sp!, {r4, lr}
3016:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  54              		.loc 1 3016 0
  55 002c FEFFFFEA 		b	_txe_event_flags_set
  56              	.L3:
  57              		.align	2
  58              	.L2:
  59 0030 00000000 		.word	posTick
  60 0034 00000000 		.word	.LC0
  61 0038 00000000 		.word	.LANCHOR0
  62              		.cfi_endproc
  63              	.LFE18:
  65              		.align	2
  66              		.global	I2cAppThread_Entry
  68              	I2cAppThread_Entry:
  69              	.LFB26:
3018:../uvc.c      **** 
3019:../uvc.c      **** 
3020:../uvc.c      **** void
3021:../uvc.c      **** UVCAppThread_Entry (
3022:../uvc.c      ****         uint32_t input)
3023:../uvc.c      **** {
3024:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3025:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3026:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3027:../uvc.c      ****     uint8_t i = 0;
3028:../uvc.c      ****     uint32_t flag;
3029:../uvc.c      ****     uint32_t prinflag = 0;
3030:../uvc.c      **** static uint8_t IMcount = 0;
3031:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3032:../uvc.c      ****     uint32_t frameCnt = 0;
3033:../uvc.c      **** #endif
3034:../uvc.c      ****     /* Initialize the Uart Debug Module */
3035:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3036:../uvc.c      **** 
3037:../uvc.c      ****     /* Initialize the I2C interface */
3038:../uvc.c      **** 	while (i++ < 6){
3039:../uvc.c      **** 		CyU3PThreadSleep(500);
3040:../uvc.c      **** 	}
3041:../uvc.c      **** 
3042:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3043:../uvc.c      **** 
3044:../uvc.c      ****     /* Initialize the UVC Application */
3045:../uvc.c      ****     CyFxUVCApplnInit ();
3046:../uvc.c      ****     /*
3047:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3048:../uvc.c      **** 
3049:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3050:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3051:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3052:../uvc.c      **** 
3053:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3054:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3055:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3056:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3057:../uvc.c      **** 
3058:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3059:../uvc.c      ****        of handling the abort request.
3060:../uvc.c      ****      */
3061:../uvc.c      **** 
3062:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3063:../uvc.c      ****     //CyU3PThreadSleep(1000);
3064:../uvc.c      **** 
3065:../uvc.c      ****     for (;;)
3066:../uvc.c      ****     {
3067:../uvc.c      ****         /* Waiting for the Video Stream Event */
3068:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3069:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3070:../uvc.c      ****         {
3071:../uvc.c      ****         	debugData[1] = debugData[1]&0xFF;
3072:../uvc.c      ****         	debugData[1] = debugData[1]|0x01;
3073:../uvc.c      **** #if 0 //test for new firmware no video bring up
3074:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3075:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3076:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3077:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3078:../uvc.c      ****             {
3079:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3080:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3081:../uvc.c      ****                 {
3082:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3083:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3084:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3085:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3086:../uvc.c      **** #endif
3087:../uvc.c      **** #endif
3088:../uvc.c      ****                     }
3089:../uvc.c      ****                 else
3090:../uvc.c      ****                 {
3091:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3092:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3093:../uvc.c      **** #ifdef USB_LOWRES_IMG
3094:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3095:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3096:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3097:../uvc.c      **** #endif
3098:../uvc.c      **** #endif
3099:../uvc.c      ****                 }
3100:../uvc.c      **** 
3101:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3102:../uvc.c      ****                 prodCount++;
3103:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3104:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3105:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3106:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3107:../uvc.c      ****                 {
3108:../uvc.c      ****                     prodCount--;
3109:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3110:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3111:../uvc.c      ****                 }
3112:../uvc.c      ****             }
3113:../uvc.c      **** #endif
3114:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3115:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3116:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3117:../uvc.c      ****             {
3118:../uvc.c      ****             	if(0&&(prinflag == 0)){
3119:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3120:../uvc.c      ****             		prinflag = 1;
3121:../uvc.c      ****             	}
3122:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3123:../uvc.c      ****             	debugData[0]++;
3124:../uvc.c      ****             	debugData[1] = debugData[1]|0x82;
3125:../uvc.c      ****             	fb=0;
3126:../uvc.c      ****             	pb=0;
3127:../uvc.c      ****             	pbc=0;
3128:../uvc.c      ****                 prodCount = 0;
3129:../uvc.c      ****                 consCount = 0;
3130:../uvc.c      ****                 hitFV     = CyFalse;
3131:../uvc.c      **** 
3132:../uvc.c      **** #ifdef BACKFLOW_DETECT
3133:../uvc.c      ****                 back_flow_detected = 0;
3134:../uvc.c      **** #endif
3135:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3136:../uvc.c      ****                 frameCnt++;
3137:../uvc.c      **** #endif
3138:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3139:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3140:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3141:../uvc.c      ****                 //}
3142:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3143:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3144:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3145:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3146:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3147:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3148:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3149:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3150:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3151:../uvc.c      ****                 		stiflag = 0xFF;
3152:../uvc.c      ****                 		IMcount = 0;
3153:../uvc.c      ****                 	}
3154:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3155:../uvc.c      **** 
3156:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3157:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3158:../uvc.c      ****                 		stiflag = 0x0F;
3159:../uvc.c      ****                 		IMcount = 0;
3160:../uvc.c      ****                 		}
3161:../uvc.c      ****                  		/*if(IMcount > 0x4){
3162:../uvc.c      ****                 			stiflag = 0x0F;
3163:../uvc.c      ****                 			IMcount = 0;
3164:../uvc.c      ****                 		}*/
3165:../uvc.c      **** 
3166:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3167:../uvc.c      ****                     //CyU3PThreadSleep(400);
3168:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3169:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3170:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3171:../uvc.c      **** 
3172:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3173:../uvc.c      ****                 	{
3174:../uvc.c      ****                     switch (setRes)
3175:../uvc.c      ****                      {
3176:../uvc.c      ****                  	case 1: //1944
3177:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3178:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3179:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3180:../uvc.c      ****                  		break;
3181:../uvc.c      ****                  	case 2: //1080
3182:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3183:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3184:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3185:../uvc.c      ****                  		break;
3186:../uvc.c      ****                  	case 3: //720
3187:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3188:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3189:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3190:../uvc.c      ****                  		break;
3191:../uvc.c      ****                  	case 4: //VGA
3192:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3193:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3194:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3195:../uvc.c      ****                  		break;
3196:../uvc.c      ****                  	default:
3197:../uvc.c      ****                  		break;
3198:../uvc.c      ****                      }
3199:../uvc.c      ****                     IMcount = 0;
3200:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3201:../uvc.c      ****                 	stiflag = 0x0;
3202:../uvc.c      ****                 	}
3203:../uvc.c      ****                 }
3204:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3205:../uvc.c      ****                 /* Reset the DMA channel. */
3206:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3207:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3208:../uvc.c      ****                 {
3209:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3210:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3211:../uvc.c      ****                 }
3212:../uvc.c      **** 
3213:../uvc.c      ****                 /* Start Channel Immediately */
3214:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3215:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3216:../uvc.c      ****                 {
3217:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3218:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3219:../uvc.c      ****                 }
3220:../uvc.c      **** 
3221:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3222:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3223:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3224:../uvc.c      ****                 }
3225:../uvc.c      ****         }
3226:../uvc.c      ****         else
3227:../uvc.c      ****         {
3228:../uvc.c      ****             /* If we have a stream abort request pending. */
3229:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3230:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3231:../uvc.c      ****             {
3232:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
3233:../uvc.c      ****             	debugData[1] = debugData[1]|0x04;
3234:../uvc.c      ****             	hitFV     = CyFalse;
3235:../uvc.c      ****                 prodCount = 0;
3236:../uvc.c      ****                 consCount = 0;
3237:../uvc.c      ****                 if(0&&(prinflag == 0)){
3238:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3239:../uvc.c      ****                 	prinflag = 1;
3240:../uvc.c      ****                 }
3241:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3242:../uvc.c      ****                 fb=0;
3243:../uvc.c      ****                 pb=0;
3244:../uvc.c      ****                 pbc=0;
3245:../uvc.c      **** 
3246:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3247:../uvc.c      ****                 {
3248:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3249:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3250:../uvc.c      ****                     {
3251:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3252:../uvc.c      ****                     }
3253:../uvc.c      **** 
3254:../uvc.c      ****                     /* Flush the Endpoint memory */
3255:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3256:../uvc.c      ****                 }
3257:../uvc.c      **** 
3258:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3259:../uvc.c      ****             }
3260:../uvc.c      ****             else
3261:../uvc.c      ****             {
3262:../uvc.c      ****                 if(stream_start == CyTrue){
3263:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
3264:../uvc.c      ****                     		&flag, CYU3P_NO_WAIT != CY_U3P_SUCCESS)){
3265:../uvc.c      ****     					if(1||clearFeatureRqtReceived){
3266:../uvc.c      ****     						CyU3PThreadSleep(3000);
3267:../uvc.c      ****     						//if(stream_start == CyTrue){
3268:../uvc.c      ****     							streamingRecove = CyTrue;
3269:../uvc.c      ****     							debugData[3]++;
3270:../uvc.c      ****     						//}
3271:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
3272:../uvc.c      ****     						stream_start == CyFalse;
3273:../uvc.c      ****     					}
3274:../uvc.c      ****                     }
3275:../uvc.c      **** 
3276:../uvc.c      ****                 }
3277:../uvc.c      **** 
3278:../uvc.c      **** 
3279:../uvc.c      ****             	/* We are essentially idle at this point. Wait for the reception of a start streaming 
3280:../uvc.c      **** 
3281:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3282:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3283:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3284:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3285:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3286:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3287:../uvc.c      ****                 {
3288:../uvc.c      ****                     /* Error handling */
3289:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3290:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3291:../uvc.c      ****                 }
3292:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
3293:../uvc.c      ****             	debugData[1] = debugData[1]|0x08;
3294:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3295:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3296:../uvc.c      ****                 {
3297:../uvc.c      **** #if 0
3298:../uvc.c      ****                 	//for start up of the AF Lens
3299:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3300:../uvc.c      ****                     CyU3PThreadSleep(500);
3301:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3302:../uvc.c      ****                     CyU3PThreadSleep(500);
3303:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3304:../uvc.c      ****                    	CyU3PThreadSleep(300);
3305:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3306:../uvc.c      ****                     CyU3PThreadSleep(500);
3307:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3308:../uvc.c      ****                     CyU3PThreadSleep(500);
3309:../uvc.c      **** #endif
3310:../uvc.c      **** #if 1
3311:../uvc.c      ****                     if(streamingRecove){
3312:../uvc.c      ****                     switch (setRes)
3313:../uvc.c      ****                     {
3314:../uvc.c      ****                      	case 1: //1944
3315:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
3316:../uvc.c      ****                      		CyU3PThreadSleep(100);
3317:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
3318:../uvc.c      ****                      		break;
3319:../uvc.c      ****                      	case 2: //1080
3320:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
3321:../uvc.c      ****                      		CyU3PThreadSleep(100);
3322:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
3323:../uvc.c      ****                      		break;
3324:../uvc.c      ****                      	case 3: //720
3325:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
3326:../uvc.c      ****                      		CyU3PThreadSleep(100);
3327:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
3328:../uvc.c      ****                      		break;
3329:../uvc.c      ****                      	case 4: //VGA
3330:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
3331:../uvc.c      ****                      		CyU3PThreadSleep(100);
3332:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
3333:../uvc.c      ****                      		break;
3334:../uvc.c      ****                      	default:
3335:../uvc.c      ****                      		break;
3336:../uvc.c      **** 
3337:../uvc.c      ****                     }
3338:../uvc.c      ****                     streamingRecove = CyFalse;
3339:../uvc.c      ****                     }
3340:../uvc.c      **** #endif
3341:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3342:../uvc.c      **** 
3343:../uvc.c      ****                     gpif_initialized = CyTrue;
3344:../uvc.c      ****                     stream_start = CyTrue;
3345:../uvc.c      ****                     CyU3PThreadSleep(200);
3346:../uvc.c      ****                     
3347:../uvc.c      ****                 }
3348:../uvc.c      ****                 else
3349:../uvc.c      ****                 {
3350:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3351:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3352:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3353:../uvc.c      ****                 }
3354:../uvc.c      ****             }
3355:../uvc.c      ****         }
3356:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3357:../uvc.c      **** 
3358:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3359:../uvc.c      ****         CyU3PThreadRelinquish ();
3360:../uvc.c      ****     }
3361:../uvc.c      **** }
3362:../uvc.c      **** 
3363:../uvc.c      **** /*
3364:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3365:../uvc.c      ****  */
3366:../uvc.c      **** 
3367:../uvc.c      **** static void
3368:../uvc.c      **** UVCHandleProcessingUnitRqts (
3369:../uvc.c      ****         void)
3370:../uvc.c      **** {
3371:../uvc.c      ****     uint8_t CtrlAdd;
3372:../uvc.c      **** #ifdef DbgInfo
3373:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3374:../uvc.c      **** #endif
3375:../uvc.c      ****     switch (wValue)
3376:../uvc.c      ****     {
3377:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3378:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3379:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3380:../uvc.c      ****     		break;
3381:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3382:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3383:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3384:../uvc.c      ****     		break;
3385:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3386:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3387:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3388:../uvc.c      **** 			break;
3389:../uvc.c      **** 
3390:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3391:../uvc.c      **** 
3392:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3393:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3394:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3395:../uvc.c      ****       		break;
3396:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3397:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3398:../uvc.c      ****      		ControlHandle(HueCtlID5);
3399:../uvc.c      ****      		break;
3400:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3401:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3402:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3403:../uvc.c      ****           		break;
3404:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3405:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3406:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3407:../uvc.c      ****           		break;
3408:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3409:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3410:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3411:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3412:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3413:../uvc.c      ****     		break;
3414:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3415:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3416:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3417:../uvc.c      ****     		break;
3418:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3419:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3420:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3421:../uvc.c      ****     		break;
3422:../uvc.c      **** 
3423:../uvc.c      ****         default:
3424:../uvc.c      ****             /*
3425:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3426:../uvc.c      ****              * other controls.
3427:../uvc.c      ****              */
3428:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3429:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3430:../uvc.c      ****             break;
3431:../uvc.c      ****     }
3432:../uvc.c      **** }
3433:../uvc.c      **** 
3434:../uvc.c      **** /*
3435:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3436:../uvc.c      ****  */
3437:../uvc.c      **** static void
3438:../uvc.c      **** UVCHandleCameraTerminalRqts (
3439:../uvc.c      ****         void)
3440:../uvc.c      **** {
3441:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3442:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3443:../uvc.c      ****     uint16_t readCount;
3444:../uvc.c      ****     uint16_t zoomVal;
3445:../uvc.c      ****     int32_t  panVal, tiltVal;
3446:../uvc.c      ****     CyBool_t sendData = CyFalse;
3447:../uvc.c      **** #endif
3448:../uvc.c      ****     uint8_t CtrlAdd;
3449:../uvc.c      **** 
3450:../uvc.c      ****     switch (wValue)
3451:../uvc.c      ****     {
3452:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3453:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3454:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3455:../uvc.c      ****     		break;
3456:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3457:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3458:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3459:../uvc.c      ****     		break;
3460:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3461:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3462:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3463:../uvc.c      **** 			break;
3464:../uvc.c      **** 
3465:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3466:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3467:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3468:../uvc.c      **** 			break;
3469:../uvc.c      **** 
3470:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3471:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3472:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3473:../uvc.c      ****       		break;
3474:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3475:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3476:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3477:../uvc.c      ****      		break;
3478:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3479:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3480:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3481:../uvc.c      ****           		break;
3482:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3483:../uvc.c      ****           		break;
3484:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3485:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3486:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3487:../uvc.c      ****      		break;
3488:../uvc.c      **** 
3489:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3490:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3491:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3492:../uvc.c      ****     		break;
3493:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3494:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3495:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3496:../uvc.c      ****     		break;
3497:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3498:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3499:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3500:../uvc.c      ****     		break;
3501:../uvc.c      **** 
3502:../uvc.c      ****         default:
3503:../uvc.c      ****             /*
3504:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3505:../uvc.c      ****              * other controls.
3506:../uvc.c      ****              */
3507:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3508:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3509:../uvc.c      ****             break;
3510:../uvc.c      ****     }
3511:../uvc.c      **** 
3512:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3513:../uvc.c      ****     switch (wValue)
3514:../uvc.c      ****     {
3515:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3516:../uvc.c      ****             switch (bRequest)
3517:../uvc.c      ****             {
3518:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3519:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3520:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3521:../uvc.c      ****                     break;
3522:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3523:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3524:../uvc.c      ****                     sendData = CyTrue;
3525:../uvc.c      ****                     break;
3526:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3527:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3528:../uvc.c      ****                     sendData = CyTrue;
3529:../uvc.c      ****                     break;
3530:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3531:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3532:../uvc.c      ****                     sendData = CyTrue;
3533:../uvc.c      ****                     break;
3534:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3535:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3536:../uvc.c      ****                     sendData = CyTrue;
3537:../uvc.c      ****                     break;
3538:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3539:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3540:../uvc.c      ****                     sendData = CyTrue;
3541:../uvc.c      ****                     break;
3542:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3543:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3544:../uvc.c      ****                             glEp0Buffer, &readCount);
3545:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3546:../uvc.c      ****                     {
3547:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3548:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3549:../uvc.c      ****                     }
3550:../uvc.c      ****                     break;
3551:../uvc.c      ****                 default:
3552:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3553:../uvc.c      ****                     break;
3554:../uvc.c      ****             }
3555:../uvc.c      **** 
3556:../uvc.c      ****             if (sendData)
3557:../uvc.c      ****             {
3558:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3559:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3560:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3561:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3562:../uvc.c      ****             }
3563:../uvc.c      ****             break;
3564:../uvc.c      **** 
3565:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3566:../uvc.c      ****             switch (bRequest)
3567:../uvc.c      ****             {
3568:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3569:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3570:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3571:../uvc.c      ****                     break;
3572:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3573:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3574:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3575:../uvc.c      ****                     sendData = CyTrue;
3576:../uvc.c      ****                     break;
3577:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3578:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3579:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3580:../uvc.c      ****                     sendData = CyTrue;
3581:../uvc.c      ****                     break;
3582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3583:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3584:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3585:../uvc.c      ****                     sendData = CyTrue;
3586:../uvc.c      ****                     break;
3587:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3588:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3589:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3590:../uvc.c      ****                     sendData = CyTrue;
3591:../uvc.c      ****                     break;
3592:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3593:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3594:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3595:../uvc.c      ****                     sendData = CyTrue;
3596:../uvc.c      ****                     break;
3597:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3598:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3599:../uvc.c      ****                             glEp0Buffer, &readCount);
3600:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3601:../uvc.c      ****                     {
3602:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3603:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3604:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3605:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3606:../uvc.c      **** 
3607:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3608:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3609:../uvc.c      ****                     }
3610:../uvc.c      ****                     break;
3611:../uvc.c      ****                 default:
3612:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3613:../uvc.c      ****                     break;
3614:../uvc.c      ****             }
3615:../uvc.c      **** 
3616:../uvc.c      ****             if (sendData)
3617:../uvc.c      ****             {
3618:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3619:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3620:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3621:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3622:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3623:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3624:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3625:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3626:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3627:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3628:../uvc.c      ****             }
3629:../uvc.c      ****             break;
3630:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3631:../uvc.c      ****         default:
3632:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3633:../uvc.c      ****             break;
3634:../uvc.c      ****     }
3635:../uvc.c      **** #endif
3636:../uvc.c      **** }
3637:../uvc.c      **** 
3638:../uvc.c      **** /*
3639:../uvc.c      ****  * Handler for UVC Interface control requests.
3640:../uvc.c      ****  */
3641:../uvc.c      **** static void
3642:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3643:../uvc.c      ****         void)
3644:../uvc.c      **** {
3645:../uvc.c      **** 
3646:../uvc.c      ****     switch (wValue)
3647:../uvc.c      ****     {
3648:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3649:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3650:../uvc.c      ****     		break;
3651:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3652:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3653:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3654:../uvc.c      ****     		break;
3655:../uvc.c      ****     	default:
3656:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3657:../uvc.c      ****      		break;
3658:../uvc.c      ****     }
3659:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3660:../uvc.c      **** 
3661:../uvc.c      **** }
3662:../uvc.c      **** 
3663:../uvc.c      **** /*
3664:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3665:../uvc.c      ****  */
3666:../uvc.c      **** static void
3667:../uvc.c      **** UVCHandleExtensionUnitRqts (
3668:../uvc.c      ****         void)
3669:../uvc.c      **** {
3670:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3671:../uvc.c      **** 
3672:../uvc.c      **** #ifdef DbgInfo
3673:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3674:../uvc.c      **** #endif
3675:../uvc.c      ****     switch (wValue)
3676:../uvc.c      ****     {
3677:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3678:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3679:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3680:../uvc.c      ****     		break;
3681:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3682:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3683:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3684:../uvc.c      ****     		break;
3685:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3686:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3687:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3688:../uvc.c      ****      		break;
3689:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3690:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3691:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3692:../uvc.c      ****     		break;
3693:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3694:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3695:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3696:../uvc.c      ****     		break;
3697:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3698:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3699:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3700:../uvc.c      ****      		break;
3701:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3702:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3703:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3704:../uvc.c      ****     		break;
3705:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3706:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3707:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3708:../uvc.c      ****     		break;
3709:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3710:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3711:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3712:../uvc.c      ****      		break;
3713:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3714:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3715:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3716:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3717:../uvc.c      ****     		}else/* no support for 1080p camera */
3718:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3719:../uvc.c      ****     		break;
3720:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3721:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3722:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3723:../uvc.c      ****     		break;
3724:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3725:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3726:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3727:../uvc.c      ****     		break;
3728:../uvc.c      **** 
3729:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3730:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3731:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3732:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3733:../uvc.c      ****     		break;
3734:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3735:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3736:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3737:../uvc.c      ****     		//break;
3738:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3739:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3740:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3741:../uvc.c      ****     		break;
3742:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3743:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3744:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3745:../uvc.c      ****     		break;
3746:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3747:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3748:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3749:../uvc.c      ****     		break;
3750:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3751:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3752:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3753:../uvc.c      ****     		break;
3754:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3755:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3756:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3757:../uvc.c      ****     		break;
3758:../uvc.c      ****    	default:
3759:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3760:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3761:../uvc.c      ****     		break;
3762:../uvc.c      ****     }
3763:../uvc.c      **** 
3764:../uvc.c      **** }
3765:../uvc.c      **** 
3766:../uvc.c      **** /*
3767:../uvc.c      ****  * Handler for the video streaming control requests.
3768:../uvc.c      ****  */
3769:../uvc.c      **** static void
3770:../uvc.c      **** UVCHandleVideoStreamingRqts (
3771:../uvc.c      ****         void)
3772:../uvc.c      **** {
3773:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3774:../uvc.c      ****     uint16_t readCount;
3775:../uvc.c      **** 
3776:../uvc.c      ****     switch (wValue)
3777:../uvc.c      ****     {
3778:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3779:../uvc.c      ****             switch (bRequest)
3780:../uvc.c      ****             {
3781:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3782:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3783:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3784:../uvc.c      ****                     break;
3785:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3786:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3787:../uvc.c      ****                     glEp0Buffer[1] = 0;
3788:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3789:../uvc.c      ****                     break;
3790:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3791:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3792:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3793:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3794:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3795:../uvc.c      ****                     {
3796:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3797:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3798:../uvc.c      **** 
3799:../uvc.c      ****                     }
3800:../uvc.c      ****                     else
3801:../uvc.c      ****                     {
3802:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3803:../uvc.c      ****                     }
3804:../uvc.c      ****                     break;
3805:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3806:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3807:../uvc.c      ****                             glCommitCtrl, &readCount);
3808:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3809:../uvc.c      ****                     {
3810:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3811:../uvc.c      ****                         {
3812:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3813:../uvc.c      ****                                active data structure. */
3814:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3815:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3816:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3817:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3818:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3819:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3820:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3821:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3822:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3823:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3824:../uvc.c      **** #if 0
3825:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3826:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3827:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3828:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3829:../uvc.c      **** #endif
3830:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3831:../uvc.c      ****                        }
3832:../uvc.c      ****                     }
3833:../uvc.c      ****                     break;
3834:../uvc.c      ****                 default:
3835:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3836:../uvc.c      ****                     break;
3837:../uvc.c      ****             }
3838:../uvc.c      ****             break;
3839:../uvc.c      **** 
3840:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3841:../uvc.c      ****             switch (bRequest)
3842:../uvc.c      ****             {
3843:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3844:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3845:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3846:../uvc.c      ****                     break;
3847:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3848:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3849:../uvc.c      ****                     glEp0Buffer[1] = 0;
3850:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3851:../uvc.c      ****                     break;
3852:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3853:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3854:../uvc.c      ****                     {
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3856:../uvc.c      ****                     }
3857:../uvc.c      ****                     else
3858:../uvc.c      ****                     {
3859:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3860:../uvc.c      ****                     }
3861:../uvc.c      ****                     break;
3862:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3863:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3864:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3865:../uvc.c      ****                        */
3866:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3867:../uvc.c      ****                             glCommitCtrl, &readCount);
3868:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3869:../uvc.c      ****                     {
3870:../uvc.c      ****                         switch (glCommitCtrl[3])
3871:../uvc.c      ****                          {
3872:../uvc.c      ****                          	case 1: //1944
3873:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3874:../uvc.c      ****                          		CyU3PThreadSleep(500);
3875:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3876:../uvc.c      ****                          		break;
3877:../uvc.c      ****                          	case 2: //1080
3878:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3879:../uvc.c      ****                          		CyU3PThreadSleep(500);
3880:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3881:../uvc.c      ****                          		break;
3882:../uvc.c      ****                          	case 3: //720
3883:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3884:../uvc.c      ****                          		CyU3PThreadSleep(500);
3885:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3886:../uvc.c      ****                          		break;
3887:../uvc.c      ****                          	case 4: //VGA
3888:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3889:../uvc.c      ****                          		CyU3PThreadSleep(500);
3890:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3891:../uvc.c      ****                          		break;
3892:../uvc.c      ****                          	default:
3893:../uvc.c      ****                          		break;
3894:../uvc.c      ****                          }
3895:../uvc.c      ****                         setRes = glCommitCtrl[3];
3896:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3897:../uvc.c      **** 
3898:../uvc.c      **** #if 0
3899:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3900:../uvc.c      ****                         {
3901:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3902:../uvc.c      ****                         }
3903:../uvc.c      ****                         else
3904:../uvc.c      ****                         {
3905:../uvc.c      ****                             SensorScaling_VGA ();
3906:../uvc.c      ****                         }
3907:../uvc.c      **** #endif
3908:../uvc.c      ****                         /* We can start streaming video now. */
3909:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3910:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3911:../uvc.c      ****                         {
3912:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3913:../uvc.c      ****                         }
3914:../uvc.c      ****                     }
3915:../uvc.c      ****                     break;
3916:../uvc.c      **** 
3917:../uvc.c      ****                 default:
3918:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3919:../uvc.c      ****                     break;
3920:../uvc.c      ****             }
3921:../uvc.c      ****             break;
3922:../uvc.c      **** 
3923:../uvc.c      **** /* still image streaming handler */
3924:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3925:../uvc.c      ****                 switch (bRequest)
3926:../uvc.c      ****                 {
3927:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3928:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3929:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3930:../uvc.c      ****                         break;
3931:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3932:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3933:../uvc.c      ****                         glEp0Buffer[1] = 0;
3934:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3935:../uvc.c      ****                         break;
3936:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3937:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3938:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3939:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3940:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3941:../uvc.c      ****                         {
3942:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3943:../uvc.c      ****                         }
3944:../uvc.c      ****                         else
3945:../uvc.c      ****                         {
3946:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3947:../uvc.c      ****                         }
3948:../uvc.c      ****                         break;
3949:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3950:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3951:../uvc.c      ****                                 glCommitCtrl, &readCount);
3952:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3953:../uvc.c      ****                         {
3954:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3955:../uvc.c      ****                             {
3956:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3957:../uvc.c      ****                                    active data structure. */
3958:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3959:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3960:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3961:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3962:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3963:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3964:../uvc.c      ****                             }
3965:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3966:../uvc.c      ****                         }
3967:../uvc.c      ****                         break;
3968:../uvc.c      ****                     default:
3969:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3970:../uvc.c      ****                         break;
3971:../uvc.c      ****                 }
3972:../uvc.c      ****                 break;
3973:../uvc.c      **** 
3974:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3975:../uvc.c      ****                 switch (bRequest)
3976:../uvc.c      ****                 {
3977:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3978:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3980:../uvc.c      ****                         break;
3981:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3983:../uvc.c      ****                         glEp0Buffer[1] = 0;
3984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3985:../uvc.c      ****                         break;
3986:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3988:../uvc.c      ****                         {
3989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3990:../uvc.c      ****                         }
3991:../uvc.c      ****                         else
3992:../uvc.c      ****                         {
3993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3994:../uvc.c      ****                         }
3995:../uvc.c      ****                         break;
3996:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3997:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3998:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3999:../uvc.c      ****                            */
4000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4001:../uvc.c      ****                                 glCommitCtrl, &readCount);
4002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4003:../uvc.c      ****                         {
4004:../uvc.c      ****     #if 0
4005:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4006:../uvc.c      ****                             {
4007:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4008:../uvc.c      ****                             }
4009:../uvc.c      ****                             else
4010:../uvc.c      ****                             {
4011:../uvc.c      ****                                 SensorScaling_VGA ();
4012:../uvc.c      ****                             }
4013:../uvc.c      ****                             /* We can start streaming video now. */
4014:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4015:../uvc.c      **** 
4016:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4017:../uvc.c      ****                             {
4018:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4019:../uvc.c      ****                             }
4020:../uvc.c      **** 	#endif
4021:../uvc.c      ****                            switch (glCommitCtrl[1])
4022:../uvc.c      ****                              {
4023:../uvc.c      ****                              	case 4: //1944
4024:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4025:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4026:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4027:../uvc.c      ****                              		break;
4028:../uvc.c      ****                              	case 3: //1080
4029:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4030:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4031:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4032:../uvc.c      ****                              		break;
4033:../uvc.c      ****                              	case 2: //720
4034:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4035:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4036:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4037:../uvc.c      ****                              		break;
4038:../uvc.c      ****                             	case 1: //VGA
4039:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4040:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4041:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4042:../uvc.c      ****                              		break;
4043:../uvc.c      ****                               	default:
4044:../uvc.c      ****                              		break;
4045:../uvc.c      ****                              }
4046:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4047:../uvc.c      **** 
4048:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4049:../uvc.c      **** 
4050:../uvc.c      ****                         }
4051:../uvc.c      ****                         break;
4052:../uvc.c      **** 
4053:../uvc.c      ****                     default:
4054:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4055:../uvc.c      ****                         break;
4056:../uvc.c      ****                 }
4057:../uvc.c      ****                 break;
4058:../uvc.c      **** 
4059:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4060:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4061:../uvc.c      ****             	switch (bRequest)
4062:../uvc.c      ****                 {
4063:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4064:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4065:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4066:../uvc.c      ****                         break;
4067:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4068:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4069:../uvc.c      ****                         glEp0Buffer[1] = 0;
4070:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4071:../uvc.c      ****                         break;
4072:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4073:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4074:../uvc.c      ****                         {
4075:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4076:../uvc.c      ****                         }
4077:../uvc.c      ****                         else
4078:../uvc.c      ****                         {
4079:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4080:../uvc.c      ****                         }
4081:../uvc.c      ****                         break;
4082:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4083:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4084:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4085:../uvc.c      ****                            */
4086:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4087:../uvc.c      ****                                 glCommitCtrl, &readCount);
4088:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4089:../uvc.c      ****                         {
4090:../uvc.c      ****     #if 1
4091:../uvc.c      ****                             /* We can start still streaming video now. */
4092:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4093:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4094:../uvc.c      ****                             {
4095:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4096:../uvc.c      ****                             }
4097:../uvc.c      ****     #endif
4098:../uvc.c      ****                             else{
4099:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4100:../uvc.c      ****                             //stillcont = 0;
4101:../uvc.c      ****                             }
4102:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4103:../uvc.c      ****                         }else{
4104:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4105:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4106:../uvc.c      ****                         }
4107:../uvc.c      ****                         break;
4108:../uvc.c      **** 
4109:../uvc.c      ****                     default:
4110:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4111:../uvc.c      ****                         break;
4112:../uvc.c      ****                 }
4113:../uvc.c      ****                 break;
4114:../uvc.c      **** 
4115:../uvc.c      ****         default:
4116:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4117:../uvc.c      ****             break;
4118:../uvc.c      ****     }
4119:../uvc.c      **** }
4120:../uvc.c      **** 
4121:../uvc.c      **** /*
4122:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4123:../uvc.c      ****  */
4124:../uvc.c      **** void
4125:../uvc.c      **** UVCAppEP0Thread_Entry (
4126:../uvc.c      ****         uint32_t input)
4127:../uvc.c      **** {
4128:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4129:../uvc.c      ****     uint32_t eventFlag;
4130:../uvc.c      **** 	CyBool_t value;
4131:../uvc.c      **** 	CyBool_t *valueptr = &value;
4132:../uvc.c      **** 
4133:../uvc.c      **** 
4134:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4135:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4136:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4137:../uvc.c      **** 
4138:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4139:../uvc.c      **** #endif
4140:../uvc.c      **** 
4141:../uvc.c      ****     /* for interrupt status test */
4142:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4143:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4144:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4145:../uvc.c      **** 
4146:../uvc.c      ****     for (;;)
4147:../uvc.c      ****     {
4148:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4149:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4150:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4151:../uvc.c      ****         {
4152:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4153:../uvc.c      ****             if (!isUsbConnected)
4154:../uvc.c      ****             {
4155:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4156:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4157:../uvc.c      ****                 {
4158:../uvc.c      ****                     isUsbConnected = CyTrue;
4159:../uvc.c      ****                 }
4160:../uvc.c      ****             }
4161:../uvc.c      **** //#ifdef DbgInfo
4162:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4163:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4164:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4165:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4166:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4167:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4168:../uvc.c      **** //#endif
4169:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4170:../uvc.c      ****             {
4171:../uvc.c      ****             	switch ((wIndex >> 8))
4172:../uvc.c      ****                 {
4173:../uvc.c      **** 
4174:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4175:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4176:../uvc.c      ****                         break;
4177:../uvc.c      **** 
4178:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4179:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4180:../uvc.c      ****                         break;
4181:../uvc.c      **** 
4182:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4183:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4184:../uvc.c      ****                         break;
4185:../uvc.c      **** 
4186:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4187:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4188:../uvc.c      ****                         break;
4189:../uvc.c      **** 
4190:../uvc.c      ****                     default:
4191:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4192:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4193:../uvc.c      ****                         break;
4194:../uvc.c      ****                 }
4195:../uvc.c      ****             }
4196:../uvc.c      **** 
4197:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4198:../uvc.c      ****             {
4199:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4200:../uvc.c      **** 
4201:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4202:../uvc.c      ****                 {
4203:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4204:../uvc.c      ****                 }
4205:../uvc.c      ****                 else
4206:../uvc.c      ****                 {
4207:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4208:../uvc.c      ****                 }
4209:../uvc.c      ****             }
4210:../uvc.c      **** 
4211:../uvc.c      ****             /* handle interrupt status event */
4212:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4213:../uvc.c      ****             {
4214:../uvc.c      **** 
4215:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4216:../uvc.c      ****             	/** preparing interrupt status data **/
4217:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4218:../uvc.c      **** 
4219:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4220:../uvc.c      **** 
4221:../uvc.c      **** #if 0 //for real button
4222:../uvc.c      **** 				if(value&&(!snapButFlag)){
4223:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4224:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4225:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4226:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4227:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4228:../uvc.c      **** 
4229:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4230:../uvc.c      **** 					interStabuf.size   = 1024;
4231:../uvc.c      **** 					interStabuf.status = 0;
4232:../uvc.c      **** 
4233:../uvc.c      **** 					interStabuf.count = 4;
4234:../uvc.c      **** 
4235:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4237:../uvc.c      **** 
4238:../uvc.c      **** 					/** send a interrupt status data **/
4239:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4240:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4241:../uvc.c      **** 					{
4242:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4243:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4244:../uvc.c      **** 					}
4245:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4246:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4247:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4248:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4249:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4250:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4251:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4252:../uvc.c      **** 
4253:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4254:../uvc.c      **** 					interStabuf.size   = 1024;
4255:../uvc.c      **** 					interStabuf.status = 0;
4256:../uvc.c      **** 
4257:../uvc.c      **** 					interStabuf.count = 4;
4258:../uvc.c      **** 
4259:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4260:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4261:../uvc.c      **** 
4262:../uvc.c      **** 					/** send a interrupt status data **/
4263:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4264:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4265:../uvc.c      **** 					{
4266:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4267:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4268:../uvc.c      **** 					}
4269:../uvc.c      **** 
4270:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4271:../uvc.c      **** 					stiflag = 0xFF;
4272:../uvc.c      **** 				}
4273:../uvc.c      **** #else			//for botton simulation
4274:../uvc.c      **** 				if(snapButFlag == 0x0f){
4275:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4276:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4277:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4278:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4279:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4280:../uvc.c      **** 
4281:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4282:../uvc.c      **** 					interStabuf.size   = 1024;
4283:../uvc.c      **** 					interStabuf.status = 0;
4284:../uvc.c      **** 
4285:../uvc.c      **** 					interStabuf.count = 4;
4286:../uvc.c      **** 
4287:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4288:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4289:../uvc.c      **** 
4290:../uvc.c      **** 					/** send a interrupt status data **/
4291:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4292:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4293:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4294:../uvc.c      **** 					{
4295:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4296:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4297:../uvc.c      **** 					}
4298:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4299:../uvc.c      **** 
4300:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4301:../uvc.c      **** 				}else if(!snapButFlag){
4302:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4303:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4304:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4305:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4306:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4307:../uvc.c      **** 
4308:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4309:../uvc.c      **** 					interStabuf.size   = 1024;
4310:../uvc.c      **** 					interStabuf.status = 0;
4311:../uvc.c      **** 
4312:../uvc.c      **** 					interStabuf.count = 4;
4313:../uvc.c      **** 
4314:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4315:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4316:../uvc.c      **** 
4317:../uvc.c      **** 					/** send a interrupt status data **/
4318:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4319:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4320:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4321:../uvc.c      **** 					{
4322:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4323:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4324:../uvc.c      **** 					}
4325:../uvc.c      **** 
4326:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4327:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4328:../uvc.c      **** 				}
4329:../uvc.c      **** #endif
4330:../uvc.c      **** 
4331:../uvc.c      ****             }
4332:../uvc.c      **** 
4333:../uvc.c      **** 
4334:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4335:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4336:../uvc.c      ****             {
4337:../uvc.c      ****                 /* Get the command buffer */
4338:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4339:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4340:../uvc.c      ****                 {
4341:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4342:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4343:../uvc.c      ****                 }
4344:../uvc.c      **** 
4345:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4346:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4347:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4348:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4349:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4350:../uvc.c      ****                  * register value high byte and register value low byte.
4351:../uvc.c      ****                  */
4352:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4353:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4354:../uvc.c      ****                 {
4355:../uvc.c      ****                     if (dmaInfo.count == 3)
4356:../uvc.c      ****                     {
4357:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4358:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4359:../uvc.c      ****                         dmaInfo.count = 3;
4360:../uvc.c      ****                     }
4361:../uvc.c      ****                     else if (dmaInfo.count == 4)
4362:../uvc.c      ****                     {
4363:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4364:../uvc.c      ****                         {
4365:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4366:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4367:../uvc.c      ****                         }
4368:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4369:../uvc.c      ****                     }
4370:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4371:../uvc.c      ****                 }
4372:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4373:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4374:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4375:../uvc.c      ****                  */
4376:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4377:../uvc.c      ****                 {
4378:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4379:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4380:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4381:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4382:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4383:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4384:../uvc.c      ****                         	break;
4385:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4386:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4387:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4388:../uvc.c      ****                         	break;*/
4389:../uvc.c      ****                     dmaInfo.count -= 2;
4390:../uvc.c      ****                 }
4391:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4392:../uvc.c      ****                 else
4393:../uvc.c      ****                 {
4394:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4395:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4396:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4397:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4398:../uvc.c      ****                 }
4399:../uvc.c      **** 
4400:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4401:../uvc.c      ****                 dmaInfo.size   = 1024;
4402:../uvc.c      ****                 dmaInfo.status = 0;
4403:../uvc.c      **** 
4404:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4405:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4406:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4407:../uvc.c      ****                 {
4408:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4409:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4410:../uvc.c      ****                 }
4411:../uvc.c      **** 
4412:../uvc.c      ****                 /* Wait until the response has gone out. */
4413:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4414:../uvc.c      **** 
4415:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4416:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4417:../uvc.c      ****                 {
4418:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4419:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4420:../uvc.c      ****                 }
4421:../uvc.c      ****             }
4422:../uvc.c      **** #endif
4423:../uvc.c      ****         }
4424:../uvc.c      ****         /* Allow other ready threads to run. */
4425:../uvc.c      ****         CyU3PThreadRelinquish ();
4426:../uvc.c      ****     }
4427:../uvc.c      **** }
4428:../uvc.c      **** 
4429:../uvc.c      **** /*
4430:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4431:../uvc.c      ****  * added 10/2013
4432:../uvc.c      ****  */
4433:../uvc.c      **** /*
4434:../uvc.c      **** static uint8_t timeDelay[64] = {
4435:../uvc.c      **** 
4436:../uvc.c      **** };
4437:../uvc.c      **** */
4438:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  70              		.loc 1 4438 0
  71              		.cfi_startproc
  72              		@ args = 0, pretend = 0, frame = 8
  73              		@ frame_needed = 0, uses_anonymous_args = 0
  74              	.LVL3:
  75 003c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 36
4439:../uvc.c      **** 
4440:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4441:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4442:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4443:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4444:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4445:../uvc.c      **** 	uint32_t flag = 0;
4446:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4447:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4448:../uvc.c      **** 	uint8_t i;
4449:../uvc.c      **** 	uint16_t delaytime;
4450:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4451:../uvc.c      **** 
4452:../uvc.c      **** #if 0 //for test the command queue
4453:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4454:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4455:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4456:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4457:../uvc.c      **** 		lcCmdDes += 1;
4458:../uvc.c      **** 	}
4459:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4460:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4461:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4462:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4463:../uvc.c      **** 		lcCmdDes += 1;
4464:../uvc.c      **** 	}
4465:../uvc.c      **** 
4466:../uvc.c      **** #endif
4467:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4468:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  78              		.loc 1 4468 0
  79 0040 68229FE5 		ldr	r2, .L30
4445:../uvc.c      **** 	uint32_t flag = 0;
  80              		.loc 1 4445 0
  81 0044 0040A0E3 		mov	r4, #0
  82              		.cfi_offset 14, -4
  83              		.cfi_offset 11, -8
  84              		.cfi_offset 10, -12
  85              		.cfi_offset 9, -16
  86              		.cfi_offset 8, -20
  87              		.cfi_offset 7, -24
  88              		.cfi_offset 6, -28
  89              		.cfi_offset 5, -32
  90              		.cfi_offset 4, -36
4438:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  91              		.loc 1 4438 0
  92 0048 1CD04DE2 		sub	sp, sp, #28
  93              	.LCFI2:
  94              		.cfi_def_cfa_offset 64
  95              		.loc 1 4468 0
  96 004c FAEFA0E3 		mov	lr, #1000
  97 0050 2CC084E2 		add	ip, r4, #44
  98 0054 0B30A0E3 		mov	r3, #11
  99 0058 0410A0E1 		mov	r1, r4
 100 005c 50029FE5 		ldr	r0, .L30+4
 101              	.LVL4:
 102 0060 00E08DE5 		str	lr, [sp, #0]
 103 0064 0CC08DE5 		str	ip, [sp, #12]
4445:../uvc.c      **** 	uint32_t flag = 0;
 104              		.loc 1 4445 0
 105 0068 14408DE5 		str	r4, [sp, #20]
 106              	.LVL5:
 107              		.loc 1 4468 0
 108 006c 04408DE5 		str	r4, [sp, #4]
 109 0070 08408DE5 		str	r4, [sp, #8]
 110 0074 FEFFFFEB 		bl	_txe_timer_create
4469:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 111              		.loc 1 4469 0
 112 0078 FEFFFFEB 		bl	_tx_time_get
 113 007c 34129FE5 		ldr	r1, .L30+8
 114 0080 34529FE5 		ldr	r5, .L30+12
 115 0084 0020A0E1 		mov	r2, r0
 116 0088 0400A0E3 		mov	r0, #4
 117 008c FEFFFFEB 		bl	CyU3PDebugPrint
4470:../uvc.c      **** 	CyU3PThreadSleep(50);
 118              		.loc 1 4470 0
 119 0090 3200A0E3 		mov	r0, #50
 120 0094 FEFFFFEB 		bl	_tx_thread_sleep
4471:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
 121              		.loc 1 4471 0
 122 0098 14029FE5 		ldr	r0, .L30+4
 123 009c FEFFFFEB 		bl	_txe_timer_activate
4472:../uvc.c      **** 
4473:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 124              		.loc 1 4473 0
 125 00a0 000000EA 		b	.L5
 126              	.L6:
4474:../uvc.c      ****         /* Allow other ready threads to run. */
4475:../uvc.c      **** 
4476:../uvc.c      ****         CyU3PThreadRelinquish ();
 127              		.loc 1 4476 0
 128 00a4 FEFFFFEB 		bl	_txe_thread_relinquish
 129              	.L5:
4473:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 130              		.loc 1 4473 0 discriminator 1
 131 00a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 132 00ac 000052E3 		cmp	r2, #0
 133 00b0 FBFFFF0A 		beq	.L6
4477:../uvc.c      **** 	}
4478:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 134              		.loc 1 4478 0
 135 00b4 00029FE5 		ldr	r0, .L30+12
 136 00b8 00129FE5 		ldr	r1, .L30+16
 137 00bc 103090E5 		ldr	r3, [r0, #16]
 138 00c0 0400A0E3 		mov	r0, #4
 139 00c4 3C3093E5 		ldr	r3, [r3, #60]
 140 00c8 FEFFFFEB 		bl	CyU3PDebugPrint
 141 00cc F0719FE5 		ldr	r7, .L30+20
 142 00d0 F0619FE5 		ldr	r6, .L30+24
 143 00d4 F0B19FE5 		ldr	fp, .L30+28
4479:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4480:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4481:../uvc.c      **** 	//CyU3PThreadSleep(100);
4482:../uvc.c      **** 	//SetCurCmd();
4483:../uvc.c      **** 	/*********** the loop of the thread ***********/
4484:../uvc.c      **** 	for(;;){
4485:../uvc.c      **** 
4486:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 144              		.loc 1 4486 0
 145 00d8 0080E0E3 		mvn	r8, #0
4487:../uvc.c      **** /*  // for test GPIO output
4488:../uvc.c      **** 		if(trigger)
4489:../uvc.c      **** 		{
4490:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4491:../uvc.c      **** 			{
4492:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4493:../uvc.c      **** 			}
4494:../uvc.c      **** 
4495:../uvc.c      **** 		}else{
4496:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4497:../uvc.c      **** 			{
4498:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4499:../uvc.c      **** 			}
4500:../uvc.c      **** 
4501:../uvc.c      **** 		}
4502:../uvc.c      **** */
4503:../uvc.c      **** 		if(streamingRecove){//start stream again after the USB-pipe reset
4504:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
4505:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
4506:../uvc.c      **** 
4507:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
4508:../uvc.c      ****             {
4509:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
4510:../uvc.c      ****             }
4511:../uvc.c      **** 		}
4512:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4513:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4514:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4515:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4516:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4517:../uvc.c      **** 				i = 0;
4518:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
4519:../uvc.c      **** 					i++;
4520:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4521:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4522:../uvc.c      **** 				}
4523:../uvc.c      **** #if 0
4524:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4525:../uvc.c      **** 				i = lcStaDes->curNum;
4526:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4527:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4528:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4529:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4530:../uvc.c      **** 
4531:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4532:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4533:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4534:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4535:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4536:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4537:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4538:../uvc.c      **** #endif
4539:../uvc.c      **** 				//}
4540:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4541:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4542:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4543:../uvc.c      **** 				/* setting delay */
4544:../uvc.c      **** 				delaytime = 300;
4545:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4546:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4547:../uvc.c      **** 			} //end of the if condition statment
4548:../uvc.c      **** #endif
4549:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4550:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4551:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4552:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4553:../uvc.c      **** 
4554:../uvc.c      **** 				/*
4555:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4556:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4557:../uvc.c      **** 				*/
4558:../uvc.c      **** 
4559:../uvc.c      **** 				/* find a available command */
4560:../uvc.c      **** 				i = 0;
4561:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4562:../uvc.c      **** 					i++;
4563:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4564:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4565:../uvc.c      **** 				}
4566:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4567:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4568:../uvc.c      **** 					i = lcCmdDes->curNum;
4569:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4570:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4571:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4572:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4573:../uvc.c      **** #if 1
4574:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4575:../uvc.c      **** 						case 0x20:
4576:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4577:../uvc.c      **** 							delaytime = 500;
4578:../uvc.c      **** 							break;
4579:../uvc.c      **** 						case 0x21:
4580:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4581:../uvc.c      **** 							delaytime = 500;
4582:../uvc.c      **** 							break;
4583:../uvc.c      **** 						case 0x22:
4584:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4585:../uvc.c      **** 							delaytime = 300;
4586:../uvc.c      **** 							break;
4587:../uvc.c      **** 						case 0x23:
4588:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4589:../uvc.c      **** 							delaytime = 300;
4590:../uvc.c      **** 							break;
4591:../uvc.c      **** 						default:
4592:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4593:../uvc.c      **** 							break;
4594:../uvc.c      **** 					}
4595:../uvc.c      **** #endif
4596:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4597:../uvc.c      **** 					/** timer's ticket modify **/
4598:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4599:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4600:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4601:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4602:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4603:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4604:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4605:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4606:../uvc.c      **** #endif
4607:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4608:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4609:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4610:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4611:../uvc.c      **** 						}else{
4612:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4613:../uvc.c      **** 						}
4614:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4615:../uvc.c      **** 					}else{
4616:../uvc.c      **** 						lcCmdDes->curNum ++;
4617:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 146              		.loc 1 4617 0
 147 00dc 0F90A0E3 		mov	r9, #15
 148              	.L24:
4486:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 149              		.loc 1 4486 0
 150 00e0 2010A0E3 		mov	r1, #32
 151 00e4 D8019FE5 		ldr	r0, .L30+20
 152 00e8 0320A0E3 		mov	r2, #3
 153 00ec 14308DE2 		add	r3, sp, #20
 154 00f0 00808DE5 		str	r8, [sp, #0]
 155 00f4 FEFFFFEB 		bl	_txe_event_flags_get
4503:../uvc.c      **** 		if(streamingRecove){//start stream again after the USB-pipe reset
 156              		.loc 1 4503 0
 157 00f8 281097E5 		ldr	r1, [r7, #40]
 158 00fc 000051E3 		cmp	r1, #0
 159 0100 5200001A 		bne	.L28
 160              	.L7:
4512:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 161              		.loc 1 4512 0
 162 0104 1C0096E5 		ldr	r0, [r6, #28]
 163 0108 0010E0E3 		mvn	r1, #0
 164 010c FEFFFFEB 		bl	_txe_mutex_get
 165              	.LVL6:
4518:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 166              		.loc 1 4518 0
 167 0110 102096E5 		ldr	r2, [r6, #16]
 168 0114 3C3092E5 		ldr	r3, [r2, #60]
 169 0118 000053E3 		cmp	r3, #0
 170 011c 0300001A 		bne	.L8
 171              	.LVL7:
 172              	.L9:
4519:../uvc.c      **** 					i++;
 173              		.loc 1 4519 0
 174 0120 01A083E2 		add	sl, r3, #1
 175 0124 FF300AE2 		and	r3, sl, #255
 176              	.LVL8:
4518:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 177              		.loc 1 4518 0
 178 0128 3F0053E3 		cmp	r3, #63
 179 012c FBFFFF9A 		bls	.L9
 180              	.LVL9:
 181              	.L8:
4549:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 182              		.loc 1 4549 0
 183 0130 1C0096E5 		ldr	r0, [r6, #28]
 184 0134 FEFFFFEB 		bl	_txe_mutex_put
 185              	.LVL10:
4551:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 186              		.loc 1 4551 0
 187 0138 1C0095E5 		ldr	r0, [r5, #28]
 188 013c 0010E0E3 		mvn	r1, #0
 189 0140 FEFFFFEB 		bl	_txe_mutex_get
4552:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 190              		.loc 1 4552 0
 191 0144 104095E5 		ldr	r4, [r5, #16]
 192              	.LVL11:
4561:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 193              		.loc 1 4561 0
 194 0148 3C2094E5 		ldr	r2, [r4, #60]
 195 014c 000052E3 		cmp	r2, #0
 196 0150 0800001A 		bne	.L10
 197 0154 0030A0E3 		mov	r3, #0
 198              	.LVL12:
 199              	.L11:
4563:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 200              		.loc 1 4563 0
 201 0158 344094E5 		ldr	r4, [r4, #52]
 202              	.LVL13:
4562:../uvc.c      **** 					i++;
 203              		.loc 1 4562 0
 204 015c 01C083E2 		add	ip, r3, #1
4561:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 205              		.loc 1 4561 0
 206 0160 3C2094E5 		ldr	r2, [r4, #60]
4562:../uvc.c      **** 					i++;
 207              		.loc 1 4562 0
 208 0164 FF300CE2 		and	r3, ip, #255
 209              	.LVL14:
4561:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 210              		.loc 1 4561 0
 211 0168 3F0053E3 		cmp	r3, #63
 212 016c 00005293 		cmpls	r2, #0
 213 0170 F8FFFF0A 		beq	.L11
 214 0174 104085E5 		str	r4, [r5, #16]
 215              	.LVL15:
 216              	.L10:
4567:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 217              		.loc 1 4567 0
 218 0178 000052E3 		cmp	r2, #0
 219 017c 2D00000A 		beq	.L12
 220              	.LVL16:
4569:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 221              		.loc 1 4569 0
 222 0180 0120D4E5 		ldrb	r2, [r4, #1]	@ zero_extendqisi2
4574:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 223              		.loc 1 4574 0
 224 0184 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4569:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 225              		.loc 1 4569 0
 226 0188 821082E0 		add	r1, r2, r2, asl #1
 227 018c 813084E0 		add	r3, r4, r1, asl #1
4574:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 228              		.loc 1 4574 0
 229 0190 20E040E2 		sub	lr, r0, #32
4570:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 230              		.loc 1 4570 0
 231 0194 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
4569:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 232              		.loc 1 4569 0
 233 0198 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 234              	.LVL17:
4571:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 235              		.loc 1 4571 0
 236 019c 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 237              	.LVL18:
4572:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 238              		.loc 1 4572 0
 239 01a0 B8A0D3E1 		ldrh	sl, [r3, #8]
 240              	.LVL19:
4574:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 241              		.loc 1 4574 0
 242 01a4 03005EE3 		cmp	lr, #3
 243 01a8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 244 01ac 1E0000EA 		b	.L13
 245              	.L18:
 246 01b0 1C020000 		.word	.L14
 247 01b4 0C020000 		.word	.L15
 248 01b8 C0010000 		.word	.L17
 249 01bc C0010000 		.word	.L17
 250              	.L17:
4588:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 251              		.loc 1 4588 0
 252 01c0 8230A0E3 		mov	r3, #130
 253 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 254              	.LVL20:
4590:../uvc.c      **** 							break;
 255              		.loc 1 4590 0
 256 01c8 4B1FA0E3 		mov	r1, #300
 257              	.LVL21:
 258              	.L19:
4599:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 259              		.loc 1 4599 0
 260 01cc 0020A0E3 		mov	r2, #0
 261 01d0 DC009FE5 		ldr	r0, .L30+4
 262 01d4 FEFFFFEB 		bl	_txe_timer_change
4600:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 263              		.loc 1 4600 0
 264 01d8 D4009FE5 		ldr	r0, .L30+4
 265 01dc FEFFFFEB 		bl	_txe_timer_activate
 266              	.LVL22:
4607:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 267              		.loc 1 4607 0
 268 01e0 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 269 01e4 02C0D4E5 		ldrb	ip, [r4, #2]	@ zero_extendqisi2
 270 01e8 0A005CE1 		cmp	ip, sl
4616:../uvc.c      **** 						lcCmdDes->curNum ++;
 271              		.loc 1 4616 0
 272 01ec 01A08A12 		addne	sl, sl, #1
 273 01f0 01A0C415 		strneb	sl, [r4, #1]
 274              		.loc 1 4617 0
 275 01f4 3C908415 		strne	r9, [r4, #60]
4607:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 276              		.loc 1 4607 0
 277 01f8 1E00000A 		beq	.L29
 278              	.LVL23:
 279              	.L23:
4618:../uvc.c      **** 					}
4619:../uvc.c      **** 				}else{
4620:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4621:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4622:../uvc.c      **** 				}
4623:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 280              		.loc 1 4623 0
 281 01fc 1C0095E5 		ldr	r0, [r5, #28]
 282 0200 FEFFFFEB 		bl	_txe_mutex_put
 283              	.LVL24:
4624:../uvc.c      **** 			}
4625:../uvc.c      **** /*
4626:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4627:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4628:../uvc.c      **** */
4629:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4630:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4631:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4632:../uvc.c      **** #endif
4633:../uvc.c      **** 
4634:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4635:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4636:../uvc.c      **** #if 0
4637:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4638:../uvc.c      **** 
4639:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4640:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4641:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4642:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4643:../uvc.c      **** 			    i = 0;
4644:../uvc.c      **** 				 switch(cmdCopyIdx)
4645:../uvc.c      **** 				 {
4646:../uvc.c      **** 					 case BrgtCtlID1:
4647:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4648:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4649:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4650:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4651:../uvc.c      **** 							 i++;
4652:../uvc.c      **** 						 }
4653:../uvc.c      **** 						 else{
4654:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4655:../uvc.c      **** 						 }
4656:../uvc.c      **** 
4657:../uvc.c      **** 						 CyU3PBusyWait(500);
4658:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4659:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4660:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4661:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4662:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4663:../uvc.c      **** 						 }
4664:../uvc.c      **** 						 else{
4665:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4666:../uvc.c      **** 						 }
4667:../uvc.c      **** 						 break;
4668:../uvc.c      **** 					 case HueCtlID5:
4669:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4670:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4671:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4672:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4673:../uvc.c      **** 						 }
4674:../uvc.c      **** 						 else{
4675:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4676:../uvc.c      **** 						 }
4677:../uvc.c      **** 						 break;
4678:../uvc.c      **** 					 case SaturCtlID6:
4679:../uvc.c      **** 					 case WBTLevCtlID10:
4680:../uvc.c      **** 					 default:
4681:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4682:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4683:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4684:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4685:../uvc.c      **** 						 }
4686:../uvc.c      **** 						 else{
4687:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4688:../uvc.c      **** 						 }
4689:../uvc.c      **** 						 break;
4690:../uvc.c      **** 				 }
4691:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4692:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4693:../uvc.c      **** 			}
4694:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4695:../uvc.c      **** #endif
4696:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4697:../uvc.c      **** 		/* Allow other ready threads to run. */
4698:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4699:../uvc.c      **** 			CyU3PThreadRelinquish ();
 284              		.loc 1 4699 0
 285 0204 FEFFFFEB 		bl	_txe_thread_relinquish
4700:../uvc.c      **** 		}
 286              		.loc 1 4700 0
 287 0208 B4FFFFEA 		b	.L24
 288              	.LVL25:
 289              	.L15:
4580:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 290              		.loc 1 4580 0
 291 020c 5230A0E3 		mov	r3, #82
 292 0210 FEFFFFEB 		bl	SensorSetIrisControl
 293              	.LVL26:
4582:../uvc.c      **** 							break;
 294              		.loc 1 4582 0
 295 0214 7D1FA0E3 		mov	r1, #500
 296 0218 EBFFFFEA 		b	.L19
 297              	.LVL27:
 298              	.L14:
4576:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 299              		.loc 1 4576 0
 300 021c 8230A0E3 		mov	r3, #130
 301 0220 FEFFFFEB 		bl	SensorSetIrisControl
 302              	.LVL28:
4578:../uvc.c      **** 							break;
 303              		.loc 1 4578 0
 304 0224 7D1FA0E3 		mov	r1, #500
 305 0228 E7FFFFEA 		b	.L19
 306              	.LVL29:
 307              	.L13:
4592:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 308              		.loc 1 4592 0
 309 022c FEFFFFEB 		bl	SensorSetControl
 310              	.LVL30:
 311 0230 0A10A0E1 		mov	r1, sl
4593:../uvc.c      **** 							break;
 312              		.loc 1 4593 0
 313 0234 E4FFFFEA 		b	.L19
 314              	.LVL31:
 315              	.L12:
4620:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 316              		.loc 1 4620 0
 317 0238 FA1FA0E3 		mov	r1, #1000
 318 023c 70009FE5 		ldr	r0, .L30+4
 319 0240 FEFFFFEB 		bl	_txe_timer_change
4621:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 320              		.loc 1 4621 0
 321 0244 68009FE5 		ldr	r0, .L30+4
 322 0248 FEFFFFEB 		bl	_txe_timer_activate
 323 024c EAFFFFEA 		b	.L23
 324              	.LVL32:
 325              	.L28:
 326              	.LBB10:
4505:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 327              		.loc 1 4505 0
 328 0250 0020A0E3 		mov	r2, #0
 329 0254 68009FE5 		ldr	r0, .L30+20
 330 0258 0110A0E3 		mov	r1, #1
 331 025c FEFFFFEB 		bl	_txe_event_flags_set
 332              	.LVL33:
4507:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
 333              		.loc 1 4507 0
 334 0260 002050E2 		subs	r2, r0, #0
 335 0264 A6FFFF0A 		beq	.L7
4509:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 336              		.loc 1 4509 0
 337 0268 60109FE5 		ldr	r1, .L30+32
 338 026c 0400A0E3 		mov	r0, #4
 339              	.LVL34:
 340 0270 FEFFFFEB 		bl	CyU3PDebugPrint
 341              	.LVL35:
 342 0274 A2FFFFEA 		b	.L7
 343              	.LVL36:
 344              	.L29:
 345              	.LBE10:
4609:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 346              		.loc 1 4609 0
 347 0278 0030D4E5 		ldrb	r3, [r4, #0]	@ zero_extendqisi2
4608:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 348              		.loc 1 4608 0
 349 027c 00E0A0E3 		mov	lr, #0
4609:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 350              		.loc 1 4609 0
 351 0280 230053E3 		cmp	r3, #35
4610:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 352              		.loc 1 4610 0
 353 0284 24304382 		subhi	r3, r3, #36
 354 0288 83308380 		addhi	r3, r3, r3, asl #1
4612:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 355              		.loc 1 4612 0
 356 028c 83308390 		addls	r3, r3, r3, asl #1
4610:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 357              		.loc 1 4610 0
 358 0290 83318B80 		addhi	r3, fp, r3, asl #3
4612:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 359              		.loc 1 4612 0
 360 0294 83318B90 		addls	r3, fp, r3, asl #3
4608:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 361              		.loc 1 4608 0
 362 0298 3CE084E5 		str	lr, [r4, #60]
4610:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 363              		.loc 1 4610 0
 364 029c 10E0C385 		strhib	lr, [r3, #16]
4612:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 365              		.loc 1 4612 0
 366 02a0 90E1C395 		strlsb	lr, [r3, #400]
4614:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 367              		.loc 1 4614 0
 368 02a4 344094E5 		ldr	r4, [r4, #52]
 369              	.LVL37:
 370 02a8 104085E5 		str	r4, [r5, #16]
 371 02ac D2FFFFEA 		b	.L23
 372              	.L31:
 373              		.align	2
 374              	.L30:
 375 02b0 00000000 		.word	I2CCmdCb
 376 02b4 00000000 		.word	I2CCmdTimer
 377 02b8 18000000 		.word	.LC1
 378 02bc 00000000 		.word	cmdQu
 379 02c0 2C000000 		.word	.LC2
 380 02c4 00000000 		.word	.LANCHOR0
 381 02c8 00000000 		.word	statQu
 382 02cc 00000000 		.word	.LANCHOR1
 383 02d0 50000000 		.word	.LC3
 384              		.cfi_endproc
 385              	.LFE26:
 387              		.align	2
 389              	CyFxUVCApplnUSBEventCB:
 390              	.LFB9:
2070:../uvc.c      **** {
 391              		.loc 1 2070 0
 392              		.cfi_startproc
 393              		@ args = 0, pretend = 0, frame = 8
 394              		@ frame_needed = 0, uses_anonymous_args = 0
 395              	.LVL38:
2071:../uvc.c      ****     switch (evtype)
 396              		.loc 1 2071 0
 397 02d4 020050E3 		cmp	r0, #2
2070:../uvc.c      **** {
 398              		.loc 1 2070 0
 399 02d8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 400              	.LCFI3:
 401              		.cfi_def_cfa_offset 16
 402 02dc 0130A0E1 		mov	r3, r1
 403 02e0 10D04DE2 		sub	sp, sp, #16
 404              	.LCFI4:
 405              		.cfi_def_cfa_offset 32
2070:../uvc.c      **** {
 406              		.loc 1 2070 0
 407 02e4 0040A0E1 		mov	r4, r0
 408              		.cfi_offset 14, -4
 409              		.cfi_offset 6, -8
 410              		.cfi_offset 5, -12
 411              		.cfi_offset 4, -16
2071:../uvc.c      ****     switch (evtype)
 412              		.loc 1 2071 0
 413 02e8 3C00000A 		beq	.L35
 414 02ec 040050E3 		cmp	r0, #4
 415 02f0 2200000A 		beq	.L36
 416 02f4 010050E3 		cmp	r0, #1
 417 02f8 0100000A 		beq	.L38
 418              	.LVL39:
 419              	.L32:
2110:../uvc.c      **** }
 420              		.loc 1 2110 0
 421 02fc 10D08DE2 		add	sp, sp, #16
 422 0300 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 423              	.LVL40:
 424              	.L38:
2094:../uvc.c      ****             debugData[2] = debugData[2]|0x04; //set bit2
 425              		.loc 1 2094 0
 426 0304 4C519FE5 		ldr	r5, .L39
2092:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 427              		.loc 1 2092 0
 428 0308 0020A0E1 		mov	r2, r0
 429 030c 48119FE5 		ldr	r1, .L39+4
 430              	.LVL41:
 431 0310 0400A0E3 		mov	r0, #4
 432              	.LVL42:
 433 0314 FEFFFFEB 		bl	CyU3PDebugPrint
2093:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 434              		.loc 1 2093 0
 435 0318 0400A0E1 		mov	r0, r4
 436 031c FEFFFFEB 		bl	CyU3PGpifDisable
2094:../uvc.c      ****             debugData[2] = debugData[2]|0x04; //set bit2
 437              		.loc 1 2094 0
 438 0320 2E20D5E5 		ldrb	r2, [r5, #46]	@ zero_extendqisi2
2095:../uvc.c      ****             gpif_initialized = 0;
 439              		.loc 1 2095 0
 440 0324 00C0A0E3 		mov	ip, #0
2094:../uvc.c      ****             debugData[2] = debugData[2]|0x04; //set bit2
 441              		.loc 1 2094 0
 442 0328 04E082E3 		orr	lr, r2, #4
 443              	.LBB17:
 444              	.LBB18:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 445              		.loc 1 2054 0
 446 032c 0410A0E1 		mov	r1, r4
 447 0330 0500A0E1 		mov	r0, r5
 448 0334 0220A0E3 		mov	r2, #2
 449 0338 0C308DE2 		add	r3, sp, #12
 450              	.LBE18:
 451              	.LBE17:
2094:../uvc.c      ****             debugData[2] = debugData[2]|0x04; //set bit2
 452              		.loc 1 2094 0
 453 033c 2EE0C5E5 		strb	lr, [r5, #46]
2095:../uvc.c      ****             gpif_initialized = 0;
 454              		.loc 1 2095 0
 455 0340 3CC085E5 		str	ip, [r5, #60]
2096:../uvc.c      ****             isUsbConnected = CyFalse;
 456              		.loc 1 2096 0
 457 0344 44C085E5 		str	ip, [r5, #68]
2097:../uvc.c      ****             streamingStarted = CyFalse;
 458              		.loc 1 2097 0
 459 0348 40C085E5 		str	ip, [r5, #64]
 460              	.LBB20:
 461              	.LBB19:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 462              		.loc 1 2054 0
 463 034c 00C08DE5 		str	ip, [sp, #0]
 464 0350 FEFFFFEB 		bl	_txe_event_flags_get
 465 0354 004050E2 		subs	r4, r0, #0
 466 0358 E7FFFF1A 		bne	.L32
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 467              		.loc 1 2057 0
 468 035c 0110E0E3 		mvn	r1, #1
 469 0360 0220A0E3 		mov	r2, #2
 470 0364 0500A0E1 		mov	r0, r5
 471              	.L37:
 472 0368 FEFFFFEB 		bl	_txe_event_flags_set
2060:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 473              		.loc 1 2060 0
 474 036c 0500A0E1 		mov	r0, r5
 475 0370 0210A0E3 		mov	r1, #2
 476 0374 0420A0E1 		mov	r2, r4
 477 0378 FEFFFFEB 		bl	_txe_event_flags_set
 478 037c DEFFFFEA 		b	.L32
 479              	.LVL43:
 480              	.L36:
 481              	.LBE19:
 482              	.LBE20:
2076:../uvc.c      ****             debugData[2] = debugData[2]|0x01; //set bit0
 483              		.loc 1 2076 0
 484 0380 D0509FE5 		ldr	r5, .L39
2074:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 485              		.loc 1 2074 0
 486 0384 D4109FE5 		ldr	r1, .L39+8
 487              	.LVL44:
 488 0388 0020A0E1 		mov	r2, r0
 489 038c FEFFFFEB 		bl	CyU3PDebugPrint
 490              	.LVL45:
2075:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 491              		.loc 1 2075 0
 492 0390 0100A0E3 		mov	r0, #1
 493 0394 FEFFFFEB 		bl	CyU3PGpifDisable
2076:../uvc.c      ****             debugData[2] = debugData[2]|0x01; //set bit0
 494              		.loc 1 2076 0
 495 0398 2E00D5E5 		ldrb	r0, [r5, #46]	@ zero_extendqisi2
2077:../uvc.c      ****             gpif_initialized = 0;
 496              		.loc 1 2077 0
 497 039c 00C0A0E3 		mov	ip, #0
2076:../uvc.c      ****             debugData[2] = debugData[2]|0x01; //set bit0
 498              		.loc 1 2076 0
 499 03a0 01E080E3 		orr	lr, r0, #1
 500              	.LBB21:
 501              	.LBB22:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 502              		.loc 1 2054 0
 503 03a4 0110A0E3 		mov	r1, #1
 504 03a8 0220A0E3 		mov	r2, #2
 505 03ac 0500A0E1 		mov	r0, r5
 506 03b0 0C308DE2 		add	r3, sp, #12
 507              	.LBE22:
 508              	.LBE21:
2076:../uvc.c      ****             debugData[2] = debugData[2]|0x01; //set bit0
 509              		.loc 1 2076 0
 510 03b4 2EE0C5E5 		strb	lr, [r5, #46]
2077:../uvc.c      ****             gpif_initialized = 0;
 511              		.loc 1 2077 0
 512 03b8 3CC085E5 		str	ip, [r5, #60]
2078:../uvc.c      ****             streamingStarted = CyFalse;
 513              		.loc 1 2078 0
 514 03bc 40C085E5 		str	ip, [r5, #64]
 515              	.LBB24:
 516              	.LBB23:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 517              		.loc 1 2054 0
 518 03c0 00C08DE5 		str	ip, [sp, #0]
 519 03c4 FEFFFFEB 		bl	_txe_event_flags_get
 520 03c8 004050E2 		subs	r4, r0, #0
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 521              		.loc 1 2057 0
 522 03cc 0500A001 		moveq	r0, r5
 523 03d0 0110E003 		mvneq	r1, #1
 524 03d4 0220A003 		moveq	r2, #2
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 525              		.loc 1 2054 0
 526 03d8 C7FFFF1A 		bne	.L32
 527 03dc E1FFFFEA 		b	.L37
 528              	.LVL46:
 529              	.L35:
 530              	.LBE23:
 531              	.LBE24:
2085:../uvc.c      ****             debugData[2] = debugData[2]|0x02; //set bit1
 532              		.loc 1 2085 0
 533 03e0 70509FE5 		ldr	r5, .L39
2083:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 534              		.loc 1 2083 0
 535 03e4 0020A0E1 		mov	r2, r0
 536 03e8 74109FE5 		ldr	r1, .L39+12
 537              	.LVL47:
 538 03ec 0400A0E3 		mov	r0, #4
 539              	.LVL48:
 540 03f0 FEFFFFEB 		bl	CyU3PDebugPrint
2084:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 541              		.loc 1 2084 0
 542 03f4 0100A0E3 		mov	r0, #1
 543 03f8 FEFFFFEB 		bl	CyU3PGpifDisable
2085:../uvc.c      ****             debugData[2] = debugData[2]|0x02; //set bit1
 544              		.loc 1 2085 0
 545 03fc 2E10D5E5 		ldrb	r1, [r5, #46]	@ zero_extendqisi2
2086:../uvc.c      ****             gpif_initialized = 0;
 546              		.loc 1 2086 0
 547 0400 0060A0E3 		mov	r6, #0
2085:../uvc.c      ****             debugData[2] = debugData[2]|0x02; //set bit1
 548              		.loc 1 2085 0
 549 0404 02C081E3 		orr	ip, r1, #2
 550              	.LBB25:
 551              	.LBB27:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 552              		.loc 1 2054 0
 553 0408 0500A0E1 		mov	r0, r5
 554 040c 0110A0E3 		mov	r1, #1
 555 0410 0420A0E1 		mov	r2, r4
 556 0414 0C308DE2 		add	r3, sp, #12
 557              	.LBE27:
 558              	.LBE25:
2086:../uvc.c      ****             gpif_initialized = 0;
 559              		.loc 1 2086 0
 560 0418 3C6085E5 		str	r6, [r5, #60]
2087:../uvc.c      ****             streamingStarted = CyFalse;
 561              		.loc 1 2087 0
 562 041c 406085E5 		str	r6, [r5, #64]
 563              	.LBB29:
 564              	.LBB26:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 565              		.loc 1 2054 0
 566 0420 00608DE5 		str	r6, [sp, #0]
 567              	.LBE26:
 568              	.LBE29:
2085:../uvc.c      ****             debugData[2] = debugData[2]|0x02; //set bit1
 569              		.loc 1 2085 0
 570 0424 2EC0C5E5 		strb	ip, [r5, #46]
 571              	.LBB30:
 572              	.LBB28:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 573              		.loc 1 2054 0
 574 0428 FEFFFFEB 		bl	_txe_event_flags_get
 575 042c 006050E2 		subs	r6, r0, #0
 576 0430 B1FFFF1A 		bne	.L32
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 577              		.loc 1 2057 0
 578 0434 0420A0E1 		mov	r2, r4
 579 0438 0500A0E1 		mov	r0, r5
 580 043c 0110E0E3 		mvn	r1, #1
 581 0440 FEFFFFEB 		bl	_txe_event_flags_set
2060:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 582              		.loc 1 2060 0
 583 0444 0500A0E1 		mov	r0, r5
 584 0448 0410A0E1 		mov	r1, r4
 585 044c 0620A0E1 		mov	r2, r6
 586 0450 FEFFFFEB 		bl	_txe_event_flags_set
 587 0454 A8FFFFEA 		b	.L32
 588              	.L40:
 589              		.align	2
 590              	.L39:
 591 0458 00000000 		.word	.LANCHOR0
 592 045c BC000000 		.word	.LC6
 593 0460 78000000 		.word	.LC4
 594 0464 98000000 		.word	.LC5
 595              	.LBE28:
 596              	.LBE30:
 597              		.cfi_endproc
 598              	.LFE9:
 600              		.align	2
 601              		.global	CyFxUvcApplnDmaCallback
 603              	CyFxUvcApplnDmaCallback:
 604              	.LFB11:
2272:../uvc.c      **** {
 605              		.loc 1 2272 0
 606              		.cfi_startproc
 607              		@ args = 0, pretend = 0, frame = 0
 608              		@ frame_needed = 0, uses_anonymous_args = 0
 609              	.LVL49:
2279:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 610              		.loc 1 2279 0
 611 0468 080051E3 		cmp	r1, #8
2272:../uvc.c      **** {
 612              		.loc 1 2272 0
 613 046c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 614              	.LCFI5:
 615              		.cfi_def_cfa_offset 20
 616 0470 0250A0E1 		mov	r5, r2
 617              		.cfi_offset 14, -4
 618              		.cfi_offset 7, -8
 619              		.cfi_offset 6, -12
 620              		.cfi_offset 5, -16
 621              		.cfi_offset 4, -20
 622 0474 0CD04DE2 		sub	sp, sp, #12
 623              	.LCFI6:
 624              		.cfi_def_cfa_offset 32
2279:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 625              		.loc 1 2279 0
 626 0478 0B00000A 		beq	.L47
2331:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 627              		.loc 1 2331 0
 628 047c 100051E3 		cmp	r1, #16
 629 0480 0700001A 		bne	.L41
2333:../uvc.c      ****         consCount++;
 630              		.loc 1 2333 0
 631 0484 7C319FE5 		ldr	r3, .L50
2334:../uvc.c      ****         streamingStarted = CyTrue;
 632              		.loc 1 2334 0
 633 0488 0120A0E3 		mov	r2, #1
 634              	.LVL50:
2333:../uvc.c      ****         consCount++;
 635              		.loc 1 2333 0
 636 048c B605D3E1 		ldrh	r0, [r3, #86]
 637              	.LVL51:
2334:../uvc.c      ****         streamingStarted = CyTrue;
 638              		.loc 1 2334 0
 639 0490 402083E5 		str	r2, [r3, #64]
2333:../uvc.c      ****         consCount++;
 640              		.loc 1 2333 0
 641 0494 02C080E0 		add	ip, r0, r2
 642 0498 0C18A0E1 		mov	r1, ip, asl #16
 643              	.LVL52:
 644 049c 2128A0E1 		mov	r2, r1, lsr #16
 645 04a0 B625C3E1 		strh	r2, [r3, #86]	@ movhi
 646              	.L41:
2336:../uvc.c      **** }
 647              		.loc 1 2336 0
 648 04a4 0CD08DE2 		add	sp, sp, #12
 649 04a8 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 650              	.LVL53:
 651              	.L47:
2281:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 652              		.loc 1 2281 0
 653 04ac B420D2E1 		ldrh	r2, [r2, #4]
 654 04b0 54319FE5 		ldr	r3, .L50+4
 655 04b4 030052E1 		cmp	r2, r3
 656 04b8 3500000A 		beq	.L48
2301:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 657              		.loc 1 2301 0
 658 04bc 006095E5 		ldr	r6, [r5, #0]
 659              	.LBB35:
 660              	.LBB37:
2015:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 661              		.loc 1 2015 0
 662 04c0 48719FE5 		ldr	r7, .L50+8
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 663              		.loc 1 2014 0
 664 04c4 0010E0E3 		mvn	r1, #0
 665              	.LVL54:
 666              	.LBE37:
 667              	.LBE35:
2301:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 668              		.loc 1 2301 0
 669 04c8 0C4046E2 		sub	r4, r6, #12
 670              	.LVL55:
 671              	.LBB39:
 672              	.LBB36:
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 673              		.loc 1 2014 0
 674 04cc 40019FE5 		ldr	r0, .L50+12
 675              	.LVL56:
 676 04d0 FEFFFFEB 		bl	_txe_mutex_get
2015:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 677              		.loc 1 2015 0
 678 04d4 0400A0E1 		mov	r0, r4
 679 04d8 121D87E2 		add	r1, r7, #1152
 680 04dc 0C20A0E3 		mov	r2, #12
 681 04e0 FEFFFFEB 		bl	CyU3PMemCopy
2016:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 682              		.loc 1 2016 0
 683 04e4 28019FE5 		ldr	r0, .L50+12
 684 04e8 FEFFFFEB 		bl	_txe_mutex_put
2021:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 685              		.loc 1 2021 0
 686 04ec 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 687              	.LBE36:
 688              	.LBE39:
2302:../uvc.c      ****                 pb++;
 689              		.loc 1 2302 0
 690 04f0 10419FE5 		ldr	r4, .L50
 691              	.LVL57:
 692              	.LBB40:
 693              	.LBB38:
2021:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 694              		.loc 1 2021 0
 695 04f4 02108CE3 		orr	r1, ip, #2
 696 04f8 0B1046E5 		strb	r1, [r6, #-11]
 697              	.LBE38:
 698              	.LBE40:
2302:../uvc.c      ****                 pb++;
 699              		.loc 1 2302 0
 700 04fc BA04D4E1 		ldrh	r0, [r4, #74]
2308:../uvc.c      ****                 if(stiflag == 0x0F){
 701              		.loc 1 2308 0
 702 0500 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
2303:../uvc.c      ****                 pbc = input->buffer_p.count;
 703              		.loc 1 2303 0
 704 0504 B410D5E1 		ldrh	r1, [r5, #4]
2302:../uvc.c      ****                 pb++;
 705              		.loc 1 2302 0
 706 0508 013080E2 		add	r3, r0, #1
2308:../uvc.c      ****                 if(stiflag == 0x0F){
 707              		.loc 1 2308 0
 708 050c 0F0052E3 		cmp	r2, #15
2302:../uvc.c      ****                 pb++;
 709              		.loc 1 2302 0
 710 0510 BA34C4E1 		strh	r3, [r4, #74]	@ movhi
2303:../uvc.c      ****                 pbc = input->buffer_p.count;
 711              		.loc 1 2303 0
 712 0514 BC14C4E1 		strh	r1, [r4, #76]	@ movhi
2308:../uvc.c      ****                 if(stiflag == 0x0F){
 713              		.loc 1 2308 0
 714 0518 2E00000A 		beq	.L49
 715              	.L45:
2315:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 716              		.loc 1 2315 0
 717 051c 01E0A0E3 		mov	lr, #1
 718 0520 50E084E5 		str	lr, [r4, #80]
 719              	.LVL58:
 720              	.L44:
2319:../uvc.c      ****             prodCount++;
 721              		.loc 1 2319 0
 722 0524 B4E5D4E1 		ldrh	lr, [r4, #84]
2320:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 723              		.loc 1 2320 0
 724 0528 0C1081E2 		add	r1, r1, #12
2319:../uvc.c      ****             prodCount++;
 725              		.loc 1 2319 0
 726 052c 01308EE2 		add	r3, lr, #1
 727 0530 0308A0E1 		mov	r0, r3, asl #16
 728 0534 20C8A0E1 		mov	ip, r0, lsr #16
2320:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 729              		.loc 1 2320 0
 730 0538 0128A0E1 		mov	r2, r1, asl #16
 731 053c 2218A0E1 		mov	r1, r2, lsr #16
 732 0540 D0009FE5 		ldr	r0, .L50+16
 733 0544 0020A0E3 		mov	r2, #0
2319:../uvc.c      ****             prodCount++;
 734              		.loc 1 2319 0
 735 0548 B4C5C4E1 		strh	ip, [r4, #84]	@ movhi
2320:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 736              		.loc 1 2320 0
 737 054c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 738              	.LVL59:
2319:../uvc.c      ****             prodCount++;
 739              		.loc 1 2319 0
 740 0550 B0109FE5 		ldr	r1, .L50
2323:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 741              		.loc 1 2323 0
 742 0554 002050E2 		subs	r2, r0, #0
 743 0558 D1FFFF0A 		beq	.L41
2325:../uvc.c      ****                 prodCount--;
 744              		.loc 1 2325 0
 745 055c B405D1E1 		ldrh	r0, [r1, #84]
 746              	.LVL60:
2326:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 747              		.loc 1 2326 0
 748 0560 B430D5E1 		ldrh	r3, [r5, #4]
2325:../uvc.c      ****                 prodCount--;
 749              		.loc 1 2325 0
 750 0564 01E040E2 		sub	lr, r0, #1
 751 0568 0EC8A0E1 		mov	ip, lr, asl #16
 752 056c 2C08A0E1 		mov	r0, ip, lsr #16
 753 0570 B405C1E1 		strh	r0, [r1, #84]	@ movhi
2326:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 754              		.loc 1 2326 0
 755 0574 B4E5D1E1 		ldrh	lr, [r1, #84]
 756 0578 B6C5D1E1 		ldrh	ip, [r1, #86]
 757 057c 0400A0E3 		mov	r0, #4
 758 0580 94109FE5 		ldr	r1, .L50+20
 759 0584 00E08DE5 		str	lr, [sp, #0]
 760 0588 04C08DE5 		str	ip, [sp, #4]
 761 058c FEFFFFEB 		bl	CyU3PDebugPrint
 762              	.LVL61:
 763 0590 C3FFFFEA 		b	.L41
 764              	.LVL62:
 765              	.L48:
2295:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 766              		.loc 1 2295 0
 767 0594 006095E5 		ldr	r6, [r5, #0]
 768              	.LBB41:
 769              	.LBB42:
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 770              		.loc 1 2014 0
 771 0598 0010E0E3 		mvn	r1, #0
 772              	.LVL63:
 773              	.LBE42:
 774              	.LBE41:
2296:../uvc.c      ****                 fb++;
 775              		.loc 1 2296 0
 776 059c 64409FE5 		ldr	r4, .L50
2295:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 777              		.loc 1 2295 0
 778 05a0 0C6046E2 		sub	r6, r6, #12
 779              	.LVL64:
 780              	.LBB44:
 781              	.LBB43:
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 782              		.loc 1 2014 0
 783 05a4 68009FE5 		ldr	r0, .L50+12
 784              	.LVL65:
 785 05a8 FEFFFFEB 		bl	_txe_mutex_get
2015:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 786              		.loc 1 2015 0
 787 05ac 6C109FE5 		ldr	r1, .L50+24
 788 05b0 0600A0E1 		mov	r0, r6
 789 05b4 0C20A0E3 		mov	r2, #12
 790 05b8 FEFFFFEB 		bl	CyU3PMemCopy
2016:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 791              		.loc 1 2016 0
 792 05bc 50009FE5 		ldr	r0, .L50+12
 793 05c0 FEFFFFEB 		bl	_txe_mutex_put
 794              	.LBE43:
 795              	.LBE44:
2296:../uvc.c      ****                 fb++;
 796              		.loc 1 2296 0
 797 05c4 B8C4D4E1 		ldrh	ip, [r4, #72]
 798 05c8 B410D5E1 		ldrh	r1, [r5, #4]
 799 05cc 01008CE2 		add	r0, ip, #1
 800 05d0 B804C4E1 		strh	r0, [r4, #72]	@ movhi
 801 05d4 D2FFFFEA 		b	.L44
 802              	.LVL66:
 803              	.L49:
2309:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 804              		.loc 1 2309 0
 805 05d8 0010E0E3 		mvn	r1, #0
 806 05dc 30009FE5 		ldr	r0, .L50+12
 807 05e0 FEFFFFEB 		bl	_txe_mutex_get
2310:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 808              		.loc 1 2310 0
 809 05e4 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2311:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 810              		.loc 1 2311 0
 811 05e8 24009FE5 		ldr	r0, .L50+12
2310:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 812              		.loc 1 2310 0
 813 05ec DF2001E2 		and	r2, r1, #223
 814 05f0 8124C7E5 		strb	r2, [r7, #1153]
2311:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 815              		.loc 1 2311 0
 816 05f4 FEFFFFEB 		bl	_txe_mutex_put
2312:../uvc.c      ****                 	stiflag = 0xAA;
 817              		.loc 1 2312 0
 818 05f8 5530E0E3 		mvn	r3, #85
 819 05fc 4E30C4E5 		strb	r3, [r4, #78]
 820 0600 B410D5E1 		ldrh	r1, [r5, #4]
 821 0604 C4FFFFEA 		b	.L45
 822              	.L51:
 823              		.align	2
 824              	.L50:
 825 0608 00000000 		.word	.LANCHOR0
 826 060c F03F0000 		.word	16368
 827 0610 00000000 		.word	.LANCHOR1
 828 0614 00000000 		.word	imgHdMux
 829 0618 00000000 		.word	glChHandleUVCStream
 830 061c DC000000 		.word	.LC7
 831 0620 80040000 		.word	.LANCHOR1+1152
 832              		.cfi_endproc
 833              	.LFE11:
 835              		.align	2
 837              	CyFxUVCApplnUSBSetupCB:
 838              	.LFB10:
2118:../uvc.c      **** {
 839              		.loc 1 2118 0
 840              		.cfi_startproc
 841              		@ args = 0, pretend = 0, frame = 8
 842              		@ frame_needed = 0, uses_anonymous_args = 0
 843              	.LVL67:
2123:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 844              		.loc 1 2123 0
 845 0624 D8329FE5 		ldr	r3, .L77
2118:../uvc.c      **** {
 846              		.loc 1 2118 0
 847 0628 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 848              	.LCFI7:
 849              		.cfi_def_cfa_offset 24
2124:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 850              		.loc 1 2124 0
 851 062c D4C29FE5 		ldr	ip, .L77+4
2123:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 852              		.loc 1 2123 0
 853 0630 FF4000E2 		and	r4, r0, #255
 854              		.cfi_offset 14, -4
 855              		.cfi_offset 8, -8
 856              		.cfi_offset 7, -12
 857              		.cfi_offset 6, -16
 858              		.cfi_offset 5, -20
 859              		.cfi_offset 4, -24
2124:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 860              		.loc 1 2124 0
 861 0634 FF8C00E2 		and	r8, r0, #65280
2125:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 862              		.loc 1 2125 0
 863 0638 2068A0E1 		mov	r6, r0, lsr #16
2123:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 864              		.loc 1 2123 0
 865 063c 0040C3E5 		strb	r4, [r3, #0]
2125:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 866              		.loc 1 2125 0
 867 0640 C4229FE5 		ldr	r2, .L77+8
2126:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 868              		.loc 1 2126 0
 869 0644 C4029FE5 		ldr	r0, .L77+12
 870              	.LVL68:
2127:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 871              		.loc 1 2127 0
 872 0648 C4329FE5 		ldr	r3, .L77+16
2126:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 873              		.loc 1 2126 0
 874 064c 0158A0E1 		mov	r5, r1, asl #16
2124:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 875              		.loc 1 2124 0
 876 0650 2884A0E1 		mov	r8, r8, lsr #8
2126:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 877              		.loc 1 2126 0
 878 0654 2558A0E1 		mov	r5, r5, lsr #16
2127:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 879              		.loc 1 2127 0
 880 0658 2118A0E1 		mov	r1, r1, lsr #16
 881              	.LVL69:
2130:../uvc.c      ****     switch (bmReqType)
 882              		.loc 1 2130 0
 883 065c 020054E3 		cmp	r4, #2
2118:../uvc.c      **** {
 884              		.loc 1 2118 0
 885 0660 10D04DE2 		sub	sp, sp, #16
 886              	.LCFI8:
 887              		.cfi_def_cfa_offset 40
2124:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 888              		.loc 1 2124 0
 889 0664 0080CCE5 		strb	r8, [ip, #0]
2125:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 890              		.loc 1 2125 0
 891 0668 B060C2E1 		strh	r6, [r2, #0]	@ movhi
2126:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 892              		.loc 1 2126 0
 893 066c B050C0E1 		strh	r5, [r0, #0]	@ movhi
2127:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 894              		.loc 1 2127 0
 895 0670 B010C3E1 		strh	r1, [r3, #0]	@ movhi
2130:../uvc.c      ****     switch (bmReqType)
 896              		.loc 1 2130 0
 897 0674 5200000A 		beq	.L55
 898 0678 0600009A 		bls	.L73
 899 067c 210054E3 		cmp	r4, #33
 900 0680 3D00000A 		beq	.L56
 901 0684 A10054E3 		cmp	r4, #161
 902 0688 3B00000A 		beq	.L56
 903              	.L70:
2119:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 904              		.loc 1 2119 0
 905 068c 0000A0E3 		mov	r0, #0
 906              	.LVL70:
 907              	.L53:
2259:../uvc.c      **** }
 908              		.loc 1 2259 0
 909 0690 10D08DE2 		add	sp, sp, #16
 910 0694 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 911              	.LVL71:
 912              	.L73:
2130:../uvc.c      ****     switch (bmReqType)
 913              		.loc 1 2130 0
 914 0698 010054E3 		cmp	r4, #1
 915 069c FAFFFF1A 		bne	.L70
2170:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 916              		.loc 1 2170 0
 917 06a0 0B0058E3 		cmp	r8, #11
 918 06a4 F8FFFF1A 		bne	.L70
2174:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 919              		.loc 1 2174 0
 920 06a8 010055E3 		cmp	r5, #1
 921 06ac F6FFFF1A 		bne	.L70
2174:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 922              		.loc 1 2174 0 is_stmt 0 discriminator 1
 923 06b0 000056E3 		cmp	r6, #0
 924 06b4 F4FFFF1A 		bne	.L70
2179:../uvc.c      ****                     gpif_initialized = 0;
 925              		.loc 1 2179 0 is_stmt 1
 926 06b8 58429FE5 		ldr	r4, .L77+20
2177:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 927              		.loc 1 2177 0
 928 06bc 58129FE5 		ldr	r1, .L77+24
 929 06c0 0400A0E3 		mov	r0, #4
 930 06c4 FEFFFFEB 		bl	CyU3PDebugPrint
2178:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 931              		.loc 1 2178 0
 932 06c8 0500A0E1 		mov	r0, r5
 933 06cc FEFFFFEB 		bl	CyU3PGpifDisable
2182:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 934              		.loc 1 2182 0
 935 06d0 0510A0E1 		mov	r1, r5
2179:../uvc.c      ****                     gpif_initialized = 0;
 936              		.loc 1 2179 0
 937 06d4 3C6084E5 		str	r6, [r4, #60]
2180:../uvc.c      ****                     streamingStarted = CyFalse;
 938              		.loc 1 2180 0
 939 06d8 406084E5 		str	r6, [r4, #64]
2182:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 940              		.loc 1 2182 0
 941 06dc 8300A0E3 		mov	r0, #131
 942 06e0 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2183:../uvc.c      ****                     CyU3PBusyWait (100);
 943              		.loc 1 2183 0
 944 06e4 6400A0E3 		mov	r0, #100
 945 06e8 FEFFFFEB 		bl	CyU3PBusyWait
2186:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 946              		.loc 1 2186 0
 947 06ec 2C029FE5 		ldr	r0, .L77+28
 948 06f0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2187:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 949              		.loc 1 2187 0
 950 06f4 8300A0E3 		mov	r0, #131
 951 06f8 FEFFFFEB 		bl	CyU3PUsbFlushEp
2188:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 952              		.loc 1 2188 0
 953 06fc 0610A0E1 		mov	r1, r6
 954 0700 8300A0E3 		mov	r0, #131
 955 0704 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2189:../uvc.c      ****                     CyU3PBusyWait (100);
 956              		.loc 1 2189 0
 957 0708 6400A0E3 		mov	r0, #100
 958 070c FEFFFFEB 		bl	CyU3PBusyWait
2192:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 959              		.loc 1 2192 0
 960 0710 0610A0E1 		mov	r1, r6
 961 0714 0520A0E1 		mov	r2, r5
 962 0718 8300A0E3 		mov	r0, #131
 963 071c FEFFFFEB 		bl	CyU3PUsbStall
 964              	.LVL72:
2195:../uvc.c      ****                     CyU3PUsbAckSetup ();
 965              		.loc 1 2195 0
 966 0720 FEFFFFEB 		bl	CyU3PUsbAckSetup
2197:../uvc.c      ****                     debugData[2] = debugData[2]|0x08; //set bit3
 967              		.loc 1 2197 0
 968 0724 2E10D4E5 		ldrb	r1, [r4, #46]	@ zero_extendqisi2
2198:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 969              		.loc 1 2198 0
 970 0728 585084E5 		str	r5, [r4, #88]
2197:../uvc.c      ****                     debugData[2] = debugData[2]|0x08; //set bit3
 971              		.loc 1 2197 0
 972 072c 08C081E3 		orr	ip, r1, #8
 973 0730 2EC0C4E5 		strb	ip, [r4, #46]
 974              	.LBB49:
 975              	.LBB50:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 976              		.loc 1 2054 0
 977 0734 0400A0E1 		mov	r0, r4
 978 0738 0510A0E1 		mov	r1, r5
 979 073c 0220A0E3 		mov	r2, #2
 980 0740 0C308DE2 		add	r3, sp, #12
 981 0744 00608DE5 		str	r6, [sp, #0]
 982 0748 FEFFFFEB 		bl	_txe_event_flags_get
 983 074c 006050E2 		subs	r6, r0, #0
 984 0750 2E00001A 		bne	.L68
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 985              		.loc 1 2057 0
 986 0754 0110E0E3 		mvn	r1, #1
 987 0758 0220A0E3 		mov	r2, #2
 988 075c 0400A0E1 		mov	r0, r4
 989 0760 FEFFFFEB 		bl	_txe_event_flags_set
2060:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 990              		.loc 1 2060 0
 991 0764 0400A0E1 		mov	r0, r4
 992 0768 0210A0E3 		mov	r1, #2
 993 076c 0620A0E1 		mov	r2, r6
 994 0770 FEFFFFEB 		bl	_txe_event_flags_set
2193:../uvc.c      ****                     uvcHandleReq = CyTrue;
 995              		.loc 1 2193 0
 996 0774 0500A0E1 		mov	r0, r5
 997 0778 C4FFFFEA 		b	.L53
 998              	.LVL73:
 999              	.L56:
 1000              	.LBE50:
 1001              	.LBE49:
2135:../uvc.c      ****             switch (wIndex & 0xFF)
 1002              		.loc 1 2135 0
 1003 077c FF5015E2 		ands	r5, r5, #255
 1004 0780 1A00001A 		bne	.L74
 1005              	.LVL74:
2140:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1006              		.loc 1 2140 0
 1007 0784 0520A0E1 		mov	r2, r5
 1008 0788 88019FE5 		ldr	r0, .L77+20
 1009 078c 0410A0E3 		mov	r1, #4
 1010 0790 FEFFFFEB 		bl	_txe_event_flags_set
 1011              	.LVL75:
2142:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1012              		.loc 1 2142 0
 1013 0794 002050E2 		subs	r2, r0, #0
2139:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1014              		.loc 1 2139 0
 1015 0798 0100A003 		moveq	r0, #1
 1016              	.LVL76:
2142:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1017              		.loc 1 2142 0
 1018 079c BBFFFF0A 		beq	.L53
2144:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1019              		.loc 1 2144 0
 1020 07a0 7C119FE5 		ldr	r1, .L77+32
 1021 07a4 0400A0E3 		mov	r0, #4
 1022 07a8 FEFFFFEB 		bl	CyU3PDebugPrint
 1023              	.LVL77:
2145:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1024              		.loc 1 2145 0
 1025 07ac 0500A0E1 		mov	r0, r5
 1026 07b0 0110A0E3 		mov	r1, #1
 1027 07b4 0520A0E1 		mov	r2, r5
 1028 07b8 FEFFFFEB 		bl	CyU3PUsbStall
2139:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1029              		.loc 1 2139 0
 1030 07bc 0100A0E3 		mov	r0, #1
 1031 07c0 B2FFFFEA 		b	.L53
 1032              	.LVL78:
 1033              	.L55:
2206:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 1034              		.loc 1 2206 0
 1035 07c4 010058E3 		cmp	r8, #1
 1036 07c8 AFFFFF1A 		bne	.L70
2208:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 1037              		.loc 1 2208 0
 1038 07cc 830055E3 		cmp	r5, #131
 1039 07d0 ADFFFF1A 		bne	.L70
2214:../uvc.c      ****                     if (streamingStarted == CyTrue)
 1040              		.loc 1 2214 0
 1041 07d4 3C619FE5 		ldr	r6, .L77+20
 1042 07d8 407096E5 		ldr	r7, [r6, #64]
 1043 07dc 010057E3 		cmp	r7, #1
 1044 07e0 1500000A 		beq	.L75
 1045              	.LVL79:
2247:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1046              		.loc 1 2247 0
 1047 07e4 FEFFFFEB 		bl	CyU3PUsbAckSetup
2246:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1048              		.loc 1 2246 0
 1049 07e8 0800A0E1 		mov	r0, r8
 1050 07ec A7FFFFEA 		b	.L53
 1051              	.LVL80:
 1052              	.L74:
2135:../uvc.c      ****             switch (wIndex & 0xFF)
 1053              		.loc 1 2135 0
 1054 07f0 010055E3 		cmp	r5, #1
 1055 07f4 A4FFFF1A 		bne	.L70
 1056              	.LVL81:
2153:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1057              		.loc 1 2153 0
 1058 07f8 0020A0E3 		mov	r2, #0
 1059 07fc 14019FE5 		ldr	r0, .L77+20
 1060 0800 0810A0E3 		mov	r1, #8
 1061 0804 FEFFFFEB 		bl	_txe_event_flags_set
 1062              	.LVL82:
2155:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1063              		.loc 1 2155 0
 1064 0808 002050E2 		subs	r2, r0, #0
 1065 080c 0100001A 		bne	.L76
 1066              	.LVL83:
 1067              	.L68:
 1068              	.LBB52:
 1069              	.LBB51:
2193:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1070              		.loc 1 2193 0
 1071 0810 0500A0E1 		mov	r0, r5
 1072 0814 9DFFFFEA 		b	.L53
 1073              	.LVL84:
 1074              	.L76:
 1075              	.LBE51:
 1076              	.LBE52:
2158:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1077              		.loc 1 2158 0
 1078 0818 08119FE5 		ldr	r1, .L77+36
 1079 081c 0400A0E3 		mov	r0, #4
 1080              	.LVL85:
 1081 0820 FEFFFFEB 		bl	CyU3PDebugPrint
 1082              	.LVL86:
2159:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1083              		.loc 1 2159 0
 1084 0824 0000A0E3 		mov	r0, #0
 1085 0828 0510A0E1 		mov	r1, r5
 1086 082c 0020A0E1 		mov	r2, r0
 1087 0830 FEFFFFEB 		bl	CyU3PUsbStall
2152:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1088              		.loc 1 2152 0
 1089 0834 0500A0E1 		mov	r0, r5
 1090 0838 94FFFFEA 		b	.L53
 1091              	.LVL87:
 1092              	.L75:
2216:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1093              		.loc 1 2216 0
 1094 083c E8109FE5 		ldr	r1, .L77+40
 1095 0840 0400A0E3 		mov	r0, #4
 1096 0844 FEFFFFEB 		bl	CyU3PDebugPrint
2220:../uvc.c      ****                         gpif_initialized = 0;
 1097              		.loc 1 2220 0
 1098 0848 0080A0E3 		mov	r8, #0
2219:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1099              		.loc 1 2219 0
 1100 084c 0700A0E1 		mov	r0, r7
 1101 0850 FEFFFFEB 		bl	CyU3PGpifDisable
2224:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1102              		.loc 1 2224 0
 1103 0854 0710A0E1 		mov	r1, r7
 1104 0858 0500A0E1 		mov	r0, r5
2220:../uvc.c      ****                         gpif_initialized = 0;
 1105              		.loc 1 2220 0
 1106 085c 3C8086E5 		str	r8, [r6, #60]
2221:../uvc.c      ****                         streamingStarted = CyFalse;
 1107              		.loc 1 2221 0
 1108 0860 408086E5 		str	r8, [r6, #64]
2224:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1109              		.loc 1 2224 0
 1110 0864 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2225:../uvc.c      ****                         CyU3PBusyWait (100);
 1111              		.loc 1 2225 0
 1112 0868 6400A0E3 		mov	r0, #100
 1113 086c FEFFFFEB 		bl	CyU3PBusyWait
2228:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1114              		.loc 1 2228 0
 1115 0870 A8009FE5 		ldr	r0, .L77+28
 1116 0874 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2229:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1117              		.loc 1 2229 0
 1118 0878 0500A0E1 		mov	r0, r5
 1119 087c FEFFFFEB 		bl	CyU3PUsbFlushEp
2230:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1120              		.loc 1 2230 0
 1121 0880 0810A0E1 		mov	r1, r8
 1122 0884 0500A0E1 		mov	r0, r5
 1123 0888 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2231:../uvc.c      ****                         CyU3PBusyWait (100);
 1124              		.loc 1 2231 0
 1125 088c 6400A0E3 		mov	r0, #100
 1126 0890 FEFFFFEB 		bl	CyU3PBusyWait
2234:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1127              		.loc 1 2234 0
 1128 0894 0810A0E1 		mov	r1, r8
 1129 0898 0720A0E1 		mov	r2, r7
 1130 089c 0500A0E1 		mov	r0, r5
 1131 08a0 FEFFFFEB 		bl	CyU3PUsbStall
 1132              	.LVL88:
2238:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1133              		.loc 1 2238 0
 1134 08a4 FEFFFFEB 		bl	CyU3PUsbAckSetup
2241:../uvc.c      ****                         debugData[2] = debugData[2]|0x10; //set bit0
 1135              		.loc 1 2241 0
 1136 08a8 2E20D6E5 		ldrb	r2, [r6, #46]	@ zero_extendqisi2
2240:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1137              		.loc 1 2240 0
 1138 08ac 587086E5 		str	r7, [r6, #88]
2241:../uvc.c      ****                         debugData[2] = debugData[2]|0x10; //set bit0
 1139              		.loc 1 2241 0
 1140 08b0 105082E3 		orr	r5, r2, #16
 1141 08b4 2E50C6E5 		strb	r5, [r6, #46]
 1142              	.LBB53:
 1143              	.LBB54:
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1144              		.loc 1 2054 0
 1145 08b8 0600A0E1 		mov	r0, r6
 1146 08bc 0710A0E1 		mov	r1, r7
 1147 08c0 0420A0E1 		mov	r2, r4
 1148 08c4 0C308DE2 		add	r3, sp, #12
 1149 08c8 00808DE5 		str	r8, [sp, #0]
 1150 08cc FEFFFFEB 		bl	_txe_event_flags_get
 1151 08d0 005050E2 		subs	r5, r0, #0
2236:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1152              		.loc 1 2236 0
 1153 08d4 0700A011 		movne	r0, r7
2054:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1154              		.loc 1 2054 0
 1155 08d8 6CFFFF1A 		bne	.L53
2057:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1156              		.loc 1 2057 0
 1157 08dc 0110E0E3 		mvn	r1, #1
 1158 08e0 0420A0E1 		mov	r2, r4
 1159 08e4 0600A0E1 		mov	r0, r6
 1160 08e8 FEFFFFEB 		bl	_txe_event_flags_set
2060:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1161              		.loc 1 2060 0
 1162 08ec 0600A0E1 		mov	r0, r6
 1163 08f0 0410A0E1 		mov	r1, r4
 1164 08f4 0520A0E1 		mov	r2, r5
 1165 08f8 FEFFFFEB 		bl	_txe_event_flags_set
2236:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1166              		.loc 1 2236 0
 1167 08fc 0700A0E1 		mov	r0, r7
 1168 0900 62FFFFEA 		b	.L53
 1169              	.L78:
 1170              		.align	2
 1171              	.L77:
 1172 0904 00000000 		.word	bmReqType
 1173 0908 00000000 		.word	bRequest
 1174 090c 00000000 		.word	wValue
 1175 0910 00000000 		.word	wIndex
 1176 0914 00000000 		.word	wLength
 1177 0918 00000000 		.word	.LANCHOR0
 1178 091c 94010000 		.word	.LC10
 1179 0920 00000000 		.word	glChHandleUVCStream
 1180 0924 28010000 		.word	.LC8
 1181 0928 60010000 		.word	.LC9
 1182 092c AC010000 		.word	.LC11
 1183              	.LBE54:
 1184              	.LBE53:
 1185              		.cfi_endproc
 1186              	.LFE10:
 1188              		.align	2
 1189              		.global	CyFxGpifCB
 1191              	CyFxGpifCB:
 1192              	.LFB13:
2458:../uvc.c      **** {
 1193              		.loc 1 2458 0
 1194              		.cfi_startproc
 1195              		@ args = 0, pretend = 0, frame = 0
 1196              		@ frame_needed = 0, uses_anonymous_args = 0
 1197              	.LVL89:
2459:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1198              		.loc 1 2459 0
 1199 0930 010050E3 		cmp	r0, #1
2458:../uvc.c      **** {
 1200              		.loc 1 2458 0
 1201 0934 10402DE9 		stmfd	sp!, {r4, lr}
 1202              	.LCFI9:
 1203              		.cfi_def_cfa_offset 8
2458:../uvc.c      **** {
 1204              		.loc 1 2458 0
 1205 0938 0120A0E1 		mov	r2, r1
2459:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1206              		.loc 1 2459 0
 1207 093c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1208              		.cfi_offset 14, -4
 1209              		.cfi_offset 4, -8
 1210              	.LVL90:
 1211              	.LBB59:
 1212              	.LBB60:
2356:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1213              		.loc 1 2356 0
 1214 0940 CC309FE5 		ldr	r3, .L94
 1215 0944 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
 1216 0948 030053E3 		cmp	r3, #3
 1217 094c 2100000A 		beq	.L93
2382:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1218              		.loc 1 2382 0
 1219 0950 020053E3 		cmp	r3, #2
 1220 0954 1080BD18 		ldmnefd	sp!, {r4, pc}
2384:../uvc.c      ****         switch (stateId)
 1221              		.loc 1 2384 0
 1222 0958 080041E2 		sub	r0, r1, #8
 1223              	.LVL91:
 1224 095c 0A0050E3 		cmp	r0, #10
 1225 0960 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1226 0964 230000EA 		b	.L86
 1227              	.L88:
 1228 0968 98090000 		.word	.L83
 1229 096c F8090000 		.word	.L86
 1230 0970 F8090000 		.word	.L86
 1231 0974 94090000 		.word	.L79
 1232 0978 F8090000 		.word	.L86
 1233 097c F8090000 		.word	.L86
 1234 0980 F8090000 		.word	.L86
 1235 0984 D0090000 		.word	.L92
 1236 0988 F8090000 		.word	.L86
 1237 098c F8090000 		.word	.L86
 1238 0990 94090000 		.word	.L79
 1239              	.LVL92:
 1240              	.L79:
 1241 0994 1080BDE8 		ldmfd	sp!, {r4, pc}
 1242              	.LVL93:
 1243              	.L83:
2367:../uvc.c      ****                 socket = 0;
 1244              		.loc 1 2367 0
 1245 0998 0010A0E3 		mov	r1, #0
 1246              	.LVL94:
 1247              	.L84:
2441:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1248              		.loc 1 2441 0
 1249 099c 74009FE5 		ldr	r0, .L94+4
 1250 09a0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1251              	.LVL95:
2442:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1252              		.loc 1 2442 0
 1253 09a4 002050E2 		subs	r2, r0, #0
 1254 09a8 F9FFFF0A 		beq	.L79
2444:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1255              		.loc 1 2444 0
 1256 09ac 0400A0E3 		mov	r0, #4
 1257              	.LVL96:
 1258 09b0 64109FE5 		ldr	r1, .L94+8
 1259 09b4 FEFFFFEB 		bl	CyU3PDebugPrint
 1260              	.LVL97:
 1261              	.L89:
 1262              	.LBB61:
 1263              	.LBB62:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1264              		.loc 1 2041 0
 1265 09b8 60109FE5 		ldr	r1, .L94+12
 1266 09bc 0400A0E3 		mov	r0, #4
 1267 09c0 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 1268              		.loc 1 2042 0
 1269 09c4 FA0FA0E3 		mov	r0, #1000
 1270 09c8 FEFFFFEB 		bl	_tx_thread_sleep
 1271 09cc F9FFFFEA 		b	.L89
 1272              	.LVL98:
 1273              	.L92:
 1274              	.LBE62:
 1275              	.LBE61:
2411:../uvc.c      ****                 socket = 1;
 1276              		.loc 1 2411 0
 1277 09d0 0110A0E3 		mov	r1, #1
 1278              	.LVL99:
 1279 09d4 F0FFFFEA 		b	.L84
 1280              	.LVL100:
 1281              	.L93:
2358:../uvc.c      ****         switch (stateId)
 1282              		.loc 1 2358 0
 1283 09d8 0B2041E2 		sub	r2, r1, #11
 1284 09dc 030052E3 		cmp	r2, #3
 1285 09e0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1286 09e4 060000EA 		b	.L82
 1287              	.L85:
 1288 09e8 98090000 		.word	.L83
 1289 09ec D0090000 		.word	.L92
 1290 09f0 94090000 		.word	.L79
 1291 09f4 94090000 		.word	.L79
 1292              	.LVL101:
 1293              	.L86:
2430:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1294              		.loc 1 2430 0
 1295 09f8 24109FE5 		ldr	r1, .L94+16
 1296              	.LVL102:
 1297 09fc 0100A0E3 		mov	r0, #1
 1298 0a00 FEFFFFEB 		bl	CyU3PDebugPrint
 1299              	.LVL103:
 1300              	.L82:
 1301              	.LBE60:
 1302              	.LBE59:
2465:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1303              		.loc 1 2465 0
 1304 0a04 1C109FE5 		ldr	r1, .L94+20
 1305 0a08 0400A0E3 		mov	r0, #4
2468:../uvc.c      **** }
 1306              		.loc 1 2468 0
 1307 0a0c 1040BDE8 		ldmfd	sp!, {r4, lr}
2465:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1308              		.loc 1 2465 0
 1309 0a10 FEFFFFEA 		b	CyU3PDebugPrint
 1310              	.L95:
 1311              		.align	2
 1312              	.L94:
 1313 0a14 00000000 		.word	.LANCHOR0
 1314 0a18 00000000 		.word	glChHandleUVCStream
 1315 0a1c E8010000 		.word	.LC13
 1316 0a20 18020000 		.word	.LC14
 1317 0a24 D0010000 		.word	.LC12
 1318 0a28 2C020000 		.word	.LC15
 1319              		.cfi_endproc
 1320              	.LFE13:
 1322              		.align	2
 1323              		.global	I2CCmdHandler
 1325              	I2CCmdHandler:
 1326              	.LFB0:
 611:../uvc.c      **** void I2CCmdHandler(){
 1327              		.loc 1 611 0
 1328              		.cfi_startproc
 1329              		@ args = 0, pretend = 0, frame = 16
 1330              		@ frame_needed = 0, uses_anonymous_args = 0
 1331 0a2c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1332              	.LCFI10:
 1333              		.cfi_def_cfa_offset 36
 614:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1334              		.loc 1 614 0
 1335 0a30 F0429FE5 		ldr	r4, .L119
 1336              		.cfi_offset 14, -4
 1337              		.cfi_offset 11, -8
 1338              		.cfi_offset 10, -12
 1339              		.cfi_offset 9, -16
 1340              		.cfi_offset 8, -20
 1341              		.cfi_offset 7, -24
 1342              		.cfi_offset 6, -28
 1343              		.cfi_offset 5, -32
 1344              		.cfi_offset 4, -36
 611:../uvc.c      **** void I2CCmdHandler(){
 1345              		.loc 1 611 0
 1346 0a34 3CD04DE2 		sub	sp, sp, #60
 1347              	.LCFI11:
 1348              		.cfi_def_cfa_offset 96
 619:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1349              		.loc 1 619 0
 1350 0a38 6710D4E5 		ldrb	r1, [r4, #103]	@ zero_extendqisi2
 1351 0a3c 6930D4E5 		ldrb	r3, [r4, #105]	@ zero_extendqisi2
 614:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1352              		.loc 1 614 0
 1353 0a40 6050D4E5 		ldrb	r5, [r4, #96]	@ zero_extendqisi2
 1354              	.LVL104:
 615:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1355              		.loc 1 615 0
 1356 0a44 6170D4E5 		ldrb	r7, [r4, #97]	@ zero_extendqisi2
 1357              	.LVL105:
 616:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1358              		.loc 1 616 0
 1359 0a48 6860D4E5 		ldrb	r6, [r4, #104]	@ zero_extendqisi2
 1360              	.LVL106:
 619:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1361              		.loc 1 619 0
 1362 0a4c 62E0D4E5 		ldrb	lr, [r4, #98]	@ zero_extendqisi2
 1363 0a50 6380D4E5 		ldrb	r8, [r4, #99]	@ zero_extendqisi2
 1364 0a54 64A0D4E5 		ldrb	sl, [r4, #100]	@ zero_extendqisi2
 1365 0a58 6590D4E5 		ldrb	r9, [r4, #101]	@ zero_extendqisi2
 1366 0a5c 66B0D4E5 		ldrb	fp, [r4, #102]	@ zero_extendqisi2
 1367 0a60 6AC0D4E5 		ldrb	ip, [r4, #106]	@ zero_extendqisi2
 1368 0a64 14108DE5 		str	r1, [sp, #20]
 1369 0a68 1C308DE5 		str	r3, [sp, #28]
 1370 0a6c 0400A0E3 		mov	r0, #4
 1371 0a70 0730A0E1 		mov	r3, r7
 1372 0a74 B0129FE5 		ldr	r1, .L119+4
 1373 0a78 0520A0E1 		mov	r2, r5
 1374 0a7c 00E08DE5 		str	lr, [sp, #0]
 1375 0a80 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1376 0a84 0C908DE5 		str	r9, [sp, #12]
 1377 0a88 10B08DE5 		str	fp, [sp, #16]
 1378 0a8c 18608DE5 		str	r6, [sp, #24]
 1379 0a90 20C08DE5 		str	ip, [sp, #32]
 1380 0a94 FEFFFFEB 		bl	CyU3PDebugPrint
 622:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1381              		.loc 1 622 0
 1382 0a98 6230D4E5 		ldrb	r3, [r4, #98]	@ zero_extendqisi2
 1383 0a9c 700053E3 		cmp	r3, #112
 1384 0aa0 1100000A 		beq	.L114
 1385              	.L97:
 633:../uvc.c      **** 		if(CmdType == 0){ //read
 1386              		.loc 1 633 0
 1387 0aa4 000055E3 		cmp	r5, #0
 1388 0aa8 0B00001A 		bne	.L101
 634:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1389              		.loc 1 634 0
 1390 0aac 0F20A0E3 		mov	r2, #15
 635:../uvc.c      **** 		if(I2CCMDArry[2] == 0){
 1391              		.loc 1 635 0
 1392 0ab0 000053E3 		cmp	r3, #0
 634:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1393              		.loc 1 634 0
 1394 0ab4 6C029FE5 		ldr	r0, .L119
 1395 0ab8 6B20C4E5 		strb	r2, [r4, #107]
 635:../uvc.c      **** 		if(I2CCMDArry[2] == 0){
 1396              		.loc 1 635 0
 1397 0abc 3300001A 		bne	.L102
 636:../uvc.c      **** 			I2CCMDArry[10] = debugData[0]; //number of frame
 1398              		.loc 1 636 0
 1399 0ac0 2C30D0E5 		ldrb	r3, [r0, #44]	@ zero_extendqisi2
 637:../uvc.c      **** 			I2CCMDArry[9] = debugData[1];  // stream status
 1400              		.loc 1 637 0
 1401 0ac4 2DC0D0E5 		ldrb	ip, [r0, #45]	@ zero_extendqisi2
 636:../uvc.c      **** 			I2CCMDArry[10] = debugData[0]; //number of frame
 1402              		.loc 1 636 0
 1403 0ac8 6A30C0E5 		strb	r3, [r0, #106]
 637:../uvc.c      **** 			I2CCMDArry[9] = debugData[1];  // stream status
 1404              		.loc 1 637 0
 1405 0acc 69C0C0E5 		strb	ip, [r0, #105]
 1406              	.LVL107:
 1407              	.L106:
 684:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1408              		.loc 1 684 0
 1409 0ad0 0020E0E3 		mvn	r2, #0
 1410 0ad4 6B20C4E5 		strb	r2, [r4, #107]
 1411 0ad8 010000EA 		b	.L96
 1412              	.LVL108:
 1413              	.L101:
 655:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 1414              		.loc 1 655 0
 1415 0adc 010055E3 		cmp	r5, #1
 1416 0ae0 3C00000A 		beq	.L115
 1417              	.LVL109:
 1418              	.L96:
 708:../uvc.c      **** }
 1419              		.loc 1 708 0
 1420 0ae4 3CD08DE2 		add	sp, sp, #60
 1421 0ae8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1422              	.LVL110:
 1423              	.L114:
 622:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1424              		.loc 1 622 0 discriminator 1
 1425 0aec 6320D4E5 		ldrb	r2, [r4, #99]	@ zero_extendqisi2
 1426 0af0 520052E3 		cmp	r2, #82
 1427 0af4 EAFFFF1A 		bne	.L97
 1428 0af8 6400D4E5 		ldrb	r0, [r4, #100]	@ zero_extendqisi2
 1429 0afc 300050E3 		cmp	r0, #48
 1430 0b00 E7FFFF1A 		bne	.L97
 1431 0b04 65C0D4E5 		ldrb	ip, [r4, #101]	@ zero_extendqisi2
 1432 0b08 01005CE3 		cmp	ip, #1
 1433 0b0c E4FFFF1A 		bne	.L97
 624:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1434              		.loc 1 624 0
 1435 0b10 6920D4E5 		ldrb	r2, [r4, #105]	@ zero_extendqisi2
 1436 0b14 14E29FE5 		ldr	lr, .L119+8
 1437 0b18 031002E2 		and	r1, r2, #3
 1438 0b1c 8C14CEE5 		strb	r1, [lr, #1164]
 625:../uvc.c      **** 		if(is60Hz==CyFalse)
 1439              		.loc 1 625 0
 1440 0b20 6C3094E5 		ldr	r3, [r4, #108]
 629:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1441              		.loc 1 629 0
 1442 0b24 0400A0E3 		mov	r0, #4
 625:../uvc.c      **** 		if(is60Hz==CyFalse)
 1443              		.loc 1 625 0
 1444 0b28 000053E3 		cmp	r3, #0
 627:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1445              		.loc 1 627 0
 1446 0b2c 80208203 		orreq	r2, r2, #128
 629:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1447              		.loc 1 629 0
 1448 0b30 8C34DEE5 		ldrb	r3, [lr, #1164]	@ zero_extendqisi2
 1449 0b34 F8119FE5 		ldr	r1, .L119+12
 627:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1450              		.loc 1 627 0
 1451 0b38 6920C405 		streqb	r2, [r4, #105]
 629:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1452              		.loc 1 629 0
 1453 0b3c FEFFFFEB 		bl	CyU3PDebugPrint
 663:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1454              		.loc 1 663 0
 1455 0b40 000055E3 		cmp	r5, #0
 1456 0b44 2800001A 		bne	.L116
 679:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1457              		.loc 1 679 0
 1458 0b48 6200D4E5 		ldrb	r0, [r4, #98]	@ zero_extendqisi2
 1459 0b4c 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 665:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1460              		.loc 1 665 0
 1461 0b50 0FC0A0E3 		mov	ip, #15
 679:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1462              		.loc 1 679 0
 1463 0b54 6530D4E5 		ldrb	r3, [r4, #101]	@ zero_extendqisi2
 1464 0b58 34E08DE2 		add	lr, sp, #52
 1465 0b5c 6420D4E5 		ldrb	r2, [r4, #100]	@ zero_extendqisi2
 1466 0b60 010080E3 		orr	r0, r0, #1
 1467 0b64 011081E3 		orr	r1, r1, #1
 665:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1468              		.loc 1 665 0
 1469 0b68 6BC0C4E5 		strb	ip, [r4, #107]
 679:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1470              		.loc 1 679 0
 1471 0b6c 00E08DE5 		str	lr, [sp, #0]
 1472 0b70 FEFFFFEB 		bl	SensorRead2B
 680:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1473              		.loc 1 680 0
 1474 0b74 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 681:../uvc.c      **** 				if(CmdDataLen == 2){
 1475              		.loc 1 681 0
 1476 0b78 020056E3 		cmp	r6, #2
 680:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1477              		.loc 1 680 0
 1478 0b7c 6930C4E5 		strb	r3, [r4, #105]
 682:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1479              		.loc 1 682 0
 1480 0b80 35C0DD05 		ldreqb	ip, [sp, #53]	@ zero_extendqisi2
 1481 0b84 9C319F05 		ldreq	r3, .L119
 1482 0b88 6AC0C305 		streqb	ip, [r3, #106]
 1483 0b8c CFFFFFEA 		b	.L106
 1484              	.L102:
 639:../uvc.c      **** 		else if (I2CCMDArry[2] == 1){
 1485              		.loc 1 639 0
 1486 0b90 010053E3 		cmp	r3, #1
 1487 0b94 0A00000A 		beq	.L117
 643:../uvc.c      **** 		else if(I2CCMDArry[2] == 2){
 1488              		.loc 1 643 0
 1489 0b98 020053E3 		cmp	r3, #2
 1490 0b9c CBFFFF1A 		bne	.L106
 1491              	.LVL111:
 1492              	.LBB63:
 645:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 1493              		.loc 1 645 0
 1494 0ba0 0520A0E1 		mov	r2, r5
 1495 0ba4 0110A0E3 		mov	r1, #1
 1496 0ba8 FEFFFFEB 		bl	_txe_event_flags_set
 1497              	.LVL112:
 647:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
 1498              		.loc 1 647 0
 1499 0bac 002050E2 		subs	r2, r0, #0
 1500 0bb0 C6FFFF0A 		beq	.L106
 649:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 1501              		.loc 1 649 0
 1502 0bb4 7C119FE5 		ldr	r1, .L119+16
 1503 0bb8 0400A0E3 		mov	r0, #4
 1504              	.LVL113:
 1505 0bbc FEFFFFEB 		bl	CyU3PDebugPrint
 1506              	.LVL114:
 1507 0bc0 C2FFFFEA 		b	.L106
 1508              	.L117:
 1509              	.LBE63:
 640:../uvc.c      **** 			I2CCMDArry[9] = debugData[2];  // stream status
 1510              		.loc 1 640 0
 1511 0bc4 2E20D0E5 		ldrb	r2, [r0, #46]	@ zero_extendqisi2
 641:../uvc.c      **** 			I2CCMDArry[10] = debugData[3]; //abort code
 1512              		.loc 1 641 0
 1513 0bc8 2F10D0E5 		ldrb	r1, [r0, #47]	@ zero_extendqisi2
 640:../uvc.c      **** 			I2CCMDArry[9] = debugData[2];  // stream status
 1514              		.loc 1 640 0
 1515 0bcc 6920C0E5 		strb	r2, [r0, #105]
 641:../uvc.c      **** 			I2CCMDArry[10] = debugData[3]; //abort code
 1516              		.loc 1 641 0
 1517 0bd0 6A10C0E5 		strb	r1, [r0, #106]
 1518 0bd4 BDFFFFEA 		b	.L106
 1519              	.L115:
 656:../uvc.c      **** 			debugData[0] = 0x00;  //
 1520              		.loc 1 656 0
 1521 0bd8 0000A0E3 		mov	r0, #0
 1522 0bdc 2C00C4E5 		strb	r0, [r4, #44]
 657:../uvc.c      **** 			debugData[1] = 0x00;  //
 1523              		.loc 1 657 0
 1524 0be0 2D00C4E5 		strb	r0, [r4, #45]
 658:../uvc.c      **** 			debugData[2] = 0x00;
 1525              		.loc 1 658 0
 1526 0be4 2E00C4E5 		strb	r0, [r4, #46]
 1527 0be8 BDFFFFEA 		b	.L96
 1528              	.L116:
 688:../uvc.c      **** 	}else if(CmdType == 1){
 1529              		.loc 1 688 0
 1530 0bec 010055E3 		cmp	r5, #1
 1531 0bf0 BBFFFF1A 		bne	.L96
 690:../uvc.c      **** 			if(CmdRegLen == 2){
 1532              		.loc 1 690 0
 1533 0bf4 020057E3 		cmp	r7, #2
 1534 0bf8 2900000A 		beq	.L118
 695:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1535              		.loc 1 695 0
 1536 0bfc 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 1537 0c00 20319FE5 		ldr	r3, .L119
 1538 0c04 FE1001E2 		and	r1, r1, #254
 1539 0c08 820051E3 		cmp	r1, #130
 698:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1540              		.loc 1 698 0
 1541 0c0c 6460D315 		ldrneb	r6, [r3, #100]	@ zero_extendqisi2
 1542              	.LVL115:
 695:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1543              		.loc 1 695 0
 1544 0c10 0200001A 		bne	.L113
 695:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1545              		.loc 1 695 0 is_stmt 0 discriminator 1
 1546 0c14 6460D3E5 		ldrb	r6, [r3, #100]	@ zero_extendqisi2
 1547 0c18 300056E3 		cmp	r6, #48
 1548 0c1c 0C00000A 		beq	.L109
 1549              	.L113:
 698:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1550              		.loc 1 698 0 is_stmt 1
 1551 0c20 6530D3E5 		ldrb	r3, [r3, #101]	@ zero_extendqisi2
 1552              	.L110:
 700:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1553              		.loc 1 700 0
 1554 0c24 6200D4E5 		ldrb	r0, [r4, #98]	@ zero_extendqisi2
 1555 0c28 69E0D4E5 		ldrb	lr, [r4, #105]	@ zero_extendqisi2
 1556 0c2c FE0000E2 		and	r0, r0, #254
 1557 0c30 0620A0E1 		mov	r2, r6
 1558 0c34 00E08DE5 		str	lr, [sp, #0]
 1559 0c38 FEFFFFEB 		bl	SensorWrite2B
 1560              	.LVL116:
 1561              	.L111:
 701:../uvc.c      **** 				if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 1562              		.loc 1 701 0
 1563 0c3c 6510D4E5 		ldrb	r1, [r4, #101]	@ zero_extendqisi2
 1564 0c40 010051E3 		cmp	r1, #1
 1565 0c44 DC109F05 		ldreq	r1, .L119
 1566 0c48 0020A003 		moveq	r2, #0
 1567 0c4c 70208105 		streq	r2, [r1, #112]
 1568 0c50 A3FFFFEA 		b	.L96
 1569              	.LVL117:
 1570              	.L109:
 695:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1571              		.loc 1 695 0 discriminator 1
 1572 0c54 6530D3E5 		ldrb	r3, [r3, #101]	@ zero_extendqisi2
 1573 0c58 100053E3 		cmp	r3, #16
 1574 0c5c F0FFFF1A 		bne	.L110
 696:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1575              		.loc 1 696 0
 1576 0c60 D4509FE5 		ldr	r5, .L119+20
 1577              	.LVL118:
 1578 0c64 0010E0E3 		mvn	r1, #0
 1579 0c68 1C0095E5 		ldr	r0, [r5, #28]
 1580 0c6c 2C308DE5 		str	r3, [sp, #44]
 1581 0c70 FEFFFFEB 		bl	_txe_mutex_get
 697:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1582              		.loc 1 697 0
 1583 0c74 2C309DE5 		ldr	r3, [sp, #44]
 1584 0c78 00C0A0E3 		mov	ip, #0
 1585 0c7c 0320A0E1 		mov	r2, r3
 1586 0c80 0500A0E1 		mov	r0, r5
 1587 0c84 1710A0E3 		mov	r1, #23
 1588 0c88 0630A0E1 		mov	r3, r6
 1589 0c8c 00C08DE5 		str	ip, [sp, #0]
 1590 0c90 04C08DE5 		str	ip, [sp, #4]
 1591 0c94 FEFFFFEB 		bl	cmdSet
 698:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1592              		.loc 1 698 0
 1593 0c98 1C0095E5 		ldr	r0, [r5, #28]
 1594 0c9c FEFFFFEB 		bl	_txe_mutex_put
 1595 0ca0 E5FFFFEA 		b	.L111
 1596              	.LVL119:
 1597              	.L118:
 692:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1598              		.loc 1 692 0
 1599 0ca4 6220D4E5 		ldrb	r2, [r4, #98]	@ zero_extendqisi2
 1600 0ca8 69E0D4E5 		ldrb	lr, [r4, #105]	@ zero_extendqisi2
 1601 0cac 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 1602 0cb0 6430D4E5 		ldrb	r3, [r4, #100]	@ zero_extendqisi2
 1603 0cb4 FE0002E2 		and	r0, r2, #254
 1604 0cb8 0020A0E3 		mov	r2, #0
 1605 0cbc 00E08DE5 		str	lr, [sp, #0]
 1606 0cc0 FEFFFFEB 		bl	SensorWrite2B2
 1607 0cc4 6200D4E5 		ldrb	r0, [r4, #98]	@ zero_extendqisi2
 1608 0cc8 69C0D4E5 		ldrb	ip, [r4, #105]	@ zero_extendqisi2
 1609 0ccc 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 1610 0cd0 6430D4E5 		ldrb	r3, [r4, #100]	@ zero_extendqisi2
 1611 0cd4 0020A0E3 		mov	r2, #0
 1612 0cd8 FE0000E2 		and	r0, r0, #254
 1613 0cdc 00C08DE5 		str	ip, [sp, #0]
 1614 0ce0 FEFFFFEB 		bl	SensorWrite2B2
 1615              	.LVL120:
 1616 0ce4 6220D4E5 		ldrb	r2, [r4, #98]	@ zero_extendqisi2
 1617 0ce8 69C0D4E5 		ldrb	ip, [r4, #105]	@ zero_extendqisi2
 1618 0cec 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 1619 0cf0 6430D4E5 		ldrb	r3, [r4, #100]	@ zero_extendqisi2
 1620 0cf4 FE0002E2 		and	r0, r2, #254
 1621 0cf8 0020A0E3 		mov	r2, #0
 1622 0cfc 00C08DE5 		str	ip, [sp, #0]
 1623 0d00 FEFFFFEB 		bl	SensorWrite2B2
 1624 0d04 6200D4E5 		ldrb	r0, [r4, #98]	@ zero_extendqisi2
 1625 0d08 69C0D4E5 		ldrb	ip, [r4, #105]	@ zero_extendqisi2
 1626 0d0c 6310D4E5 		ldrb	r1, [r4, #99]	@ zero_extendqisi2
 1627 0d10 6430D4E5 		ldrb	r3, [r4, #100]	@ zero_extendqisi2
 1628 0d14 0020A0E3 		mov	r2, #0
 1629 0d18 FE0000E2 		and	r0, r0, #254
 1630 0d1c 00C08DE5 		str	ip, [sp, #0]
 1631 0d20 FEFFFFEB 		bl	SensorWrite2B2
 1632 0d24 6EFFFFEA 		b	.L96
 1633              	.L120:
 1634              		.align	2
 1635              	.L119:
 1636 0d28 00000000 		.word	.LANCHOR0
 1637 0d2c 44020000 		.word	.LC16
 1638 0d30 00000000 		.word	.LANCHOR1
 1639 0d34 90020000 		.word	.LC17
 1640 0d38 50000000 		.word	.LC3
 1641 0d3c 00000000 		.word	cmdQu
 1642              		.cfi_endproc
 1643              	.LFE0:
 1645              		.align	2
 1646              		.global	setIrisauto
 1648              	setIrisauto:
 1649              	.LFB1:
 714:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1650              		.loc 1 714 0
 1651              		.cfi_startproc
 1652              		@ args = 0, pretend = 0, frame = 0
 1653              		@ frame_needed = 0, uses_anonymous_args = 0
 1654              	.LVL121:
 1655 0d40 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1656              	.LCFI12:
 1657              		.cfi_def_cfa_offset 16
 1658 0d44 0160A0E1 		mov	r6, r1
 1659              		.cfi_offset 14, -4
 1660              		.cfi_offset 6, -8
 1661              		.cfi_offset 5, -12
 1662              		.cfi_offset 4, -16
 1663 0d48 08D04DE2 		sub	sp, sp, #8
 1664              	.LCFI13:
 1665              		.cfi_def_cfa_offset 24
 714:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1666              		.loc 1 714 0
 1667 0d4c 0040A0E1 		mov	r4, r0
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1668              		.loc 1 717 0
 1669 0d50 0050A0E3 		mov	r5, #0
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1670              		.loc 1 716 0
 1671 0d54 0010E0E3 		mvn	r1, #0
 1672              	.LVL122:
 1673 0d58 1C0090E5 		ldr	r0, [r0, #28]
 1674              	.LVL123:
 1675 0d5c FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1676              		.loc 1 717 0
 1677 0d60 060065E0 		rsb	r0, r5, r6
 1678 0d64 00C070E2 		rsbs	ip, r0, #0
 1679 0d68 00C0ACE0 		adc	ip, ip, r0
 1680 0d6c 2010A0E3 		mov	r1, #32
 1681 0d70 2720A0E3 		mov	r2, #39
 1682 0d74 3030A0E3 		mov	r3, #48
 1683 0d78 0400A0E1 		mov	r0, r4
 1684 0d7c 00C08DE5 		str	ip, [sp, #0]
 1685 0d80 04508DE5 		str	r5, [sp, #4]
 1686 0d84 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1687              		.loc 1 718 0
 1688 0d88 050056E1 		cmp	r6, r5
 1689 0d8c 0260A003 		moveq	r6, #2
 1690 0d90 0160A013 		movne	r6, #1
 1691 0d94 0400A0E1 		mov	r0, r4
 1692 0d98 2110A0E3 		mov	r1, #33
 1693 0d9c 2520A0E3 		mov	r2, #37
 1694 0da0 3030A0E3 		mov	r3, #48
 1695 0da4 00608DE5 		str	r6, [sp, #0]
 1696 0da8 04508DE5 		str	r5, [sp, #4]
 1697 0dac FEFFFFEB 		bl	cmdSet
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1698              		.loc 1 719 0
 1699 0db0 1C0094E5 		ldr	r0, [r4, #28]
 720:../uvc.c      **** }
 1700              		.loc 1 720 0
 1701 0db4 08D08DE2 		add	sp, sp, #8
 1702 0db8 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1703              		.loc 1 719 0
 1704 0dbc FEFFFFEA 		b	_txe_mutex_put
 1705              		.cfi_endproc
 1706              	.LFE1:
 1708              		.align	2
 1709              		.global	getShutCtrl
 1711              	getShutCtrl:
 1712              	.LFB2:
 724:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1713              		.loc 1 724 0
 1714              		.cfi_startproc
 1715              		@ args = 0, pretend = 0, frame = 0
 1716              		@ frame_needed = 0, uses_anonymous_args = 0
 1717              	.LVL124:
 729:../uvc.c      **** 	switch (Data){
 1718              		.loc 1 729 0
 1719 0dc0 013040E2 		sub	r3, r0, #1
 724:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1720              		.loc 1 724 0
 1721 0dc4 10402DE9 		stmfd	sp!, {r4, lr}
 1722              	.LCFI14:
 1723              		.cfi_def_cfa_offset 8
 1724 0dc8 08D04DE2 		sub	sp, sp, #8
 1725              	.LCFI15:
 1726              		.cfi_def_cfa_offset 16
 729:../uvc.c      **** 	switch (Data){
 1727              		.loc 1 729 0
 1728 0dcc 090053E3 		cmp	r3, #9
 1729 0dd0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1730 0dd4 380000EA 		b	.L125
 1731              		.cfi_offset 14, -4
 1732              		.cfi_offset 4, -8
 1733              	.L128:
 1734 0dd8 700E0000 		.word	.L126
 1735 0ddc 700E0000 		.word	.L126
 1736 0de0 700E0000 		.word	.L126
 1737 0de4 700E0000 		.word	.L126
 1738 0de8 700E0000 		.word	.L126
 1739 0dec 000E0000 		.word	.L127
 1740 0df0 000E0000 		.word	.L127
 1741 0df4 000E0000 		.word	.L127
 1742 0df8 000E0000 		.word	.L127
 1743 0dfc 000E0000 		.word	.L127
 1744              	.L127:
 1745              	.LVL125:
 753:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1746              		.loc 1 753 0
 1747 0e00 ECC09FE5 		ldr	ip, .L137
 751:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1748              		.loc 1 751 0
 1749 0e04 8330A0E1 		mov	r3, r3, asl #1
 753:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1750              		.loc 1 753 0
 1751 0e08 B3309CE1 		ldrh	r3, [ip, r3]
 1752 0e0c E4E09FE5 		ldr	lr, .L137+4
 1753 0e10 032263E0 		rsb	r2, r3, r3, asl #4
 1754 0e14 8240A0E1 		mov	r4, r2, asl #1
 1755 0e18 94CECEE0 		smull	ip, lr, r4, lr
 1756 0e1c C4CFA0E1 		mov	ip, r4, asr #31
 1757 0e20 4E246CE0 		rsb	r2, ip, lr, asr #8
 754:../uvc.c      **** 		if(NumLn > 1944)
 1758              		.loc 1 754 0
 1759 0e24 D0E09FE5 		ldr	lr, .L137+8
 753:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1760              		.loc 1 753 0
 1761 0e28 0228A0E1 		mov	r2, r2, asl #16
 1762 0e2c 22C8A0E1 		mov	ip, r2, lsr #16
 1763              	.LVL126:
 754:../uvc.c      **** 		if(NumLn > 1944)
 1764              		.loc 1 754 0
 1765 0e30 0E005CE1 		cmp	ip, lr
 1766 0e34 2600008A 		bhi	.L134
 756:../uvc.c      **** 		else if(NumLn < 8)
 1767              		.loc 1 756 0
 1768 0e38 07005CE3 		cmp	ip, #7
 1769 0e3c 2700008A 		bhi	.L136
 1770              	.LVL127:
 1771              	.L135:
 1772 0e40 01C0A0E3 		mov	ip, #1
 1773 0e44 08E0A0E3 		mov	lr, #8
 1774 0e48 0C40A0E1 		mov	r4, ip
 1775              	.L131:
 1776              	.LVL128:
 759:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1777              		.loc 1 759 0
 1778 0e4c 0120A0E3 		mov	r2, #1
 1779 0e50 0020C1E5 		strb	r2, [r1, #0]
 760:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1780              		.loc 1 760 0
 1781 0e54 0020A0E1 		mov	r2, r0
 1782 0e58 A0109FE5 		ldr	r1, .L137+12
 1783              	.LVL129:
 1784 0e5c 0400A0E3 		mov	r0, #4
 1785              	.LVL130:
 1786 0e60 00E08DE5 		str	lr, [sp, #0]
 1787 0e64 04C08DE5 		str	ip, [sp, #4]
 1788 0e68 FEFFFFEB 		bl	CyU3PDebugPrint
 761:../uvc.c      **** 		break;
 1789              		.loc 1 761 0
 1790 0e6c 150000EA 		b	.L130
 1791              	.LVL131:
 1792              	.L126:
 735:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1793              		.loc 1 735 0
 1794 0e70 7CE09FE5 		ldr	lr, .L137
 1795 0e74 8330A0E1 		mov	r3, r3, asl #1
 1796 0e78 B3309EE1 		ldrh	r3, [lr, r3]
 1797              	.LVL132:
 737:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1798              		.loc 1 737 0
 1799 0e7c 80C09FE5 		ldr	ip, .L137+16
 738:../uvc.c      **** 		if(NumLn > 1944)
 1800              		.loc 1 738 0
 1801 0e80 74E09FE5 		ldr	lr, .L137+8
 737:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1802              		.loc 1 737 0
 1803 0e84 932C8CE0 		umull	r2, ip, r3, ip
 1804 0e88 AC24A0E1 		mov	r2, ip, lsr #9
 1805 0e8c 024262E0 		rsb	r4, r2, r2, asl #4
 1806 0e90 8448A0E1 		mov	r4, r4, asl #17
 1807 0e94 2428A0E1 		mov	r2, r4, lsr #16
 1808              	.LVL133:
 738:../uvc.c      **** 		if(NumLn > 1944)
 1809              		.loc 1 738 0
 1810 0e98 0E0052E1 		cmp	r2, lr
 1811 0e9c 0C00008A 		bhi	.L134
 740:../uvc.c      **** 		else if(NumLn < 8)
 1812              		.loc 1 740 0
 1813 0ea0 070052E3 		cmp	r2, #7
 1814 0ea4 E5FFFF9A 		bls	.L135
 1815 0ea8 A449A0E1 		mov	r4, r4, lsr #19
 1816 0eac FF4004E2 		and	r4, r4, #255
 1817 0eb0 02E0A0E1 		mov	lr, r2
 1818 0eb4 04C0A0E1 		mov	ip, r4
 1819 0eb8 E3FFFFEA 		b	.L131
 1820              	.LVL134:
 1821              	.L125:
 764:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1822              		.loc 1 764 0
 1823 0ebc 0000A0E3 		mov	r0, #0
 1824              	.LVL135:
 765:../uvc.c      **** 		LnVal = 1;
 1825              		.loc 1 765 0
 1826 0ec0 0140A0E3 		mov	r4, #1
 764:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1827              		.loc 1 764 0
 1828 0ec4 0000C1E5 		strb	r0, [r1, #0]
 1829              	.LVL136:
 1830              	.L130:
 769:../uvc.c      **** }
 1831              		.loc 1 769 0
 1832 0ec8 0400A0E1 		mov	r0, r4
 1833 0ecc 08D08DE2 		add	sp, sp, #8
 1834 0ed0 1080BDE8 		ldmfd	sp!, {r4, pc}
 1835              	.LVL137:
 1836              	.L134:
 754:../uvc.c      **** 		if(NumLn > 1944)
 1837              		.loc 1 754 0
 1838 0ed4 F3C0A0E3 		mov	ip, #243
 1839 0ed8 0C40A0E1 		mov	r4, ip
 1840 0edc DAFFFFEA 		b	.L131
 1841              	.LVL138:
 1842              	.L136:
 756:../uvc.c      **** 		else if(NumLn < 8)
 1843              		.loc 1 756 0
 1844 0ee0 A2E9A0E1 		mov	lr, r2, lsr #19
 1845 0ee4 FF400EE2 		and	r4, lr, #255
 1846 0ee8 0CE0A0E1 		mov	lr, ip
 1847 0eec 04C0A0E1 		mov	ip, r4
 1848              	.LVL139:
 1849 0ef0 D5FFFFEA 		b	.L131
 1850              	.L138:
 1851              		.align	2
 1852              	.L137:
 1853 0ef4 00000000 		.word	.LANCHOR2
 1854 0ef8 817F807F 		.word	2139127681
 1855 0efc 98070000 		.word	1944
 1856 0f00 B8020000 		.word	.LC18
 1857 0f04 01FF00FF 		.word	-16711935
 1858              		.cfi_endproc
 1859              	.LFE2:
 1861              		.align	2
 1862              		.global	ControlHandle
 1864              	ControlHandle:
 1865              	.LFB3:
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1866              		.loc 1 771 0
 1867              		.cfi_startproc
 1868              		@ args = 0, pretend = 0, frame = 24
 1869              		@ frame_needed = 0, uses_anonymous_args = 0
 1870              	.LVL140:
 1871 0f08 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1872              	.LCFI16:
 1873              		.cfi_def_cfa_offset 36
 778:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1874              		.loc 1 778 0
 1875 0f0c 230050E3 		cmp	r0, #35
 777:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1876              		.loc 1 777 0
 1877 0f10 207040E2 		sub	r7, r0, #32
 1878              		.cfi_offset 14, -4
 1879              		.cfi_offset 11, -8
 1880              		.cfi_offset 10, -12
 1881              		.cfi_offset 9, -16
 1882              		.cfi_offset 8, -20
 1883              		.cfi_offset 7, -24
 1884              		.cfi_offset 6, -28
 1885              		.cfi_offset 5, -32
 1886              		.cfi_offset 4, -36
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1887              		.loc 1 771 0
 1888 0f14 2CD04DE2 		sub	sp, sp, #44
 1889              	.LCFI17:
 1890              		.cfi_def_cfa_offset 80
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1891              		.loc 1 771 0
 1892 0f18 0040A0E1 		mov	r4, r0
 777:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1893              		.loc 1 777 0
 1894 0f1c FF7007E2 		and	r7, r7, #255
 1895              	.LVL141:
 778:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1896              		.loc 1 778 0
 1897 0f20 2300009A 		bls	.L140
 779:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1898              		.loc 1 779 0
 1899 0f24 586F9FE5 		ldr	r6, .L321+72
 1900 0f28 872087E0 		add	r2, r7, r7, asl #1
 1901 0f2c 8221A0E1 		mov	r2, r2, asl #3
 1902 0f30 023086E0 		add	r3, r6, r2
 780:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1903              		.loc 1 780 0
 1904 0f34 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 781:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1905              		.loc 1 781 0
 1906 0f38 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 782:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1907              		.loc 1 782 0
 1908 0f3c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 793:../uvc.c      ****     reqData = bRequest;
 1909              		.loc 1 793 0
 1910 0f40 F43E9FE5 		ldr	r3, .L321
 779:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1911              		.loc 1 779 0
 1912 0f44 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1913              	.LVL142:
 793:../uvc.c      ****     reqData = bRequest;
 1914              		.loc 1 793 0
 1915 0f48 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1916              	.LVL143:
 801:../uvc.c      ****     switch (bRequest)
 1917              		.loc 1 801 0
 1918 0f4c 830055E3 		cmp	r5, #131
 1919 0f50 2200000A 		beq	.L146
 1920              	.LVL144:
 1921              	.L311:
 1922 0f54 2B00009A 		bls	.L309
 1923 0f58 850055E3 		cmp	r5, #133
 1924 0f5c 8800000A 		beq	.L148
 1925 0f60 7600003A 		bcc	.L147
 1926 0f64 860055E3 		cmp	r5, #134
 1927 0f68 C500000A 		beq	.L149
 1928 0f6c 870055E3 		cmp	r5, #135
 1929 0f70 B900000A 		beq	.L310
 1930              	.L142:
1687:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1931              		.loc 1 1687 0
 1932 0f74 0000A0E3 		mov	r0, #0
 1933              	.LVL145:
 1934 0f78 0110A0E3 		mov	r1, #1
 1935 0f7c 0020A0E1 		mov	r2, r0
 1936 0f80 FEFFFFEB 		bl	CyU3PUsbStall
1688:../uvc.c      **** 			  break;
 1937              		.loc 1 1688 0
 1938 0f84 FFA0A0E3 		mov	sl, #255
 1939 0f88 0A70A0E1 		mov	r7, sl
 1940              	.LVL146:
 1941 0f8c 0A40A0E1 		mov	r4, sl
 1942 0f90 0A80A0E1 		mov	r8, sl
 1943              	.LVL147:
 1944              	.L152:
1690:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1945              		.loc 1 1690 0
 1946 0f94 A41E9FE5 		ldr	r1, .L321+4
 1947 0f98 0520A0E1 		mov	r2, r5
 1948 0f9c 0830A0E1 		mov	r3, r8
 1949 0fa0 0400A0E3 		mov	r0, #4
 1950 0fa4 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 1951 0fa8 FEFFFFEB 		bl	CyU3PDebugPrint
1691:../uvc.c      **** }
 1952              		.loc 1 1691 0
 1953 0fac 2CD08DE2 		add	sp, sp, #44
 1954 0fb0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1955              	.LVL148:
 1956              	.L140:
 784:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1957              		.loc 1 784 0
 1958 0fb4 C86E9FE5 		ldr	r6, .L321+72
 793:../uvc.c      ****     reqData = bRequest;
 1959              		.loc 1 793 0
 1960 0fb8 7C3E9FE5 		ldr	r3, .L321
 784:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1961              		.loc 1 784 0
 1962 0fbc 808080E0 		add	r8, r0, r0, asl #1
 1963 0fc0 885186E0 		add	r5, r6, r8, asl #3
 1964 0fc4 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 1965              	.LVL149:
 785:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1966              		.loc 1 785 0
 1967 0fc8 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 1968              	.LVL150:
 786:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1969              		.loc 1 786 0
 1970 0fcc 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 1971              	.LVL151:
 787:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1972              		.loc 1 787 0
 1973 0fd0 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 1974              	.LVL152:
 793:../uvc.c      ****     reqData = bRequest;
 1975              		.loc 1 793 0
 1976 0fd4 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1977              	.LVL153:
 801:../uvc.c      ****     switch (bRequest)
 1978              		.loc 1 801 0
 1979 0fd8 830055E3 		cmp	r5, #131
 1980 0fdc DCFFFF1A 		bne	.L311
 1981              	.LVL154:
 1982              	.L146:
1171:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1983              		.loc 1 1171 0
 1984 0fe0 230054E3 		cmp	r4, #35
 1985 0fe4 C400009A 		bls	.L219
1172:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1986              		.loc 1 1172 0
 1987 0fe8 872087E0 		add	r2, r7, r7, asl #1
 1988 0fec 826186E0 		add	r6, r6, r2, asl #3
 1989 0ff0 909E9FE5 		ldr	r9, .L321+76
 1990 0ff4 0530D6E5 		ldrb	r3, [r6, #5]	@ zero_extendqisi2
1173:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1991              		.loc 1 1173 0
 1992 0ff8 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 1993              	.LVL155:
1172:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1994              		.loc 1 1172 0
 1995 0ffc 7430C9E5 		strb	r3, [r9, #116]
1173:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1996              		.loc 1 1173 0
 1997 1000 7500C9E5 		strb	r0, [r9, #117]
 1998 1004 0B0000EA 		b	.L227
 1999              	.LVL156:
 2000              	.L309:
 801:../uvc.c      ****     switch (bRequest)
 2001              		.loc 1 801 0
 2002 1008 810055E3 		cmp	r5, #129
 2003 100c 6800000A 		beq	.L144
 2004 1010 1000009A 		bls	.L312
1152:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2005              		.loc 1 1152 0
 2006 1014 230054E3 		cmp	r4, #35
 2007 1018 AB00009A 		bls	.L216
1153:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2008              		.loc 1 1153 0
 2009 101c 879087E0 		add	r9, r7, r7, asl #1
 2010 1020 896186E0 		add	r6, r6, r9, asl #3
 2011 1024 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 2012              	.LVL157:
 2013 1028 589E9FE5 		ldr	r9, .L321+76
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2014              		.loc 1 1154 0
 2015 102c 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
1153:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2016              		.loc 1 1153 0
 2017 1030 7470C9E5 		strb	r7, [r9, #116]
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2018              		.loc 1 1154 0
 2019 1034 75E0C9E5 		strb	lr, [r9, #117]
 2020              	.LVL158:
 2021              	.L227:
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2022              		.loc 1 1229 0
 2023 1038 0800A0E1 		mov	r0, r8
1231:../uvc.c      **** 			  break;
 2024              		.loc 1 1231 0
 2025 103c FFA0A0E3 		mov	sl, #255
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2026              		.loc 1 1229 0
 2027 1040 FC1D9FE5 		ldr	r1, .L321+8
 2028 1044 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2029              	.LVL159:
1231:../uvc.c      **** 			  break;
 2030              		.loc 1 1231 0
 2031 1048 0A40A0E1 		mov	r4, sl
1229:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2032              		.loc 1 1229 0
 2033 104c 7470D9E5 		ldrb	r7, [r9, #116]	@ zero_extendqisi2
1231:../uvc.c      **** 			  break;
 2034              		.loc 1 1231 0
 2035 1050 0A80A0E1 		mov	r8, sl
 2036 1054 CEFFFFEA 		b	.L152
 2037              	.LVL160:
 2038              	.L312:
 801:../uvc.c      ****     switch (bRequest)
 2039              		.loc 1 801 0
 2040 1058 010055E3 		cmp	r5, #1
 2041 105c C4FFFF1A 		bne	.L142
1233:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 2042              		.loc 1 1233 0
 2043 1060 201E9FE5 		ldr	r1, .L321+76
 2044 1064 26208DE2 		add	r2, sp, #38
 2045 1068 2000A0E3 		mov	r0, #32
 2046              	.LVL161:
 2047 106c 741081E2 		add	r1, r1, #116
 2048 1070 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2049              	.LVL162:
1235:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 2050              		.loc 1 1235 0
 2051 1074 002050E2 		subs	r2, r0, #0
 2052 1078 4A04001A 		bne	.L229
1237:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2053              		.loc 1 1237 0
 2054 107c 04CE9FE5 		ldr	ip, .L321+76
1238:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2055              		.loc 1 1238 0
 2056 1080 00EE9FE5 		ldr	lr, .L321+76
1237:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2057              		.loc 1 1237 0
 2058 1084 7430DCE5 		ldrb	r3, [ip, #116]	@ zero_extendqisi2
1240:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2059              		.loc 1 1240 0
 2060 1088 7600DEE5 		ldrb	r0, [lr, #118]	@ zero_extendqisi2
 2061              	.LVL163:
1237:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2062              		.loc 1 1237 0
 2063 108c 18308DE5 		str	r3, [sp, #24]
 2064              	.LVL164:
1238:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2065              		.loc 1 1238 0
 2066 1090 75C0DEE5 		ldrb	ip, [lr, #117]	@ zero_extendqisi2
 2067              	.LVL165:
1240:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2068              		.loc 1 1240 0
 2069 1094 1C008DE5 		str	r0, [sp, #28]
 2070              	.LVL166:
1244:../uvc.c      **** 				  switch(CtrlID)
 2071              		.loc 1 1244 0
 2072 1098 260054E3 		cmp	r4, #38
 2073 109c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2074 10a0 790300EA 		b	.L230
 2075              	.L248:
 2076 10a4 D01D0000 		.word	.L231
 2077 10a8 641D0000 		.word	.L232
 2078 10ac 041D0000 		.word	.L233
 2079 10b0 8C1E0000 		.word	.L230
 2080 10b4 A01C0000 		.word	.L234
 2081 10b8 601B0000 		.word	.L235
 2082 10bc E81A0000 		.word	.L236
 2083 10c0 28210000 		.word	.L237
 2084 10c4 8C1E0000 		.word	.L230
 2085 10c8 8C1E0000 		.word	.L230
 2086 10cc 8C1E0000 		.word	.L230
 2087 10d0 A4200000 		.word	.L238
 2088 10d4 8C1E0000 		.word	.L230
 2089 10d8 8C1E0000 		.word	.L230
 2090 10dc 8C1E0000 		.word	.L230
 2091 10e0 8C1E0000 		.word	.L230
 2092 10e4 C81F0000 		.word	.L239
 2093 10e8 8C1E0000 		.word	.L230
 2094 10ec 8C1E0000 		.word	.L230
 2095 10f0 8C1E0000 		.word	.L230
 2096 10f4 8C1E0000 		.word	.L230
 2097 10f8 8C1E0000 		.word	.L230
 2098 10fc 8C1E0000 		.word	.L230
 2099 1100 8C1E0000 		.word	.L230
 2100 1104 8C1E0000 		.word	.L230
 2101 1108 F41E0000 		.word	.L240
 2102 110c 041D0000 		.word	.L233
 2103 1110 C4180000 		.word	.L241
 2104 1114 3C180000 		.word	.L242
 2105 1118 8C1E0000 		.word	.L230
 2106 111c E0170000 		.word	.L243
 2107 1120 5C170000 		.word	.L244
 2108 1124 8C1E0000 		.word	.L230
 2109 1128 8C1E0000 		.word	.L230
 2110 112c 8C1E0000 		.word	.L230
 2111 1130 8C1E0000 		.word	.L230
 2112 1134 CC190000 		.word	.L245
 2113 1138 58190000 		.word	.L246
 2114 113c 681A0000 		.word	.L247
 2115              	.LVL167:
 2116              	.L147:
1189:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2117              		.loc 1 1189 0
 2118 1140 230054E3 		cmp	r4, #35
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2119              		.loc 1 1196 0
 2120 1144 84408490 		addls	r4, r4, r4, asl #1
1190:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2121              		.loc 1 1190 0
 2122 1148 87708780 		addhi	r7, r7, r7, asl #1
 2123              	.LVL168:
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2124              		.loc 1 1196 0
 2125 114c 84618690 		addls	r6, r6, r4, asl #3
1190:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2126              		.loc 1 1190 0
 2127 1150 87618680 		addhi	r6, r6, r7, asl #3
 2128 1154 2C9D9F85 		ldrhi	r9, .L321+76
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2129              		.loc 1 1196 0
 2130 1158 289D9F95 		ldrls	r9, .L321+76
1190:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2131              		.loc 1 1190 0
 2132 115c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1191:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2133              		.loc 1 1191 0
 2134 1160 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2135              		.loc 1 1196 0
 2136 1164 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1197:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2137              		.loc 1 1197 0
 2138 1168 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1198:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2139              		.loc 1 1198 0
 2140 116c 0040A0E3 		mov	r4, #0
1196:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2141              		.loc 1 1196 0
 2142 1170 7410C9E5 		strb	r1, [r9, #116]
1197:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2143              		.loc 1 1197 0
 2144 1174 7520C9E5 		strb	r2, [r9, #117]
1198:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2145              		.loc 1 1198 0
 2146 1178 7640C9E5 		strb	r4, [r9, #118]
1199:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2147              		.loc 1 1199 0
 2148 117c 7740C9E5 		strb	r4, [r9, #119]
 2149 1180 ACFFFFEA 		b	.L227
 2150              	.LVL169:
 2151              	.L148:
 805:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2152              		.loc 1 805 0
 2153 1184 FC4C9FE5 		ldr	r4, .L321+76
 806:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2154              		.loc 1 806 0
 2155 1188 00A0A0E3 		mov	sl, #0
 805:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2156              		.loc 1 805 0
 2157 118c 7480C4E5 		strb	r8, [r4, #116]
 806:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2158              		.loc 1 806 0
 2159 1190 75A0C4E5 		strb	sl, [r4, #117]
 807:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2160              		.loc 1 807 0
 2161 1194 741084E2 		add	r1, r4, #116
 809:../uvc.c      **** 			  break;
 2162              		.loc 1 809 0
 2163 1198 FFA0A0E3 		mov	sl, #255
 807:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2164              		.loc 1 807 0
 2165 119c 0200A0E3 		mov	r0, #2
 2166              	.LVL170:
 2167 11a0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2168              	.LVL171:
 809:../uvc.c      **** 			  break;
 2169              		.loc 1 809 0
 2170 11a4 0A80A0E1 		mov	r8, sl
 807:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2171              		.loc 1 807 0
 2172 11a8 7470D4E5 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 2173              	.LVL172:
 809:../uvc.c      **** 			  break;
 2174              		.loc 1 809 0
 2175 11ac 0A40A0E1 		mov	r4, sl
 2176 11b0 77FFFFEA 		b	.L152
 2177              	.LVL173:
 2178              	.L144:
 812:../uvc.c      **** 			 switch(CtrlID)
 2179              		.loc 1 812 0
 2180 11b4 260054E3 		cmp	r4, #38
 2181 11b8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2182 11bc DB0000EA 		b	.L153
 2183              	.L170:
 2184 11c0 8C160000 		.word	.L154
 2185 11c4 CC150000 		.word	.L155
 2186 11c8 20160000 		.word	.L156
 2187 11cc 30150000 		.word	.L153
 2188 11d0 CC140000 		.word	.L157
 2189 11d4 3C170000 		.word	.L158
 2190 11d8 30150000 		.word	.L153
 2191 11dc F4150000 		.word	.L159
 2192 11e0 30150000 		.word	.L153
 2193 11e4 B8160000 		.word	.L160
 2194 11e8 30150000 		.word	.L153
 2195 11ec 00150000 		.word	.L161
 2196 11f0 30150000 		.word	.L153
 2197 11f4 30150000 		.word	.L153
 2198 11f8 30150000 		.word	.L153
 2199 11fc 30150000 		.word	.L153
 2200 1200 E0160000 		.word	.L162
 2201 1204 30150000 		.word	.L153
 2202 1208 30150000 		.word	.L153
 2203 120c 30150000 		.word	.L153
 2204 1210 30150000 		.word	.L153
 2205 1214 30150000 		.word	.L153
 2206 1218 30150000 		.word	.L153
 2207 121c 30150000 		.word	.L153
 2208 1220 30150000 		.word	.L153
 2209 1224 60150000 		.word	.L163
 2210 1228 20160000 		.word	.L156
 2211 122c 48160000 		.word	.L164
 2212 1230 A4140000 		.word	.L165
 2213 1234 30150000 		.word	.L153
 2214 1238 30150000 		.word	.L153
 2215 123c 78130000 		.word	.L166
 2216 1240 30150000 		.word	.L153
 2217 1244 30150000 		.word	.L153
 2218 1248 30150000 		.word	.L153
 2219 124c 30150000 		.word	.L153
 2220 1250 14140000 		.word	.L167
 2221 1254 78140000 		.word	.L168
 2222 1258 54140000 		.word	.L169
 2223              	.L310:
1216:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2224              		.loc 1 1216 0
 2225 125c 230054E3 		cmp	r4, #35
 2226 1260 3100009A 		bls	.L226
1217:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2227              		.loc 1 1217 0
 2228 1264 87A087E0 		add	sl, r7, r7, asl #1
 2229 1268 8A6186E0 		add	r6, r6, sl, asl #3
 2230 126c 149C9FE5 		ldr	r9, .L321+76
 2231 1270 0BC0D6E5 		ldrb	ip, [r6, #11]	@ zero_extendqisi2
1218:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2232              		.loc 1 1218 0
 2233 1274 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
1217:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2234              		.loc 1 1217 0
 2235 1278 74C0C9E5 		strb	ip, [r9, #116]
1218:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2236              		.loc 1 1218 0
 2237 127c 7510C9E5 		strb	r1, [r9, #117]
 2238 1280 6CFFFFEA 		b	.L227
 2239              	.L149:
1205:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2240              		.loc 1 1205 0
 2241 1284 230054E3 		cmp	r4, #35
1206:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2242              		.loc 1 1206 0
 2243 1288 87708780 		addhi	r7, r7, r7, asl #1
 2244              	.LVL174:
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2245              		.loc 1 1209 0
 2246 128c 84408490 		addls	r4, r4, r4, asl #1
1206:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2247              		.loc 1 1206 0
 2248 1290 87618680 		addhi	r6, r6, r7, asl #3
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2249              		.loc 1 1209 0
 2250 1294 84618690 		addls	r6, r6, r4, asl #3
1206:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2251              		.loc 1 1206 0
 2252 1298 E88B9F85 		ldrhi	r8, .L321+76
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2253              		.loc 1 1209 0
 2254 129c E48B9F95 		ldrls	r8, .L321+76
1206:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2255              		.loc 1 1206 0
 2256 12a0 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2257              		.loc 1 1209 0
 2258 12a4 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1214:../uvc.c      **** 			  break;
 2259              		.loc 1 1214 0
 2260 12a8 FFA0A0E3 		mov	sl, #255
1209:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2261              		.loc 1 1209 0
 2262 12ac 7430C8E5 		strb	r3, [r8, #116]
1211:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2263              		.loc 1 1211 0
 2264 12b0 0100A0E3 		mov	r0, #1
 2265              	.LVL175:
 2266 12b4 881B9FE5 		ldr	r1, .L321+8
 2267 12b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2268              	.LVL176:
1214:../uvc.c      **** 			  break;
 2269              		.loc 1 1214 0
 2270 12bc 0A40A0E1 		mov	r4, sl
1211:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2271              		.loc 1 1211 0
 2272 12c0 7470D8E5 		ldrb	r7, [r8, #116]	@ zero_extendqisi2
1214:../uvc.c      **** 			  break;
 2273              		.loc 1 1214 0
 2274 12c4 0A80A0E1 		mov	r8, sl
 2275 12c8 31FFFFEA 		b	.L152
 2276              	.LVL177:
 2277              	.L216:
1157:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2278              		.loc 1 1157 0
 2279 12cc 0B0054E3 		cmp	r4, #11
1164:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2280              		.loc 1 1164 0
 2281 12d0 84408410 		addne	r4, r4, r4, asl #1
 2282 12d4 84618610 		addne	r6, r6, r4, asl #3
 2283 12d8 A89B9F15 		ldrne	r9, .L321+76
1158:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2284              		.loc 1 1158 0
 2285 12dc A49B9F05 		ldreq	r9, .L321+76
 2286 12e0 603B9F05 		ldreq	r3, .L321+12
1164:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2287              		.loc 1 1164 0
 2288 12e4 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1165:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2289              		.loc 1 1165 0
 2290 12e8 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1158:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2291              		.loc 1 1158 0
 2292 12ec 74308905 		streq	r3, [r9, #116]
1164:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2293              		.loc 1 1164 0
 2294 12f0 7420C915 		strneb	r2, [r9, #116]
1165:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2295              		.loc 1 1165 0
 2296 12f4 7530C915 		strneb	r3, [r9, #117]
 2297 12f8 4EFFFFEA 		b	.L227
 2298              	.L219:
1175:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2299              		.loc 1 1175 0
 2300 12fc 0B0054E3 		cmp	r4, #11
1182:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2301              		.loc 1 1182 0
 2302 1300 84408410 		addne	r4, r4, r4, asl #1
 2303 1304 84618610 		addne	r6, r6, r4, asl #3
 2304 1308 789B9F15 		ldrne	r9, .L321+76
1176:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2305              		.loc 1 1176 0
 2306 130c 749B9F05 		ldreq	r9, .L321+76
 2307 1310 343B9F05 		ldreq	r3, .L321+16
1182:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2308              		.loc 1 1182 0
 2309 1314 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1183:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2310              		.loc 1 1183 0
 2311 1318 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1176:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2312              		.loc 1 1176 0
 2313 131c 74308905 		streq	r3, [r9, #116]
1182:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2314              		.loc 1 1182 0
 2315 1320 7420C915 		strneb	r2, [r9, #116]
1183:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2316              		.loc 1 1183 0
 2317 1324 7530C915 		strneb	r3, [r9, #117]
 2318 1328 42FFFFEA 		b	.L227
 2319              	.L226:
1220:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2320              		.loc 1 1220 0
 2321 132c 0B0054E3 		cmp	r4, #11
 2322 1330 0700000A 		beq	.L313
1226:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2323              		.loc 1 1226 0
 2324 1334 849084E0 		add	r9, r4, r4, asl #1
 2325 1338 896186E0 		add	r6, r6, r9, asl #3
 2326 133c 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2327 1340 409B9FE5 		ldr	r9, .L321+76
1227:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2328              		.loc 1 1227 0
 2329 1344 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1226:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2330              		.loc 1 1226 0
 2331 1348 7420C9E5 		strb	r2, [r9, #116]
1227:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2332              		.loc 1 1227 0
 2333 134c 7530C9E5 		strb	r3, [r9, #117]
 2334 1350 38FFFFEA 		b	.L227
 2335              	.L313:
1221:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2336              		.loc 1 1221 0
 2337 1354 2C9B9FE5 		ldr	r9, .L321+76
 2338 1358 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 2339              	.LVL178:
1223:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2340              		.loc 1 1223 0
 2341 135c 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2342              	.LVL179:
1222:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2343              		.loc 1 1222 0
 2344 1360 00E0A0E3 		mov	lr, #0
1221:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2345              		.loc 1 1221 0
 2346 1364 7400C9E5 		strb	r0, [r9, #116]
1222:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2347              		.loc 1 1222 0
 2348 1368 75E0C9E5 		strb	lr, [r9, #117]
1223:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2349              		.loc 1 1223 0
 2350 136c 7670C9E5 		strb	r7, [r9, #118]
1224:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2351              		.loc 1 1224 0
 2352 1370 77E0C9E5 		strb	lr, [r9, #119]
 2353 1374 2FFFFFEA 		b	.L227
 2354              	.LVL180:
 2355              	.L166:
 927:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2356              		.loc 1 927 0 discriminator 1
 2357 1378 000058E3 		cmp	r8, #0
 2358 137c EC04000A 		beq	.L305
 925:../uvc.c      **** 					 break;
 2359              		.loc 1 925 0
 2360 1380 28E1A0E1 		mov	lr, r8, lsr #2
 2361 1384 00005EE3 		cmp	lr, #0
 2362 1388 03005813 		cmpne	r8, #3
 2363 138c 0020A083 		movhi	r2, #0
 2364 1390 0120A093 		movls	r2, #1
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2365              		.loc 1 771 0
 2366 1394 0E31A0E1 		mov	r3, lr, asl #2
 925:../uvc.c      **** 					 break;
 2367              		.loc 1 925 0
 2368 1398 F004009A 		bls	.L285
 2369 139c A01A9FE5 		ldr	r1, .L321+8
 2370 13a0 140041E2 		sub	r0, r1, #20
 2371              	.LVL181:
 2372              	.L189:
 928:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2373              		.loc 1 928 0 discriminator 2
 2374 13a4 044090E4 		ldr	r4, [r0], #4
 2375 13a8 01A082E2 		add	sl, r2, #1
 2376 13ac FF200AE2 		and	r2, sl, #255
 2377 13b0 0E0052E1 		cmp	r2, lr
 2378 13b4 044081E4 		str	r4, [r1], #4
 2379 13b8 F9FFFF3A 		bcc	.L189
 928:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2380              		.loc 1 928 0 is_stmt 0
 2381 13bc 030058E1 		cmp	r8, r3
 2382 13c0 C00A9F15 		ldrne	r0, .L321+76
 2383 13c4 DA04000A 		beq	.L305
 2384              	.L298:
 2385 13c8 03C080E0 		add	ip, r0, r3
 2386 13cc 60E0DCE5 		ldrb	lr, [ip, #96]	@ zero_extendqisi2
 927:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2387              		.loc 1 927 0 is_stmt 1
 2388 13d0 013083E2 		add	r3, r3, #1
 2389 13d4 FF3003E2 		and	r3, r3, #255
 2390              	.LVL182:
 2391 13d8 030058E1 		cmp	r8, r3
 928:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2392              		.loc 1 928 0
 2393 13dc 74E0CCE5 		strb	lr, [ip, #116]
 927:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2394              		.loc 1 927 0
 2395 13e0 F8FFFF8A 		bhi	.L298
 2396              	.LVL183:
 2397              	.L172:
 937:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2398              		.loc 1 937 0
 2399 13e4 6B10D0E5 		ldrb	r1, [r0, #107]	@ zero_extendqisi2
 930:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2400              		.loc 1 930 0
 2401 13e8 983A9FE5 		ldr	r3, .L321+76
 937:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2402              		.loc 1 937 0
 2403 13ec FF0051E3 		cmp	r1, #255
 930:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2404              		.loc 1 930 0
 2405 13f0 7D70D0E5 		ldrb	r7, [r0, #125]	@ zero_extendqisi2
 2406              	.LVL184:
 931:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2407              		.loc 1 931 0
 2408 13f4 7EA0D0E5 		ldrb	sl, [r0, #126]	@ zero_extendqisi2
 2409              	.LVL185:
 937:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2410              		.loc 1 937 0
 2411 13f8 0F00000A 		beq	.L175
 939:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2412              		.loc 1 939 0
 2413 13fc 6920D3E5 		ldrb	r2, [r3, #105]	@ zero_extendqisi2
 2414 1400 481A9FE5 		ldr	r1, .L321+20
 2415 1404 6A30D3E5 		ldrb	r3, [r3, #106]	@ zero_extendqisi2
 2416 1408 0400A0E3 		mov	r0, #4
 2417 140c FEFFFFEB 		bl	CyU3PDebugPrint
 2418 1410 090000EA 		b	.L175
 2419              	.LVL186:
 2420              	.L167:
 816:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2421              		.loc 1 816 0
 2422 1414 6C4A9FE5 		ldr	r4, .L321+76
 2423 1418 B800D4E5 		ldrb	r0, [r4, #184]	@ zero_extendqisi2
 2424              	.LVL187:
 2425 141c 000050E3 		cmp	r0, #0
 2426 1420 0004000A 		beq	.L173
 817:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2427              		.loc 1 817 0
 2428 1424 9DC4D6E5 		ldrb	ip, [r6, #1181]	@ zero_extendqisi2
 818:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2429              		.loc 1 818 0
 2430 1428 9E14D6E5 		ldrb	r1, [r6, #1182]	@ zero_extendqisi2
 817:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2431              		.loc 1 817 0
 2432 142c FF700CE2 		and	r7, ip, #255
 2433              	.LVL188:
 818:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2434              		.loc 1 818 0
 2435 1430 FFA001E2 		and	sl, r1, #255
 817:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2436              		.loc 1 817 0
 2437 1434 7470C4E5 		strb	r7, [r4, #116]
 818:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2438              		.loc 1 818 0
 2439 1438 75A0C4E5 		strb	sl, [r4, #117]
 2440              	.LVL189:
 2441              	.L175:
1145:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2442              		.loc 1 1145 0
 2443 143c 0800A0E1 		mov	r0, r8
 2444 1440 FC199FE5 		ldr	r1, .L321+8
 2445 1444 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1150:../uvc.c      **** 			  break;
 2446              		.loc 1 1150 0
 2447 1448 FF40A0E3 		mov	r4, #255
 2448 144c 0480A0E1 		mov	r8, r4
 2449 1450 CFFEFFEA 		b	.L152
 2450              	.LVL190:
 2451              	.L169:
 849:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2452              		.loc 1 849 0
 2453 1454 2C4A9FE5 		ldr	r4, .L321+76
 2454 1458 BAB0D4E5 		ldrb	fp, [r4, #186]	@ zero_extendqisi2
 2455 145c 00005BE3 		cmp	fp, #0
 2456 1460 FF03000A 		beq	.L178
 850:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2457              		.loc 1 850 0
 2458 1464 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2459              	.LVL191:
 851:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2460              		.loc 1 851 0
 2461 1468 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 850:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2462              		.loc 1 850 0
 2463 146c 7470C4E5 		strb	r7, [r4, #116]
 851:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2464              		.loc 1 851 0
 2465 1470 75A0C4E5 		strb	sl, [r4, #117]
 2466 1474 F0FFFFEA 		b	.L175
 2467              	.LVL192:
 2468              	.L168:
 831:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2469              		.loc 1 831 0
 2470 1478 084A9FE5 		ldr	r4, .L321+76
 2471 147c B9E0D4E5 		ldrb	lr, [r4, #185]	@ zero_extendqisi2
 2472 1480 00005EE3 		cmp	lr, #0
 2473 1484 2704000A 		beq	.L176
 832:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2474              		.loc 1 832 0
 2475 1488 B1A4D6E5 		ldrb	sl, [r6, #1201]	@ zero_extendqisi2
 833:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2476              		.loc 1 833 0
 2477 148c B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 832:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2478              		.loc 1 832 0
 2479 1490 FF700AE2 		and	r7, sl, #255
 2480              	.LVL193:
 833:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2481              		.loc 1 833 0
 2482 1494 FFA002E2 		and	sl, r2, #255
 832:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2483              		.loc 1 832 0
 2484 1498 7470C4E5 		strb	r7, [r4, #116]
 833:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2485              		.loc 1 833 0
 2486 149c 75A0C4E5 		strb	sl, [r4, #117]
 2487 14a0 E5FFFFEA 		b	.L175
 2488              	.LVL194:
 2489              	.L165:
 914:../uvc.c      **** 					 if(CamMode == 1){//720p
 2490              		.loc 1 914 0
 2491 14a4 DC499FE5 		ldr	r4, .L321+76
 912:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2492              		.loc 1 912 0
 2493 14a8 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2494              	.LVL195:
 914:../uvc.c      **** 					 if(CamMode == 1){//720p
 2495              		.loc 1 914 0
 2496 14ac D420D4E5 		ldrb	r2, [r4, #212]	@ zero_extendqisi2
 2497 14b0 010052E3 		cmp	r2, #1
 2498 14b4 9004000A 		beq	.L314
 2499              	.LVL196:
 2500              	.L306:
1014:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2501              		.loc 1 1014 0
 2502 14b8 0030A0E3 		mov	r3, #0
1013:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2503              		.loc 1 1013 0
 2504 14bc 7470C4E5 		strb	r7, [r4, #116]
1014:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2505              		.loc 1 1014 0
 2506 14c0 7530C4E5 		strb	r3, [r4, #117]
 2507              	.LVL197:
 789:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2508              		.loc 1 789 0
 2509 14c4 FFA0A0E3 		mov	sl, #255
1016:../uvc.c      **** 					 break;
 2510              		.loc 1 1016 0
 2511 14c8 DBFFFFEA 		b	.L175
 2512              	.LVL198:
 2513              	.L157:
1104:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2514              		.loc 1 1104 0
 2515 14cc B4499FE5 		ldr	r4, .L321+76
 2516 14d0 98E0D4E5 		ldrb	lr, [r4, #152]	@ zero_extendqisi2
 2517 14d4 00005EE3 		cmp	lr, #0
 2518 14d8 4304000A 		beq	.L210
1106:../uvc.c      **** 		 	 			 if(is60Hz)
 2519              		.loc 1 1106 0
 2520 14dc 6CC094E5 		ldr	ip, [r4, #108]
1112:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2521              		.loc 1 1112 0
 2522 14e0 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1106:../uvc.c      **** 		 	 			 if(is60Hz)
 2523              		.loc 1 1106 0
 2524 14e4 00005CE3 		cmp	ip, #0
1107:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2525              		.loc 1 1107 0
 2526 14e8 02C0A013 		movne	ip, #2
1109:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
 2527              		.loc 1 1109 0
 2528 14ec 01C0A003 		moveq	ip, #1
 2529 14f0 74C0C4E5 		strb	ip, [r4, #116]
1112:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2530              		.loc 1 1112 0
 2531 14f4 75A0C4E5 		strb	sl, [r4, #117]
 2532 14f8 7470D4E5 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 2533              	.LVL199:
 2534 14fc CEFFFFEA 		b	.L175
 2535              	.LVL200:
 2536              	.L161:
1022:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2537              		.loc 1 1022 0
 2538 1500 80499FE5 		ldr	r4, .L321+76
 2539 1504 9F20D4E5 		ldrb	r2, [r4, #159]	@ zero_extendqisi2
 2540 1508 000052E3 		cmp	r2, #0
 2541 150c B603000A 		beq	.L200
1023:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2542              		.loc 1 1023 0
 2543 1510 F474D6E5 		ldrb	r7, [r6, #1268]	@ zero_extendqisi2
 2544              	.LVL201:
1024:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2545              		.loc 1 1024 0
 2546 1514 F6A4D6E5 		ldrb	sl, [r6, #1270]	@ zero_extendqisi2
1023:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2547              		.loc 1 1023 0
 2548 1518 7470C4E5 		strb	r7, [r4, #116]
1024:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2549              		.loc 1 1024 0
 2550 151c 76A0C4E5 		strb	sl, [r4, #118]
 2551              	.LVL202:
 2552              	.L201:
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2553              		.loc 1 1034 0
 2554 1520 00E0A0E3 		mov	lr, #0
 2555 1524 75E0C4E5 		strb	lr, [r4, #117]
1035:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2556              		.loc 1 1035 0
 2557 1528 77E0C4E5 		strb	lr, [r4, #119]
 2558              	.LVL203:
1038:../uvc.c      **** 					 break;
 2559              		.loc 1 1038 0
 2560 152c C2FFFFEA 		b	.L175
 2561              	.LVL204:
 2562              	.L153:
1129:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2563              		.loc 1 1129 0
 2564 1530 50B99FE5 		ldr	fp, .L321+76
 2565 1534 04308BE0 		add	r3, fp, r4
 2566 1538 9420D3E5 		ldrb	r2, [r3, #148]	@ zero_extendqisi2
 2567 153c 000052E3 		cmp	r2, #0
 2568 1540 0F04000A 		beq	.L214
1130:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2569              		.loc 1 1130 0
 2570 1544 844084E0 		add	r4, r4, r4, asl #1
 2571 1548 846186E0 		add	r6, r6, r4, asl #3
 2572 154c 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2573              	.LVL205:
1131:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2574              		.loc 1 1131 0
 2575 1550 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1130:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2576              		.loc 1 1130 0
 2577 1554 7470CBE5 		strb	r7, [fp, #116]
1131:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2578              		.loc 1 1131 0
 2579 1558 75A0CBE5 		strb	sl, [fp, #117]
 2580 155c B6FFFFEA 		b	.L175
 2581              	.LVL206:
 2582              	.L163:
 949:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2583              		.loc 1 949 0
 2584 1560 20499FE5 		ldr	r4, .L321+76
 943:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2585              		.loc 1 943 0
 2586 1564 E004D6E5 		ldrb	r0, [r6, #1248]	@ zero_extendqisi2
 2587              	.LVL207:
 949:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2588              		.loc 1 949 0
 2589 1568 ADA0D4E5 		ldrb	sl, [r4, #173]	@ zero_extendqisi2
 944:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2590              		.loc 1 944 0
 2591 156c E174D6E5 		ldrb	r7, [r6, #1249]	@ zero_extendqisi2
 2592              	.LVL208:
 945:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2593              		.loc 1 945 0
 2594 1570 EF24D6E5 		ldrb	r2, [r6, #1263]	@ zero_extendqisi2
 949:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2595              		.loc 1 949 0
 2596 1574 00005AE3 		cmp	sl, #0
 943:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2597              		.loc 1 943 0
 2598 1578 04699FE5 		ldr	r6, .L321+72
 944:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2599              		.loc 1 944 0
 2600 157c FFA007E2 		and	sl, r7, #255
 943:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2601              		.loc 1 943 0
 2602 1580 FF0000E2 		and	r0, r0, #255
 2603              	.LVL209:
 945:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2604              		.loc 1 945 0
 2605 1584 FF7002E2 		and	r7, r2, #255
 2606              	.LVL210:
 949:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2607              		.loc 1 949 0
 2608 1588 CF03000A 		beq	.L192
 950:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2609              		.loc 1 950 0
 2610 158c EDC4D6E5 		ldrb	ip, [r6, #1261]	@ zero_extendqisi2
 951:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2611              		.loc 1 951 0
 2612 1590 EEE4D6E5 		ldrb	lr, [r6, #1262]	@ zero_extendqisi2
 950:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2613              		.loc 1 950 0
 2614 1594 74C0C4E5 		strb	ip, [r4, #116]
 951:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2615              		.loc 1 951 0
 2616 1598 76E0C4E5 		strb	lr, [r4, #118]
 2617              	.LVL211:
 2618              	.L193:
 968:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2619              		.loc 1 968 0
 2620 159c 7470D4E5 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 2621              	.LVL212:
 969:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2622              		.loc 1 969 0
 2623 15a0 76A0D4E5 		ldrb	sl, [r4, #118]	@ zero_extendqisi2
 2624              	.LVL213:
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2625              		.loc 1 965 0
 2626 15a4 00E0A0E3 		mov	lr, #0
 2627 15a8 75E0C4E5 		strb	lr, [r4, #117]
 967:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2628              		.loc 1 967 0
 2629 15ac 77E0C4E5 		strb	lr, [r4, #119]
 970:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2630              		.loc 1 970 0
 2631 15b0 9C189FE5 		ldr	r1, .L321+24
 2632 15b4 0720A0E1 		mov	r2, r7
 2633 15b8 0E30A0E1 		mov	r3, lr
 2634 15bc 0400A0E3 		mov	r0, #4
 2635 15c0 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2636 15c4 FEFFFFEB 		bl	CyU3PDebugPrint
 971:../uvc.c      **** 					 break;
 2637              		.loc 1 971 0
 2638 15c8 9BFFFFEA 		b	.L175
 2639              	.LVL214:
 2640              	.L155:
 987:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2641              		.loc 1 987 0
 2642 15cc B4489FE5 		ldr	r4, .L321+76
 2643 15d0 9510D4E5 		ldrb	r1, [r4, #149]	@ zero_extendqisi2
 2644 15d4 000051E3 		cmp	r1, #0
 988:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2645              		.loc 1 988 0
 2646 15d8 A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2647              	.LVL215:
 987:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2648              		.loc 1 987 0
 2649 15dc 1B04000A 		beq	.L315
 2650              	.LVL216:
 2651              	.L195:
 995:../uvc.c      **** 					  if(Data0&0x80){
 2652              		.loc 1 995 0
 2653 15e0 800010E3 		tst	r0, #128
 996:../uvc.c      **** 						  Data0 = ~Data0;
 2654              		.loc 1 996 0
 2655 15e4 0000E011 		mvnne	r0, r0
 2656              	.LVL217:
 998:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2657              		.loc 1 998 0
 2658 15e8 80004002 		subeq	r0, r0, #128
 2659 15ec FF7000E2 		and	r7, r0, #255
 2660              	.LVL218:
 2661 15f0 B0FFFFEA 		b	.L306
 2662              	.LVL219:
 2663              	.L159:
1057:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2664              		.loc 1 1057 0
 2665 15f4 8C489FE5 		ldr	r4, .L321+76
 2666 15f8 9B20D4E5 		ldrb	r2, [r4, #155]	@ zero_extendqisi2
 2667 15fc 000052E3 		cmp	r2, #0
 2668 1600 A503000A 		beq	.L204
1058:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2669              		.loc 1 1058 0
 2670 1604 19E5D6E5 		ldrb	lr, [r6, #1305]	@ zero_extendqisi2
1059:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2671              		.loc 1 1059 0
 2672 1608 1A15D6E5 		ldrb	r1, [r6, #1306]	@ zero_extendqisi2
1058:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2673              		.loc 1 1058 0
 2674 160c FF700EE2 		and	r7, lr, #255
 2675              	.LVL220:
1059:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2676              		.loc 1 1059 0
 2677 1610 FFA001E2 		and	sl, r1, #255
1058:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2678              		.loc 1 1058 0
 2679 1614 7470C4E5 		strb	r7, [r4, #116]
1059:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2680              		.loc 1 1059 0
 2681 1618 75A0C4E5 		strb	sl, [r4, #117]
 2682 161c 86FFFFEA 		b	.L175
 2683              	.LVL221:
 2684              	.L156:
1074:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2685              		.loc 1 1074 0
 2686 1620 60B89FE5 		ldr	fp, .L321+76
 2687 1624 04408BE0 		add	r4, fp, r4
 2688 1628 9470D4E5 		ldrb	r7, [r4, #148]	@ zero_extendqisi2
 2689              	.LVL222:
 2690 162c 000057E3 		cmp	r7, #0
 2691 1630 C803000A 		beq	.L206
1075:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2692              		.loc 1 1075 0
 2693 1634 BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2694              		.loc 1 1076 0
 2695 1638 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1075:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2696              		.loc 1 1075 0
 2697 163c 7470CBE5 		strb	r7, [fp, #116]
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2698              		.loc 1 1076 0
 2699 1640 75A0CBE5 		strb	sl, [fp, #117]
 2700 1644 7CFFFFEA 		b	.L175
 2701              	.LVL223:
 2702              	.L164:
 899:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2703              		.loc 1 899 0
 2704 1648 38489FE5 		ldr	r4, .L321+76
 892:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2705              		.loc 1 892 0
 2706 164c CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
 899:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2707              		.loc 1 899 0
 2708 1650 AF20D4E5 		ldrb	r2, [r4, #175]	@ zero_extendqisi2
 893:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2709              		.loc 1 893 0
 2710 1654 CDE4D6E5 		ldrb	lr, [r6, #1229]	@ zero_extendqisi2
 894:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2711              		.loc 1 894 0
 2712 1658 DB14D6E5 		ldrb	r1, [r6, #1243]	@ zero_extendqisi2
 899:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2713              		.loc 1 899 0
 2714 165c 000052E3 		cmp	r2, #0
 892:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2715              		.loc 1 892 0
 2716 1660 1C689FE5 		ldr	r6, .L321+72
 893:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2717              		.loc 1 893 0
 2718 1664 FF000EE2 		and	r0, lr, #255
 2719              	.LVL224:
 894:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2720              		.loc 1 894 0
 2721 1668 FF1001E2 		and	r1, r1, #255
 2722              	.LVL225:
 899:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2723              		.loc 1 899 0
 2724 166c A303000A 		beq	.L184
 900:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2725              		.loc 1 900 0
 2726 1670 D9A4D6E5 		ldrb	sl, [r6, #1241]	@ zero_extendqisi2
 901:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2727              		.loc 1 901 0
 2728 1674 DA34D6E5 		ldrb	r3, [r6, #1242]	@ zero_extendqisi2
 900:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2729              		.loc 1 900 0
 2730 1678 FF700AE2 		and	r7, sl, #255
 2731              	.LVL226:
 901:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2732              		.loc 1 901 0
 2733 167c FFA003E2 		and	sl, r3, #255
 900:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2734              		.loc 1 900 0
 2735 1680 7470C4E5 		strb	r7, [r4, #116]
 901:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2736              		.loc 1 901 0
 2737 1684 75A0C4E5 		strb	sl, [r4, #117]
 2738 1688 6BFFFFEA 		b	.L175
 2739              	.LVL227:
 2740              	.L154:
1040:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2741              		.loc 1 1040 0
 2742 168c F4479FE5 		ldr	r4, .L321+76
 2743 1690 9470D4E5 		ldrb	r7, [r4, #148]	@ zero_extendqisi2
 2744              	.LVL228:
 2745 1694 000057E3 		cmp	r7, #0
 2746 1698 E003000A 		beq	.L202
1041:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2747              		.loc 1 1041 0
 2748 169c 05A5D6E5 		ldrb	sl, [r6, #1285]	@ zero_extendqisi2
1042:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2749              		.loc 1 1042 0
 2750 16a0 06C5D6E5 		ldrb	ip, [r6, #1286]	@ zero_extendqisi2
1041:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2751              		.loc 1 1041 0
 2752 16a4 FF700AE2 		and	r7, sl, #255
1042:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2753              		.loc 1 1042 0
 2754 16a8 FFA00CE2 		and	sl, ip, #255
1041:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2755              		.loc 1 1041 0
 2756 16ac 7470C4E5 		strb	r7, [r4, #116]
1042:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2757              		.loc 1 1042 0
 2758 16b0 75A0C4E5 		strb	sl, [r4, #117]
 2759 16b4 60FFFFEA 		b	.L175
 2760              	.LVL229:
 2761              	.L160:
1087:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2762              		.loc 1 1087 0
 2763 16b8 C8479FE5 		ldr	r4, .L321+76
 2764 16bc 9D30D4E5 		ldrb	r3, [r4, #157]	@ zero_extendqisi2
 2765 16c0 000053E3 		cmp	r3, #0
 2766 16c4 BD03000A 		beq	.L208
1089:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2767              		.loc 1 1089 0
 2768 16c8 6522D6E5 		ldrb	r2, [r6, #613]	@ zero_extendqisi2
1090:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2769              		.loc 1 1090 0
 2770 16cc 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1089:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2771              		.loc 1 1089 0
 2772 16d0 037002E2 		and	r7, r2, #3
 2773              	.LVL230:
 2774 16d4 7470C4E5 		strb	r7, [r4, #116]
1090:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2775              		.loc 1 1090 0
 2776 16d8 75A0C4E5 		strb	sl, [r4, #117]
 2777 16dc 56FFFFEA 		b	.L175
 2778              	.LVL231:
 2779              	.L162:
 874:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2780              		.loc 1 874 0
 2781 16e0 A0479FE5 		ldr	r4, .L321+76
 867:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2782              		.loc 1 867 0
 2783 16e4 B8E4D6E5 		ldrb	lr, [r6, #1208]	@ zero_extendqisi2
 874:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2784              		.loc 1 874 0
 2785 16e8 A420D4E5 		ldrb	r2, [r4, #164]	@ zero_extendqisi2
 868:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2786              		.loc 1 868 0
 2787 16ec B934D6E5 		ldrb	r3, [r6, #1209]	@ zero_extendqisi2
 869:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2788              		.loc 1 869 0
 2789 16f0 C774D6E5 		ldrb	r7, [r6, #1223]	@ zero_extendqisi2
 2790              	.LVL232:
 874:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2791              		.loc 1 874 0
 2792 16f4 000052E3 		cmp	r2, #0
 867:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2793              		.loc 1 867 0
 2794 16f8 84679FE5 		ldr	r6, .L321+72
 2795 16fc FF000EE2 		and	r0, lr, #255
 2796              	.LVL233:
 869:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2797              		.loc 1 869 0
 2798 1700 FF1007E2 		and	r1, r7, #255
 2799              	.LVL234:
 874:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2800              		.loc 1 874 0
 2801 1704 D803000A 		beq	.L182
 875:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2802              		.loc 1 875 0
 2803 1708 C5A4D6E5 		ldrb	sl, [r6, #1221]	@ zero_extendqisi2
 876:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2804              		.loc 1 876 0
 2805 170c C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 875:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2806              		.loc 1 875 0
 2807 1710 FF700AE2 		and	r7, sl, #255
 2808 1714 7470C4E5 		strb	r7, [r4, #116]
 876:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2809              		.loc 1 876 0
 2810 1718 7530C4E5 		strb	r3, [r4, #117]
 2811              	.LVL235:
 2812              	.L183:
 889:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2813              		.loc 1 889 0
 2814 171c 34179FE5 		ldr	r1, .L321+28
 2815 1720 0720A0E1 		mov	r2, r7
 2816 1724 0730A0E1 		mov	r3, r7
 2817 1728 0400A0E3 		mov	r0, #4
 2818 172c 00C08DE5 		str	ip, [sp, #0]
 888:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 2819              		.loc 1 888 0
 2820 1730 0CA0A0E1 		mov	sl, ip
 889:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2821              		.loc 1 889 0
 2822 1734 FEFFFFEB 		bl	CyU3PDebugPrint
 2823              	.LVL236:
 890:../uvc.c      **** 			 		 break;
 2824              		.loc 1 890 0
 2825 1738 3FFFFFEA 		b	.L175
 2826              	.LVL237:
 2827              	.L158:
1005:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2828              		.loc 1 1005 0
 2829 173c 44479FE5 		ldr	r4, .L321+76
 2830 1740 99C0D4E5 		ldrb	ip, [r4, #153]	@ zero_extendqisi2
 2831 1744 00005CE3 		cmp	ip, #0
1006:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2832              		.loc 1 1006 0
 2833 1748 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2834              	.LVL238:
1005:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2835              		.loc 1 1005 0
 2836 174c B002000A 		beq	.L316
 2837              	.L199:
 2838              	.LVL239:
1013:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2839              		.loc 1 1013 0
 2840 1750 800040E2 		sub	r0, r0, #128
 2841              	.LVL240:
 2842 1754 FF7000E2 		and	r7, r0, #255
 2843              	.LVL241:
 2844 1758 56FFFFEA 		b	.L306
 2845              	.LVL242:
 2846              	.L244:
1396:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2847              		.loc 1 1396 0 discriminator 1
 2848 175c 000058E3 		cmp	r8, #0
 2849 1760 1800000A 		beq	.L250
1394:../uvc.c      **** 							 break;
 2850              		.loc 1 1394 0
 2851 1764 28E1A0E1 		mov	lr, r8, lsr #2
 2852 1768 00005EE3 		cmp	lr, #0
 2853 176c 03005813 		cmpne	r8, #3
 2854 1770 0020A083 		movhi	r2, #0
 2855 1774 0120A093 		movls	r2, #1
 2856              	.LVL243:
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2857              		.loc 1 771 0
 2858 1778 0E31A0E1 		mov	r3, lr, asl #2
1394:../uvc.c      **** 							 break;
 2859              		.loc 1 1394 0
 2860 177c FA03009A 		bls	.L287
 2861 1780 D4169FE5 		ldr	r1, .L321+32
 2862 1784 140081E2 		add	r0, r1, #20
 2863              	.LVL244:
 2864              	.L260:
1397:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2865              		.loc 1 1397 0 discriminator 2
 2866 1788 047090E4 		ldr	r7, [r0], #4
 2867 178c 012082E2 		add	r2, r2, #1
 2868 1790 FF2002E2 		and	r2, r2, #255
 2869 1794 02005EE1 		cmp	lr, r2
 2870 1798 047081E4 		str	r7, [r1], #4
 2871 179c F9FFFF8A 		bhi	.L260
1397:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2872              		.loc 1 1397 0 is_stmt 0
 2873 17a0 030058E1 		cmp	r8, r3
 2874 17a4 0700000A 		beq	.L250
 2875              	.L299:
 2876 17a8 D8069FE5 		ldr	r0, .L321+76
 2877 17ac 03E080E0 		add	lr, r0, r3
 2878 17b0 7410DEE5 		ldrb	r1, [lr, #116]	@ zero_extendqisi2
1396:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2879              		.loc 1 1396 0 is_stmt 1
 2880 17b4 013083E2 		add	r3, r3, #1
 2881 17b8 FF3003E2 		and	r3, r3, #255
 2882              	.LVL245:
 2883 17bc 030058E1 		cmp	r8, r3
1397:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2884              		.loc 1 1397 0
 2885 17c0 6010CEE5 		strb	r1, [lr, #96]
1396:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2886              		.loc 1 1396 0
 2887 17c4 F7FFFF8A 		bhi	.L299
 2888              	.LVL246:
 2889              	.L250:
1400:../uvc.c      **** 							 break;
 2890              		.loc 1 1400 0
 2891 17c8 FFA0A0E3 		mov	sl, #255
1399:../uvc.c      **** 					 		I2CCmdHandler();
 2892              		.loc 1 1399 0
 2893 17cc FEFFFFEB 		bl	I2CCmdHandler
 2894              	.LVL247:
1400:../uvc.c      **** 							 break;
 2895              		.loc 1 1400 0
 2896 17d0 0A70A0E1 		mov	r7, sl
1399:../uvc.c      **** 					 		I2CCmdHandler();
 2897              		.loc 1 1399 0
 2898 17d4 18809DE5 		ldr	r8, [sp, #24]
 2899 17d8 1C409DE5 		ldr	r4, [sp, #28]
1400:../uvc.c      **** 							 break;
 2900              		.loc 1 1400 0
 2901 17dc ECFDFFEA 		b	.L152
 2902              	.LVL248:
 2903              	.L243:
1390:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2904              		.loc 1 1390 0
 2905 17e0 94769FE5 		ldr	r7, .L321+64
 2906              	.LVL249:
 2907 17e4 0010E0E3 		mvn	r1, #0
 2908 17e8 1C0097E5 		ldr	r0, [r7, #28]
 2909 17ec FEFFFFEB 		bl	_txe_mutex_get
 2910              	.LVL250:
1391:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2911              		.loc 1 1391 0
 2912 17f0 0A20A0E1 		mov	r2, sl
 2913 17f4 18A09DE5 		ldr	sl, [sp, #24]
 2914 17f8 00C0A0E3 		mov	ip, #0
 2915 17fc 01407AE2 		rsbs	r4, sl, #1
 2916 1800 0040A033 		movcc	r4, #0
 2917 1804 1E10A0E3 		mov	r1, #30
 2918 1808 0930A0E1 		mov	r3, r9
 2919 180c 0700A0E1 		mov	r0, r7
 2920 1810 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 2921 1814 FEFFFFEB 		bl	cmdSet
1392:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2922              		.loc 1 1392 0
 2923 1818 1C0097E5 		ldr	r0, [r7, #28]
 2924 181c FEFFFFEB 		bl	_txe_mutex_put
1394:../uvc.c      **** 							 break;
 2925              		.loc 1 1394 0
 2926 1820 FFA0A0E3 		mov	sl, #255
1393:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2927              		.loc 1 1393 0
 2928 1824 0100A0E3 		mov	r0, #1
 2929 1828 6004C6E5 		strb	r0, [r6, #1120]
 2930 182c 18809DE5 		ldr	r8, [sp, #24]
 2931 1830 1C409DE5 		ldr	r4, [sp, #28]
1394:../uvc.c      **** 							 break;
 2932              		.loc 1 1394 0
 2933 1834 0A70A0E1 		mov	r7, sl
 2934 1838 D5FDFFEA 		b	.L152
 2935              	.LVL251:
 2936              	.L242:
1368:../uvc.c      **** 							 if(Data0 <= 3){
 2937              		.loc 1 1368 0
 2938 183c 030053E3 		cmp	r3, #3
1369:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2939              		.loc 1 1369 0
 2940 1840 40069F95 		ldrls	r0, .L321+76
 2941 1844 03E0A0E1 		mov	lr, r3
 2942              	.LVL252:
 2943 1848 0030A093 		movls	r3, #0
 2944 184c D430C095 		strlsb	r3, [r0, #212]
 2945              	.LVL253:
1372:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2946              		.loc 1 1372 0
 2947 1850 30C69F85 		ldrhi	ip, .L321+76
1369:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2948              		.loc 1 1369 0
 2949 1854 0E30A091 		movls	r3, lr
1378:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2950              		.loc 1 1378 0
 2951 1858 1C469FE5 		ldr	r4, .L321+64
 2952 185c 18E09D95 		ldrls	lr, [sp, #24]
1373:../uvc.c      **** 								 Data1 = Data0-4;
 2953              		.loc 1 1373 0
 2954 1860 04304382 		subhi	r3, r3, #4
1372:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2955              		.loc 1 1372 0
 2956 1864 0120A083 		movhi	r2, #1
 2957              	.LVL254:
1376:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2958              		.loc 1 1376 0
 2959 1868 8D31C6E5 		strb	r3, [r6, #397]
1377:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2960              		.loc 1 1377 0
 2961 186c 0130A0E3 		mov	r3, #1
1372:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2962              		.loc 1 1372 0
 2963 1870 D420CC85 		strhib	r2, [ip, #212]
 2964              	.LVL255:
1378:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2965              		.loc 1 1378 0
 2966 1874 0010E0E3 		mvn	r1, #0
1375:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2967              		.loc 1 1375 0
 2968 1878 2DE4C6E5 		strb	lr, [r6, #1069]
1377:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2969              		.loc 1 1377 0
 2970 187c 3034C6E5 		strb	r3, [r6, #1072]
1378:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2971              		.loc 1 1378 0
 2972 1880 1C0094E5 		ldr	r0, [r4, #28]
 2973 1884 FEFFFFEB 		bl	_txe_mutex_get
1379:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2974              		.loc 1 1379 0
 2975 1888 18809DE5 		ldr	r8, [sp, #24]
 2976 188c 0A20A0E1 		mov	r2, sl
 2977 1890 1C10A0E3 		mov	r1, #28
 2978 1894 0930A0E1 		mov	r3, r9
 2979 1898 0400A0E1 		mov	r0, r4
 2980 189c 00A0A0E3 		mov	sl, #0
 2981 18a0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 2982 18a4 FEFFFFEB 		bl	cmdSet
1380:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2983              		.loc 1 1380 0
 2984 18a8 1C0094E5 		ldr	r0, [r4, #28]
 2985              	.LVL256:
 2986              	.L308:
1646:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2987              		.loc 1 1646 0
 2988 18ac FFA0A0E3 		mov	sl, #255
 2989 18b0 FEFFFFEB 		bl	_txe_mutex_put
 2990 18b4 0A70A0E1 		mov	r7, sl
 2991 18b8 18809DE5 		ldr	r8, [sp, #24]
 2992 18bc 1C409DE5 		ldr	r4, [sp, #28]
 2993 18c0 B3FDFFEA 		b	.L152
 2994              	.LVL257:
 2995              	.L241:
1345:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2996              		.loc 1 1345 0
 2997 18c4 B0459FE5 		ldr	r4, .L321+64
1341:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2998              		.loc 1 1341 0
 2999 18c8 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
1342:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3000              		.loc 1 1342 0
 3001 18cc CD74D6E5 		ldrb	r7, [r6, #1229]	@ zero_extendqisi2
 3002              	.LVL258:
1343:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3003              		.loc 1 1343 0
 3004 18d0 DBE4D6E5 		ldrb	lr, [r6, #1243]	@ zero_extendqisi2
1345:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3005              		.loc 1 1345 0
 3006 18d4 0010E0E3 		mvn	r1, #0
 3007 18d8 1C0094E5 		ldr	r0, [r4, #28]
1341:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3008              		.loc 1 1341 0
 3009 18dc FFA003E2 		and	sl, r3, #255
 3010              	.LVL259:
1342:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3011              		.loc 1 1342 0
 3012 18e0 FF8007E2 		and	r8, r7, #255
 3013              	.LVL260:
1343:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3014              		.loc 1 1343 0
 3015 18e4 FF700EE2 		and	r7, lr, #255
 3016              	.LVL261:
1345:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3017              		.loc 1 1345 0
 3018 18e8 FEFFFFEB 		bl	_txe_mutex_get
 3019              	.LVL262:
1353:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3020              		.loc 1 1353 0
 3021 18ec D904D6E5 		ldrb	r0, [r6, #1241]	@ zero_extendqisi2
 3022 18f0 18109DE5 		ldr	r1, [sp, #24]
1341:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3023              		.loc 1 1341 0
 3024 18f4 88359FE5 		ldr	r3, .L321+72
1353:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3025              		.loc 1 1353 0
 3026 18f8 000051E1 		cmp	r1, r0
 3027 18fc 0600000A 		beq	.L255
1354:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3028              		.loc 1 1354 0
 3029 1900 D914C3E5 		strb	r1, [r3, #1241]
1355:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3030              		.loc 1 1355 0
 3031 1904 ED24D3E5 		ldrb	r2, [r3, #1261]	@ zero_extendqisi2
 3032 1908 010052E3 		cmp	r2, #1
 3033 190c 6803000A 		beq	.L256
1355:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3034              		.loc 1 1355 0 is_stmt 0 discriminator 1
 3035 1910 ED14D3E5 		ldrb	r1, [r3, #1261]	@ zero_extendqisi2
 3036 1914 030051E3 		cmp	r1, #3
 3037 1918 6503000A 		beq	.L256
 3038              	.LVL263:
 3039              	.L255:
1362:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3040              		.loc 1 1362 0 is_stmt 1
 3041 191c 1C0094E5 		ldr	r0, [r4, #28]
 3042 1920 FEFFFFEB 		bl	_txe_mutex_put
1364:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3043              		.loc 1 1364 0
 3044 1924 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3045              		.loc 1 1363 0
 3046 1928 18809DE5 		ldr	r8, [sp, #24]
1364:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3047              		.loc 1 1364 0
 3048 192c EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3049              		.loc 1 1363 0
 3050 1930 1C409DE5 		ldr	r4, [sp, #28]
1364:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3051              		.loc 1 1364 0
 3052 1934 D974D6E5 		ldrb	r7, [r6, #1241]	@ zero_extendqisi2
 3053              	.LVL264:
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3054              		.loc 1 1363 0
 3055 1938 0400A0E3 		mov	r0, #4
 3056 193c 1C159FE5 		ldr	r1, .L321+36
1365:../uvc.c      **** 							 break;
 3057              		.loc 1 1365 0
 3058 1940 FFA0A0E3 		mov	sl, #255
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3059              		.loc 1 1363 0
 3060 1944 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3061 1948 08408DE5 		str	r4, [sp, #8]
1365:../uvc.c      **** 							 break;
 3062              		.loc 1 1365 0
 3063 194c 0A70A0E1 		mov	r7, sl
1363:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3064              		.loc 1 1363 0
 3065 1950 FEFFFFEB 		bl	CyU3PDebugPrint
1365:../uvc.c      **** 							 break;
 3066              		.loc 1 1365 0
 3067 1954 8EFDFFEA 		b	.L152
 3068              	.LVL265:
 3069              	.L246:
1442:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3070              		.loc 1 1442 0
 3071 1958 A4C4D6E5 		ldrb	ip, [r6, #1188]	@ zero_extendqisi2
 3072              	.LVL266:
1447:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3073              		.loc 1 1447 0
 3074 195c 18A59FE5 		ldr	sl, .L321+64
1443:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3075              		.loc 1 1443 0
 3076 1960 A534D6E5 		ldrb	r3, [r6, #1189]	@ zero_extendqisi2
1444:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3077              		.loc 1 1444 0
 3078 1964 B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1442:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3079              		.loc 1 1442 0
 3080 1968 FF800CE2 		and	r8, ip, #255
 3081              	.LVL267:
1447:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3082              		.loc 1 1447 0
 3083 196c 0010E0E3 		mvn	r1, #0
 3084 1970 1C009AE5 		ldr	r0, [sl, #28]
1444:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3085              		.loc 1 1444 0
 3086 1974 FF400EE2 		and	r4, lr, #255
 3087              	.LVL268:
1447:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3088              		.loc 1 1447 0
 3089 1978 FEFFFFEB 		bl	_txe_mutex_get
 3090              	.LVL269:
1448:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3091              		.loc 1 1448 0
 3092 197c 0820A0E1 		mov	r2, r8
 3093 1980 18809DE5 		ldr	r8, [sp, #24]
 3094              	.LVL270:
 3095 1984 0430A0E1 		mov	r3, r4
 3096 1988 2510A0E3 		mov	r1, #37
 3097 198c 0A00A0E1 		mov	r0, sl
 3098 1990 0070A0E3 		mov	r7, #0
 3099              	.LVL271:
 3100 1994 00808DE5 		str	r8, [sp, #0]
 3101 1998 04708DE5 		str	r7, [sp, #4]
 3102 199c FEFFFFEB 		bl	cmdSet
 3103              	.LVL272:
1449:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3104              		.loc 1 1449 0
 3105 19a0 1C009AE5 		ldr	r0, [sl, #28]
 3106 19a4 FEFFFFEB 		bl	_txe_mutex_put
1450:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3107              		.loc 1 1450 0
 3108 19a8 18409DE5 		ldr	r4, [sp, #24]
 3109              	.LVL273:
1454:../uvc.c      **** 							 break;
 3110              		.loc 1 1454 0
 3111 19ac FFA0A0E3 		mov	sl, #255
1451:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3112              		.loc 1 1451 0
 3113 19b0 0100A0E3 		mov	r0, #1
1450:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3114              		.loc 1 1450 0
 3115 19b4 B144C6E5 		strb	r4, [r6, #1201]
1451:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3116              		.loc 1 1451 0
 3117 19b8 0480A0E1 		mov	r8, r4
 3118 19bc B504C6E5 		strb	r0, [r6, #1205]
 3119 19c0 1C409DE5 		ldr	r4, [sp, #28]
1454:../uvc.c      **** 							 break;
 3120              		.loc 1 1454 0
 3121 19c4 0A70A0E1 		mov	r7, sl
 3122 19c8 71FDFFEA 		b	.L152
 3123              	.LVL274:
 3124              	.L245:
1402:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3125              		.loc 1 1402 0
 3126 19cc 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
1429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3127              		.loc 1 1429 0
 3128 19d0 A4449FE5 		ldr	r4, .L321+64
1403:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3129              		.loc 1 1403 0
 3130 19d4 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 3131              	.LVL275:
1404:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3132              		.loc 1 1404 0
 3133 19d8 9F14D6E5 		ldrb	r1, [r6, #1183]	@ zero_extendqisi2
1429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3134              		.loc 1 1429 0
 3135 19dc 1C0094E5 		ldr	r0, [r4, #28]
1404:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3136              		.loc 1 1404 0
 3137 19e0 FF7001E2 		and	r7, r1, #255
 3138              	.LVL276:
1429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3139              		.loc 1 1429 0
 3140 19e4 0010E0E3 		mvn	r1, #0
1402:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3141              		.loc 1 1402 0
 3142 19e8 FF9003E2 		and	r9, r3, #255
 3143              	.LVL277:
1403:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3144              		.loc 1 1403 0
 3145 19ec FF8002E2 		and	r8, r2, #255
 3146              	.LVL278:
1429:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3147              		.loc 1 1429 0
 3148 19f0 14C08DE5 		str	ip, [sp, #20]
 3149 19f4 FEFFFFEB 		bl	_txe_mutex_get
 3150              	.LVL279:
1431:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3151              		.loc 1 1431 0
 3152 19f8 18C09DE5 		ldr	ip, [sp, #24]
 3153 19fc 00E0A0E3 		mov	lr, #0
 3154 1a00 0920A0E1 		mov	r2, r9
 3155 1a04 0730A0E1 		mov	r3, r7
 3156 1a08 2410A0E3 		mov	r1, #36
 3157 1a0c 0400A0E1 		mov	r0, r4
 3158 1a10 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3159 1a14 FEFFFFEB 		bl	cmdSet
 3160              	.LVL280:
1433:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 3161              		.loc 1 1433 0
 3162 1a18 14A09DE5 		ldr	sl, [sp, #20]
 3163 1a1c 0820A0E1 		mov	r2, r8
 3164 1a20 0730A0E1 		mov	r3, r7
 3165 1a24 0190A0E3 		mov	r9, #1
 3166              	.LVL281:
 3167 1a28 2410A0E3 		mov	r1, #36
 3168 1a2c 0400A0E1 		mov	r0, r4
 3169 1a30 00A08DE5 		str	sl, [sp, #0]
 3170 1a34 04908DE5 		str	r9, [sp, #4]
 3171 1a38 FEFFFFEB 		bl	cmdSet
1434:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3172              		.loc 1 1434 0
 3173 1a3c 1C0094E5 		ldr	r0, [r4, #28]
 3174 1a40 FEFFFFEB 		bl	_txe_mutex_put
 3175              	.LVL282:
1437:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3176              		.loc 1 1437 0
 3177 1a44 18809DE5 		ldr	r8, [sp, #24]
 3178              	.LVL283:
1440:../uvc.c      **** 							 break;
 3179              		.loc 1 1440 0
 3180 1a48 FFA0A0E3 		mov	sl, #255
1437:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3181              		.loc 1 1437 0
 3182 1a4c 9D84C6E5 		strb	r8, [r6, #1181]
1438:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3183              		.loc 1 1438 0
 3184 1a50 14C09DE5 		ldr	ip, [sp, #20]
1440:../uvc.c      **** 							 break;
 3185              		.loc 1 1440 0
 3186 1a54 0A70A0E1 		mov	r7, sl
 3187              	.LVL284:
1438:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3188              		.loc 1 1438 0
 3189 1a58 9EC4C6E5 		strb	ip, [r6, #1182]
1439:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3190              		.loc 1 1439 0
 3191 1a5c 0C40A0E1 		mov	r4, ip
 3192 1a60 A194C6E5 		strb	r9, [r6, #1185]
1440:../uvc.c      **** 							 break;
 3193              		.loc 1 1440 0
 3194 1a64 4AFDFFEA 		b	.L152
 3195              	.LVL285:
 3196              	.L247:
1457:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3197              		.loc 1 1457 0
 3198 1a68 8780A0E1 		mov	r8, r7, asl #1
 3199 1a6c 10B49FE5 		ldr	fp, .L321+72
 3200 1a70 07C088E0 		add	ip, r8, r7
 3201              	.LVL286:
 3202 1a74 8CE186E0 		add	lr, r6, ip, asl #3
1463:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3203              		.loc 1 1463 0
 3204 1a78 FC439FE5 		ldr	r4, .L321+64
1457:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3205              		.loc 1 1457 0
 3206 1a7c 0D30CEE5 		strb	r3, [lr, #13]
1459:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3207              		.loc 1 1459 0
 3208 1a80 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1458:../uvc.c      **** 							 if(Data0 == 1){
 3209              		.loc 1 1458 0
 3210 1a84 010053E3 		cmp	r3, #1
1463:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3211              		.loc 1 1463 0
 3212 1a88 0010E0E3 		mvn	r1, #0
 3213 1a8c 1C0094E5 		ldr	r0, [r4, #28]
1459:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3214              		.loc 1 1459 0
 3215 1a90 80B08B03 		orreq	fp, fp, #128
 3216              	.LVL287:
1461:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 3217              		.loc 1 1461 0
 3218 1a94 7FB00B12 		andne	fp, fp, #127
 3219              	.LVL288:
1463:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3220              		.loc 1 1463 0
 3221 1a98 FEFFFFEB 		bl	_txe_mutex_get
 3222              	.LVL289:
1464:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3223              		.loc 1 1464 0
 3224 1a9c 0A20A0E1 		mov	r2, sl
 3225 1aa0 2610A0E3 		mov	r1, #38
 3226 1aa4 0930A0E1 		mov	r3, r9
 3227 1aa8 0400A0E1 		mov	r0, r4
 3228 1aac 00A0A0E3 		mov	sl, #0
 3229 1ab0 04A08DE5 		str	sl, [sp, #4]
 3230 1ab4 00B08DE5 		str	fp, [sp, #0]
 3231 1ab8 FEFFFFEB 		bl	cmdSet
1465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3232              		.loc 1 1465 0
 3233 1abc 1C0094E5 		ldr	r0, [r4, #28]
 3234 1ac0 FEFFFFEB 		bl	_txe_mutex_put
1467:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3235              		.loc 1 1467 0
 3236 1ac4 071088E0 		add	r1, r8, r7
 3237 1ac8 816186E0 		add	r6, r6, r1, asl #3
1468:../uvc.c      **** 							 break;
 3238              		.loc 1 1468 0
 3239 1acc FFA0A0E3 		mov	sl, #255
1467:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3240              		.loc 1 1467 0
 3241 1ad0 0120A0E3 		mov	r2, #1
 3242 1ad4 1020C6E5 		strb	r2, [r6, #16]
 3243 1ad8 18809DE5 		ldr	r8, [sp, #24]
 3244 1adc 1C409DE5 		ldr	r4, [sp, #28]
1468:../uvc.c      **** 							 break;
 3245              		.loc 1 1468 0
 3246 1ae0 0A70A0E1 		mov	r7, sl
 3247              	.LVL290:
 3248 1ae4 2AFDFFEA 		b	.L152
 3249              	.LVL291:
 3250              	.L236:
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3251              		.loc 1 1531 0
 3252 1ae8 8C439FE5 		ldr	r4, .L321+64
 3253 1aec 0010E0E3 		mvn	r1, #0
 3254 1af0 1C0094E5 		ldr	r0, [r4, #28]
 3255 1af4 FEFFFFEB 		bl	_txe_mutex_get
 3256              	.LVL292:
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3257              		.loc 1 1532 0
 3258 1af8 18C09DE5 		ldr	ip, [sp, #24]
 3259 1afc 00E0A0E3 		mov	lr, #0
 3260 1b00 0A20A0E1 		mov	r2, sl
 3261 1b04 0610A0E3 		mov	r1, #6
 3262 1b08 0930A0E1 		mov	r3, r9
 3263 1b0c 0400A0E1 		mov	r0, r4
 3264 1b10 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3265 1b14 FEFFFFEB 		bl	cmdSet
 3266              	.LVL293:
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3267              		.loc 1 1534 0
 3268 1b18 18A09DE5 		ldr	sl, [sp, #24]
 3269 1b1c 0170A0E3 		mov	r7, #1
 3270              	.LVL294:
 3271 1b20 0610A0E3 		mov	r1, #6
 3272 1b24 0B20A0E1 		mov	r2, fp
 3273 1b28 0930A0E1 		mov	r3, r9
 3274 1b2c 0400A0E1 		mov	r0, r4
 3275 1b30 00A08DE5 		str	sl, [sp, #0]
 3276 1b34 04708DE5 		str	r7, [sp, #4]
 3277 1b38 FEFFFFEB 		bl	cmdSet
1535:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3278              		.loc 1 1535 0
 3279 1b3c 1C0094E5 		ldr	r0, [r4, #28]
 3280 1b40 FEFFFFEB 		bl	_txe_mutex_put
1536:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3281              		.loc 1 1536 0
 3282 1b44 18809DE5 		ldr	r8, [sp, #24]
1538:../uvc.c      **** 							 break;
 3283              		.loc 1 1538 0
 3284 1b48 FFA0A0E3 		mov	sl, #255
1537:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3285              		.loc 1 1537 0
 3286 1b4c 2072C6E5 		strb	r7, [r6, #544]
1536:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3287              		.loc 1 1536 0
 3288 1b50 1D82C6E5 		strb	r8, [r6, #541]
1537:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3289              		.loc 1 1537 0
 3290 1b54 1C409DE5 		ldr	r4, [sp, #28]
1538:../uvc.c      **** 							 break;
 3291              		.loc 1 1538 0
 3292 1b58 0A70A0E1 		mov	r7, sl
 3293 1b5c 0CFDFFEA 		b	.L152
 3294              	.LVL295:
 3295              	.L235:
1511:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3296              		.loc 1 1511 0
 3297 1b60 14839FE5 		ldr	r8, .L321+64
 3298 1b64 0010E0E3 		mvn	r1, #0
 3299 1b68 1C0098E5 		ldr	r0, [r8, #28]
 3300 1b6c FEFFFFEB 		bl	_txe_mutex_get
 3301              	.LVL296:
1512:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3302              		.loc 1 1512 0
 3303 1b70 18209DE5 		ldr	r2, [sp, #24]
 3304 1b74 00C0A0E3 		mov	ip, #0
 3305 1b78 803042E2 		sub	r3, r2, #128
 3306 1b7c FF4003E2 		and	r4, r3, #255
 3307 1b80 0A20A0E1 		mov	r2, sl
 3308 1b84 0510A0E3 		mov	r1, #5
 3309 1b88 0930A0E1 		mov	r3, r9
 3310 1b8c 0800A0E1 		mov	r0, r8
 3311 1b90 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3312 1b94 FEFFFFEB 		bl	cmdSet
 3313              	.LVL297:
1514:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3314              		.loc 1 1514 0
 3315 1b98 18A09DE5 		ldr	sl, [sp, #24]
 3316 1b9c 0510A0E3 		mov	r1, #5
 3317 1ba0 76704AE2 		sub	r7, sl, #118
 3318              	.LVL298:
 3319 1ba4 FFE007E2 		and	lr, r7, #255
 3320 1ba8 DC20A0E3 		mov	r2, #220
 3321 1bac 0170A0E3 		mov	r7, #1
 3322 1bb0 0930A0E1 		mov	r3, r9
 3323 1bb4 0800A0E1 		mov	r0, r8
 3324 1bb8 00E08DE5 		str	lr, [sp, #0]
 3325 1bbc 04708DE5 		str	r7, [sp, #4]
 3326 1bc0 FEFFFFEB 		bl	cmdSet
 3327              	.LVL299:
1516:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3328              		.loc 1 1516 0
 3329 1bc4 18009DE5 		ldr	r0, [sp, #24]
 3330 1bc8 02C0A0E3 		mov	ip, #2
 3331 1bcc 7E1080E2 		add	r1, r0, #126
 3332 1bd0 FF4001E2 		and	r4, r1, #255
 3333 1bd4 DE20A0E3 		mov	r2, #222
 3334 1bd8 0510A0E3 		mov	r1, #5
 3335 1bdc 0930A0E1 		mov	r3, r9
 3336 1be0 0800A0E1 		mov	r0, r8
 3337 1be4 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3338 1be8 FEFFFFEB 		bl	cmdSet
 3339              	.LVL300:
1518:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3340              		.loc 1 1518 0
 3341 1bec 18209DE5 		ldr	r2, [sp, #24]
 3342 1bf0 0510A0E3 		mov	r1, #5
 3343 1bf4 723082E2 		add	r3, r2, #114
 3344 1bf8 FFA003E2 		and	sl, r3, #255
 3345 1bfc E020A0E3 		mov	r2, #224
 3346 1c00 0930A0E1 		mov	r3, r9
 3347 1c04 0800A0E1 		mov	r0, r8
 3348 1c08 0340A0E3 		mov	r4, #3
 3349 1c0c 00A08DE5 		str	sl, [sp, #0]
 3350 1c10 04408DE5 		str	r4, [sp, #4]
 3351 1c14 FEFFFFEB 		bl	cmdSet
 3352              	.LVL301:
1520:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3353              		.loc 1 1520 0
 3354 1c18 18009DE5 		ldr	r0, [sp, #24]
 3355 1c1c DD20A0E3 		mov	r2, #221
 3356 1c20 6F1040E2 		sub	r1, r0, #111
 3357 1c24 FFC001E2 		and	ip, r1, #255
 3358 1c28 0930A0E1 		mov	r3, r9
 3359 1c2c 0510A0E3 		mov	r1, #5
 3360 1c30 0800A0E1 		mov	r0, r8
 3361 1c34 04A0A0E3 		mov	sl, #4
 3362 1c38 00C08DE5 		str	ip, [sp, #0]
 3363 1c3c 04A08DE5 		str	sl, [sp, #4]
 3364 1c40 FEFFFFEB 		bl	cmdSet
 3365              	.LVL302:
1522:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3366              		.loc 1 1522 0
 3367 1c44 3C229FE5 		ldr	r2, .L321+76
 3368 1c48 05E0A0E3 		mov	lr, #5
 3369 1c4c 7440D2E5 		ldrb	r4, [r2, #116]	@ zero_extendqisi2
1525:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3370              		.loc 1 1525 0
 3371 1c50 30A29FE5 		ldr	sl, .L321+76
1522:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3372              		.loc 1 1522 0
 3373 1c54 7F3084E2 		add	r3, r4, #127
 3374 1c58 FFC003E2 		and	ip, r3, #255
 3375 1c5c 0E10A0E1 		mov	r1, lr
 3376 1c60 0B20A0E1 		mov	r2, fp
 3377 1c64 0930A0E1 		mov	r3, r9
 3378 1c68 0800A0E1 		mov	r0, r8
 3379 1c6c 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3380 1c70 FEFFFFEB 		bl	cmdSet
1523:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3381              		.loc 1 1523 0
 3382 1c74 1C0098E5 		ldr	r0, [r8, #28]
 3383 1c78 FEFFFFEB 		bl	_txe_mutex_put
1525:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3384              		.loc 1 1525 0
 3385 1c7c 7400DAE5 		ldrb	r0, [sl, #116]	@ zero_extendqisi2
1527:../uvc.c      **** 							 break;
 3386              		.loc 1 1527 0
 3387 1c80 FFA0A0E3 		mov	sl, #255
1525:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3388              		.loc 1 1525 0
 3389 1c84 801040E2 		sub	r1, r0, #128
1526:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3390              		.loc 1 1526 0
 3391 1c88 0872C6E5 		strb	r7, [r6, #520]
1525:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3392              		.loc 1 1525 0
 3393 1c8c 0512C6E5 		strb	r1, [r6, #517]
1526:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3394              		.loc 1 1526 0
 3395 1c90 18809DE5 		ldr	r8, [sp, #24]
 3396 1c94 1C409DE5 		ldr	r4, [sp, #28]
1527:../uvc.c      **** 							 break;
 3397              		.loc 1 1527 0
 3398 1c98 0A70A0E1 		mov	r7, sl
 3399 1c9c BCFCFFEA 		b	.L152
 3400              	.LVL303:
 3401              	.L234:
1558:../uvc.c      **** 							 Data0 = Data0 - 1;
 3402              		.loc 1 1558 0
 3403 1ca0 012043E2 		sub	r2, r3, #1
 3404              	.LVL304:
 3405 1ca4 FF2002E2 		and	r2, r2, #255
 3406              	.LVL305:
1559:../uvc.c      **** 							 is60Hz = Data0;
 3407              		.loc 1 1559 0
 3408 1ca8 D8119FE5 		ldr	r1, .L321+76
1570:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3409              		.loc 1 1570 0
 3410 1cac D4E19FE5 		ldr	lr, .L321+76
1565:../uvc.c      **** 							 else if(Data0 >2)
 3411              		.loc 1 1565 0
 3412 1cb0 020052E3 		cmp	r2, #2
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3413              		.loc 1 1557 0
 3414 1cb4 ED31C6E5 		strb	r3, [r6, #493]
1568:../uvc.c      **** 								 is60Hz = CyTrue;
 3415              		.loc 1 1568 0
 3416 1cb8 0130A083 		movhi	r3, #1
1559:../uvc.c      **** 							 is60Hz = Data0;
 3417              		.loc 1 1559 0
 3418 1cbc 6C2081E5 		str	r2, [r1, #108]
 3419              	.LVL306:
1570:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3420              		.loc 1 1570 0
 3421 1cc0 0400A0E3 		mov	r0, #4
1568:../uvc.c      **** 								 is60Hz = CyTrue;
 3422              		.loc 1 1568 0
 3423 1cc4 6C308185 		strhi	r3, [r1, #108]
 3424              	.LVL307:
 3425 1cc8 0320A081 		movhi	r2, r3
1570:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3426              		.loc 1 1570 0
 3427 1ccc 90119FE5 		ldr	r1, .L321+40
 3428 1cd0 6C309EE5 		ldr	r3, [lr, #108]
 3429 1cd4 FEFFFFEB 		bl	CyU3PDebugPrint
 3430              	.LVL308:
1571:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3431              		.loc 1 1571 0
 3432 1cd8 A8019FE5 		ldr	r0, .L321+76
 3433 1cdc 3C3090E5 		ldr	r3, [r0, #60]
 3434 1ce0 010053E3 		cmp	r3, #1
 3435 1ce4 5101000A 		beq	.L317
 3436              	.LVL309:
 3437              	.L268:
1602:../uvc.c      **** 							 break;
 3438              		.loc 1 1602 0
 3439 1ce8 FFA0A0E3 		mov	sl, #255
1601:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3440              		.loc 1 1601 0
 3441 1cec 0130A0E3 		mov	r3, #1
 3442 1cf0 F031C6E5 		strb	r3, [r6, #496]
 3443 1cf4 18809DE5 		ldr	r8, [sp, #24]
 3444 1cf8 1C409DE5 		ldr	r4, [sp, #28]
1602:../uvc.c      **** 							 break;
 3445              		.loc 1 1602 0
 3446 1cfc 0A70A0E1 		mov	r7, sl
 3447 1d00 A3FCFFEA 		b	.L152
 3448              	.LVL310:
 3449              	.L233:
1657:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3450              		.loc 1 1657 0
 3451 1d04 70819FE5 		ldr	r8, .L321+64
 3452 1d08 0010E0E3 		mvn	r1, #0
 3453 1d0c 1C0098E5 		ldr	r0, [r8, #28]
 3454 1d10 FEFFFFEB 		bl	_txe_mutex_get
 3455              	.LVL311:
1658:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3456              		.loc 1 1658 0
 3457 1d14 18C09DE5 		ldr	ip, [sp, #24]
 3458 1d18 0410A0E1 		mov	r1, r4
 3459 1d1c 0A20A0E1 		mov	r2, sl
 3460 1d20 0930A0E1 		mov	r3, r9
 3461 1d24 0800A0E1 		mov	r0, r8
 3462 1d28 00A0A0E3 		mov	sl, #0
 3463 1d2c 00C08DE5 		str	ip, [sp, #0]
 3464 1d30 04A08DE5 		str	sl, [sp, #4]
 3465 1d34 FEFFFFEB 		bl	cmdSet
1659:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3466              		.loc 1 1659 0
 3467 1d38 1C0098E5 		ldr	r0, [r8, #28]
 3468 1d3c FEFFFFEB 		bl	_txe_mutex_put
1661:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3469              		.loc 1 1661 0
 3470 1d40 18709DE5 		ldr	r7, [sp, #24]
 3471              	.LVL312:
1666:../uvc.c      **** 							 break;
 3472              		.loc 1 1666 0
 3473 1d44 FFA0A0E3 		mov	sl, #255
1662:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3474              		.loc 1 1662 0
 3475 1d48 0130A0E3 		mov	r3, #1
1661:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3476              		.loc 1 1661 0
 3477 1d4c BD71C6E5 		strb	r7, [r6, #445]
1662:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3478              		.loc 1 1662 0
 3479 1d50 0780A0E1 		mov	r8, r7
 3480 1d54 C031C6E5 		strb	r3, [r6, #448]
 3481 1d58 1C409DE5 		ldr	r4, [sp, #28]
1666:../uvc.c      **** 							 break;
 3482              		.loc 1 1666 0
 3483 1d5c 0A70A0E1 		mov	r7, sl
 3484 1d60 8BFCFFEA 		b	.L152
 3485              	.LVL313:
 3486              	.L232:
1493:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3487              		.loc 1 1493 0
 3488 1d64 10819FE5 		ldr	r8, .L321+64
 3489 1d68 0010E0E3 		mvn	r1, #0
 3490 1d6c 1C0098E5 		ldr	r0, [r8, #28]
 3491 1d70 FEFFFFEB 		bl	_txe_mutex_get
 3492              	.LVL314:
1495:../uvc.c      **** 							  if(Data0&0x80){
 3493              		.loc 1 1495 0
 3494 1d74 18209DE5 		ldr	r2, [sp, #24]
1500:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3495              		.loc 1 1500 0
 3496 1d78 0930A0E1 		mov	r3, r9
1495:../uvc.c      **** 							  if(Data0&0x80){
 3497              		.loc 1 1495 0
 3498 1d7c 800012E3 		tst	r2, #128
1496:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3499              		.loc 1 1496 0
 3500 1d80 80704212 		subne	r7, r2, #128
 3501              	.LVL315:
1498:../uvc.c      **** 								  Data0 = ~Data0;
 3502              		.loc 1 1498 0
 3503 1d84 0270E001 		mvneq	r7, r2
 3504 1d88 FF7007E2 		and	r7, r7, #255
 3505              	.LVL316:
1500:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3506              		.loc 1 1500 0
 3507 1d8c 0110A0E3 		mov	r1, #1
 3508 1d90 0B20A0E1 		mov	r2, fp
 3509 1d94 0040A0E3 		mov	r4, #0
 3510 1d98 DC009FE5 		ldr	r0, .L321+64
 3511 1d9c 00708DE5 		str	r7, [sp, #0]
 3512 1da0 04408DE5 		str	r4, [sp, #4]
 3513 1da4 FEFFFFEB 		bl	cmdSet
1501:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3514              		.loc 1 1501 0
 3515 1da8 1C0098E5 		ldr	r0, [r8, #28]
 3516 1dac FEFFFFEB 		bl	_txe_mutex_put
1507:../uvc.c      **** 							 break;
 3517              		.loc 1 1507 0
 3518 1db0 FFA0A0E3 		mov	sl, #255
1504:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3519              		.loc 1 1504 0
 3520 1db4 0130A0E3 		mov	r3, #1
1503:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3521              		.loc 1 1503 0
 3522 1db8 A571C6E5 		strb	r7, [r6, #421]
1504:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3523              		.loc 1 1504 0
 3524 1dbc A831C6E5 		strb	r3, [r6, #424]
 3525 1dc0 18809DE5 		ldr	r8, [sp, #24]
 3526 1dc4 1C409DE5 		ldr	r4, [sp, #28]
1507:../uvc.c      **** 							 break;
 3527              		.loc 1 1507 0
 3528 1dc8 0A70A0E1 		mov	r7, sl
 3529              	.LVL317:
 3530 1dcc 70FCFFEA 		b	.L152
 3531              	.LVL318:
 3532              	.L231:
1614:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3533              		.loc 1 1614 0
 3534 1dd0 B0409FE5 		ldr	r4, .L321+76
1604:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3535              		.loc 1 1604 0
 3536 1dd4 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3537              	.LVL319:
1614:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3538              		.loc 1 1614 0
 3539 1dd8 D420D4E5 		ldrb	r2, [r4, #212]	@ zero_extendqisi2
 3540              	.LVL320:
 3541 1ddc 0310A0E1 		mov	r1, r3
1605:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3542              		.loc 1 1605 0
 3543 1de0 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1606:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3544              		.loc 1 1606 0
 3545 1de4 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1614:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3546              		.loc 1 1614 0
 3547 1de8 010052E3 		cmp	r2, #1
1612:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3548              		.loc 1 1612 0
 3549 1dec 01E0A0E3 		mov	lr, #1
1611:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3550              		.loc 1 1611 0
 3551 1df0 0515C6E5 		strb	r1, [r6, #1285]
1604:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3552              		.loc 1 1604 0
 3553 1df4 FF7007E2 		and	r7, r7, #255
 3554              	.LVL321:
1612:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3555              		.loc 1 1612 0
 3556 1df8 09E5C6E5 		strb	lr, [r6, #1289]
1606:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3557              		.loc 1 1606 0
 3558 1dfc FF8008E2 		and	r8, r8, #255
 3559              	.LVL322:
 3560 1e00 0160A011 		movne	r6, r1
1614:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3561              		.loc 1 1614 0
 3562 1e04 6E01000A 		beq	.L318
 3563              	.LVL323:
 3564              	.L282:
1625:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3565              		.loc 1 1625 0
 3566 1e08 6CA09FE5 		ldr	sl, .L321+64
 3567 1e0c 0010E0E3 		mvn	r1, #0
 3568 1e10 1C009AE5 		ldr	r0, [sl, #28]
 3569 1e14 FEFFFFEB 		bl	_txe_mutex_get
1626:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3570              		.loc 1 1626 0
 3571 1e18 00C0A0E3 		mov	ip, #0
 3572 1e1c 0C10A0E1 		mov	r1, ip
 3573 1e20 0720A0E1 		mov	r2, r7
 3574 1e24 0830A0E1 		mov	r3, r8
 3575 1e28 0A00A0E1 		mov	r0, sl
 3576 1e2c 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3577 1e30 FEFFFFEB 		bl	cmdSet
1627:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3578              		.loc 1 1627 0
 3579 1e34 1C009AE5 		ldr	r0, [sl, #28]
 3580 1e38 9BFEFFEA 		b	.L308
 3581              	.L322:
 3582              		.align	2
 3583              	.L321:
 3584 1e3c 00000000 		.word	bRequest
 3585 1e40 DC040000 		.word	.LC30
 3586 1e44 74000000 		.word	.LANCHOR0+116
 3587 1e48 01000100 		.word	65537
 3588 1e4c FF00FF00 		.word	16711935
 3589 1e50 6C030000 		.word	.LC22
 3590 1e54 A8030000 		.word	.LC23
 3591 1e58 0C030000 		.word	.LC20
 3592 1e5c 60000000 		.word	.LANCHOR0+96
 3593 1e60 30040000 		.word	.LC26
 3594 1e64 68040000 		.word	.LC27
 3595 1e68 FC030000 		.word	.LC25
 3596 1e6c D0030000 		.word	.LC24
 3597 1e70 AC040000 		.word	.LC29
 3598 1e74 88040000 		.word	.LC28
 3599 1e78 E4020000 		.word	.LC19
 3600 1e7c 00000000 		.word	cmdQu
 3601 1e80 34030000 		.word	.LC21
 3602 1e84 00000000 		.word	.LANCHOR1
 3603 1e88 00000000 		.word	.LANCHOR0
 3604              	.LVL324:
 3605              	.L230:
1670:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3606              		.loc 1 1670 0
 3607 1e8c 18701FE5 		ldr	r7, .L321+64
 3608              	.LVL325:
 3609 1e90 0010E0E3 		mvn	r1, #0
 3610 1e94 1C0097E5 		ldr	r0, [r7, #28]
 3611 1e98 FEFFFFEB 		bl	_txe_mutex_get
 3612              	.LVL326:
1671:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3613              		.loc 1 1671 0
 3614 1e9c 0A20A0E1 		mov	r2, sl
 3615 1ea0 18A09DE5 		ldr	sl, [sp, #24]
 3616 1ea4 0410A0E1 		mov	r1, r4
 3617 1ea8 0930A0E1 		mov	r3, r9
 3618 1eac 0700A0E1 		mov	r0, r7
 3619 1eb0 0080A0E3 		mov	r8, #0
 3620 1eb4 00A08DE5 		str	sl, [sp, #0]
 3621 1eb8 04808DE5 		str	r8, [sp, #4]
 3622 1ebc FEFFFFEB 		bl	cmdSet
1672:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3623              		.loc 1 1672 0
 3624 1ec0 1C0097E5 		ldr	r0, [r7, #28]
 3625 1ec4 FEFFFFEB 		bl	_txe_mutex_put
1674:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3626              		.loc 1 1674 0
 3627 1ec8 18109DE5 		ldr	r1, [sp, #24]
 3628 1ecc 840084E0 		add	r0, r4, r4, asl #1
 3629 1ed0 806186E0 		add	r6, r6, r0, asl #3
1676:../uvc.c      **** 							 break;
 3630              		.loc 1 1676 0
 3631 1ed4 FFA0A0E3 		mov	sl, #255
1675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3632              		.loc 1 1675 0
 3633 1ed8 0120A0E3 		mov	r2, #1
1674:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3634              		.loc 1 1674 0
 3635 1edc 8D11C6E5 		strb	r1, [r6, #397]
1675:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3636              		.loc 1 1675 0
 3637 1ee0 9021C6E5 		strb	r2, [r6, #400]
 3638 1ee4 0180A0E1 		mov	r8, r1
 3639 1ee8 1C409DE5 		ldr	r4, [sp, #28]
1676:../uvc.c      **** 							 break;
 3640              		.loc 1 1676 0
 3641 1eec 0A70A0E1 		mov	r7, sl
 3642 1ef0 27FCFFEA 		b	.L152
 3643              	.LVL327:
 3644              	.L240:
1311:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3645              		.loc 1 1311 0
 3646 1ef4 80401FE5 		ldr	r4, .L321+64
1307:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3647              		.loc 1 1307 0
 3648 1ef8 E0A4D6E5 		ldrb	sl, [r6, #1248]	@ zero_extendqisi2
1308:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3649              		.loc 1 1308 0
 3650 1efc E1E4D6E5 		ldrb	lr, [r6, #1249]	@ zero_extendqisi2
1309:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3651              		.loc 1 1309 0
 3652 1f00 EFC4D6E5 		ldrb	ip, [r6, #1263]	@ zero_extendqisi2
 3653              	.LVL328:
1311:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3654              		.loc 1 1311 0
 3655 1f04 0010E0E3 		mvn	r1, #0
 3656 1f08 1C0094E5 		ldr	r0, [r4, #28]
1309:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3657              		.loc 1 1309 0
 3658 1f0c FF800CE2 		and	r8, ip, #255
1308:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3659              		.loc 1 1308 0
 3660 1f10 FF900EE2 		and	r9, lr, #255
1311:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3661              		.loc 1 1311 0
 3662 1f14 FEFFFFEB 		bl	_txe_mutex_get
 3663              	.LVL329:
1312:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3664              		.loc 1 1312 0
 3665 1f18 18C09DE5 		ldr	ip, [sp, #24]
 3666 1f1c ED14D6E5 		ldrb	r1, [r6, #1261]	@ zero_extendqisi2
1307:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3667              		.loc 1 1307 0
 3668 1f20 FFA00AE2 		and	sl, sl, #255
 3669              	.LVL330:
1312:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3670              		.loc 1 1312 0
 3671 1f24 01005CE1 		cmp	ip, r1
1307:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3672              		.loc 1 1307 0
 3673 1f28 AC301FE5 		ldr	r3, .L321+72
 3674 1f2c 0C70A001 		moveq	r7, ip
 3675              	.LVL331:
1312:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3676              		.loc 1 1312 0
 3677 1f30 0A00000A 		beq	.L253
1314:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3678              		.loc 1 1314 0
 3679 1f34 EDC4C3E5 		strb	ip, [r3, #1261]
1315:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3680              		.loc 1 1315 0
 3681 1f38 C534D3E5 		ldrb	r3, [r3, #1221]	@ zero_extendqisi2
1316:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3682              		.loc 1 1316 0
 3683 1f3c 0400A0E1 		mov	r0, r4
1315:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3684              		.loc 1 1315 0
 3685 1f40 03728CE1 		orr	r7, ip, r3, asl #4
 3686 1f44 FF7007E2 		and	r7, r7, #255
 3687              	.LVL332:
1316:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3688              		.loc 1 1316 0
 3689 1f48 00C0A0E3 		mov	ip, #0
 3690 1f4c 1910A0E3 		mov	r1, #25
 3691 1f50 0A20A0E1 		mov	r2, sl
 3692 1f54 0830A0E1 		mov	r3, r8
 3693 1f58 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3694 1f5c FEFFFFEB 		bl	cmdSet
 3695              	.LVL333:
 3696              	.L253:
1328:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3697              		.loc 1 1328 0
 3698 1f60 EE04D6E5 		ldrb	r0, [r6, #1262]	@ zero_extendqisi2
 3699 1f64 1CE09DE5 		ldr	lr, [sp, #28]
 3700 1f68 0E0050E1 		cmp	r0, lr
 3701 1f6c 0500000A 		beq	.L254
1330:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3702              		.loc 1 1330 0
 3703 1f70 18A09DE5 		ldr	sl, [sp, #24]
 3704              	.LVL334:
1329:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3705              		.loc 1 1329 0
 3706 1f74 F8201FE5 		ldr	r2, .L321+72
1330:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3707              		.loc 1 1330 0
 3708 1f78 02104AE2 		sub	r1, sl, #2
 3709 1f7c 010051E3 		cmp	r1, #1
1329:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3710              		.loc 1 1329 0
 3711 1f80 EEE4C2E5 		strb	lr, [r2, #1262]
1330:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3712              		.loc 1 1330 0
 3713 1f84 E101009A 		bls	.L319
 3714              	.LVL335:
 3715              	.L254:
1335:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3716              		.loc 1 1335 0
 3717 1f88 1C0094E5 		ldr	r0, [r4, #28]
 3718 1f8c FEFFFFEB 		bl	_txe_mutex_put
1337:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3719              		.loc 1 1337 0
 3720 1f90 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1336:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3721              		.loc 1 1336 0
 3722 1f94 1C409DE5 		ldr	r4, [sp, #28]
1337:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3723              		.loc 1 1337 0
 3724 1f98 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
 3725 1f9c C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
1336:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3726              		.loc 1 1336 0
 3727 1fa0 0400A0E3 		mov	r0, #4
 3728 1fa4 44111FE5 		ldr	r1, .L321+44
1338:../uvc.c      **** 							 break;
 3729              		.loc 1 1338 0
 3730 1fa8 FFA0A0E3 		mov	sl, #255
1336:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3731              		.loc 1 1336 0
 3732 1fac 04708DE5 		str	r7, [sp, #4]
 3733 1fb0 00C08DE5 		str	ip, [sp, #0]
 3734 1fb4 08408DE5 		str	r4, [sp, #8]
1338:../uvc.c      **** 							 break;
 3735              		.loc 1 1338 0
 3736 1fb8 0A70A0E1 		mov	r7, sl
 3737              	.LVL336:
1336:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3738              		.loc 1 1336 0
 3739 1fbc FEFFFFEB 		bl	CyU3PDebugPrint
 3740              	.LVL337:
 3741 1fc0 18809DE5 		ldr	r8, [sp, #24]
1338:../uvc.c      **** 							 break;
 3742              		.loc 1 1338 0
 3743 1fc4 F2FBFFEA 		b	.L152
 3744              	.LVL338:
 3745              	.L239:
1247:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3746              		.loc 1 1247 0
 3747 1fc8 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 3748 1fcc 0310A0E1 		mov	r1, r3
1248:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3749              		.loc 1 1248 0
 3750 1fd0 B984D6E5 		ldrb	r8, [r6, #1209]	@ zero_extendqisi2
1249:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3751              		.loc 1 1249 0
 3752 1fd4 C744D6E5 		ldrb	r4, [r6, #1223]	@ zero_extendqisi2
1250:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3753              		.loc 1 1250 0
 3754 1fd8 C534C6E5 		strb	r3, [r6, #1221]
1252:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3755              		.loc 1 1252 0
 3756 1fdc ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
1247:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3757              		.loc 1 1247 0
 3758 1fe0 FF700AE2 		and	r7, sl, #255
 3759              	.LVL339:
1252:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3760              		.loc 1 1252 0
 3761 1fe4 030013E3 		tst	r3, #3
1248:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3762              		.loc 1 1248 0
 3763 1fe8 FF8008E2 		and	r8, r8, #255
 3764              	.LVL340:
1249:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3765              		.loc 1 1249 0
 3766 1fec FF4004E2 		and	r4, r4, #255
 3767              	.LVL341:
1252:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3768              		.loc 1 1252 0
 3769 1ff0 0130A001 		moveq	r3, r1
 3770 1ff4 1D00000A 		beq	.L252
1254:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3771              		.loc 1 1254 0
 3772 1ff8 7C911FE5 		ldr	r9, .L321+72
1256:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3773              		.loc 1 1256 0
 3774 1ffc 88A11FE5 		ldr	sl, .L321+64
1254:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3775              		.loc 1 1254 0
 3776 2000 ED04D9E5 		ldrb	r0, [r9, #1261]	@ zero_extendqisi2
 3777 2004 0120A0E1 		mov	r2, r1
 3778              	.LVL342:
 3779 2008 023280E1 		orr	r3, r0, r2, asl #4
1256:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3780              		.loc 1 1256 0
 3781 200c 0010E0E3 		mvn	r1, #0
 3782 2010 1C009AE5 		ldr	r0, [sl, #28]
1254:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3783              		.loc 1 1254 0
 3784 2014 FF9003E2 		and	r9, r3, #255
 3785              	.LVL343:
1256:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3786              		.loc 1 1256 0
 3787 2018 14C08DE5 		str	ip, [sp, #20]
 3788 201c FEFFFFEB 		bl	_txe_mutex_get
 3789              	.LVL344:
1257:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3790              		.loc 1 1257 0
 3791 2020 00E0A0E3 		mov	lr, #0
 3792 2024 1010A0E3 		mov	r1, #16
 3793 2028 0820A0E1 		mov	r2, r8
 3794 202c 0430A0E1 		mov	r3, r4
 3795 2030 0A00A0E1 		mov	r0, sl
 3796 2034 00E08DE5 		str	lr, [sp, #0]
 3797 2038 04E08DE5 		str	lr, [sp, #4]
 3798 203c FEFFFFEB 		bl	cmdSet
 3799              	.LVL345:
1259:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3800              		.loc 1 1259 0
 3801 2040 0720A0E1 		mov	r2, r7
 3802 2044 0430A0E1 		mov	r3, r4
 3803 2048 1010A0E3 		mov	r1, #16
 3804 204c 0A00A0E1 		mov	r0, sl
 3805 2050 0170A0E3 		mov	r7, #1
 3806              	.LVL346:
 3807 2054 00908DE5 		str	r9, [sp, #0]
 3808 2058 04708DE5 		str	r7, [sp, #4]
 3809 205c FEFFFFEB 		bl	cmdSet
 3810              	.LVL347:
1260:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3811              		.loc 1 1260 0
 3812 2060 1C009AE5 		ldr	r0, [sl, #28]
 3813 2064 FEFFFFEB 		bl	_txe_mutex_put
 3814 2068 14C09DE5 		ldr	ip, [sp, #20]
 3815 206c 0930A0E1 		mov	r3, r9
 3816              	.LVL348:
 3817              	.L252:
1263:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3818              		.loc 1 1263 0
 3819 2070 ED84D6E5 		ldrb	r8, [r6, #1261]	@ zero_extendqisi2
 3820              	.LVL349:
 3821 2074 C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3822              	.LVL350:
1262:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3823              		.loc 1 1262 0
 3824 2078 0400A0E3 		mov	r0, #4
 3825 207c 18121FE5 		ldr	r1, .L321+48
 3826 2080 0C20A0E1 		mov	r2, ip
1264:../uvc.c      **** 						     break;
 3827              		.loc 1 1264 0
 3828 2084 FFA0A0E3 		mov	sl, #255
1262:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3829              		.loc 1 1262 0
 3830 2088 00808DE5 		str	r8, [sp, #0]
 3831 208c 04408DE5 		str	r4, [sp, #4]
1264:../uvc.c      **** 						     break;
 3832              		.loc 1 1264 0
 3833 2090 0A70A0E1 		mov	r7, sl
1262:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3834              		.loc 1 1262 0
 3835 2094 FEFFFFEB 		bl	CyU3PDebugPrint
 3836 2098 18809DE5 		ldr	r8, [sp, #24]
 3837 209c 1C409DE5 		ldr	r4, [sp, #28]
1264:../uvc.c      **** 						     break;
 3838              		.loc 1 1264 0
 3839 20a0 BBFBFFEA 		b	.L152
 3840              	.LVL351:
 3841              	.L238:
1545:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3842              		.loc 1 1545 0
 3843 20a4 30721FE5 		ldr	r7, .L321+64
 3844              	.LVL352:
 3845 20a8 0010E0E3 		mvn	r1, #0
 3846 20ac 1C0097E5 		ldr	r0, [r7, #28]
 3847 20b0 FEFFFFEB 		bl	_txe_mutex_get
 3848              	.LVL353:
1546:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3849              		.loc 1 1546 0
 3850 20b4 18C09DE5 		ldr	ip, [sp, #24]
 3851 20b8 0A20A0E1 		mov	r2, sl
 3852 20bc 0B10A0E3 		mov	r1, #11
 3853 20c0 0930A0E1 		mov	r3, r9
 3854 20c4 0700A0E1 		mov	r0, r7
 3855 20c8 00A0A0E3 		mov	sl, #0
 3856 20cc 00C08DE5 		str	ip, [sp, #0]
 3857 20d0 04A08DE5 		str	sl, [sp, #4]
 3858 20d4 FEFFFFEB 		bl	cmdSet
 3859              	.LVL354:
1548:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3860              		.loc 1 1548 0
 3861 20d8 1C409DE5 		ldr	r4, [sp, #28]
 3862 20dc 0180A0E3 		mov	r8, #1
 3863 20e0 0B10A0E3 		mov	r1, #11
 3864 20e4 0B20A0E1 		mov	r2, fp
 3865 20e8 0930A0E1 		mov	r3, r9
 3866 20ec 0700A0E1 		mov	r0, r7
 3867 20f0 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3868 20f4 FEFFFFEB 		bl	cmdSet
1549:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3869              		.loc 1 1549 0
 3870 20f8 1C0097E5 		ldr	r0, [r7, #28]
 3871 20fc FEFFFFEB 		bl	_txe_mutex_put
1551:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3872              		.loc 1 1551 0
 3873 2100 18009DE5 		ldr	r0, [sp, #24]
1552:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3874              		.loc 1 1552 0
 3875 2104 1C109DE5 		ldr	r1, [sp, #28]
1554:../uvc.c      **** 							 break;
 3876              		.loc 1 1554 0
 3877 2108 FFA0A0E3 		mov	sl, #255
1553:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3878              		.loc 1 1553 0
 3879 210c 9882C6E5 		strb	r8, [r6, #664]
1551:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3880              		.loc 1 1551 0
 3881 2110 F404C6E5 		strb	r0, [r6, #1268]
1552:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3882              		.loc 1 1552 0
 3883 2114 F614C6E5 		strb	r1, [r6, #1270]
1553:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3884              		.loc 1 1553 0
 3885 2118 0080A0E1 		mov	r8, r0
 3886 211c 0140A0E1 		mov	r4, r1
1554:../uvc.c      **** 							 break;
 3887              		.loc 1 1554 0
 3888 2120 0A70A0E1 		mov	r7, sl
 3889 2124 9AFBFFEA 		b	.L152
 3890              	.LVL355:
 3891              	.L237:
1631:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3892              		.loc 1 1631 0
 3893 2128 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1632:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3894              		.loc 1 1632 0
 3895 212c 0D25D6E5 		ldrb	r2, [r6, #1293]	@ zero_extendqisi2
 3896              	.LVL356:
1633:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3897              		.loc 1 1633 0
 3898 2130 1B15D6E5 		ldrb	r1, [r6, #1307]	@ zero_extendqisi2
1636:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3899              		.loc 1 1636 0
 3900 2134 0140A0E3 		mov	r4, #1
1637:../uvc.c      **** 							 if(Data0 != 0){
 3901              		.loc 1 1637 0
 3902 2138 000053E3 		cmp	r3, #0
1635:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3903              		.loc 1 1635 0
 3904 213c 1935C6E5 		strb	r3, [r6, #1305]
1631:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3905              		.loc 1 1631 0
 3906 2140 FF8000E2 		and	r8, r0, #255
 3907              	.LVL357:
1632:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3908              		.loc 1 1632 0
 3909 2144 FFA002E2 		and	sl, r2, #255
 3910              	.LVL358:
1633:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3911              		.loc 1 1633 0
 3912 2148 FF7001E2 		and	r7, r1, #255
 3913              	.LVL359:
1636:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3914              		.loc 1 1636 0
 3915 214c 1D45C6E5 		strb	r4, [r6, #1309]
1637:../uvc.c      **** 							 if(Data0 != 0){
 3916              		.loc 1 1637 0
 3917 2150 1C00000A 		beq	.L284
1638:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3918              		.loc 1 1638 0
 3919 2154 E0621FE5 		ldr	r6, .L321+64
 3920 2158 0010E0E3 		mvn	r1, #0
 3921 215c 1C0096E5 		ldr	r0, [r6, #28]
 3922 2160 FEFFFFEB 		bl	_txe_mutex_get
 3923              	.LVL360:
1642:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3924              		.loc 1 1642 0
 3925 2164 0820A0E1 		mov	r2, r8
 3926 2168 00C0A0E3 		mov	ip, #0
 3927 216c 0710A0E3 		mov	r1, #7
 3928 2170 0730A0E1 		mov	r3, r7
 3929 2174 0600A0E1 		mov	r0, r6
 3930 2178 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3931 217c FEFFFFEB 		bl	cmdSet
 3932              	.LVL361:
1644:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3933              		.loc 1 1644 0
 3934 2180 18809DE5 		ldr	r8, [sp, #24]
 3935              	.LVL362:
 3936 2184 0710A0E3 		mov	r1, #7
 3937 2188 0A20A0E1 		mov	r2, sl
 3938 218c 0730A0E1 		mov	r3, r7
 3939 2190 0600A0E1 		mov	r0, r6
 3940 2194 00808DE5 		str	r8, [sp, #0]
 3941 2198 04408DE5 		str	r4, [sp, #4]
 3942 219c FEFFFFEB 		bl	cmdSet
1646:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3943              		.loc 1 1646 0
 3944 21a0 1C0096E5 		ldr	r0, [r6, #28]
 3945 21a4 C0FDFFEA 		b	.L308
 3946              	.LVL363:
 3947              	.L229:
1679:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3948              		.loc 1 1679 0
 3949 21a8 FFA0A0E3 		mov	sl, #255
 3950 21ac 0400A0E3 		mov	r0, #4
 3951              	.LVL364:
 3952 21b0 48131FE5 		ldr	r1, .L321+52
 3953 21b4 FEFFFFEB 		bl	CyU3PDebugPrint
 3954              	.LVL365:
 3955 21b8 0A70A0E1 		mov	r7, sl
 3956              	.LVL366:
 3957 21bc 0A40A0E1 		mov	r4, sl
 3958 21c0 0A80A0E1 		mov	r8, sl
 3959 21c4 72FBFFEA 		b	.L152
 3960              	.LVL367:
 3961              	.L284:
1648:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3962              		.loc 1 1648 0
 3963 21c8 54431FE5 		ldr	r4, .L321+64
 3964 21cc 0010E0E3 		mvn	r1, #0
 3965 21d0 1C0094E5 		ldr	r0, [r4, #28]
 3966 21d4 FEFFFFEB 		bl	_txe_mutex_get
 3967              	.LVL368:
1649:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3968              		.loc 1 1649 0
 3969 21d8 18E09DE5 		ldr	lr, [sp, #24]
 3970 21dc 0820A0E1 		mov	r2, r8
 3971 21e0 0730A0E1 		mov	r3, r7
 3972 21e4 0710A0E3 		mov	r1, #7
 3973 21e8 0400A0E1 		mov	r0, r4
 3974 21ec 00E08DE5 		str	lr, [sp, #0]
 3975 21f0 04E08DE5 		str	lr, [sp, #4]
1650:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3976              		.loc 1 1650 0
 3977 21f4 FFA0A0E3 		mov	sl, #255
 3978              	.LVL369:
1649:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3979              		.loc 1 1649 0
 3980 21f8 FEFFFFEB 		bl	cmdSet
1650:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3981              		.loc 1 1650 0
 3982 21fc 1C0094E5 		ldr	r0, [r4, #28]
 3983 2200 FEFFFFEB 		bl	_txe_mutex_put
 3984 2204 0A70A0E1 		mov	r7, sl
 3985              	.LVL370:
 3986 2208 1C409DE5 		ldr	r4, [sp, #28]
 3987 220c 18809DE5 		ldr	r8, [sp, #24]
 3988              	.LVL371:
 3989 2210 5FFBFFEA 		b	.L152
 3990              	.LVL372:
 3991              	.L316:
1008:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 3992              		.loc 1 1008 0
 3993 2214 0A00A0E1 		mov	r0, sl
 3994 2218 0910A0E1 		mov	r1, r9
 3995 221c FEFFFFEB 		bl	SensorGetControl
 3996              	.LVL373:
1010:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 3997              		.loc 1 1010 0
 3998 2220 01A0A0E3 		mov	sl, #1
 3999 2224 99A0C4E5 		strb	sl, [r4, #153]
1009:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4000              		.loc 1 1009 0
 4001 2228 0502C6E5 		strb	r0, [r6, #517]
 4002 222c 47FDFFEA 		b	.L199
 4003              	.LVL374:
 4004              	.L317:
1574:../uvc.c      **** 			                       switch (setRes)
 4005              		.loc 1 1574 0
 4006 2230 D580D0E5 		ldrb	r8, [r0, #213]	@ zero_extendqisi2
 4007 2234 010048E2 		sub	r0, r8, #1
 4008 2238 030050E3 		cmp	r0, #3
 4009 223c 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 4010 2240 A8FEFFEA 		b	.L268
 4011              	.L273:
 4012 2244 70230000 		.word	.L269
 4013 2248 1C230000 		.word	.L270
 4014 224c B8220000 		.word	.L271
 4015 2250 54220000 		.word	.L272
 4016              	.L272:
1592:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4017              		.loc 1 1592 0
 4018 2254 D4031FE5 		ldr	r0, .L321+76
1594:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4019              		.loc 1 1594 0
 4020 2258 D8A31FE5 		ldr	sl, .L321+76
1592:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4021              		.loc 1 1592 0
 4022 225c 6CC090E5 		ldr	ip, [r0, #108]
 4023 2260 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 4024 2264 00005CE3 		cmp	ip, #0
 4025 2268 F4C0A003 		moveq	ip, #244
 4026 226c 74C0A013 		movne	ip, #116
 4027 2270 02208CE1 		orr	r2, ip, r2
 4028 2274 3010A0E3 		mov	r1, #48
 4029 2278 5230A0E3 		mov	r3, #82
 4030 227c 0100A0E3 		mov	r0, #1
 4031 2280 FEFFFFEB 		bl	SensorSetIrisControl
1593:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4032              		.loc 1 1593 0
 4033 2284 7D0FA0E3 		mov	r0, #500
 4034 2288 FEFFFFEB 		bl	_tx_thread_sleep
1594:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4035              		.loc 1 1594 0
 4036 228c 6C409AE5 		ldr	r4, [sl, #108]
 4037 2290 8C74D6E5 		ldrb	r7, [r6, #1164]	@ zero_extendqisi2
 4038              	.LVL375:
 4039 2294 000054E3 		cmp	r4, #0
 4040 2298 F440A003 		moveq	r4, #244
 4041 229c 7440A013 		movne	r4, #116
 4042 22a0 6C309AE5 		ldr	r3, [sl, #108]
 4043 22a4 38141FE5 		ldr	r1, .L321+56
 4044 22a8 072084E1 		orr	r2, r4, r7
 4045 22ac 0400A0E3 		mov	r0, #4
 4046 22b0 FEFFFFEB 		bl	CyU3PDebugPrint
 4047 22b4 8BFEFFEA 		b	.L268
 4048              	.LVL376:
 4049              	.L271:
1587:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 4050              		.loc 1 1587 0
 4051 22b8 38841FE5 		ldr	r8, .L321+76
 4052 22bc 5230A0E3 		mov	r3, #82
 4053 22c0 6CE098E5 		ldr	lr, [r8, #108]
 4054 22c4 8C14D6E5 		ldrb	r1, [r6, #1164]	@ zero_extendqisi2
 4055 22c8 00005EE3 		cmp	lr, #0
 4056 22cc C4E0A003 		moveq	lr, #196
 4057 22d0 44E0A013 		movne	lr, #68
 4058 22d4 01208EE1 		orr	r2, lr, r1
 4059 22d8 0100A0E3 		mov	r0, #1
 4060 22dc 3010A0E3 		mov	r1, #48
 4061 22e0 FEFFFFEB 		bl	SensorSetIrisControl
1588:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4062              		.loc 1 1588 0
 4063 22e4 7D0FA0E3 		mov	r0, #500
 4064 22e8 FEFFFFEB 		bl	_tx_thread_sleep
1589:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4065              		.loc 1 1589 0
 4066 22ec 6C341FE5 		ldr	r3, .L321+76
 4067 22f0 84141FE5 		ldr	r1, .L321+56
 4068 22f4 6C0093E5 		ldr	r0, [r3, #108]
 4069 22f8 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 4070 22fc 000050E3 		cmp	r0, #0
 4071 2300 C400A003 		moveq	r0, #196
 4072 2304 4400A013 		movne	r0, #68
 4073 2308 022080E1 		orr	r2, r0, r2
 4074 230c 6C3093E5 		ldr	r3, [r3, #108]
 4075 2310 0400A0E3 		mov	r0, #4
 4076 2314 FEFFFFEB 		bl	CyU3PDebugPrint
1590:../uvc.c      **** 			                         		break;
 4077              		.loc 1 1590 0
 4078 2318 72FEFFEA 		b	.L268
 4079              	.L270:
1582:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4080              		.loc 1 1582 0
 4081 231c 9CC41FE5 		ldr	ip, .L321+76
1584:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4082              		.loc 1 1584 0
 4083 2320 A0A41FE5 		ldr	sl, .L321+76
1582:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4084              		.loc 1 1582 0
 4085 2324 6C209CE5 		ldr	r2, [ip, #108]
 4086 2328 3010A0E3 		mov	r1, #48
 4087 232c 000052E3 		cmp	r2, #0
 4088 2330 D420A003 		moveq	r2, #212
 4089 2334 5420A013 		movne	r2, #84
 4090 2338 5230A0E3 		mov	r3, #82
 4091 233c 0100A0E3 		mov	r0, #1
 4092 2340 FEFFFFEB 		bl	SensorSetIrisControl
1583:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4093              		.loc 1 1583 0
 4094 2344 7D0FA0E3 		mov	r0, #500
 4095 2348 FEFFFFEB 		bl	_tx_thread_sleep
1584:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4096              		.loc 1 1584 0
 4097 234c 6C209AE5 		ldr	r2, [sl, #108]
 4098 2350 E4141FE5 		ldr	r1, .L321+56
 4099 2354 000052E3 		cmp	r2, #0
 4100 2358 6C309AE5 		ldr	r3, [sl, #108]
 4101 235c D420A003 		moveq	r2, #212
 4102 2360 5420A013 		movne	r2, #84
 4103 2364 0400A0E3 		mov	r0, #4
 4104 2368 FEFFFFEB 		bl	CyU3PDebugPrint
1585:../uvc.c      **** 			                         		break;
 4105              		.loc 1 1585 0
 4106 236c 5DFEFFEA 		b	.L268
 4107              	.L269:
1577:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4108              		.loc 1 1577 0
 4109 2370 F0441FE5 		ldr	r4, .L321+76
1579:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4110              		.loc 1 1579 0
 4111 2374 F4741FE5 		ldr	r7, .L321+76
 4112              	.LVL377:
1577:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4113              		.loc 1 1577 0
 4114 2378 6C2094E5 		ldr	r2, [r4, #108]
 4115 237c 3010A0E3 		mov	r1, #48
 4116 2380 000052E3 		cmp	r2, #0
 4117 2384 E420A003 		moveq	r2, #228
 4118 2388 6420A013 		movne	r2, #100
 4119 238c 5230A0E3 		mov	r3, #82
 4120 2390 0100A0E3 		mov	r0, #1
 4121 2394 FEFFFFEB 		bl	SensorSetIrisControl
1578:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4122              		.loc 1 1578 0
 4123 2398 7D0FA0E3 		mov	r0, #500
 4124 239c FEFFFFEB 		bl	_tx_thread_sleep
1579:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4125              		.loc 1 1579 0
 4126 23a0 6C2097E5 		ldr	r2, [r7, #108]
 4127 23a4 38151FE5 		ldr	r1, .L321+56
 4128 23a8 000052E3 		cmp	r2, #0
 4129 23ac 6C3097E5 		ldr	r3, [r7, #108]
 4130 23b0 E420A003 		moveq	r2, #228
 4131 23b4 6420A013 		movne	r2, #100
 4132 23b8 0400A0E3 		mov	r0, #4
 4133 23bc FEFFFFEB 		bl	CyU3PDebugPrint
1580:../uvc.c      **** 			                         		break;
 4134              		.loc 1 1580 0
 4135 23c0 48FEFFEA 		b	.L268
 4136              	.LVL378:
 4137              	.L318:
1616:../uvc.c      **** 								 if(Data0 < 3){
 4138              		.loc 1 1616 0
 4139 23c4 020051E3 		cmp	r1, #2
1617:../uvc.c      **** 					 				 Data0 += 4;
 4140              		.loc 1 1617 0
 4141 23c8 04608192 		addls	r6, r1, #4
 4142 23cc FF600692 		andls	r6, r6, #255
1616:../uvc.c      **** 								 if(Data0 < 3){
 4143              		.loc 1 1616 0
 4144 23d0 8CFEFF9A 		bls	.L282
1619:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4145              		.loc 1 1619 0
 4146 23d4 0400A0E3 		mov	r0, #4
 4147 23d8 60151FE5 		ldr	r1, .L321+68
 4148 23dc 18309DE5 		ldr	r3, [sp, #24]
 4149 23e0 FEFFFFEB 		bl	CyU3PDebugPrint
 4150              	.LVL379:
1620:../uvc.c      **** 									Data0 = 4; //set to default.
 4151              		.loc 1 1620 0
 4152 23e4 0460A0E3 		mov	r6, #4
 4153 23e8 86FEFFEA 		b	.L282
 4154              	.LVL380:
 4155              	.L200:
1026:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4156              		.loc 1 1026 0
 4157 23ec 0A00A0E1 		mov	r0, sl
 4158              	.LVL381:
 4159 23f0 0910A0E1 		mov	r1, r9
 4160 23f4 FEFFFFEB 		bl	SensorGetControl
1027:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4161              		.loc 1 1027 0
 4162 23f8 0910A0E1 		mov	r1, r9
1026:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4163              		.loc 1 1026 0
 4164 23fc 0070A0E1 		mov	r7, r0
 4165              	.LVL382:
1027:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4166              		.loc 1 1027 0
 4167 2400 0B00A0E1 		mov	r0, fp
 4168              	.LVL383:
 4169 2404 FEFFFFEB 		bl	SensorGetControl
1032:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4170              		.loc 1 1032 0
 4171 2408 0110A0E3 		mov	r1, #1
1028:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4172              		.loc 1 1028 0
 4173 240c 7470C4E5 		strb	r7, [r4, #116]
1029:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4174              		.loc 1 1029 0
 4175 2410 F474C6E5 		strb	r7, [r6, #1268]
1032:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4176              		.loc 1 1032 0
 4177 2414 9F10C4E5 		strb	r1, [r4, #159]
1027:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4178              		.loc 1 1027 0
 4179 2418 00A0A0E1 		mov	sl, r0
 4180              	.LVL384:
1030:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4181              		.loc 1 1030 0
 4182 241c 7600C4E5 		strb	r0, [r4, #118]
1031:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4183              		.loc 1 1031 0
 4184 2420 F604C6E5 		strb	r0, [r6, #1270]
 4185 2424 3DFCFFEA 		b	.L201
 4186              	.LVL385:
 4187              	.L173:
 820:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4188              		.loc 1 820 0
 4189 2428 0910A0E1 		mov	r1, r9
 4190 242c 0B00A0E1 		mov	r0, fp
 4191 2430 FEFFFFEB 		bl	SensorGetControl
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4192              		.loc 1 822 0
 4193 2434 0910A0E1 		mov	r1, r9
 823:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4194              		.loc 1 823 0
 4195 2438 0170A0E3 		mov	r7, #1
 4196              	.LVL386:
 820:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4197              		.loc 1 820 0
 4198 243c 0030A0E1 		mov	r3, r0
 4199 2440 7430C4E5 		strb	r3, [r4, #116]
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4200              		.loc 1 822 0
 4201 2444 0A00A0E1 		mov	r0, sl
 821:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4202              		.loc 1 821 0
 4203 2448 9D34C6E5 		strb	r3, [r6, #1181]
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4204              		.loc 1 822 0
 4205 244c FEFFFFEB 		bl	SensorGetControl
 823:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4206              		.loc 1 823 0
 4207 2450 B870C4E5 		strb	r7, [r4, #184]
 4208 2454 7470D4E5 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 4209              	.LVL387:
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4210              		.loc 1 822 0
 4211 2458 00A0A0E1 		mov	sl, r0
 4212              	.LVL388:
 4213 245c 7500C4E5 		strb	r0, [r4, #117]
 827:../uvc.c      **** 						 break;
 4214              		.loc 1 827 0
 4215 2460 F5FBFFEA 		b	.L175
 4216              	.LVL389:
 4217              	.L178:
 853:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4218              		.loc 1 853 0
 4219 2464 0A00A0E1 		mov	r0, sl
 4220              	.LVL390:
 4221 2468 0910A0E1 		mov	r1, r9
 4222 246c FEFFFFEB 		bl	SensorGetControl
 4223              	.LVL391:
 859:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4224              		.loc 1 859 0
 4225 2470 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 860:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4226              		.loc 1 860 0
 4227 2474 01C0A0E3 		mov	ip, #1
 859:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4228              		.loc 1 859 0
 4229 2478 75A0C4E5 		strb	sl, [r4, #117]
 860:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4230              		.loc 1 860 0
 4231 247c BAC0C4E5 		strb	ip, [r4, #186]
 854:../uvc.c      **** 			 	 			if(Data0&0x80)
 4232              		.loc 1 854 0
 4233 2480 800010E3 		tst	r0, #128
 855:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4234              		.loc 1 855 0
 4235 2484 0170A013 		movne	r7, #1
 4236              	.LVL392:
 857:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4237              		.loc 1 857 0
 4238 2488 0B70A001 		moveq	r7, fp
 4239              	.LVL393:
 855:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4240              		.loc 1 855 0
 4241 248c 7470C415 		strneb	r7, [r4, #116]
 857:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4242              		.loc 1 857 0
 4243 2490 74B0C405 		streqb	fp, [r4, #116]
 858:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 4244              		.loc 1 858 0
 4245 2494 9D70C6E5 		strb	r7, [r6, #157]
 864:../uvc.c      **** 			 	 		 break;
 4246              		.loc 1 864 0
 4247 2498 E7FBFFEA 		b	.L175
 4248              	.LVL394:
 4249              	.L204:
1061:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4250              		.loc 1 1061 0
 4251 249c 0B00A0E1 		mov	r0, fp
 4252              	.LVL395:
 4253 24a0 0910A0E1 		mov	r1, r9
 4254 24a4 FEFFFFEB 		bl	SensorGetControl
1064:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4255              		.loc 1 1064 0
 4256 24a8 01C0A0E3 		mov	ip, #1
 4257 24ac 9BC0C4E5 		strb	ip, [r4, #155]
1062:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4258              		.loc 1 1062 0
 4259 24b0 1905C6E5 		strb	r0, [r6, #1305]
1063:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4260              		.loc 1 1063 0
 4261 24b4 1AA5D6E5 		ldrb	sl, [r6, #1306]	@ zero_extendqisi2
1061:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4262              		.loc 1 1061 0
 4263 24b8 0070A0E1 		mov	r7, r0
 4264              	.LVL396:
1063:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4265              		.loc 1 1063 0
 4266 24bc FFA00AE2 		and	sl, sl, #255
 4267              	.LVL397:
1061:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4268              		.loc 1 1061 0
 4269 24c0 7400C4E5 		strb	r0, [r4, #116]
1063:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4270              		.loc 1 1063 0
 4271 24c4 75A0C4E5 		strb	sl, [r4, #117]
1068:../uvc.c      **** 					 break;
 4272              		.loc 1 1068 0
 4273 24c8 DBFBFFEA 		b	.L175
 4274              	.LVL398:
 4275              	.L192:
 953:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4276              		.loc 1 953 0
 4277 24cc 0710A0E1 		mov	r1, r7
 4278 24d0 FEFFFFEB 		bl	SensorGetControl
 4279              	.LVL399:
 957:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4280              		.loc 1 957 0
 4281 24d4 0710A0E1 		mov	r1, r7
 954:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4282              		.loc 1 954 0
 4283 24d8 032000E2 		and	r2, r0, #3
 4284 24dc 7420C4E5 		strb	r2, [r4, #116]
 957:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4285              		.loc 1 957 0
 4286 24e0 0A00A0E1 		mov	r0, sl
 955:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4287              		.loc 1 955 0
 4288 24e4 ED24C6E5 		strb	r2, [r6, #1261]
 957:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4289              		.loc 1 957 0
 4290 24e8 FEFFFFEB 		bl	SensorGetControl
 959:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4291              		.loc 1 959 0
 4292 24ec 0130A0E3 		mov	r3, #1
 4293 24f0 AD30C4E5 		strb	r3, [r4, #173]
 957:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4294              		.loc 1 957 0
 4295 24f4 7600C4E5 		strb	r0, [r4, #118]
 958:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4296              		.loc 1 958 0
 4297 24f8 EE04C6E5 		strb	r0, [r6, #1262]
 4298 24fc 26FCFFEA 		b	.L193
 4299              	.LVL400:
 4300              	.L184:
 903:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4301              		.loc 1 903 0
 4302 2500 FEFFFFEB 		bl	SensorGetControl
 4303              	.LVL401:
 906:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4304              		.loc 1 906 0
 4305 2504 01C0A0E3 		mov	ip, #1
 4306 2508 AFC0C4E5 		strb	ip, [r4, #175]
 904:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4307              		.loc 1 904 0
 4308 250c D904C6E5 		strb	r0, [r6, #1241]
 905:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4309              		.loc 1 905 0
 4310 2510 DA14D6E5 		ldrb	r1, [r6, #1242]	@ zero_extendqisi2
 903:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4311              		.loc 1 903 0
 4312 2514 0070A0E1 		mov	r7, r0
 4313              	.LVL402:
 905:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4314              		.loc 1 905 0
 4315 2518 FFA001E2 		and	sl, r1, #255
 4316              	.LVL403:
 903:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4317              		.loc 1 903 0
 4318 251c 7400C4E5 		strb	r0, [r4, #116]
 905:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4319              		.loc 1 905 0
 4320 2520 75A0C4E5 		strb	sl, [r4, #117]
 910:../uvc.c      **** 			 		 break;
 4321              		.loc 1 910 0
 4322 2524 C4FBFFEA 		b	.L175
 4323              	.LVL404:
 4324              	.L176:
 835:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4325              		.loc 1 835 0
 4326 2528 0A00A0E1 		mov	r0, sl
 4327              	.LVL405:
 4328 252c 0910A0E1 		mov	r1, r9
 4329 2530 FEFFFFEB 		bl	SensorGetControl
 837:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4330              		.loc 1 837 0
 4331 2534 B104C6E5 		strb	r0, [r6, #1201]
 838:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4332              		.loc 1 838 0
 4333 2538 B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 835:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4334              		.loc 1 835 0
 4335 253c 0070A0E1 		mov	r7, r0
 4336              	.LVL406:
 838:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4337              		.loc 1 838 0
 4338 2540 FFA001E2 		and	sl, r1, #255
 836:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4339              		.loc 1 836 0
 4340 2544 7400C4E5 		strb	r0, [r4, #116]
 839:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4341              		.loc 1 839 0
 4342 2548 0100A0E3 		mov	r0, #1
 4343              	.LVL407:
 838:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4344              		.loc 1 838 0
 4345 254c 75A0C4E5 		strb	sl, [r4, #117]
 839:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4346              		.loc 1 839 0
 4347 2550 B900C4E5 		strb	r0, [r4, #185]
 4348              	.LVL408:
 843:../uvc.c      **** 			 	 		 break;
 4349              		.loc 1 843 0
 4350 2554 B8FBFFEA 		b	.L175
 4351              	.LVL409:
 4352              	.L206:
1078:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4353              		.loc 1 1078 0
 4354 2558 0A00A0E1 		mov	r0, sl
 4355              	.LVL410:
 4356 255c 0910A0E1 		mov	r1, r9
 4357 2560 FEFFFFEB 		bl	SensorGetControl
1080:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4358              		.loc 1 1080 0
 4359 2564 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
 4360 2568 75A0CBE5 		strb	sl, [fp, #117]
1078:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4361              		.loc 1 1078 0
 4362 256c 0070A0E1 		mov	r7, r0
 4363 2570 7400CBE5 		strb	r0, [fp, #116]
1079:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4364              		.loc 1 1079 0
 4365 2574 BD01C6E5 		strb	r0, [r6, #445]
1081:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4366              		.loc 1 1081 0
 4367 2578 0100A0E3 		mov	r0, #1
 4368 257c 9400C4E5 		strb	r0, [r4, #148]
 4369              	.LVL411:
1085:../uvc.c      **** 					 break;
 4370              		.loc 1 1085 0
 4371 2580 ADFBFFEA 		b	.L175
 4372              	.LVL412:
 4373              	.L214:
1133:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4374              		.loc 1 1133 0
 4375 2584 0A00A0E1 		mov	r0, sl
 4376              	.LVL413:
 4377 2588 0910A0E1 		mov	r1, r9
 4378 258c 14308DE5 		str	r3, [sp, #20]
 4379 2590 FEFFFFEB 		bl	SensorGetControl
1134:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4380              		.loc 1 1134 0
 4381 2594 84A084E0 		add	sl, r4, r4, asl #1
 4382 2598 8A6186E0 		add	r6, r6, sl, asl #3
1135:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4383              		.loc 1 1135 0
 4384 259c 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1136:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4385              		.loc 1 1136 0
 4386 25a0 0110A0E3 		mov	r1, #1
1135:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4387              		.loc 1 1135 0
 4388 25a4 75A0CBE5 		strb	sl, [fp, #117]
1133:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4389              		.loc 1 1133 0
 4390 25a8 7400CBE5 		strb	r0, [fp, #116]
1134:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4391              		.loc 1 1134 0
 4392 25ac 8D01C6E5 		strb	r0, [r6, #397]
1136:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4393              		.loc 1 1136 0
 4394 25b0 14C09DE5 		ldr	ip, [sp, #20]
1133:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4395              		.loc 1 1133 0
 4396 25b4 0070A0E1 		mov	r7, r0
 4397              	.LVL414:
1136:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4398              		.loc 1 1136 0
 4399 25b8 9410CCE5 		strb	r1, [ip, #148]
 4400              	.LVL415:
1142:../uvc.c      **** 					 break;
 4401              		.loc 1 1142 0
 4402 25bc 9EFBFFEA 		b	.L175
 4403              	.LVL416:
 4404              	.L208:
1092:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4405              		.loc 1 1092 0
 4406 25c0 0A00A0E1 		mov	r0, sl
 4407              	.LVL417:
 4408 25c4 0910A0E1 		mov	r1, r9
 4409 25c8 FEFFFFEB 		bl	SensorGetControl
1095:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4410              		.loc 1 1095 0
 4411 25cc 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1097:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4412              		.loc 1 1097 0
 4413 25d0 0110A0E3 		mov	r1, #1
1095:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4414              		.loc 1 1095 0
 4415 25d4 75A0C4E5 		strb	sl, [r4, #117]
1097:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4416              		.loc 1 1097 0
 4417 25d8 9D10C4E5 		strb	r1, [r4, #157]
1094:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4418              		.loc 1 1094 0
 4419 25dc 037000E2 		and	r7, r0, #3
 4420              	.LVL418:
1093:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4421              		.loc 1 1093 0
 4422 25e0 6502C6E5 		strb	r0, [r6, #613]
1094:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4423              		.loc 1 1094 0
 4424 25e4 7470C4E5 		strb	r7, [r4, #116]
1101:../uvc.c      **** 					 break;
 4425              		.loc 1 1101 0
 4426 25e8 93FBFFEA 		b	.L175
 4427              	.LVL419:
 4428              	.L210:
1114:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
 4429              		.loc 1 1114 0
 4430 25ec 0100A0E3 		mov	r0, #1
 4431              	.LVL420:
 4432 25f0 0910A0E1 		mov	r1, r9
 4433 25f4 FEFFFFEB 		bl	SensorGetControl
 4434              	.LVL421:
1119:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4435              		.loc 1 1119 0
 4436 25f8 0130A0E3 		mov	r3, #1
1118:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4437              		.loc 1 1118 0
 4438 25fc EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1119:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4439              		.loc 1 1119 0
 4440 2600 9830C4E5 		strb	r3, [r4, #152]
1118:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4441              		.loc 1 1118 0
 4442 2604 75A0C4E5 		strb	sl, [r4, #117]
1115:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4443              		.loc 1 1115 0
 4444 2608 A003A0E1 		mov	r0, r0, lsr #7
 4445              	.LVL422:
1116:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4446              		.loc 1 1116 0
 4447 260c 037080E0 		add	r7, r0, r3
 4448              	.LVL423:
 4449 2610 FF7007E2 		and	r7, r7, #255
 4450              	.LVL424:
 4451 2614 7470C4E5 		strb	r7, [r4, #116]
1117:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4452              		.loc 1 1117 0
 4453 2618 ED71C6E5 		strb	r7, [r6, #493]
1124:../uvc.c      **** 					 break;
 4454              		.loc 1 1124 0
 4455 261c 86FBFFEA 		b	.L175
 4456              	.LVL425:
 4457              	.L202:
1044:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4458              		.loc 1 1044 0
 4459 2620 0A00A0E1 		mov	r0, sl
 4460              	.LVL426:
 4461 2624 0910A0E1 		mov	r1, r9
 4462 2628 FEFFFFEB 		bl	SensorGetControl
1048:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4463              		.loc 1 1048 0
 4464 262c 0130A0E3 		mov	r3, #1
 4465 2630 9430C4E5 		strb	r3, [r4, #148]
1045:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4466              		.loc 1 1045 0
 4467 2634 037000E0 		and	r7, r0, r3
 4468              	.LVL427:
1046:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4469              		.loc 1 1046 0
 4470 2638 0575C6E5 		strb	r7, [r6, #1285]
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4471              		.loc 1 1047 0
 4472 263c 0605D6E5 		ldrb	r0, [r6, #1286]	@ zero_extendqisi2
1045:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4473              		.loc 1 1045 0
 4474 2640 7470C4E5 		strb	r7, [r4, #116]
1047:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4475              		.loc 1 1047 0
 4476 2644 FFA000E2 		and	sl, r0, #255
 4477              	.LVL428:
 4478 2648 75A0C4E5 		strb	sl, [r4, #117]
1052:../uvc.c      **** 					 break;
 4479              		.loc 1 1052 0
 4480 264c 7AFBFFEA 		b	.L175
 4481              	.LVL429:
 4482              	.L315:
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4483              		.loc 1 990 0
 4484 2650 0A00A0E1 		mov	r0, sl
 4485 2654 0910A0E1 		mov	r1, r9
 4486 2658 FEFFFFEB 		bl	SensorGetControl
 4487              	.LVL430:
 992:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4488              		.loc 1 992 0
 4489 265c 0170A0E3 		mov	r7, #1
 4490              	.LVL431:
 4491 2660 9570C4E5 		strb	r7, [r4, #149]
 991:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4492              		.loc 1 991 0
 4493 2664 A501C6E5 		strb	r0, [r6, #421]
 4494 2668 DCFBFFEA 		b	.L195
 4495              	.LVL432:
 4496              	.L182:
 878:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4497              		.loc 1 878 0
 4498 266c FEFFFFEB 		bl	SensorGetControl
 4499              	.LVL433:
 884:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4500              		.loc 1 884 0
 4501 2670 00181FE5 		ldr	r1, .L321+60
 879:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4502              		.loc 1 879 0
 4503 2674 C504C6E5 		strb	r0, [r6, #1221]
 882:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4504              		.loc 1 882 0
 4505 2678 C664D6E5 		ldrb	r6, [r6, #1222]	@ zero_extendqisi2
 878:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4506              		.loc 1 878 0
 4507 267c 0070A0E1 		mov	r7, r0
 4508              	.LVL434:
 880:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4509              		.loc 1 880 0
 4510 2680 700000E2 		and	r0, r0, #112
 4511              	.LVL435:
 4512 2684 20C2A0E1 		mov	ip, r0, lsr #4
 4513              	.LVL436:
 881:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4514              		.loc 1 881 0
 4515 2688 74C0C4E5 		strb	ip, [r4, #116]
 882:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4516              		.loc 1 882 0
 4517 268c 7560C4E5 		strb	r6, [r4, #117]
 884:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4518              		.loc 1 884 0
 4519 2690 0C20A0E1 		mov	r2, ip
 4520 2694 0C30A0E1 		mov	r3, ip
 4521 2698 0400A0E3 		mov	r0, #4
 4522 269c 00708DE5 		str	r7, [sp, #0]
 4523 26a0 14C08DE5 		str	ip, [sp, #20]
 4524 26a4 FEFFFFEB 		bl	CyU3PDebugPrint
 4525              	.LVL437:
 4526 26a8 7470D4E5 		ldrb	r7, [r4, #116]	@ zero_extendqisi2
 4527              	.LVL438:
 4528 26ac 14C09DE5 		ldr	ip, [sp, #20]
 4529 26b0 19FCFFEA 		b	.L183
 4530              	.LVL439:
 4531              	.L256:
1356:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4532              		.loc 1 1356 0
 4533 26b4 0A20A0E1 		mov	r2, sl
 4534 26b8 0730A0E1 		mov	r3, r7
 4535 26bc 80E0A0E3 		mov	lr, #128
 4536 26c0 00C0A0E3 		mov	ip, #0
 4537 26c4 1B10A0E3 		mov	r1, #27
 4538 26c8 54081FE5 		ldr	r0, .L321+64
 4539 26cc 00E08DE5 		str	lr, [sp, #0]
 4540 26d0 04C08DE5 		str	ip, [sp, #4]
 4541 26d4 FEFFFFEB 		bl	cmdSet
 4542              	.LVL440:
1358:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4543              		.loc 1 1358 0
 4544 26d8 0820A0E1 		mov	r2, r8
 4545 26dc 18809DE5 		ldr	r8, [sp, #24]
 4546              	.LVL441:
 4547 26e0 01A0A0E3 		mov	sl, #1
 4548              	.LVL442:
 4549 26e4 1B10A0E3 		mov	r1, #27
 4550 26e8 0730A0E1 		mov	r3, r7
 4551 26ec 78081FE5 		ldr	r0, .L321+64
 4552 26f0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4553 26f4 FEFFFFEB 		bl	cmdSet
 4554              	.LVL443:
 4555 26f8 87FCFFEA 		b	.L255
 4556              	.LVL444:
 4557              	.L314:
 915:../uvc.c      **** 						if(sendData >= 3){
 4558              		.loc 1 915 0
 4559 26fc 020057E3 		cmp	r7, #2
 4560 2700 0D00008A 		bhi	.L320
 4561              	.LVL445:
 4562              	.L187:
 920:../uvc.c      **** 						sendData += 4;
 4563              		.loc 1 920 0
 4564 2704 047087E2 		add	r7, r7, #4
 4565              	.LVL446:
 4566 2708 FF7007E2 		and	r7, r7, #255
 4567              	.LVL447:
 4568 270c 69FBFFEA 		b	.L306
 4569              	.LVL448:
 4570              	.L319:
1331:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4571              		.loc 1 1331 0
 4572 2710 0830A0E1 		mov	r3, r8
 4573 2714 1910A0E3 		mov	r1, #25
 4574 2718 0080A0E3 		mov	r8, #0
 4575              	.LVL449:
 4576 271c 0920A0E1 		mov	r2, r9
 4577 2720 AC081FE5 		ldr	r0, .L321+64
 4578 2724 00E08DE5 		str	lr, [sp, #0]
 4579 2728 04808DE5 		str	r8, [sp, #4]
 4580 272c FEFFFFEB 		bl	cmdSet
 4581              	.LVL450:
 4582 2730 14FEFFEA 		b	.L254
 4583              	.LVL451:
 4584              	.L305:
 4585 2734 B4081FE5 		ldr	r0, .L321+76
 4586 2738 29FBFFEA 		b	.L172
 4587              	.LVL452:
 4588              	.L320:
 916:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4589              		.loc 1 916 0
 4590 273c 0730A0E1 		mov	r3, r7
 4591 2740 0400A0E3 		mov	r0, #4
 4592              	.LVL453:
 4593 2744 CC181FE5 		ldr	r1, .L321+68
 4594 2748 FEFFFFEB 		bl	CyU3PDebugPrint
 4595              	.LVL454:
 918:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4596              		.loc 1 918 0
 4597 274c D0081FE5 		ldr	r0, .L321+72
 4598 2750 0020A0E3 		mov	r2, #0
 917:../uvc.c      **** 							sendData = 0; //set back to default
 4599              		.loc 1 917 0
 4600 2754 0270A0E1 		mov	r7, r2
 918:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4601              		.loc 1 918 0
 4602 2758 2D24C0E5 		strb	r2, [r0, #1069]
 4603 275c E8FFFFEA 		b	.L187
 4604              	.LVL455:
 4605              	.L285:
 4606 2760 E0081FE5 		ldr	r0, .L321+76
 4607              	.LVL456:
 771:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4608              		.loc 1 771 0
 4609 2764 0030A0E3 		mov	r3, #0
 4610 2768 16FBFFEA 		b	.L298
 4611              	.LVL457:
 4612              	.L287:
 4613 276c 0030A0E3 		mov	r3, #0
 4614 2770 0CFCFFEA 		b	.L299
 4615              		.cfi_endproc
 4616              	.LFE3:
 4618              		.align	2
 4619              		.global	CTControlHandle
 4621              	CTControlHandle:
 4622              	.LFB4:
1695:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4623              		.loc 1 1695 0
 4624              		.cfi_startproc
 4625              		@ args = 0, pretend = 0, frame = 64
 4626              		@ frame_needed = 0, uses_anonymous_args = 0
 4627              	.LVL458:
 4628 2774 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4629              	.LCFI18:
 4630              		.cfi_def_cfa_offset 36
1714:../uvc.c      ****     reqData = bRequest;
 4631              		.loc 1 1714 0
 4632 2778 64A99FE5 		ldr	sl, .L408
 4633              		.cfi_offset 14, -4
 4634              		.cfi_offset 11, -8
 4635              		.cfi_offset 10, -12
 4636              		.cfi_offset 9, -16
 4637              		.cfi_offset 8, -20
 4638              		.cfi_offset 7, -24
 4639              		.cfi_offset 6, -28
 4640              		.cfi_offset 5, -32
 4641              		.cfi_offset 4, -36
1706:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4642              		.loc 1 1706 0
 4643 277c 64899FE5 		ldr	r8, .L408+4
1714:../uvc.c      ****     reqData = bRequest;
 4644              		.loc 1 1714 0
 4645 2780 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1706:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4646              		.loc 1 1706 0
 4647 2784 8090A0E1 		mov	r9, r0, asl #1
 4648 2788 002089E0 		add	r2, r9, r0
 4649 278c 822188E0 		add	r2, r8, r2, asl #3
1716:../uvc.c      ****     switch (bRequest)
 4650              		.loc 1 1716 0
 4651 2790 830055E3 		cmp	r5, #131
1695:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4652              		.loc 1 1695 0
 4653 2794 5CD04DE2 		sub	sp, sp, #92
 4654              	.LCFI19:
 4655              		.cfi_def_cfa_offset 128
1695:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4656              		.loc 1 1695 0
 4657 2798 0060A0E1 		mov	r6, r0
1706:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4658              		.loc 1 1706 0
 4659 279c 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4660              	.LVL459:
1707:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4661              		.loc 1 1707 0
 4662 27a0 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4663              	.LVL460:
1709:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4664              		.loc 1 1709 0
 4665 27a4 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4666              	.LVL461:
1716:../uvc.c      ****     switch (bRequest)
 4667              		.loc 1 1716 0
 4668 27a8 7600000A 		beq	.L328
 4669 27ac 2100009A 		bls	.L403
 4670 27b0 850055E3 		cmp	r5, #133
 4671 27b4 5900000A 		beq	.L330
 4672 27b8 4E00003A 		bcc	.L329
 4673 27bc 860055E3 		cmp	r5, #134
 4674 27c0 8000000A 		beq	.L331
 4675 27c4 870055E3 		cmp	r5, #135
 4676 27c8 7600000A 		beq	.L404
 4677              	.L324:
1923:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4678              		.loc 1 1923 0
 4679 27cc 0000A0E3 		mov	r0, #0
 4680              	.LVL462:
 4681 27d0 0110A0E3 		mov	r1, #1
 4682 27d4 0020A0E1 		mov	r2, r0
 4683 27d8 FEFFFFEB 		bl	CyU3PUsbStall
 4684              	.LVL463:
 4685 27dc 08499FE5 		ldr	r4, .L408+8
1924:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4686              		.loc 1 1924 0
 4687 27e0 0620A0E1 		mov	r2, r6
 4688 27e4 0400A0E3 		mov	r0, #4
 4689 27e8 00199FE5 		ldr	r1, .L408+12
 4690 27ec 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4691 27f0 FEFFFFEB 		bl	CyU3PDebugPrint
1925:../uvc.c      **** 			  break;
 4692              		.loc 1 1925 0
 4693 27f4 FFC0A0E3 		mov	ip, #255
 4694 27f8 0C60A0E1 		mov	r6, ip
 4695 27fc 0C80A0E1 		mov	r8, ip
 4696              	.LVL464:
 4697              	.L334:
1929:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4698              		.loc 1 1929 0
 4699 2800 76E0D4E5 		ldrb	lr, [r4, #118]	@ zero_extendqisi2
 4700 2804 08C08DE5 		str	ip, [sp, #8]
 4701 2808 E4189FE5 		ldr	r1, .L408+16
 4702 280c FFC0A0E3 		mov	ip, #255
 4703 2810 0520A0E1 		mov	r2, r5
 4704 2814 0830A0E1 		mov	r3, r8
 4705 2818 0400A0E3 		mov	r0, #4
 4706 281c 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4707 2820 0CC08DE5 		str	ip, [sp, #12]
 4708 2824 10E08DE5 		str	lr, [sp, #16]
 4709 2828 14708DE5 		str	r7, [sp, #20]
 4710 282c FEFFFFEB 		bl	CyU3PDebugPrint
1930:../uvc.c      **** }
 4711              		.loc 1 1930 0
 4712 2830 5CD08DE2 		add	sp, sp, #92
 4713 2834 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4714              	.LVL465:
 4715              	.L403:
1716:../uvc.c      ****     switch (bRequest)
 4716              		.loc 1 1716 0
 4717 2838 810055E3 		cmp	r5, #129
 4718 283c 4200000A 		beq	.L326
 4719 2840 1100009A 		bls	.L405
1745:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4720              		.loc 1 1745 0
 4721 2844 A0489FE5 		ldr	r4, .L408+8
 4722 2848 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1746:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4723              		.loc 1 1746 0
 4724 284c 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1747:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4725              		.loc 1 1747 0
 4726 2850 0A0050E3 		cmp	r0, #10
1745:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4727              		.loc 1 1745 0
 4728 2854 7410C4E5 		strb	r1, [r4, #116]
1746:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4729              		.loc 1 1746 0
 4730 2858 7560C4E5 		strb	r6, [r4, #117]
1747:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4731              		.loc 1 1747 0
 4732 285c 2C00000A 		beq	.L402
 4733              	.LVL466:
 4734              	.L341:
1781:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4735              		.loc 1 1781 0
 4736 2860 00E0A0E3 		mov	lr, #0
 4737 2864 76E0C4E5 		strb	lr, [r4, #118]
 4738              	.L342:
1782:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4739              		.loc 1 1782 0
 4740 2868 0030A0E3 		mov	r3, #0
1783:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4741              		.loc 1 1783 0
 4742 286c 0700A0E1 		mov	r0, r7
 4743              	.LVL467:
 4744 2870 80189FE5 		ldr	r1, .L408+20
1785:../uvc.c      **** 			  break;
 4745              		.loc 1 1785 0
 4746 2874 FF60A0E3 		mov	r6, #255
1782:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4747              		.loc 1 1782 0
 4748 2878 7730C4E5 		strb	r3, [r4, #119]
1785:../uvc.c      **** 			  break;
 4749              		.loc 1 1785 0
 4750 287c 0680A0E1 		mov	r8, r6
1783:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4751              		.loc 1 1783 0
 4752 2880 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4753              	.LVL468:
 4754 2884 74C0D4E5 		ldrb	ip, [r4, #116]	@ zero_extendqisi2
1785:../uvc.c      **** 			  break;
 4755              		.loc 1 1785 0
 4756 2888 DCFFFFEA 		b	.L334
 4757              	.LVL469:
 4758              	.L405:
1716:../uvc.c      ****     switch (bRequest)
 4759              		.loc 1 1716 0
 4760 288c 010055E3 		cmp	r5, #1
 4761 2890 CDFFFF1A 		bne	.L324
1787:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4762              		.loc 1 1787 0
 4763 2894 50489FE5 		ldr	r4, .L408+8
 4764 2898 56208DE2 		add	r2, sp, #86
 4765 289c 2000A0E3 		mov	r0, #32
 4766              	.LVL470:
 4767 28a0 741084E2 		add	r1, r4, #116
 4768 28a4 2C308DE5 		str	r3, [sp, #44]
 4769 28a8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4770              	.LVL471:
1789:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4771              		.loc 1 1789 0
 4772 28ac 7400D4E5 		ldrb	r0, [r4, #116]	@ zero_extendqisi2
1790:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4773              		.loc 1 1790 0
 4774 28b0 75C0D4E5 		ldrb	ip, [r4, #117]	@ zero_extendqisi2
1793:../uvc.c      **** 			  switch(CtrlID)
 4775              		.loc 1 1793 0
 4776 28b4 012046E2 		sub	r2, r6, #1
1789:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4777              		.loc 1 1789 0
 4778 28b8 30008DE5 		str	r0, [sp, #48]
 4779              	.LVL472:
1790:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4780              		.loc 1 1790 0
 4781 28bc 34C08DE5 		str	ip, [sp, #52]
 4782              	.LVL473:
1793:../uvc.c      **** 			  switch(CtrlID)
 4783              		.loc 1 1793 0
 4784 28c0 2C309DE5 		ldr	r3, [sp, #44]
 4785 28c4 090052E3 		cmp	r2, #9
 4786 28c8 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4787 28cc 550100EA 		b	.L343
 4788              	.L348:
 4789 28d0 E42D0000 		.word	.L344
 4790 28d4 282E0000 		.word	.L343
 4791 28d8 F42A0000 		.word	.L345
 4792 28dc 282E0000 		.word	.L343
 4793 28e0 282E0000 		.word	.L343
 4794 28e4 282E0000 		.word	.L343
 4795 28e8 702A0000 		.word	.L346
 4796 28ec 282E0000 		.word	.L343
 4797 28f0 282E0000 		.word	.L343
 4798 28f4 F4290000 		.word	.L347
 4799              	.LVL474:
 4800              	.L329:
1763:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4801              		.loc 1 1763 0
 4802 28f8 EC479FE5 		ldr	r4, .L408+8
 4803 28fc 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1764:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4804              		.loc 1 1764 0
 4805 2900 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1765:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4806              		.loc 1 1765 0
 4807 2904 0A0050E3 		cmp	r0, #10
1763:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4808              		.loc 1 1763 0
 4809 2908 7480C4E5 		strb	r8, [r4, #116]
1764:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4810              		.loc 1 1764 0
 4811 290c 7520C4E5 		strb	r2, [r4, #117]
1765:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4812              		.loc 1 1765 0
 4813 2910 D2FFFF1A 		bne	.L341
 4814              	.LVL475:
 4815              	.L402:
1780:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4816              		.loc 1 1780 0 discriminator 1
 4817 2914 0110A0E3 		mov	r1, #1
 4818 2918 7610C4E5 		strb	r1, [r4, #118]
 4819 291c D1FFFFEA 		b	.L342
 4820              	.LVL476:
 4821              	.L330:
1720:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4822              		.loc 1 1720 0
 4823 2920 C4479FE5 		ldr	r4, .L408+8
1721:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4824              		.loc 1 1721 0
 4825 2924 0030A0E3 		mov	r3, #0
 4826              	.LVL477:
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4827              		.loc 1 1722 0
 4828 2928 0200A0E3 		mov	r0, #2
 4829              	.LVL478:
 4830 292c 741084E2 		add	r1, r4, #116
1724:../uvc.c      **** 			  break;
 4831              		.loc 1 1724 0
 4832 2930 FF60A0E3 		mov	r6, #255
1720:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4833              		.loc 1 1720 0
 4834 2934 7470C4E5 		strb	r7, [r4, #116]
1721:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4835              		.loc 1 1721 0
 4836 2938 7530C4E5 		strb	r3, [r4, #117]
1724:../uvc.c      **** 			  break;
 4837              		.loc 1 1724 0
 4838 293c 0680A0E1 		mov	r8, r6
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4839              		.loc 1 1722 0
 4840 2940 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4841              	.LVL479:
 4842 2944 74C0D4E5 		ldrb	ip, [r4, #116]	@ zero_extendqisi2
1724:../uvc.c      **** 			  break;
 4843              		.loc 1 1724 0
 4844 2948 ACFFFFEA 		b	.L334
 4845              	.LVL480:
 4846              	.L326:
1730:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4847              		.loc 1 1730 0
 4848 294c 98479FE5 		ldr	r4, .L408+8
 4849 2950 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1731:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4850              		.loc 1 1731 0
 4851 2954 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1732:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4852              		.loc 1 1732 0
 4853 2958 0080A0E3 		mov	r8, #0
1738:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4854              		.loc 1 1738 0
 4855 295c 0700A0E1 		mov	r0, r7
 4856              	.LVL481:
 4857 2960 741084E2 		add	r1, r4, #116
1743:../uvc.c      **** 			  break;
 4858              		.loc 1 1743 0
 4859 2964 FF60A0E3 		mov	r6, #255
1731:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4860              		.loc 1 1731 0
 4861 2968 75C0C4E5 		strb	ip, [r4, #117]
1732:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4862              		.loc 1 1732 0
 4863 296c 7680C4E5 		strb	r8, [r4, #118]
1733:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4864              		.loc 1 1733 0
 4865 2970 7780C4E5 		strb	r8, [r4, #119]
 4866              	.LVL482:
1730:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4867              		.loc 1 1730 0
 4868 2974 74A0C4E5 		strb	sl, [r4, #116]
1743:../uvc.c      **** 			  break;
 4869              		.loc 1 1743 0
 4870 2978 0680A0E1 		mov	r8, r6
1738:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4871              		.loc 1 1738 0
 4872 297c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4873              	.LVL483:
 4874 2980 0AC0A0E1 		mov	ip, sl
1743:../uvc.c      **** 			  break;
 4875              		.loc 1 1743 0
 4876 2984 9DFFFFEA 		b	.L334
 4877              	.LVL484:
 4878              	.L328:
1754:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4879              		.loc 1 1754 0
 4880 2988 5C479FE5 		ldr	r4, .L408+8
 4881 298c 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4882              	.LVL485:
1755:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4883              		.loc 1 1755 0
 4884 2990 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1756:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4885              		.loc 1 1756 0
 4886 2994 0A0050E3 		cmp	r0, #10
1754:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4887              		.loc 1 1754 0
 4888 2998 7430C4E5 		strb	r3, [r4, #116]
1755:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4889              		.loc 1 1755 0
 4890 299c 75E0C4E5 		strb	lr, [r4, #117]
1756:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4891              		.loc 1 1756 0
 4892 29a0 AEFFFF1A 		bne	.L341
 4893 29a4 DAFFFFEA 		b	.L402
 4894              	.LVL486:
 4895              	.L404:
1778:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4896              		.loc 1 1778 0
 4897 29a8 3C479FE5 		ldr	r4, .L408+8
 4898 29ac 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1779:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4899              		.loc 1 1779 0
 4900 29b0 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1780:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4901              		.loc 1 1780 0
 4902 29b4 0A0050E3 		cmp	r0, #10
1778:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4903              		.loc 1 1778 0
 4904 29b8 7460C4E5 		strb	r6, [r4, #116]
1779:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4905              		.loc 1 1779 0
 4906 29bc 75C0C4E5 		strb	ip, [r4, #117]
1780:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4907              		.loc 1 1780 0
 4908 29c0 A6FFFF1A 		bne	.L341
 4909 29c4 D2FFFFEA 		b	.L402
 4910              	.L331:
1772:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4911              		.loc 1 1772 0
 4912 29c8 1C479FE5 		ldr	r4, .L408+8
 4913 29cc 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4914              	.LVL487:
 4915 29d0 0410A0E1 		mov	r1, r4
 4916 29d4 7400E1E5 		strb	r0, [r1, #116]!
1776:../uvc.c      **** 			  break;
 4917              		.loc 1 1776 0
 4918 29d8 FF60A0E3 		mov	r6, #255
1773:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4919              		.loc 1 1773 0
 4920 29dc 0100A0E3 		mov	r0, #1
 4921 29e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4922              	.LVL488:
1776:../uvc.c      **** 			  break;
 4923              		.loc 1 1776 0
 4924 29e4 0680A0E1 		mov	r8, r6
1773:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4925              		.loc 1 1773 0
 4926 29e8 74C0D4E5 		ldrb	ip, [r4, #116]	@ zero_extendqisi2
1776:../uvc.c      **** 			  break;
 4927              		.loc 1 1776 0
 4928 29ec 0170A0E3 		mov	r7, #1
 4929 29f0 82FFFFEA 		b	.L334
 4930              	.LVL489:
 4931              	.L347:
1902:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4932              		.loc 1 1902 0
 4933 29f4 00679FE5 		ldr	r6, .L408+24
 4934 29f8 0010E0E3 		mvn	r1, #0
 4935 29fc 1C0096E5 		ldr	r0, [r6, #28]
 4936 2a00 2C308DE5 		str	r3, [sp, #44]
 4937 2a04 FEFFFFEB 		bl	_txe_mutex_get
1903:../uvc.c      **** 					  if(getData == 1)
 4938              		.loc 1 1903 0
 4939 2a08 30E09DE5 		ldr	lr, [sp, #48]
 4940 2a0c 2C309DE5 		ldr	r3, [sp, #44]
 4941 2a10 01005EE3 		cmp	lr, #1
 4942 2a14 AA01000A 		beq	.L406
1905:../uvc.c      **** 					  else if(getData == 0xff)
 4943              		.loc 1 1905 0
 4944 2a18 FF005EE3 		cmp	lr, #255
 4945 2a1c 9F01000A 		beq	.L407
1908:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4946              		.loc 1 1908 0
 4947 2a20 0080A0E3 		mov	r8, #0
 4948 2a24 0600A0E1 		mov	r0, r6
 4949 2a28 2310A0E3 		mov	r1, #35
 4950 2a2c 0B20A0E1 		mov	r2, fp
 4951 2a30 00808DE5 		str	r8, [sp, #0]
 4952 2a34 04808DE5 		str	r8, [sp, #4]
 4953 2a38 FEFFFFEB 		bl	cmdSet
 4954              	.L400:
1911:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4955              		.loc 1 1911 0
 4956 2a3c 1C0096E5 		ldr	r0, [r6, #28]
 4957 2a40 FEFFFFEB 		bl	_txe_mutex_put
1913:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4958              		.loc 1 1913 0
 4959 2a44 30809DE5 		ldr	r8, [sp, #48]
 4960 2a48 34609DE5 		ldr	r6, [sp, #52]
 4961 2a4c 76C0D4E5 		ldrb	ip, [r4, #118]	@ zero_extendqisi2
 4962 2a50 0400A0E3 		mov	r0, #4
 4963 2a54 A4169FE5 		ldr	r1, .L408+28
 4964 2a58 0820A0E1 		mov	r2, r8
 4965 2a5c 0630A0E1 		mov	r3, r6
 4966 2a60 00C08DE5 		str	ip, [sp, #0]
 4967 2a64 FEFFFFEB 		bl	CyU3PDebugPrint
1914:../uvc.c      **** 					  break;
 4968              		.loc 1 1914 0
 4969 2a68 FFC0A0E3 		mov	ip, #255
 4970 2a6c 63FFFFEA 		b	.L334
 4971              	.LVL490:
 4972              	.L346:
1879:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4973              		.loc 1 1879 0
 4974 2a70 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4975 2a74 010058E3 		cmp	r8, #1
 4976 2a78 08005813 		cmpne	r8, #8
 4977 2a7c 0000A013 		movne	r0, #0
 4978 2a80 0100A003 		moveq	r0, #1
 4979 2a84 8101001A 		bne	.L397
 4980              	.LVL491:
1882:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4981              		.loc 1 1882 0
 4982 2a88 6C869FE5 		ldr	r8, .L408+24
 4983 2a8c 0010E0E3 		mvn	r1, #0
 4984 2a90 1C0098E5 		ldr	r0, [r8, #28]
 4985 2a94 2C308DE5 		str	r3, [sp, #44]
 4986 2a98 FEFFFFEB 		bl	_txe_mutex_get
1883:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4987              		.loc 1 1883 0
 4988 2a9c 30A09DE5 		ldr	sl, [sp, #48]
 4989 2aa0 2210A0E3 		mov	r1, #34
 4990 2aa4 0B20A0E1 		mov	r2, fp
 4991 2aa8 2C309DE5 		ldr	r3, [sp, #44]
 4992 2aac 00C0A0E3 		mov	ip, #0
 4993 2ab0 0800A0E1 		mov	r0, r8
 4994 2ab4 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4995 2ab8 FEFFFFEB 		bl	cmdSet
1884:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4996              		.loc 1 1884 0
 4997 2abc 1C0098E5 		ldr	r0, [r8, #28]
 4998 2ac0 FEFFFFEB 		bl	_txe_mutex_put
1887:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4999              		.loc 1 1887 0
 5000 2ac4 1C069FE5 		ldr	r0, .L408+4
1888:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5001              		.loc 1 1888 0
 5002 2ac8 34209DE5 		ldr	r2, [sp, #52]
1887:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5003              		.loc 1 1887 0
 5004 2acc 061089E0 		add	r1, r9, r6
 5005 2ad0 813180E0 		add	r3, r0, r1, asl #3
1889:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5006              		.loc 1 1889 0
 5007 2ad4 0160A0E3 		mov	r6, #1
1887:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5008              		.loc 1 1887 0
 5009 2ad8 2DA5C3E5 		strb	sl, [r3, #1325]
1888:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5010              		.loc 1 1888 0
 5011 2adc 2E25C3E5 		strb	r2, [r3, #1326]
1889:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5012              		.loc 1 1889 0
 5013 2ae0 3065C3E5 		strb	r6, [r3, #1328]
 5014              	.LVL492:
 5015              	.L398:
1891:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5016              		.loc 1 1891 0
 5017 2ae4 7480D4E5 		ldrb	r8, [r4, #116]	@ zero_extendqisi2
 5018 2ae8 7560D4E5 		ldrb	r6, [r4, #117]	@ zero_extendqisi2
1896:../uvc.c      **** 					  break;
 5019              		.loc 1 1896 0
 5020 2aec FFC0A0E3 		mov	ip, #255
 5021 2af0 42FFFFEA 		b	.L334
 5022              	.LVL493:
 5023              	.L345:
1845:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5024              		.loc 1 1845 0
 5025 2af4 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 5026 2af8 010050E3 		cmp	r0, #1
 5027 2afc 04005013 		cmpne	r0, #4
 5028 2b00 5D01001A 		bne	.L355
1844:../uvc.c      **** 					  value = (value << 8)|Data0;
 5029              		.loc 1 1844 0
 5030 2b04 30109DE5 		ldr	r1, [sp, #48]
 5031 2b08 34E09DE5 		ldr	lr, [sp, #52]
 5032 2b0c 0E2481E1 		orr	r2, r1, lr, asl #8
1846:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5033              		.loc 1 1846 0
 5034 2b10 F90052E3 		cmp	r2, #249
 5035 2b14 5801008A 		bhi	.L355
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5036              		.loc 1 1851 0
 5037 2b18 C8A042E2 		sub	sl, r2, #200
 5038 2b1c 0AC8A0E1 		mov	ip, sl, asl #16
 5039 2b20 3CC08DE5 		str	ip, [sp, #60]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5040              		.loc 1 1853 0
 5041 2b24 27A062E2 		rsb	sl, r2, #39
 5042 2b28 38A08DE5 		str	sl, [sp, #56]
 5043 2b2c 3CA09DE5 		ldr	sl, [sp, #60]
 5044 2b30 C81062E2 		rsb	r1, r2, #200
 5045 2b34 C80052E3 		cmp	r2, #200
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5046              		.loc 1 1851 0
 5047 2b38 640042E2 		sub	r0, r2, #100
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5048              		.loc 1 1853 0
 5049 2b3c 0118A0E1 		mov	r1, r1, asl #16
 5050 2b40 64E062E2 		rsb	lr, r2, #100
 5051 2b44 2A18A081 		movhi	r1, sl, lsr #16
 5052 2b48 2118A091 		movls	r1, r1, lsr #16
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5053              		.loc 1 1851 0
 5054 2b4c 00C8A0E1 		mov	ip, r0, asl #16
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5055              		.loc 1 1853 0
 5056 2b50 640052E3 		cmp	r2, #100
 5057 2b54 0E08A0E1 		mov	r0, lr, asl #16
 5058 2b58 2C08A081 		movhi	r0, ip, lsr #16
 5059 2b5c 38C09DE5 		ldr	ip, [sp, #56]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5060              		.loc 1 1851 0
 5061 2b60 14A042E2 		sub	sl, r2, #20
 5062 2b64 38A08DE5 		str	sl, [sp, #56]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5063              		.loc 1 1853 0
 5064 2b68 2008A091 		movls	r0, r0, lsr #16
 5065 2b6c 14A062E2 		rsb	sl, r2, #20
 5066 2b70 3CA08DE5 		str	sl, [sp, #60]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5067              		.loc 1 1851 0
 5068 2b74 27E042E2 		sub	lr, r2, #39
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5069              		.loc 1 1853 0
 5070 2b78 000051E1 		cmp	r1, r0
 5071 2b7c 01A0A031 		movcc	sl, r1
 5072 2b80 00A0A021 		movcs	sl, r0
 5073 2b84 0CC8A0E1 		mov	ip, ip, asl #16
 5074 2b88 270052E3 		cmp	r2, #39
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5075              		.loc 1 1851 0
 5076 2b8c 0EE8A0E1 		mov	lr, lr, asl #16
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5077              		.loc 1 1853 0
 5078 2b90 2CE8A091 		movls	lr, ip, lsr #16
 5079 2b94 68C59FE5 		ldr	ip, .L408+32
 5080 2b98 20A08DE5 		str	sl, [sp, #32]
 5081 2b9c 01A06CE0 		rsb	sl, ip, r1
 5082 2ba0 2EE8A081 		movhi	lr, lr, lsr #16
 5083 2ba4 00C07AE2 		rsbs	ip, sl, #0
 5084 2ba8 0AC0ACE0 		adc	ip, ip, sl
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5085              		.loc 1 1851 0
 5086 2bac 38A09DE5 		ldr	sl, [sp, #56]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5087              		.loc 1 1853 0
 5088 2bb0 44C08DE5 		str	ip, [sp, #68]
 5089              	.LVL494:
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5090              		.loc 1 1851 0
 5091 2bb4 0AC8A0E1 		mov	ip, sl, asl #16
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5092              		.loc 1 1853 0
 5093 2bb8 3CA09DE5 		ldr	sl, [sp, #60]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5094              		.loc 1 1851 0
 5095 2bbc 4CC08DE5 		str	ip, [sp, #76]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5096              		.loc 1 1853 0
 5097 2bc0 0AC8A0E1 		mov	ip, sl, asl #16
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5098              		.loc 1 1851 0
 5099 2bc4 0AA042E2 		sub	sl, r2, #10
 5100 2bc8 48A08DE5 		str	sl, [sp, #72]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5101              		.loc 1 1853 0
 5102 2bcc 20A09DE5 		ldr	sl, [sp, #32]
 5103 2bd0 3CC08DE5 		str	ip, [sp, #60]
 5104 2bd4 0A005EE1 		cmp	lr, sl
 5105 2bd8 0EA0A031 		movcc	sl, lr
 5106 2bdc 0AC062E2 		rsb	ip, r2, #10
 5107 2be0 40C08DE5 		str	ip, [sp, #64]
 5108 2be4 38A08DE5 		str	sl, [sp, #56]
 5109 2be8 3CC09DE5 		ldr	ip, [sp, #60]
 5110 2bec 4CA09DE5 		ldr	sl, [sp, #76]
 5111 2bf0 140052E3 		cmp	r2, #20
 5112 2bf4 2CA8A091 		movls	sl, ip, lsr #16
 5113 2bf8 2AA8A081 		movhi	sl, sl, lsr #16
 5114 2bfc 44C09DE5 		ldr	ip, [sp, #68]
 5115 2c00 010050E1 		cmp	r0, r1
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5116              		.loc 1 1851 0
 5117 2c04 48109DE5 		ldr	r1, [sp, #72]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5118              		.loc 1 1853 0
 5119 2c08 01C0A033 		movcc	ip, #1
 5120 2c0c 3CA08DE5 		str	sl, [sp, #60]
 5121 2c10 24C08DE5 		str	ip, [sp, #36]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5122              		.loc 1 1851 0
 5123 2c14 01A8A0E1 		mov	sl, r1, asl #16
 5124 2c18 05C042E2 		sub	ip, r2, #5
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5125              		.loc 1 1853 0
 5126 2c1c 051062E2 		rsb	r1, r2, #5
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5127              		.loc 1 1851 0
 5128 2c20 48A08DE5 		str	sl, [sp, #72]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5129              		.loc 1 1853 0
 5130 2c24 40009DE5 		ldr	r0, [sp, #64]
 5131 2c28 38A09DE5 		ldr	sl, [sp, #56]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5132              		.loc 1 1851 0
 5133 2c2c 40C08DE5 		str	ip, [sp, #64]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5134              		.loc 1 1853 0
 5135 2c30 3CC09DE5 		ldr	ip, [sp, #60]
 5136 2c34 4C108DE5 		str	r1, [sp, #76]
 5137 2c38 48109DE5 		ldr	r1, [sp, #72]
 5138 2c3c 0008A0E1 		mov	r0, r0, asl #16
 5139 2c40 0A005CE1 		cmp	ip, sl
 5140 2c44 0AC0A021 		movcs	ip, sl
 5141 2c48 0A0052E3 		cmp	r2, #10
 5142 2c4c 20A09DE5 		ldr	sl, [sp, #32]
 5143 2c50 2108A081 		movhi	r0, r1, lsr #16
 5144 2c54 2008A091 		movls	r0, r0, lsr #16
 5145 2c58 48008DE5 		str	r0, [sp, #72]
 5146 2c5c 24009DE5 		ldr	r0, [sp, #36]
 5147 2c60 0A005EE1 		cmp	lr, sl
 5148 2c64 0200A033 		movcc	r0, #2
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5149              		.loc 1 1851 0
 5150 2c68 02E042E2 		sub	lr, r2, #2
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5151              		.loc 1 1853 0
 5152 2c6c 44C08DE5 		str	ip, [sp, #68]
 5153 2c70 24008DE5 		str	r0, [sp, #36]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5154              		.loc 1 1851 0
 5155 2c74 40C09DE5 		ldr	ip, [sp, #64]
 5156 2c78 1CE08DE5 		str	lr, [sp, #28]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5157              		.loc 1 1853 0
 5158 2c7c 44009DE5 		ldr	r0, [sp, #68]
 5159 2c80 48E09DE5 		ldr	lr, [sp, #72]
 5160 2c84 4C109DE5 		ldr	r1, [sp, #76]
 5161 2c88 02A062E2 		rsb	sl, r2, #2
 5162 2c8c 00005EE1 		cmp	lr, r0
 5163 2c90 00E0A021 		movcs	lr, r0
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5164              		.loc 1 1851 0
 5165 2c94 0CC8A0E1 		mov	ip, ip, asl #16
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5166              		.loc 1 1853 0
 5167 2c98 050052E3 		cmp	r2, #5
 5168 2c9c 40A08DE5 		str	sl, [sp, #64]
 5169 2ca0 0118A0E1 		mov	r1, r1, asl #16
 5170 2ca4 3CA09DE5 		ldr	sl, [sp, #60]
 5171 2ca8 2C18A081 		movhi	r1, ip, lsr #16
 5172 2cac 38C09DE5 		ldr	ip, [sp, #56]
 5173 2cb0 4CE08DE5 		str	lr, [sp, #76]
 5174 2cb4 24009DE5 		ldr	r0, [sp, #36]
 5175 2cb8 40E09DE5 		ldr	lr, [sp, #64]
 5176 2cbc 2118A091 		movls	r1, r1, lsr #16
 5177 2cc0 0C005AE1 		cmp	sl, ip
 5178 2cc4 20108DE5 		str	r1, [sp, #32]
 5179 2cc8 0300A033 		movcc	r0, #3
 5180 2ccc 38008DE5 		str	r0, [sp, #56]
 5181 2cd0 4CA09DE5 		ldr	sl, [sp, #76]
 5182 2cd4 0E08A0E1 		mov	r0, lr, asl #16
 5183 2cd8 20E09DE5 		ldr	lr, [sp, #32]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5184              		.loc 1 1851 0
 5185 2cdc 1C109DE5 		ldr	r1, [sp, #28]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5186              		.loc 1 1853 0
 5187 2ce0 0A005EE1 		cmp	lr, sl
 5188 2ce4 0AE0A021 		movcs	lr, sl
 5189 2ce8 44C09DE5 		ldr	ip, [sp, #68]
 5190 2cec 48A09DE5 		ldr	sl, [sp, #72]
 5191 2cf0 020052E3 		cmp	r2, #2
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5192              		.loc 1 1851 0
 5193 2cf4 0118A0E1 		mov	r1, r1, asl #16
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5194              		.loc 1 1853 0
 5195 2cf8 2018A091 		movls	r1, r0, lsr #16
 5196 2cfc 38009DE5 		ldr	r0, [sp, #56]
 5197 2d00 2118A081 		movhi	r1, r1, lsr #16
 5198 2d04 0C005AE1 		cmp	sl, ip
 5199 2d08 0400A033 		movcc	r0, #4
 5200 2d0c 40008DE5 		str	r0, [sp, #64]
1851:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5201              		.loc 1 1851 0
 5202 2d10 010042E2 		sub	r0, r2, #1
 5203 2d14 38008DE5 		str	r0, [sp, #56]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5204              		.loc 1 1853 0
 5205 2d18 4CA09DE5 		ldr	sl, [sp, #76]
 5206 2d1c 20009DE5 		ldr	r0, [sp, #32]
 5207 2d20 01C062E2 		rsb	ip, r2, #1
 5208 2d24 3CC08DE5 		str	ip, [sp, #60]
 5209 2d28 0A0050E1 		cmp	r0, sl
1860:../uvc.c      **** 						  shutter = shutter+index;
 5210              		.loc 1 1860 0
 5211 2d2c 38A09DE5 		ldr	sl, [sp, #56]
 5212 2d30 3C009DE5 		ldr	r0, [sp, #60]
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5213              		.loc 1 1853 0
 5214 2d34 40C09DE5 		ldr	ip, [sp, #64]
 5215 2d38 05C0A033 		movcc	ip, #5
1860:../uvc.c      **** 						  shutter = shutter+index;
 5216              		.loc 1 1860 0
 5217 2d3c 010052E3 		cmp	r2, #1
 5218 2d40 0028A091 		movls	r2, r0, asl #16
 5219 2d44 0A28A081 		movhi	r2, sl, asl #16
 5220 2d48 0E0051E1 		cmp	r1, lr
 5221 2d4c 01A0A031 		movcc	sl, r1
 5222 2d50 0EA0A021 		movcs	sl, lr
1853:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5223              		.loc 1 1853 0
 5224 2d54 0E0051E1 		cmp	r1, lr
 5225 2d58 0C10A021 		movcs	r1, ip
 5226 2d5c 0610A033 		movcc	r1, #6
1860:../uvc.c      **** 						  shutter = shutter+index;
 5227              		.loc 1 1860 0
 5228 2d60 22085AE1 		cmp	sl, r2, lsr #16
1863:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5229              		.loc 1 1863 0
 5230 2d64 90A39FE5 		ldr	sl, .L408+24
1860:../uvc.c      **** 						  shutter = shutter+index;
 5231              		.loc 1 1860 0
 5232 2d68 0120A091 		movls	r2, r1
 5233 2d6c 0720A083 		movhi	r2, #7
 5234 2d70 012082E2 		add	r2, r2, #1
 5235 2d74 FFE002E2 		and	lr, r2, #255
1863:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5236              		.loc 1 1863 0
 5237 2d78 0010E0E3 		mvn	r1, #0
 5238 2d7c 1C009AE5 		ldr	r0, [sl, #28]
1860:../uvc.c      **** 						  shutter = shutter+index;
 5239              		.loc 1 1860 0
 5240 2d80 38E08DE5 		str	lr, [sp, #56]
 5241              	.LVL495:
1863:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5242              		.loc 1 1863 0
 5243 2d84 2C308DE5 		str	r3, [sp, #44]
 5244 2d88 FEFFFFEB 		bl	_txe_mutex_get
1864:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5245              		.loc 1 1864 0
 5246 2d8c 38C09DE5 		ldr	ip, [sp, #56]
 5247 2d90 0310A0E3 		mov	r1, #3
 5248 2d94 0B20A0E1 		mov	r2, fp
 5249 2d98 2C309DE5 		ldr	r3, [sp, #44]
 5250 2d9c 00C08DE5 		str	ip, [sp, #0]
 5251 2da0 0A00A0E1 		mov	r0, sl
 5252 2da4 00C0A0E3 		mov	ip, #0
 5253 2da8 04C08DE5 		str	ip, [sp, #4]
 5254 2dac FEFFFFEB 		bl	cmdSet
1865:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5255              		.loc 1 1865 0
 5256 2db0 1C009AE5 		ldr	r0, [sl, #28]
 5257 2db4 FEFFFFEB 		bl	_txe_mutex_put
1868:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5258              		.loc 1 1868 0
 5259 2db8 30009DE5 		ldr	r0, [sp, #48]
1869:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5260              		.loc 1 1869 0
 5261 2dbc 34C09DE5 		ldr	ip, [sp, #52]
1871:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5262              		.loc 1 1871 0
 5263 2dc0 38309DE5 		ldr	r3, [sp, #56]
1868:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5264              		.loc 1 1868 0
 5265 2dc4 061089E0 		add	r1, r9, r6
 5266 2dc8 816188E0 		add	r6, r8, r1, asl #3
1870:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5267              		.loc 1 1870 0
 5268 2dcc 0120A0E3 		mov	r2, #1
1868:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5269              		.loc 1 1868 0
 5270 2dd0 2D05C6E5 		strb	r0, [r6, #1325]
1869:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5271              		.loc 1 1869 0
 5272 2dd4 2EC5C6E5 		strb	ip, [r6, #1326]
1870:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5273              		.loc 1 1870 0
 5274 2dd8 3025C6E5 		strb	r2, [r6, #1328]
1871:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5275              		.loc 1 1871 0
 5276 2ddc 0D33C8E5 		strb	r3, [r8, #781]
 5277 2de0 3FFFFFEA 		b	.L398
 5278              	.LVL496:
 5279              	.L344:
1798:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5280              		.loc 1 1798 0
 5281 2de4 062089E0 		add	r2, r9, r6
 5282 2de8 826188E0 		add	r6, r8, r2, asl #3
1799:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5283              		.loc 1 1799 0
 5284 2dec 0110A0E3 		mov	r1, #1
1802:../uvc.c      **** 		  		    switch (getData){
 5285              		.loc 1 1802 0
 5286 2df0 01E040E2 		sub	lr, r0, #1
1798:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5287              		.loc 1 1798 0
 5288 2df4 2D05C6E5 		strb	r0, [r6, #1325]
1799:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5289              		.loc 1 1799 0
 5290 2df8 3015C6E5 		strb	r1, [r6, #1328]
 5291              	.LVL497:
1802:../uvc.c      **** 		  		    switch (getData){
 5292              		.loc 1 1802 0
 5293 2dfc 07005EE3 		cmp	lr, #7
 5294 2e00 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5295 2e04 980000EA 		b	.L349
 5296              	.L354:
 5297 2e08 00300000 		.word	.L350
 5298 2e0c 642F0000 		.word	.L351
 5299 2e10 6C300000 		.word	.L349
 5300 2e14 FC2E0000 		.word	.L352
 5301 2e18 6C300000 		.word	.L349
 5302 2e1c 6C300000 		.word	.L349
 5303 2e20 6C300000 		.word	.L349
 5304 2e24 5C2E0000 		.word	.L353
 5305              	.LVL498:
 5306              	.L343:
1918:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5307              		.loc 1 1918 0
 5308 2e28 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1917:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5309              		.loc 1 1917 0
 5310 2e2c 30A09DE5 		ldr	sl, [sp, #48]
 5311 2e30 069089E0 		add	r9, r9, r6
 5312 2e34 89E188E0 		add	lr, r8, r9, asl #3
1918:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5313              		.loc 1 1918 0
 5314 2e38 0620A0E1 		mov	r2, r6
 5315 2e3c 0400A0E3 		mov	r0, #4
 5316 2e40 C0129FE5 		ldr	r1, .L408+36
1917:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5317              		.loc 1 1917 0
 5318 2e44 2DA5CEE5 		strb	sl, [lr, #1325]
1918:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5319              		.loc 1 1918 0
 5320 2e48 FEFFFFEB 		bl	CyU3PDebugPrint
1919:../uvc.c      **** 			  		 break;
 5321              		.loc 1 1919 0
 5322 2e4c FFC0A0E3 		mov	ip, #255
 5323 2e50 0C60A0E1 		mov	r6, ip
 5324 2e54 0C80A0E1 		mov	r8, ip
 5325 2e58 68FEFFEA 		b	.L334
 5326              	.LVL499:
 5327              	.L353:
1821:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5328              		.loc 1 1821 0
 5329 2e5c 98629FE5 		ldr	r6, .L408+24
1819:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5330              		.loc 1 1819 0
 5331 2e60 00A0A0E3 		mov	sl, #0
1821:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5332              		.loc 1 1821 0
 5333 2e64 1C0096E5 		ldr	r0, [r6, #28]
1819:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5334              		.loc 1 1819 0
 5335 2e68 0DA3C8E5 		strb	sl, [r8, #781]
 5336              	.LVL500:
1821:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5337              		.loc 1 1821 0
 5338 2e6c 0010E0E3 		mvn	r1, #0
 5339 2e70 2C308DE5 		str	r3, [sp, #44]
 5340 2e74 FEFFFFEB 		bl	_txe_mutex_get
1822:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5341              		.loc 1 1822 0
 5342 2e78 0B20A0E1 		mov	r2, fp
 5343 2e7c 2C309DE5 		ldr	r3, [sp, #44]
 5344 2e80 1010A0E3 		mov	r1, #16
 5345 2e84 0600A0E1 		mov	r0, r6
 5346 2e88 00A08DE5 		str	sl, [sp, #0]
 5347 2e8c 04A08DE5 		str	sl, [sp, #4]
 5348 2e90 FEFFFFEB 		bl	cmdSet
1823:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5349              		.loc 1 1823 0
 5350 2e94 1C0096E5 		ldr	r0, [r6, #28]
 5351 2e98 FEFFFFEB 		bl	_txe_mutex_put
 5352              	.LVL501:
 5353              	.LBB72:
 5354              	.LBB73:
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5355              		.loc 1 716 0
 5356 2e9c 0010E0E3 		mvn	r1, #0
 5357 2ea0 1C0096E5 		ldr	r0, [r6, #28]
 5358 2ea4 FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5359              		.loc 1 717 0
 5360 2ea8 01C0A0E3 		mov	ip, #1
 5361 2eac 2010A0E3 		mov	r1, #32
 5362 2eb0 2720A0E3 		mov	r2, #39
 5363 2eb4 3030A0E3 		mov	r3, #48
 5364 2eb8 0600A0E1 		mov	r0, r6
 5365 2ebc 00C08DE5 		str	ip, [sp, #0]
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5366              		.loc 1 718 0
 5367 2ec0 0280A0E3 		mov	r8, #2
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5368              		.loc 1 717 0
 5369 2ec4 04A08DE5 		str	sl, [sp, #4]
 5370 2ec8 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5371              		.loc 1 718 0
 5372 2ecc 2110A0E3 		mov	r1, #33
 5373 2ed0 2520A0E3 		mov	r2, #37
 5374 2ed4 3030A0E3 		mov	r3, #48
 5375 2ed8 0600A0E1 		mov	r0, r6
 5376 2edc 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5377 2ee0 FEFFFFEB 		bl	cmdSet
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5378              		.loc 1 719 0
 5379 2ee4 1C0096E5 		ldr	r0, [r6, #28]
 5380 2ee8 FEFFFFEB 		bl	_txe_mutex_put
 5381              	.LBE73:
 5382              	.LBE72:
1825:../uvc.c      **** 							break;
 5383              		.loc 1 1825 0
 5384 2eec FFC0A0E3 		mov	ip, #255
 5385 2ef0 0C60A0E1 		mov	r6, ip
 5386 2ef4 0880A0E3 		mov	r8, #8
 5387 2ef8 40FEFFEA 		b	.L334
 5388              	.LVL502:
 5389              	.L352:
 5390              	.LBB74:
 5391              	.LBB75:
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5392              		.loc 1 716 0
 5393 2efc F8619FE5 		ldr	r6, .L408+24
 5394 2f00 0010E0E3 		mvn	r1, #0
 5395 2f04 1C0096E5 		ldr	r0, [r6, #28]
 5396 2f08 FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5397              		.loc 1 717 0
 5398 2f0c 0080A0E3 		mov	r8, #0
 5399 2f10 2010A0E3 		mov	r1, #32
 5400 2f14 2720A0E3 		mov	r2, #39
 5401 2f18 3030A0E3 		mov	r3, #48
 5402 2f1c 0600A0E1 		mov	r0, r6
 5403 2f20 00808DE5 		str	r8, [sp, #0]
 5404 2f24 04808DE5 		str	r8, [sp, #4]
 5405 2f28 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5406              		.loc 1 718 0
 5407 2f2c 01C0A0E3 		mov	ip, #1
 5408 2f30 2110A0E3 		mov	r1, #33
 5409 2f34 2520A0E3 		mov	r2, #37
 5410 2f38 3030A0E3 		mov	r3, #48
 5411 2f3c 0600A0E1 		mov	r0, r6
 5412 2f40 00C08DE5 		str	ip, [sp, #0]
 5413 2f44 04808DE5 		str	r8, [sp, #4]
 5414 2f48 FEFFFFEB 		bl	cmdSet
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5415              		.loc 1 719 0
 5416 2f4c 1C0096E5 		ldr	r0, [r6, #28]
 5417 2f50 FEFFFFEB 		bl	_txe_mutex_put
 5418 2f54 FFC0A0E3 		mov	ip, #255
 5419 2f58 0C60A0E1 		mov	r6, ip
 5420 2f5c 0480A0E3 		mov	r8, #4
 5421 2f60 26FEFFEA 		b	.L334
 5422              	.LVL503:
 5423              	.L351:
 5424              	.LBE75:
 5425              	.LBE74:
1809:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5426              		.loc 1 1809 0
 5427 2f64 90619FE5 		ldr	r6, .L408+24
1807:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5428              		.loc 1 1807 0
 5429 2f68 00A0A0E3 		mov	sl, #0
1809:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5430              		.loc 1 1809 0
 5431 2f6c 1C0096E5 		ldr	r0, [r6, #28]
1807:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5432              		.loc 1 1807 0
 5433 2f70 0DA3C8E5 		strb	sl, [r8, #781]
 5434              	.LVL504:
1809:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5435              		.loc 1 1809 0
 5436 2f74 0010E0E3 		mvn	r1, #0
 5437 2f78 2C308DE5 		str	r3, [sp, #44]
 5438 2f7c FEFFFFEB 		bl	_txe_mutex_get
1810:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5439              		.loc 1 1810 0
 5440 2f80 0B20A0E1 		mov	r2, fp
 5441 2f84 2C309DE5 		ldr	r3, [sp, #44]
 5442 2f88 1010A0E3 		mov	r1, #16
 5443 2f8c 0600A0E1 		mov	r0, r6
 5444 2f90 00A08DE5 		str	sl, [sp, #0]
 5445 2f94 04A08DE5 		str	sl, [sp, #4]
 5446 2f98 FEFFFFEB 		bl	cmdSet
1811:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5447              		.loc 1 1811 0
 5448 2f9c 1C0096E5 		ldr	r0, [r6, #28]
 5449 2fa0 FEFFFFEB 		bl	_txe_mutex_put
 5450              	.LVL505:
 5451              	.LBB76:
 5452              	.LBB77:
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5453              		.loc 1 716 0
 5454 2fa4 0010E0E3 		mvn	r1, #0
 5455 2fa8 1C0096E5 		ldr	r0, [r6, #28]
 5456 2fac FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5457              		.loc 1 717 0
 5458 2fb0 2010A0E3 		mov	r1, #32
 5459 2fb4 2720A0E3 		mov	r2, #39
 5460 2fb8 3030A0E3 		mov	r3, #48
 5461 2fbc 0600A0E1 		mov	r0, r6
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5462              		.loc 1 718 0
 5463 2fc0 0180A0E3 		mov	r8, #1
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5464              		.loc 1 717 0
 5465 2fc4 00A08DE5 		str	sl, [sp, #0]
 5466 2fc8 04A08DE5 		str	sl, [sp, #4]
 5467 2fcc FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5468              		.loc 1 718 0
 5469 2fd0 2110A0E3 		mov	r1, #33
 5470 2fd4 2520A0E3 		mov	r2, #37
 5471 2fd8 3030A0E3 		mov	r3, #48
 5472 2fdc 0600A0E1 		mov	r0, r6
 5473 2fe0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5474 2fe4 FEFFFFEB 		bl	cmdSet
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5475              		.loc 1 719 0
 5476 2fe8 1C0096E5 		ldr	r0, [r6, #28]
 5477 2fec FEFFFFEB 		bl	_txe_mutex_put
 5478 2ff0 FFC0A0E3 		mov	ip, #255
 5479 2ff4 0C60A0E1 		mov	r6, ip
 5480 2ff8 0280A0E3 		mov	r8, #2
 5481 2ffc FFFDFFEA 		b	.L334
 5482              	.LVL506:
 5483              	.L350:
 5484              	.LBE77:
 5485              	.LBE76:
 5486              	.LBB78:
 5487              	.LBB79:
 716:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5488              		.loc 1 716 0
 5489 3000 F4609FE5 		ldr	r6, .L408+24
 5490 3004 0010E0E3 		mvn	r1, #0
 5491 3008 1C0096E5 		ldr	r0, [r6, #28]
 5492 300c FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5493              		.loc 1 717 0
 5494 3010 0080A0E3 		mov	r8, #0
 5495 3014 01A0A0E3 		mov	sl, #1
 5496 3018 2010A0E3 		mov	r1, #32
 5497 301c 2720A0E3 		mov	r2, #39
 5498 3020 3030A0E3 		mov	r3, #48
 5499 3024 0600A0E1 		mov	r0, r6
 5500 3028 04808DE5 		str	r8, [sp, #4]
 5501 302c 00A08DE5 		str	sl, [sp, #0]
 5502 3030 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5503              		.loc 1 718 0
 5504 3034 02C0A0E3 		mov	ip, #2
 5505 3038 2110A0E3 		mov	r1, #33
 5506 303c 2520A0E3 		mov	r2, #37
 5507 3040 3030A0E3 		mov	r3, #48
 5508 3044 0600A0E1 		mov	r0, r6
 5509 3048 00C08DE5 		str	ip, [sp, #0]
 5510 304c 04808DE5 		str	r8, [sp, #4]
 5511 3050 FEFFFFEB 		bl	cmdSet
 719:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5512              		.loc 1 719 0
 5513 3054 1C0096E5 		ldr	r0, [r6, #28]
 5514 3058 FEFFFFEB 		bl	_txe_mutex_put
 5515              	.LBE79:
 5516              	.LBE78:
1805:../uvc.c      **** 							break;
 5517              		.loc 1 1805 0
 5518 305c FFC0A0E3 		mov	ip, #255
 5519 3060 0C60A0E1 		mov	r6, ip
 5520 3064 0A80A0E1 		mov	r8, sl
 5521 3068 E4FDFFEA 		b	.L334
 5522              	.LVL507:
 5523              	.L349:
1802:../uvc.c      **** 		  		    switch (getData){
 5524              		.loc 1 1802 0
 5525 306c FFC0A0E3 		mov	ip, #255
 5526 3070 0080A0E1 		mov	r8, r0
 5527 3074 0C60A0E1 		mov	r6, ip
 5528 3078 E0FDFFEA 		b	.L334
 5529              	.LVL508:
 5530              	.L355:
1873:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5531              		.loc 1 1873 0
 5532 307c 0000A0E3 		mov	r0, #0
 5533 3080 0110A0E3 		mov	r1, #1
 5534 3084 0020A0E1 		mov	r2, r0
 5535 3088 FEFFFFEB 		bl	CyU3PUsbStall
 5536              	.LVL509:
 5537 308c 94FEFFEA 		b	.L398
 5538              	.LVL510:
 5539              	.L397:
1891:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5540              		.loc 1 1891 0
 5541 3090 0110A0E3 		mov	r1, #1
 5542 3094 0020A0E1 		mov	r2, r0
 5543 3098 FEFFFFEB 		bl	CyU3PUsbStall
 5544 309c 90FEFFEA 		b	.L398
 5545              	.LVL511:
 5546              	.L407:
1906:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5547              		.loc 1 1906 0
 5548 30a0 08E0A0E3 		mov	lr, #8
 5549 30a4 00C0A0E3 		mov	ip, #0
 5550 30a8 0600A0E1 		mov	r0, r6
 5551 30ac 2310A0E3 		mov	r1, #35
 5552 30b0 0B20A0E1 		mov	r2, fp
 5553 30b4 00E08DE5 		str	lr, [sp, #0]
 5554 30b8 04C08DE5 		str	ip, [sp, #4]
 5555 30bc FEFFFFEB 		bl	cmdSet
 5556 30c0 5DFEFFEA 		b	.L400
 5557              	.L406:
1904:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5558              		.loc 1 1904 0
 5559 30c4 0480A0E3 		mov	r8, #4
 5560 30c8 00E0A0E3 		mov	lr, #0
 5561 30cc 0600A0E1 		mov	r0, r6
 5562 30d0 2310A0E3 		mov	r1, #35
 5563 30d4 0B20A0E1 		mov	r2, fp
 5564 30d8 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5565 30dc FEFFFFEB 		bl	cmdSet
 5566 30e0 55FEFFEA 		b	.L400
 5567              	.L409:
 5568              		.align	2
 5569              	.L408:
 5570 30e4 00000000 		.word	bRequest
 5571 30e8 00000000 		.word	.LANCHOR1
 5572 30ec 00000000 		.word	.LANCHOR0
 5573 30f0 78050000 		.word	.LC33
 5574 30f4 9C050000 		.word	.LC34
 5575 30f8 74000000 		.word	.LANCHOR0+116
 5576 30fc 00000000 		.word	cmdQu
 5577 3100 2C050000 		.word	.LC31
 5578 3104 FFFF0000 		.word	65535
 5579 3108 54050000 		.word	.LC32
 5580              		.cfi_endproc
 5581              	.LFE4:
 5583              		.align	2
 5584              		.global	UVCAppEP0Thread_Entry
 5586              	UVCAppEP0Thread_Entry:
 5587              	.LFB25:
4127:../uvc.c      **** {
 5588              		.loc 1 4127 0
 5589              		.cfi_startproc
 5590              		@ args = 0, pretend = 0, frame = 24
 5591              		@ frame_needed = 0, uses_anonymous_args = 0
 5592              	.LVL512:
 5593 310c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5594              	.LCFI20:
 5595              		.cfi_def_cfa_offset 36
 5596 3110 644D9FE5 		ldr	r4, .L605
 5597              		.cfi_offset 14, -4
 5598              		.cfi_offset 11, -8
 5599              		.cfi_offset 10, -12
 5600              		.cfi_offset 9, -16
 5601              		.cfi_offset 8, -20
 5602              		.cfi_offset 7, -24
 5603              		.cfi_offset 6, -28
 5604              		.cfi_offset 5, -32
 5605              		.cfi_offset 4, -36
 5606 3114 645D9FE5 		ldr	r5, .L605+4
 5607 3118 648D9FE5 		ldr	r8, .L605+8
 5608 311c 64AD9FE5 		ldr	sl, .L605+12
 5609 3120 64BD9FE5 		ldr	fp, .L605+16
 5610 3124 647D9FE5 		ldr	r7, .L605+20
 5611 3128 34D04DE2 		sub	sp, sp, #52
 5612              	.LCFI21:
 5613              		.cfi_def_cfa_offset 88
 5614              	.LVL513:
4149:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5615              		.loc 1 4149 0
 5616 312c 0460A0E1 		mov	r6, r4
 5617              	.LVL514:
 5618              	.L565:
 5619 3130 00C0E0E3 		mvn	ip, #0
 5620 3134 400D9FE5 		ldr	r0, .L605
 5621 3138 4C10A0E3 		mov	r1, #76
 5622 313c 0120A0E3 		mov	r2, #1
 5623 3140 28308DE2 		add	r3, sp, #40
 5624 3144 00C08DE5 		str	ip, [sp, #0]
 5625 3148 FEFFFFEB 		bl	_txe_event_flags_get
 5626 314c 000050E3 		cmp	r0, #0
 5627 3150 3000001A 		bne	.L411
4153:../uvc.c      ****             if (!isUsbConnected)
 5628              		.loc 1 4153 0
 5629 3154 443096E5 		ldr	r3, [r6, #68]
 5630 3158 000053E3 		cmp	r3, #0
 5631 315c 8C00000A 		beq	.L594
 5632              	.L412:
4162:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 5633              		.loc 1 4162 0
 5634 3160 28309DE5 		ldr	r3, [sp, #40]
 5635 3164 0C0013E3 		tst	r3, #12
 5636 3168 7500001A 		bne	.L595
 5637              	.L413:
4169:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5638              		.loc 1 4169 0
 5639 316c 040013E3 		tst	r3, #4
 5640 3170 1C00000A 		beq	.L414
4171:../uvc.c      ****             	switch ((wIndex >> 8))
 5641              		.loc 1 4171 0
 5642 3174 B0E0DBE1 		ldrh	lr, [fp, #0]
 5643 3178 2E24A0E1 		mov	r2, lr, lsr #8
 5644 317c 030052E3 		cmp	r2, #3
 5645 3180 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5646 3184 120000EA 		b	.L415
 5647              	.L420:
 5648 3188 D4310000 		.word	.L415
 5649 318c C4320000 		.word	.L417
 5650 3190 98310000 		.word	.L418
 5651 3194 00330000 		.word	.L419
 5652              	.L418:
 5653              	.LBB94:
 5654              	.LBB98:
3375:../uvc.c      ****     switch (wValue)
 5655              		.loc 1 3375 0
 5656 3198 B020DAE1 		ldrh	r2, [sl, #0]
 5657 319c 060C52E3 		cmp	r2, #1536
 5658 31a0 9902000A 		beq	.L426
 5659 31a4 D900008A 		bhi	.L432
 5660 31a8 030C52E3 		cmp	r2, #768
 5661 31ac 9202000A 		beq	.L424
 5662 31b0 A001008A 		bhi	.L433
 5663 31b4 010C52E3 		cmp	r2, #256
 5664 31b8 B602000A 		beq	.L422
 5665 31bc 020C52E3 		cmp	r2, #512
 5666 31c0 B002000A 		beq	.L596
 5667              	.L435:
 5668              	.LBE98:
 5669              	.LBE94:
 5670              	.LBB102:
 5671              	.LBB107:
3507:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5672              		.loc 1 3507 0
 5673 31c4 C81C9FE5 		ldr	r1, .L605+24
 5674 31c8 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5675 31cc 0400A0E3 		mov	r0, #4
 5676 31d0 FEFFFFEB 		bl	CyU3PDebugPrint
 5677              	.L415:
 5678              	.LBE107:
 5679              	.LBE102:
4192:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5680              		.loc 1 4192 0
 5681 31d4 0000A0E3 		mov	r0, #0
 5682 31d8 0110A0E3 		mov	r1, #1
 5683 31dc 0020A0E1 		mov	r2, r0
 5684 31e0 FEFFFFEB 		bl	CyU3PUsbStall
 5685 31e4 28309DE5 		ldr	r3, [sp, #40]
 5686              	.L414:
4197:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5687              		.loc 1 4197 0
 5688 31e8 080013E3 		tst	r3, #8
 5689 31ec 0700000A 		beq	.L478
4201:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5690              		.loc 1 4201 0
 5691 31f0 B030DBE1 		ldrh	r3, [fp, #0]
 5692 31f4 010053E3 		cmp	r3, #1
 5693 31f8 6B00000A 		beq	.L479
 5694              	.L480:
 5695              	.LBB113:
 5696              	.LBB117:
4116:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5697              		.loc 1 4116 0
 5698 31fc 0000A0E3 		mov	r0, #0
 5699 3200 0110A0E3 		mov	r1, #1
 5700 3204 0020A0E1 		mov	r2, r0
 5701 3208 FEFFFFEB 		bl	CyU3PUsbStall
 5702              	.L584:
 5703 320c 28309DE5 		ldr	r3, [sp, #40]
 5704              	.L478:
 5705              	.LBE117:
 5706              	.LBE113:
4212:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5707              		.loc 1 4212 0
 5708 3210 400013E3 		tst	r3, #64
 5709 3214 0100001A 		bne	.L597
 5710              	.L411:
4425:../uvc.c      ****         CyU3PThreadRelinquish ();
 5711              		.loc 1 4425 0
 5712 3218 FEFFFFEB 		bl	_txe_thread_relinquish
4426:../uvc.c      ****     }
 5713              		.loc 1 4426 0
 5714 321c C3FFFFEA 		b	.L565
 5715              	.L597:
4217:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5716              		.loc 1 4217 0
 5717 3220 1800A0E3 		mov	r0, #24
 5718 3224 24108DE2 		add	r1, sp, #36
 5719 3228 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4274:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5720              		.loc 1 4274 0
 5721 322c 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 5722 3230 0F0053E3 		cmp	r3, #15
 5723 3234 9400000A 		beq	.L598
4301:../uvc.c      **** 				}else if(!snapButFlag){
 5724              		.loc 1 4301 0
 5725 3238 000053E3 		cmp	r3, #0
 5726 323c F5FFFF1A 		bne	.L411
4303:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5727              		.loc 1 4303 0
 5728 3240 002097E5 		ldr	r2, [r7, #0]
 5729 3244 0290A0E3 		mov	r9, #2
 5730 3248 0090C2E5 		strb	r9, [r2, #0]
4304:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5731              		.loc 1 4304 0
 5732 324c 001097E5 		ldr	r1, [r7, #0]
 5733 3250 0190A0E3 		mov	r9, #1
 5734 3254 0190C1E5 		strb	r9, [r1, #1]
4305:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5735              		.loc 1 4305 0
 5736 3258 000097E5 		ldr	r0, [r7, #0]
4309:../uvc.c      **** 					interStabuf.size   = 1024;
 5737              		.loc 1 4309 0
 5738 325c 01CBA0E3 		mov	ip, #1024	@ movhi
4305:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5739              		.loc 1 4305 0
 5740 3260 0230C0E5 		strb	r3, [r0, #2]
4306:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5741              		.loc 1 4306 0
 5742 3264 00E097E5 		ldr	lr, [r7, #0]
4315:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5743              		.loc 1 4315 0
 5744 3268 0010E0E3 		mvn	r1, #0
4306:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5745              		.loc 1 4306 0
 5746 326c 0390CEE5 		strb	r9, [lr, #3]
4308:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5747              		.loc 1 4308 0
 5748 3270 002097E5 		ldr	r2, [r7, #0]
4312:../uvc.c      **** 					interStabuf.count = 4;
 5749              		.loc 1 4312 0
 5750 3274 04E0A0E3 		mov	lr, #4	@ movhi
4315:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5751              		.loc 1 4315 0
 5752 3278 180C9FE5 		ldr	r0, .L605+28
4308:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5753              		.loc 1 4308 0
 5754 327c 18208DE5 		str	r2, [sp, #24]
4309:../uvc.c      **** 					interStabuf.size   = 1024;
 5755              		.loc 1 4309 0
 5756 3280 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4310:../uvc.c      **** 					interStabuf.status = 0;
 5757              		.loc 1 4310 0
 5758 3284 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4312:../uvc.c      **** 					interStabuf.count = 4;
 5759              		.loc 1 4312 0
 5760 3288 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
4315:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5761              		.loc 1 4315 0
 5762 328c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4318:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5763              		.loc 1 4318 0
 5764 3290 000C9FE5 		ldr	r0, .L605+28
 5765 3294 18108DE2 		add	r1, sp, #24
 5766 3298 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5767              	.LVL515:
4320:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5768              		.loc 1 4320 0
 5769 329c 002050E2 		subs	r2, r0, #0
 5770 32a0 5B01001A 		bne	.L599
4326:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 5771              		.loc 1 4326 0
 5772 32a4 3010A0E3 		mov	r1, #48
 5773 32a8 0920A0E1 		mov	r2, r9
 5774 32ac 0500A0E3 		mov	r0, #5
 5775              	.LVL516:
 5776 32b0 FEFFFFEB 		bl	SensorSetControl
4327:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 5777              		.loc 1 4327 0
 5778 32b4 C43B9FE5 		ldr	r3, .L605+4
 5779 32b8 0B97C3E5 		strb	r9, [r3, #1803]
4425:../uvc.c      ****         CyU3PThreadRelinquish ();
 5780              		.loc 1 4425 0
 5781 32bc FEFFFFEB 		bl	_txe_thread_relinquish
 5782 32c0 9AFFFFEA 		b	.L565
 5783              	.L417:
 5784              	.LBB122:
 5785              	.LBB108:
3450:../uvc.c      ****     switch (wValue)
 5786              		.loc 1 3450 0
 5787 32c4 B020DAE1 		ldrh	r2, [sl, #0]
 5788 32c8 060C52E3 		cmp	r2, #1536
 5789 32cc 7502000A 		beq	.L441
 5790 32d0 9900008A 		bhi	.L447
 5791 32d4 030C52E3 		cmp	r2, #768
 5792 32d8 5B02000A 		beq	.L438
 5793 32dc 8101008A 		bhi	.L448
 5794 32e0 010C52E3 		cmp	r2, #256
 5795 32e4 5402000A 		beq	.L436
 5796 32e8 020C52E3 		cmp	r2, #512
 5797 32ec B4FFFF1A 		bne	.L435
 5798              	.LVL517:
3458:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 5799              		.loc 1 3458 0
 5800 32f0 0100A0E3 		mov	r0, #1
 5801 32f4 FEFFFFEB 		bl	CTControlHandle
 5802              	.LVL518:
 5803 32f8 28309DE5 		ldr	r3, [sp, #40]
 5804 32fc B9FFFFEA 		b	.L414
 5805              	.L419:
 5806              	.LBE108:
 5807              	.LBE122:
 5808              	.LBB123:
 5809              	.LBB129:
3675:../uvc.c      ****     switch (wValue)
 5810              		.loc 1 3675 0
 5811 3300 B030DAE1 		ldrh	r3, [sl, #0]
 5812 3304 090C53E3 		cmp	r3, #2304
 5813 3308 4702000A 		beq	.L462
 5814 330c 9200008A 		bhi	.L472
 5815 3310 010B53E3 		cmp	r3, #1024
 5816 3314 4002000A 		beq	.L457
 5817 3318 5701008A 		bhi	.L473
 5818 331c 020C53E3 		cmp	r3, #512
 5819 3320 C101000A 		beq	.L455
 5820 3324 030C53E3 		cmp	r3, #768
 5821 3328 BB01000A 		beq	.L456
 5822 332c 010C53E3 		cmp	r3, #256
 5823 3330 A7FFFF1A 		bne	.L415
 5824              	.LVL519:
3679:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5825              		.loc 1 3679 0
 5826 3334 1000A0E3 		mov	r0, #16
 5827 3338 FEFFFFEB 		bl	ControlHandle
 5828              	.LVL520:
 5829 333c 28309DE5 		ldr	r3, [sp, #40]
 5830 3340 A8FFFFEA 		b	.L414
 5831              	.L595:
 5832              	.LBE129:
 5833              	.LBE123:
4163:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 5834              		.loc 1 4163 0
 5835 3344 B0C0DAE1 		ldrh	ip, [sl, #0]
 5836 3348 4C9B9FE5 		ldr	r9, .L605+32
 5837 334c 4C1B9FE5 		ldr	r1, .L605+36
 5838 3350 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 5839 3354 08C08DE5 		str	ip, [sp, #8]
 5840 3358 B000DBE1 		ldrh	r0, [fp, #0]
 5841 335c 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 5842 3360 0C008DE5 		str	r0, [sp, #12]
 5843 3364 B0C0D1E1 		ldrh	ip, [r1, #0]
 5844 3368 5C20D4E5 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 5845 336c 04908DE5 		str	r9, [sp, #4]
 5846 3370 0400A0E3 		mov	r0, #4
 5847 3374 281B9FE5 		ldr	r1, .L605+40
 5848 3378 0090A0E3 		mov	r9, #0
 5849 337c 00E08DE5 		str	lr, [sp, #0]
 5850 3380 10C08DE5 		str	ip, [sp, #16]
 5851 3384 14908DE5 		str	r9, [sp, #20]
 5852 3388 FEFFFFEB 		bl	CyU3PDebugPrint
 5853 338c 28309DE5 		ldr	r3, [sp, #40]
 5854 3390 75FFFFEA 		b	.L413
 5855              	.L594:
4155:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5856              		.loc 1 4155 0
 5857 3394 FEFFFFEB 		bl	CyU3PUsbGetSpeed
4156:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5858              		.loc 1 4156 0
 5859 3398 000050E3 		cmp	r0, #0
4155:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5860              		.loc 1 4155 0
 5861 339c 5C00C6E5 		strb	r0, [r6, #92]
4158:../uvc.c      ****                     isUsbConnected = CyTrue;
 5862              		.loc 1 4158 0
 5863 33a0 0100A013 		movne	r0, #1
 5864 33a4 44008615 		strne	r0, [r6, #68]
 5865 33a8 6CFFFFEA 		b	.L412
 5866              	.L479:
 5867              	.LVL521:
 5868              	.LBB136:
 5869              	.LBB118:
3776:../uvc.c      ****     switch (wValue)
 5870              		.loc 1 3776 0
 5871 33ac B020DAE1 		ldrh	r2, [sl, #0]
 5872 33b0 030C52E3 		cmp	r2, #768
 5873 33b4 CD00000A 		beq	.L483
 5874 33b8 0F00008A 		bhi	.L486
 5875 33bc 010C52E3 		cmp	r2, #256
 5876 33c0 8600000A 		beq	.L481
 5877 33c4 020C52E3 		cmp	r2, #512
 5878 33c8 8BFFFF1A 		bne	.L480
3841:../uvc.c      ****             switch (bRequest)
 5879              		.loc 1 3841 0
 5880 33cc 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5881 33d0 810053E3 		cmp	r3, #129
 5882 33d4 8301000A 		beq	.L552
 5883 33d8 D100008A 		bhi	.L501
 5884 33dc 010053E3 		cmp	r3, #1
 5885 33e0 7101000A 		beq	.L600
 5886              	.L528:
4054:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5887              		.loc 1 4054 0
 5888 33e4 0000A0E3 		mov	r0, #0
 5889 33e8 0110A0E3 		mov	r1, #1
 5890 33ec 0020A0E1 		mov	r2, r0
 5891 33f0 FEFFFFEB 		bl	CyU3PUsbStall
 5892 33f4 28309DE5 		ldr	r3, [sp, #40]
 5893 33f8 84FFFFEA 		b	.L478
 5894              	.L486:
3776:../uvc.c      ****     switch (wValue)
 5895              		.loc 1 3776 0
 5896 33fc 010B52E3 		cmp	r2, #1024
 5897 3400 6100000A 		beq	.L484
 5898 3404 050C52E3 		cmp	r2, #1280
 5899 3408 7BFFFF1A 		bne	.L480
4061:../uvc.c      ****             	switch (bRequest)
 5900              		.loc 1 4061 0
 5901 340c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5902 3410 810052E3 		cmp	r2, #129
 5903 3414 7301000A 		beq	.L552
 5904 3418 4401008A 		bhi	.L555
 5905 341c 010052E3 		cmp	r2, #1
 5906 3420 75FFFF1A 		bne	.L480
4086:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5907              		.loc 1 4086 0
 5908 3424 2000A0E3 		mov	r0, #32
 5909 3428 781A9FE5 		ldr	r1, .L605+44
 5910 342c 2E208DE2 		add	r2, sp, #46
 5911 3430 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5912              	.LVL522:
4088:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5913              		.loc 1 4088 0
 5914 3434 000050E3 		cmp	r0, #0
 5915 3438 5501001A 		bne	.L557
4092:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5916              		.loc 1 4092 0
 5917 343c 0020A0E3 		mov	r2, #0
 5918 3440 340A9FE5 		ldr	r0, .L605
 5919              	.LVL523:
 5920 3444 8010A0E3 		mov	r1, #128
 5921 3448 FEFFFFEB 		bl	_txe_event_flags_set
 5922              	.LVL524:
4093:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5923              		.loc 1 4093 0
 5924 344c 002050E2 		subs	r2, r0, #0
4099:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5925              		.loc 1 4099 0
 5926 3450 0FC0E003 		mvneq	ip, #15
 5927 3454 4EC0C605 		streqb	ip, [r6, #78]
4093:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5928              		.loc 1 4093 0
 5929 3458 0200000A 		beq	.L559
4095:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5930              		.loc 1 4095 0
 5931 345c 481A9FE5 		ldr	r1, .L605+48
 5932 3460 0400A0E3 		mov	r0, #4
 5933              	.LVL525:
 5934 3464 FEFFFFEB 		bl	CyU3PDebugPrint
 5935              	.LVL526:
 5936              	.L559:
4102:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5937              		.loc 1 4102 0
 5938 3468 D9E0D4E5 		ldrb	lr, [r4, #217]	@ zero_extendqisi2
 5939 346c D830D4E5 		ldrb	r3, [r4, #216]	@ zero_extendqisi2
 5940 3470 BE22DDE1 		ldrh	r2, [sp, #46]
 5941              	.LVL527:
 5942 3474 0400A0E3 		mov	r0, #4
 5943 3478 301A9FE5 		ldr	r1, .L605+52
 5944 347c 00E08DE5 		str	lr, [sp, #0]
 5945 3480 FEFFFFEB 		bl	CyU3PDebugPrint
 5946 3484 28309DE5 		ldr	r3, [sp, #40]
 5947 3488 60FFFFEA 		b	.L478
 5948              	.LVL528:
 5949              	.L598:
 5950              	.LBE118:
 5951              	.LBE136:
4276:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5952              		.loc 1 4276 0
 5953 348c 003097E5 		ldr	r3, [r7, #0]
 5954 3490 0290A0E3 		mov	r9, #2
 5955 3494 0090C3E5 		strb	r9, [r3, #0]
4277:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5956              		.loc 1 4277 0
 5957 3498 002097E5 		ldr	r2, [r7, #0]
 5958 349c 0190A0E3 		mov	r9, #1
 5959 34a0 0190C2E5 		strb	r9, [r2, #1]
4278:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5960              		.loc 1 4278 0
 5961 34a4 001097E5 		ldr	r1, [r7, #0]
 5962 34a8 0030A0E3 		mov	r3, #0
 5963 34ac 0230C1E5 		strb	r3, [r1, #2]
4279:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5964              		.loc 1 4279 0
 5965 34b0 000097E5 		ldr	r0, [r7, #0]
4285:../uvc.c      **** 					interStabuf.count = 4;
 5966              		.loc 1 4285 0
 5967 34b4 0420A0E3 		mov	r2, #4	@ movhi
4279:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5968              		.loc 1 4279 0
 5969 34b8 0330C0E5 		strb	r3, [r0, #3]
4281:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5970              		.loc 1 4281 0
 5971 34bc 00E097E5 		ldr	lr, [r7, #0]
4282:../uvc.c      **** 					interStabuf.size   = 1024;
 5972              		.loc 1 4282 0
 5973 34c0 01CBA0E3 		mov	ip, #1024	@ movhi
4288:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5974              		.loc 1 4288 0
 5975 34c4 0010E0E3 		mvn	r1, #0
 5976 34c8 C8099FE5 		ldr	r0, .L605+28
4285:../uvc.c      **** 					interStabuf.count = 4;
 5977              		.loc 1 4285 0
 5978 34cc BC21CDE1 		strh	r2, [sp, #28]	@ movhi
4281:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5979              		.loc 1 4281 0
 5980 34d0 18E08DE5 		str	lr, [sp, #24]
4282:../uvc.c      **** 					interStabuf.size   = 1024;
 5981              		.loc 1 4282 0
 5982 34d4 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4283:../uvc.c      **** 					interStabuf.status = 0;
 5983              		.loc 1 4283 0
 5984 34d8 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4288:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5985              		.loc 1 4288 0
 5986 34dc FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4291:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5987              		.loc 1 4291 0
 5988 34e0 B0099FE5 		ldr	r0, .L605+28
 5989 34e4 18108DE2 		add	r1, sp, #24
 5990 34e8 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5991              	.LVL529:
4293:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5992              		.loc 1 4293 0
 5993 34ec 002050E2 		subs	r2, r0, #0
 5994 34f0 D800001A 		bne	.L601
4298:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5995              		.loc 1 4298 0
 5996 34f4 3010A0E3 		mov	r1, #48
 5997 34f8 0500A0E3 		mov	r0, #5
 5998              	.LVL530:
 5999 34fc FEFFFFEB 		bl	SensorSetControl
 6000              	.LVL531:
4300:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 6001              		.loc 1 4300 0
 6002 3500 78C99FE5 		ldr	ip, .L605+4
 6003 3504 0B97CCE5 		strb	r9, [ip, #1803]
4425:../uvc.c      ****         CyU3PThreadRelinquish ();
 6004              		.loc 1 4425 0
 6005 3508 FEFFFFEB 		bl	_txe_thread_relinquish
 6006 350c 07FFFFEA 		b	.L565
 6007              	.L432:
 6008              	.LBB137:
 6009              	.LBB97:
3375:../uvc.c      ****     switch (wValue)
 6010              		.loc 1 3375 0
 6011 3510 0A0C52E3 		cmp	r2, #2560
 6012 3514 1A01000A 		beq	.L429
 6013 3518 FA00008A 		bhi	.L434
 6014 351c 070C52E3 		cmp	r2, #1792
 6015 3520 1301000A 		beq	.L427
 6016 3524 020B52E3 		cmp	r2, #2048
 6017 3528 25FFFF1A 		bne	.L435
 6018              	.LVL532:
3406:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 6019              		.loc 1 3406 0
 6020 352c 0700A0E3 		mov	r0, #7
 6021 3530 FEFFFFEB 		bl	ControlHandle
 6022              	.LVL533:
 6023 3534 28309DE5 		ldr	r3, [sp, #40]
 6024 3538 2AFFFFEA 		b	.L414
 6025              	.L447:
 6026              	.LBE97:
 6027              	.LBE137:
 6028              	.LBB138:
 6029              	.LBB106:
3450:../uvc.c      ****     switch (wValue)
 6030              		.loc 1 3450 0
 6031 353c 090C52E3 		cmp	r2, #2304
 6032 3540 A901000A 		beq	.L443
 6033 3544 D500008A 		bhi	.L449
 6034 3548 070C52E3 		cmp	r2, #1792
 6035 354c A201000A 		beq	.L442
 6036 3550 020B52E3 		cmp	r2, #2048
 6037 3554 1AFFFF1A 		bne	.L435
 6038 3558 22FFFFEA 		b	.L414
 6039              	.L472:
 6040              	.LBE106:
 6041              	.LBE138:
 6042              	.LBB139:
 6043              	.LBB130:
3675:../uvc.c      ****     switch (wValue)
 6044              		.loc 1 3675 0
 6045 355c 0F0C53E3 		cmp	r3, #3840
 6046 3560 9901000A 		beq	.L467
 6047 3564 A100008A 		bhi	.L475
 6048 3568 0B0C53E3 		cmp	r3, #2816
 6049 356c FC00000A 		beq	.L464
 6050 3570 9600008A 		bhi	.L476
 6051 3574 0A0C53E3 		cmp	r3, #2560
 6052 3578 15FFFF1A 		bne	.L415
 6053              	.LVL534:
3716:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 6054              		.loc 1 3716 0
 6055 357c 1900A0E3 		mov	r0, #25
 6056 3580 FEFFFFEB 		bl	ControlHandle
 6057              	.LVL535:
 6058 3584 28309DE5 		ldr	r3, [sp, #40]
 6059 3588 16FFFFEA 		b	.L414
 6060              	.LVL536:
 6061              	.L484:
 6062              	.LBE130:
 6063              	.LBE139:
 6064              	.LBB140:
 6065              	.LBB116:
3975:../uvc.c      ****                 switch (bRequest)
 6066              		.loc 1 3975 0
 6067 358c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6068 3590 810052E3 		cmp	r2, #129
 6069 3594 5A00000A 		beq	.L530
 6070 3598 2100008A 		bhi	.L533
 6071 359c 010052E3 		cmp	r2, #1
 6072 35a0 8FFFFF1A 		bne	.L528
4000:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6073              		.loc 1 4000 0
 6074 35a4 2000A0E3 		mov	r0, #32
 6075 35a8 F8189FE5 		ldr	r1, .L605+44
 6076 35ac 2E208DE2 		add	r2, sp, #46
 6077 35b0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6078              	.LVL537:
4002:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6079              		.loc 1 4002 0
 6080 35b4 000050E3 		cmp	r0, #0
 6081 35b8 13FFFF1A 		bne	.L584
4021:../uvc.c      ****                            switch (glCommitCtrl[1])
 6082              		.loc 1 4021 0
 6083 35bc D920D6E5 		ldrb	r2, [r6, #217]	@ zero_extendqisi2
 6084 35c0 011042E2 		sub	r1, r2, #1
 6085 35c4 030051E3 		cmp	r1, #3
 6086 35c8 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6087 35cc C90100EA 		b	.L536
 6088              	.L541:
 6089 35d0 643D0000 		.word	.L537
 6090 35d4 B83D0000 		.word	.L538
 6091 35d8 203D0000 		.word	.L539
 6092 35dc B83C0000 		.word	.L540
 6093              	.LVL538:
 6094              	.L481:
3779:../uvc.c      ****             switch (bRequest)
 6095              		.loc 1 3779 0
 6096 35e0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6097 35e4 830052E3 		cmp	r2, #131
 6098 35e8 3100008A 		bhi	.L492
 6099 35ec 810052E3 		cmp	r2, #129
 6100 35f0 1600003A 		bcc	.L602
 6101              	.L489:
3794:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 6102              		.loc 1 3794 0
 6103 35f4 5C30D4E5 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 6104 35f8 030053E3 		cmp	r3, #3
 6105 35fc FC00001A 		bne	.L556
3796:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 6106              		.loc 1 3796 0
 6107 3600 AC189FE5 		ldr	r1, .L605+56
 6108 3604 1A00A0E3 		mov	r0, #26
 6109 3608 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3797:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 6110              		.loc 1 3797 0
 6111 360c 0400A0E3 		mov	r0, #4
 6112 3610 A0189FE5 		ldr	r1, .L605+60
 6113 3614 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6114 3618 FEFFFFEB 		bl	CyU3PDebugPrint
 6115 361c 28309DE5 		ldr	r3, [sp, #40]
 6116 3620 FAFEFFEA 		b	.L478
 6117              	.L533:
3975:../uvc.c      ****                 switch (bRequest)
 6118              		.loc 1 3975 0
 6119 3624 850052E3 		cmp	r2, #133
 6120 3628 2700000A 		beq	.L531
 6121 362c 860052E3 		cmp	r2, #134
 6122 3630 6BFFFF1A 		bne	.L528
 6123              	.L588:
3979:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6124              		.loc 1 3979 0
 6125 3634 0300A0E1 		mov	r0, r3
 6126              	.L583:
3845:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6127              		.loc 1 3845 0
 6128 3638 7C189FE5 		ldr	r1, .L605+64
3844:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6129              		.loc 1 3844 0
 6130 363c 0390A0E3 		mov	r9, #3
 6131 3640 7490C4E5 		strb	r9, [r4, #116]
3845:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6132              		.loc 1 3845 0
 6133 3644 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6134 3648 28309DE5 		ldr	r3, [sp, #40]
 6135 364c EFFEFFEA 		b	.L478
 6136              	.L602:
3779:../uvc.c      ****             switch (bRequest)
 6137              		.loc 1 3779 0
 6138 3650 010052E3 		cmp	r2, #1
 6139 3654 62FFFF1A 		bne	.L528
3806:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6140              		.loc 1 3806 0
 6141 3658 2000A0E3 		mov	r0, #32
 6142 365c 44189FE5 		ldr	r1, .L605+44
 6143 3660 2E208DE2 		add	r2, sp, #46
 6144 3664 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6145              	.LVL539:
3808:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6146              		.loc 1 3808 0
 6147 3668 000050E3 		cmp	r0, #0
 6148 366c E6FEFF1A 		bne	.L584
3810:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6149              		.loc 1 3810 0
 6150 3670 5C10D6E5 		ldrb	r1, [r6, #92]	@ zero_extendqisi2
 6151 3674 030051E3 		cmp	r1, #3
 6152 3678 E3FEFF1A 		bne	.L584
3817:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6153              		.loc 1 3817 0
 6154 367c DD30D4E5 		ldrb	r3, [r4, #221]	@ zero_extendqisi2
3814:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6155              		.loc 1 3814 0
 6156 3680 DAE0D4E5 		ldrb	lr, [r4, #218]	@ zero_extendqisi2
3815:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6157              		.loc 1 3815 0
 6158 3684 DBC0D4E5 		ldrb	ip, [r4, #219]	@ zero_extendqisi2
3816:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6159              		.loc 1 3816 0
 6160 3688 DC00D4E5 		ldrb	r0, [r4, #220]	@ zero_extendqisi2
 6161              	.LVL540:
3818:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6162              		.loc 1 3818 0
 6163 368c DE20D4E5 		ldrb	r2, [r4, #222]	@ zero_extendqisi2
3819:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6164              		.loc 1 3819 0
 6165 3690 DF90D4E5 		ldrb	r9, [r4, #223]	@ zero_extendqisi2
3817:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6166              		.loc 1 3817 0
 6167 3694 A536C5E5 		strb	r3, [r5, #1701]
3814:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6168              		.loc 1 3814 0
 6169 3698 A2E6C5E5 		strb	lr, [r5, #1698]
3815:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6170              		.loc 1 3815 0
 6171 369c A3C6C5E5 		strb	ip, [r5, #1699]
3816:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6172              		.loc 1 3816 0
 6173 36a0 A406C5E5 		strb	r0, [r5, #1700]
3818:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6174              		.loc 1 3818 0
 6175 36a4 A626C5E5 		strb	r2, [r5, #1702]
3819:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6176              		.loc 1 3819 0
 6177 36a8 A796C5E5 		strb	r9, [r5, #1703]
 6178 36ac 28309DE5 		ldr	r3, [sp, #40]
 6179 36b0 D6FEFFEA 		b	.L478
 6180              	.LVL541:
 6181              	.L492:
3779:../uvc.c      ****             switch (bRequest)
 6182              		.loc 1 3779 0
 6183 36b4 860052E3 		cmp	r2, #134
 6184 36b8 DDFFFF0A 		beq	.L588
 6185 36bc 870052E3 		cmp	r2, #135
 6186 36c0 CBFFFF0A 		beq	.L489
 6187              	.L593:
3925:../uvc.c      ****                 switch (bRequest)
 6188              		.loc 1 3925 0
 6189 36c4 850052E3 		cmp	r2, #133
 6190 36c8 45FFFF1A 		bne	.L528
 6191              	.L531:
3984:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6192              		.loc 1 3984 0
 6193 36cc E8179FE5 		ldr	r1, .L605+64
 6194 36d0 0200A0E3 		mov	r0, #2
3982:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 6195              		.loc 1 3982 0
 6196 36d4 1A30A0E3 		mov	r3, #26
 6197              	.L585:
4069:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6198              		.loc 1 4069 0
 6199 36d8 0090A0E3 		mov	r9, #0
4068:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 6200              		.loc 1 4068 0
 6201 36dc 7430C4E5 		strb	r3, [r4, #116]
4069:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6202              		.loc 1 4069 0
 6203 36e0 7590C4E5 		strb	r9, [r4, #117]
4070:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6204              		.loc 1 4070 0
 6205 36e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6206 36e8 28309DE5 		ldr	r3, [sp, #40]
 6207 36ec C7FEFFEA 		b	.L478
 6208              	.L483:
3925:../uvc.c      ****                 switch (bRequest)
 6209              		.loc 1 3925 0
 6210 36f0 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 6211 36f4 830052E3 		cmp	r2, #131
 6212 36f8 2F00008A 		bhi	.L524
 6213 36fc 810052E3 		cmp	r2, #129
 6214 3700 0D00003A 		bcc	.L603
 6215              	.L530:
3987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6216              		.loc 1 3987 0
 6217 3704 5C30D4E5 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
3989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6218              		.loc 1 3989 0
 6219 3708 0B00A0E3 		mov	r0, #11
3987:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6220              		.loc 1 3987 0
 6221 370c 030053E3 		cmp	r3, #3
3989:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6222              		.loc 1 3989 0
 6223 3710 A8179F05 		ldreq	r1, .L605+68
3993:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6224              		.loc 1 3993 0
 6225 3714 A8179F15 		ldrne	r1, .L605+72
 6226 3718 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6227 371c 28309DE5 		ldr	r3, [sp, #40]
 6228 3720 BAFEFFEA 		b	.L478
 6229              	.L501:
3841:../uvc.c      ****             switch (bRequest)
 6230              		.loc 1 3841 0
 6231 3724 850053E3 		cmp	r3, #133
 6232 3728 E7FFFF0A 		beq	.L531
 6233 372c 860053E3 		cmp	r3, #134
 6234 3730 2BFFFF1A 		bne	.L528
 6235              	.L589:
3845:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6236              		.loc 1 3845 0
 6237 3734 0100A0E3 		mov	r0, #1
 6238 3738 BEFFFFEA 		b	.L583
 6239              	.L603:
3925:../uvc.c      ****                 switch (bRequest)
 6240              		.loc 1 3925 0
 6241 373c 010052E3 		cmp	r2, #1
 6242 3740 27FFFF1A 		bne	.L528
3950:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6243              		.loc 1 3950 0
 6244 3744 2000A0E3 		mov	r0, #32
 6245 3748 58179FE5 		ldr	r1, .L605+44
 6246 374c 2E208DE2 		add	r2, sp, #46
 6247 3750 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6248              	.LVL542:
3952:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6249              		.loc 1 3952 0
 6250 3754 000050E3 		cmp	r0, #0
 6251 3758 ABFEFF1A 		bne	.L584
3954:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 6252              		.loc 1 3954 0
 6253 375c 5C10D6E5 		ldrb	r1, [r6, #92]	@ zero_extendqisi2
 6254 3760 030051E3 		cmp	r1, #3
 6255 3764 0B00001A 		bne	.L527
3958:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6256              		.loc 1 3958 0
 6257 3768 D9E0D6E5 		ldrb	lr, [r6, #217]	@ zero_extendqisi2
3959:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6258              		.loc 1 3959 0
 6259 376c DAC0D6E5 		ldrb	ip, [r6, #218]	@ zero_extendqisi2
3960:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6260              		.loc 1 3960 0
 6261 3770 DB00D6E5 		ldrb	r0, [r6, #219]	@ zero_extendqisi2
 6262              	.LVL543:
3961:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6263              		.loc 1 3961 0
 6264 3774 DC20D6E5 		ldrb	r2, [r6, #220]	@ zero_extendqisi2
3962:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6265              		.loc 1 3962 0
 6266 3778 DD90D6E5 		ldrb	r9, [r6, #221]	@ zero_extendqisi2
3963:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6267              		.loc 1 3963 0
 6268 377c DE30D6E5 		ldrb	r3, [r6, #222]	@ zero_extendqisi2
3958:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6269              		.loc 1 3958 0
 6270 3780 F5E6C5E5 		strb	lr, [r5, #1781]
3959:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6271              		.loc 1 3959 0
 6272 3784 F6C6C5E5 		strb	ip, [r5, #1782]
3960:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6273              		.loc 1 3960 0
 6274 3788 F706C5E5 		strb	r0, [r5, #1783]
3961:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6275              		.loc 1 3961 0
 6276 378c F826C5E5 		strb	r2, [r5, #1784]
3962:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6277              		.loc 1 3962 0
 6278 3790 F996C5E5 		strb	r9, [r5, #1785]
3963:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6279              		.loc 1 3963 0
 6280 3794 FA36C5E5 		strb	r3, [r5, #1786]
 6281              	.L527:
3965:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 6282              		.loc 1 3965 0
 6283 3798 D990D4E5 		ldrb	r9, [r4, #217]	@ zero_extendqisi2
 6284 379c D830D4E5 		ldrb	r3, [r4, #216]	@ zero_extendqisi2
 6285 37a0 BE22DDE1 		ldrh	r2, [sp, #46]
 6286              	.LVL544:
 6287 37a4 0400A0E3 		mov	r0, #4
 6288 37a8 18179FE5 		ldr	r1, .L605+76
 6289 37ac 00908DE5 		str	r9, [sp, #0]
 6290 37b0 FEFFFFEB 		bl	CyU3PDebugPrint
 6291 37b4 28309DE5 		ldr	r3, [sp, #40]
 6292 37b8 94FEFFEA 		b	.L478
 6293              	.LVL545:
 6294              	.L524:
3925:../uvc.c      ****                 switch (bRequest)
 6295              		.loc 1 3925 0
 6296 37bc 860052E3 		cmp	r2, #134
 6297 37c0 9BFFFF0A 		beq	.L588
 6298 37c4 870052E3 		cmp	r2, #135
 6299 37c8 BDFFFF1A 		bne	.L593
 6300 37cc CCFFFFEA 		b	.L530
 6301              	.LVL546:
 6302              	.L476:
 6303              	.LBE116:
 6304              	.LBE140:
 6305              	.LBB141:
 6306              	.LBB128:
3675:../uvc.c      ****     switch (wValue)
 6307              		.loc 1 3675 0
 6308 37d0 030B53E3 		cmp	r3, #3072
 6309 37d4 A401000A 		beq	.L465
 6310 37d8 0D0C53E3 		cmp	r3, #3328
 6311 37dc 7CFEFF1A 		bne	.L415
 6312              	.LVL547:
3732:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6313              		.loc 1 3732 0
 6314 37e0 1C00A0E3 		mov	r0, #28
 6315 37e4 FEFFFFEB 		bl	ControlHandle
 6316              	.LVL548:
 6317 37e8 28309DE5 		ldr	r3, [sp, #40]
 6318 37ec 7DFEFFEA 		b	.L414
 6319              	.L475:
3675:../uvc.c      ****     switch (wValue)
 6320              		.loc 1 3675 0
 6321 37f0 110C53E3 		cmp	r3, #4352
 6322 37f4 9801000A 		beq	.L469
 6323 37f8 5100008A 		bhi	.L477
 6324 37fc 010A53E3 		cmp	r3, #4096
 6325 3800 73FEFF1A 		bne	.L415
 6326              	.LVL549:
3744:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6327              		.loc 1 3744 0
 6328 3804 1F00A0E3 		mov	r0, #31
 6329 3808 FEFFFFEB 		bl	ControlHandle
 6330              	.LVL550:
 6331 380c 28309DE5 		ldr	r3, [sp, #40]
 6332 3810 74FEFFEA 		b	.L414
 6333              	.LVL551:
 6334              	.L599:
 6335              	.LBE128:
 6336              	.LBE141:
4322:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6337              		.loc 1 4322 0
 6338 3814 0400A0E3 		mov	r0, #4
 6339              	.LVL552:
 6340 3818 AC169FE5 		ldr	r1, .L605+80
 6341 381c FEFFFFEB 		bl	CyU3PDebugPrint
 6342              	.LVL553:
 6343              	.L564:
 6344              	.LBB142:
 6345              	.LBB143:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6346              		.loc 1 2041 0
 6347 3820 A8169FE5 		ldr	r1, .L605+84
 6348 3824 0400A0E3 		mov	r0, #4
 6349 3828 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 6350              		.loc 1 2042 0
 6351 382c FA0FA0E3 		mov	r0, #1000
 6352 3830 FEFFFFEB 		bl	_tx_thread_sleep
 6353 3834 F9FFFFEA 		b	.L564
 6354              	.L433:
 6355              	.LBE143:
 6356              	.LBE142:
 6357              	.LBB144:
 6358              	.LBB99:
3375:../uvc.c      ****     switch (wValue)
 6359              		.loc 1 3375 0
 6360 3838 010B52E3 		cmp	r2, #1024
 6361 383c 69FEFF0A 		beq	.L414
 6362 3840 050C52E3 		cmp	r2, #1280
 6363 3844 5EFEFF1A 		bne	.L435
 6364              	.LVL554:
3394:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6365              		.loc 1 3394 0
 6366 3848 0400A0E3 		mov	r0, #4
 6367 384c FEFFFFEB 		bl	ControlHandle
 6368              	.LVL555:
 6369 3850 28309DE5 		ldr	r3, [sp, #40]
 6370 3854 63FEFFEA 		b	.L414
 6371              	.LVL556:
 6372              	.L601:
 6373              	.LBE99:
 6374              	.LBE144:
4295:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 6375              		.loc 1 4295 0
 6376 3858 0400A0E3 		mov	r0, #4
 6377              	.LVL557:
 6378 385c 68169FE5 		ldr	r1, .L605+80
 6379 3860 FEFFFFEB 		bl	CyU3PDebugPrint
 6380              	.LVL558:
 6381              	.L562:
 6382              	.LBB145:
 6383              	.LBB146:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6384              		.loc 1 2041 0
 6385 3864 64169FE5 		ldr	r1, .L605+84
 6386 3868 0400A0E3 		mov	r0, #4
 6387 386c FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 6388              		.loc 1 2042 0
 6389 3870 FA0FA0E3 		mov	r0, #1000
 6390 3874 FEFFFFEB 		bl	_tx_thread_sleep
 6391 3878 F9FFFFEA 		b	.L562
 6392              	.L473:
 6393              	.LBE146:
 6394              	.LBE145:
 6395              	.LBB147:
 6396              	.LBB131:
3675:../uvc.c      ****     switch (wValue)
 6397              		.loc 1 3675 0
 6398 387c 060C53E3 		cmp	r3, #1536
 6399 3880 7101000A 		beq	.L459
 6400 3884 0F00008A 		bhi	.L474
 6401 3888 050C53E3 		cmp	r3, #1280
 6402 388c 50FEFF1A 		bne	.L415
 6403              	.LVL559:
3695:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6404              		.loc 1 3695 0
 6405 3890 1400A0E3 		mov	r0, #20
 6406 3894 FEFFFFEB 		bl	ControlHandle
 6407              	.LVL560:
 6408 3898 28309DE5 		ldr	r3, [sp, #40]
 6409 389c 51FEFFEA 		b	.L414
 6410              	.L449:
 6411              	.LBE131:
 6412              	.LBE147:
 6413              	.LBB148:
 6414              	.LBB109:
3450:../uvc.c      ****     switch (wValue)
 6415              		.loc 1 3450 0
 6416 38a0 0B0C52E3 		cmp	r2, #2816
 6417 38a4 6401000A 		beq	.L445
 6418 38a8 030B52E3 		cmp	r2, #3072
 6419 38ac 5E01000A 		beq	.L446
 6420 38b0 0A0C52E3 		cmp	r2, #2560
 6421 38b4 42FEFF1A 		bne	.L435
 6422              	.LVL561:
3491:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6423              		.loc 1 3491 0
 6424 38b8 0800A0E3 		mov	r0, #8
 6425 38bc FEFFFFEB 		bl	CTControlHandle
 6426              	.LVL562:
 6427 38c0 28309DE5 		ldr	r3, [sp, #40]
 6428 38c4 47FEFFEA 		b	.L414
 6429              	.L474:
 6430              	.LBE109:
 6431              	.LBE148:
 6432              	.LBB149:
 6433              	.LBB127:
3675:../uvc.c      ****     switch (wValue)
 6434              		.loc 1 3675 0
 6435 38c8 070C53E3 		cmp	r3, #1792
 6436 38cc 5201000A 		beq	.L460
 6437 38d0 020B53E3 		cmp	r3, #2048
 6438 38d4 3EFEFF1A 		bne	.L415
 6439              	.LVL563:
3707:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6440              		.loc 1 3707 0
 6441 38d8 1700A0E3 		mov	r0, #23
 6442 38dc FEFFFFEB 		bl	ControlHandle
 6443              	.LVL564:
 6444 38e0 28309DE5 		ldr	r3, [sp, #40]
 6445 38e4 3FFEFFEA 		b	.L414
 6446              	.L448:
 6447              	.LBE127:
 6448              	.LBE149:
 6449              	.LBB150:
 6450              	.LBB105:
3450:../uvc.c      ****     switch (wValue)
 6451              		.loc 1 3450 0
 6452 38e8 010B52E3 		cmp	r2, #1024
 6453 38ec 4601000A 		beq	.L439
 6454 38f0 050C52E3 		cmp	r2, #1280
 6455 38f4 32FEFF1A 		bne	.L435
 6456              	.LVL565:
3472:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6457              		.loc 1 3472 0
 6458 38f8 0400A0E3 		mov	r0, #4
 6459 38fc FEFFFFEB 		bl	CTControlHandle
 6460              	.LVL566:
 6461 3900 28309DE5 		ldr	r3, [sp, #40]
 6462 3904 37FEFFEA 		b	.L414
 6463              	.L434:
 6464              	.LBE105:
 6465              	.LBE150:
 6466              	.LBB151:
 6467              	.LBB96:
3375:../uvc.c      ****     switch (wValue)
 6468              		.loc 1 3375 0
 6469 3908 0D0C52E3 		cmp	r2, #3328
 6470 390c 1C00000A 		beq	.L429
 6471 3910 0E0C52E3 		cmp	r2, #3584
 6472 3914 D700000A 		beq	.L431
 6473 3918 030B52E3 		cmp	r2, #3072
 6474 391c 28FEFF1A 		bne	.L435
 6475              	.LVL567:
3416:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6476              		.loc 1 3416 0
 6477 3920 0B00A0E3 		mov	r0, #11
 6478 3924 FEFFFFEB 		bl	ControlHandle
 6479              	.LVL568:
 6480 3928 28309DE5 		ldr	r3, [sp, #40]
 6481 392c 2DFEFFEA 		b	.L414
 6482              	.LVL569:
 6483              	.L555:
 6484              	.LBE96:
 6485              	.LBE151:
 6486              	.LBB152:
 6487              	.LBB119:
4061:../uvc.c      ****             	switch (bRequest)
 6488              		.loc 1 4061 0
 6489 3930 850052E3 		cmp	r2, #133
 6490 3934 CC00000A 		beq	.L553
 6491 3938 860052E3 		cmp	r2, #134
 6492 393c 2EFEFF1A 		bne	.L480
 6493 3940 7BFFFFEA 		b	.L589
 6494              	.LVL570:
 6495              	.L477:
 6496              	.LBE119:
 6497              	.LBE152:
 6498              	.LBB153:
 6499              	.LBB132:
3675:../uvc.c      ****     switch (wValue)
 6500              		.loc 1 3675 0
 6501 3944 120C53E3 		cmp	r3, #4608
 6502 3948 C300000A 		beq	.L470
 6503 394c 130C53E3 		cmp	r3, #4864
 6504 3950 1FFEFF1A 		bne	.L415
 6505              	.LVL571:
3756:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6506              		.loc 1 3756 0
 6507 3954 2600A0E3 		mov	r0, #38
 6508 3958 FEFFFFEB 		bl	ControlHandle
 6509              	.LVL572:
 6510 395c 28309DE5 		ldr	r3, [sp, #40]
 6511 3960 20FEFFEA 		b	.L414
 6512              	.L464:
 6513              	.LVL573:
3722:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 6514              		.loc 1 3722 0
 6515 3964 1A00A0E3 		mov	r0, #26
 6516 3968 FEFFFFEB 		bl	ControlHandle
 6517              	.LVL574:
 6518 396c 28309DE5 		ldr	r3, [sp, #40]
 6519 3970 1CFEFFEA 		b	.L414
 6520              	.L427:
 6521              	.LVL575:
 6522              	.LBE132:
 6523              	.LBE153:
 6524              	.LBB154:
 6525              	.LBB100:
3402:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 6526              		.loc 1 3402 0
 6527 3974 0600A0E3 		mov	r0, #6
 6528 3978 FEFFFFEB 		bl	ControlHandle
 6529              	.LVL576:
 6530 397c 28309DE5 		ldr	r3, [sp, #40]
 6531 3980 18FEFFEA 		b	.L414
 6532              	.L429:
 6533              	.LVL577:
3412:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 6534              		.loc 1 3412 0
 6535 3984 0900A0E3 		mov	r0, #9
 6536 3988 FEFFFFEB 		bl	ControlHandle
 6537              	.LVL578:
 6538 398c 28309DE5 		ldr	r3, [sp, #40]
 6539 3990 14FEFFEA 		b	.L414
 6540              	.LVL579:
 6541              	.L557:
 6542              	.LBE100:
 6543              	.LBE154:
 6544              	.LBB155:
 6545              	.LBB115:
4104:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6546              		.loc 1 4104 0
 6547 3994 38159FE5 		ldr	r1, .L605+88
 6548 3998 BE22DDE1 		ldrh	r2, [sp, #46]
 6549 399c D830D4E5 		ldrb	r3, [r4, #216]	@ zero_extendqisi2
 6550 39a0 0400A0E3 		mov	r0, #4
 6551              	.LVL580:
 6552 39a4 FEFFFFEB 		bl	CyU3PDebugPrint
 6553 39a8 13FEFFEA 		b	.L480
 6554              	.LVL581:
 6555              	.L600:
3866:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6556              		.loc 1 3866 0
 6557 39ac 2000A0E3 		mov	r0, #32
 6558 39b0 F0149FE5 		ldr	r1, .L605+44
 6559 39b4 2E208DE2 		add	r2, sp, #46
 6560 39b8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6561              	.LVL582:
3868:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6562              		.loc 1 3868 0
 6563 39bc 000050E3 		cmp	r0, #0
 6564 39c0 11FEFF1A 		bne	.L584
3870:../uvc.c      ****                         switch (glCommitCtrl[3])
 6565              		.loc 1 3870 0
 6566 39c4 DB20D4E5 		ldrb	r2, [r4, #219]	@ zero_extendqisi2
 6567 39c8 011042E2 		sub	r1, r2, #1
 6568 39cc 030051E3 		cmp	r1, #3
 6569 39d0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6570 39d4 2E0000EA 		b	.L504
 6571              	.L509:
 6572 39d8 343B0000 		.word	.L505
 6573 39dc 803B0000 		.word	.L506
 6574 39e0 D83A0000 		.word	.L507
 6575 39e4 3C3A0000 		.word	.L508
 6576              	.LVL583:
 6577              	.L552:
4073:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6578              		.loc 1 4073 0
 6579 39e8 5C10D4E5 		ldrb	r1, [r4, #92]	@ zero_extendqisi2
 6580 39ec 030051E3 		cmp	r1, #3
 6581 39f0 0400000A 		beq	.L604
 6582              	.L556:
4079:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6583              		.loc 1 4079 0
 6584 39f4 1A00A0E3 		mov	r0, #26
 6585 39f8 D8149FE5 		ldr	r1, .L605+92
 6586 39fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6587 3a00 28309DE5 		ldr	r3, [sp, #40]
 6588 3a04 01FEFFEA 		b	.L478
 6589              	.L604:
4075:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6590              		.loc 1 4075 0
 6591 3a08 1A00A0E3 		mov	r0, #26
 6592 3a0c C8149FE5 		ldr	r1, .L605+96
 6593 3a10 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6594 3a14 28309DE5 		ldr	r3, [sp, #40]
 6595 3a18 FCFDFFEA 		b	.L478
 6596              	.LVL584:
 6597              	.L456:
 6598              	.LBE115:
 6599              	.LBE155:
 6600              	.LBB156:
 6601              	.LBB126:
3687:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 6602              		.loc 1 3687 0
 6603 3a1c 1200A0E3 		mov	r0, #18
 6604 3a20 FEFFFFEB 		bl	ControlHandle
 6605              	.LVL585:
 6606 3a24 28309DE5 		ldr	r3, [sp, #40]
 6607 3a28 EEFDFFEA 		b	.L414
 6608              	.L455:
 6609              	.LVL586:
3683:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 6610              		.loc 1 3683 0
 6611 3a2c 1100A0E3 		mov	r0, #17
 6612 3a30 FEFFFFEB 		bl	ControlHandle
 6613              	.LVL587:
 6614 3a34 28309DE5 		ldr	r3, [sp, #40]
 6615 3a38 EAFDFFEA 		b	.L414
 6616              	.LVL588:
 6617              	.L508:
 6618              	.LBE126:
 6619              	.LBE156:
 6620              	.LBB157:
 6621              	.LBB120:
3888:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6622              		.loc 1 3888 0
 6623 3a3c 6CC094E5 		ldr	ip, [r4, #108]
 6624 3a40 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 6625              	.LVL589:
 6626 3a44 00005CE3 		cmp	ip, #0
 6627 3a48 F4C0A003 		moveq	ip, #244
 6628 3a4c 74C0A013 		movne	ip, #116
 6629 3a50 00208CE1 		orr	r2, ip, r0
 6630 3a54 3010A0E3 		mov	r1, #48
 6631 3a58 5230A0E3 		mov	r3, #82
 6632 3a5c 0100A0E3 		mov	r0, #1
 6633 3a60 FEFFFFEB 		bl	SensorSetIrisControl
3889:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6634              		.loc 1 3889 0
 6635 3a64 7D0FA0E3 		mov	r0, #500
 6636 3a68 FEFFFFEB 		bl	_tx_thread_sleep
3890:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6637              		.loc 1 3890 0
 6638 3a6c 6C2094E5 		ldr	r2, [r4, #108]
 6639 3a70 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6640 3a74 000052E3 		cmp	r2, #0
 6641 3a78 F420A003 		moveq	r2, #244
 6642 3a7c 7420A013 		movne	r2, #116
 6643 3a80 6C3094E5 		ldr	r3, [r4, #108]
 6644 3a84 0400A0E3 		mov	r0, #4
 6645 3a88 50149FE5 		ldr	r1, .L605+100
 6646 3a8c 092082E1 		orr	r2, r2, r9
 6647 3a90 FEFFFFEB 		bl	CyU3PDebugPrint
 6648              	.L504:
3895:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6649              		.loc 1 3895 0
 6650 3a94 DBE0D4E5 		ldrb	lr, [r4, #219]	@ zero_extendqisi2
3896:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6651              		.loc 1 3896 0
 6652 3a98 44149FE5 		ldr	r1, .L605+104
 6653 3a9c 0E20A0E1 		mov	r2, lr
 6654 3aa0 0400A0E3 		mov	r0, #4
3895:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6655              		.loc 1 3895 0
 6656 3aa4 D5E0C4E5 		strb	lr, [r4, #213]
3896:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6657              		.loc 1 3896 0
 6658 3aa8 FEFFFFEB 		bl	CyU3PDebugPrint
3909:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6659              		.loc 1 3909 0
 6660 3aac 0020A0E3 		mov	r2, #0
 6661 3ab0 C4039FE5 		ldr	r0, .L605
 6662 3ab4 0110A0E3 		mov	r1, #1
 6663 3ab8 FEFFFFEB 		bl	_txe_event_flags_set
 6664              	.LVL590:
3910:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6665              		.loc 1 3910 0
 6666 3abc 002050E2 		subs	r2, r0, #0
 6667 3ac0 D1FDFF0A 		beq	.L584
3912:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6668              		.loc 1 3912 0
 6669 3ac4 0400A0E3 		mov	r0, #4
 6670              	.LVL591:
 6671 3ac8 18149FE5 		ldr	r1, .L605+108
 6672 3acc FEFFFFEB 		bl	CyU3PDebugPrint
 6673              	.LVL592:
 6674 3ad0 28309DE5 		ldr	r3, [sp, #40]
 6675 3ad4 CDFDFFEA 		b	.L478
 6676              	.LVL593:
 6677              	.L507:
3883:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6678              		.loc 1 3883 0
 6679 3ad8 6CE094E5 		ldr	lr, [r4, #108]
 6680 3adc 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6681 3ae0 00005EE3 		cmp	lr, #0
 6682 3ae4 C4E0A003 		moveq	lr, #196
 6683 3ae8 44E0A013 		movne	lr, #68
 6684 3aec 03208EE1 		orr	r2, lr, r3
 6685 3af0 3010A0E3 		mov	r1, #48
 6686 3af4 5230A0E3 		mov	r3, #82
 6687 3af8 0100A0E3 		mov	r0, #1
 6688              	.LVL594:
 6689 3afc FEFFFFEB 		bl	SensorSetIrisControl
3884:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6690              		.loc 1 3884 0
 6691 3b00 7D0FA0E3 		mov	r0, #500
 6692 3b04 FEFFFFEB 		bl	_tx_thread_sleep
3885:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6693              		.loc 1 3885 0
 6694 3b08 6C0094E5 		ldr	r0, [r4, #108]
 6695 3b0c 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6696 3b10 000050E3 		cmp	r0, #0
 6697 3b14 C400A003 		moveq	r0, #196
 6698 3b18 4400A013 		movne	r0, #68
 6699 3b1c 0C2080E1 		orr	r2, r0, ip
 6700 3b20 6C3094E5 		ldr	r3, [r4, #108]
 6701 3b24 B4139FE5 		ldr	r1, .L605+100
 6702 3b28 0400A0E3 		mov	r0, #4
 6703 3b2c FEFFFFEB 		bl	CyU3PDebugPrint
 6704 3b30 D7FFFFEA 		b	.L504
 6705              	.LVL595:
 6706              	.L505:
3873:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6707              		.loc 1 3873 0
 6708 3b34 6C2094E5 		ldr	r2, [r4, #108]
 6709 3b38 3010A0E3 		mov	r1, #48
 6710 3b3c 000052E3 		cmp	r2, #0
 6711 3b40 E420A003 		moveq	r2, #228
 6712 3b44 6420A013 		movne	r2, #100
 6713 3b48 5230A0E3 		mov	r3, #82
 6714 3b4c 0100A0E3 		mov	r0, #1
 6715              	.LVL596:
 6716 3b50 FEFFFFEB 		bl	SensorSetIrisControl
3874:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6717              		.loc 1 3874 0
 6718 3b54 7D0FA0E3 		mov	r0, #500
 6719 3b58 FEFFFFEB 		bl	_tx_thread_sleep
3875:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6720              		.loc 1 3875 0
 6721 3b5c 6C2094E5 		ldr	r2, [r4, #108]
 6722 3b60 78139FE5 		ldr	r1, .L605+100
 6723 3b64 000052E3 		cmp	r2, #0
 6724 3b68 6C3094E5 		ldr	r3, [r4, #108]
 6725 3b6c E420A003 		moveq	r2, #228
 6726 3b70 6420A013 		movne	r2, #100
 6727 3b74 0400A0E3 		mov	r0, #4
 6728 3b78 FEFFFFEB 		bl	CyU3PDebugPrint
 6729 3b7c C4FFFFEA 		b	.L504
 6730              	.LVL597:
 6731              	.L506:
3878:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6732              		.loc 1 3878 0
 6733 3b80 6C2094E5 		ldr	r2, [r4, #108]
 6734 3b84 3010A0E3 		mov	r1, #48
 6735 3b88 000052E3 		cmp	r2, #0
 6736 3b8c D420A003 		moveq	r2, #212
 6737 3b90 5420A013 		movne	r2, #84
 6738 3b94 5230A0E3 		mov	r3, #82
 6739 3b98 0100A0E3 		mov	r0, #1
 6740              	.LVL598:
 6741 3b9c FEFFFFEB 		bl	SensorSetIrisControl
3879:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6742              		.loc 1 3879 0
 6743 3ba0 7D0FA0E3 		mov	r0, #500
 6744 3ba4 FEFFFFEB 		bl	_tx_thread_sleep
3880:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6745              		.loc 1 3880 0
 6746 3ba8 6C2094E5 		ldr	r2, [r4, #108]
 6747 3bac 2C139FE5 		ldr	r1, .L605+100
 6748 3bb0 000052E3 		cmp	r2, #0
 6749 3bb4 6C3094E5 		ldr	r3, [r4, #108]
 6750 3bb8 D420A003 		moveq	r2, #212
 6751 3bbc 5420A013 		movne	r2, #84
 6752 3bc0 0400A0E3 		mov	r0, #4
 6753 3bc4 FEFFFFEB 		bl	CyU3PDebugPrint
 6754 3bc8 B1FFFFEA 		b	.L504
 6755              	.L467:
 6756              	.LVL599:
 6757              	.LBE120:
 6758              	.LBE157:
 6759              	.LBB158:
 6760              	.LBB133:
3740:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 6761              		.loc 1 3740 0
 6762 3bcc 1E00A0E3 		mov	r0, #30
 6763 3bd0 FEFFFFEB 		bl	ControlHandle
 6764              	.LVL600:
 6765 3bd4 28309DE5 		ldr	r3, [sp, #40]
 6766 3bd8 82FDFFEA 		b	.L414
 6767              	.L442:
 6768              	.LVL601:
 6769              	.LBE133:
 6770              	.LBE158:
 6771              	.LBB159:
 6772              	.LBB110:
3480:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 6773              		.loc 1 3480 0
 6774 3bdc 0600A0E3 		mov	r0, #6
 6775 3be0 FEFFFFEB 		bl	CTControlHandle
 6776              	.LVL602:
 6777 3be4 28309DE5 		ldr	r3, [sp, #40]
 6778 3be8 7EFDFFEA 		b	.L414
 6779              	.L443:
 6780              	.LVL603:
3486:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 6781              		.loc 1 3486 0
 6782 3bec 0700A0E3 		mov	r0, #7
 6783 3bf0 FEFFFFEB 		bl	CTControlHandle
 6784              	.LVL604:
 6785 3bf4 28309DE5 		ldr	r3, [sp, #40]
 6786 3bf8 7AFDFFEA 		b	.L414
 6787              	.L424:
 6788              	.LVL605:
 6789              	.LBE110:
 6790              	.LBE159:
 6791              	.LBB160:
 6792              	.LBB95:
3387:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 6793              		.loc 1 3387 0
 6794 3bfc 0200A0E3 		mov	r0, #2
 6795 3c00 FEFFFFEB 		bl	ControlHandle
 6796              	.LVL606:
 6797 3c04 28309DE5 		ldr	r3, [sp, #40]
 6798 3c08 76FDFFEA 		b	.L414
 6799              	.L426:
 6800              	.LVL607:
3398:../uvc.c      ****      		ControlHandle(HueCtlID5);
 6801              		.loc 1 3398 0
 6802 3c0c 0500A0E3 		mov	r0, #5
 6803 3c10 FEFFFFEB 		bl	ControlHandle
 6804              	.LVL608:
 6805 3c14 28309DE5 		ldr	r3, [sp, #40]
 6806 3c18 72FDFFEA 		b	.L414
 6807              	.L457:
 6808              	.LVL609:
 6809              	.LBE95:
 6810              	.LBE160:
 6811              	.LBB161:
 6812              	.LBB125:
3691:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6813              		.loc 1 3691 0
 6814 3c1c 1300A0E3 		mov	r0, #19
 6815 3c20 FEFFFFEB 		bl	ControlHandle
 6816              	.LVL610:
 6817 3c24 28309DE5 		ldr	r3, [sp, #40]
 6818 3c28 6EFDFFEA 		b	.L414
 6819              	.L462:
 6820              	.LVL611:
3711:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6821              		.loc 1 3711 0
 6822 3c2c 1800A0E3 		mov	r0, #24
 6823 3c30 FEFFFFEB 		bl	ControlHandle
 6824              	.LVL612:
 6825 3c34 28309DE5 		ldr	r3, [sp, #40]
 6826 3c38 6AFDFFEA 		b	.L414
 6827              	.L436:
 6828              	.LVL613:
 6829              	.LBE125:
 6830              	.LBE161:
 6831              	.LBB162:
 6832              	.LBB104:
3454:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6833              		.loc 1 3454 0
 6834 3c3c 0000A0E3 		mov	r0, #0
 6835 3c40 FEFFFFEB 		bl	CTControlHandle
 6836              	.LVL614:
 6837 3c44 28309DE5 		ldr	r3, [sp, #40]
 6838 3c48 66FDFFEA 		b	.L414
 6839              	.L438:
 6840              	.LVL615:
3462:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6841              		.loc 1 3462 0
 6842 3c4c 0200A0E3 		mov	r0, #2
 6843 3c50 FEFFFFEB 		bl	CTControlHandle
 6844              	.LVL616:
 6845 3c54 28309DE5 		ldr	r3, [sp, #40]
 6846 3c58 62FDFFEA 		b	.L414
 6847              	.L470:
 6848              	.LVL617:
 6849              	.LBE104:
 6850              	.LBE162:
 6851              	.LBB163:
 6852              	.LBB134:
3752:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6853              		.loc 1 3752 0
 6854 3c5c 2500A0E3 		mov	r0, #37
 6855 3c60 FEFFFFEB 		bl	ControlHandle
 6856              	.LVL618:
 6857 3c64 28309DE5 		ldr	r3, [sp, #40]
 6858 3c68 5EFDFFEA 		b	.L414
 6859              	.LVL619:
 6860              	.L553:
 6861              	.LBE134:
 6862              	.LBE163:
 6863              	.LBB164:
 6864              	.LBB114:
4070:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6865              		.loc 1 4070 0
 6866 3c6c 0200A0E3 		mov	r0, #2
 6867 3c70 44129FE5 		ldr	r1, .L605+64
 6868 3c74 97FEFFEA 		b	.L585
 6869              	.LVL620:
 6870              	.L431:
 6871              	.LBE114:
 6872              	.LBE164:
 6873              	.LBB165:
 6874              	.LBB101:
3420:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6875              		.loc 1 3420 0
 6876 3c78 0E00A0E3 		mov	r0, #14
 6877 3c7c FEFFFFEB 		bl	ControlHandle
 6878              	.LVL621:
 6879 3c80 28309DE5 		ldr	r3, [sp, #40]
 6880 3c84 57FDFFEA 		b	.L414
 6881              	.L596:
 6882              	.LVL622:
3383:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6883              		.loc 1 3383 0
 6884 3c88 0100A0E3 		mov	r0, #1
 6885 3c8c FEFFFFEB 		bl	ControlHandle
 6886              	.LVL623:
 6887 3c90 28309DE5 		ldr	r3, [sp, #40]
 6888 3c94 53FDFFEA 		b	.L414
 6889              	.L422:
 6890              	.LVL624:
3379:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6891              		.loc 1 3379 0
 6892 3c98 0000A0E3 		mov	r0, #0
 6893 3c9c FEFFFFEB 		bl	ControlHandle
 6894              	.LVL625:
 6895 3ca0 28309DE5 		ldr	r3, [sp, #40]
 6896 3ca4 4FFDFFEA 		b	.L414
 6897              	.L441:
 6898              	.LVL626:
 6899              	.LBE101:
 6900              	.LBE165:
 6901              	.LBB166:
 6902              	.LBB111:
3476:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6903              		.loc 1 3476 0
 6904 3ca8 0500A0E3 		mov	r0, #5
 6905 3cac FEFFFFEB 		bl	CTControlHandle
 6906              	.LVL627:
 6907 3cb0 28309DE5 		ldr	r3, [sp, #40]
 6908 3cb4 4BFDFFEA 		b	.L414
 6909              	.LVL628:
 6910              	.L540:
 6911              	.LBE111:
 6912              	.LBE166:
 6913              	.LBB167:
 6914              	.LBB121:
4024:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6915              		.loc 1 4024 0
 6916 3cb8 6C2094E5 		ldr	r2, [r4, #108]
 6917 3cbc 3010A0E3 		mov	r1, #48
 6918 3cc0 000052E3 		cmp	r2, #0
 6919 3cc4 E420A003 		moveq	r2, #228
 6920 3cc8 6420A013 		movne	r2, #100
 6921 3ccc 5230A0E3 		mov	r3, #82
 6922 3cd0 0100A0E3 		mov	r0, #1
 6923              	.LVL629:
 6924 3cd4 FEFFFFEB 		bl	SensorSetIrisControl
4026:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6925              		.loc 1 4026 0
 6926 3cd8 6C2094E5 		ldr	r2, [r4, #108]
 6927 3cdc 08129FE5 		ldr	r1, .L605+112
 6928 3ce0 000052E3 		cmp	r2, #0
 6929 3ce4 6C3094E5 		ldr	r3, [r4, #108]
 6930 3ce8 E420A003 		moveq	r2, #228
 6931 3cec 6420A013 		movne	r2, #100
 6932 3cf0 0400A0E3 		mov	r0, #4
 6933 3cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 6934              	.L536:
4046:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6935              		.loc 1 4046 0
 6936 3cf8 D9E0D4E5 		ldrb	lr, [r4, #217]	@ zero_extendqisi2
4048:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6937              		.loc 1 4048 0
 6938 3cfc D830D4E5 		ldrb	r3, [r4, #216]	@ zero_extendqisi2
 6939 3d00 BE22DDE1 		ldrh	r2, [sp, #46]
 6940              	.LVL630:
 6941 3d04 0400A0E3 		mov	r0, #4
 6942 3d08 E0119FE5 		ldr	r1, .L605+116
4046:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6943              		.loc 1 4046 0
 6944 3d0c F8E0C4E5 		strb	lr, [r4, #248]
4048:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6945              		.loc 1 4048 0
 6946 3d10 00E08DE5 		str	lr, [sp, #0]
 6947 3d14 FEFFFFEB 		bl	CyU3PDebugPrint
 6948 3d18 28309DE5 		ldr	r3, [sp, #40]
 6949 3d1c 3BFDFFEA 		b	.L478
 6950              	.LVL631:
 6951              	.L539:
4029:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6952              		.loc 1 4029 0
 6953 3d20 6C2094E5 		ldr	r2, [r4, #108]
 6954 3d24 3010A0E3 		mov	r1, #48
 6955 3d28 000052E3 		cmp	r2, #0
 6956 3d2c D420A003 		moveq	r2, #212
 6957 3d30 5420A013 		movne	r2, #84
 6958 3d34 5230A0E3 		mov	r3, #82
 6959 3d38 0100A0E3 		mov	r0, #1
 6960              	.LVL632:
 6961 3d3c FEFFFFEB 		bl	SensorSetIrisControl
4031:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6962              		.loc 1 4031 0
 6963 3d40 6C2094E5 		ldr	r2, [r4, #108]
 6964 3d44 A0119FE5 		ldr	r1, .L605+112
 6965 3d48 000052E3 		cmp	r2, #0
 6966 3d4c 6C3094E5 		ldr	r3, [r4, #108]
 6967 3d50 D420A003 		moveq	r2, #212
 6968 3d54 5420A013 		movne	r2, #84
 6969 3d58 0400A0E3 		mov	r0, #4
 6970 3d5c FEFFFFEB 		bl	CyU3PDebugPrint
 6971 3d60 E4FFFFEA 		b	.L536
 6972              	.LVL633:
 6973              	.L537:
4039:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6974              		.loc 1 4039 0
 6975 3d64 6C0094E5 		ldr	r0, [r4, #108]
 6976              	.LVL634:
 6977 3d68 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6978 3d6c 000050E3 		cmp	r0, #0
 6979 3d70 F400A003 		moveq	r0, #244
 6980 3d74 7400A013 		movne	r0, #116
 6981 3d78 032080E1 		orr	r2, r0, r3
 6982 3d7c 3010A0E3 		mov	r1, #48
 6983 3d80 5230A0E3 		mov	r3, #82
 6984 3d84 0100A0E3 		mov	r0, #1
 6985 3d88 FEFFFFEB 		bl	SensorSetIrisControl
4041:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6986              		.loc 1 4041 0
 6987 3d8c 6CC094E5 		ldr	ip, [r4, #108]
 6988 3d90 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6989 3d94 00005CE3 		cmp	ip, #0
 6990 3d98 F4C0A003 		moveq	ip, #244
 6991 3d9c 74C0A013 		movne	ip, #116
 6992 3da0 6C3094E5 		ldr	r3, [r4, #108]
 6993 3da4 40119FE5 		ldr	r1, .L605+112
 6994 3da8 02208CE1 		orr	r2, ip, r2
 6995 3dac 0400A0E3 		mov	r0, #4
 6996 3db0 FEFFFFEB 		bl	CyU3PDebugPrint
 6997 3db4 CFFFFFEA 		b	.L536
 6998              	.LVL635:
 6999              	.L538:
4034:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 7000              		.loc 1 4034 0
 7001 3db8 6CE094E5 		ldr	lr, [r4, #108]
 7002 3dbc 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 7003 3dc0 00005EE3 		cmp	lr, #0
 7004 3dc4 C4E0A003 		moveq	lr, #196
 7005 3dc8 44E0A013 		movne	lr, #68
 7006 3dcc 09208EE1 		orr	r2, lr, r9
 7007 3dd0 3010A0E3 		mov	r1, #48
 7008 3dd4 5230A0E3 		mov	r3, #82
 7009 3dd8 0100A0E3 		mov	r0, #1
 7010              	.LVL636:
 7011 3ddc FEFFFFEB 		bl	SensorSetIrisControl
4036:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 7012              		.loc 1 4036 0
 7013 3de0 6C0094E5 		ldr	r0, [r4, #108]
 7014 3de4 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 7015 3de8 000050E3 		cmp	r0, #0
 7016 3dec C400A003 		moveq	r0, #196
 7017 3df0 4400A013 		movne	r0, #68
 7018 3df4 0C2080E1 		orr	r2, r0, ip
 7019 3df8 6C3094E5 		ldr	r3, [r4, #108]
 7020 3dfc E8109FE5 		ldr	r1, .L605+112
 7021 3e00 0400A0E3 		mov	r0, #4
 7022 3e04 FEFFFFEB 		bl	CyU3PDebugPrint
 7023 3e08 BAFFFFEA 		b	.L536
 7024              	.L439:
 7025              	.LVL637:
 7026              	.LBE121:
 7027              	.LBE167:
 7028              	.LBB168:
 7029              	.LBB103:
3467:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 7030              		.loc 1 3467 0
 7031 3e0c 0300A0E3 		mov	r0, #3
 7032 3e10 FEFFFFEB 		bl	CTControlHandle
 7033              	.LVL638:
 7034 3e14 28309DE5 		ldr	r3, [sp, #40]
 7035 3e18 F2FCFFEA 		b	.L414
 7036              	.L460:
 7037              	.LVL639:
 7038              	.LBE103:
 7039              	.LBE168:
 7040              	.LBB169:
 7041              	.LBB124:
3703:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 7042              		.loc 1 3703 0
 7043 3e1c 1600A0E3 		mov	r0, #22
 7044 3e20 FEFFFFEB 		bl	ControlHandle
 7045              	.LVL640:
 7046 3e24 28309DE5 		ldr	r3, [sp, #40]
 7047 3e28 EEFCFFEA 		b	.L414
 7048              	.L446:
 7049              	.LVL641:
 7050              	.LBE124:
 7051              	.LBE169:
 7052              	.LBB170:
 7053              	.LBB112:
3499:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 7054              		.loc 1 3499 0
 7055 3e2c 0A00A0E3 		mov	r0, #10
 7056 3e30 FEFFFFEB 		bl	CTControlHandle
 7057              	.LVL642:
 7058 3e34 28309DE5 		ldr	r3, [sp, #40]
 7059 3e38 EAFCFFEA 		b	.L414
 7060              	.L445:
 7061              	.LVL643:
3495:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 7062              		.loc 1 3495 0
 7063 3e3c 0900A0E3 		mov	r0, #9
 7064 3e40 FEFFFFEB 		bl	CTControlHandle
 7065              	.LVL644:
 7066 3e44 28309DE5 		ldr	r3, [sp, #40]
 7067 3e48 E6FCFFEA 		b	.L414
 7068              	.L459:
 7069              	.LVL645:
 7070              	.LBE112:
 7071              	.LBE170:
 7072              	.LBB171:
 7073              	.LBB135:
3699:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 7074              		.loc 1 3699 0
 7075 3e4c 1500A0E3 		mov	r0, #21
 7076 3e50 FEFFFFEB 		bl	ControlHandle
 7077              	.LVL646:
 7078 3e54 28309DE5 		ldr	r3, [sp, #40]
 7079 3e58 E2FCFFEA 		b	.L414
 7080              	.L469:
 7081              	.LVL647:
3748:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 7082              		.loc 1 3748 0
 7083 3e5c 2400A0E3 		mov	r0, #36
 7084 3e60 FEFFFFEB 		bl	ControlHandle
 7085              	.LVL648:
 7086 3e64 28309DE5 		ldr	r3, [sp, #40]
 7087 3e68 DEFCFFEA 		b	.L414
 7088              	.L465:
 7089              	.LVL649:
3726:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 7090              		.loc 1 3726 0
 7091 3e6c 1B00A0E3 		mov	r0, #27
 7092 3e70 FEFFFFEB 		bl	ControlHandle
 7093              	.LVL650:
 7094 3e74 28309DE5 		ldr	r3, [sp, #40]
 7095 3e78 DAFCFFEA 		b	.L414
 7096              	.L606:
 7097              		.align	2
 7098              	.L605:
 7099 3e7c 00000000 		.word	.LANCHOR0
 7100 3e80 00000000 		.word	.LANCHOR1
 7101 3e84 00000000 		.word	bRequest
 7102 3e88 00000000 		.word	wValue
 7103 3e8c 00000000 		.word	wIndex
 7104 3e90 00000000 		.word	glInterStaBuffer
 7105 3e94 7C060000 		.word	.LC36
 7106 3e98 00000000 		.word	glChHandleInterStat
 7107 3e9c 00000000 		.word	bmReqType
 7108 3ea0 00000000 		.word	wLength
 7109 3ea4 00060000 		.word	.LC35
 7110 3ea8 D8000000 		.word	.LANCHOR0+216
 7111 3eac 94070000 		.word	.LC43
 7112 3eb0 B8070000 		.word	.LC44
 7113 3eb4 A0060000 		.word	.LANCHOR1+1696
 7114 3eb8 A8060000 		.word	.LC37
 7115 3ebc 74000000 		.word	.LANCHOR0+116
 7116 3ec0 F4060000 		.word	.LANCHOR1+1780
 7117 3ec4 00070000 		.word	.LANCHOR1+1792
 7118 3ec8 1C070000 		.word	.LC40
 7119 3ecc 0C080000 		.word	.LC46
 7120 3ed0 18020000 		.word	.LC14
 7121 3ed4 E4070000 		.word	.LC45
 7122 3ed8 BC060000 		.word	.LANCHOR1+1724
 7123 3edc D8060000 		.word	.LANCHOR1+1752
 7124 3ee0 D0060000 		.word	.LC38
 7125 3ee4 F4060000 		.word	.LC39
 7126 3ee8 50000000 		.word	.LC3
 7127 3eec 48070000 		.word	.LC41
 7128 3ef0 6C070000 		.word	.LC42
 7129              	.LBE135:
 7130              	.LBE171:
 7131              		.cfi_endproc
 7132              	.LFE25:
 7134              		.align	2
 7135              		.global	CamDefSet
 7137              	CamDefSet:
 7138              	.LFB5:
1934:../uvc.c      **** {
 7139              		.loc 1 1934 0
 7140              		.cfi_startproc
 7141              		@ args = 0, pretend = 0, frame = 24
 7142              		@ frame_needed = 0, uses_anonymous_args = 0
 7143              	.LVL651:
 7144 3ef4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7145              	.LCFI22:
 7146              		.cfi_def_cfa_offset 36
1941:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7147              		.loc 1 1941 0
 7148 3ef8 B0429FE5 		ldr	r4, .L610
 7149              		.cfi_offset 14, -4
 7150              		.cfi_offset 11, -8
 7151              		.cfi_offset 10, -12
 7152              		.cfi_offset 9, -16
 7153              		.cfi_offset 8, -20
 7154              		.cfi_offset 7, -24
 7155              		.cfi_offset 6, -28
 7156              		.cfi_offset 5, -32
 7157              		.cfi_offset 4, -36
1946:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7158              		.loc 1 1946 0
 7159 3efc B0229FE5 		ldr	r2, .L610+4
1943:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 7160              		.loc 1 1943 0
 7161 3f00 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1934:../uvc.c      **** {
 7162              		.loc 1 1934 0
 7163 3f04 2CD04DE2 		sub	sp, sp, #44
 7164              	.LCFI23:
 7165              		.cfi_def_cfa_offset 80
1946:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7166              		.loc 1 1946 0
 7167 3f08 1C0092E5 		ldr	r0, [r2, #28]
 7168 3f0c 0010E0E3 		mvn	r1, #0
1948:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7169              		.loc 1 1948 0
 7170 3f10 2963A0E1 		mov	r6, r9, lsr #6
1942:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7171              		.loc 1 1942 0
 7172 3f14 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1941:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7173              		.loc 1 1941 0
 7174 3f18 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 7175              	.LVL652:
1946:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7176              		.loc 1 1946 0
 7177 3f1c FEFFFFEB 		bl	_txe_mutex_get
1947:../uvc.c      ****     if(Data1&0x80){
 7178              		.loc 1 1947 0
 7179 3f20 800019E3 		tst	r9, #128
1948:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7180              		.loc 1 1948 0
 7181 3f24 01600612 		andne	r6, r6, #1
 7182 3f28 0660E011 		mvnne	r6, r6
 7183 3f2c 3B600612 		andne	r6, r6, #59
 7184 3f30 0660E011 		mvnne	r6, r6
 7185 3f34 FF600612 		andne	r6, r6, #255
 7186              	.LVL653:
1950:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 7187              		.loc 1 1950 0
 7188 3f38 C6608603 		orreq	r6, r6, #198
 7189              	.LVL654:
1954:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7190              		.loc 1 1954 0
 7191 3f3c 0080A0E3 		mov	r8, #0
 7192 3f40 0A20A0E1 		mov	r2, sl
 7193 3f44 0730A0E1 		mov	r3, r7
 7194 3f48 0110A0E3 		mov	r1, #1
1952:../uvc.c      ****     Data0 = (Data0 << 2);
 7195              		.loc 1 1952 0
 7196 3f4c 0951A0E1 		mov	r5, r9, asl #2
1954:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7197              		.loc 1 1954 0
 7198 3f50 5C029FE5 		ldr	r0, .L610+4
1957:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7199              		.loc 1 1957 0
 7200 3f54 0190A0E3 		mov	r9, #1
 7201              	.LVL655:
1952:../uvc.c      ****     Data0 = (Data0 << 2);
 7202              		.loc 1 1952 0
 7203 3f58 FF5005E2 		and	r5, r5, #255
 7204              	.LVL656:
1954:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7205              		.loc 1 1954 0
 7206 3f5c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7207 3f60 FEFFFFEB 		bl	cmdSet
 7208              	.LVL657:
1957:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7209              		.loc 1 1957 0
 7210 3f64 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 7211 3f68 0910A0E1 		mov	r1, r9
 7212 3f6c 0730A0E1 		mov	r3, r7
 7213 3f70 3C029FE5 		ldr	r0, .L610+4
 7214 3f74 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 7215 3f78 FEFFFFEB 		bl	cmdSet
 7216              	.LVL658:
1960:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7217              		.loc 1 1960 0
 7218 3f7c 0620A0E1 		mov	r2, r6
 7219 3f80 0530A0E1 		mov	r3, r5
 7220 3f84 2C129FE5 		ldr	r1, .L610+8
 7221 3f88 0400A0E3 		mov	r0, #4
1959:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 7222              		.loc 1 1959 0
 7223 3f8c A661C4E5 		strb	r6, [r4, #422]
1958:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7224              		.loc 1 1958 0
 7225 3f90 A551C4E5 		strb	r5, [r4, #421]
1960:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7226              		.loc 1 1960 0
 7227 3f94 FEFFFFEB 		bl	CyU3PDebugPrint
 7228              	.LVL659:
1965:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7229              		.loc 1 1965 0
 7230 3f98 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 7231              	.LVL660:
1966:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 7232              		.loc 1 1966 0
 7233 3f9c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 7234 3fa0 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 7235 3fa4 0210A0E3 		mov	r1, #2
 7236 3fa8 04029FE5 		ldr	r0, .L610+4
 7237 3fac 00B08DE5 		str	fp, [sp, #0]
 7238 3fb0 04808DE5 		str	r8, [sp, #4]
 7239 3fb4 FEFFFFEB 		bl	cmdSet
 7240              	.LVL661:
1969:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7241              		.loc 1 1969 0
 7242 3fb8 0B20A0E1 		mov	r2, fp
 7243 3fbc 0530A0E1 		mov	r3, r5
 7244 3fc0 F0119FE5 		ldr	r1, .L610+8
 7245 3fc4 0400A0E3 		mov	r0, #4
1967:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7246              		.loc 1 1967 0
 7247 3fc8 BD51C4E5 		strb	r5, [r4, #445]
1968:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 7248              		.loc 1 1968 0
 7249 3fcc FD53C4E5 		strb	r5, [r4, #1021]
1969:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7250              		.loc 1 1969 0
 7251 3fd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7252              	.LVL662:
1974:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7253              		.loc 1 1974 0
 7254 3fd4 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1973:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7255              		.loc 1 1973 0
 7256 3fd8 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 7257              	.LVL663:
1975:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7258              		.loc 1 1975 0
 7259 3fdc 80B047E2 		sub	fp, r7, #128
 7260 3fe0 FF100BE2 		and	r1, fp, #255
 7261 3fe4 14108DE5 		str	r1, [sp, #20]
 7262 3fe8 14C09DE5 		ldr	ip, [sp, #20]
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7263              		.loc 1 1976 0
 7264 3fec 760047E2 		sub	r0, r7, #118
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7265              		.loc 1 1977 0
 7266 3ff0 7EE087E2 		add	lr, r7, #126
1975:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7267              		.loc 1 1975 0
 7268 3ff4 0630A0E1 		mov	r3, r6
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7269              		.loc 1 1976 0
 7270 3ff8 18008DE5 		str	r0, [sp, #24]
1975:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7271              		.loc 1 1975 0
 7272 3ffc 0510A0E3 		mov	r1, #5
 7273 4000 DF20A0E3 		mov	r2, #223
 7274 4004 A8019FE5 		ldr	r0, .L610+4
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7275              		.loc 1 1977 0
 7276 4008 1CE08DE5 		str	lr, [sp, #28]
1975:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7277              		.loc 1 1975 0
 7278 400c 00C08DE5 		str	ip, [sp, #0]
 7279 4010 04808DE5 		str	r8, [sp, #4]
 7280 4014 FEFFFFEB 		bl	cmdSet
 7281              	.LVL664:
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7282              		.loc 1 1976 0
 7283 4018 18A09DE5 		ldr	sl, [sp, #24]
1978:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7284              		.loc 1 1978 0
 7285 401c 72E087E2 		add	lr, r7, #114
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7286              		.loc 1 1976 0
 7287 4020 FFC00AE2 		and	ip, sl, #255
 7288 4024 0630A0E1 		mov	r3, r6
 7289 4028 0510A0E3 		mov	r1, #5
 7290 402c DC20A0E3 		mov	r2, #220
 7291 4030 7C019FE5 		ldr	r0, .L610+4
1978:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7292              		.loc 1 1978 0
 7293 4034 20E08DE5 		str	lr, [sp, #32]
1976:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7294              		.loc 1 1976 0
 7295 4038 00C08DE5 		str	ip, [sp, #0]
 7296 403c 04908DE5 		str	r9, [sp, #4]
 7297 4040 FEFFFFEB 		bl	cmdSet
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7298              		.loc 1 1977 0
 7299 4044 1C009DE5 		ldr	r0, [sp, #28]
 7300 4048 02E0A0E3 		mov	lr, #2
 7301 404c FFC000E2 		and	ip, r0, #255
 7302 4050 0630A0E1 		mov	r3, r6
1979:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7303              		.loc 1 1979 0
 7304 4054 6FA047E2 		sub	sl, r7, #111
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7305              		.loc 1 1977 0
 7306 4058 0510A0E3 		mov	r1, #5
 7307 405c DE20A0E3 		mov	r2, #222
 7308 4060 4C019FE5 		ldr	r0, .L610+4
 7309 4064 04E08DE5 		str	lr, [sp, #4]
1979:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7310              		.loc 1 1979 0
 7311 4068 24A08DE5 		str	sl, [sp, #36]
1977:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7312              		.loc 1 1977 0
 7313 406c 00C08DE5 		str	ip, [sp, #0]
 7314 4070 FEFFFFEB 		bl	cmdSet
1978:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7315              		.loc 1 1978 0
 7316 4074 20A09DE5 		ldr	sl, [sp, #32]
 7317 4078 0630A0E1 		mov	r3, r6
 7318 407c FFC00AE2 		and	ip, sl, #255
 7319 4080 00C08DE5 		str	ip, [sp, #0]
 7320 4084 0510A0E3 		mov	r1, #5
 7321 4088 03C0A0E3 		mov	ip, #3
 7322 408c E020A0E3 		mov	r2, #224
 7323 4090 1C019FE5 		ldr	r0, .L610+4
 7324 4094 04C08DE5 		str	ip, [sp, #4]
 7325 4098 FEFFFFEB 		bl	cmdSet
1979:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7326              		.loc 1 1979 0
 7327 409c 24009DE5 		ldr	r0, [sp, #36]
 7328 40a0 04A0A0E3 		mov	sl, #4
 7329 40a4 FFC000E2 		and	ip, r0, #255
 7330 40a8 0630A0E1 		mov	r3, r6
 7331 40ac 0510A0E3 		mov	r1, #5
 7332 40b0 DD20A0E3 		mov	r2, #221
 7333 40b4 F8009FE5 		ldr	r0, .L610+4
 7334 40b8 00C08DE5 		str	ip, [sp, #0]
1980:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7335              		.loc 1 1980 0
 7336 40bc 7F7087E2 		add	r7, r7, #127
 7337              	.LVL665:
1979:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7338              		.loc 1 1979 0
 7339 40c0 04A08DE5 		str	sl, [sp, #4]
 7340 40c4 FEFFFFEB 		bl	cmdSet
1980:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7341              		.loc 1 1980 0
 7342 40c8 05E0A0E3 		mov	lr, #5
 7343 40cc 0E10A0E1 		mov	r1, lr
 7344 40d0 0630A0E1 		mov	r3, r6
 7345 40d4 E120A0E3 		mov	r2, #225
 7346 40d8 FF6007E2 		and	r6, r7, #255
 7347              	.LVL666:
 7348 40dc D0009FE5 		ldr	r0, .L610+4
 7349 40e0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7350 40e4 FEFFFFEB 		bl	cmdSet
 7351              	.LVL667:
1981:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7352              		.loc 1 1981 0
 7353 40e8 14C09DE5 		ldr	ip, [sp, #20]
1982:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7354              		.loc 1 1982 0
 7355 40ec 24E09DE5 		ldr	lr, [sp, #36]
 7356 40f0 1C609DE5 		ldr	r6, [sp, #28]
1981:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7357              		.loc 1 1981 0
 7358 40f4 05C2C4E5 		strb	ip, [r4, #517]
1982:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7359              		.loc 1 1982 0
 7360 40f8 20C09DE5 		ldr	ip, [sp, #32]
 7361 40fc 0B20A0E1 		mov	r2, fp
 7362 4100 18309DE5 		ldr	r3, [sp, #24]
 7363 4104 B0109FE5 		ldr	r1, .L610+12
 7364 4108 0A00A0E1 		mov	r0, sl
 7365 410c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7366 4110 0C708DE5 		str	r7, [sp, #12]
 7367 4114 FEFFFFEB 		bl	CyU3PDebugPrint
 7368              	.LVL668:
1986:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7369              		.loc 1 1986 0
 7370 4118 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7371              	.LVL669:
1987:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7372              		.loc 1 1987 0
 7373 411c 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7374              	.LVL670:
1988:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7375              		.loc 1 1988 0
 7376 4120 0730A0E1 		mov	r3, r7
 7377 4124 0610A0E3 		mov	r1, #6
 7378 4128 8520A0E3 		mov	r2, #133
 7379 412c 80009FE5 		ldr	r0, .L610+4
 7380 4130 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7381 4134 FEFFFFEB 		bl	cmdSet
1989:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7382              		.loc 1 1989 0
 7383 4138 0730A0E1 		mov	r3, r7
 7384 413c 0610A0E3 		mov	r1, #6
 7385 4140 8620A0E3 		mov	r2, #134
 7386 4144 68009FE5 		ldr	r0, .L610+4
 7387 4148 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7388 414c FEFFFFEB 		bl	cmdSet
1991:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7389              		.loc 1 1991 0
 7390 4150 0620A0E1 		mov	r2, r6
 7391 4154 0530A0E1 		mov	r3, r5
 7392 4158 58109FE5 		ldr	r1, .L610+8
 7393 415c 0A00A0E1 		mov	r0, sl
1990:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7394              		.loc 1 1990 0
 7395 4160 1D62C4E5 		strb	r6, [r4, #541]
1991:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7396              		.loc 1 1991 0
 7397 4164 FEFFFFEB 		bl	CyU3PDebugPrint
 7398              	.LVL671:
1996:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7399              		.loc 1 1996 0
 7400 4168 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7401              	.LVL672:
1997:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7402              		.loc 1 1997 0
 7403 416c 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7404 4170 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7405 4174 0710A0E3 		mov	r1, #7
 7406 4178 34009FE5 		ldr	r0, .L610+4
 7407 417c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7408 4180 FEFFFFEB 		bl	cmdSet
 7409              	.LVL673:
1999:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7410              		.loc 1 1999 0
 7411 4184 0530A0E1 		mov	r3, r5
 7412 4188 0A00A0E1 		mov	r0, sl
 7413 418c 24109FE5 		ldr	r1, .L610+8
 7414 4190 0620A0E1 		mov	r2, r6
1998:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7415              		.loc 1 1998 0
 7416 4194 3552C4E5 		strb	r5, [r4, #565]
1999:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7417              		.loc 1 1999 0
 7418 4198 FEFFFFEB 		bl	CyU3PDebugPrint
2001:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7419              		.loc 1 2001 0
 7420 419c 10309FE5 		ldr	r3, .L610+4
 7421 41a0 1C0093E5 		ldr	r0, [r3, #28]
2004:../uvc.c      **** }
 7422              		.loc 1 2004 0
 7423 41a4 2CD08DE2 		add	sp, sp, #44
 7424 41a8 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2001:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7425              		.loc 1 2001 0
 7426 41ac FEFFFFEA 		b	_txe_mutex_put
 7427              	.L611:
 7428              		.align	2
 7429              	.L610:
 7430 41b0 00000000 		.word	.LANCHOR1
 7431 41b4 00000000 		.word	statQu
 7432 41b8 40080000 		.word	.LC47
 7433 41bc 60080000 		.word	.LC48
 7434              		.cfi_endproc
 7435              	.LFE5:
 7437              		.align	2
 7438              		.global	CyFxUVCAddHeader
 7440              	CyFxUVCAddHeader:
 7441              	.LFB6:
2012:../uvc.c      **** {
 7442              		.loc 1 2012 0
 7443              		.cfi_startproc
 7444              		@ args = 0, pretend = 0, frame = 0
 7445              		@ frame_needed = 0, uses_anonymous_args = 0
 7446              	.LVL674:
 7447 41c0 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7448              	.LCFI24:
 7449              		.cfi_def_cfa_offset 16
2012:../uvc.c      **** {
 7450              		.loc 1 2012 0
 7451 41c4 0040A0E1 		mov	r4, r0
 7452              		.cfi_offset 14, -4
 7453              		.cfi_offset 5, -8
 7454              		.cfi_offset 4, -12
 7455              		.cfi_offset 3, -16
 7456 41c8 0150A0E1 		mov	r5, r1
2014:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7457              		.loc 1 2014 0
 7458 41cc 30009FE5 		ldr	r0, .L614
 7459              	.LVL675:
 7460 41d0 0010E0E3 		mvn	r1, #0
 7461              	.LVL676:
 7462 41d4 FEFFFFEB 		bl	_txe_mutex_get
2015:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7463              		.loc 1 2015 0
 7464 41d8 0400A0E1 		mov	r0, r4
 7465 41dc 24109FE5 		ldr	r1, .L614+4
 7466 41e0 0C20A0E3 		mov	r2, #12
 7467 41e4 FEFFFFEB 		bl	CyU3PMemCopy
2016:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7468              		.loc 1 2016 0
 7469 41e8 14009FE5 		ldr	r0, .L614
 7470 41ec FEFFFFEB 		bl	_txe_mutex_put
2019:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7471              		.loc 1 2019 0
 7472 41f0 020015E3 		tst	r5, #2
2021:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7473              		.loc 1 2021 0
 7474 41f4 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7475 41f8 02308313 		orrne	r3, r3, #2
 7476 41fc 0130C415 		strneb	r3, [r4, #1]
 7477 4200 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7478              	.L615:
 7479              		.align	2
 7480              	.L614:
 7481 4204 00000000 		.word	imgHdMux
 7482 4208 80040000 		.word	.LANCHOR1+1152
 7483              		.cfi_endproc
 7484              	.LFE6:
 7486              		.align	2
 7487              		.global	CyFxAppErrorHandler
 7489              	CyFxAppErrorHandler:
 7490              	.LFB7:
2031:../uvc.c      **** {
 7491              		.loc 1 2031 0
 7492              		.cfi_startproc
 7493              		@ args = 0, pretend = 0, frame = 0
 7494              		@ frame_needed = 0, uses_anonymous_args = 0
 7495              	.LVL677:
 7496 420c 08402DE9 		stmfd	sp!, {r3, lr}
 7497              	.LCFI25:
 7498              		.cfi_def_cfa_offset 8
 7499              	.LVL678:
 7500              	.L617:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7501              		.loc 1 2041 0 discriminator 1
 7502 4210 10109FE5 		ldr	r1, .L618
 7503 4214 0400A0E3 		mov	r0, #4
 7504              		.cfi_offset 14, -4
 7505              		.cfi_offset 3, -8
 7506 4218 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 7507              		.loc 1 2042 0 discriminator 1
 7508 421c FA0FA0E3 		mov	r0, #1000
 7509 4220 FEFFFFEB 		bl	_tx_thread_sleep
 7510 4224 F9FFFFEA 		b	.L617
 7511              	.L619:
 7512              		.align	2
 7513              	.L618:
 7514 4228 18020000 		.word	.LC14
 7515              		.cfi_endproc
 7516              	.LFE7:
 7518              		.align	2
 7519              		.global	UVCAppThread_Entry
 7521              	UVCAppThread_Entry:
 7522              	.LFB19:
3023:../uvc.c      **** {
 7523              		.loc 1 3023 0
 7524              		.cfi_startproc
 7525              		@ args = 0, pretend = 0, frame = 176
 7526              		@ frame_needed = 0, uses_anonymous_args = 0
 7527              	.LVL679:
 7528 422c F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 7529              	.LCFI26:
 7530              		.cfi_def_cfa_offset 28
 7531 4230 BCD04DE2 		sub	sp, sp, #188
 7532              	.LCFI27:
 7533              		.cfi_def_cfa_offset 216
 7534              	.LBB224:
 7535              	.LBB225:
2479:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7536              		.loc 1 2479 0
 7537              		.cfi_offset 14, -4
 7538              		.cfi_offset 10, -8
 7539              		.cfi_offset 8, -12
 7540              		.cfi_offset 7, -16
 7541              		.cfi_offset 6, -20
 7542              		.cfi_offset 5, -24
 7543              		.cfi_offset 4, -28
 7544 4234 FEFFFFEB 		bl	CyU3PUartInit
 7545              	.LVL680:
2480:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7546              		.loc 1 2480 0
 7547 4238 004050E2 		subs	r4, r0, #0
 7548 423c 0400000A 		beq	.L621
2482:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7549              		.loc 1 2482 0
 7550 4240 0400A0E3 		mov	r0, #4
 7551              	.LVL681:
 7552 4244 F41D9FE5 		ldr	r1, .L761
 7553 4248 FEFFFFEB 		bl	CyU3PDebugPrint
2483:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7554              		.loc 1 2483 0
 7555 424c 0400A0E1 		mov	r0, r4
 7556 4250 FEFFFFEB 		bl	CyFxAppErrorHandler
 7557              	.L621:
2487:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7558              		.loc 1 2487 0
 7559 4254 E8CD9FE5 		ldr	ip, .L761+4
2489:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7560              		.loc 1 2489 0
 7561 4258 0030A0E3 		mov	r3, #0
2488:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7562              		.loc 1 2488 0
 7563 425c 0120A0E3 		mov	r2, #1
2496:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7564              		.loc 1 2496 0
 7565 4260 50008DE2 		add	r0, sp, #80
 7566 4264 0310A0E1 		mov	r1, r3
2487:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7567              		.loc 1 2487 0
 7568 4268 60C08DE5 		str	ip, [sp, #96]
2488:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7569              		.loc 1 2488 0
 7570 426c 6420CDE5 		strb	r2, [sp, #100]
2489:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7571              		.loc 1 2489 0
 7572 4270 6530CDE5 		strb	r3, [sp, #101]
2490:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7573              		.loc 1 2490 0
 7574 4274 50208DE5 		str	r2, [sp, #80]
2491:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7575              		.loc 1 2491 0
 7576 4278 54308DE5 		str	r3, [sp, #84]
2492:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7577              		.loc 1 2492 0
 7578 427c 58308DE5 		str	r3, [sp, #88]
2493:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7579              		.loc 1 2493 0
 7580 4280 5C208DE5 		str	r2, [sp, #92]
2496:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7581              		.loc 1 2496 0
 7582 4284 FEFFFFEB 		bl	CyU3PUartSetConfig
 7583              	.LVL682:
2497:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7584              		.loc 1 2497 0
 7585 4288 000050E3 		cmp	r0, #0
 7586 428c 0000000A 		beq	.L622
2499:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7587              		.loc 1 2499 0
 7588 4290 FEFFFFEB 		bl	CyFxAppErrorHandler
 7589              	.LVL683:
 7590              	.L622:
2503:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7591              		.loc 1 2503 0
 7592 4294 0000E0E3 		mvn	r0, #0
 7593 4298 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7594              	.LVL684:
2504:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7595              		.loc 1 2504 0
 7596 429c 000050E3 		cmp	r0, #0
 7597 42a0 0000000A 		beq	.L623
2506:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7598              		.loc 1 2506 0
 7599 42a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 7600              	.LVL685:
 7601              	.L623:
2510:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7602              		.loc 1 2510 0
 7603 42a8 0300A0E3 		mov	r0, #3
 7604 42ac 0410A0E3 		mov	r1, #4
 7605 42b0 FEFFFFEB 		bl	CyU3PDebugInit
 7606              	.LVL686:
2511:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7607              		.loc 1 2511 0
 7608 42b4 000050E3 		cmp	r0, #0
 7609 42b8 0000000A 		beq	.L624
2513:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7610              		.loc 1 2513 0
 7611 42bc FEFFFFEB 		bl	CyFxAppErrorHandler
 7612              	.LVL687:
 7613              	.L624:
2517:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7614              		.loc 1 2517 0
 7615 42c0 0000A0E3 		mov	r0, #0
 7616 42c4 FEFFFFEB 		bl	CyU3PDebugPreamble
 7617              	.LVL688:
 7618              	.LBE225:
 7619              	.LBE224:
3039:../uvc.c      **** 		CyU3PThreadSleep(500);
 7620              		.loc 1 3039 0
 7621 42c8 7D0FA0E3 		mov	r0, #500
 7622 42cc FEFFFFEB 		bl	_tx_thread_sleep
 7623              	.LVL689:
 7624 42d0 7D0FA0E3 		mov	r0, #500
 7625 42d4 FEFFFFEB 		bl	_tx_thread_sleep
 7626 42d8 7D0FA0E3 		mov	r0, #500
 7627 42dc FEFFFFEB 		bl	_tx_thread_sleep
 7628 42e0 7D0FA0E3 		mov	r0, #500
 7629 42e4 FEFFFFEB 		bl	_tx_thread_sleep
 7630 42e8 7D0FA0E3 		mov	r0, #500
 7631 42ec FEFFFFEB 		bl	_tx_thread_sleep
 7632 42f0 7D0FA0E3 		mov	r0, #500
 7633 42f4 FEFFFFEB 		bl	_tx_thread_sleep
 7634              	.LBB226:
 7635              	.LBB227:
2527:../uvc.c      ****     status = CyU3PI2cInit ();
 7636              		.loc 1 2527 0
 7637 42f8 FEFFFFEB 		bl	CyU3PI2cInit
 7638              	.LVL690:
2528:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7639              		.loc 1 2528 0
 7640 42fc 004050E2 		subs	r4, r0, #0
 7641 4300 0400000A 		beq	.L625
2530:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7642              		.loc 1 2530 0
 7643 4304 0400A0E3 		mov	r0, #4
 7644              	.LVL691:
 7645 4308 381D9FE5 		ldr	r1, .L761+8
 7646 430c FEFFFFEB 		bl	CyU3PDebugPrint
2531:../uvc.c      ****         CyFxAppErrorHandler (status);
 7647              		.loc 1 2531 0
 7648 4310 0400A0E1 		mov	r0, r4
 7649 4314 FEFFFFEB 		bl	CyFxAppErrorHandler
 7650              	.L625:
2535:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7651              		.loc 1 2535 0
 7652 4318 2C6D9FE5 		ldr	r6, .L761+12
2536:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7653              		.loc 1 2536 0
 7654 431c 0050A0E3 		mov	r5, #0
2537:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7655              		.loc 1 2537 0
 7656 4320 0040E0E3 		mvn	r4, #0
 7657              	.LVL692:
2540:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7658              		.loc 1 2540 0
 7659 4324 8C008DE2 		add	r0, sp, #140
 7660 4328 0510A0E1 		mov	r1, r5
2537:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7661              		.loc 1 2537 0
 7662 432c 94408DE5 		str	r4, [sp, #148]
2538:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7663              		.loc 1 2538 0
 7664 4330 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2535:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7665              		.loc 1 2535 0
 7666 4334 8C608DE5 		str	r6, [sp, #140]
2536:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7667              		.loc 1 2536 0
 7668 4338 90508DE5 		str	r5, [sp, #144]
2540:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7669              		.loc 1 2540 0
 7670 433c FEFFFFEB 		bl	CyU3PI2cSetConfig
 7671              	.LVL693:
2541:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7672              		.loc 1 2541 0
 7673 4340 004050E2 		subs	r4, r0, #0
 7674 4344 0400000A 		beq	.L626
2543:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7675              		.loc 1 2543 0
 7676 4348 0400A0E3 		mov	r0, #4
 7677              	.LVL694:
 7678 434c FC1C9FE5 		ldr	r1, .L761+16
 7679 4350 FEFFFFEB 		bl	CyU3PDebugPrint
2544:../uvc.c      ****         CyFxAppErrorHandler (status);
 7680              		.loc 1 2544 0
 7681 4354 0400A0E1 		mov	r0, r4
 7682 4358 FEFFFFEB 		bl	CyFxAppErrorHandler
 7683              	.L626:
 7684              	.LBE227:
 7685              	.LBE226:
 7686              	.LBB228:
 7687              	.LBB231:
2614:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 7688              		.loc 1 2614 0
 7689 435c F05C9FE5 		ldr	r5, .L761+20
 7690 4360 2820A0E3 		mov	r2, #40
 7691 4364 0010A0E3 		mov	r1, #0
 7692 4368 0500A0E1 		mov	r0, r5
 7693 436c FEFFFFEB 		bl	_txe_event_flags_create
 7694              	.LVL695:
2615:../uvc.c      ****     if (apiRetStatus != 0)
 7695              		.loc 1 2615 0
 7696 4370 002050E2 		subs	r2, r0, #0
 7697 4374 FB00001A 		bne	.L735
2629:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7698              		.loc 1 2629 0
 7699 4378 0260A0E3 		mov	r6, #2
2636:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7700              		.loc 1 2636 0
 7701 437c 0210A0E1 		mov	r1, r2
2625:../uvc.c      ****     isUsbConnected = CyFalse;
 7702              		.loc 1 2625 0
 7703 4380 442085E5 		str	r2, [r5, #68]
2626:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7704              		.loc 1 2626 0
 7705 4384 582085E5 		str	r2, [r5, #88]
2632:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7706              		.loc 1 2632 0
 7707 4388 0370A0E3 		mov	r7, #3
2636:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7708              		.loc 1 2636 0
 7709 438c 9C008DE2 		add	r0, sp, #156
 7710              	.LVL696:
2631:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7711              		.loc 1 2631 0
 7712 4390 A420CDE5 		strb	r2, [sp, #164]
2633:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7713              		.loc 1 2633 0
 7714 4394 A0208DE5 		str	r2, [sp, #160]
2629:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7715              		.loc 1 2629 0
 7716 4398 9C60CDE5 		strb	r6, [sp, #156]
2630:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7717              		.loc 1 2630 0
 7718 439c 9D60CDE5 		strb	r6, [sp, #157]
2632:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7719              		.loc 1 2632 0
 7720 43a0 A570CDE5 		strb	r7, [sp, #165]
2636:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7721              		.loc 1 2636 0
 7722 43a4 FEFFFFEB 		bl	CyU3PGpioInit
 7723              	.LVL697:
2637:../uvc.c      ****     if (apiRetStatus != 0)
 7724              		.loc 1 2637 0
 7725 43a8 002050E2 		subs	r2, r0, #0
 7726 43ac FF00001A 		bne	.L736
2645:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 7727              		.loc 1 2645 0
 7728 43b0 1600A0E3 		mov	r0, #22
 7729              	.LVL698:
 7730 43b4 0110A0E3 		mov	r1, #1
 7731 43b8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7732              	.LVL699:
2646:../uvc.c      ****     if (apiRetStatus != 0)
 7733              		.loc 1 2646 0
 7734 43bc 002050E2 		subs	r2, r0, #0
 7735 43c0 F100001A 		bne	.L737
2651:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 7736              		.loc 1 2651 0
 7737 43c4 1400A0E3 		mov	r0, #20
 7738              	.LVL700:
 7739 43c8 0110A0E3 		mov	r1, #1
 7740 43cc FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7741              	.LVL701:
2652:../uvc.c      ****     if (apiRetStatus != 0)
 7742              		.loc 1 2652 0
 7743 43d0 002050E2 		subs	r2, r0, #0
 7744 43d4 FE00001A 		bne	.L738
2657:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 7745              		.loc 1 2657 0
 7746 43d8 1800A0E3 		mov	r0, #24
 7747              	.LVL702:
 7748 43dc 0110A0E3 		mov	r1, #1
 7749 43e0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7750              	.LVL703:
2658:../uvc.c      ****     if (apiRetStatus != 0)
 7751              		.loc 1 2658 0
 7752 43e4 002050E2 		subs	r2, r0, #0
 7753 43e8 5602001A 		bne	.L739
2665:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7754              		.loc 1 2665 0
 7755 43ec 0140A0E3 		mov	r4, #1
 7756              	.LVL704:
2670:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7757              		.loc 1 2670 0
 7758 43f0 1600A0E3 		mov	r0, #22
 7759              	.LVL705:
 7760 43f4 68108DE2 		add	r1, sp, #104
2668:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7761              		.loc 1 2668 0
 7762 43f8 74208DE5 		str	r2, [sp, #116]
2669:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7763              		.loc 1 2669 0
 7764 43fc 7820CDE5 		strb	r2, [sp, #120]
2665:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7765              		.loc 1 2665 0
 7766 4400 68408DE5 		str	r4, [sp, #104]
2666:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7767              		.loc 1 2666 0
 7768 4404 6C408DE5 		str	r4, [sp, #108]
2667:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7769              		.loc 1 2667 0
 7770 4408 70408DE5 		str	r4, [sp, #112]
2670:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7771              		.loc 1 2670 0
 7772 440c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7773              	.LVL706:
2671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7774              		.loc 1 2671 0
 7775 4410 002050E2 		subs	r2, r0, #0
 7776 4414 4202001A 		bne	.L740
2684:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7777              		.loc 1 2684 0
 7778 4418 1400A0E3 		mov	r0, #20
 7779              	.LVL707:
 7780 441c 68108DE2 		add	r1, sp, #104
2682:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7781              		.loc 1 2682 0
 7782 4420 74208DE5 		str	r2, [sp, #116]
2683:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7783              		.loc 1 2683 0
 7784 4424 7820CDE5 		strb	r2, [sp, #120]
2679:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7785              		.loc 1 2679 0
 7786 4428 68408DE5 		str	r4, [sp, #104]
2680:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7787              		.loc 1 2680 0
 7788 442c 6C408DE5 		str	r4, [sp, #108]
2681:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7789              		.loc 1 2681 0
 7790 4430 70408DE5 		str	r4, [sp, #112]
2684:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7791              		.loc 1 2684 0
 7792 4434 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7793              	.LVL708:
2685:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7794              		.loc 1 2685 0
 7795 4438 002050E2 		subs	r2, r0, #0
 7796 443c 4A02001A 		bne	.L741
2698:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7797              		.loc 1 2698 0
 7798 4440 1800A0E3 		mov	r0, #24
 7799              	.LVL709:
 7800 4444 68108DE2 		add	r1, sp, #104
2693:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 7801              		.loc 1 2693 0
 7802 4448 68208DE5 		str	r2, [sp, #104]
2694:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7803              		.loc 1 2694 0
 7804 444c 6C208DE5 		str	r2, [sp, #108]
2695:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7805              		.loc 1 2695 0
 7806 4450 70208DE5 		str	r2, [sp, #112]
2697:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7807              		.loc 1 2697 0
 7808 4454 7820CDE5 		strb	r2, [sp, #120]
2696:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7809              		.loc 1 2696 0
 7810 4458 74408DE5 		str	r4, [sp, #116]
2698:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7811              		.loc 1 2698 0
 7812 445c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7813              	.LVL710:
2699:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7814              		.loc 1 2699 0
 7815 4460 002050E2 		subs	r2, r0, #0
 7816 4464 2502001A 		bne	.L742
2711:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7817              		.loc 1 2711 0
 7818 4468 0400A0E1 		mov	r0, r4
 7819              	.LVL711:
 7820 446c 7C108DE2 		add	r1, sp, #124
2708:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7821              		.loc 1 2708 0
 7822 4470 84208DE5 		str	r2, [sp, #132]
2709:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7823              		.loc 1 2709 0
 7824 4474 80208DE5 		str	r2, [sp, #128]
2706:../uvc.c      ****     pibclock.clkDiv      = 2;
 7825              		.loc 1 2706 0
 7826 4478 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2707:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7827              		.loc 1 2707 0
 7828 447c 8870CDE5 		strb	r7, [sp, #136]
2711:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7829              		.loc 1 2711 0
 7830 4480 FEFFFFEB 		bl	CyU3PPibInit
 7831              	.LVL712:
2712:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7832              		.loc 1 2712 0
 7833 4484 002050E2 		subs	r2, r0, #0
 7834 4488 1302001A 		bne	.L743
2719:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7835              		.loc 1 2719 0
 7836 448c C40B9FE5 		ldr	r0, .L761+24
 7837              	.LVL713:
 7838 4490 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7839              	.LVL714:
2727:../uvc.c      ****     SensorReset ();
 7840              		.loc 1 2727 0
 7841 4494 FEFFFFEB 		bl	SensorReset
2728:../uvc.c      ****     CyU3PThreadSleep(5000);
 7842              		.loc 1 2728 0
 7843 4498 BC0B9FE5 		ldr	r0, .L761+28
 7844 449c FEFFFFEB 		bl	_tx_thread_sleep
2732:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7845              		.loc 1 2732 0
 7846 44a0 FEFFFFEB 		bl	CyU3PUsbStart
 7847              	.LVL715:
2733:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7848              		.loc 1 2733 0
 7849 44a4 002050E2 		subs	r2, r0, #0
 7850 44a8 0202001A 		bne	.L744
2739:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7851              		.loc 1 2739 0
 7852 44ac 0010A0E3 		mov	r1, #0
 7853 44b0 A80B9FE5 		ldr	r0, .L761+32
 7854              	.LVL716:
 7855 44b4 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7856              	.LVL717:
2742:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7857              		.loc 1 2742 0
 7858 44b8 A40B9FE5 		ldr	r0, .L761+36
 7859 44bc FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2748:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7860              		.loc 1 2748 0
 7861 44c0 0010A0E3 		mov	r1, #0
 7862 44c4 9C2B9FE5 		ldr	r2, .L761+40
 7863 44c8 0100A0E3 		mov	r0, #1
 7864 44cc FEFFFFEB 		bl	CyU3PUsbSetDesc
2749:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7865              		.loc 1 2749 0
 7866 44d0 0000A0E3 		mov	r0, #0
 7867 44d4 0010A0E1 		mov	r1, r0
 7868 44d8 8C2B9FE5 		ldr	r2, .L761+44
 7869 44dc FEFFFFEB 		bl	CyU3PUsbSetDesc
2752:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7870              		.loc 1 2752 0
 7871 44e0 0010A0E3 		mov	r1, #0
 7872 44e4 842B9FE5 		ldr	r2, .L761+48
 7873 44e8 0200A0E3 		mov	r0, #2
 7874 44ec FEFFFFEB 		bl	CyU3PUsbSetDesc
2753:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7875              		.loc 1 2753 0
 7876 44f0 0010A0E3 		mov	r1, #0
 7877 44f4 782B9FE5 		ldr	r2, .L761+52
 7878 44f8 0700A0E3 		mov	r0, #7
 7879 44fc FEFFFFEB 		bl	CyU3PUsbSetDesc
2756:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7880              		.loc 1 2756 0
 7881 4500 0010A0E3 		mov	r1, #0
 7882 4504 6C2B9FE5 		ldr	r2, .L761+56
 7883 4508 0400A0E3 		mov	r0, #4
 7884 450c FEFFFFEB 		bl	CyU3PUsbSetDesc
2757:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7885              		.loc 1 2757 0
 7886 4510 0010A0E3 		mov	r1, #0
 7887 4514 602B9FE5 		ldr	r2, .L761+60
 7888 4518 0300A0E3 		mov	r0, #3
 7889 451c FEFFFFEB 		bl	CyU3PUsbSetDesc
2758:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7890              		.loc 1 2758 0
 7891 4520 0010A0E3 		mov	r1, #0
 7892 4524 542B9FE5 		ldr	r2, .L761+64
 7893 4528 0600A0E3 		mov	r0, #6
 7894 452c FEFFFFEB 		bl	CyU3PUsbSetDesc
2761:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7895              		.loc 1 2761 0
 7896 4530 0010A0E3 		mov	r1, #0
 7897 4534 482B9FE5 		ldr	r2, .L761+68
 7898 4538 0500A0E3 		mov	r0, #5
 7899 453c FEFFFFEB 		bl	CyU3PUsbSetDesc
2762:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7900              		.loc 1 2762 0
 7901 4540 0110A0E3 		mov	r1, #1
 7902 4544 3C2B9FE5 		ldr	r2, .L761+72
 7903 4548 0500A0E3 		mov	r0, #5
 7904 454c FEFFFFEB 		bl	CyU3PUsbSetDesc
2763:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7905              		.loc 1 2763 0
 7906 4550 0210A0E3 		mov	r1, #2
 7907 4554 302B9FE5 		ldr	r2, .L761+76
 7908 4558 0500A0E3 		mov	r0, #5
 7909 455c FEFFFFEB 		bl	CyU3PUsbSetDesc
2773:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7910              		.loc 1 2773 0
 7911 4560 0080A0E3 		mov	r8, #0
2770:../uvc.c      ****     endPointConfig.enable   = 1;
 7912              		.loc 1 2770 0
 7913 4564 0140A0E3 		mov	r4, #1
2772:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7914              		.loc 1 2772 0
 7915 4568 4070A0E3 		mov	r7, #64	@ movhi
2776:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7916              		.loc 1 2776 0
 7917 456c 8200A0E3 		mov	r0, #130
 7918 4570 A8108DE2 		add	r1, sp, #168
2771:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7919              		.loc 1 2771 0
 7920 4574 03A0A0E3 		mov	sl, #3
2772:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7921              		.loc 1 2772 0
 7922 4578 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2770:../uvc.c      ****     endPointConfig.enable   = 1;
 7923              		.loc 1 2770 0
 7924 457c A8408DE5 		str	r4, [sp, #168]
2771:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7925              		.loc 1 2771 0
 7926 4580 ACA0CDE5 		strb	sl, [sp, #172]
2773:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7927              		.loc 1 2773 0
 7928 4584 B380CDE5 		strb	r8, [sp, #179]
2774:../uvc.c      ****     endPointConfig.streams  = 0;
 7929              		.loc 1 2774 0
 7930 4588 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2775:../uvc.c      ****     endPointConfig.burstLen = 1;
 7931              		.loc 1 2775 0
 7932 458c B240CDE5 		strb	r4, [sp, #178]
2776:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7933              		.loc 1 2776 0
 7934 4590 FEFFFFEB 		bl	CyU3PSetEpConfig
 7935              	.LVL718:
2774:../uvc.c      ****     endPointConfig.streams  = 0;
 7936              		.loc 1 2774 0
 7937 4594 0870A0E1 		mov	r7, r8	@ movhi
2777:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7938              		.loc 1 2777 0
 7939 4598 003050E2 		subs	r3, r0, #0
 7940 459c BB01001A 		bne	.L745
2787:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7941              		.loc 1 2787 0
 7942 45a0 E8CA9FE5 		ldr	ip, .L761+80
2788:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7943              		.loc 1 2788 0
 7944 45a4 E8EA9FE5 		ldr	lr, .L761+84
2785:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7945              		.loc 1 2785 0
 7946 45a8 016BA0E3 		mov	r6, #1024	@ movhi
2794:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7947              		.loc 1 2794 0
 7948 45ac 1080A0E3 		mov	r8, #16
2796:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7949              		.loc 1 2796 0
 7950 45b0 E00A9FE5 		ldr	r0, .L761+88
 7951              	.LVL719:
 7952 45b4 0410A0E3 		mov	r1, #4
 7953 45b8 34208DE2 		add	r2, sp, #52
2785:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7954              		.loc 1 2785 0
 7955 45bc B463CDE1 		strh	r6, [sp, #52]	@ movhi
2786:../uvc.c      ****     dmaInterConfig.count          = 1;
 7956              		.loc 1 2786 0
 7957 45c0 B643CDE1 		strh	r4, [sp, #54]	@ movhi
2787:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7958              		.loc 1 2787 0
 7959 45c4 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2788:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7960              		.loc 1 2788 0
 7961 45c8 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2789:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7962              		.loc 1 2789 0
 7963 45cc BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2790:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7964              		.loc 1 2790 0
 7965 45d0 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2791:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7966              		.loc 1 2791 0
 7967 45d4 B034CDE1 		strh	r3, [sp, #64]	@ movhi
2792:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7968              		.loc 1 2792 0
 7969 45d8 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2793:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7970              		.loc 1 2793 0
 7971 45dc 4470CDE5 		strb	r7, [sp, #68]
2794:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7972              		.loc 1 2794 0
 7973 45e0 48808DE5 		str	r8, [sp, #72]
2795:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7974              		.loc 1 2795 0
 7975 45e4 4C308DE5 		str	r3, [sp, #76]
2796:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7976              		.loc 1 2796 0
 7977 45e8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7978              	.LVL720:
2798:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7979              		.loc 1 2798 0
 7980 45ec 006050E2 		subs	r6, r0, #0
 7981 45f0 E600001A 		bne	.L746
2805:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7982              		.loc 1 2805 0
 7983 45f4 010BA0E3 		mov	r0, #1024
 7984              	.LVL721:
 7985 45f8 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7986 45fc 981A9FE5 		ldr	r1, .L761+92
2806:../uvc.c      ****     if (glInterStaBuffer == 0)
 7987              		.loc 1 2806 0
 7988 4600 000050E3 		cmp	r0, #0
2805:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7989              		.loc 1 2805 0
 7990 4604 000081E5 		str	r0, [r1, #0]
2806:../uvc.c      ****     if (glInterStaBuffer == 0)
 7991              		.loc 1 2806 0
 7992 4608 D700000A 		beq	.L747
2813:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7993              		.loc 1 2813 0
 7994 460c 0610A0E1 		mov	r1, r6
 7995 4610 0620A0E1 		mov	r2, r6
 7996 4614 3830A0E3 		mov	r3, #56
 7997 4618 800A9FE5 		ldr	r0, .L761+96
 7998 461c FEFFFFEB 		bl	_txe_mutex_create
2815:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7999              		.loc 1 2815 0
 8000 4620 0430A0E3 		mov	r3, #4	@ movhi
 8001 4624 BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2818:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8002              		.loc 1 2818 0
 8003 4628 743A9FE5 		ldr	r3, .L761+100
2814:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 8004              		.loc 1 2814 0
 8005 462c 01C9A0E3 		mov	ip, #16384	@ movhi
 8006 4630 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2817:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 8007              		.loc 1 2817 0
 8008 4634 01CCA0E3 		mov	ip, #256	@ movhi
 8009 4638 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2818:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8010              		.loc 1 2818 0
 8011 463c B431CDE1 		strh	r3, [sp, #20]	@ movhi
2819:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8012              		.loc 1 2819 0
 8013 4640 60CA9FE5 		ldr	ip, .L761+104
2821:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 8014              		.loc 1 2821 0
 8015 4644 0C30A0E3 		mov	r3, #12	@ movhi
 8016 4648 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2826:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8017              		.loc 1 2826 0
 8018 464c 583A9FE5 		ldr	r3, .L761+108
2827:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8019              		.loc 1 2827 0
 8020 4650 0C208DE2 		add	r2, sp, #12
2819:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8021              		.loc 1 2819 0
 8022 4654 BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2824:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8023              		.loc 1 2824 0
 8024 4658 2A70CDE5 		strb	r7, [sp, #42]
2822:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8025              		.loc 1 2822 0
 8026 465c 04C0A0E3 		mov	ip, #4	@ movhi
2816:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8027              		.loc 1 2816 0
 8028 4660 02A0A0E3 		mov	sl, #2	@ movhi
2827:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8029              		.loc 1 2827 0
 8030 4664 440A9FE5 		ldr	r0, .L761+112
 8031 4668 0710A0E3 		mov	r1, #7
2825:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8032              		.loc 1 2825 0
 8033 466c 1870A0E3 		mov	r7, #24
2816:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8034              		.loc 1 2816 0
 8035 4670 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2820:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 8036              		.loc 1 2820 0
 8037 4674 B262CDE1 		strh	r6, [sp, #34]	@ movhi
2822:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8038              		.loc 1 2822 0
 8039 4678 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2823:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 8040              		.loc 1 2823 0
 8041 467c B862CDE1 		strh	r6, [sp, #40]	@ movhi
2825:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8042              		.loc 1 2825 0
 8043 4680 2C708DE5 		str	r7, [sp, #44]
2826:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8044              		.loc 1 2826 0
 8045 4684 30308DE5 		str	r3, [sp, #48]
2827:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8046              		.loc 1 2827 0
 8047 4688 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 8048              	.LVL722:
2829:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8049              		.loc 1 2829 0
 8050 468c 002050E2 		subs	r2, r0, #0
 8051 4690 C800001A 		bne	.L748
2920:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 8052              		.loc 1 2920 0
 8053 4694 0400A0E1 		mov	r0, r4
 8054              	.LVL723:
 8055 4698 0410A0E1 		mov	r1, r4
 8056 469c FEFFFFEB 		bl	CyU3PConnectState
 8057              	.LVL724:
2921:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8058              		.loc 1 2921 0
 8059 46a0 002050E2 		subs	r2, r0, #0
 8060 46a4 A700001A 		bne	.L749
2927:../uvc.c      ****     CyU3PBusyWait(100);
 8061              		.loc 1 2927 0
 8062 46a8 6400A0E3 		mov	r0, #100
 8063              	.LVL725:
 8064 46ac FEFFFFEB 		bl	CyU3PBusyWait
 8065              	.LVL726:
2929:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8066              		.loc 1 2929 0
 8067 46b0 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2943:../uvc.c      ****     endPointConfig.streams  = 0;
 8068              		.loc 1 2943 0
 8069 46b4 0020A0E3 		mov	r2, #0	@ movhi
2932:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8070              		.loc 1 2932 0
 8071 46b8 ACA0CDE5 		strb	sl, [sp, #172]
2944:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8072              		.loc 1 2944 0
 8073 46bc A8108DE2 		add	r1, sp, #168
2943:../uvc.c      ****     endPointConfig.streams  = 0;
 8074              		.loc 1 2943 0
 8075 46c0 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2931:../uvc.c      ****     endPointConfig.enable   = 1;
 8076              		.loc 1 2931 0
 8077 46c4 A8408DE5 		str	r4, [sp, #168]
2933:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 8078              		.loc 1 2933 0
 8079 46c8 030050E3 		cmp	r0, #3
2929:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8080              		.loc 1 2929 0
 8081 46cc 5C00C5E5 		strb	r0, [r5, #92]
2940:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8082              		.loc 1 2940 0
 8083 46d0 020CA013 		movne	r0, #512	@ movhi
2935:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8084              		.loc 1 2935 0
 8085 46d4 01ABA003 		moveq	sl, #1024	@ movhi
2940:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8086              		.loc 1 2940 0
 8087 46d8 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2944:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8088              		.loc 1 2944 0
 8089 46dc 8300A0E3 		mov	r0, #131
2935:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8090              		.loc 1 2935 0
 8091 46e0 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2936:../uvc.c      ****     	endPointConfig.burstLen = 16;
 8092              		.loc 1 2936 0
 8093 46e4 B280CD05 		streqb	r8, [sp, #178]
2941:../uvc.c      ****     	endPointConfig.burstLen = 1;
 8094              		.loc 1 2941 0
 8095 46e8 B240CD15 		strneb	r4, [sp, #178]
2944:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8096              		.loc 1 2944 0
 8097 46ec FEFFFFEB 		bl	CyU3PSetEpConfig
 8098              	.LVL727:
2945:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8099              		.loc 1 2945 0
 8100 46f0 002050E2 		subs	r2, r0, #0
 8101 46f4 5600001A 		bne	.L732
 8102 46f8 B4799FE5 		ldr	r7, .L761+116
 8103              	.LBE231:
 8104              	.LBE228:
3068:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8105              		.loc 1 3068 0
 8106 46fc 50499FE5 		ldr	r4, .L761+20
 8107 4700 0260A0E1 		mov	r6, r2
3281:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8108              		.loc 1 3281 0
 8109 4704 00A0E0E3 		mvn	sl, #0
 8110              	.LVL728:
 8111              	.L659:
3068:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8112              		.loc 1 3068 0
 8113 4708 44099FE5 		ldr	r0, .L761+20
 8114 470c 0110A0E3 		mov	r1, #1
 8115 4710 0220A0E3 		mov	r2, #2
 8116 4714 B4308DE2 		add	r3, sp, #180
 8117 4718 00608DE5 		str	r6, [sp, #0]
 8118 471c FEFFFFEB 		bl	_txe_event_flags_get
 8119 4720 000050E3 		cmp	r0, #0
 8120 4724 3300001A 		bne	.L661
3072:../uvc.c      ****         	debugData[1] = debugData[1]|0x01;
 8121              		.loc 1 3072 0
 8122 4728 2DE0D4E5 		ldrb	lr, [r4, #45]	@ zero_extendqisi2
3116:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8123              		.loc 1 3116 0
 8124 472c 508094E5 		ldr	r8, [r4, #80]
3072:../uvc.c      ****         	debugData[1] = debugData[1]|0x01;
 8125              		.loc 1 3072 0
 8126 4730 01308EE3 		orr	r3, lr, #1
3116:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8127              		.loc 1 3116 0
 8128 4734 000058E3 		cmp	r8, #0
3072:../uvc.c      ****         	debugData[1] = debugData[1]|0x01;
 8129              		.loc 1 3072 0
 8130 4738 2D30C4E5 		strb	r3, [r4, #45]
3116:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8131              		.loc 1 3116 0
 8132 473c 0300000A 		beq	.L662
3116:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8133              		.loc 1 3116 0 is_stmt 0 discriminator 1
 8134 4740 B415D4E1 		ldrh	r1, [r4, #84]
 8135 4744 B6C5D4E1 		ldrh	ip, [r4, #86]
 8136 4748 0C0051E1 		cmp	r1, ip
 8137 474c 8F01000A 		beq	.L750
 8138              	.L662:
3356:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 8139              		.loc 1 3356 0 is_stmt 1
 8140 4750 4010A0E3 		mov	r1, #64
 8141 4754 0020A0E3 		mov	r2, #0
 8142 4758 F4089FE5 		ldr	r0, .L761+20
 8143 475c FEFFFFEB 		bl	_txe_event_flags_set
3359:../uvc.c      ****         CyU3PThreadRelinquish ();
 8144              		.loc 1 3359 0
 8145 4760 FEFFFFEB 		bl	_txe_thread_relinquish
3360:../uvc.c      ****     }
 8146              		.loc 1 3360 0
 8147 4764 E7FFFFEA 		b	.L659
 8148              	.LVL729:
 8149              	.L735:
 8150              	.LBB266:
 8151              	.LBB230:
2617:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 8152              		.loc 1 2617 0
 8153 4768 0400A0E3 		mov	r0, #4
 8154              	.LVL730:
 8155 476c 44199FE5 		ldr	r1, .L761+120
 8156 4770 FEFFFFEB 		bl	CyU3PDebugPrint
 8157              	.LVL731:
 8158              	.L628:
 8159              	.LBB246:
 8160              	.LBB247:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8161              		.loc 1 2041 0
 8162 4774 40199FE5 		ldr	r1, .L761+124
 8163 4778 0400A0E3 		mov	r0, #4
 8164 477c FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8165              		.loc 1 2042 0
 8166 4780 FA0FA0E3 		mov	r0, #1000
 8167 4784 FEFFFFEB 		bl	_tx_thread_sleep
 8168 4788 F9FFFFEA 		b	.L628
 8169              	.LVL732:
 8170              	.L737:
 8171              	.LBE247:
 8172              	.LBE246:
2648:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 8173              		.loc 1 2648 0
 8174 478c 0400A0E3 		mov	r0, #4
 8175              	.LVL733:
 8176 4790 28199FE5 		ldr	r1, .L761+128
 8177 4794 FEFFFFEB 		bl	CyU3PDebugPrint
 8178              	.LVL734:
 8179              	.L632:
 8180              	.LBB244:
 8181              	.LBB245:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8182              		.loc 1 2041 0
 8183 4798 1C199FE5 		ldr	r1, .L761+124
 8184 479c 0400A0E3 		mov	r0, #4
 8185 47a0 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8186              		.loc 1 2042 0
 8187 47a4 FA0FA0E3 		mov	r0, #1000
 8188 47a8 FEFFFFEB 		bl	_tx_thread_sleep
 8189 47ac F9FFFFEA 		b	.L632
 8190              	.LVL735:
 8191              	.L736:
 8192              	.LBE245:
 8193              	.LBE244:
2639:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 8194              		.loc 1 2639 0
 8195 47b0 0400A0E3 		mov	r0, #4
 8196              	.LVL736:
 8197 47b4 08199FE5 		ldr	r1, .L761+132
 8198 47b8 FEFFFFEB 		bl	CyU3PDebugPrint
 8199              	.LVL737:
 8200              	.L630:
 8201              	.LBB242:
 8202              	.LBB243:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8203              		.loc 1 2041 0
 8204 47bc F8189FE5 		ldr	r1, .L761+124
 8205 47c0 0400A0E3 		mov	r0, #4
 8206 47c4 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8207              		.loc 1 2042 0
 8208 47c8 FA0FA0E3 		mov	r0, #1000
 8209 47cc FEFFFFEB 		bl	_tx_thread_sleep
 8210 47d0 F9FFFFEA 		b	.L630
 8211              	.LVL738:
 8212              	.L738:
 8213              	.LBE243:
 8214              	.LBE242:
2654:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 8215              		.loc 1 2654 0
 8216 47d4 0400A0E3 		mov	r0, #4
 8217              	.LVL739:
 8218 47d8 E8189FE5 		ldr	r1, .L761+136
 8219 47dc FEFFFFEB 		bl	CyU3PDebugPrint
 8220              	.LVL740:
 8221              	.L634:
 8222              	.LBB240:
 8223              	.LBB241:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8224              		.loc 1 2041 0
 8225 47e0 D4189FE5 		ldr	r1, .L761+124
 8226 47e4 0400A0E3 		mov	r0, #4
 8227 47e8 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8228              		.loc 1 2042 0
 8229 47ec FA0FA0E3 		mov	r0, #1000
 8230 47f0 FEFFFFEB 		bl	_tx_thread_sleep
 8231 47f4 F9FFFFEA 		b	.L634
 8232              	.LVL741:
 8233              	.L661:
 8234              	.LBE241:
 8235              	.LBE240:
 8236              	.LBE230:
 8237              	.LBE266:
3229:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 8238              		.loc 1 3229 0
 8239 47f8 54089FE5 		ldr	r0, .L761+20
 8240 47fc 0210A0E3 		mov	r1, #2
 8241 4800 0320A0E3 		mov	r2, #3
 8242 4804 B4308DE2 		add	r3, sp, #180
 8243 4808 00608DE5 		str	r6, [sp, #0]
 8244 480c FEFFFFEB 		bl	_txe_event_flags_get
 8245 4810 000050E3 		cmp	r0, #0
 8246 4814 2900001A 		bne	.L684
3232:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
 8247              		.loc 1 3232 0
 8248 4818 2D80D4E5 		ldrb	r8, [r4, #45]	@ zero_extendqisi2
3246:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8249              		.loc 1 3246 0
 8250 481c 582094E5 		ldr	r2, [r4, #88]
3232:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
 8251              		.loc 1 3232 0
 8252 4820 7F3008E2 		and	r3, r8, #127
3233:../uvc.c      ****             	debugData[1] = debugData[1]|0x04;
 8253              		.loc 1 3233 0
 8254 4824 041083E3 		orr	r1, r3, #4
3246:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8255              		.loc 1 3246 0
 8256 4828 000052E3 		cmp	r2, #0
3234:../uvc.c      ****             	hitFV     = CyFalse;
 8257              		.loc 1 3234 0
 8258 482c 506084E5 		str	r6, [r4, #80]
3233:../uvc.c      ****             	debugData[1] = debugData[1]|0x04;
 8259              		.loc 1 3233 0
 8260 4830 2D10C4E5 		strb	r1, [r4, #45]
3235:../uvc.c      ****                 prodCount = 0;
 8261              		.loc 1 3235 0
 8262 4834 B465C4E1 		strh	r6, [r4, #84]	@ movhi
3242:../uvc.c      ****                 fb=0;
 8263              		.loc 1 3242 0
 8264 4838 B864C4E1 		strh	r6, [r4, #72]	@ movhi
3236:../uvc.c      ****                 consCount = 0;
 8265              		.loc 1 3236 0
 8266 483c B665C4E1 		strh	r6, [r4, #86]	@ movhi
3243:../uvc.c      ****                 pb=0;
 8267              		.loc 1 3243 0
 8268 4840 BA64C4E1 		strh	r6, [r4, #74]	@ movhi
3244:../uvc.c      ****                 pbc=0;
 8269              		.loc 1 3244 0
 8270 4844 BC64C4E1 		strh	r6, [r4, #76]	@ movhi
3246:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8271              		.loc 1 3246 0
 8272 4848 0A00000A 		beq	.L751
 8273              	.L685:
3258:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 8274              		.loc 1 3258 0
 8275 484c 586085E5 		str	r6, [r5, #88]
 8276 4850 BEFFFFEA 		b	.L662
 8277              	.LVL742:
 8278              	.L732:
 8279              	.LBB267:
 8280              	.LBB264:
2948:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8281              		.loc 1 2948 0
 8282 4854 0400A0E3 		mov	r0, #4
 8283              	.LVL743:
 8284 4858 6C189FE5 		ldr	r1, .L761+140
 8285 485c FEFFFFEB 		bl	CyU3PDebugPrint
 8286              	.LVL744:
 8287              	.L660:
 8288              	.LBB248:
 8289              	.LBB249:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8290              		.loc 1 2041 0
 8291 4860 54189FE5 		ldr	r1, .L761+124
 8292 4864 0400A0E3 		mov	r0, #4
 8293 4868 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8294              		.loc 1 2042 0
 8295 486c FA0FA0E3 		mov	r0, #1000
 8296 4870 FEFFFFEB 		bl	_tx_thread_sleep
 8297 4874 F9FFFFEA 		b	.L660
 8298              	.LVL745:
 8299              	.L751:
 8300              	.LBE249:
 8301              	.LBE248:
 8302              	.LBE264:
 8303              	.LBE267:
3248:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8304              		.loc 1 3248 0
 8305 4878 30089FE5 		ldr	r0, .L761+112
 8306 487c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8307              	.LVL746:
3249:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8308              		.loc 1 3249 0
 8309 4880 000050E3 		cmp	r0, #0
 8310 4884 0200001A 		bne	.L733
3255:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8311              		.loc 1 3255 0
 8312 4888 8300A0E3 		mov	r0, #131
 8313              	.LVL747:
 8314 488c FEFFFFEB 		bl	CyU3PUsbFlushEp
 8315 4890 EDFFFFEA 		b	.L685
 8316              	.L733:
 8317              	.LBB268:
 8318              	.LBB269:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8319              		.loc 1 2041 0
 8320 4894 20189FE5 		ldr	r1, .L761+124
 8321 4898 0400A0E3 		mov	r0, #4
 8322 489c FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8323              		.loc 1 2042 0
 8324 48a0 FA0FA0E3 		mov	r0, #1000
 8325 48a4 FEFFFFEB 		bl	_tx_thread_sleep
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8326              		.loc 1 2041 0
 8327 48a8 0C189FE5 		ldr	r1, .L761+124
 8328 48ac 0400A0E3 		mov	r0, #4
 8329 48b0 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8330              		.loc 1 2042 0
 8331 48b4 FA0FA0E3 		mov	r0, #1000
 8332 48b8 FEFFFFEB 		bl	_tx_thread_sleep
 8333 48bc F4FFFFEA 		b	.L733
 8334              	.L684:
 8335              	.LBE269:
 8336              	.LBE268:
3262:../uvc.c      ****                 if(stream_start == CyTrue){
 8337              		.loc 1 3262 0
 8338 48c0 708094E5 		ldr	r8, [r4, #112]
 8339 48c4 010058E3 		cmp	r8, #1
 8340 48c8 A200000A 		beq	.L752
 8341              	.L688:
3281:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 8342              		.loc 1 3281 0
 8343 48cc 0110A0E3 		mov	r1, #1
 8344 48d0 0220A0E3 		mov	r2, #2
 8345 48d4 B4308DE2 		add	r3, sp, #180
 8346 48d8 74079FE5 		ldr	r0, .L761+20
 8347 48dc 00A08DE5 		str	sl, [sp, #0]
 8348 48e0 FEFFFFEB 		bl	_txe_event_flags_get
3285:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8349              		.loc 1 3285 0
 8350 48e4 0010A0E3 		mov	r1, #0
 8351 48e8 0120A0E1 		mov	r2, r1
 8352 48ec BC079FE5 		ldr	r0, .L761+112
 8353 48f0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8354              	.LVL748:
3286:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8355              		.loc 1 3286 0
 8356 48f4 002050E2 		subs	r2, r0, #0
 8357 48f8 8D00001A 		bne	.L753
3292:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
 8358              		.loc 1 3292 0
 8359 48fc 2D80D4E5 		ldrb	r8, [r4, #45]	@ zero_extendqisi2
3295:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8360              		.loc 1 3295 0
 8361 4900 3C1094E5 		ldr	r1, [r4, #60]
3292:../uvc.c      ****             	debugData[1] = debugData[1]&0x7F;
 8362              		.loc 1 3292 0
 8363 4904 7F3008E2 		and	r3, r8, #127
3293:../uvc.c      ****             	debugData[1] = debugData[1]|0x08;
 8364              		.loc 1 3293 0
 8365 4908 08E083E3 		orr	lr, r3, #8
3295:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8366              		.loc 1 3295 0
 8367 490c 000051E3 		cmp	r1, #0
3293:../uvc.c      ****             	debugData[1] = debugData[1]|0x08;
 8368              		.loc 1 3293 0
 8369 4910 2DE0C4E5 		strb	lr, [r4, #45]
3295:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8370              		.loc 1 3295 0
 8371 4914 5200001A 		bne	.L691
3311:../uvc.c      ****                     if(streamingRecove){
 8372              		.loc 1 3311 0
 8373 4918 282094E5 		ldr	r2, [r4, #40]
 8374 491c 000052E3 		cmp	r2, #0
 8375 4920 4400000A 		beq	.L692
3312:../uvc.c      ****                     switch (setRes)
 8376              		.loc 1 3312 0
 8377 4924 D500D4E5 		ldrb	r0, [r4, #213]	@ zero_extendqisi2
 8378              	.LVL749:
 8379 4928 01C040E2 		sub	ip, r0, #1
 8380 492c 03005CE3 		cmp	ip, #3
 8381 4930 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 8382 4934 3E0000EA 		b	.L693
 8383              	.L698:
 8384 4938 F84B0000 		.word	.L694
 8385 493c 444C0000 		.word	.L695
 8386 4940 9C4B0000 		.word	.L696
 8387 4944 DC490000 		.word	.L697
 8388              	.LVL750:
 8389              	.L749:
 8390              	.LBB270:
 8391              	.LBB229:
2923:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 8392              		.loc 1 2923 0
 8393 4948 0400A0E3 		mov	r0, #4
 8394              	.LVL751:
 8395 494c 7C179FE5 		ldr	r1, .L761+144
 8396 4950 FEFFFFEB 		bl	CyU3PDebugPrint
 8397              	.LVL752:
 8398              	.L656:
 8399              	.LBB238:
 8400              	.LBB239:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8401              		.loc 1 2041 0
 8402 4954 60179FE5 		ldr	r1, .L761+124
 8403 4958 0400A0E3 		mov	r0, #4
 8404 495c FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8405              		.loc 1 2042 0
 8406 4960 FA0FA0E3 		mov	r0, #1000
 8407 4964 FEFFFFEB 		bl	_tx_thread_sleep
 8408 4968 F9FFFFEA 		b	.L656
 8409              	.LVL753:
 8410              	.L747:
 8411              	.LBE239:
 8412              	.LBE238:
2808:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 8413              		.loc 1 2808 0
 8414 496c 040080E2 		add	r0, r0, #4
 8415 4970 5C179FE5 		ldr	r1, .L761+148
 8416 4974 FEFFFFEB 		bl	CyU3PDebugPrint
 8417              	.LVL754:
 8418              	.L652:
 8419              	.LBB236:
 8420              	.LBB237:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8421              		.loc 1 2041 0
 8422 4978 3C179FE5 		ldr	r1, .L761+124
 8423 497c 0400A0E3 		mov	r0, #4
 8424 4980 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8425              		.loc 1 2042 0
 8426 4984 FA0FA0E3 		mov	r0, #1000
 8427 4988 FEFFFFEB 		bl	_tx_thread_sleep
 8428 498c F9FFFFEA 		b	.L652
 8429              	.LVL755:
 8430              	.L746:
 8431              	.LBE237:
 8432              	.LBE236:
2801:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 8433              		.loc 1 2801 0
 8434 4990 0400A0E3 		mov	r0, #4
 8435 4994 3C179FE5 		ldr	r1, .L761+152
 8436 4998 0620A0E1 		mov	r2, r6
 8437 499c FEFFFFEB 		bl	CyU3PDebugPrint
 8438              	.L650:
 8439              	.LBB234:
 8440              	.LBB235:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8441              		.loc 1 2041 0
 8442 49a0 14179FE5 		ldr	r1, .L761+124
 8443 49a4 0400A0E3 		mov	r0, #4
 8444 49a8 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8445              		.loc 1 2042 0
 8446 49ac FA0FA0E3 		mov	r0, #1000
 8447 49b0 FEFFFFEB 		bl	_tx_thread_sleep
 8448 49b4 F9FFFFEA 		b	.L650
 8449              	.LVL756:
 8450              	.L748:
 8451              	.LBE235:
 8452              	.LBE234:
2832:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 8453              		.loc 1 2832 0
 8454 49b8 0400A0E3 		mov	r0, #4
 8455              	.LVL757:
 8456 49bc 18179FE5 		ldr	r1, .L761+156
 8457 49c0 FEFFFFEB 		bl	CyU3PDebugPrint
 8458              	.LVL758:
 8459              	.L654:
 8460              	.LBB232:
 8461              	.LBB233:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8462              		.loc 1 2041 0
 8463 49c4 F0169FE5 		ldr	r1, .L761+124
 8464 49c8 0400A0E3 		mov	r0, #4
 8465 49cc FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8466              		.loc 1 2042 0
 8467 49d0 FA0FA0E3 		mov	r0, #1000
 8468 49d4 FEFFFFEB 		bl	_tx_thread_sleep
 8469 49d8 F9FFFFEA 		b	.L654
 8470              	.LVL759:
 8471              	.L697:
 8472              	.LBE233:
 8473              	.LBE232:
 8474              	.LBE229:
 8475              	.LBE270:
3330:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
 8476              		.loc 1 3330 0
 8477 49dc 6C0095E5 		ldr	r0, [r5, #108]
 8478 49e0 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8479 49e4 000050E3 		cmp	r0, #0
 8480 49e8 F400A003 		moveq	r0, #244
 8481 49ec 7400A013 		movne	r0, #116
 8482 49f0 032080E1 		orr	r2, r0, r3
 8483 49f4 3010A0E3 		mov	r1, #48
 8484 49f8 5230A0E3 		mov	r3, #82
 8485 49fc 0100A0E3 		mov	r0, #1
 8486 4a00 FEFFFFEB 		bl	SensorSetIrisControl
3331:../uvc.c      ****                      		CyU3PThreadSleep(100);
 8487              		.loc 1 3331 0
 8488 4a04 6400A0E3 		mov	r0, #100
 8489 4a08 FEFFFFEB 		bl	_tx_thread_sleep
3332:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
 8490              		.loc 1 3332 0
 8491 4a0c 6CC095E5 		ldr	ip, [r5, #108]
 8492 4a10 8C84D7E5 		ldrb	r8, [r7, #1164]	@ zero_extendqisi2
 8493 4a14 00005CE3 		cmp	ip, #0
 8494 4a18 F4C0A003 		moveq	ip, #244
 8495 4a1c 74C0A013 		movne	ip, #116
 8496 4a20 6C3095E5 		ldr	r3, [r5, #108]
 8497 4a24 0400A0E3 		mov	r0, #4
 8498 4a28 B0169FE5 		ldr	r1, .L761+160
 8499 4a2c 08208CE1 		orr	r2, ip, r8
 8500 4a30 FEFFFFEB 		bl	CyU3PDebugPrint
 8501              	.L693:
3338:../uvc.c      ****                     streamingRecove = CyFalse;
 8502              		.loc 1 3338 0
 8503 4a34 286085E5 		str	r6, [r5, #40]
 8504              	.L692:
 8505              	.LVL760:
 8506              	.LBB271:
 8507              	.LBB272:
2973:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8508              		.loc 1 2973 0
 8509 4a38 5C30D5E5 		ldrb	r3, [r5, #92]	@ zero_extendqisi2
 8510 4a3c 030053E3 		cmp	r3, #3
 8511 4a40 2B00000A 		beq	.L754
2978:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8512              		.loc 1 2978 0
 8513 4a44 020053E3 		cmp	r3, #2
 8514 4a48 0D00000A 		beq	.L755
 8515              	.LVL761:
 8516              	.L709:
 8517              	.LBE272:
 8518              	.LBE271:
3343:../uvc.c      ****                     gpif_initialized = CyTrue;
 8519              		.loc 1 3343 0
 8520 4a4c 0120A0E3 		mov	r2, #1
 8521 4a50 3C2085E5 		str	r2, [r5, #60]
3345:../uvc.c      ****                     CyU3PThreadSleep(200);
 8522              		.loc 1 3345 0
 8523 4a54 C800A0E3 		mov	r0, #200
3344:../uvc.c      ****                     stream_start = CyTrue;
 8524              		.loc 1 3344 0
 8525 4a58 702085E5 		str	r2, [r5, #112]
3345:../uvc.c      ****                     CyU3PThreadSleep(200);
 8526              		.loc 1 3345 0
 8527 4a5c FEFFFFEB 		bl	_tx_thread_sleep
 8528 4a60 3AFFFFEA 		b	.L662
 8529              	.LVL762:
 8530              	.L691:
3352:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8531              		.loc 1 3352 0
 8532 4a64 38069FE5 		ldr	r0, .L761+100
 8533              	.LVL763:
 8534 4a68 0210A0E1 		mov	r1, r2
 8535 4a6c 02E0A0E3 		mov	lr, #2
 8536 4a70 0020A0E1 		mov	r2, r0
 8537              	.LVL764:
 8538 4a74 0130A0E1 		mov	r3, r1
 8539 4a78 00E08DE5 		str	lr, [sp, #0]
 8540 4a7c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8541              	.LVL765:
 8542 4a80 32FFFFEA 		b	.L662
 8543              	.LVL766:
 8544              	.L755:
 8545              	.LBB278:
 8546              	.LBB277:
2980:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8547              		.loc 1 2980 0
 8548 4a84 58169FE5 		ldr	r1, .L761+164
 8549 4a88 0100A0E3 		mov	r0, #1
 8550 4a8c FEFFFFEB 		bl	CyU3PDebugPrint
2981:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8551              		.loc 1 2981 0
 8552 4a90 50069FE5 		ldr	r0, .L761+168
 8553 4a94 FEFFFFEB 		bl	CyU3PGpifLoad
 8554 4a98 0020A0E1 		mov	r2, r0
 8555              	.LVL767:
 8556              	.L708:
2983:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8557              		.loc 1 2983 0
 8558 4a9c 000052E3 		cmp	r2, #0
 8559 4aa0 1A00001A 		bne	.L756
2991:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8560              		.loc 1 2991 0
 8561 4aa4 5C30D5E5 		ldrb	r3, [r5, #92]	@ zero_extendqisi2
 8562 4aa8 030053E3 		cmp	r3, #3
 8563 4aac 0100000A 		beq	.L734
2995:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8564              		.loc 1 2995 0
 8565 4ab0 020053E3 		cmp	r3, #2
 8566 4ab4 E4FFFF1A 		bne	.L709
 8567              	.L734:
2997:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8568              		.loc 1 2997 0
 8569 4ab8 0200A0E1 		mov	r0, r2
 8570              	.LVL768:
 8571 4abc 0210A0E1 		mov	r1, r2
 8572 4ac0 FEFFFFEB 		bl	CyU3PGpifSMStart
 8573              	.LVL769:
2999:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8574              		.loc 1 2999 0
 8575 4ac4 000050E3 		cmp	r0, #0
2997:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8576              		.loc 1 2997 0
 8577 4ac8 0020A0E1 		mov	r2, r0
 8578              	.LVL770:
2999:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8579              		.loc 1 2999 0
 8580 4acc DEFFFF0A 		beq	.L709
3002:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8581              		.loc 1 3002 0
 8582 4ad0 0400A0E3 		mov	r0, #4
 8583              	.LVL771:
 8584 4ad4 10169FE5 		ldr	r1, .L761+172
 8585 4ad8 FEFFFFEB 		bl	CyU3PDebugPrint
 8586              	.LVL772:
 8587              	.L714:
 8588              	.LBB273:
 8589              	.LBB274:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8590              		.loc 1 2041 0
 8591 4adc D8159FE5 		ldr	r1, .L761+124
 8592 4ae0 0400A0E3 		mov	r0, #4
 8593 4ae4 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8594              		.loc 1 2042 0
 8595 4ae8 FA0FA0E3 		mov	r0, #1000
 8596 4aec FEFFFFEB 		bl	_tx_thread_sleep
 8597 4af0 F9FFFFEA 		b	.L714
 8598              	.LVL773:
 8599              	.L754:
 8600              	.LBE274:
 8601              	.LBE273:
2975:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 8602              		.loc 1 2975 0
 8603 4af4 F4159FE5 		ldr	r1, .L761+176
 8604 4af8 0100A0E3 		mov	r0, #1
 8605 4afc FEFFFFEB 		bl	CyU3PDebugPrint
2976:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 8606              		.loc 1 2976 0
 8607 4b00 EC059FE5 		ldr	r0, .L761+180
 8608 4b04 FEFFFFEB 		bl	CyU3PGpifLoad
 8609 4b08 0020A0E1 		mov	r2, r0
 8610              	.LVL774:
 8611 4b0c E2FFFFEA 		b	.L708
 8612              	.L756:
2986:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 8613              		.loc 1 2986 0
 8614 4b10 0400A0E3 		mov	r0, #4
 8615              	.LVL775:
 8616 4b14 DC159FE5 		ldr	r1, .L761+184
 8617 4b18 FEFFFFEB 		bl	CyU3PDebugPrint
 8618              	.LVL776:
 8619              	.L711:
 8620              	.LBB275:
 8621              	.LBB276:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8622              		.loc 1 2041 0
 8623 4b1c 98159FE5 		ldr	r1, .L761+124
 8624 4b20 0400A0E3 		mov	r0, #4
 8625 4b24 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8626              		.loc 1 2042 0
 8627 4b28 FA0FA0E3 		mov	r0, #1000
 8628 4b2c FEFFFFEB 		bl	_tx_thread_sleep
 8629 4b30 F9FFFFEA 		b	.L711
 8630              	.LVL777:
 8631              	.L753:
 8632              	.LBE276:
 8633              	.LBE275:
 8634              	.LBE277:
 8635              	.LBE278:
3289:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 8636              		.loc 1 3289 0
 8637 4b34 0400A0E3 		mov	r0, #4
 8638              	.LVL778:
 8639 4b38 BC159FE5 		ldr	r1, .L761+188
 8640 4b3c FEFFFFEB 		bl	CyU3PDebugPrint
 8641              	.LVL779:
 8642              	.L690:
 8643              	.LBB279:
 8644              	.LBB280:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8645              		.loc 1 2041 0
 8646 4b40 74159FE5 		ldr	r1, .L761+124
 8647 4b44 0400A0E3 		mov	r0, #4
 8648 4b48 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8649              		.loc 1 2042 0
 8650 4b4c FA0FA0E3 		mov	r0, #1000
 8651 4b50 FEFFFFEB 		bl	_tx_thread_sleep
 8652 4b54 F9FFFFEA 		b	.L690
 8653              	.L752:
 8654              	.LBE280:
 8655              	.LBE279:
3263:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
 8656              		.loc 1 3263 0
 8657 4b58 F4049FE5 		ldr	r0, .L761+20
 8658 4b5c 0810A0E1 		mov	r1, r8
 8659 4b60 0220A0E3 		mov	r2, #2
 8660 4b64 B4308DE2 		add	r3, sp, #180
 8661 4b68 00608DE5 		str	r6, [sp, #0]
 8662 4b6c FEFFFFEB 		bl	_txe_event_flags_get
 8663 4b70 000050E3 		cmp	r0, #0
 8664 4b74 54FFFF0A 		beq	.L688
3266:../uvc.c      ****     						CyU3PThreadSleep(3000);
 8665              		.loc 1 3266 0
 8666 4b78 80059FE5 		ldr	r0, .L761+192
 8667 4b7c FEFFFFEB 		bl	_tx_thread_sleep
3269:../uvc.c      ****     							debugData[3]++;
 8668              		.loc 1 3269 0
 8669 4b80 2F00D4E5 		ldrb	r0, [r4, #47]	@ zero_extendqisi2
3272:../uvc.c      ****     						stream_start == CyFalse;
 8670              		.loc 1 3272 0
 8671 4b84 702094E5 		ldr	r2, [r4, #112]
3269:../uvc.c      ****     							debugData[3]++;
 8672              		.loc 1 3269 0
 8673 4b88 01C080E2 		add	ip, r0, #1
3268:../uvc.c      ****     							streamingRecove = CyTrue;
 8674              		.loc 1 3268 0
 8675 4b8c 288084E5 		str	r8, [r4, #40]
3269:../uvc.c      ****     							debugData[3]++;
 8676              		.loc 1 3269 0
 8677 4b90 2FC0C4E5 		strb	ip, [r4, #47]
3271:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
 8678              		.loc 1 3271 0
 8679 4b94 586084E5 		str	r6, [r4, #88]
 8680 4b98 4BFFFFEA 		b	.L688
 8681              	.L696:
3325:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
 8682              		.loc 1 3325 0
 8683 4b9c 6CE095E5 		ldr	lr, [r5, #108]
 8684 4ba0 8C14D7E5 		ldrb	r1, [r7, #1164]	@ zero_extendqisi2
 8685 4ba4 00005EE3 		cmp	lr, #0
 8686 4ba8 C4E0A003 		moveq	lr, #196
 8687 4bac 44E0A013 		movne	lr, #68
 8688 4bb0 01208EE1 		orr	r2, lr, r1
 8689 4bb4 5230A0E3 		mov	r3, #82
 8690 4bb8 3010A0E3 		mov	r1, #48
 8691 4bbc 0100A0E3 		mov	r0, #1
 8692 4bc0 FEFFFFEB 		bl	SensorSetIrisControl
3326:../uvc.c      ****                      		CyU3PThreadSleep(100);
 8693              		.loc 1 3326 0
 8694 4bc4 6400A0E3 		mov	r0, #100
 8695 4bc8 FEFFFFEB 		bl	_tx_thread_sleep
3327:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
 8696              		.loc 1 3327 0
 8697 4bcc 6C2095E5 		ldr	r2, [r5, #108]
 8698 4bd0 8C84D7E5 		ldrb	r8, [r7, #1164]	@ zero_extendqisi2
 8699 4bd4 000052E3 		cmp	r2, #0
 8700 4bd8 C420A003 		moveq	r2, #196
 8701 4bdc 4420A013 		movne	r2, #68
 8702 4be0 6C3095E5 		ldr	r3, [r5, #108]
 8703 4be4 F4149FE5 		ldr	r1, .L761+160
 8704 4be8 082082E1 		orr	r2, r2, r8
 8705 4bec 0400A0E3 		mov	r0, #4
 8706 4bf0 FEFFFFEB 		bl	CyU3PDebugPrint
3328:../uvc.c      ****                      		break;
 8707              		.loc 1 3328 0
 8708 4bf4 8EFFFFEA 		b	.L693
 8709              	.L694:
3315:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
 8710              		.loc 1 3315 0
 8711 4bf8 6C2095E5 		ldr	r2, [r5, #108]
 8712 4bfc 3010A0E3 		mov	r1, #48
 8713 4c00 000052E3 		cmp	r2, #0
 8714 4c04 E420A003 		moveq	r2, #228
 8715 4c08 6420A013 		movne	r2, #100
 8716 4c0c 5230A0E3 		mov	r3, #82
 8717 4c10 0100A0E3 		mov	r0, #1
 8718 4c14 FEFFFFEB 		bl	SensorSetIrisControl
3316:../uvc.c      ****                      		CyU3PThreadSleep(100);
 8719              		.loc 1 3316 0
 8720 4c18 6400A0E3 		mov	r0, #100
 8721 4c1c FEFFFFEB 		bl	_tx_thread_sleep
3317:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
 8722              		.loc 1 3317 0
 8723 4c20 6C2095E5 		ldr	r2, [r5, #108]
 8724 4c24 B4149FE5 		ldr	r1, .L761+160
 8725 4c28 000052E3 		cmp	r2, #0
 8726 4c2c 6C3095E5 		ldr	r3, [r5, #108]
 8727 4c30 E420A003 		moveq	r2, #228
 8728 4c34 6420A013 		movne	r2, #100
 8729 4c38 0400A0E3 		mov	r0, #4
 8730 4c3c FEFFFFEB 		bl	CyU3PDebugPrint
3318:../uvc.c      ****                      		break;
 8731              		.loc 1 3318 0
 8732 4c40 7BFFFFEA 		b	.L693
 8733              	.L695:
3320:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
 8734              		.loc 1 3320 0
 8735 4c44 6C2095E5 		ldr	r2, [r5, #108]
 8736 4c48 3010A0E3 		mov	r1, #48
 8737 4c4c 000052E3 		cmp	r2, #0
 8738 4c50 D420A003 		moveq	r2, #212
 8739 4c54 5420A013 		movne	r2, #84
 8740 4c58 5230A0E3 		mov	r3, #82
 8741 4c5c 0100A0E3 		mov	r0, #1
 8742 4c60 FEFFFFEB 		bl	SensorSetIrisControl
3321:../uvc.c      ****                      		CyU3PThreadSleep(100);
 8743              		.loc 1 3321 0
 8744 4c64 6400A0E3 		mov	r0, #100
 8745 4c68 FEFFFFEB 		bl	_tx_thread_sleep
3322:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
 8746              		.loc 1 3322 0
 8747 4c6c 6C2095E5 		ldr	r2, [r5, #108]
 8748 4c70 68149FE5 		ldr	r1, .L761+160
 8749 4c74 000052E3 		cmp	r2, #0
 8750 4c78 6C3095E5 		ldr	r3, [r5, #108]
 8751 4c7c D420A003 		moveq	r2, #212
 8752 4c80 5420A013 		movne	r2, #84
 8753 4c84 0400A0E3 		mov	r0, #4
 8754 4c88 FEFFFFEB 		bl	CyU3PDebugPrint
3323:../uvc.c      ****                      		break;
 8755              		.loc 1 3323 0
 8756 4c8c 68FFFFEA 		b	.L693
 8757              	.LVL780:
 8758              	.L745:
 8759              	.LBB281:
 8760              	.LBB265:
2780:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8761              		.loc 1 2780 0
 8762 4c90 0400A0E3 		mov	r0, #4
 8763              	.LVL781:
 8764 4c94 30149FE5 		ldr	r1, .L761+140
 8765 4c98 0320A0E1 		mov	r2, r3
 8766 4c9c FEFFFFEB 		bl	CyU3PDebugPrint
 8767              	.LVL782:
 8768              	.L648:
 8769              	.LBB250:
 8770              	.LBB251:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8771              		.loc 1 2041 0
 8772 4ca0 14149FE5 		ldr	r1, .L761+124
 8773 4ca4 0400A0E3 		mov	r0, #4
 8774 4ca8 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8775              		.loc 1 2042 0
 8776 4cac FA0FA0E3 		mov	r0, #1000
 8777 4cb0 FEFFFFEB 		bl	_tx_thread_sleep
 8778 4cb4 F9FFFFEA 		b	.L648
 8779              	.LVL783:
 8780              	.L744:
 8781              	.LBE251:
 8782              	.LBE250:
2735:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8783              		.loc 1 2735 0
 8784 4cb8 0400A0E3 		mov	r0, #4
 8785              	.LVL784:
 8786 4cbc 40149FE5 		ldr	r1, .L761+196
 8787 4cc0 FEFFFFEB 		bl	CyU3PDebugPrint
 8788              	.LVL785:
 8789              	.L646:
 8790              	.LBB252:
 8791              	.LBB253:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8792              		.loc 1 2041 0
 8793 4cc4 F0139FE5 		ldr	r1, .L761+124
 8794 4cc8 0400A0E3 		mov	r0, #4
 8795 4ccc FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8796              		.loc 1 2042 0
 8797 4cd0 FA0FA0E3 		mov	r0, #1000
 8798 4cd4 FEFFFFEB 		bl	_tx_thread_sleep
 8799 4cd8 F9FFFFEA 		b	.L646
 8800              	.LVL786:
 8801              	.L743:
 8802              	.LBE253:
 8803              	.LBE252:
2714:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 8804              		.loc 1 2714 0
 8805 4cdc 0400A0E3 		mov	r0, #4
 8806              	.LVL787:
 8807 4ce0 20149FE5 		ldr	r1, .L761+200
 8808 4ce4 FEFFFFEB 		bl	CyU3PDebugPrint
 8809              	.LVL788:
 8810              	.L644:
 8811              	.LBB254:
 8812              	.LBB255:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8813              		.loc 1 2041 0
 8814 4ce8 CC139FE5 		ldr	r1, .L761+124
 8815 4cec 0400A0E3 		mov	r0, #4
 8816 4cf0 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8817              		.loc 1 2042 0
 8818 4cf4 FA0FA0E3 		mov	r0, #1000
 8819 4cf8 FEFFFFEB 		bl	_tx_thread_sleep
 8820 4cfc F9FFFFEA 		b	.L644
 8821              	.LVL789:
 8822              	.L742:
 8823              	.LBE255:
 8824              	.LBE254:
2701:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 8825              		.loc 1 2701 0
 8826 4d00 0400A0E3 		mov	r0, #4
 8827              	.LVL790:
 8828 4d04 00149FE5 		ldr	r1, .L761+204
 8829 4d08 FEFFFFEB 		bl	CyU3PDebugPrint
 8830              	.LVL791:
 8831              	.L642:
 8832              	.LBB256:
 8833              	.LBB257:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8834              		.loc 1 2041 0
 8835 4d0c A8139FE5 		ldr	r1, .L761+124
 8836 4d10 0400A0E3 		mov	r0, #4
 8837 4d14 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8838              		.loc 1 2042 0
 8839 4d18 FA0FA0E3 		mov	r0, #1000
 8840 4d1c FEFFFFEB 		bl	_tx_thread_sleep
 8841 4d20 F9FFFFEA 		b	.L642
 8842              	.LVL792:
 8843              	.L740:
 8844              	.LBE257:
 8845              	.LBE256:
2673:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 8846              		.loc 1 2673 0
 8847 4d24 0400A0E3 		mov	r0, #4
 8848              	.LVL793:
 8849 4d28 E0139FE5 		ldr	r1, .L761+208
 8850 4d2c FEFFFFEB 		bl	CyU3PDebugPrint
 8851              	.LVL794:
 8852              	.L638:
 8853              	.LBB258:
 8854              	.LBB259:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8855              		.loc 1 2041 0
 8856 4d30 84139FE5 		ldr	r1, .L761+124
 8857 4d34 0400A0E3 		mov	r0, #4
 8858 4d38 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8859              		.loc 1 2042 0
 8860 4d3c FA0FA0E3 		mov	r0, #1000
 8861 4d40 FEFFFFEB 		bl	_tx_thread_sleep
 8862 4d44 F9FFFFEA 		b	.L638
 8863              	.LVL795:
 8864              	.L739:
 8865              	.LBE259:
 8866              	.LBE258:
2660:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 8867              		.loc 1 2660 0
 8868 4d48 0400A0E3 		mov	r0, #4
 8869              	.LVL796:
 8870 4d4c C0139FE5 		ldr	r1, .L761+212
 8871 4d50 FEFFFFEB 		bl	CyU3PDebugPrint
 8872              	.LVL797:
 8873              	.L636:
 8874              	.LBB260:
 8875              	.LBB261:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8876              		.loc 1 2041 0
 8877 4d54 60139FE5 		ldr	r1, .L761+124
 8878 4d58 0400A0E3 		mov	r0, #4
 8879 4d5c FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8880              		.loc 1 2042 0
 8881 4d60 FA0FA0E3 		mov	r0, #1000
 8882 4d64 FEFFFFEB 		bl	_tx_thread_sleep
 8883 4d68 F9FFFFEA 		b	.L636
 8884              	.LVL798:
 8885              	.L741:
 8886              	.LBE261:
 8887              	.LBE260:
2687:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 8888              		.loc 1 2687 0
 8889 4d6c 0400A0E3 		mov	r0, #4
 8890              	.LVL799:
 8891 4d70 A0139FE5 		ldr	r1, .L761+216
 8892 4d74 FEFFFFEB 		bl	CyU3PDebugPrint
 8893              	.LVL800:
 8894              	.L640:
 8895              	.LBB262:
 8896              	.LBB263:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8897              		.loc 1 2041 0
 8898 4d78 3C139FE5 		ldr	r1, .L761+124
 8899 4d7c 0400A0E3 		mov	r0, #4
 8900 4d80 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8901              		.loc 1 2042 0
 8902 4d84 FA0FA0E3 		mov	r0, #1000
 8903 4d88 FEFFFFEB 		bl	_tx_thread_sleep
 8904 4d8c F9FFFFEA 		b	.L640
 8905              	.LVL801:
 8906              	.L750:
 8907              	.LBE263:
 8908              	.LBE262:
 8909              	.LBE265:
 8910              	.LBE281:
3123:../uvc.c      ****             	debugData[0]++;
 8911              		.loc 1 3123 0
 8912 4d90 2CC0D4E5 		ldrb	ip, [r4, #44]	@ zero_extendqisi2
3124:../uvc.c      ****             	debugData[1] = debugData[1]|0x82;
 8913              		.loc 1 3124 0
 8914 4d94 0330E0E1 		mvn	r3, r3
 8915 4d98 7D1003E2 		and	r1, r3, #125
3123:../uvc.c      ****             	debugData[0]++;
 8916              		.loc 1 3123 0
 8917 4d9c 01E08CE2 		add	lr, ip, #1
3124:../uvc.c      ****             	debugData[1] = debugData[1]|0x82;
 8918              		.loc 1 3124 0
 8919 4da0 0180E0E1 		mvn	r8, r1
3128:../uvc.c      ****                 prodCount = 0;
 8920              		.loc 1 3128 0
 8921 4da4 B465C4E1 		strh	r6, [r4, #84]	@ movhi
3143:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8922              		.loc 1 3143 0
 8923 4da8 F0029FE5 		ldr	r0, .L761+96
3129:../uvc.c      ****                 consCount = 0;
 8924              		.loc 1 3129 0
 8925 4dac B665C4E1 		strh	r6, [r4, #86]	@ movhi
3143:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8926              		.loc 1 3143 0
 8927 4db0 0010E0E3 		mvn	r1, #0
3123:../uvc.c      ****             	debugData[0]++;
 8928              		.loc 1 3123 0
 8929 4db4 2CE0C4E5 		strb	lr, [r4, #44]
3124:../uvc.c      ****             	debugData[1] = debugData[1]|0x82;
 8930              		.loc 1 3124 0
 8931 4db8 2D80C4E5 		strb	r8, [r4, #45]
3125:../uvc.c      ****             	fb=0;
 8932              		.loc 1 3125 0
 8933 4dbc B864C4E1 		strh	r6, [r4, #72]	@ movhi
3126:../uvc.c      ****             	pb=0;
 8934              		.loc 1 3126 0
 8935 4dc0 BA64C4E1 		strh	r6, [r4, #74]	@ movhi
3127:../uvc.c      ****             	pbc=0;
 8936              		.loc 1 3127 0
 8937 4dc4 BC64C4E1 		strh	r6, [r4, #76]	@ movhi
3130:../uvc.c      ****                 hitFV     = CyFalse;
 8938              		.loc 1 3130 0
 8939 4dc8 506084E5 		str	r6, [r4, #80]
3143:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8940              		.loc 1 3143 0
 8941 4dcc FEFFFFEB 		bl	_txe_mutex_get
3144:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 8942              		.loc 1 3144 0
 8943 4dd0 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 8944 4dd4 012020E2 		eor	r2, r0, #1
 8945 4dd8 8124C7E5 		strb	r2, [r7, #1153]
3146:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8946              		.loc 1 3146 0
 8947 4ddc 4E30D4E5 		ldrb	r3, [r4, #78]	@ zero_extendqisi2
 8948 4de0 F00053E3 		cmp	r3, #240
 8949 4de4 1900000A 		beq	.L757
 8950              	.L663:
3154:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 8951              		.loc 1 3154 0
 8952 4de8 4E20D5E5 		ldrb	r2, [r5, #78]	@ zero_extendqisi2
 8953 4dec FF0052E3 		cmp	r2, #255
 8954 4df0 3800000A 		beq	.L758
3166:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 8955              		.loc 1 3166 0
 8956 4df4 4E30D4E5 		ldrb	r3, [r4, #78]	@ zero_extendqisi2
 8957 4df8 AA0053E3 		cmp	r3, #170
 8958 4dfc 2700000A 		beq	.L759
 8959              	.L664:
3204:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 8960              		.loc 1 3204 0
 8961 4e00 98029FE5 		ldr	r0, .L761+96
 8962 4e04 FEFFFFEB 		bl	_txe_mutex_put
3206:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8963              		.loc 1 3206 0
 8964 4e08 A0029FE5 		ldr	r0, .L761+112
 8965 4e0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8966              	.LVL802:
3207:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8967              		.loc 1 3207 0
 8968 4e10 002050E2 		subs	r2, r0, #0
 8969 4e14 1800001A 		bne	.L760
3214:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8970              		.loc 1 3214 0
 8971 4e18 0210A0E1 		mov	r1, r2
 8972 4e1c 8C029FE5 		ldr	r0, .L761+112
 8973              	.LVL803:
 8974 4e20 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8975              	.LVL804:
3215:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8976              		.loc 1 3215 0
 8977 4e24 002050E2 		subs	r2, r0, #0
 8978 4e28 0DFFFF0A 		beq	.L691
3217:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8979              		.loc 1 3217 0
 8980 4e2c 0400A0E3 		mov	r0, #4
 8981              	.LVL805:
 8982 4e30 E4129FE5 		ldr	r1, .L761+220
 8983 4e34 FEFFFFEB 		bl	CyU3PDebugPrint
 8984              	.LVL806:
 8985              	.L683:
 8986              	.LBB282:
 8987              	.LBB283:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8988              		.loc 1 2041 0
 8989 4e38 7C129FE5 		ldr	r1, .L761+124
 8990 4e3c 0400A0E3 		mov	r0, #4
 8991 4e40 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 8992              		.loc 1 2042 0
 8993 4e44 FA0FA0E3 		mov	r0, #1000
 8994 4e48 FEFFFFEB 		bl	_tx_thread_sleep
 8995 4e4c F9FFFFEA 		b	.L683
 8996              	.L757:
 8997              	.LBE283:
 8998              	.LBE282:
3146:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8999              		.loc 1 3146 0 discriminator 1
 9000 4e50 FC019FE5 		ldr	r0, .L761+20
 9001 4e54 8010A0E3 		mov	r1, #128
 9002 4e58 0320A0E3 		mov	r2, #3
 9003 4e5c B4308DE2 		add	r3, sp, #180
 9004 4e60 00608DE5 		str	r6, [sp, #0]
 9005 4e64 FEFFFFEB 		bl	_txe_event_flags_get
 9006 4e68 000050E3 		cmp	r0, #0
3151:../uvc.c      ****                 		stiflag = 0xFF;
 9007              		.loc 1 3151 0 discriminator 1
 9008 4e6c 4EA0C405 		streqb	sl, [r4, #78]
3152:../uvc.c      ****                 		IMcount = 0;
 9009              		.loc 1 3152 0 discriminator 1
 9010 4e70 F960C405 		streqb	r6, [r4, #249]
3146:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9011              		.loc 1 3146 0 discriminator 1
 9012 4e74 E1FFFF0A 		beq	.L664
 9013 4e78 DAFFFFEA 		b	.L663
 9014              	.LVL807:
 9015              	.L760:
3209:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 9016              		.loc 1 3209 0
 9017 4e7c 0400A0E3 		mov	r0, #4
 9018              	.LVL808:
 9019 4e80 98129FE5 		ldr	r1, .L761+224
 9020 4e84 FEFFFFEB 		bl	CyU3PDebugPrint
 9021              	.LVL809:
 9022              	.L681:
 9023              	.LBB284:
 9024              	.LBB285:
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9025              		.loc 1 2041 0
 9026 4e88 2C129FE5 		ldr	r1, .L761+124
 9027 4e8c 0400A0E3 		mov	r0, #4
 9028 4e90 FEFFFFEB 		bl	CyU3PDebugPrint
2042:../uvc.c      ****         CyU3PThreadSleep (1000);
 9029              		.loc 1 2042 0
 9030 4e94 FA0FA0E3 		mov	r0, #1000
 9031 4e98 FEFFFFEB 		bl	_tx_thread_sleep
 9032 4e9c F9FFFFEA 		b	.L681
 9033              	.L759:
 9034              	.LBE285:
 9035              	.LBE284:
3172:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 9036              		.loc 1 3172 0
 9037 4ea0 F900D4E5 		ldrb	r0, [r4, #249]	@ zero_extendqisi2
 9038 4ea4 012080E2 		add	r2, r0, #1
 9039 4ea8 020050E3 		cmp	r0, #2
 9040 4eac F920C4E5 		strb	r2, [r4, #249]
 9041 4eb0 D2FFFF9A 		bls	.L664
3174:../uvc.c      ****                     switch (setRes)
 9042              		.loc 1 3174 0
 9043 4eb4 D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 9044 4eb8 01804EE2 		sub	r8, lr, #1
 9045 4ebc 030058E3 		cmp	r8, #3
 9046 4ec0 08F19F97 		ldrls	pc, [pc, r8, asl #2]
 9047 4ec4 230000EA 		b	.L666
 9048              	.L671:
 9049 4ec8 B84F0000 		.word	.L667
 9050 4ecc FC4F0000 		.word	.L668
 9051 4ed0 644F0000 		.word	.L669
 9052 4ed4 084F0000 		.word	.L670
 9053              	.L758:
3156:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 9054              		.loc 1 3156 0
 9055 4ed8 F980D4E5 		ldrb	r8, [r4, #249]	@ zero_extendqisi2
 9056 4edc 010088E2 		add	r0, r8, #1
 9057 4ee0 020058E3 		cmp	r8, #2
 9058 4ee4 F900C4E5 		strb	r0, [r4, #249]
 9059 4ee8 C4FFFF9A 		bls	.L664
3157:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9060              		.loc 1 3157 0
 9061 4eec 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
3158:../uvc.c      ****                 		stiflag = 0x0F;
 9062              		.loc 1 3158 0
 9063 4ef0 0FE0A0E3 		mov	lr, #15
3157:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9064              		.loc 1 3157 0
 9065 4ef4 20108CE3 		orr	r1, ip, #32
 9066 4ef8 8114C7E5 		strb	r1, [r7, #1153]
3159:../uvc.c      ****                 		IMcount = 0;
 9067              		.loc 1 3159 0
 9068 4efc F960C4E5 		strb	r6, [r4, #249]
3158:../uvc.c      ****                 		stiflag = 0x0F;
 9069              		.loc 1 3158 0
 9070 4f00 4EE0C4E5 		strb	lr, [r4, #78]
 9071 4f04 BDFFFFEA 		b	.L664
 9072              	.L670:
3192:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 9073              		.loc 1 3192 0
 9074 4f08 6C0095E5 		ldr	r0, [r5, #108]
 9075 4f0c 8CE4D7E5 		ldrb	lr, [r7, #1164]	@ zero_extendqisi2
 9076 4f10 000050E3 		cmp	r0, #0
 9077 4f14 F400A003 		moveq	r0, #244
 9078 4f18 7400A013 		movne	r0, #116
 9079 4f1c 0E2080E1 		orr	r2, r0, lr
 9080 4f20 3010A0E3 		mov	r1, #48
 9081 4f24 5230A0E3 		mov	r3, #82
 9082 4f28 0100A0E3 		mov	r0, #1
 9083 4f2c FEFFFFEB 		bl	SensorSetIrisControl
3194:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 9084              		.loc 1 3194 0
 9085 4f30 6CC095E5 		ldr	ip, [r5, #108]
 9086 4f34 8C84D7E5 		ldrb	r8, [r7, #1164]	@ zero_extendqisi2
 9087 4f38 00005CE3 		cmp	ip, #0
 9088 4f3c F4C0A003 		moveq	ip, #244
 9089 4f40 74C0A013 		movne	ip, #116
 9090 4f44 6C3095E5 		ldr	r3, [r5, #108]
 9091 4f48 0400A0E3 		mov	r0, #4
 9092 4f4c 8C119FE5 		ldr	r1, .L761+160
 9093 4f50 08208CE1 		orr	r2, ip, r8
 9094 4f54 FEFFFFEB 		bl	CyU3PDebugPrint
 9095              	.L666:
3199:../uvc.c      ****                     IMcount = 0;
 9096              		.loc 1 3199 0
 9097 4f58 F960C5E5 		strb	r6, [r5, #249]
3201:../uvc.c      ****                 	stiflag = 0x0;
 9098              		.loc 1 3201 0
 9099 4f5c 4E60C5E5 		strb	r6, [r5, #78]
 9100 4f60 A6FFFFEA 		b	.L664
 9101              	.L669:
3187:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 9102              		.loc 1 3187 0
 9103 4f64 6C1095E5 		ldr	r1, [r5, #108]
 9104 4f68 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 9105 4f6c 000051E3 		cmp	r1, #0
 9106 4f70 C410A003 		moveq	r1, #196
 9107 4f74 4410A013 		movne	r1, #68
 9108 4f78 032081E1 		orr	r2, r1, r3
 9109 4f7c 0100A0E3 		mov	r0, #1
 9110 4f80 3010A0E3 		mov	r1, #48
 9111 4f84 5230A0E3 		mov	r3, #82
 9112 4f88 FEFFFFEB 		bl	SensorSetIrisControl
3189:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 9113              		.loc 1 3189 0
 9114 4f8c 6C2095E5 		ldr	r2, [r5, #108]
 9115 4f90 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 9116 4f94 000052E3 		cmp	r2, #0
 9117 4f98 C420A003 		moveq	r2, #196
 9118 4f9c 4420A013 		movne	r2, #68
 9119 4fa0 6C3095E5 		ldr	r3, [r5, #108]
 9120 4fa4 34119FE5 		ldr	r1, .L761+160
 9121 4fa8 0C2082E1 		orr	r2, r2, ip
 9122 4fac 0400A0E3 		mov	r0, #4
 9123 4fb0 FEFFFFEB 		bl	CyU3PDebugPrint
3190:../uvc.c      ****                  		break;
 9124              		.loc 1 3190 0
 9125 4fb4 E7FFFFEA 		b	.L666
 9126              	.L667:
3177:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 9127              		.loc 1 3177 0
 9128 4fb8 6C2095E5 		ldr	r2, [r5, #108]
 9129 4fbc 3010A0E3 		mov	r1, #48
 9130 4fc0 000052E3 		cmp	r2, #0
 9131 4fc4 E420A003 		moveq	r2, #228
 9132 4fc8 6420A013 		movne	r2, #100
 9133 4fcc 5230A0E3 		mov	r3, #82
 9134 4fd0 0100A0E3 		mov	r0, #1
 9135 4fd4 FEFFFFEB 		bl	SensorSetIrisControl
3179:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 9136              		.loc 1 3179 0
 9137 4fd8 6C2095E5 		ldr	r2, [r5, #108]
 9138 4fdc FC109FE5 		ldr	r1, .L761+160
 9139 4fe0 000052E3 		cmp	r2, #0
 9140 4fe4 6C3095E5 		ldr	r3, [r5, #108]
 9141 4fe8 E420A003 		moveq	r2, #228
 9142 4fec 6420A013 		movne	r2, #100
 9143 4ff0 0400A0E3 		mov	r0, #4
 9144 4ff4 FEFFFFEB 		bl	CyU3PDebugPrint
3180:../uvc.c      ****                  		break;
 9145              		.loc 1 3180 0
 9146 4ff8 D6FFFFEA 		b	.L666
 9147              	.L668:
3182:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 9148              		.loc 1 3182 0
 9149 4ffc 6C2095E5 		ldr	r2, [r5, #108]
 9150 5000 3010A0E3 		mov	r1, #48
 9151 5004 000052E3 		cmp	r2, #0
 9152 5008 D420A003 		moveq	r2, #212
 9153 500c 5420A013 		movne	r2, #84
 9154 5010 5230A0E3 		mov	r3, #82
 9155 5014 0100A0E3 		mov	r0, #1
 9156 5018 FEFFFFEB 		bl	SensorSetIrisControl
3184:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 9157              		.loc 1 3184 0
 9158 501c 6C2095E5 		ldr	r2, [r5, #108]
 9159 5020 B8109FE5 		ldr	r1, .L761+160
 9160 5024 000052E3 		cmp	r2, #0
 9161 5028 6C3095E5 		ldr	r3, [r5, #108]
 9162 502c D420A003 		moveq	r2, #212
 9163 5030 5420A013 		movne	r2, #84
 9164 5034 0400A0E3 		mov	r0, #4
 9165 5038 FEFFFFEB 		bl	CyU3PDebugPrint
3185:../uvc.c      ****                  		break;
 9166              		.loc 1 3185 0
 9167 503c C5FFFFEA 		b	.L666
 9168              	.L762:
 9169              		.align	2
 9170              	.L761:
 9171 5040 98080000 		.word	.LC49
 9172 5044 00C20100 		.word	115200
 9173 5048 B8080000 		.word	.LC50
 9174 504c A0860100 		.word	100000
 9175 5050 D4080000 		.word	.LC51
 9176 5054 00000000 		.word	.LANCHOR0
 9177 5058 00000000 		.word	CyFxGpifCB
 9178 505c 88130000 		.word	5000
 9179 5060 00000000 		.word	CyFxUVCApplnUSBSetupCB
 9180 5064 00000000 		.word	CyFxUVCApplnUSBEventCB
 9181 5068 00000000 		.word	CyFxUSBDeviceDscr
 9182 506c 00000000 		.word	CyFxUSBDeviceDscrSS
 9183 5070 00000000 		.word	CyFxUSBDeviceQualDscr
 9184 5074 00000000 		.word	CyFxUSBBOSDscr
 9185 5078 00000000 		.word	CyFxUSBHSConfigDscr
 9186 507c 00000000 		.word	CyFxUSBFSConfigDscr
 9187 5080 00000000 		.word	CyFxUSBSSConfigDscr
 9188 5084 00000000 		.word	CyFxUSBStringLangIDDscr
 9189 5088 00000000 		.word	CyFxUSBManufactureDscr
 9190 508c 00000000 		.word	CyFxUSBProductDscr
 9191 5090 013F0000 		.word	16129
 9192 5094 02030000 		.word	770
 9193 5098 00000000 		.word	glChHandleInterStat
 9194 509c 00000000 		.word	glInterStaBuffer
 9195 50a0 00000000 		.word	imgHdMux
 9196 50a4 01010000 		.word	257
 9197 50a8 03030000 		.word	771
 9198 50ac 00000000 		.word	CyFxUvcApplnDmaCallback
 9199 50b0 00000000 		.word	glChHandleUVCStream
 9200 50b4 00000000 		.word	.LANCHOR1
 9201 50b8 F0080000 		.word	.LC52
 9202 50bc 18020000 		.word	.LC14
 9203 50c0 40090000 		.word	.LC54
 9204 50c4 1C090000 		.word	.LC53
 9205 50c8 68090000 		.word	.LC55
 9206 50cc C00A0000 		.word	.LC62
 9207 50d0 9C0B0000 		.word	.LC66
 9208 50d4 340B0000 		.word	.LC64
 9209 50d8 F40A0000 		.word	.LC63
 9210 50dc 6C0B0000 		.word	.LC65
 9211 50e0 C40B0000 		.word	.LC67
 9212 50e4 8C0C0000 		.word	.LC72
 9213 50e8 3C000000 		.word	.LANCHOR2+60
 9214 50ec D40C0000 		.word	.LC74
 9215 50f0 7C0C0000 		.word	.LC71
 9216 50f4 20000000 		.word	.LANCHOR2+32
 9217 50f8 9C0C0000 		.word	.LC73
 9218 50fc 480C0000 		.word	.LC70
 9219 5100 B80B0000 		.word	3000
 9220 5104 900A0000 		.word	.LC61
 9221 5108 600A0000 		.word	.LC60
 9222 510c 280A0000 		.word	.LC59
 9223 5110 C0090000 		.word	.LC57
 9224 5114 94090000 		.word	.LC56
 9225 5118 F4090000 		.word	.LC58
 9226 511c 140C0000 		.word	.LC69
 9227 5120 E80B0000 		.word	.LC68
 9228              		.cfi_endproc
 9229              	.LFE19:
 9231              		.align	2
 9232              		.global	CyFxApplicationDefine
 9234              	CyFxApplicationDefine:
 9235              	.LFB27:
4701:../uvc.c      **** }
4702:../uvc.c      **** 
4703:../uvc.c      **** 
4704:../uvc.c      **** /*
4705:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4706:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4707:../uvc.c      ****  */
4708:../uvc.c      **** void
4709:../uvc.c      **** CyFxApplicationDefine (
4710:../uvc.c      ****         void)
4711:../uvc.c      **** {
 9236              		.loc 1 4711 0
 9237              		.cfi_startproc
 9238              		@ args = 0, pretend = 0, frame = 32
 9239              		@ frame_needed = 0, uses_anonymous_args = 0
 9240              	.LVL810:
 9241 5124 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 9242              	.LCFI28:
 9243              		.cfi_def_cfa_offset 32
4712:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4713:../uvc.c      ****     uint32_t retThrdCreate;
4714:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4715:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4716:../uvc.c      **** 
4717:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4718:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9244              		.loc 1 4718 0
 9245 5128 010AA0E3 		mov	r0, #4096
4711:../uvc.c      **** {
 9246              		.loc 1 4711 0
 9247 512c 40D04DE2 		sub	sp, sp, #64
 9248              	.LCFI29:
 9249              		.cfi_def_cfa_offset 96
 9250              		.loc 1 4718 0
 9251              		.cfi_offset 14, -4
 9252              		.cfi_offset 10, -8
 9253              		.cfi_offset 9, -12
 9254              		.cfi_offset 8, -16
 9255              		.cfi_offset 7, -20
 9256              		.cfi_offset 6, -24
 9257              		.cfi_offset 5, -28
 9258              		.cfi_offset 4, -32
 9259 5130 FEFFFFEB 		bl	CyU3PMemAlloc
 9260 5134 0080A0E1 		mov	r8, r0
 9261              	.LVL811:
4719:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9262              		.loc 1 4719 0
 9263 5138 010AA0E3 		mov	r0, #4096
 9264              	.LVL812:
 9265 513c FEFFFFEB 		bl	CyU3PMemAlloc
 9266 5140 00A0A0E1 		mov	sl, r0
 9267              	.LVL813:
4720:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9268              		.loc 1 4720 0
 9269 5144 010AA0E3 		mov	r0, #4096
 9270              	.LVL814:
 9271 5148 FEFFFFEB 		bl	CyU3PMemAlloc
4721:../uvc.c      **** 
4722:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 9272              		.loc 1 4722 0
 9273 514c 000058E3 		cmp	r8, #0
 9274 5150 00005A13 		cmpne	sl, #0
 9275 5154 0070A013 		movne	r7, #0
 9276 5158 0170A003 		moveq	r7, #1
4720:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9277              		.loc 1 4720 0
 9278 515c 0090A0E1 		mov	r9, r0
 9279              	.LVL815:
 9280              		.loc 1 4722 0
 9281 5160 0000001A 		bne	.L767
 9282              	.LVL816:
 9283              	.L764:
 9284              	.L766:
 9285 5164 FEFFFFEA 		b	.L766
 9286              	.L767:
 9287              		.loc 1 4722 0 is_stmt 0 discriminator 1
 9288 5168 000050E3 		cmp	r0, #0
 9289 516c FCFFFF0A 		beq	.L764
 9290              	.LVL817:
4723:../uvc.c      ****         goto fatalErrorHandler;
4724:../uvc.c      **** 
4725:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4726:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4727:../uvc.c      ****     char *staName = "I2CstaQue";
4728:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9291              		.loc 1 4728 0 is_stmt 1
 9292 5170 04619FE5 		ldr	r6, .L768
 9293 5174 20408DE2 		add	r4, sp, #32
 9294 5178 0400A0E1 		mov	r0, r4
 9295 517c 4010A0E3 		mov	r1, #64
 9296 5180 F8209FE5 		ldr	r2, .L768+4
 9297 5184 0730A0E1 		mov	r3, r7
 9298 5188 00608DE5 		str	r6, [sp, #0]
 9299 518c FEFFFFEB 		bl	cmdbufCreate
 9300 5190 04E0A0E1 		mov	lr, r4
 9301 5194 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 9302 5198 E4C09FE5 		ldr	ip, .L768+8
4729:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4730:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4731:../uvc.c      **** 
4732:../uvc.c      **** 	/****** initialize command descriptor ***********/
4733:../uvc.c      **** 	cmdquInit(cmdQuptr);
4734:../uvc.c      **** 	cmdquInit(statQuptr);
4735:../uvc.c      **** 
4736:../uvc.c      ****     /* Create the UVC application thread. */
4737:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 9303              		.loc 1 4737 0
 9304 519c 0840A0E3 		mov	r4, #8
4728:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9305              		.loc 1 4728 0
 9306 51a0 0C50A0E1 		mov	r5, ip
 9307 51a4 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 9308 51a8 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 9309              		.loc 1 4737 0
 9310 51ac 0160A0E3 		mov	r6, #1
4728:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9311              		.loc 1 4728 0
 9312 51b0 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
4733:../uvc.c      **** 	cmdquInit(cmdQuptr);
 9313              		.loc 1 4733 0
 9314 51b4 0C00A0E1 		mov	r0, ip
 9315 51b8 FEFFFFEB 		bl	cmdquInit
4734:../uvc.c      **** 	cmdquInit(statQuptr);
 9316              		.loc 1 4734 0
 9317 51bc C4009FE5 		ldr	r0, .L768+12
 9318 51c0 FEFFFFEB 		bl	cmdquInit
 9319              		.loc 1 4737 0
 9320 51c4 A850A0E3 		mov	r5, #168
 9321 51c8 01CAA0E3 		mov	ip, #4096
 9322 51cc B8009FE5 		ldr	r0, .L768+16
 9323 51d0 B8109FE5 		ldr	r1, .L768+20
 9324 51d4 B8209FE5 		ldr	r2, .L768+24
 9325 51d8 0730A0E1 		mov	r3, r7
 9326 51dc 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 9327 51e0 08408DE5 		str	r4, [sp, #8]
 9328 51e4 0C408DE5 		str	r4, [sp, #12]
 9329 51e8 10708DE5 		str	r7, [sp, #16]
 9330 51ec 14608DE5 		str	r6, [sp, #20]
 9331 51f0 18508DE5 		str	r5, [sp, #24]
 9332 51f4 FEFFFFEB 		bl	_txe_thread_create
 9333              	.LVL818:
4738:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4739:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4740:../uvc.c      ****             0,                                          /* No input parameter to thread */
4741:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4742:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4743:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4744:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4745:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4746:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4747:../uvc.c      ****             );
4748:../uvc.c      ****     if (retThrdCreate != 0)
 9334              		.loc 1 4748 0
 9335 51f8 00C050E2 		subs	ip, r0, #0
 9336 51fc D8FFFF1A 		bne	.L764
4749:../uvc.c      ****     {
4750:../uvc.c      ****         goto fatalErrorHandler;
4751:../uvc.c      ****     }
4752:../uvc.c      **** 
4753:../uvc.c      ****     /* Create the control request handling thread. */
4754:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 9337              		.loc 1 4754 0
 9338 5200 0C30A0E1 		mov	r3, ip
 9339 5204 027BA0E3 		mov	r7, #2048
 9340 5208 88009FE5 		ldr	r0, .L768+28
 9341              	.LVL819:
 9342 520c 88109FE5 		ldr	r1, .L768+32
 9343 5210 88209FE5 		ldr	r2, .L768+36
 9344 5214 10C08DE5 		str	ip, [sp, #16]
 9345 5218 00A08DE5 		str	sl, [sp, #0]
 9346 521c 04708DE5 		str	r7, [sp, #4]
 9347 5220 08408DE5 		str	r4, [sp, #8]
 9348 5224 0C408DE5 		str	r4, [sp, #12]
 9349 5228 14608DE5 		str	r6, [sp, #20]
 9350 522c 18508DE5 		str	r5, [sp, #24]
 9351 5230 FEFFFFEB 		bl	_txe_thread_create
 9352              	.LVL820:
4755:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4756:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4757:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4758:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4759:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4760:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4761:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4762:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4763:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4764:../uvc.c      ****             );
4765:../uvc.c      ****     if (retThrdCreate != 0)
 9353              		.loc 1 4765 0
 9354 5234 00C050E2 		subs	ip, r0, #0
 9355 5238 C9FFFF1A 		bne	.L764
4766:../uvc.c      ****     {
4767:../uvc.c      ****         goto fatalErrorHandler;
4768:../uvc.c      ****     }
4769:../uvc.c      **** #if 1
4770:../uvc.c      ****     /* Create the I2C control command handling thread. */
4771:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 9356              		.loc 1 4771 0
 9357 523c 60009FE5 		ldr	r0, .L768+40
 9358              	.LVL821:
 9359 5240 60109FE5 		ldr	r1, .L768+44
 9360 5244 60209FE5 		ldr	r2, .L768+48
 9361 5248 0C30A0E1 		mov	r3, ip
 9362 524c 00908DE5 		str	r9, [sp, #0]
 9363 5250 04708DE5 		str	r7, [sp, #4]
 9364 5254 08408DE5 		str	r4, [sp, #8]
 9365 5258 0C408DE5 		str	r4, [sp, #12]
 9366 525c 10C08DE5 		str	ip, [sp, #16]
 9367 5260 14608DE5 		str	r6, [sp, #20]
 9368 5264 18508DE5 		str	r5, [sp, #24]
 9369 5268 FEFFFFEB 		bl	_txe_thread_create
 9370              	.LVL822:
4772:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4773:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4774:../uvc.c      ****             0,                                          /* No input parameter to thread */
4775:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4776:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4777:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4778:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4779:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4780:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4781:../uvc.c      ****             );
4782:../uvc.c      ****     if (retThrdCreate != 0)
 9371              		.loc 1 4782 0
 9372 526c 000050E3 		cmp	r0, #0
 9373 5270 BBFFFF1A 		bne	.L764
4783:../uvc.c      ****     {
4784:../uvc.c      ****         goto fatalErrorHandler;
4785:../uvc.c      ****     }
4786:../uvc.c      **** #endif
4787:../uvc.c      **** 
4788:../uvc.c      ****     return;
4789:../uvc.c      **** 
4790:../uvc.c      **** fatalErrorHandler:
4791:../uvc.c      ****     /* Add custom recovery or debug actions here */
4792:../uvc.c      ****     /* Loop indefinitely */
4793:../uvc.c      ****     while (1);
4794:../uvc.c      **** }
 9374              		.loc 1 4794 0
 9375 5274 40D08DE2 		add	sp, sp, #64
 9376 5278 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 9377              	.L769:
 9378              		.align	2
 9379              	.L768:
 9380 527c 00000000 		.word	cmdQuMux
 9381 5280 0C0D0000 		.word	.LC75
 9382 5284 00000000 		.word	cmdQu
 9383 5288 00000000 		.word	statQu
 9384 528c FC000000 		.word	.LANCHOR0+252
 9385 5290 180D0000 		.word	.LC76
 9386 5294 00000000 		.word	UVCAppThread_Entry
 9387 5298 A4010000 		.word	.LANCHOR0+420
 9388 529c 2C0D0000 		.word	.LC77
 9389 52a0 00000000 		.word	UVCAppEP0Thread_Entry
 9390 52a4 4C020000 		.word	.LANCHOR0+588
 9391 52a8 440D0000 		.word	.LC78
 9392 52ac 00000000 		.word	I2cAppThread_Entry
 9393              		.cfi_endproc
 9394              	.LFE27:
 9396              		.align	2
 9397              		.global	main
 9399              	main:
 9400              	.LFB28:
4795:../uvc.c      **** 
4796:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4797:../uvc.c      ****  * the ThreadX RTOS here.
4798:../uvc.c      ****  */
4799:../uvc.c      **** int
4800:../uvc.c      **** main (
4801:../uvc.c      ****         void)
4802:../uvc.c      **** {
 9401              		.loc 1 4802 0
 9402              		.cfi_startproc
 9403              		@ args = 0, pretend = 0, frame = 56
 9404              		@ frame_needed = 0, uses_anonymous_args = 0
 9405 52b0 30402DE9 		stmfd	sp!, {r4, r5, lr}
 9406              	.LCFI30:
 9407              		.cfi_def_cfa_offset 12
4803:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4804:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4805:../uvc.c      **** 
4806:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4807:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4808:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4809:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4810:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4811:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9408              		.loc 1 4811 0
 9409 52b4 0010A0E3 		mov	r1, #0
4802:../uvc.c      **** {
 9410              		.loc 1 4802 0
 9411 52b8 3CD04DE2 		sub	sp, sp, #60
 9412              	.LCFI31:
 9413              		.cfi_def_cfa_offset 72
4808:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9414              		.loc 1 4808 0
 9415 52bc 0220A0E3 		mov	r2, #2
4812:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9416              		.loc 1 4812 0
 9417 52c0 033081E2 		add	r3, r1, #3
4807:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9418              		.loc 1 4807 0
 9419 52c4 0150A0E3 		mov	r5, #1
 9420              		.cfi_offset 14, -4
 9421              		.cfi_offset 5, -8
 9422              		.cfi_offset 4, -12
4813:../uvc.c      **** 
4814:../uvc.c      ****     /* Initialize the device */
4815:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9423              		.loc 1 4815 0
 9424 52c8 28008DE2 		add	r0, sp, #40
4807:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9425              		.loc 1 4807 0
 9426 52cc 28508DE5 		str	r5, [sp, #40]
4808:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9427              		.loc 1 4808 0
 9428 52d0 2C20CDE5 		strb	r2, [sp, #44]
4809:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9429              		.loc 1 4809 0
 9430 52d4 2D20CDE5 		strb	r2, [sp, #45]
4810:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9431              		.loc 1 4810 0
 9432 52d8 2E20CDE5 		strb	r2, [sp, #46]
4811:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9433              		.loc 1 4811 0
 9434 52dc 30108DE5 		str	r1, [sp, #48]
4812:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9435              		.loc 1 4812 0
 9436 52e0 3430CDE5 		strb	r3, [sp, #52]
 9437              		.loc 1 4815 0
 9438 52e4 FEFFFFEB 		bl	CyU3PDeviceInit
 9439              	.LVL823:
4816:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9440              		.loc 1 4816 0
 9441 52e8 004050E2 		subs	r4, r0, #0
 9442 52ec 0000000A 		beq	.L773
 9443              	.L771:
 9444              	.L772:
 9445 52f0 FEFFFFEA 		b	.L772
 9446              	.L773:
4817:../uvc.c      ****     {
4818:../uvc.c      ****         goto handle_fatal_error;
4819:../uvc.c      ****     }
4820:../uvc.c      **** 
4821:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4822:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 9447              		.loc 1 4822 0
 9448 52f4 0410A0E1 		mov	r1, r4
 9449 52f8 0420A0E1 		mov	r2, r4
 9450 52fc 0500A0E1 		mov	r0, r5
 9451              	.LVL824:
 9452 5300 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 9453              	.LVL825:
4823:../uvc.c      **** 
4824:../uvc.c      ****     /* Configure the IO matrix for the device. */
4825:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4826:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4827:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4828:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4829:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4830:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4831:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4832:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4833:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4834:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4835:../uvc.c      **** 
4836:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 9454              		.loc 1 4836 0
 9455 5304 0D00A0E1 		mov	r0, sp
4826:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 9456              		.loc 1 4826 0
 9457 5308 1640CDE5 		strb	r4, [sp, #22]
4827:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 9458              		.loc 1 4827 0
 9459 530c 18408DE5 		str	r4, [sp, #24]
4828:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 9460              		.loc 1 4828 0
 9461 5310 1C408DE5 		str	r4, [sp, #28]
4829:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 9462              		.loc 1 4829 0
 9463 5314 20408DE5 		str	r4, [sp, #32]
4830:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 9464              		.loc 1 4830 0
 9465 5318 24408DE5 		str	r4, [sp, #36]
4833:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 9466              		.loc 1 4833 0
 9467 531c 0C408DE5 		str	r4, [sp, #12]
4834:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 9468              		.loc 1 4834 0
 9469 5320 10408DE5 		str	r4, [sp, #16]
4825:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 9470              		.loc 1 4825 0
 9471 5324 00508DE5 		str	r5, [sp, #0]
4831:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 9472              		.loc 1 4831 0
 9473 5328 04508DE5 		str	r5, [sp, #4]
4832:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 9474              		.loc 1 4832 0
 9475 532c 08508DE5 		str	r5, [sp, #8]
 9476              		.loc 1 4836 0
 9477 5330 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 9478              	.LVL826:
4837:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9479              		.loc 1 4837 0
 9480 5334 004050E2 		subs	r4, r0, #0
 9481 5338 ECFFFF1A 		bne	.L771
4838:../uvc.c      ****     {
4839:../uvc.c      ****         goto handle_fatal_error;
4840:../uvc.c      ****     }
4841:../uvc.c      **** 
4842:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4843:../uvc.c      ****     CyU3PKernelEntry ();
 9482              		.loc 1 4843 0
 9483 533c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 9484              	.LVL827:
4844:../uvc.c      **** 
4845:../uvc.c      ****     /* Dummy return to make the compiler happy */
4846:../uvc.c      ****     return 0;
4847:../uvc.c      **** 
4848:../uvc.c      **** handle_fatal_error:
4849:../uvc.c      ****     /* Cannot recover from this error. */
4850:../uvc.c      ****     while (1);
4851:../uvc.c      **** }
 9485              		.loc 1 4851 0
 9486 5340 0400A0E1 		mov	r0, r4
 9487 5344 3CD08DE2 		add	sp, sp, #60
 9488 5348 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 9489              		.cfi_endproc
 9490              	.LFE28:
 9492              		.global	CyFxGpifTransition
 9493              		.global	CyFxGpifWavedata
 9494              		.global	CyFxGpifWavedataPosition
 9495              		.global	CyFxGpifRegValue
 9496              		.global	CyFxGpifConfig
 9497              		.global	CyFxGpifTransition_usb2
 9498              		.global	CyFxGpifWavedata_usb2
 9499              		.global	CyFxGpifWavedataPosition_usb2
 9500              		.global	CyFxGpifRegValue_usb2
 9501              		.global	CyFxGpifConfig_usb2
 9502              		.global	snapButFlag
 9503              		.global	testSnap
 9504              		.global	fb
 9505              		.global	pb
 9506              		.global	pbc
 9507              		.global	fbbak
 9508              		.global	pbbak
 9509              		.global	pbcbak
 9510              		.global	pbcpbak
 9511              		.global	isUsbConnected
 9512              		.global	usbSpeed
 9513              		.global	clearFeatureRqtReceived
 9514              		.global	streamingRecove
 9515              		.global	streamingStarted
 9516              		.global	glProbeCtrl
 9517              		.global	glProbeCtrlFull
 9518              		.global	glProbeStilCtrl
 9519              		.global	glProbeCtrl20
 9520              		.global	glProbeStilCtrl20
 9521              		.global	glUVCHeader
 9522              		.comm	glChHandleUVCStream,220,4
 9523              		.comm	glChHandleStillStream,220,4
 9524              		.comm	glChHandleInterStat,160,4
 9525              		.comm	glInterStaBuffer,4,4
 9526              		.comm	cmdQu,32,4
 9527              		.comm	statQu,32,4
 9528              		.comm	cmdQuMux,56,4
 9529              		.comm	staQuMux,56,4
 9530              		.comm	timMux,56,4
 9531              		.comm	imgHdMux,56,4
 9532              		.comm	bmReqType,1,1
 9533              		.comm	bRequest,1,1
 9534              		.comm	wValue,2,2
 9535              		.comm	wIndex,2,2
 9536              		.comm	wLength,2,2
 9537              		.comm	posTick,4,4
 9538              		.comm	I2CCmdTimer,44,4
 9539              		.section	.rodata
 9540              		.align	2
 9541              		.set	.LANCHOR2,. + 0
 9544              	ShutSp:
 9545 0000 3582     		.short	-32203
 9546 0002 1B41     		.short	16667
 9547 0004 8D20     		.short	8333
 9548 0006 A00F     		.short	4000
 9549 0008 D007     		.short	2000
 9550 000a E803     		.short	1000
 9551 000c F401     		.short	500
 9552 000e C800     		.short	200
 9553 0010 6400     		.short	100
 9554 0012 0A00     		.short	10
 9555 0014 0000     		.short	0
 9556 0016 00000000 		.space	10
 9556      00000000 
 9556      0000
 9559              	CyFxGpifConfig:
 9560 0020 0F00     		.short	15
 9561 0022 0000     		.space	2
 9562 0024 00000000 		.word	CyFxGpifWavedata
 9563 0028 00000000 		.word	CyFxGpifWavedataPosition
 9564 002c 0500     		.short	5
 9565 002e 0000     		.space	2
 9566 0030 00000000 		.word	CyFxGpifTransition
 9567 0034 4C00     		.short	76
 9568 0036 0000     		.space	2
 9569 0038 00000000 		.word	CyFxGpifRegValue
 9572              	CyFxGpifConfig_usb2:
 9573 003c 9300     		.short	147
 9574 003e 0000     		.space	2
 9575 0040 00000000 		.word	CyFxGpifWavedata_usb2
 9576 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 9577 0048 0800     		.short	8
 9578 004a 0000     		.space	2
 9579 004c 00000000 		.word	CyFxGpifTransition_usb2
 9580 0050 4C00     		.short	76
 9581 0052 0000     		.space	2
 9582 0054 00000000 		.word	CyFxGpifRegValue_usb2
 9583              		.data
 9584              		.align	2
 9585              		.set	.LANCHOR1,. + 0
 9588              	ExUCtrlParArry:
 9589 0000 00       		.byte	0
 9590 0001 00       		.byte	0
 9591 0002 04       		.byte	4
 9592 0003 01       		.byte	1
 9593 0004 00       		.byte	0
 9594 0005 38       		.byte	56
 9595 0006 01       		.byte	1
 9596 0007 01       		.byte	1
 9597 0008 00       		.byte	0
 9598 0009 03       		.byte	3
 9599 000a 00       		.byte	0
 9600 000b 4E       		.byte	78
 9601 000c 00       		.byte	0
 9602 000d 4E       		.byte	78
 9603 000e 00       		.byte	0
 9604 000f 30       		.byte	48
 9605 0010 01       		.byte	1
 9606 0011 00       		.byte	0
 9607 0012 00       		.byte	0
 9608 0013 00000000 		.space	5
 9608      00
 9609 0018 00       		.byte	0
 9610 0019 00       		.byte	0
 9611 001a 01       		.byte	1
 9612 001b 00       		.byte	0
 9613 001c 00       		.byte	0
 9614 001d 00       		.byte	0
 9615 001e 00       		.byte	0
 9616 001f 01       		.byte	1
 9617 0020 00       		.byte	0
 9618 0021 03       		.byte	3
 9619 0022 00       		.byte	0
 9620 0023 00       		.byte	0
 9621 0024 00       		.byte	0
 9622 0025 00       		.byte	0
 9623 0026 00       		.byte	0
 9624 0027 30       		.byte	48
 9625 0028 01       		.byte	1
 9626 0029 00       		.byte	0
 9627 002a 00       		.byte	0
 9628 002b 00000000 		.space	5
 9628      00
 9629 0030 00       		.byte	0
 9630 0031 00       		.byte	0
 9631 0032 02       		.byte	2
 9632 0033 00       		.byte	0
 9633 0034 00       		.byte	0
 9634 0035 FF       		.byte	-1
 9635 0036 00       		.byte	0
 9636 0037 01       		.byte	1
 9637 0038 00       		.byte	0
 9638 0039 03       		.byte	3
 9639 003a 00       		.byte	0
 9640 003b 01       		.byte	1
 9641 003c 00       		.byte	0
 9642 003d 00       		.byte	0
 9643 003e 00       		.byte	0
 9644 003f 30       		.byte	48
 9645 0040 01       		.byte	1
 9646 0041 01       		.byte	1
 9647 0042 00       		.byte	0
 9648 0043 00000000 		.space	5
 9648      00
 9649 0048 00       		.byte	0
 9650 0049 00       		.byte	0
 9651 004a 02       		.byte	2
 9652 004b 00       		.byte	0
 9653 004c 00       		.byte	0
 9654 004d 00       		.byte	0
 9655 004e 00       		.byte	0
 9656 004f 00       		.byte	0
 9657 0050 00       		.byte	0
 9658 0051 03       		.byte	3
 9659 0052 00       		.byte	0
 9660 0053 00       		.byte	0
 9661 0054 00       		.byte	0
 9662 0055 00       		.byte	0
 9663 0056 00       		.byte	0
 9664 0057 30       		.byte	48
 9665 0058 01       		.byte	1
 9666 0059 01       		.byte	1
 9667 005a 00       		.byte	0
 9668 005b 00000000 		.space	5
 9668      00
 9669 0060 13       		.byte	19
 9670 0061 14       		.byte	20
 9671 0062 02       		.byte	2
 9672 0063 00       		.byte	0
 9673 0064 00       		.byte	0
 9674 0065 FF       		.byte	-1
 9675 0066 FF       		.byte	-1
 9676 0067 01       		.byte	1
 9677 0068 00       		.byte	0
 9678 0069 03       		.byte	3
 9679 006a 00       		.byte	0
 9680 006b 66       		.byte	102
 9681 006c 66       		.byte	102
 9682 006d 66       		.byte	102
 9683 006e 66       		.byte	102
 9684 006f 30       		.byte	48
 9685 0070 01       		.byte	1
 9686 0071 00       		.byte	0
 9687 0072 00       		.byte	0
 9688 0073 00000000 		.space	5
 9688      00
 9689 0078 11       		.byte	17
 9690 0079 00       		.byte	0
 9691 007a 02       		.byte	2
 9692 007b 01       		.byte	1
 9693 007c 00       		.byte	0
 9694 007d 03       		.byte	3
 9695 007e 00       		.byte	0
 9696 007f 01       		.byte	1
 9697 0080 00       		.byte	0
 9698 0081 03       		.byte	3
 9699 0082 00       		.byte	0
 9700 0083 80       		.byte	-128
 9701 0084 00       		.byte	0
 9702 0085 80       		.byte	-128
 9703 0086 00       		.byte	0
 9704 0087 30       		.byte	48
 9705 0088 01       		.byte	1
 9706 0089 01       		.byte	1
 9707 008a 00       		.byte	0
 9708 008b 00000000 		.space	5
 9708      00
 9709 0090 10       		.byte	16
 9710 0091 00       		.byte	0
 9711 0092 01       		.byte	1
 9712 0093 01       		.byte	1
 9713 0094 00       		.byte	0
 9714 0095 02       		.byte	2
 9715 0096 00       		.byte	0
 9716 0097 01       		.byte	1
 9717 0098 00       		.byte	0
 9718 0099 03       		.byte	3
 9719 009a 00       		.byte	0
 9720 009b 00       		.byte	0
 9721 009c 00       		.byte	0
 9722 009d 00       		.byte	0
 9723 009e 00       		.byte	0
 9724 009f 30       		.byte	48
 9725 00a0 01       		.byte	1
 9726 00a1 01       		.byte	1
 9727 00a2 00       		.byte	0
 9728 00a3 00000000 		.space	5
 9728      00
 9729 00a8 00       		.byte	0
 9730 00a9 00       		.byte	0
 9731 00aa 04       		.byte	4
 9732 00ab 01       		.byte	1
 9733 00ac 00       		.byte	0
 9734 00ad 38       		.byte	56
 9735 00ae 01       		.byte	1
 9736 00af 01       		.byte	1
 9737 00b0 00       		.byte	0
 9738 00b1 03       		.byte	3
 9739 00b2 00       		.byte	0
 9740 00b3 4E       		.byte	78
 9741 00b4 00       		.byte	0
 9742 00b5 4E       		.byte	78
 9743 00b6 00       		.byte	0
 9744 00b7 30       		.byte	48
 9745 00b8 01       		.byte	1
 9746 00b9 00       		.byte	0
 9747 00ba 00       		.byte	0
 9748 00bb 00000000 		.space	5
 9748      00
 9749 00c0 00       		.byte	0
 9750 00c1 00       		.byte	0
 9751 00c2 01       		.byte	1
 9752 00c3 00       		.byte	0
 9753 00c4 00       		.byte	0
 9754 00c5 00       		.byte	0
 9755 00c6 00       		.byte	0
 9756 00c7 01       		.byte	1
 9757 00c8 00       		.byte	0
 9758 00c9 03       		.byte	3
 9759 00ca 00       		.byte	0
 9760 00cb 00       		.byte	0
 9761 00cc 00       		.byte	0
 9762 00cd 00       		.byte	0
 9763 00ce 00       		.byte	0
 9764 00cf 30       		.byte	48
 9765 00d0 01       		.byte	1
 9766 00d1 00       		.byte	0
 9767 00d2 00       		.byte	0
 9768 00d3 00000000 		.space	5
 9768      00
 9769 00d8 00       		.byte	0
 9770 00d9 00       		.byte	0
 9771 00da 02       		.byte	2
 9772 00db 00       		.byte	0
 9773 00dc 00       		.byte	0
 9774 00dd 05       		.byte	5
 9775 00de 00       		.byte	0
 9776 00df 01       		.byte	1
 9777 00e0 00       		.byte	0
 9778 00e1 03       		.byte	3
 9779 00e2 00       		.byte	0
 9780 00e3 00       		.byte	0
 9781 00e4 00       		.byte	0
 9782 00e5 00       		.byte	0
 9783 00e6 00       		.byte	0
 9784 00e7 30       		.byte	48
 9785 00e8 01       		.byte	1
 9786 00e9 00       		.byte	0
 9787 00ea 00       		.byte	0
 9788 00eb 00000000 		.space	5
 9788      00
 9789 00f0 00       		.byte	0
 9790 00f1 00       		.byte	0
 9791 00f2 03       		.byte	3
 9792 00f3 00       		.byte	0
 9793 00f4 00       		.byte	0
 9794 00f5 0A       		.byte	10
 9795 00f6 00       		.byte	0
 9796 00f7 01       		.byte	1
 9797 00f8 00       		.byte	0
 9798 00f9 03       		.byte	3
 9799 00fa 00       		.byte	0
 9800 00fb 00       		.byte	0
 9801 00fc 00       		.byte	0
 9802 00fd 00       		.byte	0
 9803 00fe 00       		.byte	0
 9804 00ff 30       		.byte	48
 9805 0100 01       		.byte	1
 9806 0101 00       		.byte	0
 9807 0102 00       		.byte	0
 9808 0103 00000000 		.space	5
 9808      00
 9809 0108 00       		.byte	0
 9810 0109 00       		.byte	0
 9811 010a 02       		.byte	2
 9812 010b 00       		.byte	0
 9813 010c 00       		.byte	0
 9814 010d 40       		.byte	64
 9815 010e 00       		.byte	0
 9816 010f 01       		.byte	1
 9817 0110 00       		.byte	0
 9818 0111 03       		.byte	3
 9819 0112 00       		.byte	0
 9820 0113 0F       		.byte	15
 9821 0114 11       		.byte	17
 9822 0115 00       		.byte	0
 9823 0116 00       		.byte	0
 9824 0117 30       		.byte	48
 9825 0118 01       		.byte	1
 9826 0119 00       		.byte	0
 9827 011a 00       		.byte	0
 9828 011b 00000000 		.space	5
 9828      00
 9829 0120 00       		.byte	0
 9830 0121 00       		.byte	0
 9831 0122 02       		.byte	2
 9832 0123 00       		.byte	0
 9833 0124 00       		.byte	0
 9834 0125 64       		.byte	100
 9835 0126 00       		.byte	0
 9836 0127 01       		.byte	1
 9837 0128 00       		.byte	0
 9838 0129 03       		.byte	3
 9839 012a 00       		.byte	0
 9840 012b 00       		.byte	0
 9841 012c 00       		.byte	0
 9842 012d 00       		.byte	0
 9843 012e 00       		.byte	0
 9844 012f 30       		.byte	48
 9845 0130 01       		.byte	1
 9846 0131 00       		.byte	0
 9847 0132 00       		.byte	0
 9848 0133 00000000 		.space	5
 9848      00
 9849 0138 00       		.byte	0
 9850 0139 00       		.byte	0
 9851 013a 02       		.byte	2
 9852 013b 00       		.byte	0
 9853 013c 00       		.byte	0
 9854 013d 64       		.byte	100
 9855 013e 00       		.byte	0
 9856 013f 01       		.byte	1
 9857 0140 00       		.byte	0
 9858 0141 03       		.byte	3
 9859 0142 00       		.byte	0
 9860 0143 00       		.byte	0
 9861 0144 00       		.byte	0
 9862 0145 00       		.byte	0
 9863 0146 00       		.byte	0
 9864 0147 30       		.byte	48
 9865 0148 01       		.byte	1
 9866 0149 00       		.byte	0
 9867 014a 00       		.byte	0
 9868 014b 00000000 		.space	5
 9868      00
 9869 0150 00       		.byte	0
 9870 0151 00       		.byte	0
 9871 0152 02       		.byte	2
 9872 0153 00       		.byte	0
 9873 0154 00       		.byte	0
 9874 0155 64       		.byte	100
 9875 0156 00       		.byte	0
 9876 0157 01       		.byte	1
 9877 0158 00       		.byte	0
 9878 0159 03       		.byte	3
 9879 015a 00       		.byte	0
 9880 015b 00       		.byte	0
 9881 015c 00       		.byte	0
 9882 015d 00       		.byte	0
 9883 015e 00       		.byte	0
 9884 015f 30       		.byte	48
 9885 0160 01       		.byte	1
 9886 0161 00       		.byte	0
 9887 0162 00       		.byte	0
 9888 0163 00000000 		.space	5
 9888      00
 9889 0168 00       		.byte	0
 9890 0169 00       		.byte	0
 9891 016a 02       		.byte	2
 9892 016b 00       		.byte	0
 9893 016c 00       		.byte	0
 9894 016d 64       		.byte	100
 9895 016e 00       		.byte	0
 9896 016f 01       		.byte	1
 9897 0170 00       		.byte	0
 9898 0171 03       		.byte	3
 9899 0172 00       		.byte	0
 9900 0173 00       		.byte	0
 9901 0174 00       		.byte	0
 9902 0175 00       		.byte	0
 9903 0176 00       		.byte	0
 9904 0177 30       		.byte	48
 9905 0178 01       		.byte	1
 9906 0179 00       		.byte	0
 9907 017a 00       		.byte	0
 9908 017b 00000000 		.space	5
 9908      00
 9911              	CtrlParArry:
 9912 0180 10       		.byte	16
 9913 0181 10       		.byte	16
 9914 0182 02       		.byte	2
 9915 0183 00       		.byte	0
 9916 0184 00       		.byte	0
 9917 0185 03       		.byte	3
 9918 0186 00       		.byte	0
 9919 0187 01       		.byte	1
 9920 0188 00       		.byte	0
 9921 0189 03       		.byte	3
 9922 018a 00       		.byte	0
 9923 018b 03       		.byte	3
 9924 018c 00       		.byte	0
 9925 018d 03       		.byte	3
 9926 018e 00       		.byte	0
 9927 018f 30       		.byte	48
 9928 0190 01       		.byte	1
 9929 0191 00       		.byte	0
 9930 0192 00       		.byte	0
 9931 0193 00000000 		.space	5
 9931      00
 9932 0198 15       		.byte	21
 9933 0199 15       		.byte	21
 9934 019a 02       		.byte	2
 9935 019b 00       		.byte	0
 9936 019c 00       		.byte	0
 9937 019d FF       		.byte	-1
 9938 019e 00       		.byte	0
 9939 019f 01       		.byte	1
 9940 01a0 00       		.byte	0
 9941 01a1 03       		.byte	3
 9942 01a2 00       		.byte	0
 9943 01a3 76       		.byte	118
 9944 01a4 00       		.byte	0
 9945 01a5 76       		.byte	118
 9946 01a6 C7       		.byte	-57
 9947 01a7 30       		.byte	48
 9948 01a8 01       		.byte	1
 9949 01a9 01       		.byte	1
 9950 01aa 00       		.byte	0
 9951 01ab 00000000 		.space	5
 9951      00
 9952 01b0 04       		.byte	4
 9953 01b1 04       		.byte	4
 9954 01b2 02       		.byte	2
 9955 01b3 00       		.byte	0
 9956 01b4 00       		.byte	0
 9957 01b5 FF       		.byte	-1
 9958 01b6 00       		.byte	0
 9959 01b7 01       		.byte	1
 9960 01b8 00       		.byte	0
 9961 01b9 03       		.byte	3
 9962 01ba 00       		.byte	0
 9963 01bb 70       		.byte	112
 9964 01bc 00       		.byte	0
 9965 01bd 70       		.byte	112
 9966 01be 00       		.byte	0
 9967 01bf 30       		.byte	48
 9968 01c0 01       		.byte	1
 9969 01c1 01       		.byte	1
 9970 01c2 00       		.byte	0
 9971 01c3 00000000 		.space	5
 9971      00
 9972 01c8 00       		.byte	0
 9973 01c9 00       		.byte	0
 9974 01ca 02       		.byte	2
 9975 01cb 00       		.byte	0
 9976 01cc 00       		.byte	0
 9977 01cd 64       		.byte	100
 9978 01ce 00       		.byte	0
 9979 01cf 01       		.byte	1
 9980 01d0 00       		.byte	0
 9981 01d1 03       		.byte	3
 9982 01d2 00       		.byte	0
 9983 01d3 00       		.byte	0
 9984 01d4 00       		.byte	0
 9985 01d5 00       		.byte	0
 9986 01d6 00       		.byte	0
 9987 01d7 30       		.byte	48
 9988 01d8 01       		.byte	1
 9989 01d9 00       		.byte	0
 9990 01da 00       		.byte	0
 9991 01db 00000000 		.space	5
 9991      00
 9992 01e0 07       		.byte	7
 9993 01e1 07       		.byte	7
 9994 01e2 02       		.byte	2
 9995 01e3 00       		.byte	0
 9996 01e4 00       		.byte	0
 9997 01e5 01       		.byte	1
 9998 01e6 00       		.byte	0
 9999 01e7 01       		.byte	1
 10000 01e8 00       		.byte	0
 10001 01e9 03       		.byte	3
 10002 01ea 00       		.byte	0
 10003 01eb 01       		.byte	1
 10004 01ec 00       		.byte	0
 10005 01ed 01       		.byte	1
 10006 01ee 00       		.byte	0
 10007 01ef 30       		.byte	48
 10008 01f0 01       		.byte	1
 10009 01f1 00       		.byte	0
 10010 01f2 00       		.byte	0
 10011 01f3 00000000 		.space	5
 10011      00
 10012 01f8 DF       		.byte	-33
 10013 01f9 E1       		.byte	-31
 10014 01fa 02       		.byte	2
 10015 01fb 00       		.byte	0
 10016 01fc 00       		.byte	0
 10017 01fd FF       		.byte	-1
 10018 01fe 00       		.byte	0
 10019 01ff 01       		.byte	1
 10020 0200 00       		.byte	0
 10021 0201 03       		.byte	3
 10022 0202 00       		.byte	0
 10023 0203 80       		.byte	-128
 10024 0204 00       		.byte	0
 10025 0205 00       		.byte	0
 10026 0206 00       		.byte	0
 10027 0207 C6       		.byte	-58
 10028 0208 01       		.byte	1
 10029 0209 01       		.byte	1
 10030 020a 00       		.byte	0
 10031 020b 00000000 		.space	5
 10031      00
 10032 0210 85       		.byte	-123
 10033 0211 86       		.byte	-122
 10034 0212 02       		.byte	2
 10035 0213 00       		.byte	0
 10036 0214 00       		.byte	0
 10037 0215 64       		.byte	100
 10038 0216 00       		.byte	0
 10039 0217 01       		.byte	1
 10040 0218 00       		.byte	0
 10041 0219 03       		.byte	3
 10042 021a 00       		.byte	0
 10043 021b 32       		.byte	50
 10044 021c 00       		.byte	0
 10045 021d 32       		.byte	50
 10046 021e 00       		.byte	0
 10047 021f F2       		.byte	-14
 10048 0220 01       		.byte	1
 10049 0221 01       		.byte	1
 10050 0222 00       		.byte	0
 10051 0223 00000000 		.space	5
 10051      00
 10052 0228 06       		.byte	6
 10053 0229 06       		.byte	6
 10054 022a 02       		.byte	2
 10055 022b 00       		.byte	0
 10056 022c 00       		.byte	0
 10057 022d FF       		.byte	-1
 10058 022e 00       		.byte	0
 10059 022f 01       		.byte	1
 10060 0230 00       		.byte	0
 10061 0231 03       		.byte	3
 10062 0232 00       		.byte	0
 10063 0233 20       		.byte	32
 10064 0234 00       		.byte	0
 10065 0235 20       		.byte	32
 10066 0236 00       		.byte	0
 10067 0237 30       		.byte	48
 10068 0238 01       		.byte	1
 10069 0239 01       		.byte	1
 10070 023a 00       		.byte	0
 10071 023b 00000000 		.space	5
 10071      00
 10072 0240 00       		.byte	0
 10073 0241 00       		.byte	0
 10074 0242 02       		.byte	2
 10075 0243 00       		.byte	0
 10076 0244 00       		.byte	0
 10077 0245 64       		.byte	100
 10078 0246 00       		.byte	0
 10079 0247 01       		.byte	1
 10080 0248 00       		.byte	0
 10081 0249 03       		.byte	3
 10082 024a 00       		.byte	0
 10083 024b 00       		.byte	0
 10084 024c 00       		.byte	0
 10085 024d 00       		.byte	0
 10086 024e 00       		.byte	0
 10087 024f 30       		.byte	48
 10088 0250 01       		.byte	1
 10089 0251 00       		.byte	0
 10090 0252 00       		.byte	0
 10091 0253 00000000 		.space	5
 10091      00
 10092 0258 08       		.byte	8
 10093 0259 08       		.byte	8
 10094 025a 02       		.byte	2
 10095 025b 00       		.byte	0
 10096 025c 00       		.byte	0
 10097 025d 05       		.byte	5
 10098 025e 00       		.byte	0
 10099 025f 01       		.byte	1
 10100 0260 00       		.byte	0
 10101 0261 03       		.byte	3
 10102 0262 00       		.byte	0
 10103 0263 00       		.byte	0
 10104 0264 00       		.byte	0
 10105 0265 00       		.byte	0
 10106 0266 00       		.byte	0
 10107 0267 30       		.byte	48
 10108 0268 01       		.byte	1
 10109 0269 00       		.byte	0
 10110 026a 00       		.byte	0
 10111 026b 00000000 		.space	5
 10111      00
 10112 0270 00       		.byte	0
 10113 0271 00       		.byte	0
 10114 0272 02       		.byte	2
 10115 0273 00       		.byte	0
 10116 0274 00       		.byte	0
 10117 0275 40       		.byte	64
 10118 0276 00       		.byte	0
 10119 0277 01       		.byte	1
 10120 0278 00       		.byte	0
 10121 0279 03       		.byte	3
 10122 027a 00       		.byte	0
 10123 027b 00       		.byte	0
 10124 027c 00       		.byte	0
 10125 027d 00       		.byte	0
 10126 027e 00       		.byte	0
 10127 027f 30       		.byte	48
 10128 0280 01       		.byte	1
 10129 0281 00       		.byte	0
 10130 0282 00       		.byte	0
 10131 0283 00000000 		.space	5
 10131      00
 10132 0288 09       		.byte	9
 10133 0289 0A       		.byte	10
 10134 028a 04       		.byte	4
 10135 028b 00       		.byte	0
 10136 028c 00       		.byte	0
 10137 028d 40       		.byte	64
 10138 028e 00       		.byte	0
 10139 028f 01       		.byte	1
 10140 0290 00       		.byte	0
 10141 0291 03       		.byte	3
 10142 0292 00       		.byte	0
 10143 0293 20       		.byte	32
 10144 0294 38       		.byte	56
 10145 0295 20       		.byte	32
 10146 0296 38       		.byte	56
 10147 0297 30       		.byte	48
 10148 0298 01       		.byte	1
 10149 0299 00       		.byte	0
 10150 029a 00       		.byte	0
 10151 029b 00000000 		.space	5
 10151      00
 10152 02a0 00       		.byte	0
 10153 02a1 00       		.byte	0
 10154 02a2 02       		.byte	2
 10155 02a3 00       		.byte	0
 10156 02a4 00       		.byte	0
 10157 02a5 64       		.byte	100
 10158 02a6 00       		.byte	0
 10159 02a7 01       		.byte	1
 10160 02a8 00       		.byte	0
 10161 02a9 03       		.byte	3
 10162 02aa 00       		.byte	0
 10163 02ab 00       		.byte	0
 10164 02ac 00       		.byte	0
 10165 02ad 00       		.byte	0
 10166 02ae 00       		.byte	0
 10167 02af 30       		.byte	48
 10168 02b0 01       		.byte	1
 10169 02b1 00       		.byte	0
 10170 02b2 00       		.byte	0
 10171 02b3 00000000 		.space	5
 10171      00
 10172 02b8 00       		.byte	0
 10173 02b9 00       		.byte	0
 10174 02ba 02       		.byte	2
 10175 02bb 00       		.byte	0
 10176 02bc 00       		.byte	0
 10177 02bd 64       		.byte	100
 10178 02be 00       		.byte	0
 10179 02bf 01       		.byte	1
 10180 02c0 00       		.byte	0
 10181 02c1 03       		.byte	3
 10182 02c2 00       		.byte	0
 10183 02c3 00       		.byte	0
 10184 02c4 00       		.byte	0
 10185 02c5 00       		.byte	0
 10186 02c6 00       		.byte	0
 10187 02c7 30       		.byte	48
 10188 02c8 01       		.byte	1
 10189 02c9 00       		.byte	0
 10190 02ca 00       		.byte	0
 10191 02cb 00000000 		.space	5
 10191      00
 10192 02d0 2A       		.byte	42
 10193 02d1 2A       		.byte	42
 10194 02d2 02       		.byte	2
 10195 02d3 00       		.byte	0
 10196 02d4 00       		.byte	0
 10197 02d5 1B       		.byte	27
 10198 02d6 00       		.byte	0
 10199 02d7 01       		.byte	1
 10200 02d8 00       		.byte	0
 10201 02d9 03       		.byte	3
 10202 02da 00       		.byte	0
 10203 02db 00       		.byte	0
 10204 02dc 00       		.byte	0
 10205 02dd 00       		.byte	0
 10206 02de 00       		.byte	0
 10207 02df 30       		.byte	48
 10208 02e0 01       		.byte	1
 10209 02e1 00       		.byte	0
 10210 02e2 00       		.byte	0
 10211 02e3 00000000 		.space	5
 10211      00
 10212 02e8 00       		.byte	0
 10213 02e9 00       		.byte	0
 10214 02ea 02       		.byte	2
 10215 02eb 00       		.byte	0
 10216 02ec 00       		.byte	0
 10217 02ed 64       		.byte	100
 10218 02ee 00       		.byte	0
 10219 02ef 01       		.byte	1
 10220 02f0 00       		.byte	0
 10221 02f1 03       		.byte	3
 10222 02f2 00       		.byte	0
 10223 02f3 00       		.byte	0
 10224 02f4 00       		.byte	0
 10225 02f5 00       		.byte	0
 10226 02f6 00       		.byte	0
 10227 02f7 30       		.byte	48
 10228 02f8 01       		.byte	1
 10229 02f9 00       		.byte	0
 10230 02fa 00       		.byte	0
 10231 02fb 00000000 		.space	5
 10231      00
 10232 0300 00       		.byte	0
 10233 0301 00       		.byte	0
 10234 0302 02       		.byte	2
 10235 0303 00       		.byte	0
 10236 0304 00       		.byte	0
 10237 0305 12       		.byte	18
 10238 0306 00       		.byte	0
 10239 0307 01       		.byte	1
 10240 0308 00       		.byte	0
 10241 0309 03       		.byte	3
 10242 030a 00       		.byte	0
 10243 030b 00       		.byte	0
 10244 030c 00       		.byte	0
 10245 030d 00       		.byte	0
 10246 030e 00       		.byte	0
 10247 030f 30       		.byte	48
 10248 0310 01       		.byte	1
 10249 0311 00       		.byte	0
 10250 0312 00       		.byte	0
 10251 0313 00000000 		.space	5
 10251      00
 10252 0318 01       		.byte	1
 10253 0319 01       		.byte	1
 10254 031a 02       		.byte	2
 10255 031b 00       		.byte	0
 10256 031c 00       		.byte	0
 10257 031d 09       		.byte	9
 10258 031e 00       		.byte	0
 10259 031f 01       		.byte	1
 10260 0320 00       		.byte	0
 10261 0321 03       		.byte	3
 10262 0322 00       		.byte	0
 10263 0323 00       		.byte	0
 10264 0324 00       		.byte	0
 10265 0325 01       		.byte	1
 10266 0326 00       		.byte	0
 10267 0327 30       		.byte	48
 10268 0328 01       		.byte	1
 10269 0329 00       		.byte	0
 10270 032a 00       		.byte	0
 10271 032b 00000000 		.space	5
 10271      00
 10272 0330 05       		.byte	5
 10273 0331 05       		.byte	5
 10274 0332 02       		.byte	2
 10275 0333 00       		.byte	0
 10276 0334 00       		.byte	0
 10277 0335 03       		.byte	3
 10278 0336 00       		.byte	0
 10279 0337 01       		.byte	1
 10280 0338 00       		.byte	0
 10281 0339 03       		.byte	3
 10282 033a 00       		.byte	0
 10283 033b 00       		.byte	0
 10284 033c 00       		.byte	0
 10285 033d 00       		.byte	0
 10286 033e 00       		.byte	0
 10287 033f 30       		.byte	48
 10288 0340 01       		.byte	1
 10289 0341 00       		.byte	0
 10290 0342 00       		.byte	0
 10291 0343 00000000 		.space	5
 10291      00
 10292 0348 18       		.byte	24
 10293 0349 18       		.byte	24
 10294 034a 02       		.byte	2
 10295 034b 00       		.byte	0
 10296 034c 00       		.byte	0
 10297 034d 01       		.byte	1
 10298 034e 00       		.byte	0
 10299 034f 01       		.byte	1
 10300 0350 00       		.byte	0
 10301 0351 03       		.byte	3
 10302 0352 00       		.byte	0
 10303 0353 00       		.byte	0
 10304 0354 00       		.byte	0
 10305 0355 00       		.byte	0
 10306 0356 00       		.byte	0
 10307 0357 30       		.byte	48
 10308 0358 01       		.byte	1
 10309 0359 00       		.byte	0
 10310 035a 00       		.byte	0
 10311 035b 00000000 		.space	5
 10311      00
 10312 0360 19       		.byte	25
 10313 0361 19       		.byte	25
 10314 0362 01       		.byte	1
 10315 0363 00       		.byte	0
 10316 0364 00       		.byte	0
 10317 0365 40       		.byte	64
 10318 0366 00       		.byte	0
 10319 0367 01       		.byte	1
 10320 0368 00       		.byte	0
 10321 0369 03       		.byte	3
 10322 036a 00       		.byte	0
 10323 036b 20       		.byte	32
 10324 036c 00       		.byte	0
 10325 036d 20       		.byte	32
 10326 036e 00       		.byte	0
 10327 036f 30       		.byte	48
 10328 0370 01       		.byte	1
 10329 0371 00       		.byte	0
 10330 0372 00       		.byte	0
 10331 0373 00000000 		.space	5
 10331      00
 10332 0378 20       		.byte	32
 10333 0379 20       		.byte	32
 10334 037a 02       		.byte	2
 10335 037b 00       		.byte	0
 10336 037c 00       		.byte	0
 10337 037d 02       		.byte	2
 10338 037e 00       		.byte	0
 10339 037f 01       		.byte	1
 10340 0380 00       		.byte	0
 10341 0381 03       		.byte	3
 10342 0382 00       		.byte	0
 10343 0383 00       		.byte	0
 10344 0384 00       		.byte	0
 10345 0385 00       		.byte	0
 10346 0386 00       		.byte	0
 10347 0387 30       		.byte	48
 10348 0388 01       		.byte	1
 10349 0389 00       		.byte	0
 10350 038a 00       		.byte	0
 10351 038b 00000000 		.space	5
 10351      00
 10352 0390 22       		.byte	34
 10353 0391 22       		.byte	34
 10354 0392 02       		.byte	2
 10355 0393 00       		.byte	0
 10356 0394 00       		.byte	0
 10357 0395 3F       		.byte	63
 10358 0396 00       		.byte	0
 10359 0397 01       		.byte	1
 10360 0398 00       		.byte	0
 10361 0399 03       		.byte	3
 10362 039a 00       		.byte	0
 10363 039b 00       		.byte	0
 10364 039c 00       		.byte	0
 10365 039d 00       		.byte	0
 10366 039e 00       		.byte	0
 10367 039f 30       		.byte	48
 10368 03a0 01       		.byte	1
 10369 03a1 00       		.byte	0
 10370 03a2 00       		.byte	0
 10371 03a3 00000000 		.space	5
 10371      00
 10372 03a8 23       		.byte	35
 10373 03a9 23       		.byte	35
 10374 03aa 02       		.byte	2
 10375 03ab 00       		.byte	0
 10376 03ac 00       		.byte	0
 10377 03ad 64       		.byte	100
 10378 03ae 00       		.byte	0
 10379 03af 01       		.byte	1
 10380 03b0 00       		.byte	0
 10381 03b1 03       		.byte	3
 10382 03b2 00       		.byte	0
 10383 03b3 10       		.byte	16
 10384 03b4 00       		.byte	0
 10385 03b5 10       		.byte	16
 10386 03b6 00       		.byte	0
 10387 03b7 30       		.byte	48
 10388 03b8 01       		.byte	1
 10389 03b9 00       		.byte	0
 10390 03ba 00       		.byte	0
 10391 03bb 00000000 		.space	5
 10391      00
 10392 03c0 24       		.byte	36
 10393 03c1 24       		.byte	36
 10394 03c2 02       		.byte	2
 10395 03c3 00       		.byte	0
 10396 03c4 00       		.byte	0
 10397 03c5 64       		.byte	100
 10398 03c6 00       		.byte	0
 10399 03c7 01       		.byte	1
 10400 03c8 00       		.byte	0
 10401 03c9 03       		.byte	3
 10402 03ca 00       		.byte	0
 10403 03cb 10       		.byte	16
 10404 03cc 00       		.byte	0
 10405 03cd 10       		.byte	16
 10406 03ce 00       		.byte	0
 10407 03cf 30       		.byte	48
 10408 03d0 01       		.byte	1
 10409 03d1 00       		.byte	0
 10410 03d2 00       		.byte	0
 10411 03d3 00000000 		.space	5
 10411      00
 10412 03d8 02       		.byte	2
 10413 03d9 03       		.byte	3
 10414 03da 04       		.byte	4
 10415 03db 00       		.byte	0
 10416 03dc 00       		.byte	0
 10417 03dd 7F       		.byte	127
 10418 03de 00       		.byte	0
 10419 03df 01       		.byte	1
 10420 03e0 00       		.byte	0
 10421 03e1 03       		.byte	3
 10422 03e2 00       		.byte	0
 10423 03e3 00       		.byte	0
 10424 03e4 20       		.byte	32
 10425 03e5 00       		.byte	0
 10426 03e6 20       		.byte	32
 10427 03e7 30       		.byte	48
 10428 03e8 01       		.byte	1
 10429 03e9 00       		.byte	0
 10430 03ea 00       		.byte	0
 10431 03eb 00000000 		.space	5
 10431      00
 10432 03f0 04       		.byte	4
 10433 03f1 04       		.byte	4
 10434 03f2 02       		.byte	2
 10435 03f3 00       		.byte	0
 10436 03f4 00       		.byte	0
 10437 03f5 FF       		.byte	-1
 10438 03f6 00       		.byte	0
 10439 03f7 01       		.byte	1
 10440 03f8 00       		.byte	0
 10441 03f9 03       		.byte	3
 10442 03fa 00       		.byte	0
 10443 03fb 60       		.byte	96
 10444 03fc 00       		.byte	0
 10445 03fd 60       		.byte	96
 10446 03fe 00       		.byte	0
 10447 03ff 30       		.byte	48
 10448 0400 01       		.byte	1
 10449 0401 00       		.byte	0
 10450 0402 00       		.byte	0
 10451 0403 00000000 		.space	5
 10451      00
 10452 0408 00       		.byte	0
 10453 0409 00       		.byte	0
 10454 040a 02       		.byte	2
 10455 040b 00       		.byte	0
 10456 040c 00       		.byte	0
 10457 040d 19       		.byte	25
 10458 040e 00       		.byte	0
 10459 040f 01       		.byte	1
 10460 0410 00       		.byte	0
 10461 0411 03       		.byte	3
 10462 0412 00       		.byte	0
 10463 0413 00       		.byte	0
 10464 0414 00       		.byte	0
 10465 0415 00       		.byte	0
 10466 0416 00       		.byte	0
 10467 0417 30       		.byte	48
 10468 0418 01       		.byte	1
 10469 0419 00       		.byte	0
 10470 041a 00       		.byte	0
 10471 041b 00000000 		.space	5
 10471      00
 10472 0420 10       		.byte	16
 10473 0421 10       		.byte	16
 10474 0422 02       		.byte	2
 10475 0423 00       		.byte	0
 10476 0424 00       		.byte	0
 10477 0425 06       		.byte	6
 10478 0426 00       		.byte	0
 10479 0427 01       		.byte	1
 10480 0428 00       		.byte	0
 10481 0429 03       		.byte	3
 10482 042a 00       		.byte	0
 10483 042b 03       		.byte	3
 10484 042c 00       		.byte	0
 10485 042d 03       		.byte	3
 10486 042e 00       		.byte	0
 10487 042f 30       		.byte	48
 10488 0430 01       		.byte	1
 10489 0431 00       		.byte	0
 10490 0432 00       		.byte	0
 10491 0433 00000000 		.space	5
 10491      00
 10492 0438 00       		.byte	0
 10493 0439 00       		.byte	0
 10494 043a 02       		.byte	2
 10495 043b 00       		.byte	0
 10496 043c 00       		.byte	0
 10497 043d 03       		.byte	3
 10498 043e 00       		.byte	0
 10499 043f 01       		.byte	1
 10500 0440 00       		.byte	0
 10501 0441 03       		.byte	3
 10502 0442 00       		.byte	0
 10503 0443 00       		.byte	0
 10504 0444 00       		.byte	0
 10505 0445 00       		.byte	0
 10506 0446 00       		.byte	0
 10507 0447 30       		.byte	48
 10508 0448 01       		.byte	1
 10509 0449 00       		.byte	0
 10510 044a 00       		.byte	0
 10511 044b 00000000 		.space	5
 10511      00
 10512 0450 50       		.byte	80
 10513 0451 50       		.byte	80
 10514 0452 01       		.byte	1
 10515 0453 00       		.byte	0
 10516 0454 00       		.byte	0
 10517 0455 03       		.byte	3
 10518 0456 00       		.byte	0
 10519 0457 01       		.byte	1
 10520 0458 00       		.byte	0
 10521 0459 03       		.byte	3
 10522 045a 00       		.byte	0
 10523 045b 00       		.byte	0
 10524 045c 00       		.byte	0
 10525 045d 00       		.byte	0
 10526 045e 00       		.byte	0
 10527 045f 30       		.byte	48
 10528 0460 01       		.byte	1
 10529 0461 00       		.byte	0
 10530 0462 00       		.byte	0
 10531 0463 00000000 		.space	5
 10531      00
 10532 0468 00       		.byte	0
 10533 0469 00       		.byte	0
 10534 046a 0B       		.byte	11
 10535 046b 00       		.byte	0
 10536 046c 00       		.byte	0
 10537 046d FF       		.byte	-1
 10538 046e FF       		.byte	-1
 10539 046f 01       		.byte	1
 10540 0470 00       		.byte	0
 10541 0471 03       		.byte	3
 10542 0472 00       		.byte	0
 10543 0473 00       		.byte	0
 10544 0474 00       		.byte	0
 10545 0475 00       		.byte	0
 10546 0476 00       		.byte	0
 10547 0477 00       		.byte	0
 10548 0478 01       		.byte	1
 10549 0479 00       		.byte	0
 10550 047a 00       		.byte	0
 10551 047b 00000000 		.space	5
 10551      00
 10554              	glUVCHeader:
 10555 0480 0C       		.byte	12
 10556 0481 8C       		.byte	-116
 10557 0482 00       		.byte	0
 10558 0483 00       		.byte	0
 10559 0484 00       		.byte	0
 10560 0485 00       		.byte	0
 10561 0486 00       		.byte	0
 10562 0487 00       		.byte	0
 10563 0488 00       		.byte	0
 10564 0489 00       		.byte	0
 10565 048a 00       		.byte	0
 10566 048b 00       		.byte	0
 10569              	ROIMode:
 10570 048c 01       		.byte	1
 10571 048d 000000   		.space	3
 10574              	EXTBLCWinPos:
 10575 0490 14       		.byte	20
 10576 0491 13       		.byte	19
 10577 0492 02       		.byte	2
 10578 0493 00       		.byte	0
 10579 0494 00       		.byte	0
 10580 0495 FF       		.byte	-1
 10581 0496 FF       		.byte	-1
 10582 0497 01       		.byte	1
 10583 0498 00       		.byte	0
 10584 0499 03       		.byte	3
 10585 049a 00       		.byte	0
 10586 049b 66       		.byte	102
 10587 049c 66       		.byte	102
 10588 049d 66       		.byte	102
 10589 049e 66       		.byte	102
 10590 049f 30       		.byte	48
 10591 04a0 01       		.byte	1
 10592 04a1 00       		.byte	0
 10593 04a2 0000     		.space	2
 10596              	EXTBLCWeight:
 10597 04a4 11       		.byte	17
 10598 04a5 11       		.byte	17
 10599 04a6 02       		.byte	2
 10600 04a7 00       		.byte	0
 10601 04a8 00       		.byte	0
 10602 04a9 FF       		.byte	-1
 10603 04aa 00       		.byte	0
 10604 04ab 01       		.byte	1
 10605 04ac 00       		.byte	0
 10606 04ad 03       		.byte	3
 10607 04ae 00       		.byte	0
 10608 04af 80       		.byte	-128
 10609 04b0 00       		.byte	0
 10610 04b1 80       		.byte	-128
 10611 04b2 00       		.byte	0
 10612 04b3 30       		.byte	48
 10613 04b4 01       		.byte	1
 10614 04b5 00       		.byte	0
 10615 04b6 0000     		.space	2
 10618              	EXTShutter:
 10619 04b8 00       		.byte	0
 10620 04b9 02       		.byte	2
 10621 04ba 02       		.byte	2
 10622 04bb 00       		.byte	0
 10623 04bc 00       		.byte	0
 10624 04bd 08       		.byte	8
 10625 04be 00       		.byte	0
 10626 04bf 01       		.byte	1
 10627 04c0 00       		.byte	0
 10628 04c1 03       		.byte	3
 10629 04c2 00       		.byte	0
 10630 04c3 00       		.byte	0
 10631 04c4 00       		.byte	0
 10632 04c5 00       		.byte	0
 10633 04c6 00       		.byte	0
 10634 04c7 30       		.byte	48
 10635 04c8 01       		.byte	1
 10636 04c9 00       		.byte	0
 10637 04ca 0000     		.space	2
 10640              	EXTShutlev:
 10641 04cc 02       		.byte	2
 10642 04cd 12       		.byte	18
 10643 04ce 02       		.byte	2
 10644 04cf 00       		.byte	0
 10645 04d0 00       		.byte	0
 10646 04d1 FF       		.byte	-1
 10647 04d2 7F       		.byte	127
 10648 04d3 01       		.byte	1
 10649 04d4 00       		.byte	0
 10650 04d5 03       		.byte	3
 10651 04d6 00       		.byte	0
 10652 04d7 3F       		.byte	63
 10653 04d8 00       		.byte	0
 10654 04d9 3F       		.byte	63
 10655 04da 00       		.byte	0
 10656 04db 30       		.byte	48
 10657 04dc 01       		.byte	1
 10658 04dd 00       		.byte	0
 10659 04de 0000     		.space	2
 10662              	EXTAexModGainlev:
 10663 04e0 00       		.byte	0
 10664 04e1 03       		.byte	3
 10665 04e2 04       		.byte	4
 10666 04e3 00       		.byte	0
 10667 04e4 00       		.byte	0
 10668 04e5 03       		.byte	3
 10669 04e6 7F       		.byte	127
 10670 04e7 01       		.byte	1
 10671 04e8 00       		.byte	0
 10672 04e9 03       		.byte	3
 10673 04ea 00       		.byte	0
 10674 04eb 00       		.byte	0
 10675 04ec 3F       		.byte	63
 10676 04ed 00       		.byte	0
 10677 04ee 3F       		.byte	63
 10678 04ef 30       		.byte	48
 10679 04f0 01       		.byte	1
 10680 04f1 00       		.byte	0
 10681 04f2 0000     		.space	2
 10684              	WBMenuCmpArry:
 10685 04f4 20       		.byte	32
 10686 04f5 0F       		.byte	15
 10687 04f6 38       		.byte	56
 10688 04f7 F0       		.byte	-16
 10691              	PUCBLC:
 10692 04f8 10       		.byte	16
 10693 04f9 11       		.byte	17
 10694 04fa 02       		.byte	2
 10695 04fb 00       		.byte	0
 10696 04fc 00       		.byte	0
 10697 04fd 03       		.byte	3
 10698 04fe 00       		.byte	0
 10699 04ff 01       		.byte	1
 10700 0500 00       		.byte	0
 10701 0501 03       		.byte	3
 10702 0502 00       		.byte	0
 10703 0503 03       		.byte	3
 10704 0504 00       		.byte	0
 10705 0505 03       		.byte	3
 10706 0506 00       		.byte	0
 10707 0507 30       		.byte	48
 10708 0508 01       		.byte	1
 10709 0509 00       		.byte	0
 10710 050a 0000     		.space	2
 10713              	PUCSharp:
 10714 050c 06       		.byte	6
 10715 050d 07       		.byte	7
 10716 050e 02       		.byte	2
 10717 050f 00       		.byte	0
 10718 0510 00       		.byte	0
 10719 0511 08       		.byte	8
 10720 0512 00       		.byte	0
 10721 0513 01       		.byte	1
 10722 0514 00       		.byte	0
 10723 0515 03       		.byte	3
 10724 0516 00       		.byte	0
 10725 0517 00       		.byte	0
 10726 0518 00       		.byte	0
 10727 0519 00       		.byte	0
 10728 051a 00       		.byte	0
 10729 051b 30       		.byte	48
 10730 051c 01       		.byte	1
 10731 051d 00       		.byte	0
 10732 051e 0000     		.space	2
 10735              	CTCtrlParArry:
 10736 0520 00       		.byte	0
 10737 0521 00       		.byte	0
 10738 0522 01       		.byte	1
 10739 0523 00       		.byte	0
 10740 0524 00       		.byte	0
 10741 0525 03       		.byte	3
 10742 0526 00       		.byte	0
 10743 0527 01       		.byte	1
 10744 0528 00       		.byte	0
 10745 0529 03       		.byte	3
 10746 052a 00       		.byte	0
 10747 052b 03       		.byte	3
 10748 052c 00       		.byte	0
 10749 052d 03       		.byte	3
 10750 052e 00       		.byte	0
 10751 052f 30       		.byte	48
 10752 0530 01       		.byte	1
 10753 0531 00       		.byte	0
 10754 0532 00       		.byte	0
 10755 0533 00000000 		.space	5
 10755      00
 10756 0538 00       		.byte	0
 10757 0539 00       		.byte	0
 10758 053a 01       		.byte	1
 10759 053b 01       		.byte	1
 10760 053c 00       		.byte	0
 10761 053d 0F       		.byte	15
 10762 053e 00       		.byte	0
 10763 053f 0F       		.byte	15
 10764 0540 00       		.byte	0
 10765 0541 03       		.byte	3
 10766 0542 00       		.byte	0
 10767 0543 02       		.byte	2
 10768 0544 00       		.byte	0
 10769 0545 02       		.byte	2
 10770 0546 00       		.byte	0
 10771 0547 30       		.byte	48
 10772 0548 01       		.byte	1
 10773 0549 01       		.byte	1
 10774 054a 00       		.byte	0
 10775 054b 00000000 		.space	5
 10775      00
 10776 0550 02       		.byte	2
 10777 0551 00       		.byte	0
 10778 0552 01       		.byte	1
 10779 0553 00       		.byte	0
 10780 0554 00       		.byte	0
 10781 0555 01       		.byte	1
 10782 0556 00       		.byte	0
 10783 0557 01       		.byte	1
 10784 0558 00       		.byte	0
 10785 0559 03       		.byte	3
 10786 055a 00       		.byte	0
 10787 055b 00       		.byte	0
 10788 055c 00       		.byte	0
 10789 055d 00       		.byte	0
 10790 055e 00       		.byte	0
 10791 055f 30       		.byte	48
 10792 0560 01       		.byte	1
 10793 0561 01       		.byte	1
 10794 0562 00       		.byte	0
 10795 0563 00000000 		.space	5
 10795      00
 10796 0568 00       		.byte	0
 10797 0569 00       		.byte	0
 10798 056a 04       		.byte	4
 10799 056b 01       		.byte	1
 10800 056c 00       		.byte	0
 10801 056d 38       		.byte	56
 10802 056e 01       		.byte	1
 10803 056f 01       		.byte	1
 10804 0570 00       		.byte	0
 10805 0571 03       		.byte	3
 10806 0572 00       		.byte	0
 10807 0573 4E       		.byte	78
 10808 0574 00       		.byte	0
 10809 0575 4E       		.byte	78
 10810 0576 00       		.byte	0
 10811 0577 30       		.byte	48
 10812 0578 01       		.byte	1
 10813 0579 00       		.byte	0
 10814 057a 00       		.byte	0
 10815 057b 00000000 		.space	5
 10815      00
 10816 0580 04       		.byte	4
 10817 0581 00       		.byte	0
 10818 0582 01       		.byte	1
 10819 0583 00       		.byte	0
 10820 0584 00       		.byte	0
 10821 0585 00       		.byte	0
 10822 0586 00       		.byte	0
 10823 0587 01       		.byte	1
 10824 0588 00       		.byte	0
 10825 0589 03       		.byte	3
 10826 058a 00       		.byte	0
 10827 058b 00       		.byte	0
 10828 058c 00       		.byte	0
 10829 058d 00       		.byte	0
 10830 058e 00       		.byte	0
 10831 058f 30       		.byte	48
 10832 0590 01       		.byte	1
 10833 0591 00       		.byte	0
 10834 0592 00       		.byte	0
 10835 0593 00000000 		.space	5
 10835      00
 10836 0598 05       		.byte	5
 10837 0599 00       		.byte	0
 10838 059a 02       		.byte	2
 10839 059b 00       		.byte	0
 10840 059c 00       		.byte	0
 10841 059d FF       		.byte	-1
 10842 059e 00       		.byte	0
 10843 059f 01       		.byte	1
 10844 05a0 00       		.byte	0
 10845 05a1 03       		.byte	3
 10846 05a2 00       		.byte	0
 10847 05a3 01       		.byte	1
 10848 05a4 00       		.byte	0
 10849 05a5 00       		.byte	0
 10850 05a6 00       		.byte	0
 10851 05a7 30       		.byte	48
 10852 05a8 01       		.byte	1
 10853 05a9 01       		.byte	1
 10854 05aa 00       		.byte	0
 10855 05ab 00000000 		.space	5
 10855      00
 10856 05b0 06       		.byte	6
 10857 05b1 00       		.byte	0
 10858 05b2 02       		.byte	2
 10859 05b3 00       		.byte	0
 10860 05b4 00       		.byte	0
 10861 05b5 00       		.byte	0
 10862 05b6 00       		.byte	0
 10863 05b7 00       		.byte	0
 10864 05b8 00       		.byte	0
 10865 05b9 03       		.byte	3
 10866 05ba 00       		.byte	0
 10867 05bb 00       		.byte	0
 10868 05bc 00       		.byte	0
 10869 05bd 00       		.byte	0
 10870 05be 00       		.byte	0
 10871 05bf 30       		.byte	48
 10872 05c0 01       		.byte	1
 10873 05c1 01       		.byte	1
 10874 05c2 00       		.byte	0
 10875 05c3 00000000 		.space	5
 10875      00
 10876 05c8 23       		.byte	35
 10877 05c9 00       		.byte	0
 10878 05ca 02       		.byte	2
 10879 05cb 00       		.byte	0
 10880 05cc 00       		.byte	0
 10881 05cd 30       		.byte	48
 10882 05ce 00       		.byte	0
 10883 05cf 01       		.byte	1
 10884 05d0 00       		.byte	0
 10885 05d1 03       		.byte	3
 10886 05d2 0A       		.byte	10
 10887 05d3 00       		.byte	0
 10888 05d4 00       		.byte	0
 10889 05d5 0A       		.byte	10
 10890 05d6 00       		.byte	0
 10891 05d7 30       		.byte	48
 10892 05d8 01       		.byte	1
 10893 05d9 01       		.byte	1
 10894 05da 00       		.byte	0
 10895 05db 00000000 		.space	5
 10895      00
 10896 05e0 08       		.byte	8
 10897 05e1 00       		.byte	0
 10898 05e2 01       		.byte	1
 10899 05e3 00       		.byte	0
 10900 05e4 00       		.byte	0
 10901 05e5 7F       		.byte	127
 10902 05e6 00       		.byte	0
 10903 05e7 01       		.byte	1
 10904 05e8 00       		.byte	0
 10905 05e9 03       		.byte	3
 10906 05ea 00       		.byte	0
 10907 05eb 00       		.byte	0
 10908 05ec 00       		.byte	0
 10909 05ed 00       		.byte	0
 10910 05ee 00       		.byte	0
 10911 05ef 30       		.byte	48
 10912 05f0 01       		.byte	1
 10913 05f1 00       		.byte	0
 10914 05f2 00       		.byte	0
 10915 05f3 00000000 		.space	5
 10915      00
 10916 05f8 09       		.byte	9
 10917 05f9 00       		.byte	0
 10918 05fa 02       		.byte	2
 10919 05fb 00       		.byte	0
 10920 05fc 00       		.byte	0
 10921 05fd 05       		.byte	5
 10922 05fe 00       		.byte	0
 10923 05ff 01       		.byte	1
 10924 0600 00       		.byte	0
 10925 0601 03       		.byte	3
 10926 0602 00       		.byte	0
 10927 0603 00       		.byte	0
 10928 0604 00       		.byte	0
 10929 0605 00       		.byte	0
 10930 0606 00       		.byte	0
 10931 0607 30       		.byte	48
 10932 0608 01       		.byte	1
 10933 0609 00       		.byte	0
 10934 060a 00       		.byte	0
 10935 060b 00000000 		.space	5
 10935      00
 10936 0610 10       		.byte	16
 10937 0611 00       		.byte	0
 10938 0612 03       		.byte	3
 10939 0613 00       		.byte	0
 10940 0614 00       		.byte	0
 10941 0615 00       		.byte	0
 10942 0616 00       		.byte	0
 10943 0617 00       		.byte	0
 10944 0618 00       		.byte	0
 10945 0619 03       		.byte	3
 10946 061a 00       		.byte	0
 10947 061b 00       		.byte	0
 10948 061c 00       		.byte	0
 10949 061d 00       		.byte	0
 10950 061e 00       		.byte	0
 10951 061f 30       		.byte	48
 10952 0620 01       		.byte	1
 10953 0621 00       		.byte	0
 10954 0622 00       		.byte	0
 10955 0623 00000000 		.space	5
 10955      00
 10956 0628 00       		.byte	0
 10957 0629 00       		.byte	0
 10958 062a 02       		.byte	2
 10959 062b 00       		.byte	0
 10960 062c 00       		.byte	0
 10961 062d 40       		.byte	64
 10962 062e 00       		.byte	0
 10963 062f 01       		.byte	1
 10964 0630 00       		.byte	0
 10965 0631 03       		.byte	3
 10966 0632 00       		.byte	0
 10967 0633 0F       		.byte	15
 10968 0634 11       		.byte	17
 10969 0635 00       		.byte	0
 10970 0636 00       		.byte	0
 10971 0637 30       		.byte	48
 10972 0638 01       		.byte	1
 10973 0639 00       		.byte	0
 10974 063a 00       		.byte	0
 10975 063b 00000000 		.space	5
 10975      00
 10976 0640 00       		.byte	0
 10977 0641 00       		.byte	0
 10978 0642 02       		.byte	2
 10979 0643 00       		.byte	0
 10980 0644 00       		.byte	0
 10981 0645 64       		.byte	100
 10982 0646 00       		.byte	0
 10983 0647 01       		.byte	1
 10984 0648 00       		.byte	0
 10985 0649 03       		.byte	3
 10986 064a 00       		.byte	0
 10987 064b 00       		.byte	0
 10988 064c 00       		.byte	0
 10989 064d 00       		.byte	0
 10990 064e 00       		.byte	0
 10991 064f 30       		.byte	48
 10992 0650 01       		.byte	1
 10993 0651 00       		.byte	0
 10994 0652 00       		.byte	0
 10995 0653 00000000 		.space	5
 10995      00
 10996 0658 00       		.byte	0
 10997 0659 00       		.byte	0
 10998 065a 02       		.byte	2
 10999 065b 00       		.byte	0
 11000 065c 00       		.byte	0
 11001 065d 64       		.byte	100
 11002 065e 00       		.byte	0
 11003 065f 01       		.byte	1
 11004 0660 00       		.byte	0
 11005 0661 03       		.byte	3
 11006 0662 00       		.byte	0
 11007 0663 00       		.byte	0
 11008 0664 00       		.byte	0
 11009 0665 00       		.byte	0
 11010 0666 00       		.byte	0
 11011 0667 30       		.byte	48
 11012 0668 01       		.byte	1
 11013 0669 00       		.byte	0
 11014 066a 00       		.byte	0
 11015 066b 00000000 		.space	5
 11015      00
 11016 0670 00       		.byte	0
 11017 0671 00       		.byte	0
 11018 0672 02       		.byte	2
 11019 0673 00       		.byte	0
 11020 0674 00       		.byte	0
 11021 0675 64       		.byte	100
 11022 0676 00       		.byte	0
 11023 0677 01       		.byte	1
 11024 0678 00       		.byte	0
 11025 0679 03       		.byte	3
 11026 067a 00       		.byte	0
 11027 067b 00       		.byte	0
 11028 067c 00       		.byte	0
 11029 067d 00       		.byte	0
 11030 067e 00       		.byte	0
 11031 067f 30       		.byte	48
 11032 0680 01       		.byte	1
 11033 0681 00       		.byte	0
 11034 0682 00       		.byte	0
 11035 0683 00000000 		.space	5
 11035      00
 11036 0688 00       		.byte	0
 11037 0689 00       		.byte	0
 11038 068a 02       		.byte	2
 11039 068b 00       		.byte	0
 11040 068c 00       		.byte	0
 11041 068d 64       		.byte	100
 11042 068e 00       		.byte	0
 11043 068f 01       		.byte	1
 11044 0690 00       		.byte	0
 11045 0691 03       		.byte	3
 11046 0692 00       		.byte	0
 11047 0693 00       		.byte	0
 11048 0694 00       		.byte	0
 11049 0695 00       		.byte	0
 11050 0696 00       		.byte	0
 11051 0697 30       		.byte	48
 11052 0698 01       		.byte	1
 11053 0699 00       		.byte	0
 11054 069a 00       		.byte	0
 11055 069b 00000000 		.space	5
 11055      00
 11058              	glProbeCtrlFull:
 11059 06a0 00       		.byte	0
 11060 06a1 00       		.byte	0
 11061 06a2 01       		.byte	1
 11062 06a3 01       		.byte	1
 11063 06a4 15       		.byte	21
 11064 06a5 16       		.byte	22
 11065 06a6 05       		.byte	5
 11066 06a7 00       		.byte	0
 11067 06a8 00       		.byte	0
 11068 06a9 00       		.byte	0
 11069 06aa 00       		.byte	0
 11070 06ab 00       		.byte	0
 11071 06ac 00       		.byte	0
 11072 06ad 00       		.byte	0
 11073 06ae 00       		.byte	0
 11074 06af 00       		.byte	0
 11075 06b0 00       		.byte	0
 11076 06b1 00       		.byte	0
 11077 06b2 00       		.byte	0
 11078 06b3 C6       		.byte	-58
 11079 06b4 99       		.byte	-103
 11080 06b5 00       		.byte	0
 11081 06b6 00       		.byte	0
 11082 06b7 40       		.byte	64
 11083 06b8 00       		.byte	0
 11084 06b9 00       		.byte	0
 11085 06ba 0000     		.space	2
 11088              	glProbeCtrl20:
 11089 06bc 00       		.byte	0
 11090 06bd 00       		.byte	0
 11091 06be 01       		.byte	1
 11092 06bf 01       		.byte	1
 11093 06c0 80       		.byte	-128
 11094 06c1 1A       		.byte	26
 11095 06c2 06       		.byte	6
 11096 06c3 00       		.byte	0
 11097 06c4 00       		.byte	0
 11098 06c5 00       		.byte	0
 11099 06c6 00       		.byte	0
 11100 06c7 00       		.byte	0
 11101 06c8 00       		.byte	0
 11102 06c9 00       		.byte	0
 11103 06ca 00       		.byte	0
 11104 06cb 00       		.byte	0
 11105 06cc 00       		.byte	0
 11106 06cd 00       		.byte	0
 11107 06ce 00       		.byte	0
 11108 06cf D2       		.byte	-46
 11109 06d0 0F       		.byte	15
 11110 06d1 00       		.byte	0
 11111 06d2 00       		.byte	0
 11112 06d3 40       		.byte	64
 11113 06d4 00       		.byte	0
 11114 06d5 00       		.byte	0
 11115 06d6 0000     		.space	2
 11118              	glProbeCtrl:
 11119 06d8 00       		.byte	0
 11120 06d9 00       		.byte	0
 11121 06da 01       		.byte	1
 11122 06db 01       		.byte	1
 11123 06dc 15       		.byte	21
 11124 06dd 16       		.byte	22
 11125 06de 05       		.byte	5
 11126 06df 00       		.byte	0
 11127 06e0 00       		.byte	0
 11128 06e1 00       		.byte	0
 11129 06e2 00       		.byte	0
 11130 06e3 00       		.byte	0
 11131 06e4 00       		.byte	0
 11132 06e5 00       		.byte	0
 11133 06e6 00       		.byte	0
 11134 06e7 00       		.byte	0
 11135 06e8 00       		.byte	0
 11136 06e9 00       		.byte	0
 11137 06ea 00       		.byte	0
 11138 06eb 48       		.byte	72
 11139 06ec 3F       		.byte	63
 11140 06ed 00       		.byte	0
 11141 06ee 00       		.byte	0
 11142 06ef 40       		.byte	64
 11143 06f0 00       		.byte	0
 11144 06f1 00       		.byte	0
 11145 06f2 0000     		.space	2
 11148              	glProbeStilCtrl:
 11149 06f4 01       		.byte	1
 11150 06f5 02       		.byte	2
 11151 06f6 00       		.byte	0
 11152 06f7 00       		.byte	0
 11153 06f8 C6       		.byte	-58
 11154 06f9 99       		.byte	-103
 11155 06fa 00       		.byte	0
 11156 06fb 00       		.byte	0
 11157 06fc 40       		.byte	64
 11158 06fd 00       		.byte	0
 11159 06fe 00       		.byte	0
 11160 06ff 00       		.space	1
 11163              	glProbeStilCtrl20:
 11164 0700 01       		.byte	1
 11165 0701 01       		.byte	1
 11166 0702 00       		.byte	0
 11167 0703 00       		.byte	0
 11168 0704 D2       		.byte	-46
 11169 0705 0F       		.byte	15
 11170 0706 00       		.byte	0
 11171 0707 00       		.byte	0
 11172 0708 40       		.byte	64
 11173 0709 00       		.byte	0
 11174 070a 00       		.byte	0
 11177              	snapButFlag:
 11178 070b 01       		.byte	1
 11181              	CyFxGpifTransition:
 11182 070c 0000     		.short	0
 11183 070e 5555     		.short	21845
 11184 0710 8888     		.short	-30584
 11185 0712 AAAA     		.short	-21846
 11186 0714 3333     		.short	13107
 11187 0716 0000     		.space	2
 11190              	CyFxGpifWavedata:
 11191 0718 0181731E 		.word	510886145
 11192 071c 00000000 		.word	0
 11193 0720 00000080 		.word	-2147483648
 11194 0724 00000000 		.word	0
 11195 0728 00000000 		.word	0
 11196 072c 00000000 		.word	0
 11197 0730 0201702E 		.word	779092226
 11198 0734 00010000 		.word	256
 11199 0738 A0000080 		.word	-2147483488
 11200 073c 00000000 		.word	0
 11201 0740 00000000 		.word	0
 11202 0744 00000000 		.word	0
 11203 0748 0380722E 		.word	779255811
 11204 074c 02010020 		.word	536871170
 11205 0750 60000080 		.word	-2147483552
 11206 0754 00000000 		.word	0
 11207 0758 00000000 		.word	0
 11208 075c 00000000 		.word	0
 11209 0760 0460722E 		.word	779247620
 11210 0764 02010024 		.word	603980034
 11211 0768 90000080 		.word	-2147483504
 11212 076c 0594731E 		.word	510891013
 11213 0770 06000000 		.word	6
 11214 0774 00000080 		.word	-2147483648
 11215 0778 0380722E 		.word	779255811
 11216 077c 02010020 		.word	536871170
 11217 0780 60000080 		.word	-2147483552
 11218 0784 0693731E 		.word	510890758
 11219 0788 06000000 		.word	6
 11220 078c 00000080 		.word	-2147483648
 11221 0790 0720703E 		.word	1047535623
 11222 0794 08010000 		.word	264
 11223 0798 00000080 		.word	-2147483648
 11224 079c 0820703E 		.word	1047535624
 11225 07a0 08010000 		.word	264
 11226 07a4 00000080 		.word	-2147483648
 11227 07a8 0920703E 		.word	1047535625
 11228 07ac 08010000 		.word	264
 11229 07b0 00000080 		.word	-2147483648
 11230 07b4 0A20703E 		.word	1047535626
 11231 07b8 08010000 		.word	264
 11232 07bc 00000080 		.word	-2147483648
 11233 07c0 0380722E 		.word	779255811
 11234 07c4 02010020 		.word	536871170
 11235 07c8 60000080 		.word	-2147483552
 11236 07cc 0B000000 		.word	11
 11237 07d0 00000000 		.word	0
 11238 07d4 00010080 		.word	-2147483392
 11239 07d8 0460722E 		.word	779247620
 11240 07dc 02010024 		.word	603980034
 11241 07e0 90000080 		.word	-2147483504
 11242 07e4 0D000000 		.word	13
 11243 07e8 00000000 		.word	0
 11244 07ec 00010080 		.word	-2147483392
 11245 07f0 0460722E 		.word	779247620
 11246 07f4 02010024 		.word	603980034
 11247 07f8 90000080 		.word	-2147483504
 11248 07fc 0C000000 		.word	12
 11249 0800 00000000 		.word	0
 11250 0804 00010080 		.word	-2147483392
 11251 0808 0380722E 		.word	779255811
 11252 080c 02010020 		.word	536871170
 11253 0810 60000080 		.word	-2147483552
 11254 0814 0E000000 		.word	14
 11255 0818 00000000 		.word	0
 11256 081c 00010080 		.word	-2147483392
 11257 0820 00000000 		.word	0
 11258 0824 00000000 		.word	0
 11259 0828 00000000 		.word	0
 11260 082c 00000000 		.word	0
 11261 0830 00000000 		.word	0
 11262 0834 00000000 		.word	0
 11265              	CyFxGpifWavedataPosition:
 11266 0838 00       		.byte	0
 11267 0839 01       		.byte	1
 11268 083a 02       		.byte	2
 11269 083b 03       		.byte	3
 11270 083c 04       		.byte	4
 11271 083d 05       		.byte	5
 11272 083e 06       		.byte	6
 11273 083f 07       		.byte	7
 11274 0840 08       		.byte	8
 11275 0841 09       		.byte	9
 11276 0842 0A       		.byte	10
 11277 0843 0B       		.byte	11
 11278 0844 0B       		.byte	11
 11279 0845 0B       		.byte	11
 11280 0846 0B       		.byte	11
 11281 0847 00       		.space	1
 11284              	CyFxGpifRegValue:
 11285 0848 08830080 		.word	-2147450104
 11286 084c 67000000 		.word	103
 11287 0850 00000000 		.word	0
 11288 0854 46000000 		.word	70
 11289 0858 00000000 		.word	0
 11290 085c 00000000 		.word	0
 11291 0860 02000000 		.word	2
 11292 0864 82000000 		.word	130
 11293 0868 82070000 		.word	1922
 11294 086c 40040000 		.word	1088
 11295 0870 FCFF0000 		.word	65532
 11296 0874 28000000 		.word	40
 11297 0878 00000000 		.word	0
 11298 087c 00000000 		.word	0
 11299 0880 00000000 		.word	0
 11300 0884 00000000 		.word	0
 11301 0888 01000000 		.word	1
 11302 088c 00000000 		.word	0
 11303 0890 00000000 		.word	0
 11304 0894 00000000 		.word	0
 11305 0898 00000000 		.word	0
 11306 089c 00000000 		.word	0
 11307 08a0 00000000 		.word	0
 11308 08a4 00000000 		.word	0
 11309 08a8 00000000 		.word	0
 11310 08ac 00000000 		.word	0
 11311 08b0 00000000 		.word	0
 11312 08b4 00000000 		.word	0
 11313 08b8 00000000 		.word	0
 11314 08bc 06000000 		.word	6
 11315 08c0 00000000 		.word	0
 11316 08c4 FFFF0000 		.word	65535
 11317 08c8 09010000 		.word	265
 11318 08cc 00000000 		.word	0
 11319 08d0 F71F0000 		.word	8183
 11320 08d4 00000000 		.word	0
 11321 08d8 FFFF0000 		.word	65535
 11322 08dc 09010000 		.word	265
 11323 08e0 00000000 		.word	0
 11324 08e4 F71F0000 		.word	8183
 11325 08e8 00000000 		.word	0
 11326 08ec 00000000 		.word	0
 11327 08f0 00000000 		.word	0
 11328 08f4 00000000 		.word	0
 11329 08f8 00000000 		.word	0
 11330 08fc 00000000 		.word	0
 11331 0900 00000000 		.word	0
 11332 0904 00000000 		.word	0
 11333 0908 00000000 		.word	0
 11334 090c 00000000 		.word	0
 11335 0910 00000000 		.word	0
 11336 0914 00000000 		.word	0
 11337 0918 00000000 		.word	0
 11338 091c 00000000 		.word	0
 11339 0920 00000000 		.word	0
 11340 0924 00000000 		.word	0
 11341 0928 00000000 		.word	0
 11342 092c 00000000 		.word	0
 11343 0930 00000000 		.word	0
 11344 0934 00000000 		.word	0
 11345 0938 00000000 		.word	0
 11346 093c 00000000 		.word	0
 11347 0940 00000000 		.word	0
 11348 0944 00040180 		.word	-2147417088
 11349 0948 01040180 		.word	-2147417087
 11350 094c 02040180 		.word	-2147417086
 11351 0950 03040180 		.word	-2147417085
 11352 0954 00000000 		.word	0
 11353 0958 00000000 		.word	0
 11354 095c 00000000 		.word	0
 11355 0960 00000000 		.word	0
 11356 0964 00000000 		.word	0
 11357 0968 00000000 		.word	0
 11358 096c 00000000 		.word	0
 11359 0970 00000000 		.word	0
 11360 0974 C1FFFFFF 		.word	-63
 11363              	CyFxGpifTransition_usb2:
 11364 0978 0000     		.short	0
 11365 097a 5555     		.short	21845
 11366 097c AAAA     		.short	-21846
 11367 097e 8888     		.short	-30584
 11368 0980 1111     		.short	4369
 11369 0982 4444     		.short	17476
 11370 0984 3333     		.short	13107
 11371 0986 CCCC     		.short	-13108
 11374              	CyFxGpifWavedata_usb2:
 11375 0988 0181731E 		.word	510886145
 11376 098c 00000000 		.word	0
 11377 0990 00000080 		.word	-2147483648
 11378 0994 00000000 		.word	0
 11379 0998 00000000 		.word	0
 11380 099c 00000000 		.word	0
 11381 09a0 0201703E 		.word	1047527682
 11382 09a4 00010000 		.word	256
 11383 09a8 A00000C0 		.word	-1073741664
 11384 09ac 00000000 		.word	0
 11385 09b0 00000000 		.word	0
 11386 09b4 00000000 		.word	0
 11387 09b8 0394731E 		.word	510891011
 11388 09bc 04000020 		.word	536870916
 11389 09c0 60004080 		.word	-2143289248
 11390 09c4 00000000 		.word	0
 11391 09c8 00000000 		.word	0
 11392 09cc 00000000 		.word	0
 11393 09d0 0620702E 		.word	779100166
 11394 09d4 0C000000 		.word	12
 11395 09d8 00000080 		.word	-2147483648
 11396 09dc 0620702E 		.word	779100166
 11397 09e0 0C000000 		.word	12
 11398 09e4 00000080 		.word	-2147483648
 11399 09e8 0394731E 		.word	510891011
 11400 09ec 04000020 		.word	536870916
 11401 09f0 60004080 		.word	-2143289248
 11402 09f4 0620702E 		.word	779100166
 11403 09f8 0C000000 		.word	12
 11404 09fc 00000080 		.word	-2147483648
 11405 0a00 0C93731E 		.word	510890764
 11406 0a04 04000024 		.word	603979780
 11407 0a08 90004080 		.word	-2143289200
 11408 0a0c 0D20702E 		.word	779100173
 11409 0a10 0C000000 		.word	12
 11410 0a14 00000080 		.word	-2147483648
 11411 0a18 0780724E 		.word	1316126727
 11412 0a1c 0A000000 		.word	10
 11413 0a20 00000080 		.word	-2147483648
 11414 0a24 08000000 		.word	8
 11415 0a28 00000000 		.word	0
 11416 0a2c 00010080 		.word	-2147483392
 11417 0a30 0920702E 		.word	779100169
 11418 0a34 0C010000 		.word	268
 11419 0a38 00000080 		.word	-2147483648
 11420 0a3c 0A01701E 		.word	510656778
 11421 0a40 0E000100 		.word	65550
 11422 0a44 00000080 		.word	-2147483648
 11423 0a48 00000000 		.word	0
 11424 0a4c 00000000 		.word	0
 11425 0a50 00000000 		.word	0
 11426 0a54 00000000 		.word	0
 11427 0a58 00000000 		.word	0
 11428 0a5c 00000000 		.word	0
 11429 0a60 0394731E 		.word	510891011
 11430 0a64 04000020 		.word	536870916
 11431 0a68 60004080 		.word	-2143289248
 11432 0a6c 08000000 		.word	8
 11433 0a70 00000000 		.word	0
 11434 0a74 00010080 		.word	-2147483392
 11435 0a78 0B000000 		.word	11
 11436 0a7c 00000000 		.word	0
 11437 0a80 00010080 		.word	-2147483392
 11438 0a84 0C93731E 		.word	510890764
 11439 0a88 04000024 		.word	603979780
 11440 0a8c 90004080 		.word	-2143289200
 11441 0a90 0D20702E 		.word	779100173
 11442 0a94 0C000000 		.word	12
 11443 0a98 00000080 		.word	-2147483648
 11444 0a9c 0D20702E 		.word	779100173
 11445 0aa0 0C000000 		.word	12
 11446 0aa4 00000080 		.word	-2147483648
 11447 0aa8 0E60724E 		.word	1316118542
 11448 0aac 0A000000 		.word	10
 11449 0ab0 00000080 		.word	-2147483648
 11450 0ab4 0F000000 		.word	15
 11451 0ab8 00000000 		.word	0
 11452 0abc 00010080 		.word	-2147483392
 11453 0ac0 1020702E 		.word	779100176
 11454 0ac4 0C010000 		.word	268
 11455 0ac8 00000080 		.word	-2147483648
 11456 0acc 1101701E 		.word	510656785
 11457 0ad0 0E000100 		.word	65550
 11458 0ad4 00000080 		.word	-2147483648
 11459 0ad8 0C93731E 		.word	510890764
 11460 0adc 04000024 		.word	603979780
 11461 0ae0 90004080 		.word	-2143289200
 11462 0ae4 0F000000 		.word	15
 11463 0ae8 00000000 		.word	0
 11464 0aec 00010080 		.word	-2147483392
 11465 0af0 12000000 		.word	18
 11466 0af4 00000000 		.word	0
 11467 0af8 00010080 		.word	-2147483392
 11468 0afc 0394731E 		.word	510891011
 11469 0b00 04000020 		.word	536870916
 11470 0b04 60004080 		.word	-2143289248
 11471 0b08 0480732E 		.word	779321348
 11472 0b0c 02010000 		.word	258
 11473 0b10 0000C0C0 		.word	-1061158912
 11474 0b14 0580732E 		.word	779321349
 11475 0b18 02010000 		.word	258
 11476 0b1c 0000C0C0 		.word	-1061158912
 11477 0b20 0580732E 		.word	779321349
 11478 0b24 02010000 		.word	258
 11479 0b28 0000C0C0 		.word	-1061158912
 11480 0b2c 0480732E 		.word	779321348
 11481 0b30 02010000 		.word	258
 11482 0b34 0000C0C0 		.word	-1061158912
 11485              	CyFxGpifWavedataPosition_usb2:
 11486 0b38 00       		.byte	0
 11487 0b39 01       		.byte	1
 11488 0b3a 02       		.byte	2
 11489 0b3b 03       		.byte	3
 11490 0b3c 04       		.byte	4
 11491 0b3d 05       		.byte	5
 11492 0b3e 06       		.byte	6
 11493 0b3f 07       		.byte	7
 11494 0b40 08       		.byte	8
 11495 0b41 09       		.byte	9
 11496 0b42 0A       		.byte	10
 11497 0b43 08       		.byte	8
 11498 0b44 0B       		.byte	11
 11499 0b45 0C       		.byte	12
 11500 0b46 0D       		.byte	13
 11501 0b47 08       		.byte	8
 11502 0b48 0E       		.byte	14
 11503 0b49 0F       		.byte	15
 11504 0b4a 08       		.byte	8
 11505 0b4b 08       		.byte	8
 11506 0b4c 08       		.byte	8
 11507 0b4d 08       		.byte	8
 11508 0b4e 08       		.byte	8
 11509 0b4f 08       		.byte	8
 11510 0b50 08       		.byte	8
 11511 0b51 08       		.byte	8
 11512 0b52 08       		.byte	8
 11513 0b53 08       		.byte	8
 11514 0b54 08       		.byte	8
 11515 0b55 08       		.byte	8
 11516 0b56 08       		.byte	8
 11517 0b57 08       		.byte	8
 11518 0b58 08       		.byte	8
 11519 0b59 08       		.byte	8
 11520 0b5a 08       		.byte	8
 11521 0b5b 08       		.byte	8
 11522 0b5c 08       		.byte	8
 11523 0b5d 08       		.byte	8
 11524 0b5e 08       		.byte	8
 11525 0b5f 08       		.byte	8
 11526 0b60 08       		.byte	8
 11527 0b61 08       		.byte	8
 11528 0b62 08       		.byte	8
 11529 0b63 08       		.byte	8
 11530 0b64 08       		.byte	8
 11531 0b65 08       		.byte	8
 11532 0b66 08       		.byte	8
 11533 0b67 08       		.byte	8
 11534 0b68 08       		.byte	8
 11535 0b69 08       		.byte	8
 11536 0b6a 08       		.byte	8
 11537 0b6b 08       		.byte	8
 11538 0b6c 08       		.byte	8
 11539 0b6d 08       		.byte	8
 11540 0b6e 08       		.byte	8
 11541 0b6f 08       		.byte	8
 11542 0b70 08       		.byte	8
 11543 0b71 08       		.byte	8
 11544 0b72 08       		.byte	8
 11545 0b73 08       		.byte	8
 11546 0b74 08       		.byte	8
 11547 0b75 08       		.byte	8
 11548 0b76 08       		.byte	8
 11549 0b77 08       		.byte	8
 11550 0b78 08       		.byte	8
 11551 0b79 08       		.byte	8
 11552 0b7a 08       		.byte	8
 11553 0b7b 08       		.byte	8
 11554 0b7c 08       		.byte	8
 11555 0b7d 08       		.byte	8
 11556 0b7e 08       		.byte	8
 11557 0b7f 08       		.byte	8
 11558 0b80 08       		.byte	8
 11559 0b81 08       		.byte	8
 11560 0b82 08       		.byte	8
 11561 0b83 08       		.byte	8
 11562 0b84 08       		.byte	8
 11563 0b85 08       		.byte	8
 11564 0b86 08       		.byte	8
 11565 0b87 08       		.byte	8
 11566 0b88 08       		.byte	8
 11567 0b89 08       		.byte	8
 11568 0b8a 08       		.byte	8
 11569 0b8b 08       		.byte	8
 11570 0b8c 08       		.byte	8
 11571 0b8d 08       		.byte	8
 11572 0b8e 08       		.byte	8
 11573 0b8f 08       		.byte	8
 11574 0b90 08       		.byte	8
 11575 0b91 08       		.byte	8
 11576 0b92 08       		.byte	8
 11577 0b93 08       		.byte	8
 11578 0b94 08       		.byte	8
 11579 0b95 08       		.byte	8
 11580 0b96 08       		.byte	8
 11581 0b97 08       		.byte	8
 11582 0b98 08       		.byte	8
 11583 0b99 08       		.byte	8
 11584 0b9a 08       		.byte	8
 11585 0b9b 08       		.byte	8
 11586 0b9c 08       		.byte	8
 11587 0b9d 08       		.byte	8
 11588 0b9e 08       		.byte	8
 11589 0b9f 08       		.byte	8
 11590 0ba0 08       		.byte	8
 11591 0ba1 08       		.byte	8
 11592 0ba2 08       		.byte	8
 11593 0ba3 08       		.byte	8
 11594 0ba4 08       		.byte	8
 11595 0ba5 08       		.byte	8
 11596 0ba6 08       		.byte	8
 11597 0ba7 08       		.byte	8
 11598 0ba8 08       		.byte	8
 11599 0ba9 08       		.byte	8
 11600 0baa 08       		.byte	8
 11601 0bab 08       		.byte	8
 11602 0bac 08       		.byte	8
 11603 0bad 08       		.byte	8
 11604 0bae 08       		.byte	8
 11605 0baf 08       		.byte	8
 11606 0bb0 08       		.byte	8
 11607 0bb1 08       		.byte	8
 11608 0bb2 08       		.byte	8
 11609 0bb3 08       		.byte	8
 11610 0bb4 08       		.byte	8
 11611 0bb5 08       		.byte	8
 11612 0bb6 08       		.byte	8
 11613 0bb7 08       		.byte	8
 11614 0bb8 00       		.byte	0
 11615 0bb9 01       		.byte	1
 11616 0bba 02       		.byte	2
 11617 0bbb 10       		.byte	16
 11618 0bbc 04       		.byte	4
 11619 0bbd 05       		.byte	5
 11620 0bbe 06       		.byte	6
 11621 0bbf 07       		.byte	7
 11622 0bc0 08       		.byte	8
 11623 0bc1 09       		.byte	9
 11624 0bc2 0A       		.byte	10
 11625 0bc3 08       		.byte	8
 11626 0bc4 11       		.byte	17
 11627 0bc5 0C       		.byte	12
 11628 0bc6 0D       		.byte	13
 11629 0bc7 08       		.byte	8
 11630 0bc8 0E       		.byte	14
 11631 0bc9 0F       		.byte	15
 11632 0bca 08       		.byte	8
 11633 0bcb 00       		.space	1
 11636              	CyFxGpifRegValue_usb2:
 11637 0bcc 08830080 		.word	-2147450104
 11638 0bd0 67000000 		.word	103
 11639 0bd4 01000000 		.word	1
 11640 0bd8 46000000 		.word	70
 11641 0bdc 00000000 		.word	0
 11642 0be0 00000000 		.word	0
 11643 0be4 02000000 		.word	2
 11644 0be8 82000000 		.word	130
 11645 0bec 82070000 		.word	1922
 11646 0bf0 40040000 		.word	1088
 11647 0bf4 FCFF0000 		.word	65532
 11648 0bf8 28000000 		.word	40
 11649 0bfc 00000000 		.word	0
 11650 0c00 00000000 		.word	0
 11651 0c04 00000000 		.word	0
 11652 0c08 00000000 		.word	0
 11653 0c0c 01000000 		.word	1
 11654 0c10 00000000 		.word	0
 11655 0c14 00000000 		.word	0
 11656 0c18 00000000 		.word	0
 11657 0c1c 00000000 		.word	0
 11658 0c20 00000000 		.word	0
 11659 0c24 00000000 		.word	0
 11660 0c28 00000000 		.word	0
 11661 0c2c 00000000 		.word	0
 11662 0c30 00000000 		.word	0
 11663 0c34 00000000 		.word	0
 11664 0c38 00000000 		.word	0
 11665 0c3c 00000000 		.word	0
 11666 0c40 06000000 		.word	6
 11667 0c44 00000000 		.word	0
 11668 0c48 FFFF0000 		.word	65535
 11669 0c4c 09010000 		.word	265
 11670 0c50 00000000 		.word	0
 11671 0c54 F71F0000 		.word	8183
 11672 0c58 00000000 		.word	0
 11673 0c5c FFFF0000 		.word	65535
 11674 0c60 09010000 		.word	265
 11675 0c64 00000000 		.word	0
 11676 0c68 F71F0000 		.word	8183
 11677 0c6c 00000000 		.word	0
 11678 0c70 00000000 		.word	0
 11679 0c74 00000000 		.word	0
 11680 0c78 00000000 		.word	0
 11681 0c7c 00000000 		.word	0
 11682 0c80 00000000 		.word	0
 11683 0c84 00000000 		.word	0
 11684 0c88 00000000 		.word	0
 11685 0c8c 00000000 		.word	0
 11686 0c90 00000000 		.word	0
 11687 0c94 00000000 		.word	0
 11688 0c98 00000000 		.word	0
 11689 0c9c 00000000 		.word	0
 11690 0ca0 00000000 		.word	0
 11691 0ca4 00000000 		.word	0
 11692 0ca8 00000000 		.word	0
 11693 0cac 00000000 		.word	0
 11694 0cb0 00000000 		.word	0
 11695 0cb4 00000000 		.word	0
 11696 0cb8 00000000 		.word	0
 11697 0cbc 00000000 		.word	0
 11698 0cc0 00000000 		.word	0
 11699 0cc4 00000000 		.word	0
 11700 0cc8 00040180 		.word	-2147417088
 11701 0ccc 01040180 		.word	-2147417087
 11702 0cd0 02040180 		.word	-2147417086
 11703 0cd4 03040180 		.word	-2147417085
 11704 0cd8 00000000 		.word	0
 11705 0cdc 00000000 		.word	0
 11706 0ce0 00000000 		.word	0
 11707 0ce4 00000000 		.word	0
 11708 0ce8 00000000 		.word	0
 11709 0cec 00000000 		.word	0
 11710 0cf0 00000000 		.word	0
 11711 0cf4 00000000 		.word	0
 11712 0cf8 C1FFFFFF 		.word	-63
 11713              		.section	.rodata.str1.4,"aMS",%progbits,1
 11714              		.align	2
 11715              	.LC0:
 11716 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 11716      706F732D 
 11716      74696D65 
 11716      72202564 
 11716      2025640D 
 11717 0016 0000     		.space	2
 11718              	.LC1:
 11719 0018 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 11719      7065722D 
 11719      74696D65 
 11719      72202564 
 11719      0D0A00
 11720 002b 00       		.space	1
 11721              	.LC2:
 11722 002c 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 11722      636F6D6D 
 11722      616E6420 
 11722      71756575 
 11722      65206973 
 11723 004f 00       		.space	1
 11724              	.LC3:
 11725 0050 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 11725      43595F46 
 11725      585F5556 
 11725      435F5354 
 11725      5245414D 
 11726 0076 0000     		.space	2
 11727              	.LC4:
 11728 0078 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 11728      5420656E 
 11728      636F756E 
 11728      74657265 
 11728      642E2E2E 
 11729              	.LC5:
 11730 0098 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 11730      454E4420 
 11730      656E636F 
 11730      756E7465 
 11730      7265642E 
 11731 00ba 0000     		.space	2
 11732              	.LC6:
 11733 00bc 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 11733      64697363 
 11733      6F6E6E65 
 11733      63746564 
 11733      2E2E2E30 
 11734 00db 00       		.space	1
 11735              	.LC7:
 11736 00dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 11736      7220696E 
 11736      206D756C 
 11736      74696368 
 11736      616E6E65 
 11737 010f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 11737      2025782C 
 11737      20646D61 
 11737      446F6E65 
 11737      20256420 
 11738              	.LC8:
 11739 0128 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 11739      43595F46 
 11739      585F5556 
 11739      435F5649 
 11739      44454F5F 
 11740 015b 0A00     		.ascii	"\012\000"
 11741 015d 000000   		.space	3
 11742              	.LC9:
 11743 0160 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 11743      43595F46 
 11743      585F5556 
 11743      435F5649 
 11743      44454F5F 
 11744 0193 00       		.ascii	"\000"
 11745              	.LC10:
 11746 0194 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 11746      726E6174 
 11746      65207365 
 11746      7474696E 
 11746      6720302E 
 11747              	.LC11:
 11748 01ac 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 11748      72206665 
 11748      61747572 
 11748      65207265 
 11748      71756573 
 11749 01cf 00       		.space	1
 11750              	.LC12:
 11751 01d0 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 11751      6F6D6D69 
 11751      74656F66 
 11751      20737461 
 11751      7465203D 
 11752              	.LC13:
 11753 01e8 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 11753      6E656C20 
 11753      53657420 
 11753      57726170 
 11753      55702066 
 11754 0215 000000   		.space	3
 11755              	.LC14:
 11756 0218 4572726F 		.ascii	"Error handler...\015\012\000"
 11756      72206861 
 11756      6E646C65 
 11756      722E2E2E 
 11756      0D0A00
 11757 022b 00       		.space	1
 11758              	.LC15:
 11759 022c 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 11759      69742045 
 11759      4F462066 
 11759      61696C65 
 11759      64210D0A 
 11760 0241 000000   		.space	3
 11761              	.LC16:
 11762 0244 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 11762      49324320 
 11762      636F6D6D 
 11762      616E6420 
 11762      69732030 
 11763 0277 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11763      78257820 
 11763      30782578 
 11763      20307825 
 11763      78203078 
 11764              	.LC17:
 11765 0290 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 11765      49324320 
 11765      636F6D6D 
 11765      616E6420 
 11765      73657474 
 11766 02b6 0000     		.space	2
 11767              	.LC18:
 11768 02b8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 11768      73687574 
 11768      74657220 
 11768      73657420 
 11768      76616C75 
 11769 02e2 0000     		.space	2
 11770              	.LC19:
 11771 02e4 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 11771      20736875 
 11771      74746572 
 11771      20737065 
 11771      65642E20 
 11772 0309 000000   		.space	3
 11773              	.LC20:
 11774 030c 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 11774      20736875 
 11774      74746572 
 11774      20737065 
 11774      6564322E 
 11775 0332 0000     		.space	2
 11776              	.LC21:
 11777 0334 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 11777      206C6967 
 11777      68742063 
 11777      6F6D7065 
 11777      6E736174 
 11778 0367 25640D0A 		.ascii	"%d\015\012\000"
 11778      00
 11779              	.LC22:
 11780 036c 54686520 		.ascii	"The I2C current data is not available. try again. %"
 11780      49324320 
 11780      63757272 
 11780      656E7420 
 11780      64617461 
 11781 039f 64202564 		.ascii	"d %d\015\012\000"
 11781      0D0A00
 11782 03a6 0000     		.space	2
 11783              	.LC23:
 11784 03a8 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 11784      26414743 
 11784      2073656E 
 11784      7420746F 
 11784      20686F73 
 11785 03ce 0000     		.space	2
 11786              	.LC24:
 11787 03d0 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 11787      73687574 
 11787      74657226 
 11787      6578706F 
 11787      73757265 
 11788 03fb 00       		.space	1
 11789              	.LC25:
 11790 03fc 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 11790      26414743 
 11790      20676F74 
 11790      74656E20 
 11790      66726F6D 
 11791 042d 0A00     		.ascii	"\012\000"
 11792 042f 00       		.space	1
 11793              	.LC26:
 11794 0430 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 11794      74657220 
 11794      6C657665 
 11794      6C20676F 
 11794      7474656E 
 11795 0463 25640D0A 		.ascii	"%d\015\012\000"
 11795      00
 11796              	.LC27:
 11797 0468 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 11797      75656E63 
 11797      79207365 
 11797      7474696E 
 11797      67206973 
 11798 0486 0000     		.space	2
 11799              	.LC28:
 11800 0488 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 11800      20746865 
 11800      20766964 
 11800      656F206D 
 11800      6F646520 
 11801 04aa 0000     		.space	2
 11802              	.LC29:
 11803 04ac 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 11803      67657420 
 11803      64617461 
 11803      2066726F 
 11803      6D20686F 
 11804 04d9 000000   		.space	3
 11805              	.LC30:
 11806 04dc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 11806      52657175 
 11806      65737420 
 11806      30782578 
 11806      20706172 
 11807 050f 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 11807      6E642074 
 11807      6F20686F 
 11807      73742030 
 11807      78257820 
 11808 052a 0000     		.space	2
 11809              	.LC31:
 11810 052c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 11810      204F7020 
 11810      72656365 
 11810      69766573 
 11810      20284354 
 11811 0553 00       		.space	1
 11812              	.LC32:
 11813 0554 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 11813      756C7420 
 11813      73656C65 
 11813      63746F72 
 11813      20284354 
 11814 0576 0000     		.space	2
 11815              	.LC33:
 11816 0578 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 11816      756C7420 
 11816      72657175 
 11816      65737420 
 11816      28435429 
 11817 0599 000000   		.space	3
 11818              	.LC34:
 11819 059c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 11819      52657175 
 11819      65737420 
 11819      30782578 
 11819      20706172 
 11820 05cf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 11820      20307825 
 11820      78202F20 
 11820      73656E64 
 11820      20746F20 
 11821 05fc 00       		.ascii	"\000"
 11822 05fd 000000   		.space	3
 11823              	.LC35:
 11824 0600 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 11824      73706565 
 11824      64203D20 
 11824      25642065 
 11824      76656E66 
 11825 0630 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 11825      71756573 
 11825      74203D20 
 11825      30782578 
 11825      20775661 
 11826 0660 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 11826      203D2030 
 11826      78257820 
 11826      6973666C 
 11826      61672030 
 11827 067a 0000     		.space	2
 11828              	.LC36:
 11829 067c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 11829      64656661 
 11829      756C7420 
 11829      73657475 
 11829      70207265 
 11830              	.LC37:
 11831 06a8 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 11831      6F207374 
 11831      7265616D 
 11831      20474554 
 11831      20726571 
 11832 06cd 000000   		.space	3
 11833              	.LC38:
 11834 06d0 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 11834      74686520 
 11834      76696465 
 11834      6F206D6F 
 11834      64652066 
 11835 06f1 000000   		.space	3
 11836              	.LC39:
 11837 06f4 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 11837      74686520 
 11837      76696465 
 11837      6F206D6F 
 11837      64652066 
 11838 0719 000000   		.space	3
 11839              	.LC40:
 11840 071c 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 11840      55564320 
 11840      7374696C 
 11840      6C205072 
 11840      6F622873 
 11841 0747 00       		.space	1
 11842              	.LC41:
 11843 0748 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 11843      74686520 
 11843      7374696C 
 11843      6C206D6F 
 11843      64652066 
 11844 0769 000000   		.space	3
 11845              	.LC42:
 11846 076c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 11846      7374696C 
 11846      6C20636F 
 11846      6D6D6974 
 11846      20636F6E 
 11847              	.LC43:
 11848 0794 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 11848      43595F46 
 11848      585F5556 
 11848      435F5354 
 11848      494C5F45 
 11849              	.LC44:
 11850 07b8 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 11850      55564320 
 11850      7374696C 
 11850      6C207472 
 11850      69676765 
 11851 07e1 000000   		.space	3
 11852              	.LC45:
 11853 07e4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 11853      7374696C 
 11853      6C207472 
 11853      69676765 
 11853      7220636F 
 11854 080b 00       		.space	1
 11855              	.LC46:
 11856 080c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 11856      65642074 
 11856      6F207365 
 11856      6E642069 
 11856      6E746572 
 11857 083d 0A00     		.ascii	"\012\000"
 11858 083f 00       		.space	1
 11859              	.LC47:
 11860 0840 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 11860      73657420 
 11860      64656620 
 11860      64617461 
 11860      20307825 
 11861 085f 00       		.space	1
 11862              	.LC48:
 11863 0860 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 11863      73657420 
 11863      64656620 
 11863      64617461 
 11863      20307825 
 11864 0893 2E0D0A00 		.ascii	".\015\012\000"
 11865 0897 00       		.space	1
 11866              	.LC49:
 11867 0898 55415254 		.ascii	"UART initialization failed!\012\000"
 11867      20696E69 
 11867      7469616C 
 11867      697A6174 
 11867      696F6E20 
 11868 08b5 000000   		.space	3
 11869              	.LC50:
 11870 08b8 49324320 		.ascii	"I2C initialization failed!\012\000"
 11870      696E6974 
 11870      69616C69 
 11870      7A617469 
 11870      6F6E2066 
 11871              	.LC51:
 11872 08d4 49324320 		.ascii	"I2C configuration failed!\012\000"
 11872      636F6E66 
 11872      69677572 
 11872      6174696F 
 11872      6E206661 
 11873 08ef 00       		.space	1
 11874              	.LC52:
 11875 08f0 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 11875      43726561 
 11875      74652045 
 11875      76656E74 
 11875      20666169 
 11876 091a 0000     		.space	2
 11877              	.LC53:
 11878 091c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 11878      20496E69 
 11878      74206661 
 11878      696C6564 
 11878      2C204572 
 11879 093f 00       		.space	1
 11880              	.LC54:
 11881 0940 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 11881      204F7665 
 11881      72726964 
 11881      65206661 
 11881      696C6564 
 11882 0967 00       		.space	1
 11883              	.LC55:
 11884 0968 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 11884      28323029 
 11884      204F7665 
 11884      72726964 
 11884      65206661 
 11885 0993 00       		.space	1
 11886              	.LC56:
 11887 0994 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 11887      28323429 
 11887      204F7665 
 11887      72726964 
 11887      65206661 
 11888 09bf 00       		.space	1
 11889              	.LC57:
 11890 09c0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 11890      20536574 
 11890      20287265 
 11890      73657420 
 11890      32322920 
 11891 09f2 00       		.ascii	"\000"
 11892 09f3 00       		.space	1
 11893              	.LC58:
 11894 09f4 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 11894      20536574 
 11894      2028706F 
 11894      77657220 
 11894      32302920 
 11895 0a26 00       		.ascii	"\000"
 11896 0a27 00       		.space	1
 11897              	.LC59:
 11898 0a28 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 11898      20536574 
 11898      2028736E 
 11898      61702073 
 11898      686F7420 
 11899 0a5b 25640A00 		.ascii	"%d\012\000"
 11900 0a5f 00       		.space	1
 11901              	.LC60:
 11902 0a60 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 11902      46756E63 
 11902      74696F6E 
 11902      20466169 
 11902      6C656420 
 11903 0a8f 00       		.space	1
 11904              	.LC61:
 11905 0a90 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 11905      46756E63 
 11905      74696F6E 
 11905      20466169 
 11905      6C656420 
 11906 0abf 00       		.space	1
 11907              	.LC62:
 11908 0ac0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 11908      53657420 
 11908      456E6470 
 11908      6F696E74 
 11908      20636F6E 
 11909 0af0 00       		.ascii	"\000"
 11910 0af1 000000   		.space	3
 11911              	.LC63:
 11912 0af4 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 11912      496E7465 
 11912      72727570 
 11912      74205374 
 11912      61747573 
 11913 0b27 20436F64 		.ascii	" Code = %d\012\000"
 11913      65203D20 
 11913      25640A00 
 11914 0b33 00       		.space	1
 11915              	.LC64:
 11916 0b34 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 11916      65642074 
 11916      6F20616C 
 11916      6C6F6361 
 11916      7465206D 
 11917 0b67 65720D0A 		.ascii	"er\015\012\000"
 11917      00
 11918              	.LC65:
 11919 0b6c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 11919      4368616E 
 11919      6E656C20 
 11919      43726561 
 11919      74696F6E 
 11920 0b9a 0000     		.space	2
 11921              	.LC66:
 11922 0b9c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 11922      436F6E6E 
 11922      65637420 
 11922      6661696C 
 11922      65642C20 
 11923 0bc1 000000   		.space	3
 11924              	.LC67:
 11925 0bc4 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 11925      74686520 
 11925      76696465 
 11925      6F206D6F 
 11925      64652066 
 11926 0be6 0000     		.space	2
 11927              	.LC68:
 11928 0be8 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 11928      4368616E 
 11928      6E656C20 
 11928      52657365 
 11928      74204661 
 11929 0c13 00       		.space	1
 11930              	.LC69:
 11931 0c14 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 11931      4368616E 
 11931      6E656C20 
 11931      53657420 
 11931      5472616E 
 11932 0c45 00       		.ascii	"\000"
 11933 0c46 0000     		.space	2
 11934              	.LC70:
 11935 0c48 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 11935      4368616E 
 11935      6E656C20 
 11935      53657420 
 11935      5472616E 
 11936 0c79 0A00     		.ascii	"\012\000"
 11937 0c7b 00       		.space	1
 11938              	.LC71:
 11939 0c7c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 11939      75706572 
 11939      20677069 
 11939      6600
 11940 0c8a 0000     		.space	2
 11941              	.LC72:
 11942 0c8c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 11942      69676820 
 11942      67706966 
 11942      00
 11943 0c99 000000   		.space	3
 11944              	.LC73:
 11945 0c9c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11945      696E6720 
 11945      47504946 
 11945      20436F6E 
 11945      66696775 
 11946 0ccf 0A00     		.ascii	"\012\000"
 11947 0cd1 000000   		.space	3
 11948              	.LC74:
 11949 0cd4 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11949      74696E67 
 11949      20475049 
 11949      46207374 
 11949      61746520 
 11950 0d07 0D0A00   		.ascii	"\015\012\000"
 11951 0d0a 0000     		.space	2
 11952              	.LC75:
 11953 0d0c 49324363 		.ascii	"I2CcmdQue\000"
 11953      6D645175 
 11953      6500
 11954 0d16 0000     		.space	2
 11955              	.LC76:
 11956 0d18 33303A55 		.ascii	"30:UVC App Thread\000"
 11956      56432041 
 11956      70702054 
 11956      68726561 
 11956      6400
 11957 0d2a 0000     		.space	2
 11958              	.LC77:
 11959 0d2c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11959      56432041 
 11959      70702045 
 11959      50302054 
 11959      68726561 
 11960 0d42 0000     		.space	2
 11961              	.LC78:
 11962 0d44 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11962      32432041 
 11962      70702043 
 11962      54524C20 
 11962      54687265 
 11963 0d5b 00       		.bss
 11964              		.align	2
 11965              		.set	.LANCHOR0,. + 0
 11968              	glFxUVCEvent:
 11969 0000 00000000 		.space	40
 11969      00000000 
 11969      00000000 
 11969      00000000 
 11969      00000000 
 11972              	streamingRecove:
 11973 0028 00000000 		.space	4
 11976              	debugData:
 11977 002c 00000000 		.space	16
 11977      00000000 
 11977      00000000 
 11977      00000000 
 11980              	gpif_initialized:
 11981 003c 00000000 		.space	4
 11984              	streamingStarted:
 11985 0040 00000000 		.space	4
 11988              	isUsbConnected:
 11989 0044 00000000 		.space	4
 11992              	fb:
 11993 0048 0000     		.space	2
 11996              	pb:
 11997 004a 0000     		.space	2
 12000              	pbc:
 12001 004c 0000     		.space	2
 12004              	stiflag:
 12005 004e 00       		.space	1
 12006 004f 00       		.space	1
 12009              	hitFV:
 12010 0050 00000000 		.space	4
 12013              	prodCount:
 12014 0054 0000     		.space	2
 12017              	consCount:
 12018 0056 0000     		.space	2
 12021              	clearFeatureRqtReceived:
 12022 0058 00000000 		.space	4
 12025              	usbSpeed:
 12026 005c 00       		.space	1
 12027 005d 000000   		.space	3
 12030              	I2CCMDArry:
 12031 0060 00000000 		.space	12
 12031      00000000 
 12031      00000000 
 12034              	is60Hz:
 12035 006c 00000000 		.space	4
 12038              	stream_start:
 12039 0070 00000000 		.space	4
 12042              	glEp0Buffer:
 12043 0074 00000000 		.space	32
 12043      00000000 
 12043      00000000 
 12043      00000000 
 12043      00000000 
 12046              	curFlag:
 12047 0094 00000000 		.space	64
 12047      00000000 
 12047      00000000 
 12047      00000000 
 12047      00000000 
 12050              	CamMode:
 12051 00d4 00       		.space	1
 12054              	setRes:
 12055 00d5 00       		.space	1
 12056 00d6 0000     		.space	2
 12059              	glCommitCtrl:
 12060 00d8 00000000 		.space	32
 12060      00000000 
 12060      00000000 
 12060      00000000 
 12060      00000000 
 12063              	setstilRes:
 12064 00f8 00       		.space	1
 12067              	IMcount.7862:
 12068 00f9 00       		.space	1
 12069 00fa 0000     		.space	2
 12072              	uvcAppThread:
 12073 00fc 00000000 		.space	168
 12073      00000000 
 12073      00000000 
 12073      00000000 
 12073      00000000 
 12076              	uvcAppEP0Thread:
 12077 01a4 00000000 		.space	168
 12077      00000000 
 12077      00000000 
 12077      00000000 
 12077      00000000 
 12080              	i2cAppThread:
 12081 024c 00000000 		.space	168
 12081      00000000 
 12081      00000000 
 12081      00000000 
 12081      00000000 
 12084              	testSnap:
 12085 02f4 00       		.space	1
 12086 02f5 00       		.space	1
 12089              	fbbak:
 12090 02f6 0000     		.space	2
 12093              	pbbak:
 12094 02f8 0000     		.space	2
 12097              	pbcbak:
 12098 02fa 0000     		.space	2
 12101              	pbcpbak:
 12102 02fc 0000     		.space	2
 12103 02fe 0000     		.text
 12104              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:24     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:59     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:65     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:68     .text:0000003c I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:246    .text:000001b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:252    .text:000001c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:375    .text:000002b0 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:387    .text:000002d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:389    .text:000002d4 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:591    .text:00000458 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:600    .text:00000468 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:603    .text:00000468 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:825    .text:00000608 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:835    .text:00000624 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:837    .text:00000624 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1172   .text:00000904 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1188   .text:00000930 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1191   .text:00000930 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1228   .text:00000968 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1241   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1288   .text:000009e8 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1295   .text:000009f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1313   .text:00000a14 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1322   .text:00000a2c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1325   .text:00000a2c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1636   .text:00000d28 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1645   .text:00000d40 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1648   .text:00000d40 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1711   .text:00000dc0 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1734   .text:00000dd8 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1747   .text:00000e00 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1853   .text:00000ef4 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1861   .text:00000f08 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:1864   .text:00000f08 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:2076   .text:000010a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:2118   .text:00001140 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:2184   .text:000011c0 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:2225   .text:0000125c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:3584   .text:00001e3c $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:3607   .text:00001e8c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:4012   .text:00002244 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:4018   .text:00002254 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:4621   .text:00002774 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:4789   .text:000028d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:4802   .text:000028f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5297   .text:00002e08 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5308   .text:00002e28 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5570   .text:000030e4 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5583   .text:0000310c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5586   .text:0000310c UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5648   .text:00003188 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:5656   .text:00003198 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:6089   .text:000035d0 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:6096   .text:000035e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:6572   .text:000039d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:6579   .text:000039e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7099   .text:00003e7c $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7134   .text:00003ef4 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7137   .text:00003ef4 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7430   .text:000041b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7437   .text:000041c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7440   .text:000041c0 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7481   .text:00004204 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7486   .text:0000420c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7489   .text:0000420c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7514   .text:00004228 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7518   .text:0000422c $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:7521   .text:0000422c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:8384   .text:00004938 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:8393   .text:00004948 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9049   .text:00004ec8 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9055   .text:00004ed8 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9171   .text:00005040 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9231   .text:00005124 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9234   .text:00005124 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9380   .text:0000527c $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9396   .text:000052b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9399   .text:000052b0 main
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11181  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11190  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11265  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11284  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9559   .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11363  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11374  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11485  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11636  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9572   .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11177  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12084  .bss:000002f4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11992  .bss:00000048 fb
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11996  .bss:0000004a pb
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12000  .bss:0000004c pbc
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12089  .bss:000002f6 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12093  .bss:000002f8 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12097  .bss:000002fa pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12101  .bss:000002fc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11988  .bss:00000044 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12025  .bss:0000005c usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12021  .bss:00000058 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11972  .bss:00000028 streamingRecove
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11984  .bss:00000040 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11118  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11058  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11148  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11088  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11163  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10554  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 staQuMux
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9540   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9544   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9584   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9588   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:9911   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10569  .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10574  .data:00000490 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10596  .data:000004a4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10618  .data:000004b8 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10640  .data:000004cc EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10662  .data:000004e0 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10684  .data:000004f4 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10691  .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10713  .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:10735  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11714  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11964  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11968  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11976  .bss:0000002c debugData
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:11980  .bss:0000003c gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12004  .bss:0000004e stiflag
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12009  .bss:00000050 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12013  .bss:00000054 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12017  .bss:00000056 consCount
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12030  .bss:00000060 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12034  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12038  .bss:00000070 stream_start
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12042  .bss:00000074 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12046  .bss:00000094 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12050  .bss:000000d4 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12054  .bss:000000d5 setRes
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12059  .bss:000000d8 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12063  .bss:000000f8 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12067  .bss:000000f9 IMcount.7862
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12072  .bss:000000fc uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12076  .bss:000001a4 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccUR40Xe.s:12080  .bss:0000024c i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
_txe_timer_create
_tx_time_get
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
SensorWrite2B2
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
