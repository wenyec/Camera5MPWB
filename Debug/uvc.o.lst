   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB26:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** /*
 594:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 595:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 596:../uvc.c      ****  */
 597:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 598:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 599:../uvc.c      **** };
 600:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 601:../uvc.c      **** 		0
 602:../uvc.c      **** };
 603:../uvc.c      **** 
 604:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 605:../uvc.c      **** 
 606:../uvc.c      **** void I2CCmdHandler(){
 607:../uvc.c      **** 	uint8_t buf[2];
 608:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 612:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 613:../uvc.c      **** 	uint8_t i;
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 615:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 616:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 618:../uvc.c      **** 	{
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 621:../uvc.c      **** 			{
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 623:../uvc.c      **** 			}
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 625:../uvc.c      **** 
 626:../uvc.c      **** 	}
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 628:../uvc.c      **** 	{
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 630:../uvc.c      **** #if 0 //for debugging
 631:../uvc.c      **** 		/* test still image operation */
 632:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 633:../uvc.c      **** 			snapButFlag = 0; //press
 634:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 635:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 636:../uvc.c      **** 			snapButFlag = 0xf; //release
 637:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 638:../uvc.c      **** 		}
 639:../uvc.c      **** 
 640:../uvc.c      **** 		/* end of the test */
 641:../uvc.c      **** #endif
 642:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 647:../uvc.c      **** 				}
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 649:../uvc.c      **** 		}else{//not support currently
 650:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 651:../uvc.c      **** 		}
 652:../uvc.c      **** 	}else if(CmdType == 1){
 653:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 655:../uvc.c      **** 				for(i = 0; i<4; i++)
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else{
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 663:../uvc.c      **** 				}
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 665:../uvc.c      **** 			}
 666:../uvc.c      **** 		}else{//not support currently
 667:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 	}
 671:../uvc.c      **** }
 672:../uvc.c      **** 
 673:../uvc.c      **** /************************************
 674:../uvc.c      ****  * set Iris mode
 675:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 676:../uvc.c      ****  */
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 678:../uvc.c      **** 	uint8_t dataIdx = 0;
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 683:../uvc.c      **** }
 684:../uvc.c      **** 
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 688:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 689:../uvc.c      **** 	uint16_t NumLn;
 690:../uvc.c      **** 	uint16_t fRate, shutTm;
 691:../uvc.c      **** 	uint8_t LnVal;
 692:../uvc.c      **** 	switch (Data){
 693:../uvc.c      **** 	case 1:
 694:../uvc.c      **** 	case 2:
 695:../uvc.c      **** 	case 3:
 696:../uvc.c      **** 	case 4:
 697:../uvc.c      **** 	case 5:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 699:../uvc.c      **** 		fRate = 30;
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 701:../uvc.c      **** 		if(NumLn > 1944)
 702:../uvc.c      **** 			NumLn =1944;
 703:../uvc.c      **** 		else if(NumLn < 8)
 704:../uvc.c      **** 			NumLn = 8;
 705:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 706:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 707:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 708:../uvc.c      **** 		break;
 709:../uvc.c      **** 	case 6:
 710:../uvc.c      **** 	case 7:
 711:../uvc.c      **** 	case 8:
 712:../uvc.c      **** 	case 9:
 713:../uvc.c      **** 	case 10:
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 715:../uvc.c      **** 		fRate = 30;
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 717:../uvc.c      **** 		if(NumLn > 1944)
 718:../uvc.c      **** 			NumLn =1944;
 719:../uvc.c      **** 		else if(NumLn < 8)
 720:../uvc.c      **** 			NumLn = 8;
 721:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 724:../uvc.c      **** 		break;
 725:../uvc.c      **** 	case 0: //auto
 726:../uvc.c      **** 	default:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 728:../uvc.c      **** 		LnVal = 1;
 729:../uvc.c      **** 		break;
 730:../uvc.c      **** 	}
 731:../uvc.c      **** 	return LnVal;
 732:../uvc.c      **** }
 733:../uvc.c      **** 
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 736:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 737:../uvc.c      ****     uint16_t readCount;
 738:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 739:../uvc.c      ****     uint8_t devAdd;
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 746:../uvc.c      ****     }else{
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 751:../uvc.c      ****     }
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 754:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 755:../uvc.c      **** #endif
 756:../uvc.c      ****     reqData = bRequest;
 757:../uvc.c      ****     /*
 758:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 759:../uvc.c      ****      */
 760:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 761:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 762:../uvc.c      ****     	goto EndofSet;
 763:../uvc.c      ****     }
 764:../uvc.c      ****     switch (bRequest)
 765:../uvc.c      **** 		 {
 766:../uvc.c      **** 
 767:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 772:../uvc.c      **** 			  break;
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 774:../uvc.c      **** 
 775:../uvc.c      **** 			 switch(CtrlID)
 776:../uvc.c      **** 			 {
 777:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 778:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 779:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 780:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 781:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 782:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 783:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 784:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 785:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 786:../uvc.c      **** 			 	 		 break;
 787:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 788:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 789:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 790:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 791:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 792:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 793:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 794:../uvc.c      **** 			 	 		 break;
 795:../uvc.c      **** 			 	 }
 796:../uvc.c      **** 			 	 case ExtShutCtlID0:
 797:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 798:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 799:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 800:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 801:../uvc.c      **** 			 		 break;
 802:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 803:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 804:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 805:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 806:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 807:../uvc.c      **** 			 		 break;
 808:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 809:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 810:../uvc.c      **** 					 if(CamMode == 1){//720p
 811:../uvc.c      **** 						if(sendData >= 3){
 812:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 813:../uvc.c      **** 							sendData = 0; //set back to default
 814:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 815:../uvc.c      **** 						}
 816:../uvc.c      **** 						sendData += 4;
 817:../uvc.c      **** 					 }
 818:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 819:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 820:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 821:../uvc.c      **** 					 break;
 822:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 823:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 824:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 825:../uvc.c      **** 			 		 }
 826:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 827:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 828:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 829:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 830:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 831:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 832:../uvc.c      **** #endif
 833:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 834:../uvc.c      **** 			 		 {
 835:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 836:../uvc.c      **** 			 		 }
 837:../uvc.c      **** 			 		 break;
 838:../uvc.c      **** 				 case ExtAexModCtlID9:
 839:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 840:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 841:../uvc.c      **** 
 842:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 843:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 844:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 845:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 846:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 847:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 848:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 849:../uvc.c      **** 					 break;
 850:../uvc.c      **** 
 851:../uvc.c      **** 			 	 case BrgtCtlID1:
 852:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 853:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 854:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 855:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 856:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 857:../uvc.c      **** 					 }else{
 858:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 859:../uvc.c      **** 					 }
 860:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 861:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 862:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 863:../uvc.c      **** 					 */
 864:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 865:../uvc.c      **** 					  if(Data0&0x80){
 866:../uvc.c      **** 						  Data0 = ~Data0;
 867:../uvc.c      **** 					  }else{
 868:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 869:../uvc.c      **** 					  }
 870:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 871:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 872:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 873:../uvc.c      **** 			 		 break;
 874:../uvc.c      **** 				 case HueCtlID5:
 875:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 876:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 877:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 878:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 879:../uvc.c      **** 					 break;
 880:../uvc.c      **** 				 case WBTLevCtlID11:
 881:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 882:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 883:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 884:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 885:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 886:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 887:../uvc.c      **** 					 break;
 888:../uvc.c      **** 				 case BLCCtlID0:
 889:../uvc.c      **** 				 case ShapCtlID7:
 890:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 891:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 892:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 893:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 894:../uvc.c      **** 					 break;
 895:../uvc.c      **** 				 case ExtExRefCtlID10:
 896:../uvc.c      **** 				 case ConsCtlID2:
 897:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
 898:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 899:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 900:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 901:../uvc.c      **** 					 break;
 902:../uvc.c      **** 				 case SaturCtlID6:
 903:../uvc.c      **** 				 default:
 904:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 905:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 906:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 907:../uvc.c      **** 					 break;
 908:../uvc.c      **** 			 }
 909:../uvc.c      **** 
 910:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 911:../uvc.c      **** 
 912:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 913:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 914:../uvc.c      **** #endif
 915:../uvc.c      **** 			  break;
 916:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 917:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 918:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 919:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 920:../uvc.c      **** 		 	 }
 921:../uvc.c      **** 
 922:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 923:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 924:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 925:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 926:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 927:../uvc.c      **** 			 }else
 928:../uvc.c      **** 			 {
 929:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 930:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 931:../uvc.c      **** 			 }
 932:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 933:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 934:../uvc.c      **** 			  break;
 935:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 936:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 937:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 938:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 939:../uvc.c      **** 		 	 }
 940:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 941:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 942:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 943:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 944:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 945:../uvc.c      **** 			 }else
 946:../uvc.c      **** 			 {
 947:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 948:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 949:../uvc.c      **** 			 }
 950:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 951:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 954:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 955:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 956:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 957:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 958:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 959:../uvc.c      **** 		 	 }
 960:../uvc.c      **** 		 	 else{
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 962:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 963:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 964:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 965:../uvc.c      **** 		 	 }
 966:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 967:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 968:../uvc.c      **** 			  break;
 969:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 970:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 971:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 972:../uvc.c      **** 		 	 }
 973:../uvc.c      **** 		 	 else{
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 975:../uvc.c      **** 		 	 }
 976:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 977:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 978:../uvc.c      **** 			  Len = 1;
 979:../uvc.c      **** 			  break;
 980:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 981:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 982:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 983:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 984:../uvc.c      **** 		 	 }
 985:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 986:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 987:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 988:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 989:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 990:../uvc.c      **** 			 }else{
 991:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 992:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 993:../uvc.c      **** 			 }
 994:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 995:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 996:../uvc.c      **** 			  break;
 997:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 998:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 999:../uvc.c      **** 				  glEp0Buffer, &readCount);
1000:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1001:../uvc.c      **** 			   {
1002:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1003:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1004:../uvc.c      **** 				  getData = glEp0Buffer[0];
1005:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1006:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1007:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1008:../uvc.c      **** #endif
1009:../uvc.c      **** 				  switch(CtrlID)
1010:../uvc.c      **** 					 {
1011:../uvc.c      **** 						 case ExtShutCtlID0:
1012:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1013:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1014:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1015:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1016:../uvc.c      **** #if 1	// register setting directly
1017:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1018:../uvc.c      **** 						     {
1019:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1020:../uvc.c      **** 						    	 dataIdx = 0;
1021:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1022:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1023:../uvc.c      **** 								 dataIdx++;
1024:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1025:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1026:../uvc.c      **** 						     }
1027:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1028:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1029:../uvc.c      **** 						     break;
1030:../uvc.c      **** #else	// old fashion
1031:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1032:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1033:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1034:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1035:../uvc.c      **** 									 }else{
1036:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1037:../uvc.c      **** 									 }
1038:../uvc.c      **** 								 }
1039:../uvc.c      **** 							 }else{
1040:../uvc.c      **** 								 Data1 = Data0 - 1;
1041:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1042:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1043:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1044:../uvc.c      **** 									 }else{
1045:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1046:../uvc.c      **** 									 }
1047:../uvc.c      **** 								 }
1048:../uvc.c      **** 								 if(Data1 < 8){
1049:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1050:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1051:../uvc.c      **** 								 }else{
1052:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1053:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1054:../uvc.c      **** 								 }
1055:../uvc.c      **** 							 }
1056:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1057:../uvc.c      **** 							 dataIdx = 0;
1058:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1059:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1060:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1061:../uvc.c      **** 							 if(AxMode){
1062:../uvc.c      **** 								 dataIdx++;
1063:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1064:../uvc.c      **** 								 dataIdx++;
1065:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1066:../uvc.c      **** 							 }
1067:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1068:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1069:../uvc.c      **** 							 break;
1070:../uvc.c      **** #endif
1071:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1072:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1073:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1074:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1075:../uvc.c      **** 						     dataIdx = 0;
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1077:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1078:../uvc.c      **** 							 {
1079:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1080:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1081:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1082:../uvc.c      **** 								 /*
1083:../uvc.c      **** 								 dataIdx++;
1084:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1085:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1086:../uvc.c      **** 									 dataIdx++;
1087:../uvc.c      **** 								 }else{
1088:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1089:../uvc.c      **** 									 dataIdx++;
1090:../uvc.c      **** 								 }
1091:../uvc.c      **** 								 */
1092:../uvc.c      **** 							 }
1093:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1094:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1095:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1096:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1097:../uvc.c      **** 								 }
1098:../uvc.c      **** 							 }
1099:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1100:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1101:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1102:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1103:../uvc.c      **** 							 break;
1104:../uvc.c      **** 
1105:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1106:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1107:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1108:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1109:../uvc.c      **** 						     dataIdx = 0;
1110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1111:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1112:../uvc.c      **** 							 {
1113:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1114:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1115:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1116:../uvc.c      **** 								 dataIdx++;
1117:../uvc.c      **** 							 }
1118:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1119:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1120:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1121:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1122:../uvc.c      **** 									 dataIdx++;
1123:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1124:../uvc.c      **** 								 }
1125:../uvc.c      **** 							 }
1126:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1127:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1128:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1129:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1130:../uvc.c      **** 							 break;
1131:../uvc.c      **** 						 case ExtCamMCtlID12:
1132:../uvc.c      **** 							 dataIdx = 0;
1133:../uvc.c      **** 							 if(Data0 <= 3){
1134:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1135:../uvc.c      **** 								 Data1 = Data0;
1136:../uvc.c      **** 							 }else{
1137:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1138:../uvc.c      **** 								 Data1 = Data0-4;
1139:../uvc.c      **** 							 }
1140:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1141:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1142:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1143:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1144:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1145:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1146:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1147:../uvc.c      **** 							 break;
1148:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1149:../uvc.c      **** 							 dataIdx = 0;
1150:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1151:../uvc.c      **** 								 Data0 = 1;
1152:../uvc.c      **** 							 }else{ //save current sensor parameters.
1153:../uvc.c      **** 								 Data0 = 0;
1154:../uvc.c      **** 							 }
1155:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1156:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1157:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1158:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1159:../uvc.c      **** 							 break;
1160:../uvc.c      **** 						 case ExtI2CCtlID15:
1161:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1162:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1163:../uvc.c      **** 					 		 }
1164:../uvc.c      **** 					 		I2CCmdHandler();
1165:../uvc.c      **** 							 break;
1166:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1167:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1168:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1169:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1170:../uvc.c      **** 
1171:../uvc.c      **** 							 dataIdx = 0;
1172:../uvc.c      **** #if 0 //seperate version
1173:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1174:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1175:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1176:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1177:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1178:../uvc.c      **** 							 }else{ //disable BLD window
1179:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1180:../uvc.c      **** 							 }
1181:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1182:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1183:../uvc.c      **** 							 dataIdx++;
1184:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1185:../uvc.c      **** 							 dataIdx++;
1186:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1187:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1188:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1189:../uvc.c      **** 							 dataIdx++;
1190:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1191:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1192:../uvc.c      **** #else //combination version
1193:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1195:../uvc.c      **** 						     /* end test */
1196:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1197:../uvc.c      **** 							 dataIdx++;
1198:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1199:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1200:../uvc.c      **** 							 getData1 = Data1;
1201:../uvc.c      **** #endif
1202:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1203:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1204:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1205:../uvc.c      **** 							 break;
1206:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1207:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1208:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1209:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1210:../uvc.c      **** 
1211:../uvc.c      **** 							 dataIdx = 0;
1212:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1213:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1214:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1215:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1216:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1217:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1218:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1219:../uvc.c      **** 							 break;
1220:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1221:../uvc.c      **** 							 dataIdx = 0;
1222:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1223:../uvc.c      **** 							 if(Data0 == 1){
1224:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1225:../uvc.c      **** 							 }else{
1226:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1227:../uvc.c      **** 							 }
1228:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1229:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1230:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1231:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1232:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1233:../uvc.c      **** 							 break;
1234:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1235:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1236:../uvc.c      **** 							 dataIdx = 0;
1237:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1238:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1239:../uvc.c      **** 							  if(Data0&0x80){
1240:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1241:../uvc.c      **** 							  }else{
1242:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1243:../uvc.c      **** 							  }
1244:../uvc.c      **** 							 Data1 |= ~0x03;
1245:../uvc.c      **** 							 Data1 &= 0xC7;
1246:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1247:../uvc.c      **** 						  	 dataIdx++;
1248:../uvc.c      **** 
1249:../uvc.c      **** 							 Data0 = (Data0 << 2);
1250:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1251:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1252:../uvc.c      **** 
1253:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1254:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1255:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1256:../uvc.c      **** #endif
1257:../uvc.c      **** 							 dataIdx = 0;
1258:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1259:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1260:../uvc.c      **** 							  if(Data0&0x80){
1261:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1262:../uvc.c      **** 							  }else{
1263:../uvc.c      **** 								  Data0 = ~Data0;
1264:../uvc.c      **** 							  }
1265:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1266:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1267:../uvc.c      **** 
1268:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1269:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1270:../uvc.c      **** 
1271:../uvc.c      **** 
1272:../uvc.c      **** 							 break;
1273:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1274:../uvc.c      **** 							 dataIdx = 0;
1275:../uvc.c      **** 
1276:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1278:../uvc.c      **** 							 dataIdx++;
1279:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1280:../uvc.c      **** 							 dataIdx++;
1281:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1282:../uvc.c      **** 							 dataIdx++;
1283:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1284:../uvc.c      **** 							 dataIdx++;
1285:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1286:../uvc.c      **** 							 dataIdx++;
1287:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1288:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1289:../uvc.c      **** 
1290:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1291:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1292:../uvc.c      **** 							 break;
1293:../uvc.c      **** 						 case SaturCtlID6:
1294:../uvc.c      **** 							 dataIdx = 0;
1295:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1296:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1297:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1298:../uvc.c      **** 							 dataIdx++;
1299:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1300:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1301:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1302:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1303:../uvc.c      **** 							 break;
1304:../uvc.c      **** 
1305:../uvc.c      **** 						 case WBTLevCtlID11:
1306:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1307:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1308:../uvc.c      **** 							 dataIdx = 0;
1309:../uvc.c      **** 
1310:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1311:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1312:../uvc.c      **** 							 dataIdx++;
1313:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1314:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1315:../uvc.c      **** 
1316:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1317:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1318:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1319:../uvc.c      **** 							 break;
1320:../uvc.c      **** 						 case MFreqCtlID4:
1321:../uvc.c      **** 							 dataIdx = 0;
1322:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1323:../uvc.c      **** 							 Data0 = Data0 - 1;
1324:../uvc.c      **** 							 is60Hz = Data0;
1325:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1326:../uvc.c      **** 							 {
1327:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1328:../uvc.c      **** 								 is60Hz = CyFalse;
1329:../uvc.c      **** 							 }
1330:../uvc.c      **** 							 else if(Data0 >2)
1331:../uvc.c      **** 							 {
1332:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1333:../uvc.c      **** 								 is60Hz = CyTrue;
1334:../uvc.c      **** 							 }
1335:../uvc.c      **** 							 //CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1336:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1337:../uvc.c      **** 							 {
1338:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1339:../uvc.c      **** 			                       switch (setRes)
1340:../uvc.c      **** 			                         {
1341:../uvc.c      **** 			                         	case 1: //1944
1342:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1343:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1344:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1345:../uvc.c      **** 			                         		break;
1346:../uvc.c      **** 			                         	case 2: //1080
1347:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1348:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1349:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1350:../uvc.c      **** 			                         		break;
1351:../uvc.c      **** 			                         	case 3: //720
1352:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1353:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1354:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1355:../uvc.c      **** 			                         		break;
1356:../uvc.c      **** 			                         	case 4: //VGA
1357:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1358:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1359:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1360:../uvc.c      **** 			                         	default:
1361:../uvc.c      **** 			                         		break;
1362:../uvc.c      **** 			                         }
1363:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1364:../uvc.c      **** 							 }
1365:../uvc.c      **** 
1366:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1367:../uvc.c      **** 							 break;
1368:../uvc.c      **** 					 	 case BLCCtlID0:
1369:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1370:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1371:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1372:../uvc.c      **** 						     dataIdx = 0;
1373:../uvc.c      **** 
1374:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1375:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1376:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1377:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1378:../uvc.c      **** 
1379:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1380:../uvc.c      **** 							 {
1381:../uvc.c      **** 								 if(Data0 < 3){
1382:../uvc.c      **** 					 				 Data0 += 4;
1383:../uvc.c      **** 					 			 }else{
1384:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1385:../uvc.c      **** 									Data0 = 4; //set to default.
1386:../uvc.c      **** 					 			 }
1387:../uvc.c      **** 					 		 }
1388:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1389:../uvc.c      **** 							 dataIdx = 0;
1390:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1391:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1392:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1393:../uvc.c      **** 
1394:../uvc.c      **** 					 		 break;
1395:../uvc.c      **** 					 	 case ShapCtlID7:
1396:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1397:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1398:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1399:../uvc.c      **** 						     dataIdx = 0;
1400:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1401:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1402:../uvc.c      **** 							 if(Data0 != 0){
1403:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1404:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1405:../uvc.c      **** 								 dataIdx++;
1406:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1407:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1408:../uvc.c      **** 							 }else{
1409:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1410:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1411:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1412:../uvc.c      **** 
1413:../uvc.c      **** 							 }
1414:../uvc.c      **** 							 break;
1415:../uvc.c      **** 						 case ExtExRefCtlID10:
1416:../uvc.c      **** 						 case ConsCtlID2:
1417:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1418:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1419:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1420:../uvc.c      **** 
1421:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1422:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1423:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1424:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1425:../uvc.c      **** 
1426:../uvc.c      **** 							 break;
1427:../uvc.c      **** 						 default:
1428:../uvc.c      **** 							 dataIdx = 0;
1429:../uvc.c      **** 
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1431:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1432:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1433:../uvc.c      **** 
1434:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1435:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1436:../uvc.c      **** 							 break;
1437:../uvc.c      **** 					 }
1438:../uvc.c      **** 			   }else{
1439:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1440:../uvc.c      **** 			   }
1441:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1442:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1443:../uvc.c      **** #endif
1444:../uvc.c      **** 
1445:../uvc.c      **** 			  break;
1446:../uvc.c      **** 		  default:
1447:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1448:../uvc.c      **** 			  break;
1449:../uvc.c      **** 		 }
1450:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1451:../uvc.c      **** }
1452:../uvc.c      **** /************** CT control requests handler *************************/
1453:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1454:../uvc.c      **** 
1455:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1456:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1457:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1458:../uvc.c      ****     uint16_t readCount;
1459:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1460:../uvc.c      ****     uint16_t diff, value, diffRd;
1461:../uvc.c      ****     uint8_t i, shutter, index;
1462:../uvc.c      ****     diff = 0xffff;
1463:../uvc.c      ****     shutter = 1;
1464:../uvc.c      ****     index = 1;
1465:../uvc.c      **** 
1466:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1467:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1468:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1469:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1470:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1471:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1472:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1473:../uvc.c      **** #endif
1474:../uvc.c      ****     reqData = bRequest;
1475:../uvc.c      **** 
1476:../uvc.c      ****     switch (bRequest)
1477:../uvc.c      **** 		 {
1478:../uvc.c      **** 
1479:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1480:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1481:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1482:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1483:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1484:../uvc.c      **** 			  break;
1485:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1486:../uvc.c      **** 
1487:../uvc.c      **** 			 switch(CtrlID)
1488:../uvc.c      **** 			 {
1489:../uvc.c      **** 				 default:
1490:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1491:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1492:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1493:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1494:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1495:../uvc.c      **** 					 break;
1496:../uvc.c      **** 			 }
1497:../uvc.c      **** 
1498:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1499:../uvc.c      **** 
1500:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1501:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1502:../uvc.c      **** #endif
1503:../uvc.c      **** 			  break;
1504:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1505:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1506:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1507:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1508:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1509:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1510:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1511:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1512:../uvc.c      **** 			  break;
1513:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1514:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1515:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1516:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1517:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1518:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1519:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1520:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1521:../uvc.c      **** 			  break;
1522:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1523:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1524:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1525:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1526:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1527:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1528:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1529:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1530:../uvc.c      **** 			  break;
1531:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1532:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1533:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1534:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1535:../uvc.c      **** 			  Len = 1;
1536:../uvc.c      **** 			  break;
1537:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1538:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1539:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1540:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1541:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1542:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1543:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1544:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1545:../uvc.c      **** 			  break;
1546:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1547:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1548:../uvc.c      **** 			  glEp0Buffer, &readCount);
1549:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1550:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1551:../uvc.c      **** 			  value = Data1;
1552:../uvc.c      **** 
1553:../uvc.c      **** 			  switch(CtrlID)
1554:../uvc.c      **** 			  {
1555:../uvc.c      **** 		  	      case AutoExMCtlID1:
1556:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1557:../uvc.c      **** 
1558:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1559:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1560:../uvc.c      **** 				    getData = glEp0Buffer[0];
1561:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1562:../uvc.c      **** 		  		    switch (getData){
1563:../uvc.c      **** 						case 1:
1564:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1565:../uvc.c      **** 							break;
1566:../uvc.c      **** 						case 2:
1567:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1568:../uvc.c      **** 							dataIdx = 0;
1569:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1570:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1571:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1572:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1573:../uvc.c      **** 
1574:../uvc.c      **** 							break;
1575:../uvc.c      **** 						case 4:
1576:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1577:../uvc.c      **** 							break;
1578:../uvc.c      **** 						case 8:
1579:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1580:../uvc.c      **** 			  		    	dataIdx = 0;
1581:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1582:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1583:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1584:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1585:../uvc.c      **** 							break;
1586:../uvc.c      **** 		  		    }
1587:../uvc.c      **** #if 0
1588:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1589:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1590:../uvc.c      **** 						  dataIdx = 0;
1591:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1592:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1593:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1594:../uvc.c      **** 		  		    }
1595:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1596:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1597:../uvc.c      **** 		  		    }
1598:../uvc.c      **** #endif
1599:../uvc.c      **** 				    break;
1600:../uvc.c      **** 
1601:../uvc.c      **** 			  	  case ExTmACtlID3:
1602:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1603:../uvc.c      **** 
1604:../uvc.c      **** 					  value = (value << 8)|Data0;
1605:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1606:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1607:../uvc.c      **** 					  {
1608:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1609:../uvc.c      **** 						  {
1610:../uvc.c      **** 							if(value > ShutValueArry[i]){
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1612:../uvc.c      **** 							}else{
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1614:../uvc.c      **** 							}
1615:../uvc.c      **** 							  if(diff > diffRd){
1616:../uvc.c      **** 								  diff = diffRd;
1617:../uvc.c      **** 								  index = i;
1618:../uvc.c      **** 							  }
1619:../uvc.c      **** 						  }
1620:../uvc.c      **** 						  shutter = shutter+index;
1621:../uvc.c      **** 
1622:../uvc.c      **** 						  dataIdx = 0;
1623:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1624:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1625:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1626:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1627:../uvc.c      **** 
1628:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1629:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1630:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1631:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1632:../uvc.c      **** 					  }else{
1633:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1634:../uvc.c      **** 					  }
1635:../uvc.c      **** 					  getData = glEp0Buffer[0];
1636:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1637:../uvc.c      **** 					  break;
1638:../uvc.c      **** 			  	  case IriACtlID7:
1639:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1640:../uvc.c      **** 					  {
1641:../uvc.c      **** 							 dataIdx = 0;
1642:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1643:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1644:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1645:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1646:../uvc.c      **** 
1647:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1648:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1649:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1650:../uvc.c      **** 					  }else{
1651:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1652:../uvc.c      **** 					  }
1653:../uvc.c      **** 					  getData = glEp0Buffer[0];
1654:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1655:../uvc.c      **** 
1656:../uvc.c      **** 					  break;
1657:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1658:../uvc.c      **** 					  getData = glEp0Buffer[0];
1659:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1660:../uvc.c      **** #if 1
1661:../uvc.c      **** 					  dataIdx = 0;
1662:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1663:../uvc.c      **** 					  if(getData == 1)
1664:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1665:../uvc.c      **** 					  else if(getData == 0xff)
1666:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1667:../uvc.c      **** 					  else
1668:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1669:../uvc.c      **** 					  //dataIdx++;
1670:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1671:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1672:../uvc.c      **** #endif
1673:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1674:../uvc.c      **** 					  break;
1675:../uvc.c      **** 
1676:../uvc.c      **** 			  	  default:
1677:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1678:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1679:../uvc.c      **** 			  		 break;
1680:../uvc.c      **** 			  }
1681:../uvc.c      **** 			  break;
1682:../uvc.c      **** 		  default:
1683:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1684:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1685:../uvc.c      **** 			  break;
1686:../uvc.c      **** 		 }
1687:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1688:../uvc.c      **** 
1689:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1690:../uvc.c      **** }
1691:../uvc.c      **** 
1692:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1693:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1694:../uvc.c      **** {
1695:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1696:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1697:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1698:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1699:../uvc.c      **** 
1700:../uvc.c      ****     CtrlID = BrgtCtlID1;
1701:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1702:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1703:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1704:../uvc.c      ****     Data1 = Data0;
1705:../uvc.c      **** 
1706:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1707:../uvc.c      ****     if(Data1&0x80){
1708:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1709:../uvc.c      ****     }else{
1710:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1711:../uvc.c      ****     }
1712:../uvc.c      ****     Data0 = (Data0 << 2);
1713:../uvc.c      **** 
1714:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1715:../uvc.c      **** 
1716:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1717:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1718:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1719:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1720:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1721:../uvc.c      **** 
1722:../uvc.c      ****     CtrlID = ConsCtlID2;
1723:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1724:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1725:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1726:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1727:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1728:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1729:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1730:../uvc.c      **** 
1731:../uvc.c      ****     CtrlID = HueCtlID5;
1732:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1733:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1734:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1735:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1738:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1739:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1740:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1741:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1742:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1743:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1744:../uvc.c      **** 
1745:../uvc.c      ****     CtrlID = SaturCtlID6;
1746:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1747:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1748:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1749:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1750:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1751:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1752:../uvc.c      **** 
1753:../uvc.c      ****     CtrlID = ShapCtlID7;
1754:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1755:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1756:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1757:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1758:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1759:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1760:../uvc.c      **** 
1761:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
1762:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1763:../uvc.c      **** 	return;
1764:../uvc.c      **** }
1765:../uvc.c      **** 
1766:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1767:../uvc.c      **** void
1768:../uvc.c      **** CyFxUVCAddHeader (
1769:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1770:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1771:../uvc.c      ****         )
1772:../uvc.c      **** {
1773:../uvc.c      ****     /* Copy header to buffer */
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1775:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1776:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1777:../uvc.c      **** 
1778:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1779:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1780:../uvc.c      ****     {
1781:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1782:../uvc.c      ****     }
1783:../uvc.c      **** }
1784:../uvc.c      **** 
1785:../uvc.c      **** 
1786:../uvc.c      **** /* Application Error Handler */
1787:../uvc.c      **** void
1788:../uvc.c      **** CyFxAppErrorHandler (
1789:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1790:../uvc.c      ****         )
1791:../uvc.c      **** {
1792:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1793:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1794:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1795:../uvc.c      **** 
1796:../uvc.c      ****        This function can be modified to take additional error handling actions such
1797:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1798:../uvc.c      ****      */
1799:../uvc.c      ****     for (;;)
1800:../uvc.c      ****     {
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
1803:../uvc.c      ****     }
1804:../uvc.c      **** }
1805:../uvc.c      **** 
1806:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1807:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1808:../uvc.c      ****  */
1809:../uvc.c      **** static void
1810:../uvc.c      **** CyFxUVCApplnAbortHandler (
1811:../uvc.c      ****         void)
1812:../uvc.c      **** {
1813:../uvc.c      **** 	uint32_t flag;
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1815:../uvc.c      **** 	{
1816:../uvc.c      ****         /* Clear the Video Stream Request Event */
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1818:../uvc.c      **** 
1819:../uvc.c      ****         /* Set Video Stream Abort Event */
1820:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1821:../uvc.c      **** 	}
1822:../uvc.c      **** }
1823:../uvc.c      **** 
1824:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1825:../uvc.c      **** static void
1826:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1827:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1828:../uvc.c      ****         uint16_t             evdata  /* Event data */
1829:../uvc.c      ****         )
1830:../uvc.c      **** {
1831:../uvc.c      ****     switch (evtype)
1832:../uvc.c      ****     {
1833:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1834:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1835:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1836:../uvc.c      ****             gpif_initialized = 0;
1837:../uvc.c      ****             streamingStarted = CyFalse;
1838:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1839:../uvc.c      ****             break;
1840:../uvc.c      **** 
1841:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1842:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1843:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1844:../uvc.c      ****             gpif_initialized = 0;
1845:../uvc.c      ****             streamingStarted = CyFalse;
1846:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1847:../uvc.c      ****             break;
1848:../uvc.c      **** 
1849:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1850:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1851:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1852:../uvc.c      ****             gpif_initialized = 0;
1853:../uvc.c      ****             isUsbConnected = CyFalse;
1854:../uvc.c      ****             streamingStarted = CyFalse;
1855:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1856:../uvc.c      ****             break;
1857:../uvc.c      **** 
1858:../uvc.c      **** #ifdef BACKFLOW_DETECT
1859:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1860:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1861:../uvc.c      ****             break;
1862:../uvc.c      **** #endif
1863:../uvc.c      **** 
1864:../uvc.c      ****         default:
1865:../uvc.c      ****             break;
1866:../uvc.c      ****     }
1867:../uvc.c      **** }
1868:../uvc.c      **** 
1869:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1870:../uvc.c      **** static CyBool_t
1871:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1872:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1873:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1874:../uvc.c      ****         )
1875:../uvc.c      **** {
1876:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1877:../uvc.c      ****     uint32_t status;
1878:../uvc.c      **** 
1879:../uvc.c      ****     /* Obtain Request Type and Request */
1880:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1881:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1882:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1883:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1884:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* Check for UVC Class Requests */
1887:../uvc.c      ****     switch (bmReqType)
1888:../uvc.c      ****     {
1889:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1890:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1891:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1892:../uvc.c      ****             switch (wIndex & 0xFF)
1893:../uvc.c      ****             {
1894:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1895:../uvc.c      ****                     {
1896:../uvc.c      ****                         uvcHandleReq = CyTrue;
1897:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1898:../uvc.c      ****                                 CYU3P_EVENT_OR);
1899:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1900:../uvc.c      ****                         {
1901:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1902:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1903:../uvc.c      ****                         }
1904:../uvc.c      ****                     }
1905:../uvc.c      ****                     break;
1906:../uvc.c      **** 
1907:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1908:../uvc.c      ****                     {
1909:../uvc.c      ****                         uvcHandleReq = CyTrue;
1910:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1911:../uvc.c      ****                                 CYU3P_EVENT_OR);
1912:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1913:../uvc.c      ****                         {
1914:../uvc.c      ****                             /* Error handling */
1915:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1916:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1917:../uvc.c      ****                         }
1918:../uvc.c      ****                     }
1919:../uvc.c      ****                     break;
1920:../uvc.c      **** 
1921:../uvc.c      ****                 default:
1922:../uvc.c      ****                     break;
1923:../uvc.c      ****             }
1924:../uvc.c      ****             break;
1925:../uvc.c      **** 
1926:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1927:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1928:../uvc.c      ****             {
1929:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1930:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1931:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1932:../uvc.c      ****                 {
1933:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1934:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1935:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1936:../uvc.c      ****                     gpif_initialized = 0;
1937:../uvc.c      ****                     streamingStarted = CyFalse;
1938:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1939:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1940:../uvc.c      ****                     CyU3PBusyWait (100);
1941:../uvc.c      **** 
1942:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1943:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1944:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1945:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1946:../uvc.c      ****                     CyU3PBusyWait (100);
1947:../uvc.c      **** 
1948:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1949:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1950:../uvc.c      ****                     uvcHandleReq = CyTrue;
1951:../uvc.c      ****                     /* Complete Control request handshake */
1952:../uvc.c      ****                     CyU3PUsbAckSetup ();
1953:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1954:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1955:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1956:../uvc.c      **** 
1957:../uvc.c      ****                 }
1958:../uvc.c      ****             }
1959:../uvc.c      ****             break;
1960:../uvc.c      **** 
1961:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1962:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1963:../uvc.c      ****             {
1964:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1965:../uvc.c      ****                 {
1966:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1967:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1968:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1969:../uvc.c      ****                 	 * has started. */
1970:../uvc.c      ****                     if (streamingStarted == CyTrue)
1971:../uvc.c      ****                     {
1972:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1973:../uvc.c      **** 
1974:../uvc.c      ****                         /* Disable the GPIF state machine. */
1975:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1976:../uvc.c      ****                         gpif_initialized = 0;
1977:../uvc.c      ****                         streamingStarted = CyFalse;
1978:../uvc.c      **** 
1979:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1980:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1981:../uvc.c      ****                         CyU3PBusyWait (100);
1982:../uvc.c      **** 
1983:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1984:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1985:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1986:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1987:../uvc.c      ****                         CyU3PBusyWait (100);
1988:../uvc.c      **** 
1989:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1990:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1991:../uvc.c      **** 
1992:../uvc.c      ****                         uvcHandleReq = CyTrue;
1993:../uvc.c      ****                         /* Complete Control request handshake */
1994:../uvc.c      ****                         CyU3PUsbAckSetup ();
1995:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1996:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1997:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1998:../uvc.c      ****                     }
1999:../uvc.c      ****                     else
2000:../uvc.c      ****                     {
2001:../uvc.c      ****                         uvcHandleReq = CyTrue;
2002:../uvc.c      ****                         CyU3PUsbAckSetup ();
2003:../uvc.c      ****                     }
2004:../uvc.c      ****                 }
2005:../uvc.c      ****             }
2006:../uvc.c      ****             break;
2007:../uvc.c      **** 
2008:../uvc.c      ****         default:
2009:../uvc.c      ****             break;
2010:../uvc.c      ****     }
2011:../uvc.c      **** 
2012:../uvc.c      ****     /* Return status of request handling to the USB driver */
2013:../uvc.c      ****     return uvcHandleReq;
2014:../uvc.c      **** }
2015:../uvc.c      **** 
2016:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2017:../uvc.c      **** 
2018:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2019:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2020:../uvc.c      ****  */
2021:../uvc.c      **** void
2022:../uvc.c      **** CyFxUvcApplnDmaCallback (
2023:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2024:../uvc.c      ****         CyU3PDmaCbType_t      type,
2025:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2026:../uvc.c      ****         )
2027:../uvc.c      **** {
2028:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2029:../uvc.c      **** #if 1
2030:../uvc.c      ****     CyU3PReturnStatus_t status;
2031:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2032:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2033:../uvc.c      **** 
2034:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2035:../uvc.c      ****     {
2036:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2037:../uvc.c      ****             {
2038:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2039:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2040:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2041:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2042:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2043:../uvc.c      ****                 	stiflag = 0x03;
2044:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2045:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2046:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2047:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2048:../uvc.c      ****                 }
2049:../uvc.c      **** #endif
2050:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2051:../uvc.c      ****                 fb++;
2052:../uvc.c      ****             }
2053:../uvc.c      ****             else
2054:../uvc.c      ****             {
2055:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2056:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2057:../uvc.c      ****                 pb++;
2058:../uvc.c      ****                 pbc = input->buffer_p.count;
2059:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2060:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2061:../uvc.c      ****                 //lineCount = 0; //res test
2062:../uvc.c      **** #if 1   //remove the still flag clearing here
2063:../uvc.c      ****                 if(stiflag == 0x0F){
2064:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2065:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2066:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2067:../uvc.c      ****                 	stiflag = 0xAA;
2068:../uvc.c      ****                 }
2069:../uvc.c      **** #endif
2070:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2071:../uvc.c      ****             }
2072:../uvc.c      **** 
2073:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2074:../uvc.c      ****             prodCount++;
2075:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2076:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2077:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2078:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2079:../uvc.c      ****             {
2080:../uvc.c      ****                 prodCount--;
2081:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2082:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2083:../uvc.c      ****             }
2084:../uvc.c      ****     }
2085:../uvc.c      **** #endif
2086:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2087:../uvc.c      ****     {
2088:../uvc.c      ****         consCount++;
2089:../uvc.c      ****         streamingStarted = CyTrue;
2090:../uvc.c      ****     }
2091:../uvc.c      **** }
2092:../uvc.c      **** 
2093:../uvc.c      **** /*
2094:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2095:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2096:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2097:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2098:../uvc.c      ****  * to commit the buffer.
2099:../uvc.c      ****  */
2100:../uvc.c      **** static uint8_t
2101:../uvc.c      **** CyFxUvcAppCommitEOF (
2102:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2103:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2104:../uvc.c      ****         )
2105:../uvc.c      **** {
2106:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2107:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2108:../uvc.c      **** 
2109:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2110:../uvc.c      **** 
2111:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2112:../uvc.c      ****     {
2113:../uvc.c      ****         switch (stateId)
2114:../uvc.c      ****         {
2115:../uvc.c      **** 
2116:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2117:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2118:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2119:../uvc.c      ****                 break;
2120:../uvc.c      **** 
2121:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2122:../uvc.c      ****                 socket = 0;
2123:../uvc.c      ****                 break;
2124:../uvc.c      **** 
2125:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2126:../uvc.c      ****                 socket = 1;
2127:../uvc.c      ****                 break;
2128:../uvc.c      **** 
2129:../uvc.c      ****             default:
2130:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2131:../uvc.c      ****                 /* Unexpected current state. Return error. */
2132:../uvc.c      ****             	//lineCount++;
2133:../uvc.c      ****             	return 1;
2134:../uvc.c      ****         }
2135:../uvc.c      ****     }
2136:../uvc.c      **** 
2137:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2138:../uvc.c      ****     {
2139:../uvc.c      ****         switch (stateId)
2140:../uvc.c      ****         {
2141:../uvc.c      **** #ifndef CAM720
2142:../uvc.c      **** #ifdef GPIFIIM
2143:../uvc.c      ****             case 13:
2144:../uvc.c      ****             case 24:
2145:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2146:../uvc.c      ****                 break;
2147:../uvc.c      **** 
2148:../uvc.c      ****             case 8:
2149:../uvc.c      ****                 socket = 0;
2150:../uvc.c      ****                 break;
2151:../uvc.c      **** 
2152:../uvc.c      ****             case 20:
2153:../uvc.c      ****                 socket = 1;
2154:../uvc.c      ****                 break;
2155:../uvc.c      **** #else
2156:../uvc.c      ****             case 11:
2157:../uvc.c      ****             case 18:
2158:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2159:../uvc.c      ****                 break;
2160:../uvc.c      **** 
2161:../uvc.c      ****             case 8:
2162:../uvc.c      ****                 socket = 0;
2163:../uvc.c      ****                 break;
2164:../uvc.c      **** 
2165:../uvc.c      ****             case 15:
2166:../uvc.c      ****                 socket = 1;
2167:../uvc.c      ****                 break;
2168:../uvc.c      **** #endif
2169:../uvc.c      **** #else
2170:../uvc.c      ****             case 11:
2171:../uvc.c      ****             case 18:
2172:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2173:../uvc.c      ****                 break;
2174:../uvc.c      **** 
2175:../uvc.c      ****             case 8:
2176:../uvc.c      ****                 socket = 0;
2177:../uvc.c      ****                 break;
2178:../uvc.c      **** 
2179:../uvc.c      ****             case 15:
2180:../uvc.c      ****                 socket = 1;
2181:../uvc.c      ****                 break;
2182:../uvc.c      **** 
2183:../uvc.c      **** #endif
2184:../uvc.c      ****              default:
2185:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2186:../uvc.c      ****                 /* Unexpected current state. Return error. */
2187:../uvc.c      ****                return 1;
2188:../uvc.c      ****         }
2189:../uvc.c      ****     }
2190:../uvc.c      **** 
2191:../uvc.c      ****     if (socket != 0xFF)
2192:../uvc.c      ****     {
2193:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2194:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2195:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2196:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2197:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2198:../uvc.c      ****         {
2199:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2200:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2201:../uvc.c      ****         }
2202:../uvc.c      ****     }
2203:../uvc.c      **** 
2204:../uvc.c      ****     return 0;
2205:../uvc.c      **** }
2206:../uvc.c      **** 
2207:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2208:../uvc.c      **** void
2209:../uvc.c      **** CyFxGpifCB (
2210:../uvc.c      ****         CyU3PGpifEventType event,
2211:../uvc.c      ****         uint8_t currentState
2212:../uvc.c      ****         )
2213:../uvc.c      **** {
2214:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2215:../uvc.c      ****     {
2216:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2217:../uvc.c      ****     	           in the UVC implementation. */
2218:../uvc.c      ****     	//hitFV = CyTrue;
2219:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2220:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2221:../uvc.c      ****     }
2222:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2223:../uvc.c      **** }
2224:../uvc.c      **** 
2225:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2226:../uvc.c      **** static void
2227:../uvc.c      **** CyFxUVCApplnDebugInit (
2228:../uvc.c      ****         void)
2229:../uvc.c      **** {
2230:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2231:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2232:../uvc.c      **** 
2233:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2234:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2235:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2236:../uvc.c      ****     {
2237:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2238:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2239:../uvc.c      ****     }
2240:../uvc.c      **** 
2241:../uvc.c      ****     /* Set UART Configuration */
2242:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2243:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2244:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2245:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2246:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2247:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2248:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2249:../uvc.c      **** 
2250:../uvc.c      ****     /* Set the UART configuration */
2251:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2252:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2253:../uvc.c      ****     {
2254:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2255:../uvc.c      ****     }
2256:../uvc.c      **** 
2257:../uvc.c      ****     /* Set the UART transfer */
2258:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2259:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2260:../uvc.c      ****     {
2261:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2262:../uvc.c      ****     }
2263:../uvc.c      **** 
2264:../uvc.c      ****     /* Initialize the Debug logger module. */
2265:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2266:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2267:../uvc.c      ****     {
2268:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2269:../uvc.c      ****     }
2270:../uvc.c      **** 
2271:../uvc.c      ****     /* Disable log message headers. */
2272:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2273:../uvc.c      **** }
2274:../uvc.c      **** 
2275:../uvc.c      **** /* I2C initialization. */
2276:../uvc.c      **** static void
2277:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2278:../uvc.c      **** {
2279:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2280:../uvc.c      ****     CyU3PReturnStatus_t status;
2281:../uvc.c      **** 
2282:../uvc.c      ****     status = CyU3PI2cInit ();
2283:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2284:../uvc.c      ****     {
2285:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2286:../uvc.c      ****         CyFxAppErrorHandler (status);
2287:../uvc.c      ****     }
2288:../uvc.c      **** 
2289:../uvc.c      ****     /*  Set I2C Configuration */
2290:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2291:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2292:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2293:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2294:../uvc.c      **** 
2295:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2296:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2297:../uvc.c      ****     {
2298:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2299:../uvc.c      ****         CyFxAppErrorHandler (status);
2300:../uvc.c      ****     }
2301:../uvc.c      **** }
2302:../uvc.c      **** 
2303:../uvc.c      **** #ifdef BACKFLOW_DETECT
2304:../uvc.c      **** static void CyFxUvcAppPibCallback (
2305:../uvc.c      ****         CyU3PPibIntrType cbType,
2306:../uvc.c      ****         uint16_t cbArg)
2307:../uvc.c      **** {
2308:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2309:../uvc.c      ****     {
2310:../uvc.c      ****         if (!back_flow_detected)
2311:../uvc.c      ****         {
2312:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2313:../uvc.c      ****             back_flow_detected = 1;
2314:../uvc.c      ****         }
2315:../uvc.c      ****     }
2316:../uvc.c      **** }
2317:../uvc.c      **** #endif
2318:../uvc.c      **** 
2319:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2320:../uvc.c      **** static void
2321:../uvc.c      **** CyFxUvcAppDebugCallback (
2322:../uvc.c      ****         CyU3PDmaChannel   *handle,
2323:../uvc.c      ****         CyU3PDmaCbType_t   type,
2324:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2325:../uvc.c      **** {
2326:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2327:../uvc.c      ****     {
2328:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2329:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2330:../uvc.c      ****     }
2331:../uvc.c      **** }
2332:../uvc.c      **** #endif
2333:../uvc.c      **** 
2334:../uvc.c      **** #if 0
2335:../uvc.c      **** static void CyFxAppIntEpCb(
2336:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2337:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2338:../uvc.c      **** 		uint8_t  ebNum)
2339:../uvc.c      **** 		{
2340:../uvc.c      **** 			//CyBool_t value;
2341:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2342:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2343:../uvc.c      **** 
2344:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2345:../uvc.c      **** 		}
2346:../uvc.c      **** #endif
2347:../uvc.c      **** 
2348:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2349:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2350:../uvc.c      ****    configures the DMA module for the UVC Application */
2351:../uvc.c      **** static void
2352:../uvc.c      **** CyFxUVCApplnInit (void)
2353:../uvc.c      **** {
2354:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2355:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2356:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2357:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2358:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2359:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2360:../uvc.c      **** 
2361:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2362:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2363:../uvc.c      **** 
2364:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2365:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2366:../uvc.c      **** #endif
2367:../uvc.c      **** 
2368:../uvc.c      ****     /* Create UVC event group */
2369:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2370:../uvc.c      ****     if (apiRetStatus != 0)
2371:../uvc.c      ****     {
2372:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2373:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2374:../uvc.c      ****     }
2375:../uvc.c      **** 
2376:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2377:../uvc.c      ****     CyFxUvcAppPTZInit ();
2378:../uvc.c      **** #endif
2379:../uvc.c      **** 
2380:../uvc.c      ****     isUsbConnected = CyFalse;
2381:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* Init the GPIO module */
2384:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2385:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2386:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2387:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2388:../uvc.c      ****     gpioClock.halfDiv    = 0;
2389:../uvc.c      **** 
2390:../uvc.c      ****     /* Initialize Gpio interface */
2391:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2392:../uvc.c      ****     if (apiRetStatus != 0)
2393:../uvc.c      ****     {
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2395:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2396:../uvc.c      ****     }
2397:../uvc.c      **** 
2398:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2399:../uvc.c      ****      * must use GpioOverride to configure it */
2400:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2401:../uvc.c      ****     if (apiRetStatus != 0)
2402:../uvc.c      ****     {
2403:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2404:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2405:../uvc.c      ****     }
2406:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2407:../uvc.c      ****     if (apiRetStatus != 0)
2408:../uvc.c      ****     {
2409:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2410:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2411:../uvc.c      ****     }
2412:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2413:../uvc.c      ****     if (apiRetStatus != 0)
2414:../uvc.c      ****     {
2415:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2416:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2417:../uvc.c      ****     }
2418:../uvc.c      **** 
2419:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2420:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2421:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2422:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2423:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2424:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2425:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2426:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2427:../uvc.c      ****     {
2428:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2429:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2430:../uvc.c      ****     }
2431:../uvc.c      **** 
2432:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2433:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2434:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2435:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2436:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2437:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2438:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2439:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2440:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2441:../uvc.c      ****     {
2442:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2443:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2444:../uvc.c      ****     }
2445:../uvc.c      **** 
2446:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2447:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2448:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2449:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2450:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2451:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2452:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2453:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2454:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2455:../uvc.c      ****     {
2456:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2457:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2458:../uvc.c      ****     }
2459:../uvc.c      **** 
2460:../uvc.c      ****     /* Initialize the P-port. */
2461:../uvc.c      ****     pibclock.clkDiv      = 2;
2462:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2463:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2464:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2465:../uvc.c      **** 
2466:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2467:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2468:../uvc.c      ****     {
2469:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2470:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2471:../uvc.c      ****     }
2472:../uvc.c      **** 
2473:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2474:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2475:../uvc.c      **** 
2476:../uvc.c      **** #ifdef BACKFLOW_DETECT
2477:../uvc.c      ****     back_flow_detected = 0;
2478:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2479:../uvc.c      **** #endif
2480:../uvc.c      **** 
2481:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2482:../uvc.c      ****     SensorReset ();
2483:../uvc.c      ****     CyU3PThreadSleep(5000);
2484:../uvc.c      ****     //SensorInit ();
2485:../uvc.c      **** 
2486:../uvc.c      ****     /* USB initialization. */
2487:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2488:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2489:../uvc.c      ****     {
2490:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2491:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2492:../uvc.c      ****     }
2493:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2494:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2495:../uvc.c      **** 
2496:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2497:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2498:../uvc.c      **** 
2499:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2500:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2501:../uvc.c      **** 
2502:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2503:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2504:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2505:../uvc.c      **** 
2506:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2507:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2508:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2509:../uvc.c      **** 
2510:../uvc.c      ****     /* Configuration descriptors. */
2511:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2512:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2513:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2514:../uvc.c      **** 
2515:../uvc.c      ****     /* String Descriptors */
2516:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2517:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2518:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2519:../uvc.c      **** 
2520:../uvc.c      ****     /* Configure the status interrupt endpoint.
2521:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2522:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2523:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2524:../uvc.c      ****      */
2525:../uvc.c      ****     endPointConfig.enable   = 1;
2526:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2527:../uvc.c      ****     endPointConfig.pcktSize = 64;
2528:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2529:../uvc.c      ****     endPointConfig.streams  = 0;
2530:../uvc.c      ****     endPointConfig.burstLen = 1;
2531:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2532:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2533:../uvc.c      ****     {
2534:../uvc.c      ****         /* Error Handling */
2535:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2536:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2537:../uvc.c      ****     }
2538:../uvc.c      **** 
2539:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2540:../uvc.c      ****     dmaInterConfig.size           = 1024;
2541:../uvc.c      ****     dmaInterConfig.count          = 1;
2542:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2543:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2544:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2545:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2546:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2547:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2548:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2549:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2550:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2551:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2552:../uvc.c      ****             &dmaInterConfig);
2553:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2554:../uvc.c      ****     {
2555:../uvc.c      ****         /* Error handling */
2556:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2557:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2558:../uvc.c      ****     }
2559:../uvc.c      **** 
2560:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2561:../uvc.c      ****     if (glInterStaBuffer == 0)
2562:../uvc.c      ****     {
2563:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2564:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2565:../uvc.c      ****     }
2566:../uvc.c      **** 
2567:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2568:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2569:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2570:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2571:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2572:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2573:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2574:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2575:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2576:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2577:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2578:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2579:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2580:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2581:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2582:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2583:../uvc.c      ****             &dmaMultiConfig);
2584:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2585:../uvc.c      ****     {
2586:../uvc.c      ****         /* Error handling */
2587:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2588:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2589:../uvc.c      ****     }
2590:../uvc.c      **** 
2591:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2592:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2593:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2594:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2595:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2596:../uvc.c      ****      */
2597:../uvc.c      **** 
2598:../uvc.c      ****     endPointConfig.enable   = 1;
2599:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2600:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2601:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2602:../uvc.c      ****     endPointConfig.streams  = 0;
2603:../uvc.c      ****     endPointConfig.burstLen = 1;
2604:../uvc.c      **** 
2605:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2606:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2607:../uvc.c      ****     {
2608:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2609:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2610:../uvc.c      ****     }
2611:../uvc.c      **** 
2612:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2613:../uvc.c      **** 
2614:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2615:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2616:../uvc.c      ****     {
2617:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2618:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2619:../uvc.c      ****     }
2620:../uvc.c      **** 
2621:../uvc.c      ****     channelConfig.size           = 1024;
2622:../uvc.c      ****     channelConfig.count          = 1;
2623:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2624:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2625:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2626:../uvc.c      ****     channelConfig.prodHeader     = 0;
2627:../uvc.c      ****     channelConfig.prodFooter     = 0;
2628:../uvc.c      ****     channelConfig.consHeader     = 0;
2629:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2630:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2631:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2632:../uvc.c      **** 
2633:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2634:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2635:../uvc.c      ****     {
2636:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2637:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2638:../uvc.c      ****     }
2639:../uvc.c      **** 
2640:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2641:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2642:../uvc.c      ****     {
2643:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2644:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2645:../uvc.c      ****     }
2646:../uvc.c      **** 
2647:../uvc.c      ****     channelConfig.size           = 1024;
2648:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2649:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2650:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2651:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2652:../uvc.c      ****     channelConfig.prodHeader     = 0;
2653:../uvc.c      ****     channelConfig.prodFooter     = 0;
2654:../uvc.c      ****     channelConfig.consHeader     = 0;
2655:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2656:../uvc.c      ****     channelConfig.notification   = 0;
2657:../uvc.c      ****     channelConfig.cb             = 0;
2658:../uvc.c      **** 
2659:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2660:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2661:../uvc.c      ****     {
2662:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2663:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2664:../uvc.c      ****     }
2665:../uvc.c      **** 
2666:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2667:../uvc.c      ****     if (glDebugRspBuffer == 0)
2668:../uvc.c      ****     {
2669:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2670:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2671:../uvc.c      ****     }
2672:../uvc.c      **** #endif
2673:../uvc.c      **** 
2674:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2675:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2676:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2677:../uvc.c      ****     {
2678:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2679:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2680:../uvc.c      ****     }
2681:../uvc.c      **** 
2682:../uvc.c      ****     CyU3PBusyWait(100);
2683:../uvc.c      **** 
2684:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2685:../uvc.c      **** 
2686:../uvc.c      ****     endPointConfig.enable   = 1;
2687:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2688:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2689:../uvc.c      ****     {
2690:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2691:../uvc.c      ****     	endPointConfig.burstLen = 16;
2692:../uvc.c      ****     }
2693:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2694:../uvc.c      ****     {
2695:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2696:../uvc.c      ****     	endPointConfig.burstLen = 1;
2697:../uvc.c      ****     }
2698:../uvc.c      ****     endPointConfig.streams  = 0;
2699:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2701:../uvc.c      ****     {
2702:../uvc.c      ****         /* Error Handling */
2703:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2704:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2705:../uvc.c      ****     }
2706:../uvc.c      **** #if 0    //for still image method 3 using
2707:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2708:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2709:../uvc.c      ****     {
2710:../uvc.c      ****         /* Error Handling */
2711:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2712:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2713:../uvc.c      ****     }
2714:../uvc.c      **** #endif
2715:../uvc.c      **** 
2716:../uvc.c      **** }
2717:../uvc.c      **** 
2718:../uvc.c      **** /*
2719:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2720:../uvc.c      ****  * streaming session is started.
2721:../uvc.c      ****  */
2722:../uvc.c      **** static void
2723:../uvc.c      **** CyFxUvcAppGpifInit (
2724:../uvc.c      ****         void)
2725:../uvc.c      **** {
2726:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2727:../uvc.c      **** 
2728:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2729:../uvc.c      ****     {
2730:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2731:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2732:../uvc.c      ****     }
2733:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2734:../uvc.c      ****     {
2735:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2736:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2737:../uvc.c      ****     }
2738:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2739:../uvc.c      ****     {
2740:../uvc.c      ****         /* Error Handling */
2741:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2742:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2743:../uvc.c      ****     }
2744:../uvc.c      **** 
2745:../uvc.c      ****     /* Start the state machine from the designated start state. */
2746:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2747:../uvc.c      ****     {
2748:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2749:../uvc.c      ****     }
2750:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2751:../uvc.c      ****     {
2752:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2753:../uvc.c      ****     }
2754:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2755:../uvc.c      ****     {
2756:../uvc.c      ****         /* Error Handling */
2757:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2758:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2759:../uvc.c      ****     }
2760:../uvc.c      **** }
2761:../uvc.c      **** 
2762:../uvc.c      **** /*
2763:../uvc.c      ****  * Entry function for the UVC Application Thread
2764:../uvc.c      ****  */
2765:../uvc.c      **** 
2766:../uvc.c      **** uint32_t posTick;
2767:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2768:../uvc.c      **** 
2769:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2770:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2771:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2772:../uvc.c      **** }
2773:../uvc.c      **** 
2774:../uvc.c      **** 
2775:../uvc.c      **** void
2776:../uvc.c      **** UVCAppThread_Entry (
2777:../uvc.c      ****         uint32_t input)
2778:../uvc.c      **** {
2779:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2780:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2781:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2782:../uvc.c      ****     uint8_t i = 0;
2783:../uvc.c      ****     uint32_t flag;
2784:../uvc.c      ****     uint32_t prinflag = 0;
2785:../uvc.c      **** static uint8_t IMcount = 0;
2786:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2787:../uvc.c      ****     uint32_t frameCnt = 0;
2788:../uvc.c      **** #endif
2789:../uvc.c      ****     /* Initialize the Uart Debug Module */
2790:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2791:../uvc.c      **** 
2792:../uvc.c      ****     /* Initialize the I2C interface */
2793:../uvc.c      **** 	while (i++ < 6){
2794:../uvc.c      **** 		CyU3PThreadSleep(500);
2795:../uvc.c      **** 	}
2796:../uvc.c      **** 
2797:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2798:../uvc.c      **** 
2799:../uvc.c      ****     /* Initialize the UVC Application */
2800:../uvc.c      ****     CyFxUVCApplnInit ();
2801:../uvc.c      ****     /*
2802:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2803:../uvc.c      **** 
2804:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2805:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2806:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2807:../uvc.c      **** 
2808:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2809:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2810:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2811:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2812:../uvc.c      **** 
2813:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2814:../uvc.c      ****        of handling the abort request.
2815:../uvc.c      ****      */
2816:../uvc.c      **** 
2817:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
2818:../uvc.c      ****     //CyU3PThreadSleep(1000);
2819:../uvc.c      **** 
2820:../uvc.c      ****     for (;;)
2821:../uvc.c      ****     {
2822:../uvc.c      ****         /* Waiting for the Video Stream Event */
2823:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2824:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2825:../uvc.c      ****         {
2826:../uvc.c      **** #if 0 //test for new firmware no video bring up
2827:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2828:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2829:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2830:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2831:../uvc.c      ****             {
2832:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2833:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2834:../uvc.c      ****                 {
2835:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2836:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2837:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2838:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2839:../uvc.c      **** #endif
2840:../uvc.c      **** #endif
2841:../uvc.c      ****                     }
2842:../uvc.c      ****                 else
2843:../uvc.c      ****                 {
2844:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2845:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2846:../uvc.c      **** #ifdef USB_LOWRES_IMG
2847:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2848:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2849:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2850:../uvc.c      **** #endif
2851:../uvc.c      **** #endif
2852:../uvc.c      ****                 }
2853:../uvc.c      **** 
2854:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2855:../uvc.c      ****                 prodCount++;
2856:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2857:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2858:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2859:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2860:../uvc.c      ****                 {
2861:../uvc.c      ****                     prodCount--;
2862:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2863:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2864:../uvc.c      ****                 }
2865:../uvc.c      ****             }
2866:../uvc.c      **** #endif
2867:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2868:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2869:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2870:../uvc.c      ****             {
2871:../uvc.c      ****             	if(0&&(prinflag == 0)){
2872:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
2873:../uvc.c      ****             		prinflag = 1;
2874:../uvc.c      ****             	}
2875:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2876:../uvc.c      ****             	fb=0;
2877:../uvc.c      ****             	pb=0;
2878:../uvc.c      ****             	pbc=0;
2879:../uvc.c      ****                 prodCount = 0;
2880:../uvc.c      ****                 consCount = 0;
2881:../uvc.c      ****                 hitFV     = CyFalse;
2882:../uvc.c      **** 
2883:../uvc.c      **** #ifdef BACKFLOW_DETECT
2884:../uvc.c      ****                 back_flow_detected = 0;
2885:../uvc.c      **** #endif
2886:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2887:../uvc.c      ****                 frameCnt++;
2888:../uvc.c      **** #endif
2889:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2890:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2891:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2892:../uvc.c      ****                 //}
2893:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2894:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2895:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2896:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
2897:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
2898:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
2899:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
2900:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
2901:../uvc.c      ****                      	//CyU3PThreadSleep(100);
2902:../uvc.c      ****                 		stiflag = 0xFF;
2903:../uvc.c      ****                 		IMcount = 0;
2904:../uvc.c      ****                 	}
2905:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
2906:../uvc.c      **** 
2907:../uvc.c      ****                  		if(IMcount++ >= 0x3){
2908:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
2909:../uvc.c      ****                 		stiflag = 0x0F;
2910:../uvc.c      ****                 		IMcount = 0;
2911:../uvc.c      ****                 		}
2912:../uvc.c      ****                  		/*if(IMcount > 0x4){
2913:../uvc.c      ****                 			stiflag = 0x0F;
2914:../uvc.c      ****                 			IMcount = 0;
2915:../uvc.c      ****                 		}*/
2916:../uvc.c      **** 
2917:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
2918:../uvc.c      ****                     //CyU3PThreadSleep(400);
2919:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2920:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2921:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2922:../uvc.c      **** 
2923:../uvc.c      ****                 	if(IMcount++ >= 0x3)
2924:../uvc.c      ****                 	{
2925:../uvc.c      ****                     switch (setRes)
2926:../uvc.c      ****                      {
2927:../uvc.c      ****                  	case 1: //1944
2928:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
2929:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2930:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
2931:../uvc.c      ****                  		break;
2932:../uvc.c      ****                  	case 2: //1080
2933:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
2934:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2935:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
2936:../uvc.c      ****                  		break;
2937:../uvc.c      ****                  	case 3: //720
2938:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
2939:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2940:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
2941:../uvc.c      ****                  		break;
2942:../uvc.c      ****                  	case 4: //VGA
2943:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
2944:../uvc.c      ****                  		//CyU3PThreadSleep(100);
2945:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
2946:../uvc.c      ****                  		break;
2947:../uvc.c      ****                  	default:
2948:../uvc.c      ****                  		break;
2949:../uvc.c      ****                      }
2950:../uvc.c      ****                     IMcount = 0;
2951:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2952:../uvc.c      ****                 	stiflag = 0x0;
2953:../uvc.c      ****                 	}
2954:../uvc.c      ****                 }
2955:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
2956:../uvc.c      ****                 /* Reset the DMA channel. */
2957:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2958:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2959:../uvc.c      ****                 {
2960:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2961:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2962:../uvc.c      ****                 }
2963:../uvc.c      **** 
2964:../uvc.c      ****                 /* Start Channel Immediately */
2965:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2966:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2967:../uvc.c      ****                 {
2968:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2969:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2970:../uvc.c      ****                 }
2971:../uvc.c      **** 
2972:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2973:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2974:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2975:../uvc.c      ****                 }
2976:../uvc.c      ****         }
2977:../uvc.c      ****         else
2978:../uvc.c      ****         {
2979:../uvc.c      ****             /* If we have a stream abort request pending. */
2980:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2981:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2982:../uvc.c      ****             {
2983:../uvc.c      ****                 hitFV     = CyFalse;
2984:../uvc.c      ****                 prodCount = 0;
2985:../uvc.c      ****                 consCount = 0;
2986:../uvc.c      ****                 if(0&&(prinflag == 0)){
2987:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
2988:../uvc.c      ****                 	prinflag = 1;
2989:../uvc.c      ****                 }
2990:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2991:../uvc.c      ****                 fb=0;
2992:../uvc.c      ****                 pb=0;
2993:../uvc.c      ****                 pbc=0;
2994:../uvc.c      **** 
2995:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2996:../uvc.c      ****                 {
2997:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2998:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2999:../uvc.c      ****                     {
3000:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3001:../uvc.c      ****                     }
3002:../uvc.c      **** 
3003:../uvc.c      ****                     /* Flush the Endpoint memory */
3004:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3005:../uvc.c      ****                 }
3006:../uvc.c      **** 
3007:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3008:../uvc.c      ****             }
3009:../uvc.c      ****             else
3010:../uvc.c      ****             {
3011:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3012:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3013:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3014:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3015:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3016:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3017:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3018:../uvc.c      ****                 {
3019:../uvc.c      ****                     /* Error handling */
3020:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3021:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3022:../uvc.c      ****                 }
3023:../uvc.c      **** 
3024:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3025:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3026:../uvc.c      ****                 {
3027:../uvc.c      **** #if 0
3028:../uvc.c      ****                 	//for start up of the AF Lens
3029:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3030:../uvc.c      ****                     CyU3PThreadSleep(500);
3031:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3032:../uvc.c      ****                     CyU3PThreadSleep(500);
3033:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3034:../uvc.c      ****                    	CyU3PThreadSleep(300);
3035:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3036:../uvc.c      ****                     CyU3PThreadSleep(500);
3037:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3038:../uvc.c      ****                     CyU3PThreadSleep(500);
3039:../uvc.c      **** #endif
3040:../uvc.c      **** #if 0
3041:../uvc.c      ****                     switch (setRes)
3042:../uvc.c      ****                     {
3043:../uvc.c      ****                     	case 1: //1944
3044:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3045:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3046:../uvc.c      ****                     		break;
3047:../uvc.c      ****                     	case 2: //1080
3048:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3049:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3050:../uvc.c      ****                     		break;
3051:../uvc.c      ****                     	case 3: //720
3052:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3053:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3054:../uvc.c      ****                     		break;
3055:../uvc.c      ****                     	default:
3056:../uvc.c      ****                     		break;
3057:../uvc.c      ****                     }
3058:../uvc.c      **** #endif
3059:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3060:../uvc.c      **** 
3061:../uvc.c      ****                     gpif_initialized = CyTrue;
3062:../uvc.c      ****                     CyU3PThreadSleep(200);
3063:../uvc.c      ****                     
3064:../uvc.c      ****                 }
3065:../uvc.c      ****                 else
3066:../uvc.c      ****                 {
3067:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3068:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3069:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3070:../uvc.c      ****                 }
3071:../uvc.c      ****             }
3072:../uvc.c      ****         }
3073:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3074:../uvc.c      **** 
3075:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3076:../uvc.c      ****         CyU3PThreadRelinquish ();
3077:../uvc.c      ****     }
3078:../uvc.c      **** }
3079:../uvc.c      **** 
3080:../uvc.c      **** /*
3081:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3082:../uvc.c      ****  */
3083:../uvc.c      **** 
3084:../uvc.c      **** static void
3085:../uvc.c      **** UVCHandleProcessingUnitRqts (
3086:../uvc.c      ****         void)
3087:../uvc.c      **** {
3088:../uvc.c      ****     uint8_t CtrlAdd;
3089:../uvc.c      **** #ifdef DbgInfo
3090:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3091:../uvc.c      **** #endif
3092:../uvc.c      ****     switch (wValue)
3093:../uvc.c      ****     {
3094:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3095:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3096:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3097:../uvc.c      ****     		break;
3098:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3099:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3100:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3101:../uvc.c      ****     		break;
3102:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3103:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3104:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3105:../uvc.c      **** 			break;
3106:../uvc.c      **** 
3107:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3108:../uvc.c      **** 
3109:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3110:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3111:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3112:../uvc.c      ****       		break;
3113:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3114:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3115:../uvc.c      ****      		ControlHandle(HueCtlID5);
3116:../uvc.c      ****      		break;
3117:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3118:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3119:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3120:../uvc.c      ****           		break;
3121:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3122:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3123:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3124:../uvc.c      ****           		break;
3125:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3126:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3127:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3128:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3129:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3130:../uvc.c      ****     		break;
3131:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3132:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3133:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3134:../uvc.c      ****     		break;
3135:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3136:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3137:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3138:../uvc.c      ****     		break;
3139:../uvc.c      **** 
3140:../uvc.c      ****         default:
3141:../uvc.c      ****             /*
3142:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3143:../uvc.c      ****              * other controls.
3144:../uvc.c      ****              */
3145:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3146:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3147:../uvc.c      ****             break;
3148:../uvc.c      ****     }
3149:../uvc.c      **** }
3150:../uvc.c      **** 
3151:../uvc.c      **** /*
3152:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3153:../uvc.c      ****  */
3154:../uvc.c      **** static void
3155:../uvc.c      **** UVCHandleCameraTerminalRqts (
3156:../uvc.c      ****         void)
3157:../uvc.c      **** {
3158:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3159:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3160:../uvc.c      ****     uint16_t readCount;
3161:../uvc.c      ****     uint16_t zoomVal;
3162:../uvc.c      ****     int32_t  panVal, tiltVal;
3163:../uvc.c      ****     CyBool_t sendData = CyFalse;
3164:../uvc.c      **** #endif
3165:../uvc.c      ****     uint8_t CtrlAdd;
3166:../uvc.c      **** 
3167:../uvc.c      ****     switch (wValue)
3168:../uvc.c      ****     {
3169:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3170:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3171:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3172:../uvc.c      ****     		break;
3173:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3174:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3175:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3176:../uvc.c      ****     		break;
3177:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3178:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3179:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3180:../uvc.c      **** 			break;
3181:../uvc.c      **** 
3182:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3183:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3184:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3185:../uvc.c      **** 			break;
3186:../uvc.c      **** 
3187:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3188:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3189:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3190:../uvc.c      ****       		break;
3191:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3192:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3193:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3194:../uvc.c      ****      		break;
3195:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3196:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3197:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3198:../uvc.c      ****           		break;
3199:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3200:../uvc.c      ****           		break;
3201:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3202:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3203:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3204:../uvc.c      ****      		break;
3205:../uvc.c      **** 
3206:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3207:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3208:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3209:../uvc.c      ****     		break;
3210:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3211:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3212:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3213:../uvc.c      ****     		break;
3214:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3215:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3216:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3217:../uvc.c      ****     		break;
3218:../uvc.c      **** 
3219:../uvc.c      ****         default:
3220:../uvc.c      ****             /*
3221:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3222:../uvc.c      ****              * other controls.
3223:../uvc.c      ****              */
3224:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3225:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3226:../uvc.c      ****             break;
3227:../uvc.c      ****     }
3228:../uvc.c      **** 
3229:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3230:../uvc.c      ****     switch (wValue)
3231:../uvc.c      ****     {
3232:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3233:../uvc.c      ****             switch (bRequest)
3234:../uvc.c      ****             {
3235:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3236:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3237:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3238:../uvc.c      ****                     break;
3239:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3240:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3241:../uvc.c      ****                     sendData = CyTrue;
3242:../uvc.c      ****                     break;
3243:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3244:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3245:../uvc.c      ****                     sendData = CyTrue;
3246:../uvc.c      ****                     break;
3247:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3248:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3249:../uvc.c      ****                     sendData = CyTrue;
3250:../uvc.c      ****                     break;
3251:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3252:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3253:../uvc.c      ****                     sendData = CyTrue;
3254:../uvc.c      ****                     break;
3255:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3256:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3257:../uvc.c      ****                     sendData = CyTrue;
3258:../uvc.c      ****                     break;
3259:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3260:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3261:../uvc.c      ****                             glEp0Buffer, &readCount);
3262:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3263:../uvc.c      ****                     {
3264:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3265:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3266:../uvc.c      ****                     }
3267:../uvc.c      ****                     break;
3268:../uvc.c      ****                 default:
3269:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3270:../uvc.c      ****                     break;
3271:../uvc.c      ****             }
3272:../uvc.c      **** 
3273:../uvc.c      ****             if (sendData)
3274:../uvc.c      ****             {
3275:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3276:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3277:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3278:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3279:../uvc.c      ****             }
3280:../uvc.c      ****             break;
3281:../uvc.c      **** 
3282:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3283:../uvc.c      ****             switch (bRequest)
3284:../uvc.c      ****             {
3285:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3286:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3287:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3288:../uvc.c      ****                     break;
3289:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3290:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3291:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3292:../uvc.c      ****                     sendData = CyTrue;
3293:../uvc.c      ****                     break;
3294:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3295:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3296:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3297:../uvc.c      ****                     sendData = CyTrue;
3298:../uvc.c      ****                     break;
3299:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3300:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3301:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3302:../uvc.c      ****                     sendData = CyTrue;
3303:../uvc.c      ****                     break;
3304:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3305:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3306:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3307:../uvc.c      ****                     sendData = CyTrue;
3308:../uvc.c      ****                     break;
3309:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3310:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3311:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3312:../uvc.c      ****                     sendData = CyTrue;
3313:../uvc.c      ****                     break;
3314:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3315:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3316:../uvc.c      ****                             glEp0Buffer, &readCount);
3317:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3318:../uvc.c      ****                     {
3319:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3320:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3321:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3322:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3323:../uvc.c      **** 
3324:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3325:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3326:../uvc.c      ****                     }
3327:../uvc.c      ****                     break;
3328:../uvc.c      ****                 default:
3329:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3330:../uvc.c      ****                     break;
3331:../uvc.c      ****             }
3332:../uvc.c      **** 
3333:../uvc.c      ****             if (sendData)
3334:../uvc.c      ****             {
3335:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3336:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3337:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3338:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3339:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3340:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3341:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3342:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3343:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3344:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3345:../uvc.c      ****             }
3346:../uvc.c      ****             break;
3347:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3348:../uvc.c      ****         default:
3349:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3350:../uvc.c      ****             break;
3351:../uvc.c      ****     }
3352:../uvc.c      **** #endif
3353:../uvc.c      **** }
3354:../uvc.c      **** 
3355:../uvc.c      **** /*
3356:../uvc.c      ****  * Handler for UVC Interface control requests.
3357:../uvc.c      ****  */
3358:../uvc.c      **** static void
3359:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3360:../uvc.c      ****         void)
3361:../uvc.c      **** {
3362:../uvc.c      **** 
3363:../uvc.c      ****     switch (wValue)
3364:../uvc.c      ****     {
3365:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3366:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3367:../uvc.c      ****     		break;
3368:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3369:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3370:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3371:../uvc.c      ****     		break;
3372:../uvc.c      ****     	default:
3373:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3374:../uvc.c      ****      		break;
3375:../uvc.c      ****     }
3376:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3377:../uvc.c      **** 
3378:../uvc.c      **** }
3379:../uvc.c      **** 
3380:../uvc.c      **** /*
3381:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3382:../uvc.c      ****  */
3383:../uvc.c      **** static void
3384:../uvc.c      **** UVCHandleExtensionUnitRqts (
3385:../uvc.c      ****         void)
3386:../uvc.c      **** {
3387:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3388:../uvc.c      **** 
3389:../uvc.c      **** #ifdef DbgInfo
3390:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3391:../uvc.c      **** #endif
3392:../uvc.c      ****     switch (wValue)
3393:../uvc.c      ****     {
3394:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3395:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3396:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3397:../uvc.c      ****     		break;
3398:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3399:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3400:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3401:../uvc.c      ****     		break;
3402:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3403:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3404:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3405:../uvc.c      ****      		break;
3406:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3407:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3408:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3409:../uvc.c      ****     		break;
3410:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3411:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3412:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3413:../uvc.c      ****     		break;
3414:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3415:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3416:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3417:../uvc.c      ****      		break;
3418:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3419:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3420:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3421:../uvc.c      ****     		break;
3422:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3423:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3424:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3425:../uvc.c      ****     		break;
3426:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3427:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3428:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3429:../uvc.c      ****      		break;
3430:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3431:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3432:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3433:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3434:../uvc.c      ****     		}else/* no support for 1080p camera */
3435:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3436:../uvc.c      ****     		break;
3437:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3438:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3439:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3440:../uvc.c      ****     		break;
3441:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3442:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3443:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3444:../uvc.c      ****     		break;
3445:../uvc.c      **** 
3446:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3447:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3448:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3449:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3450:../uvc.c      ****     		break;
3451:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3452:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3453:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3454:../uvc.c      ****     		//break;
3455:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3456:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3457:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3458:../uvc.c      ****     		break;
3459:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3460:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3461:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3462:../uvc.c      ****     		break;
3463:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3464:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3465:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3466:../uvc.c      ****     		break;
3467:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3468:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3469:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3470:../uvc.c      ****     		break;
3471:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3472:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3473:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3474:../uvc.c      ****     		break;
3475:../uvc.c      ****    	default:
3476:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3477:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3478:../uvc.c      ****     		break;
3479:../uvc.c      ****     }
3480:../uvc.c      **** 
3481:../uvc.c      **** }
3482:../uvc.c      **** 
3483:../uvc.c      **** /*
3484:../uvc.c      ****  * Handler for the video streaming control requests.
3485:../uvc.c      ****  */
3486:../uvc.c      **** static void
3487:../uvc.c      **** UVCHandleVideoStreamingRqts (
3488:../uvc.c      ****         void)
3489:../uvc.c      **** {
3490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3491:../uvc.c      ****     uint16_t readCount;
3492:../uvc.c      **** 
3493:../uvc.c      ****     switch (wValue)
3494:../uvc.c      ****     {
3495:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3496:../uvc.c      ****             switch (bRequest)
3497:../uvc.c      ****             {
3498:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3499:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3500:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3501:../uvc.c      ****                     break;
3502:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3503:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3504:../uvc.c      ****                     glEp0Buffer[1] = 0;
3505:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3506:../uvc.c      ****                     break;
3507:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3508:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3509:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3510:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3511:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3512:../uvc.c      ****                     {
3513:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3514:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3515:../uvc.c      **** 
3516:../uvc.c      ****                     }
3517:../uvc.c      ****                     else
3518:../uvc.c      ****                     {
3519:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3520:../uvc.c      ****                     }
3521:../uvc.c      ****                     break;
3522:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3523:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3524:../uvc.c      ****                             glCommitCtrl, &readCount);
3525:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3526:../uvc.c      ****                     {
3527:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3528:../uvc.c      ****                         {
3529:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3530:../uvc.c      ****                                active data structure. */
3531:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3532:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3533:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3534:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3535:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3536:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3537:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3538:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3539:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3540:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3541:../uvc.c      **** #if 0
3542:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3543:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3544:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3545:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3546:../uvc.c      **** #endif
3547:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3548:../uvc.c      ****                        }
3549:../uvc.c      ****                     }
3550:../uvc.c      ****                     break;
3551:../uvc.c      ****                 default:
3552:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3553:../uvc.c      ****                     break;
3554:../uvc.c      ****             }
3555:../uvc.c      ****             break;
3556:../uvc.c      **** 
3557:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3558:../uvc.c      ****             switch (bRequest)
3559:../uvc.c      ****             {
3560:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3561:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3562:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3563:../uvc.c      ****                     break;
3564:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3565:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3566:../uvc.c      ****                     glEp0Buffer[1] = 0;
3567:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3568:../uvc.c      ****                     break;
3569:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3570:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3571:../uvc.c      ****                     {
3572:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3573:../uvc.c      ****                     }
3574:../uvc.c      ****                     else
3575:../uvc.c      ****                     {
3576:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3577:../uvc.c      ****                     }
3578:../uvc.c      ****                     break;
3579:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3580:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3581:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3582:../uvc.c      ****                        */
3583:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3584:../uvc.c      ****                             glCommitCtrl, &readCount);
3585:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3586:../uvc.c      ****                     {
3587:../uvc.c      ****                         switch (glCommitCtrl[3])
3588:../uvc.c      ****                          {
3589:../uvc.c      ****                          	case 1: //1944
3590:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3591:../uvc.c      ****                          		CyU3PThreadSleep(500);
3592:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3593:../uvc.c      ****                          		break;
3594:../uvc.c      ****                          	case 2: //1080
3595:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3596:../uvc.c      ****                          		CyU3PThreadSleep(500);
3597:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3598:../uvc.c      ****                          		break;
3599:../uvc.c      ****                          	case 3: //720
3600:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3601:../uvc.c      ****                          		CyU3PThreadSleep(500);
3602:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3603:../uvc.c      ****                          		break;
3604:../uvc.c      ****                          	case 4: //VGA
3605:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3606:../uvc.c      ****                          		CyU3PThreadSleep(500);
3607:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3608:../uvc.c      ****                          		break;
3609:../uvc.c      ****                          	default:
3610:../uvc.c      ****                          		break;
3611:../uvc.c      ****                          }
3612:../uvc.c      ****                         setRes = glCommitCtrl[3];
3613:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3614:../uvc.c      **** 
3615:../uvc.c      **** #if 0
3616:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3617:../uvc.c      ****                         {
3618:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3619:../uvc.c      ****                         }
3620:../uvc.c      ****                         else
3621:../uvc.c      ****                         {
3622:../uvc.c      ****                             SensorScaling_VGA ();
3623:../uvc.c      ****                         }
3624:../uvc.c      **** #endif
3625:../uvc.c      ****                         /* We can start streaming video now. */
3626:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3627:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3628:../uvc.c      ****                         {
3629:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3630:../uvc.c      ****                         }
3631:../uvc.c      ****                     }
3632:../uvc.c      ****                     break;
3633:../uvc.c      **** 
3634:../uvc.c      ****                 default:
3635:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3636:../uvc.c      ****                     break;
3637:../uvc.c      ****             }
3638:../uvc.c      ****             break;
3639:../uvc.c      **** 
3640:../uvc.c      **** /* still image streaming handler */
3641:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3642:../uvc.c      ****                 switch (bRequest)
3643:../uvc.c      ****                 {
3644:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3645:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3646:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3647:../uvc.c      ****                         break;
3648:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3649:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3650:../uvc.c      ****                         glEp0Buffer[1] = 0;
3651:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3652:../uvc.c      ****                         break;
3653:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3654:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3655:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3656:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3657:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3658:../uvc.c      ****                         {
3659:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3660:../uvc.c      ****                         }
3661:../uvc.c      ****                         else
3662:../uvc.c      ****                         {
3663:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3664:../uvc.c      ****                         }
3665:../uvc.c      ****                         break;
3666:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3667:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3668:../uvc.c      ****                                 glCommitCtrl, &readCount);
3669:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3670:../uvc.c      ****                         {
3671:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3672:../uvc.c      ****                             {
3673:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3674:../uvc.c      ****                                    active data structure. */
3675:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3676:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3677:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
3678:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
3679:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
3680:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
3681:../uvc.c      ****                             }
3682:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3683:../uvc.c      ****                         }
3684:../uvc.c      ****                         break;
3685:../uvc.c      ****                     default:
3686:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3687:../uvc.c      ****                         break;
3688:../uvc.c      ****                 }
3689:../uvc.c      ****                 break;
3690:../uvc.c      **** 
3691:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3692:../uvc.c      ****                 switch (bRequest)
3693:../uvc.c      ****                 {
3694:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3695:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3696:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3697:../uvc.c      ****                         break;
3698:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3699:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3700:../uvc.c      ****                         glEp0Buffer[1] = 0;
3701:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3702:../uvc.c      ****                         break;
3703:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3704:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3705:../uvc.c      ****                         {
3706:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3707:../uvc.c      ****                         }
3708:../uvc.c      ****                         else
3709:../uvc.c      ****                         {
3710:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3711:../uvc.c      ****                         }
3712:../uvc.c      ****                         break;
3713:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3714:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3715:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3716:../uvc.c      ****                            */
3717:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3718:../uvc.c      ****                                 glCommitCtrl, &readCount);
3719:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3720:../uvc.c      ****                         {
3721:../uvc.c      ****     #if 0
3722:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3723:../uvc.c      ****                             {
3724:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3725:../uvc.c      ****                             }
3726:../uvc.c      ****                             else
3727:../uvc.c      ****                             {
3728:../uvc.c      ****                                 SensorScaling_VGA ();
3729:../uvc.c      ****                             }
3730:../uvc.c      ****                             /* We can start streaming video now. */
3731:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3732:../uvc.c      **** 
3733:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3734:../uvc.c      ****                             {
3735:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3736:../uvc.c      ****                             }
3737:../uvc.c      **** 	#endif
3738:../uvc.c      ****                            switch (glCommitCtrl[1])
3739:../uvc.c      ****                              {
3740:../uvc.c      ****                              	case 4: //1944
3741:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3742:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3743:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3744:../uvc.c      ****                              		break;
3745:../uvc.c      ****                              	case 3: //1080
3746:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3747:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3748:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3749:../uvc.c      ****                              		break;
3750:../uvc.c      ****                              	case 2: //720
3751:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3752:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3753:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3754:../uvc.c      ****                              		break;
3755:../uvc.c      ****                             	case 1: //VGA
3756:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3757:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3758:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3759:../uvc.c      ****                              		break;
3760:../uvc.c      ****                               	default:
3761:../uvc.c      ****                              		break;
3762:../uvc.c      ****                              }
3763:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3764:../uvc.c      **** 
3765:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3766:../uvc.c      **** 
3767:../uvc.c      ****                         }
3768:../uvc.c      ****                         break;
3769:../uvc.c      **** 
3770:../uvc.c      ****                     default:
3771:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3772:../uvc.c      ****                         break;
3773:../uvc.c      ****                 }
3774:../uvc.c      ****                 break;
3775:../uvc.c      **** 
3776:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3777:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3778:../uvc.c      ****             	switch (bRequest)
3779:../uvc.c      ****                 {
3780:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3781:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3782:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3783:../uvc.c      ****                         break;
3784:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3785:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3786:../uvc.c      ****                         glEp0Buffer[1] = 0;
3787:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3788:../uvc.c      ****                         break;
3789:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3790:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3791:../uvc.c      ****                         {
3792:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3793:../uvc.c      ****                         }
3794:../uvc.c      ****                         else
3795:../uvc.c      ****                         {
3796:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3797:../uvc.c      ****                         }
3798:../uvc.c      ****                         break;
3799:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3800:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3801:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3802:../uvc.c      ****                            */
3803:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3804:../uvc.c      ****                                 glCommitCtrl, &readCount);
3805:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3806:../uvc.c      ****                         {
3807:../uvc.c      ****     #if 1
3808:../uvc.c      ****                             /* We can start still streaming video now. */
3809:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3810:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3811:../uvc.c      ****                             {
3812:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
3813:../uvc.c      ****                             }
3814:../uvc.c      ****     #endif
3815:../uvc.c      ****                             else{
3816:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
3817:../uvc.c      ****                             //stillcont = 0;
3818:../uvc.c      ****                             }
3819:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
3820:../uvc.c      ****                         }else{
3821:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3822:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3823:../uvc.c      ****                         }
3824:../uvc.c      ****                         break;
3825:../uvc.c      **** 
3826:../uvc.c      ****                     default:
3827:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3828:../uvc.c      ****                         break;
3829:../uvc.c      ****                 }
3830:../uvc.c      ****                 break;
3831:../uvc.c      **** 
3832:../uvc.c      ****         default:
3833:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3834:../uvc.c      ****             break;
3835:../uvc.c      ****     }
3836:../uvc.c      **** }
3837:../uvc.c      **** 
3838:../uvc.c      **** /*
3839:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3840:../uvc.c      ****  */
3841:../uvc.c      **** void
3842:../uvc.c      **** UVCAppEP0Thread_Entry (
3843:../uvc.c      ****         uint32_t input)
3844:../uvc.c      **** {
3845:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3846:../uvc.c      ****     uint32_t eventFlag;
3847:../uvc.c      **** 	CyBool_t value;
3848:../uvc.c      **** 	CyBool_t *valueptr = &value;
3849:../uvc.c      **** 
3850:../uvc.c      **** 
3851:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3852:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3853:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3854:../uvc.c      **** 
3855:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3856:../uvc.c      **** #endif
3857:../uvc.c      **** 
3858:../uvc.c      ****     /* for interrupt status test */
3859:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3860:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3861:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3862:../uvc.c      **** 
3863:../uvc.c      ****     for (;;)
3864:../uvc.c      ****     {
3865:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3866:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3867:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3868:../uvc.c      ****         {
3869:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3870:../uvc.c      ****             if (!isUsbConnected)
3871:../uvc.c      ****             {
3872:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3873:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3874:../uvc.c      ****                 {
3875:../uvc.c      ****                     isUsbConnected = CyTrue;
3876:../uvc.c      ****                 }
3877:../uvc.c      ****             }
3878:../uvc.c      **** //#ifdef DbgInfo
3879:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3880:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3881:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3882:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3883:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3884:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3885:../uvc.c      **** //#endif
3886:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3887:../uvc.c      ****             {
3888:../uvc.c      ****             	switch ((wIndex >> 8))
3889:../uvc.c      ****                 {
3890:../uvc.c      **** 
3891:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3892:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3893:../uvc.c      ****                         break;
3894:../uvc.c      **** 
3895:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3896:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3897:../uvc.c      ****                         break;
3898:../uvc.c      **** 
3899:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3900:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3901:../uvc.c      ****                         break;
3902:../uvc.c      **** 
3903:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3904:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3905:../uvc.c      ****                         break;
3906:../uvc.c      **** 
3907:../uvc.c      ****                     default:
3908:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3909:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3910:../uvc.c      ****                         break;
3911:../uvc.c      ****                 }
3912:../uvc.c      ****             }
3913:../uvc.c      **** 
3914:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3915:../uvc.c      ****             {
3916:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3917:../uvc.c      **** 
3918:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3919:../uvc.c      ****                 {
3920:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3921:../uvc.c      ****                 }
3922:../uvc.c      ****                 else
3923:../uvc.c      ****                 {
3924:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3925:../uvc.c      ****                 }
3926:../uvc.c      ****             }
3927:../uvc.c      **** 
3928:../uvc.c      ****             /* handle interrupt status event */
3929:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3930:../uvc.c      ****             {
3931:../uvc.c      **** 
3932:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3933:../uvc.c      ****             	/** preparing interrupt status data **/
3934:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3935:../uvc.c      **** 
3936:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3937:../uvc.c      **** 
3938:../uvc.c      **** #if 0 //for real button
3939:../uvc.c      **** 				if(value&&(!snapButFlag)){
3940:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3941:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3942:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3943:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3944:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3945:../uvc.c      **** 
3946:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3947:../uvc.c      **** 					interStabuf.size   = 1024;
3948:../uvc.c      **** 					interStabuf.status = 0;
3949:../uvc.c      **** 
3950:../uvc.c      **** 					interStabuf.count = 4;
3951:../uvc.c      **** 
3952:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3953:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3954:../uvc.c      **** 
3955:../uvc.c      **** 					/** send a interrupt status data **/
3956:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3957:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3958:../uvc.c      **** 					{
3959:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3960:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3961:../uvc.c      **** 					}
3962:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3963:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3964:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3965:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3966:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3967:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3968:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3969:../uvc.c      **** 
3970:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3971:../uvc.c      **** 					interStabuf.size   = 1024;
3972:../uvc.c      **** 					interStabuf.status = 0;
3973:../uvc.c      **** 
3974:../uvc.c      **** 					interStabuf.count = 4;
3975:../uvc.c      **** 
3976:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3977:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3978:../uvc.c      **** 
3979:../uvc.c      **** 					/** send a interrupt status data **/
3980:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3981:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3982:../uvc.c      **** 					{
3983:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3984:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3985:../uvc.c      **** 					}
3986:../uvc.c      **** 
3987:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3988:../uvc.c      **** 					stiflag = 0xFF;
3989:../uvc.c      **** 				}
3990:../uvc.c      **** #else			//for botton simulation
3991:../uvc.c      **** 				if(snapButFlag == 0x0f){
3992:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3993:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3994:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3995:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3996:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3997:../uvc.c      **** 
3998:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3999:../uvc.c      **** 					interStabuf.size   = 1024;
4000:../uvc.c      **** 					interStabuf.status = 0;
4001:../uvc.c      **** 
4002:../uvc.c      **** 					interStabuf.count = 4;
4003:../uvc.c      **** 
4004:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4005:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4006:../uvc.c      **** 
4007:../uvc.c      **** 					/** send a interrupt status data **/
4008:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4009:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4010:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4011:../uvc.c      **** 					{
4012:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4013:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4014:../uvc.c      **** 					}
4015:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4016:../uvc.c      **** 
4017:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4018:../uvc.c      **** 				}else if(!snapButFlag){
4019:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4020:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4021:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4022:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4023:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4024:../uvc.c      **** 
4025:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4026:../uvc.c      **** 					interStabuf.size   = 1024;
4027:../uvc.c      **** 					interStabuf.status = 0;
4028:../uvc.c      **** 
4029:../uvc.c      **** 					interStabuf.count = 4;
4030:../uvc.c      **** 
4031:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4032:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4033:../uvc.c      **** 
4034:../uvc.c      **** 					/** send a interrupt status data **/
4035:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4036:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4037:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4038:../uvc.c      **** 					{
4039:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4040:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4041:../uvc.c      **** 					}
4042:../uvc.c      **** 
4043:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4044:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4045:../uvc.c      **** 				}
4046:../uvc.c      **** #endif
4047:../uvc.c      **** 
4048:../uvc.c      ****             }
4049:../uvc.c      **** 
4050:../uvc.c      **** 
4051:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4052:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4053:../uvc.c      ****             {
4054:../uvc.c      ****                 /* Get the command buffer */
4055:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4056:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4057:../uvc.c      ****                 {
4058:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4059:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4060:../uvc.c      ****                 }
4061:../uvc.c      **** 
4062:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4063:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4064:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4065:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4066:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4067:../uvc.c      ****                  * register value high byte and register value low byte.
4068:../uvc.c      ****                  */
4069:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4070:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4071:../uvc.c      ****                 {
4072:../uvc.c      ****                     if (dmaInfo.count == 3)
4073:../uvc.c      ****                     {
4074:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4075:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4076:../uvc.c      ****                         dmaInfo.count = 3;
4077:../uvc.c      ****                     }
4078:../uvc.c      ****                     else if (dmaInfo.count == 4)
4079:../uvc.c      ****                     {
4080:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4081:../uvc.c      ****                         {
4082:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4083:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4084:../uvc.c      ****                         }
4085:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4086:../uvc.c      ****                     }
4087:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4088:../uvc.c      ****                 }
4089:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4090:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4091:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4092:../uvc.c      ****                  */
4093:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4094:../uvc.c      ****                 {
4095:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4096:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4097:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4098:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4099:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4100:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4101:../uvc.c      ****                         	break;
4102:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4103:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4104:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4105:../uvc.c      ****                         	break;*/
4106:../uvc.c      ****                     dmaInfo.count -= 2;
4107:../uvc.c      ****                 }
4108:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4109:../uvc.c      ****                 else
4110:../uvc.c      ****                 {
4111:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4112:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4113:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4114:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4115:../uvc.c      ****                 }
4116:../uvc.c      **** 
4117:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4118:../uvc.c      ****                 dmaInfo.size   = 1024;
4119:../uvc.c      ****                 dmaInfo.status = 0;
4120:../uvc.c      **** 
4121:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4122:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4123:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4124:../uvc.c      ****                 {
4125:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4126:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4127:../uvc.c      ****                 }
4128:../uvc.c      **** 
4129:../uvc.c      ****                 /* Wait until the response has gone out. */
4130:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4131:../uvc.c      **** 
4132:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4133:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4134:../uvc.c      ****                 {
4135:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4136:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4137:../uvc.c      ****                 }
4138:../uvc.c      ****             }
4139:../uvc.c      **** #endif
4140:../uvc.c      ****         }
4141:../uvc.c      ****         /* Allow other ready threads to run. */
4142:../uvc.c      ****         CyU3PThreadRelinquish ();
4143:../uvc.c      ****     }
4144:../uvc.c      **** }
4145:../uvc.c      **** 
4146:../uvc.c      **** /*
4147:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4148:../uvc.c      ****  * added 10/2013
4149:../uvc.c      ****  */
4150:../uvc.c      **** /*
4151:../uvc.c      **** static uint8_t timeDelay[64] = {
4152:../uvc.c      **** 
4153:../uvc.c      **** };
4154:../uvc.c      **** */
4155:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4155 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4156:../uvc.c      **** 
4157:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4158:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4159:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4160:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4161:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4162:../uvc.c      **** 	uint32_t flag = 0;
4163:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4164:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4165:../uvc.c      **** 	uint8_t i;
4166:../uvc.c      **** 	uint16_t delaytime;
4167:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4168:../uvc.c      **** 
4169:../uvc.c      **** #if 0 //for test the command queue
4170:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4171:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4172:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4173:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4174:../uvc.c      **** 		lcCmdDes += 1;
4175:../uvc.c      **** 	}
4176:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4177:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4178:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4179:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4180:../uvc.c      **** 		lcCmdDes += 1;
4181:../uvc.c      **** 	}
4182:../uvc.c      **** 
4183:../uvc.c      **** #endif
4184:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4185:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4185 0
  36 0004 98229FE5 		ldr	r2, .L27
4162:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4162 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4155:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4155 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4185 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 80029FE5 		ldr	r0, .L27+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4162:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4162 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4185 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4186:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4186 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 64129FE5 		ldr	r1, .L27+8
  71 0044 64629FE5 		ldr	r6, .L27+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4187:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4187 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4188:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4188 0
  79 005c 44029FE5 		ldr	r0, .L27+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4189:../uvc.c      **** 
4190:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4190 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4191:../uvc.c      ****         /* Allow other ready threads to run. */
4192:../uvc.c      **** 
4193:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4193 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4190:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4190 0 discriminator 1
  88 006c 1A20D6E5 		ldrb	r2, [r6, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4194:../uvc.c      **** 	}
4195:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4195 0
  92 0078 30029FE5 		ldr	r0, .L27+12
  93 007c 30129FE5 		ldr	r1, .L27+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 20529FE5 		ldr	r5, .L27+20
4196:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4197:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4198:../uvc.c      **** 	//CyU3PThreadSleep(100);
4199:../uvc.c      **** 	//SetCurCmd();
4200:../uvc.c      **** 	/*********** the loop of the thread ***********/
4201:../uvc.c      **** 	for(;;){
4202:../uvc.c      **** 
4203:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
  99              		.loc 1 4203 0
 100 0094 0070E0E3 		mvn	r7, #0
4204:../uvc.c      **** /*  // for test GPIO output
4205:../uvc.c      **** 		if(trigger)
4206:../uvc.c      **** 		{
4207:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4208:../uvc.c      **** 			{
4209:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4210:../uvc.c      **** 			}
4211:../uvc.c      **** 
4212:../uvc.c      **** 		}else{
4213:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4214:../uvc.c      **** 			{
4215:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4216:../uvc.c      **** 			}
4217:../uvc.c      **** 
4218:../uvc.c      **** 		}
4219:../uvc.c      **** */
4220:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 101              		.loc 1 4220 0
 102 0098 0590A0E1 		mov	r9, r5
4221:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4222:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4223:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4224:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4225:../uvc.c      **** 				i = 0;
4226:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
4227:../uvc.c      **** 					i++;
4228:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4229:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4230:../uvc.c      **** 				}
4231:../uvc.c      **** #if 1
4232:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4233:../uvc.c      **** 				i = lcStaDes->curNum;
4234:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4235:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4236:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4237:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4238:../uvc.c      **** 
4239:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4240:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4241:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4242:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4243:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4244:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4245:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4246:../uvc.c      **** #endif
4247:../uvc.c      **** 				//}
4248:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4249:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4250:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4251:../uvc.c      **** 				/* setting delay */
4252:../uvc.c      **** 				delaytime = 300;
4253:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4254:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4255:../uvc.c      **** 			} //end of the if condition statment
4256:../uvc.c      **** #endif
4257:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4258:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4259:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4260:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4261:../uvc.c      **** 
4262:../uvc.c      **** 				/*
4263:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4264:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4265:../uvc.c      **** 				*/
4266:../uvc.c      **** 
4267:../uvc.c      **** 				/* find a available command */
4268:../uvc.c      **** 				i = 0;
4269:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4270:../uvc.c      **** 					i++;
4271:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4272:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4273:../uvc.c      **** 				}
4274:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4275:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4276:../uvc.c      **** 					i = lcCmdDes->curNum;
4277:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4278:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4279:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4280:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4281:../uvc.c      **** #if 1
4282:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4283:../uvc.c      **** 						case 0x20:
4284:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4285:../uvc.c      **** 							delaytime = 500;
4286:../uvc.c      **** 							break;
4287:../uvc.c      **** 						case 0x21:
4288:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4289:../uvc.c      **** 							delaytime = 500;
4290:../uvc.c      **** 							break;
4291:../uvc.c      **** 						case 0x22:
4292:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4293:../uvc.c      **** 							delaytime = 300;
4294:../uvc.c      **** 							break;
4295:../uvc.c      **** 						case 0x23:
4296:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4297:../uvc.c      **** 							delaytime = 300;
4298:../uvc.c      **** 							break;
4299:../uvc.c      **** 						default:
4300:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4301:../uvc.c      **** 							break;
4302:../uvc.c      **** 					}
4303:../uvc.c      **** #endif
4304:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4305:../uvc.c      **** 					/** timer's ticket modify **/
4306:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4307:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4308:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4309:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4310:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4311:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4312:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4313:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4314:../uvc.c      **** #endif
4315:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4316:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4317:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4318:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4319:../uvc.c      **** 						}else{
4320:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4321:../uvc.c      **** 						}
4322:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4323:../uvc.c      **** 					}else{
4324:../uvc.c      **** 						lcCmdDes->curNum ++;
4325:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 103              		.loc 1 4325 0
 104 009c 0FB0A0E3 		mov	fp, #15
 105              	.L22:
4203:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 106              		.loc 1 4203 0
 107 00a0 14308DE2 		add	r3, sp, #20
 108 00a4 2010A0E3 		mov	r1, #32
 109 00a8 0320A0E3 		mov	r2, #3
 110 00ac 08029FE5 		ldr	r0, .L27+24
 111 00b0 00708DE5 		str	r7, [sp, #0]
 112 00b4 FEFFFFEB 		bl	_txe_event_flags_get
4220:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 113              		.loc 1 4220 0
 114 00b8 1C0095E5 		ldr	r0, [r5, #28]
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 FEFFFFEB 		bl	_txe_mutex_get
4223:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
 117              		.loc 1 4223 0
 118 00c4 104095E5 		ldr	r4, [r5, #16]
 119              	.LVL3:
4226:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 120              		.loc 1 4226 0
 121 00c8 3C3094E5 		ldr	r3, [r4, #60]
 122 00cc 018073E2 		rsbs	r8, r3, #1
 123 00d0 0080A033 		movcc	r8, #0
 124 00d4 000058E3 		cmp	r8, #0
 125 00d8 5B00000A 		beq	.L4
 126              	.LVL4:
 127              	.L5:
4227:../uvc.c      **** 					i++;
 128              		.loc 1 4227 0
 129 00dc 011083E2 		add	r1, r3, #1
 130 00e0 FF3001E2 		and	r3, r1, #255
 131              	.LVL5:
4226:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 132              		.loc 1 4226 0
 133 00e4 3F0053E3 		cmp	r3, #63
 134 00e8 FBFFFF9A 		bls	.L5
 135              	.LVL6:
 136              	.L6:
4257:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 137              		.loc 1 4257 0
 138 00ec 1C0095E5 		ldr	r0, [r5, #28]
 139 00f0 FEFFFFEB 		bl	_txe_mutex_put
 140              	.LVL7:
4259:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 141              		.loc 1 4259 0
 142 00f4 1C0096E5 		ldr	r0, [r6, #28]
 143 00f8 0010E0E3 		mvn	r1, #0
 144 00fc FEFFFFEB 		bl	_txe_mutex_get
4260:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 145              		.loc 1 4260 0
 146 0100 104096E5 		ldr	r4, [r6, #16]
 147              	.LVL8:
4269:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 148              		.loc 1 4269 0
 149 0104 3C2094E5 		ldr	r2, [r4, #60]
 150 0108 000052E3 		cmp	r2, #0
 151 010c 0800001A 		bne	.L8
 152 0110 0030A0E3 		mov	r3, #0
 153              	.LVL9:
 154              	.L9:
4271:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 155              		.loc 1 4271 0
 156 0114 344094E5 		ldr	r4, [r4, #52]
 157              	.LVL10:
4270:../uvc.c      **** 					i++;
 158              		.loc 1 4270 0
 159 0118 01E083E2 		add	lr, r3, #1
4269:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 160              		.loc 1 4269 0
 161 011c 3C2094E5 		ldr	r2, [r4, #60]
4270:../uvc.c      **** 					i++;
 162              		.loc 1 4270 0
 163 0120 FF300EE2 		and	r3, lr, #255
 164              	.LVL11:
4269:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 165              		.loc 1 4269 0
 166 0124 3F0053E3 		cmp	r3, #63
 167 0128 00005293 		cmpls	r2, #0
 168 012c F8FFFF0A 		beq	.L9
 169 0130 104086E5 		str	r4, [r6, #16]
 170              	.LVL12:
 171              	.L8:
4275:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 172              		.loc 1 4275 0
 173 0134 000052E3 		cmp	r2, #0
 174 0138 2D00000A 		beq	.L10
 175              	.LVL13:
4277:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 176              		.loc 1 4277 0
 177 013c 0180D4E5 		ldrb	r8, [r4, #1]	@ zero_extendqisi2
4282:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 178              		.loc 1 4282 0
 179 0140 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4277:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 180              		.loc 1 4277 0
 181 0144 881088E0 		add	r1, r8, r8, asl #1
 182 0148 813084E0 		add	r3, r4, r1, asl #1
4282:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 183              		.loc 1 4282 0
 184 014c 20A040E2 		sub	sl, r0, #32
4278:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 185              		.loc 1 4278 0
 186 0150 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
4277:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 187              		.loc 1 4277 0
 188 0154 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 189              	.LVL14:
4279:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 190              		.loc 1 4279 0
 191 0158 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 192              	.LVL15:
4280:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 193              		.loc 1 4280 0
 194 015c B880D3E1 		ldrh	r8, [r3, #8]
 195              	.LVL16:
4282:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 196              		.loc 1 4282 0
 197 0160 03005AE3 		cmp	sl, #3
 198 0164 0AF19F97 		ldrls	pc, [pc, sl, asl #2]
 199 0168 1E0000EA 		b	.L11
 200              	.L16:
 201 016c D8010000 		.word	.L12
 202 0170 C8010000 		.word	.L13
 203 0174 7C010000 		.word	.L15
 204 0178 7C010000 		.word	.L15
 205              	.L15:
4296:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 206              		.loc 1 4296 0
 207 017c 8230A0E3 		mov	r3, #130
 208 0180 FEFFFFEB 		bl	SensorSetIrisControl
 209              	.LVL17:
4298:../uvc.c      **** 							break;
 210              		.loc 1 4298 0
 211 0184 4B1FA0E3 		mov	r1, #300
 212              	.LVL18:
 213              	.L17:
4307:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 214              		.loc 1 4307 0
 215 0188 0020A0E3 		mov	r2, #0
 216 018c 14019FE5 		ldr	r0, .L27+4
 217 0190 FEFFFFEB 		bl	_txe_timer_change
4308:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 218              		.loc 1 4308 0
 219 0194 0C019FE5 		ldr	r0, .L27+4
 220 0198 FEFFFFEB 		bl	_txe_timer_activate
 221              	.LVL19:
4315:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 222              		.loc 1 4315 0
 223 019c 01C0D4E5 		ldrb	ip, [r4, #1]	@ zero_extendqisi2
 224 01a0 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 225 01a4 0C0052E1 		cmp	r2, ip
4324:../uvc.c      **** 						lcCmdDes->curNum ++;
 226              		.loc 1 4324 0
 227 01a8 01C08C12 		addne	ip, ip, #1
 228 01ac 01C0C415 		strneb	ip, [r4, #1]
 229              		.loc 1 4325 0
 230 01b0 3CB08415 		strne	fp, [r4, #60]
4315:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 231              		.loc 1 4315 0
 232 01b4 1400000A 		beq	.L26
 233              	.LVL20:
 234              	.L21:
4326:../uvc.c      **** 					}
4327:../uvc.c      **** 				}else{
4328:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4329:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4330:../uvc.c      **** 				}
4331:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 235              		.loc 1 4331 0
 236 01b8 1C0096E5 		ldr	r0, [r6, #28]
 237 01bc FEFFFFEB 		bl	_txe_mutex_put
 238              	.LVL21:
4332:../uvc.c      **** 			}
4333:../uvc.c      **** /*
4334:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4335:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4336:../uvc.c      **** */
4337:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4338:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4339:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4340:../uvc.c      **** #endif
4341:../uvc.c      **** 
4342:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4343:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4344:../uvc.c      **** #if 0
4345:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4346:../uvc.c      **** 
4347:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4348:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4349:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4350:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4351:../uvc.c      **** 			    i = 0;
4352:../uvc.c      **** 				 switch(cmdCopyIdx)
4353:../uvc.c      **** 				 {
4354:../uvc.c      **** 					 case BrgtCtlID1:
4355:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4356:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4357:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4358:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4359:../uvc.c      **** 							 i++;
4360:../uvc.c      **** 						 }
4361:../uvc.c      **** 						 else{
4362:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4363:../uvc.c      **** 						 }
4364:../uvc.c      **** 
4365:../uvc.c      **** 						 CyU3PBusyWait(500);
4366:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4367:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4368:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4369:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4370:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4371:../uvc.c      **** 						 }
4372:../uvc.c      **** 						 else{
4373:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4374:../uvc.c      **** 						 }
4375:../uvc.c      **** 						 break;
4376:../uvc.c      **** 					 case HueCtlID5:
4377:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4378:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4379:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4380:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4381:../uvc.c      **** 						 }
4382:../uvc.c      **** 						 else{
4383:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4384:../uvc.c      **** 						 }
4385:../uvc.c      **** 						 break;
4386:../uvc.c      **** 					 case SaturCtlID6:
4387:../uvc.c      **** 					 case WBTLevCtlID10:
4388:../uvc.c      **** 					 default:
4389:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4390:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4391:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4392:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4393:../uvc.c      **** 						 }
4394:../uvc.c      **** 						 else{
4395:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4396:../uvc.c      **** 						 }
4397:../uvc.c      **** 						 break;
4398:../uvc.c      **** 				 }
4399:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4400:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4401:../uvc.c      **** 			}
4402:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4403:../uvc.c      **** #endif
4404:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4405:../uvc.c      **** 		/* Allow other ready threads to run. */
4406:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4407:../uvc.c      **** 			CyU3PThreadRelinquish ();
 239              		.loc 1 4407 0
 240 01c0 FEFFFFEB 		bl	_txe_thread_relinquish
4408:../uvc.c      **** 		}
 241              		.loc 1 4408 0
 242 01c4 B5FFFFEA 		b	.L22
 243              	.LVL22:
 244              	.L13:
4288:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 245              		.loc 1 4288 0
 246 01c8 5230A0E3 		mov	r3, #82
 247 01cc FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL23:
4290:../uvc.c      **** 							break;
 249              		.loc 1 4290 0
 250 01d0 7D1FA0E3 		mov	r1, #500
 251 01d4 EBFFFFEA 		b	.L17
 252              	.LVL24:
 253              	.L12:
4284:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 254              		.loc 1 4284 0
 255 01d8 8230A0E3 		mov	r3, #130
 256 01dc FEFFFFEB 		bl	SensorSetIrisControl
 257              	.LVL25:
4286:../uvc.c      **** 							break;
 258              		.loc 1 4286 0
 259 01e0 7D1FA0E3 		mov	r1, #500
 260 01e4 E7FFFFEA 		b	.L17
 261              	.LVL26:
 262              	.L11:
4300:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 263              		.loc 1 4300 0
 264 01e8 FEFFFFEB 		bl	SensorSetControl
 265              	.LVL27:
 266 01ec 0810A0E1 		mov	r1, r8
4301:../uvc.c      **** 							break;
 267              		.loc 1 4301 0
 268 01f0 E4FFFFEA 		b	.L17
 269              	.LVL28:
 270              	.L10:
4328:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 271              		.loc 1 4328 0
 272 01f4 FA1FA0E3 		mov	r1, #1000
 273 01f8 A8009FE5 		ldr	r0, .L27+4
 274 01fc FEFFFFEB 		bl	_txe_timer_change
4329:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 275              		.loc 1 4329 0
 276 0200 A0009FE5 		ldr	r0, .L27+4
 277 0204 FEFFFFEB 		bl	_txe_timer_activate
 278 0208 EAFFFFEA 		b	.L21
 279              	.LVL29:
 280              	.L26:
4317:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 281              		.loc 1 4317 0
 282 020c 00A0D4E5 		ldrb	sl, [r4, #0]	@ zero_extendqisi2
4316:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 283              		.loc 1 4316 0
 284 0210 00E0A0E3 		mov	lr, #0
4317:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 285              		.loc 1 4317 0
 286 0214 23005AE3 		cmp	sl, #35
4318:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 287              		.loc 1 4318 0
 288 0218 A0109F85 		ldrhi	r1, .L27+28
4320:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 289              		.loc 1 4320 0
 290 021c 9C109F95 		ldrls	r1, .L27+28
4318:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 291              		.loc 1 4318 0
 292 0220 24A04A82 		subhi	sl, sl, #36
 293 0224 8AA08A80 		addhi	sl, sl, sl, asl #1
4320:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 294              		.loc 1 4320 0
 295 0228 8AA08A90 		addls	sl, sl, sl, asl #1
4318:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 296              		.loc 1 4318 0
 297 022c 8AA18180 		addhi	sl, r1, sl, asl #3
4320:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 298              		.loc 1 4320 0
 299 0230 8AA18190 		addls	sl, r1, sl, asl #3
4316:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 300              		.loc 1 4316 0
 301 0234 3CE084E5 		str	lr, [r4, #60]
4318:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 302              		.loc 1 4318 0
 303 0238 10E0CA85 		strhib	lr, [sl, #16]
4320:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 304              		.loc 1 4320 0
 305 023c 90E1CA95 		strlsb	lr, [sl, #400]
4322:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 306              		.loc 1 4322 0
 307 0240 344094E5 		ldr	r4, [r4, #52]
 308              	.LVL30:
 309 0244 104086E5 		str	r4, [r6, #16]
 310 0248 DAFFFFEA 		b	.L21
 311              	.LVL31:
 312              	.L4:
4232:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
 313              		.loc 1 4232 0
 314 024c 000053E3 		cmp	r3, #0
 315 0250 A5FFFF0A 		beq	.L6
 316              	.LVL32:
4234:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
 317              		.loc 1 4234 0
 318 0254 01C0D4E5 		ldrb	ip, [r4, #1]	@ zero_extendqisi2
 319              	.LVL33:
 320 0258 8C208CE0 		add	r2, ip, ip, asl #1
 321 025c 82A084E0 		add	sl, r4, r2, asl #1
4242:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
 322              		.loc 1 4242 0
 323 0260 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 324 0264 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 325 0268 FEFFFFEB 		bl	SensorGetControl
 326              	.LVL34:
4253:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 327              		.loc 1 4253 0
 328 026c 0820A0E1 		mov	r2, r8
4248:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
 329              		.loc 1 4248 0
 330 0270 3C8084E5 		str	r8, [r4, #60]
4253:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 331              		.loc 1 4253 0
 332 0274 4B1FA0E3 		mov	r1, #300
4242:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
 333              		.loc 1 4242 0
 334 0278 0600CAE5 		strb	r0, [sl, #6]
4249:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
 335              		.loc 1 4249 0
 336 027c 348094E5 		ldr	r8, [r4, #52]
4253:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 337              		.loc 1 4253 0
 338 0280 20009FE5 		ldr	r0, .L27+4
4249:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
 339              		.loc 1 4249 0
 340 0284 108089E5 		str	r8, [r9, #16]
 341              	.LVL35:
4253:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 342              		.loc 1 4253 0
 343 0288 FEFFFFEB 		bl	_txe_timer_change
4254:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 344              		.loc 1 4254 0
 345 028c 14009FE5 		ldr	r0, .L27+4
 346 0290 FEFFFFEB 		bl	_txe_timer_activate
4257:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 347              		.loc 1 4257 0
 348 0294 1C0099E5 		ldr	r0, [r9, #28]
 349 0298 FEFFFFEB 		bl	_txe_mutex_put
 350              	.LVL36:
4407:../uvc.c      **** 			CyU3PThreadRelinquish ();
 351              		.loc 1 4407 0
 352 029c FEFFFFEB 		bl	_txe_thread_relinquish
 353 02a0 7EFFFFEA 		b	.L22
 354              	.L28:
 355              		.align	2
 356              	.L27:
 357 02a4 00000000 		.word	I2CCmdCb
 358 02a8 00000000 		.word	I2CCmdTimer
 359 02ac 00000000 		.word	.LC0
 360 02b0 00000000 		.word	cmdQu
 361 02b4 14000000 		.word	.LC1
 362 02b8 00000000 		.word	statQu
 363 02bc 00000000 		.word	.LANCHOR0
 364 02c0 00000000 		.word	.LANCHOR1
 365              		.cfi_endproc
 366              	.LFE26:
 368              		.align	2
 369              		.global	I2CCmdCb
 371              	I2CCmdCb:
 372              	.LFB18:
2769:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 373              		.loc 1 2769 0
 374              		.cfi_startproc
 375              		@ args = 0, pretend = 0, frame = 0
 376              		@ frame_needed = 0, uses_anonymous_args = 0
 377              	.LVL37:
2770:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 378              		.loc 1 2770 0
 379 02c4 28209FE5 		ldr	r2, .L30
2769:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 380              		.loc 1 2769 0
 381 02c8 0030A0E1 		mov	r3, r0
 382 02cc 10402DE9 		stmfd	sp!, {r4, lr}
 383              	.LCFI2:
 384              		.cfi_def_cfa_offset 8
2770:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 385              		.loc 1 2770 0
 386 02d0 20109FE5 		ldr	r1, .L30+4
 387 02d4 002092E5 		ldr	r2, [r2, #0]
 388 02d8 0400A0E3 		mov	r0, #4
 389              	.LVL38:
 390              		.cfi_offset 14, -4
 391              		.cfi_offset 4, -8
 392 02dc FEFFFFEB 		bl	CyU3PDebugPrint
 393              	.LVL39:
2771:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 394              		.loc 1 2771 0
 395 02e0 14009FE5 		ldr	r0, .L30+8
 396 02e4 2010A0E3 		mov	r1, #32
 397 02e8 0020A0E3 		mov	r2, #0
2772:../uvc.c      **** }
 398              		.loc 1 2772 0
 399 02ec 1040BDE8 		ldmfd	sp!, {r4, lr}
2771:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 400              		.loc 1 2771 0
 401 02f0 FEFFFFEA 		b	_txe_event_flags_set
 402              	.L31:
 403              		.align	2
 404              	.L30:
 405 02f4 00000000 		.word	posTick
 406 02f8 38000000 		.word	.LC2
 407 02fc 00000000 		.word	.LANCHOR0
 408              		.cfi_endproc
 409              	.LFE18:
 411              		.align	2
 413              	CyFxUVCApplnUSBEventCB:
 414              	.LFB9:
1830:../uvc.c      **** {
 415              		.loc 1 1830 0
 416              		.cfi_startproc
 417              		@ args = 0, pretend = 0, frame = 8
 418              		@ frame_needed = 0, uses_anonymous_args = 0
 419              	.LVL40:
1831:../uvc.c      ****     switch (evtype)
 420              		.loc 1 1831 0
 421 0300 020050E3 		cmp	r0, #2
1830:../uvc.c      **** {
 422              		.loc 1 1830 0
 423 0304 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 424              	.LCFI3:
 425              		.cfi_def_cfa_offset 16
 426 0308 0130A0E1 		mov	r3, r1
 427 030c 10D04DE2 		sub	sp, sp, #16
 428              	.LCFI4:
 429              		.cfi_def_cfa_offset 32
1830:../uvc.c      **** {
 430              		.loc 1 1830 0
 431 0310 0040A0E1 		mov	r4, r0
 432              		.cfi_offset 14, -4
 433              		.cfi_offset 6, -8
 434              		.cfi_offset 5, -12
 435              		.cfi_offset 4, -16
1831:../uvc.c      ****     switch (evtype)
 436              		.loc 1 1831 0
 437 0314 3600000A 		beq	.L35
 438 0318 040050E3 		cmp	r0, #4
 439 031c 1F00000A 		beq	.L36
 440 0320 010050E3 		cmp	r0, #1
 441 0324 0100000A 		beq	.L38
 442              	.LVL41:
 443              	.L32:
1867:../uvc.c      **** }
 444              		.loc 1 1867 0
 445 0328 10D08DE2 		add	sp, sp, #16
 446 032c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 447              	.LVL42:
 448              	.L38:
1852:../uvc.c      ****             gpif_initialized = 0;
 449              		.loc 1 1852 0
 450 0330 28519FE5 		ldr	r5, .L39
1850:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 451              		.loc 1 1850 0
 452 0334 0020A0E1 		mov	r2, r0
 453 0338 24119FE5 		ldr	r1, .L39+4
 454              	.LVL43:
 455 033c 0400A0E3 		mov	r0, #4
 456              	.LVL44:
 457 0340 FEFFFFEB 		bl	CyU3PDebugPrint
1851:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 458              		.loc 1 1851 0
 459 0344 0400A0E1 		mov	r0, r4
 460 0348 FEFFFFEB 		bl	CyU3PGpifDisable
1852:../uvc.c      ****             gpif_initialized = 0;
 461              		.loc 1 1852 0
 462 034c 00C0A0E3 		mov	ip, #0
 463              	.LBB16:
 464              	.LBB17:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 465              		.loc 1 1814 0
 466 0350 0410A0E1 		mov	r1, r4
 467 0354 0500A0E1 		mov	r0, r5
 468 0358 0220A0E3 		mov	r2, #2
 469 035c 0C308DE2 		add	r3, sp, #12
 470              	.LBE17:
 471              	.LBE16:
1852:../uvc.c      ****             gpif_initialized = 0;
 472              		.loc 1 1852 0
 473 0360 28C085E5 		str	ip, [r5, #40]
1853:../uvc.c      ****             isUsbConnected = CyFalse;
 474              		.loc 1 1853 0
 475 0364 30C085E5 		str	ip, [r5, #48]
1854:../uvc.c      ****             streamingStarted = CyFalse;
 476              		.loc 1 1854 0
 477 0368 2CC085E5 		str	ip, [r5, #44]
 478              	.LBB19:
 479              	.LBB18:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 480              		.loc 1 1814 0
 481 036c 00C08DE5 		str	ip, [sp, #0]
 482 0370 FEFFFFEB 		bl	_txe_event_flags_get
 483 0374 004050E2 		subs	r4, r0, #0
 484 0378 EAFFFF1A 		bne	.L32
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 485              		.loc 1 1817 0
 486 037c 0110E0E3 		mvn	r1, #1
 487 0380 0220A0E3 		mov	r2, #2
 488 0384 0500A0E1 		mov	r0, r5
 489              	.L37:
 490 0388 FEFFFFEB 		bl	_txe_event_flags_set
1820:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 491              		.loc 1 1820 0
 492 038c 0500A0E1 		mov	r0, r5
 493 0390 0210A0E3 		mov	r1, #2
 494 0394 0420A0E1 		mov	r2, r4
 495 0398 FEFFFFEB 		bl	_txe_event_flags_set
 496 039c E1FFFFEA 		b	.L32
 497              	.LVL45:
 498              	.L36:
 499              	.LBE18:
 500              	.LBE19:
1836:../uvc.c      ****             gpif_initialized = 0;
 501              		.loc 1 1836 0
 502 03a0 B8509FE5 		ldr	r5, .L39
1834:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 503              		.loc 1 1834 0
 504 03a4 BC109FE5 		ldr	r1, .L39+8
 505              	.LVL46:
 506 03a8 0020A0E1 		mov	r2, r0
 507 03ac FEFFFFEB 		bl	CyU3PDebugPrint
 508              	.LVL47:
1835:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 509              		.loc 1 1835 0
 510 03b0 0100A0E3 		mov	r0, #1
 511 03b4 FEFFFFEB 		bl	CyU3PGpifDisable
1836:../uvc.c      ****             gpif_initialized = 0;
 512              		.loc 1 1836 0
 513 03b8 00C0A0E3 		mov	ip, #0
 514              	.LBB20:
 515              	.LBB21:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 516              		.loc 1 1814 0
 517 03bc 0110A0E3 		mov	r1, #1
 518 03c0 0220A0E3 		mov	r2, #2
 519 03c4 0500A0E1 		mov	r0, r5
 520 03c8 0C308DE2 		add	r3, sp, #12
 521              	.LBE21:
 522              	.LBE20:
1836:../uvc.c      ****             gpif_initialized = 0;
 523              		.loc 1 1836 0
 524 03cc 28C085E5 		str	ip, [r5, #40]
1837:../uvc.c      ****             streamingStarted = CyFalse;
 525              		.loc 1 1837 0
 526 03d0 2CC085E5 		str	ip, [r5, #44]
 527              	.LBB23:
 528              	.LBB22:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 529              		.loc 1 1814 0
 530 03d4 00C08DE5 		str	ip, [sp, #0]
 531 03d8 FEFFFFEB 		bl	_txe_event_flags_get
 532 03dc 004050E2 		subs	r4, r0, #0
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 533              		.loc 1 1817 0
 534 03e0 0500A001 		moveq	r0, r5
 535 03e4 0110E003 		mvneq	r1, #1
 536 03e8 0220A003 		moveq	r2, #2
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 537              		.loc 1 1814 0
 538 03ec CDFFFF1A 		bne	.L32
 539 03f0 E4FFFFEA 		b	.L37
 540              	.LVL48:
 541              	.L35:
 542              	.LBE22:
 543              	.LBE23:
1844:../uvc.c      ****             gpif_initialized = 0;
 544              		.loc 1 1844 0
 545 03f4 64509FE5 		ldr	r5, .L39
1842:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 546              		.loc 1 1842 0
 547 03f8 0020A0E1 		mov	r2, r0
 548 03fc 68109FE5 		ldr	r1, .L39+12
 549              	.LVL49:
 550 0400 0400A0E3 		mov	r0, #4
 551              	.LVL50:
 552 0404 FEFFFFEB 		bl	CyU3PDebugPrint
1843:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 553              		.loc 1 1843 0
 554 0408 0100A0E3 		mov	r0, #1
 555 040c FEFFFFEB 		bl	CyU3PGpifDisable
1844:../uvc.c      ****             gpif_initialized = 0;
 556              		.loc 1 1844 0
 557 0410 0060A0E3 		mov	r6, #0
 558              	.LBB24:
 559              	.LBB25:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 560              		.loc 1 1814 0
 561 0414 0500A0E1 		mov	r0, r5
 562 0418 0110A0E3 		mov	r1, #1
 563 041c 0420A0E1 		mov	r2, r4
 564 0420 0C308DE2 		add	r3, sp, #12
 565              	.LBE25:
 566              	.LBE24:
1844:../uvc.c      ****             gpif_initialized = 0;
 567              		.loc 1 1844 0
 568 0424 286085E5 		str	r6, [r5, #40]
1845:../uvc.c      ****             streamingStarted = CyFalse;
 569              		.loc 1 1845 0
 570 0428 2C6085E5 		str	r6, [r5, #44]
 571              	.LBB27:
 572              	.LBB26:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 573              		.loc 1 1814 0
 574 042c 00608DE5 		str	r6, [sp, #0]
 575 0430 FEFFFFEB 		bl	_txe_event_flags_get
 576 0434 006050E2 		subs	r6, r0, #0
 577 0438 BAFFFF1A 		bne	.L32
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 578              		.loc 1 1817 0
 579 043c 0420A0E1 		mov	r2, r4
 580 0440 0500A0E1 		mov	r0, r5
 581 0444 0110E0E3 		mvn	r1, #1
 582 0448 FEFFFFEB 		bl	_txe_event_flags_set
1820:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 583              		.loc 1 1820 0
 584 044c 0500A0E1 		mov	r0, r5
 585 0450 0410A0E1 		mov	r1, r4
 586 0454 0620A0E1 		mov	r2, r6
 587 0458 FEFFFFEB 		bl	_txe_event_flags_set
 588 045c B1FFFFEA 		b	.L32
 589              	.L40:
 590              		.align	2
 591              	.L39:
 592 0460 00000000 		.word	.LANCHOR0
 593 0464 94000000 		.word	.LC5
 594 0468 50000000 		.word	.LC3
 595 046c 70000000 		.word	.LC4
 596              	.LBE26:
 597              	.LBE27:
 598              		.cfi_endproc
 599              	.LFE9:
 601              		.align	2
 602              		.global	CyFxUvcApplnDmaCallback
 604              	CyFxUvcApplnDmaCallback:
 605              	.LFB11:
2027:../uvc.c      **** {
 606              		.loc 1 2027 0
 607              		.cfi_startproc
 608              		@ args = 0, pretend = 0, frame = 0
 609              		@ frame_needed = 0, uses_anonymous_args = 0
 610              	.LVL51:
2034:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 611              		.loc 1 2034 0
 612 0470 080051E3 		cmp	r1, #8
2027:../uvc.c      **** {
 613              		.loc 1 2027 0
 614 0474 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 615              	.LCFI5:
 616              		.cfi_def_cfa_offset 20
 617 0478 0250A0E1 		mov	r5, r2
 618              		.cfi_offset 14, -4
 619              		.cfi_offset 7, -8
 620              		.cfi_offset 6, -12
 621              		.cfi_offset 5, -16
 622              		.cfi_offset 4, -20
 623 047c 0CD04DE2 		sub	sp, sp, #12
 624              	.LCFI6:
 625              		.cfi_def_cfa_offset 32
2034:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 626              		.loc 1 2034 0
 627 0480 0B00000A 		beq	.L47
2086:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 628              		.loc 1 2086 0
 629 0484 100051E3 		cmp	r1, #16
 630 0488 0700001A 		bne	.L41
2088:../uvc.c      ****         consCount++;
 631              		.loc 1 2088 0
 632 048c 7C319FE5 		ldr	r3, .L50
2089:../uvc.c      ****         streamingStarted = CyTrue;
 633              		.loc 1 2089 0
 634 0490 0120A0E3 		mov	r2, #1
 635              	.LVL52:
2088:../uvc.c      ****         consCount++;
 636              		.loc 1 2088 0
 637 0494 B204D3E1 		ldrh	r0, [r3, #66]
 638              	.LVL53:
2089:../uvc.c      ****         streamingStarted = CyTrue;
 639              		.loc 1 2089 0
 640 0498 2C2083E5 		str	r2, [r3, #44]
2088:../uvc.c      ****         consCount++;
 641              		.loc 1 2088 0
 642 049c 02C080E0 		add	ip, r0, r2
 643 04a0 0C18A0E1 		mov	r1, ip, asl #16
 644              	.LVL54:
 645 04a4 2128A0E1 		mov	r2, r1, lsr #16
 646 04a8 B224C3E1 		strh	r2, [r3, #66]	@ movhi
 647              	.L41:
2091:../uvc.c      **** }
 648              		.loc 1 2091 0
 649 04ac 0CD08DE2 		add	sp, sp, #12
 650 04b0 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 651              	.LVL55:
 652              	.L47:
2036:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 653              		.loc 1 2036 0
 654 04b4 B420D2E1 		ldrh	r2, [r2, #4]
 655 04b8 54319FE5 		ldr	r3, .L50+4
 656 04bc 030052E1 		cmp	r2, r3
 657 04c0 3500000A 		beq	.L48
2056:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 658              		.loc 1 2056 0
 659 04c4 006095E5 		ldr	r6, [r5, #0]
 660              	.LBB32:
 661              	.LBB34:
1775:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 662              		.loc 1 1775 0
 663 04c8 48719FE5 		ldr	r7, .L50+8
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 664              		.loc 1 1774 0
 665 04cc 0010E0E3 		mvn	r1, #0
 666              	.LVL56:
 667              	.LBE34:
 668              	.LBE32:
2056:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 669              		.loc 1 2056 0
 670 04d0 0C4046E2 		sub	r4, r6, #12
 671              	.LVL57:
 672              	.LBB36:
 673              	.LBB33:
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 674              		.loc 1 1774 0
 675 04d4 40019FE5 		ldr	r0, .L50+12
 676              	.LVL58:
 677 04d8 FEFFFFEB 		bl	_txe_mutex_get
1775:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 678              		.loc 1 1775 0
 679 04dc 0400A0E1 		mov	r0, r4
 680 04e0 121D87E2 		add	r1, r7, #1152
 681 04e4 0C20A0E3 		mov	r2, #12
 682 04e8 FEFFFFEB 		bl	CyU3PMemCopy
1776:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 683              		.loc 1 1776 0
 684 04ec 28019FE5 		ldr	r0, .L50+12
 685 04f0 FEFFFFEB 		bl	_txe_mutex_put
1781:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 686              		.loc 1 1781 0
 687 04f4 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 688              	.LBE33:
 689              	.LBE36:
2057:../uvc.c      ****                 pb++;
 690              		.loc 1 2057 0
 691 04f8 10419FE5 		ldr	r4, .L50
 692              	.LVL59:
 693              	.LBB37:
 694              	.LBB35:
1781:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 695              		.loc 1 1781 0
 696 04fc 02108CE3 		orr	r1, ip, #2
 697 0500 0B1046E5 		strb	r1, [r6, #-11]
 698              	.LBE35:
 699              	.LBE37:
2057:../uvc.c      ****                 pb++;
 700              		.loc 1 2057 0
 701 0504 B603D4E1 		ldrh	r0, [r4, #54]
2063:../uvc.c      ****                 if(stiflag == 0x0F){
 702              		.loc 1 2063 0
 703 0508 3A20D4E5 		ldrb	r2, [r4, #58]	@ zero_extendqisi2
2058:../uvc.c      ****                 pbc = input->buffer_p.count;
 704              		.loc 1 2058 0
 705 050c B410D5E1 		ldrh	r1, [r5, #4]
2057:../uvc.c      ****                 pb++;
 706              		.loc 1 2057 0
 707 0510 013080E2 		add	r3, r0, #1
2063:../uvc.c      ****                 if(stiflag == 0x0F){
 708              		.loc 1 2063 0
 709 0514 0F0052E3 		cmp	r2, #15
2057:../uvc.c      ****                 pb++;
 710              		.loc 1 2057 0
 711 0518 B633C4E1 		strh	r3, [r4, #54]	@ movhi
2058:../uvc.c      ****                 pbc = input->buffer_p.count;
 712              		.loc 1 2058 0
 713 051c B813C4E1 		strh	r1, [r4, #56]	@ movhi
2063:../uvc.c      ****                 if(stiflag == 0x0F){
 714              		.loc 1 2063 0
 715 0520 2E00000A 		beq	.L49
 716              	.L45:
2070:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 717              		.loc 1 2070 0
 718 0524 01E0A0E3 		mov	lr, #1
 719 0528 3CE084E5 		str	lr, [r4, #60]
 720              	.LVL60:
 721              	.L44:
2074:../uvc.c      ****             prodCount++;
 722              		.loc 1 2074 0
 723 052c B0E4D4E1 		ldrh	lr, [r4, #64]
2075:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 724              		.loc 1 2075 0
 725 0530 0C1081E2 		add	r1, r1, #12
2074:../uvc.c      ****             prodCount++;
 726              		.loc 1 2074 0
 727 0534 01308EE2 		add	r3, lr, #1
 728 0538 0308A0E1 		mov	r0, r3, asl #16
 729 053c 20C8A0E1 		mov	ip, r0, lsr #16
2075:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 730              		.loc 1 2075 0
 731 0540 0128A0E1 		mov	r2, r1, asl #16
 732 0544 2218A0E1 		mov	r1, r2, lsr #16
 733 0548 D0009FE5 		ldr	r0, .L50+16
 734 054c 0020A0E3 		mov	r2, #0
2074:../uvc.c      ****             prodCount++;
 735              		.loc 1 2074 0
 736 0550 B0C4C4E1 		strh	ip, [r4, #64]	@ movhi
2075:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 737              		.loc 1 2075 0
 738 0554 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 739              	.LVL61:
2074:../uvc.c      ****             prodCount++;
 740              		.loc 1 2074 0
 741 0558 B0109FE5 		ldr	r1, .L50
2078:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 742              		.loc 1 2078 0
 743 055c 002050E2 		subs	r2, r0, #0
 744 0560 D1FFFF0A 		beq	.L41
2080:../uvc.c      ****                 prodCount--;
 745              		.loc 1 2080 0
 746 0564 B004D1E1 		ldrh	r0, [r1, #64]
 747              	.LVL62:
2081:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 748              		.loc 1 2081 0
 749 0568 B430D5E1 		ldrh	r3, [r5, #4]
2080:../uvc.c      ****                 prodCount--;
 750              		.loc 1 2080 0
 751 056c 01E040E2 		sub	lr, r0, #1
 752 0570 0EC8A0E1 		mov	ip, lr, asl #16
 753 0574 2C08A0E1 		mov	r0, ip, lsr #16
 754 0578 B004C1E1 		strh	r0, [r1, #64]	@ movhi
2081:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 755              		.loc 1 2081 0
 756 057c B0E4D1E1 		ldrh	lr, [r1, #64]
 757 0580 B2C4D1E1 		ldrh	ip, [r1, #66]
 758 0584 0400A0E3 		mov	r0, #4
 759 0588 94109FE5 		ldr	r1, .L50+20
 760 058c 00E08DE5 		str	lr, [sp, #0]
 761 0590 04C08DE5 		str	ip, [sp, #4]
 762 0594 FEFFFFEB 		bl	CyU3PDebugPrint
 763              	.LVL63:
 764 0598 C3FFFFEA 		b	.L41
 765              	.LVL64:
 766              	.L48:
2050:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 767              		.loc 1 2050 0
 768 059c 006095E5 		ldr	r6, [r5, #0]
 769              	.LBB38:
 770              	.LBB39:
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 771              		.loc 1 1774 0
 772 05a0 0010E0E3 		mvn	r1, #0
 773              	.LVL65:
 774              	.LBE39:
 775              	.LBE38:
2051:../uvc.c      ****                 fb++;
 776              		.loc 1 2051 0
 777 05a4 64409FE5 		ldr	r4, .L50
2050:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 778              		.loc 1 2050 0
 779 05a8 0C6046E2 		sub	r6, r6, #12
 780              	.LVL66:
 781              	.LBB41:
 782              	.LBB40:
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 783              		.loc 1 1774 0
 784 05ac 68009FE5 		ldr	r0, .L50+12
 785              	.LVL67:
 786 05b0 FEFFFFEB 		bl	_txe_mutex_get
1775:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 787              		.loc 1 1775 0
 788 05b4 6C109FE5 		ldr	r1, .L50+24
 789 05b8 0600A0E1 		mov	r0, r6
 790 05bc 0C20A0E3 		mov	r2, #12
 791 05c0 FEFFFFEB 		bl	CyU3PMemCopy
1776:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 792              		.loc 1 1776 0
 793 05c4 50009FE5 		ldr	r0, .L50+12
 794 05c8 FEFFFFEB 		bl	_txe_mutex_put
 795              	.LBE40:
 796              	.LBE41:
2051:../uvc.c      ****                 fb++;
 797              		.loc 1 2051 0
 798 05cc B4C3D4E1 		ldrh	ip, [r4, #52]
 799 05d0 B410D5E1 		ldrh	r1, [r5, #4]
 800 05d4 01008CE2 		add	r0, ip, #1
 801 05d8 B403C4E1 		strh	r0, [r4, #52]	@ movhi
 802 05dc D2FFFFEA 		b	.L44
 803              	.LVL68:
 804              	.L49:
2064:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 805              		.loc 1 2064 0
 806 05e0 0010E0E3 		mvn	r1, #0
 807 05e4 30009FE5 		ldr	r0, .L50+12
 808 05e8 FEFFFFEB 		bl	_txe_mutex_get
2065:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 809              		.loc 1 2065 0
 810 05ec 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2066:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 811              		.loc 1 2066 0
 812 05f0 24009FE5 		ldr	r0, .L50+12
2065:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 813              		.loc 1 2065 0
 814 05f4 DF2001E2 		and	r2, r1, #223
 815 05f8 8124C7E5 		strb	r2, [r7, #1153]
2066:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 816              		.loc 1 2066 0
 817 05fc FEFFFFEB 		bl	_txe_mutex_put
2067:../uvc.c      ****                 	stiflag = 0xAA;
 818              		.loc 1 2067 0
 819 0600 5530E0E3 		mvn	r3, #85
 820 0604 3A30C4E5 		strb	r3, [r4, #58]
 821 0608 B410D5E1 		ldrh	r1, [r5, #4]
 822 060c C4FFFFEA 		b	.L45
 823              	.L51:
 824              		.align	2
 825              	.L50:
 826 0610 00000000 		.word	.LANCHOR0
 827 0614 F03F0000 		.word	16368
 828 0618 00000000 		.word	.LANCHOR1
 829 061c 00000000 		.word	imgHdMux
 830 0620 00000000 		.word	glChHandleUVCStream
 831 0624 B4000000 		.word	.LC6
 832 0628 80040000 		.word	.LANCHOR1+1152
 833              		.cfi_endproc
 834              	.LFE11:
 836              		.align	2
 838              	CyFxUVCApplnUSBSetupCB:
 839              	.LFB10:
1875:../uvc.c      **** {
 840              		.loc 1 1875 0
 841              		.cfi_startproc
 842              		@ args = 0, pretend = 0, frame = 8
 843              		@ frame_needed = 0, uses_anonymous_args = 0
 844              	.LVL69:
1880:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 845              		.loc 1 1880 0
 846 062c C0329FE5 		ldr	r3, .L77
1875:../uvc.c      **** {
 847              		.loc 1 1875 0
 848 0630 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 849              	.LCFI7:
 850              		.cfi_def_cfa_offset 24
1881:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 851              		.loc 1 1881 0
 852 0634 BCC29FE5 		ldr	ip, .L77+4
1880:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 853              		.loc 1 1880 0
 854 0638 FF4000E2 		and	r4, r0, #255
 855              		.cfi_offset 14, -4
 856              		.cfi_offset 8, -8
 857              		.cfi_offset 7, -12
 858              		.cfi_offset 6, -16
 859              		.cfi_offset 5, -20
 860              		.cfi_offset 4, -24
1881:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 861              		.loc 1 1881 0
 862 063c FF8C00E2 		and	r8, r0, #65280
1882:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 863              		.loc 1 1882 0
 864 0640 2078A0E1 		mov	r7, r0, lsr #16
1880:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 865              		.loc 1 1880 0
 866 0644 0040C3E5 		strb	r4, [r3, #0]
1882:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 867              		.loc 1 1882 0
 868 0648 AC229FE5 		ldr	r2, .L77+8
1883:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 869              		.loc 1 1883 0
 870 064c AC029FE5 		ldr	r0, .L77+12
 871              	.LVL70:
1884:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 872              		.loc 1 1884 0
 873 0650 AC329FE5 		ldr	r3, .L77+16
1883:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 874              		.loc 1 1883 0
 875 0654 0158A0E1 		mov	r5, r1, asl #16
1881:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 876              		.loc 1 1881 0
 877 0658 2884A0E1 		mov	r8, r8, lsr #8
1883:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 878              		.loc 1 1883 0
 879 065c 2558A0E1 		mov	r5, r5, lsr #16
1884:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 880              		.loc 1 1884 0
 881 0660 2118A0E1 		mov	r1, r1, lsr #16
 882              	.LVL71:
1887:../uvc.c      ****     switch (bmReqType)
 883              		.loc 1 1887 0
 884 0664 020054E3 		cmp	r4, #2
1875:../uvc.c      **** {
 885              		.loc 1 1875 0
 886 0668 10D04DE2 		sub	sp, sp, #16
 887              	.LCFI8:
 888              		.cfi_def_cfa_offset 40
1881:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 889              		.loc 1 1881 0
 890 066c 0080CCE5 		strb	r8, [ip, #0]
1882:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 891              		.loc 1 1882 0
 892 0670 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1883:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 893              		.loc 1 1883 0
 894 0674 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1884:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 895              		.loc 1 1884 0
 896 0678 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1887:../uvc.c      ****     switch (bmReqType)
 897              		.loc 1 1887 0
 898 067c 4F00000A 		beq	.L55
 899 0680 0600009A 		bls	.L73
 900 0684 210054E3 		cmp	r4, #33
 901 0688 3A00000A 		beq	.L56
 902 068c A10054E3 		cmp	r4, #161
 903 0690 3800000A 		beq	.L56
 904              	.L70:
1876:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 905              		.loc 1 1876 0
 906 0694 0000A0E3 		mov	r0, #0
 907              	.LVL72:
 908              	.L53:
2014:../uvc.c      **** }
 909              		.loc 1 2014 0
 910 0698 10D08DE2 		add	sp, sp, #16
 911 069c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 912              	.LVL73:
 913              	.L73:
1887:../uvc.c      ****     switch (bmReqType)
 914              		.loc 1 1887 0
 915 06a0 010054E3 		cmp	r4, #1
 916 06a4 FAFFFF1A 		bne	.L70
1927:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 917              		.loc 1 1927 0
 918 06a8 0B0058E3 		cmp	r8, #11
 919 06ac F8FFFF1A 		bne	.L70
1931:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 920              		.loc 1 1931 0
 921 06b0 010055E3 		cmp	r5, #1
 922 06b4 F6FFFF1A 		bne	.L70
1931:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 923              		.loc 1 1931 0 is_stmt 0 discriminator 1
 924 06b8 000057E3 		cmp	r7, #0
 925 06bc F4FFFF1A 		bne	.L70
1936:../uvc.c      ****                     gpif_initialized = 0;
 926              		.loc 1 1936 0 is_stmt 1
 927 06c0 40429FE5 		ldr	r4, .L77+20
1934:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 928              		.loc 1 1934 0
 929 06c4 40129FE5 		ldr	r1, .L77+24
 930 06c8 0400A0E3 		mov	r0, #4
 931 06cc FEFFFFEB 		bl	CyU3PDebugPrint
1935:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 932              		.loc 1 1935 0
 933 06d0 0500A0E1 		mov	r0, r5
 934 06d4 FEFFFFEB 		bl	CyU3PGpifDisable
1939:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 935              		.loc 1 1939 0
 936 06d8 0510A0E1 		mov	r1, r5
 937 06dc 8300A0E3 		mov	r0, #131
1936:../uvc.c      ****                     gpif_initialized = 0;
 938              		.loc 1 1936 0
 939 06e0 287084E5 		str	r7, [r4, #40]
1937:../uvc.c      ****                     streamingStarted = CyFalse;
 940              		.loc 1 1937 0
 941 06e4 2C7084E5 		str	r7, [r4, #44]
1939:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 942              		.loc 1 1939 0
 943 06e8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1940:../uvc.c      ****                     CyU3PBusyWait (100);
 944              		.loc 1 1940 0
 945 06ec 6400A0E3 		mov	r0, #100
 946 06f0 FEFFFFEB 		bl	CyU3PBusyWait
1943:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 947              		.loc 1 1943 0
 948 06f4 14029FE5 		ldr	r0, .L77+28
 949 06f8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1944:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 950              		.loc 1 1944 0
 951 06fc 8300A0E3 		mov	r0, #131
 952 0700 FEFFFFEB 		bl	CyU3PUsbFlushEp
1945:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 953              		.loc 1 1945 0
 954 0704 0710A0E1 		mov	r1, r7
 955 0708 8300A0E3 		mov	r0, #131
 956 070c FEFFFFEB 		bl	CyU3PUsbSetEpNak
1946:../uvc.c      ****                     CyU3PBusyWait (100);
 957              		.loc 1 1946 0
 958 0710 6400A0E3 		mov	r0, #100
 959 0714 FEFFFFEB 		bl	CyU3PBusyWait
1949:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 960              		.loc 1 1949 0
 961 0718 0710A0E1 		mov	r1, r7
 962 071c 0520A0E1 		mov	r2, r5
 963 0720 8300A0E3 		mov	r0, #131
 964 0724 FEFFFFEB 		bl	CyU3PUsbStall
 965              	.LVL74:
1952:../uvc.c      ****                     CyU3PUsbAckSetup ();
 966              		.loc 1 1952 0
 967 0728 FEFFFFEB 		bl	CyU3PUsbAckSetup
1954:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 968              		.loc 1 1954 0
 969 072c 445084E5 		str	r5, [r4, #68]
 970              	.LBB46:
 971              	.LBB47:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 972              		.loc 1 1814 0
 973 0730 0400A0E1 		mov	r0, r4
 974 0734 0510A0E1 		mov	r1, r5
 975 0738 0220A0E3 		mov	r2, #2
 976 073c 0C308DE2 		add	r3, sp, #12
 977 0740 00708DE5 		str	r7, [sp, #0]
 978 0744 FEFFFFEB 		bl	_txe_event_flags_get
 979 0748 006050E2 		subs	r6, r0, #0
 980 074c 2E00001A 		bne	.L68
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 981              		.loc 1 1817 0
 982 0750 0110E0E3 		mvn	r1, #1
 983 0754 0220A0E3 		mov	r2, #2
 984 0758 0400A0E1 		mov	r0, r4
 985 075c FEFFFFEB 		bl	_txe_event_flags_set
1820:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 986              		.loc 1 1820 0
 987 0760 0400A0E1 		mov	r0, r4
 988 0764 0210A0E3 		mov	r1, #2
 989 0768 0620A0E1 		mov	r2, r6
 990 076c FEFFFFEB 		bl	_txe_event_flags_set
1950:../uvc.c      ****                     uvcHandleReq = CyTrue;
 991              		.loc 1 1950 0
 992 0770 0500A0E1 		mov	r0, r5
 993 0774 C7FFFFEA 		b	.L53
 994              	.LVL75:
 995              	.L56:
 996              	.LBE47:
 997              	.LBE46:
1892:../uvc.c      ****             switch (wIndex & 0xFF)
 998              		.loc 1 1892 0
 999 0778 FF5015E2 		ands	r5, r5, #255
 1000 077c 1A00001A 		bne	.L74
 1001              	.LVL76:
1897:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1002              		.loc 1 1897 0
 1003 0780 0520A0E1 		mov	r2, r5
 1004 0784 7C019FE5 		ldr	r0, .L77+20
 1005 0788 0410A0E3 		mov	r1, #4
 1006 078c FEFFFFEB 		bl	_txe_event_flags_set
 1007              	.LVL77:
1899:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1008              		.loc 1 1899 0
 1009 0790 002050E2 		subs	r2, r0, #0
1896:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1010              		.loc 1 1896 0
 1011 0794 0100A003 		moveq	r0, #1
 1012              	.LVL78:
1899:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1013              		.loc 1 1899 0
 1014 0798 BEFFFF0A 		beq	.L53
1901:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1015              		.loc 1 1901 0
 1016 079c 70119FE5 		ldr	r1, .L77+32
 1017 07a0 0400A0E3 		mov	r0, #4
 1018 07a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1019              	.LVL79:
1902:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1020              		.loc 1 1902 0
 1021 07a8 0500A0E1 		mov	r0, r5
 1022 07ac 0110A0E3 		mov	r1, #1
 1023 07b0 0520A0E1 		mov	r2, r5
 1024 07b4 FEFFFFEB 		bl	CyU3PUsbStall
1896:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1025              		.loc 1 1896 0
 1026 07b8 0100A0E3 		mov	r0, #1
 1027 07bc B5FFFFEA 		b	.L53
 1028              	.LVL80:
 1029              	.L55:
1962:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 1030              		.loc 1 1962 0
 1031 07c0 010058E3 		cmp	r8, #1
 1032 07c4 B2FFFF1A 		bne	.L70
1964:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 1033              		.loc 1 1964 0
 1034 07c8 830055E3 		cmp	r5, #131
 1035 07cc B0FFFF1A 		bne	.L70
1970:../uvc.c      ****                     if (streamingStarted == CyTrue)
 1036              		.loc 1 1970 0
 1037 07d0 30719FE5 		ldr	r7, .L77+20
 1038 07d4 2C6097E5 		ldr	r6, [r7, #44]
 1039 07d8 010056E3 		cmp	r6, #1
 1040 07dc 1500000A 		beq	.L75
 1041              	.LVL81:
2002:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1042              		.loc 1 2002 0
 1043 07e0 FEFFFFEB 		bl	CyU3PUsbAckSetup
2001:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1044              		.loc 1 2001 0
 1045 07e4 0800A0E1 		mov	r0, r8
 1046 07e8 AAFFFFEA 		b	.L53
 1047              	.LVL82:
 1048              	.L74:
1892:../uvc.c      ****             switch (wIndex & 0xFF)
 1049              		.loc 1 1892 0
 1050 07ec 010055E3 		cmp	r5, #1
 1051 07f0 A7FFFF1A 		bne	.L70
 1052              	.LVL83:
1910:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1053              		.loc 1 1910 0
 1054 07f4 0020A0E3 		mov	r2, #0
 1055 07f8 08019FE5 		ldr	r0, .L77+20
 1056 07fc 0810A0E3 		mov	r1, #8
 1057 0800 FEFFFFEB 		bl	_txe_event_flags_set
 1058              	.LVL84:
1912:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1059              		.loc 1 1912 0
 1060 0804 002050E2 		subs	r2, r0, #0
 1061 0808 0100001A 		bne	.L76
 1062              	.LVL85:
 1063              	.L68:
 1064              	.LBB49:
 1065              	.LBB48:
1950:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1066              		.loc 1 1950 0
 1067 080c 0500A0E1 		mov	r0, r5
 1068 0810 A0FFFFEA 		b	.L53
 1069              	.LVL86:
 1070              	.L76:
 1071              	.LBE48:
 1072              	.LBE49:
1915:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1073              		.loc 1 1915 0
 1074 0814 FC109FE5 		ldr	r1, .L77+36
 1075 0818 0400A0E3 		mov	r0, #4
 1076              	.LVL87:
 1077 081c FEFFFFEB 		bl	CyU3PDebugPrint
 1078              	.LVL88:
1916:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1079              		.loc 1 1916 0
 1080 0820 0000A0E3 		mov	r0, #0
 1081 0824 0510A0E1 		mov	r1, r5
 1082 0828 0020A0E1 		mov	r2, r0
 1083 082c FEFFFFEB 		bl	CyU3PUsbStall
1909:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1084              		.loc 1 1909 0
 1085 0830 0500A0E1 		mov	r0, r5
 1086 0834 97FFFFEA 		b	.L53
 1087              	.LVL89:
 1088              	.L75:
1972:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1089              		.loc 1 1972 0
 1090 0838 DC109FE5 		ldr	r1, .L77+40
 1091 083c 0400A0E3 		mov	r0, #4
 1092 0840 FEFFFFEB 		bl	CyU3PDebugPrint
1976:../uvc.c      ****                         gpif_initialized = 0;
 1093              		.loc 1 1976 0
 1094 0844 0080A0E3 		mov	r8, #0
1975:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1095              		.loc 1 1975 0
 1096 0848 0600A0E1 		mov	r0, r6
 1097 084c FEFFFFEB 		bl	CyU3PGpifDisable
1980:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1098              		.loc 1 1980 0
 1099 0850 0610A0E1 		mov	r1, r6
 1100 0854 0500A0E1 		mov	r0, r5
1976:../uvc.c      ****                         gpif_initialized = 0;
 1101              		.loc 1 1976 0
 1102 0858 288087E5 		str	r8, [r7, #40]
1977:../uvc.c      ****                         streamingStarted = CyFalse;
 1103              		.loc 1 1977 0
 1104 085c 2C8087E5 		str	r8, [r7, #44]
1980:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1105              		.loc 1 1980 0
 1106 0860 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1981:../uvc.c      ****                         CyU3PBusyWait (100);
 1107              		.loc 1 1981 0
 1108 0864 6400A0E3 		mov	r0, #100
 1109 0868 FEFFFFEB 		bl	CyU3PBusyWait
1984:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1110              		.loc 1 1984 0
 1111 086c 9C009FE5 		ldr	r0, .L77+28
 1112 0870 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1985:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1113              		.loc 1 1985 0
 1114 0874 0500A0E1 		mov	r0, r5
 1115 0878 FEFFFFEB 		bl	CyU3PUsbFlushEp
1986:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1116              		.loc 1 1986 0
 1117 087c 0810A0E1 		mov	r1, r8
 1118 0880 0500A0E1 		mov	r0, r5
 1119 0884 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1987:../uvc.c      ****                         CyU3PBusyWait (100);
 1120              		.loc 1 1987 0
 1121 0888 6400A0E3 		mov	r0, #100
 1122 088c FEFFFFEB 		bl	CyU3PBusyWait
1990:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1123              		.loc 1 1990 0
 1124 0890 0810A0E1 		mov	r1, r8
 1125 0894 0620A0E1 		mov	r2, r6
 1126 0898 0500A0E1 		mov	r0, r5
 1127 089c FEFFFFEB 		bl	CyU3PUsbStall
 1128              	.LVL90:
1994:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1129              		.loc 1 1994 0
 1130 08a0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1996:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1131              		.loc 1 1996 0
 1132 08a4 446087E5 		str	r6, [r7, #68]
 1133              	.LBB50:
 1134              	.LBB51:
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1135              		.loc 1 1814 0
 1136 08a8 0700A0E1 		mov	r0, r7
 1137 08ac 0610A0E1 		mov	r1, r6
 1138 08b0 0420A0E1 		mov	r2, r4
 1139 08b4 0C308DE2 		add	r3, sp, #12
 1140 08b8 00808DE5 		str	r8, [sp, #0]
 1141 08bc FEFFFFEB 		bl	_txe_event_flags_get
 1142 08c0 005050E2 		subs	r5, r0, #0
1992:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1143              		.loc 1 1992 0
 1144 08c4 0600A011 		movne	r0, r6
1814:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1145              		.loc 1 1814 0
 1146 08c8 72FFFF1A 		bne	.L53
1817:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1147              		.loc 1 1817 0
 1148 08cc 0110E0E3 		mvn	r1, #1
 1149 08d0 0420A0E1 		mov	r2, r4
 1150 08d4 0700A0E1 		mov	r0, r7
 1151 08d8 FEFFFFEB 		bl	_txe_event_flags_set
1820:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1152              		.loc 1 1820 0
 1153 08dc 0700A0E1 		mov	r0, r7
 1154 08e0 0410A0E1 		mov	r1, r4
 1155 08e4 0520A0E1 		mov	r2, r5
 1156 08e8 FEFFFFEB 		bl	_txe_event_flags_set
1992:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1157              		.loc 1 1992 0
 1158 08ec 0600A0E1 		mov	r0, r6
 1159 08f0 68FFFFEA 		b	.L53
 1160              	.L78:
 1161              		.align	2
 1162              	.L77:
 1163 08f4 00000000 		.word	bmReqType
 1164 08f8 00000000 		.word	bRequest
 1165 08fc 00000000 		.word	wValue
 1166 0900 00000000 		.word	wIndex
 1167 0904 00000000 		.word	wLength
 1168 0908 00000000 		.word	.LANCHOR0
 1169 090c 6C010000 		.word	.LC9
 1170 0910 00000000 		.word	glChHandleUVCStream
 1171 0914 00010000 		.word	.LC7
 1172 0918 38010000 		.word	.LC8
 1173 091c 84010000 		.word	.LC10
 1174              	.LBE51:
 1175              	.LBE50:
 1176              		.cfi_endproc
 1177              	.LFE10:
 1179              		.align	2
 1180              		.global	CyFxGpifCB
 1182              	CyFxGpifCB:
 1183              	.LFB13:
2213:../uvc.c      **** {
 1184              		.loc 1 2213 0
 1185              		.cfi_startproc
 1186              		@ args = 0, pretend = 0, frame = 0
 1187              		@ frame_needed = 0, uses_anonymous_args = 0
 1188              	.LVL91:
2214:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1189              		.loc 1 2214 0
 1190 0920 010050E3 		cmp	r0, #1
2213:../uvc.c      **** {
 1191              		.loc 1 2213 0
 1192 0924 10402DE9 		stmfd	sp!, {r4, lr}
 1193              	.LCFI9:
 1194              		.cfi_def_cfa_offset 8
2213:../uvc.c      **** {
 1195              		.loc 1 2213 0
 1196 0928 0120A0E1 		mov	r2, r1
2214:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1197              		.loc 1 2214 0
 1198 092c 1080BD18 		ldmnefd	sp!, {r4, pc}
 1199              		.cfi_offset 14, -4
 1200              		.cfi_offset 4, -8
 1201              	.LVL92:
 1202              	.LBB56:
 1203              	.LBB57:
2111:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1204              		.loc 1 2111 0
 1205 0930 CC309FE5 		ldr	r3, .L94
 1206 0934 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 1207 0938 030053E3 		cmp	r3, #3
 1208 093c 2100000A 		beq	.L93
2137:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1209              		.loc 1 2137 0
 1210 0940 020053E3 		cmp	r3, #2
 1211 0944 1080BD18 		ldmnefd	sp!, {r4, pc}
2139:../uvc.c      ****         switch (stateId)
 1212              		.loc 1 2139 0
 1213 0948 080041E2 		sub	r0, r1, #8
 1214              	.LVL93:
 1215 094c 0A0050E3 		cmp	r0, #10
 1216 0950 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1217 0954 230000EA 		b	.L86
 1218              	.L88:
 1219 0958 88090000 		.word	.L83
 1220 095c E8090000 		.word	.L86
 1221 0960 E8090000 		.word	.L86
 1222 0964 84090000 		.word	.L79
 1223 0968 E8090000 		.word	.L86
 1224 096c E8090000 		.word	.L86
 1225 0970 E8090000 		.word	.L86
 1226 0974 C0090000 		.word	.L92
 1227 0978 E8090000 		.word	.L86
 1228 097c E8090000 		.word	.L86
 1229 0980 84090000 		.word	.L79
 1230              	.LVL94:
 1231              	.L79:
 1232 0984 1080BDE8 		ldmfd	sp!, {r4, pc}
 1233              	.LVL95:
 1234              	.L83:
2122:../uvc.c      ****                 socket = 0;
 1235              		.loc 1 2122 0
 1236 0988 0010A0E3 		mov	r1, #0
 1237              	.LVL96:
 1238              	.L84:
2196:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1239              		.loc 1 2196 0
 1240 098c 74009FE5 		ldr	r0, .L94+4
 1241 0990 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1242              	.LVL97:
2197:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1243              		.loc 1 2197 0
 1244 0994 002050E2 		subs	r2, r0, #0
 1245 0998 F9FFFF0A 		beq	.L79
2199:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1246              		.loc 1 2199 0
 1247 099c 0400A0E3 		mov	r0, #4
 1248              	.LVL98:
 1249 09a0 64109FE5 		ldr	r1, .L94+8
 1250 09a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1251              	.LVL99:
 1252              	.L89:
 1253              	.LBB58:
 1254              	.LBB59:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1255              		.loc 1 1801 0
 1256 09a8 60109FE5 		ldr	r1, .L94+12
 1257 09ac 0400A0E3 		mov	r0, #4
 1258 09b0 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 1259              		.loc 1 1802 0
 1260 09b4 FA0FA0E3 		mov	r0, #1000
 1261 09b8 FEFFFFEB 		bl	_tx_thread_sleep
 1262 09bc F9FFFFEA 		b	.L89
 1263              	.LVL100:
 1264              	.L92:
 1265              	.LBE59:
 1266              	.LBE58:
2166:../uvc.c      ****                 socket = 1;
 1267              		.loc 1 2166 0
 1268 09c0 0110A0E3 		mov	r1, #1
 1269              	.LVL101:
 1270 09c4 F0FFFFEA 		b	.L84
 1271              	.LVL102:
 1272              	.L93:
2113:../uvc.c      ****         switch (stateId)
 1273              		.loc 1 2113 0
 1274 09c8 0B2041E2 		sub	r2, r1, #11
 1275 09cc 030052E3 		cmp	r2, #3
 1276 09d0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1277 09d4 060000EA 		b	.L82
 1278              	.L85:
 1279 09d8 88090000 		.word	.L83
 1280 09dc C0090000 		.word	.L92
 1281 09e0 84090000 		.word	.L79
 1282 09e4 84090000 		.word	.L79
 1283              	.LVL103:
 1284              	.L86:
2185:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1285              		.loc 1 2185 0
 1286 09e8 24109FE5 		ldr	r1, .L94+16
 1287              	.LVL104:
 1288 09ec 0100A0E3 		mov	r0, #1
 1289 09f0 FEFFFFEB 		bl	CyU3PDebugPrint
 1290              	.LVL105:
 1291              	.L82:
 1292              	.LBE57:
 1293              	.LBE56:
2220:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1294              		.loc 1 2220 0
 1295 09f4 1C109FE5 		ldr	r1, .L94+20
 1296 09f8 0400A0E3 		mov	r0, #4
2223:../uvc.c      **** }
 1297              		.loc 1 2223 0
 1298 09fc 1040BDE8 		ldmfd	sp!, {r4, lr}
2220:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1299              		.loc 1 2220 0
 1300 0a00 FEFFFFEA 		b	CyU3PDebugPrint
 1301              	.L95:
 1302              		.align	2
 1303              	.L94:
 1304 0a04 00000000 		.word	.LANCHOR0
 1305 0a08 00000000 		.word	glChHandleUVCStream
 1306 0a0c C0010000 		.word	.LC12
 1307 0a10 F0010000 		.word	.LC13
 1308 0a14 A8010000 		.word	.LC11
 1309 0a18 04020000 		.word	.LC14
 1310              		.cfi_endproc
 1311              	.LFE13:
 1313              		.align	2
 1314              		.global	I2CCmdHandler
 1316              	I2CCmdHandler:
 1317              	.LFB0:
 606:../uvc.c      **** void I2CCmdHandler(){
 1318              		.loc 1 606 0
 1319              		.cfi_startproc
 1320              		@ args = 0, pretend = 0, frame = 16
 1321              		@ frame_needed = 0, uses_anonymous_args = 0
 1322 0a1c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1323              	.LCFI10:
 1324              		.cfi_def_cfa_offset 36
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1325              		.loc 1 609 0
 1326 0a20 40429FE5 		ldr	r4, .L111
 1327              		.cfi_offset 14, -4
 1328              		.cfi_offset 11, -8
 1329              		.cfi_offset 10, -12
 1330              		.cfi_offset 9, -16
 1331              		.cfi_offset 8, -20
 1332              		.cfi_offset 7, -24
 1333              		.cfi_offset 6, -28
 1334              		.cfi_offset 5, -32
 1335              		.cfi_offset 4, -36
 606:../uvc.c      **** void I2CCmdHandler(){
 1336              		.loc 1 606 0
 1337 0a24 3CD04DE2 		sub	sp, sp, #60
 1338              	.LCFI11:
 1339              		.cfi_def_cfa_offset 96
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1340              		.loc 1 614 0
 1341 0a28 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
 609:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1342              		.loc 1 609 0
 1343 0a2c 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1344              	.LVL106:
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1345              		.loc 1 610 0
 1346 0a30 4D70D4E5 		ldrb	r7, [r4, #77]	@ zero_extendqisi2
 1347              	.LVL107:
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1348              		.loc 1 611 0
 1349 0a34 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1350              	.LVL108:
 614:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1351              		.loc 1 614 0
 1352 0a38 4EE0D4E5 		ldrb	lr, [r4, #78]	@ zero_extendqisi2
 1353 0a3c 4F80D4E5 		ldrb	r8, [r4, #79]	@ zero_extendqisi2
 1354 0a40 50A0D4E5 		ldrb	sl, [r4, #80]	@ zero_extendqisi2
 1355 0a44 5190D4E5 		ldrb	r9, [r4, #81]	@ zero_extendqisi2
 1356 0a48 52B0D4E5 		ldrb	fp, [r4, #82]	@ zero_extendqisi2
 1357 0a4c 14208DE5 		str	r2, [sp, #20]
 1358 0a50 5510D4E5 		ldrb	r1, [r4, #85]	@ zero_extendqisi2
 1359 0a54 0730A0E1 		mov	r3, r7
 1360 0a58 1C108DE5 		str	r1, [sp, #28]
 1361 0a5c 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1362 0a60 0400A0E3 		mov	r0, #4
 1363 0a64 00129FE5 		ldr	r1, .L111+4
 1364 0a68 0520A0E1 		mov	r2, r5
 1365 0a6c 00E08DE5 		str	lr, [sp, #0]
 1366 0a70 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1367 0a74 0C908DE5 		str	r9, [sp, #12]
 1368 0a78 10B08DE5 		str	fp, [sp, #16]
 1369 0a7c 18608DE5 		str	r6, [sp, #24]
 1370 0a80 20C08DE5 		str	ip, [sp, #32]
 1371 0a84 FEFFFFEB 		bl	CyU3PDebugPrint
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1372              		.loc 1 617 0
 1373 0a88 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 1374 0a8c 520053E3 		cmp	r3, #82
 1375 0a90 2C00000A 		beq	.L107
 1376              	.L97:
 627:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1377              		.loc 1 627 0
 1378 0a94 000055E3 		cmp	r5, #0
 1379 0a98 1600000A 		beq	.L108
 652:../uvc.c      **** 	}else if(CmdType == 1){
 1380              		.loc 1 652 0
 1381 0a9c 010055E3 		cmp	r5, #1
 1382 0aa0 0100000A 		beq	.L109
 1383              	.LVL109:
 1384              	.L96:
 671:../uvc.c      **** }
 1385              		.loc 1 671 0
 1386 0aa4 3CD08DE2 		add	sp, sp, #60
 1387 0aa8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1388              	.LVL110:
 1389              	.L109:
 654:../uvc.c      **** 			if(CmdRegLen == 2){
 1390              		.loc 1 654 0
 1391 0aac 020057E3 		cmp	r7, #2
 1392 0ab0 3700000A 		beq	.L110
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1393              		.loc 1 659 0
 1394 0ab4 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1395 0ab8 A8319FE5 		ldr	r3, .L111
 1396 0abc FE1001E2 		and	r1, r1, #254
 1397 0ac0 820051E3 		cmp	r1, #130
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1398              		.loc 1 662 0
 1399 0ac4 5050D315 		ldrneb	r5, [r3, #80]	@ zero_extendqisi2
 1400              	.LVL111:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1401              		.loc 1 659 0
 1402 0ac8 0200001A 		bne	.L106
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1403              		.loc 1 659 0 is_stmt 0 discriminator 1
 1404 0acc 5050D3E5 		ldrb	r5, [r3, #80]	@ zero_extendqisi2
 1405 0ad0 300055E3 		cmp	r5, #48
 1406 0ad4 4F00000A 		beq	.L104
 1407              	.L106:
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1408              		.loc 1 662 0 is_stmt 1
 1409 0ad8 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1410              	.L105:
 664:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1411              		.loc 1 664 0
 1412 0adc 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1413 0ae0 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1414 0ae4 FE0002E2 		and	r0, r2, #254
 1415 0ae8 0520A0E1 		mov	r2, r5
 1416 0aec 00E08DE5 		str	lr, [sp, #0]
 1417 0af0 FEFFFFEB 		bl	SensorWrite2B
 1418 0af4 EAFFFFEA 		b	.L96
 1419              	.LVL112:
 1420              	.L108:
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1421              		.loc 1 643 0
 1422 0af8 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1423 0afc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1424              		.loc 1 629 0
 1425 0b00 0FE0A0E3 		mov	lr, #15
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1426              		.loc 1 643 0
 1427 0b04 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 1428 0b08 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 629:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1429              		.loc 1 629 0
 1430 0b0c 57E0C4E5 		strb	lr, [r4, #87]
 643:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1431              		.loc 1 643 0
 1432 0b10 34C08DE2 		add	ip, sp, #52
 1433 0b14 010080E3 		orr	r0, r0, #1
 1434 0b18 011081E3 		orr	r1, r1, #1
 1435 0b1c 00C08DE5 		str	ip, [sp, #0]
 1436 0b20 FEFFFFEB 		bl	SensorRead2B
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1437              		.loc 1 644 0
 1438 0b24 3430DDE5 		ldrb	r3, [sp, #52]	@ zero_extendqisi2
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 1439              		.loc 1 645 0
 1440 0b28 020056E3 		cmp	r6, #2
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1441              		.loc 1 644 0
 1442 0b2c 5530C4E5 		strb	r3, [r4, #85]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1443              		.loc 1 646 0
 1444 0b30 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1445 0b34 2C319F05 		ldreq	r3, .L111
 648:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1446              		.loc 1 648 0
 1447 0b38 0020E0E3 		mvn	r2, #0
 1448 0b3c 5720C4E5 		strb	r2, [r4, #87]
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1449              		.loc 1 646 0
 1450 0b40 5600C305 		streqb	r0, [r3, #86]
 1451 0b44 D6FFFFEA 		b	.L96
 1452              	.L107:
 617:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 1453              		.loc 1 617 0 discriminator 1
 1454 0b48 5000D4E5 		ldrb	r0, [r4, #80]	@ zero_extendqisi2
 1455 0b4c 300050E3 		cmp	r0, #48
 1456 0b50 CFFFFF1A 		bne	.L97
 1457 0b54 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1458 0b58 010053E3 		cmp	r3, #1
 1459 0b5c CCFFFF1A 		bne	.L97
 619:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1460              		.loc 1 619 0
 1461 0b60 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 1462 0b64 04C19FE5 		ldr	ip, .L111+8
 1463 0b68 031002E2 		and	r1, r2, #3
 1464 0b6c 8C14CCE5 		strb	r1, [ip, #1164]
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1465              		.loc 1 620 0
 1466 0b70 58E094E5 		ldr	lr, [r4, #88]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1467              		.loc 1 624 0
 1468 0b74 F8109FE5 		ldr	r1, .L111+12
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 1469              		.loc 1 620 0
 1470 0b78 00005EE3 		cmp	lr, #0
 622:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1471              		.loc 1 622 0
 1472 0b7c 80208203 		orreq	r2, r2, #128
 1473 0b80 5520C405 		streqb	r2, [r4, #85]
 624:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1474              		.loc 1 624 0
 1475 0b84 8C34DCE5 		ldrb	r3, [ip, #1164]	@ zero_extendqisi2
 1476 0b88 0400A0E3 		mov	r0, #4
 1477 0b8c FEFFFFEB 		bl	CyU3PDebugPrint
 1478 0b90 BFFFFFEA 		b	.L97
 1479              	.L110:
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1480              		.loc 1 656 0
 1481 0b94 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1482 0b98 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1483 0b9c 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1484 0ba0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1485 0ba4 0020A0E3 		mov	r2, #0
 1486 0ba8 FE0000E2 		and	r0, r0, #254
 1487 0bac 00E08DE5 		str	lr, [sp, #0]
 1488 0bb0 FEFFFFEB 		bl	SensorWrite2B2
 1489 0bb4 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1490 0bb8 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1491 0bbc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1492 0bc0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1493 0bc4 FE0002E2 		and	r0, r2, #254
 1494 0bc8 0020A0E3 		mov	r2, #0
 1495 0bcc 00C08DE5 		str	ip, [sp, #0]
 1496 0bd0 FEFFFFEB 		bl	SensorWrite2B2
 1497              	.LVL113:
 1498 0bd4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1499 0bd8 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1500 0bdc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1501 0be0 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1502 0be4 0020A0E3 		mov	r2, #0
 1503 0be8 FE0000E2 		and	r0, r0, #254
 1504 0bec 00C08DE5 		str	ip, [sp, #0]
 1505 0bf0 FEFFFFEB 		bl	SensorWrite2B2
 1506 0bf4 4E20D4E5 		ldrb	r2, [r4, #78]	@ zero_extendqisi2
 1507 0bf8 55C0D4E5 		ldrb	ip, [r4, #85]	@ zero_extendqisi2
 1508 0bfc 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 1509 0c00 5030D4E5 		ldrb	r3, [r4, #80]	@ zero_extendqisi2
 1510 0c04 FE0002E2 		and	r0, r2, #254
 1511 0c08 0020A0E3 		mov	r2, #0
 1512 0c0c 00C08DE5 		str	ip, [sp, #0]
 1513 0c10 FEFFFFEB 		bl	SensorWrite2B2
 1514 0c14 A2FFFFEA 		b	.L96
 1515              	.LVL114:
 1516              	.L104:
 659:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1517              		.loc 1 659 0 discriminator 1
 1518 0c18 5130D3E5 		ldrb	r3, [r3, #81]	@ zero_extendqisi2
 1519 0c1c 100053E3 		cmp	r3, #16
 1520 0c20 ADFFFF1A 		bne	.L105
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1521              		.loc 1 660 0
 1522 0c24 4C409FE5 		ldr	r4, .L111+16
 1523 0c28 0010E0E3 		mvn	r1, #0
 1524 0c2c 1C0094E5 		ldr	r0, [r4, #28]
 1525 0c30 2C308DE5 		str	r3, [sp, #44]
 1526 0c34 FEFFFFEB 		bl	_txe_mutex_get
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1527              		.loc 1 661 0
 1528 0c38 2C309DE5 		ldr	r3, [sp, #44]
 1529 0c3c 00C0A0E3 		mov	ip, #0
 1530 0c40 0320A0E1 		mov	r2, r3
 1531 0c44 0400A0E1 		mov	r0, r4
 1532 0c48 1710A0E3 		mov	r1, #23
 1533 0c4c 0530A0E1 		mov	r3, r5
 1534 0c50 00C08DE5 		str	ip, [sp, #0]
 1535 0c54 04C08DE5 		str	ip, [sp, #4]
 1536 0c58 FEFFFFEB 		bl	cmdSet
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1537              		.loc 1 662 0
 1538 0c5c 1C0094E5 		ldr	r0, [r4, #28]
 1539 0c60 FEFFFFEB 		bl	_txe_mutex_put
 1540 0c64 8EFFFFEA 		b	.L96
 1541              	.L112:
 1542              		.align	2
 1543              	.L111:
 1544 0c68 00000000 		.word	.LANCHOR0
 1545 0c6c 1C020000 		.word	.LC15
 1546 0c70 00000000 		.word	.LANCHOR1
 1547 0c74 68020000 		.word	.LC16
 1548 0c78 00000000 		.word	cmdQu
 1549              		.cfi_endproc
 1550              	.LFE0:
 1552              		.align	2
 1553              		.global	setIrisauto
 1555              	setIrisauto:
 1556              	.LFB1:
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1557              		.loc 1 677 0
 1558              		.cfi_startproc
 1559              		@ args = 0, pretend = 0, frame = 0
 1560              		@ frame_needed = 0, uses_anonymous_args = 0
 1561              	.LVL115:
 1562 0c7c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1563              	.LCFI12:
 1564              		.cfi_def_cfa_offset 16
 1565 0c80 0160A0E1 		mov	r6, r1
 1566              		.cfi_offset 14, -4
 1567              		.cfi_offset 6, -8
 1568              		.cfi_offset 5, -12
 1569              		.cfi_offset 4, -16
 1570 0c84 08D04DE2 		sub	sp, sp, #8
 1571              	.LCFI13:
 1572              		.cfi_def_cfa_offset 24
 677:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1573              		.loc 1 677 0
 1574 0c88 0040A0E1 		mov	r4, r0
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1575              		.loc 1 680 0
 1576 0c8c 0050A0E3 		mov	r5, #0
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1577              		.loc 1 679 0
 1578 0c90 0010E0E3 		mvn	r1, #0
 1579              	.LVL116:
 1580 0c94 1C0090E5 		ldr	r0, [r0, #28]
 1581              	.LVL117:
 1582 0c98 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1583              		.loc 1 680 0
 1584 0c9c 060065E0 		rsb	r0, r5, r6
 1585 0ca0 00C070E2 		rsbs	ip, r0, #0
 1586 0ca4 00C0ACE0 		adc	ip, ip, r0
 1587 0ca8 2010A0E3 		mov	r1, #32
 1588 0cac 2720A0E3 		mov	r2, #39
 1589 0cb0 3030A0E3 		mov	r3, #48
 1590 0cb4 0400A0E1 		mov	r0, r4
 1591 0cb8 00C08DE5 		str	ip, [sp, #0]
 1592 0cbc 04508DE5 		str	r5, [sp, #4]
 1593 0cc0 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1594              		.loc 1 681 0
 1595 0cc4 050056E1 		cmp	r6, r5
 1596 0cc8 0260A003 		moveq	r6, #2
 1597 0ccc 0160A013 		movne	r6, #1
 1598 0cd0 0400A0E1 		mov	r0, r4
 1599 0cd4 2110A0E3 		mov	r1, #33
 1600 0cd8 2520A0E3 		mov	r2, #37
 1601 0cdc 3030A0E3 		mov	r3, #48
 1602 0ce0 00608DE5 		str	r6, [sp, #0]
 1603 0ce4 04508DE5 		str	r5, [sp, #4]
 1604 0ce8 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1605              		.loc 1 682 0
 1606 0cec 1C0094E5 		ldr	r0, [r4, #28]
 683:../uvc.c      **** }
 1607              		.loc 1 683 0
 1608 0cf0 08D08DE2 		add	sp, sp, #8
 1609 0cf4 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1610              		.loc 1 682 0
 1611 0cf8 FEFFFFEA 		b	_txe_mutex_put
 1612              		.cfi_endproc
 1613              	.LFE1:
 1615              		.align	2
 1616              		.global	getShutCtrl
 1618              	getShutCtrl:
 1619              	.LFB2:
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1620              		.loc 1 687 0
 1621              		.cfi_startproc
 1622              		@ args = 0, pretend = 0, frame = 0
 1623              		@ frame_needed = 0, uses_anonymous_args = 0
 1624              	.LVL118:
 692:../uvc.c      **** 	switch (Data){
 1625              		.loc 1 692 0
 1626 0cfc 013040E2 		sub	r3, r0, #1
 687:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1627              		.loc 1 687 0
 1628 0d00 10402DE9 		stmfd	sp!, {r4, lr}
 1629              	.LCFI14:
 1630              		.cfi_def_cfa_offset 8
 1631 0d04 08D04DE2 		sub	sp, sp, #8
 1632              	.LCFI15:
 1633              		.cfi_def_cfa_offset 16
 692:../uvc.c      **** 	switch (Data){
 1634              		.loc 1 692 0
 1635 0d08 090053E3 		cmp	r3, #9
 1636 0d0c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1637 0d10 380000EA 		b	.L117
 1638              		.cfi_offset 14, -4
 1639              		.cfi_offset 4, -8
 1640              	.L120:
 1641 0d14 AC0D0000 		.word	.L118
 1642 0d18 AC0D0000 		.word	.L118
 1643 0d1c AC0D0000 		.word	.L118
 1644 0d20 AC0D0000 		.word	.L118
 1645 0d24 AC0D0000 		.word	.L118
 1646 0d28 3C0D0000 		.word	.L119
 1647 0d2c 3C0D0000 		.word	.L119
 1648 0d30 3C0D0000 		.word	.L119
 1649 0d34 3C0D0000 		.word	.L119
 1650 0d38 3C0D0000 		.word	.L119
 1651              	.L119:
 1652              	.LVL119:
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1653              		.loc 1 716 0
 1654 0d3c ECC09FE5 		ldr	ip, .L129
 714:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1655              		.loc 1 714 0
 1656 0d40 8330A0E1 		mov	r3, r3, asl #1
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1657              		.loc 1 716 0
 1658 0d44 B3309CE1 		ldrh	r3, [ip, r3]
 1659 0d48 E4E09FE5 		ldr	lr, .L129+4
 1660 0d4c 032263E0 		rsb	r2, r3, r3, asl #4
 1661 0d50 8240A0E1 		mov	r4, r2, asl #1
 1662 0d54 94CECEE0 		smull	ip, lr, r4, lr
 1663 0d58 C4CFA0E1 		mov	ip, r4, asr #31
 1664 0d5c 4E246CE0 		rsb	r2, ip, lr, asr #8
 717:../uvc.c      **** 		if(NumLn > 1944)
 1665              		.loc 1 717 0
 1666 0d60 D0E09FE5 		ldr	lr, .L129+8
 716:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1667              		.loc 1 716 0
 1668 0d64 0228A0E1 		mov	r2, r2, asl #16
 1669 0d68 22C8A0E1 		mov	ip, r2, lsr #16
 1670              	.LVL120:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1671              		.loc 1 717 0
 1672 0d6c 0E005CE1 		cmp	ip, lr
 1673 0d70 2600008A 		bhi	.L126
 719:../uvc.c      **** 		else if(NumLn < 8)
 1674              		.loc 1 719 0
 1675 0d74 07005CE3 		cmp	ip, #7
 1676 0d78 2700008A 		bhi	.L128
 1677              	.LVL121:
 1678              	.L127:
 1679 0d7c 01C0A0E3 		mov	ip, #1
 1680 0d80 08E0A0E3 		mov	lr, #8
 1681 0d84 0C40A0E1 		mov	r4, ip
 1682              	.L123:
 1683              	.LVL122:
 722:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1684              		.loc 1 722 0
 1685 0d88 0120A0E3 		mov	r2, #1
 1686 0d8c 0020C1E5 		strb	r2, [r1, #0]
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1687              		.loc 1 723 0
 1688 0d90 0020A0E1 		mov	r2, r0
 1689 0d94 A0109FE5 		ldr	r1, .L129+12
 1690              	.LVL123:
 1691 0d98 0400A0E3 		mov	r0, #4
 1692              	.LVL124:
 1693 0d9c 00E08DE5 		str	lr, [sp, #0]
 1694 0da0 04C08DE5 		str	ip, [sp, #4]
 1695 0da4 FEFFFFEB 		bl	CyU3PDebugPrint
 724:../uvc.c      **** 		break;
 1696              		.loc 1 724 0
 1697 0da8 150000EA 		b	.L122
 1698              	.LVL125:
 1699              	.L118:
 698:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1700              		.loc 1 698 0
 1701 0dac 7CE09FE5 		ldr	lr, .L129
 1702 0db0 8330A0E1 		mov	r3, r3, asl #1
 1703 0db4 B3309EE1 		ldrh	r3, [lr, r3]
 1704              	.LVL126:
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1705              		.loc 1 700 0
 1706 0db8 80C09FE5 		ldr	ip, .L129+16
 701:../uvc.c      **** 		if(NumLn > 1944)
 1707              		.loc 1 701 0
 1708 0dbc 74E09FE5 		ldr	lr, .L129+8
 700:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1709              		.loc 1 700 0
 1710 0dc0 932C8CE0 		umull	r2, ip, r3, ip
 1711 0dc4 AC24A0E1 		mov	r2, ip, lsr #9
 1712 0dc8 024262E0 		rsb	r4, r2, r2, asl #4
 1713 0dcc 8448A0E1 		mov	r4, r4, asl #17
 1714 0dd0 2428A0E1 		mov	r2, r4, lsr #16
 1715              	.LVL127:
 701:../uvc.c      **** 		if(NumLn > 1944)
 1716              		.loc 1 701 0
 1717 0dd4 0E0052E1 		cmp	r2, lr
 1718 0dd8 0C00008A 		bhi	.L126
 703:../uvc.c      **** 		else if(NumLn < 8)
 1719              		.loc 1 703 0
 1720 0ddc 070052E3 		cmp	r2, #7
 1721 0de0 E5FFFF9A 		bls	.L127
 1722 0de4 A449A0E1 		mov	r4, r4, lsr #19
 1723 0de8 FF4004E2 		and	r4, r4, #255
 1724 0dec 02E0A0E1 		mov	lr, r2
 1725 0df0 04C0A0E1 		mov	ip, r4
 1726 0df4 E3FFFFEA 		b	.L123
 1727              	.LVL128:
 1728              	.L117:
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1729              		.loc 1 727 0
 1730 0df8 0000A0E3 		mov	r0, #0
 1731              	.LVL129:
 728:../uvc.c      **** 		LnVal = 1;
 1732              		.loc 1 728 0
 1733 0dfc 0140A0E3 		mov	r4, #1
 727:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1734              		.loc 1 727 0
 1735 0e00 0000C1E5 		strb	r0, [r1, #0]
 1736              	.LVL130:
 1737              	.L122:
 732:../uvc.c      **** }
 1738              		.loc 1 732 0
 1739 0e04 0400A0E1 		mov	r0, r4
 1740 0e08 08D08DE2 		add	sp, sp, #8
 1741 0e0c 1080BDE8 		ldmfd	sp!, {r4, pc}
 1742              	.LVL131:
 1743              	.L126:
 717:../uvc.c      **** 		if(NumLn > 1944)
 1744              		.loc 1 717 0
 1745 0e10 F3C0A0E3 		mov	ip, #243
 1746 0e14 0C40A0E1 		mov	r4, ip
 1747 0e18 DAFFFFEA 		b	.L123
 1748              	.LVL132:
 1749              	.L128:
 719:../uvc.c      **** 		else if(NumLn < 8)
 1750              		.loc 1 719 0
 1751 0e1c A2E9A0E1 		mov	lr, r2, lsr #19
 1752 0e20 FF400EE2 		and	r4, lr, #255
 1753 0e24 0CE0A0E1 		mov	lr, ip
 1754 0e28 04C0A0E1 		mov	ip, r4
 1755              	.LVL133:
 1756 0e2c D5FFFFEA 		b	.L123
 1757              	.L130:
 1758              		.align	2
 1759              	.L129:
 1760 0e30 00000000 		.word	.LANCHOR2
 1761 0e34 817F807F 		.word	2139127681
 1762 0e38 98070000 		.word	1944
 1763 0e3c 90020000 		.word	.LC17
 1764 0e40 01FF00FF 		.word	-16711935
 1765              		.cfi_endproc
 1766              	.LFE2:
 1768              		.align	2
 1769              		.global	ControlHandle
 1771              	ControlHandle:
 1772              	.LFB3:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1773              		.loc 1 734 0
 1774              		.cfi_startproc
 1775              		@ args = 0, pretend = 0, frame = 24
 1776              		@ frame_needed = 0, uses_anonymous_args = 0
 1777              	.LVL134:
 1778 0e44 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1779              	.LCFI16:
 1780              		.cfi_def_cfa_offset 36
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1781              		.loc 1 741 0
 1782 0e48 230050E3 		cmp	r0, #35
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1783              		.loc 1 740 0
 1784 0e4c 207040E2 		sub	r7, r0, #32
 1785              		.cfi_offset 14, -4
 1786              		.cfi_offset 11, -8
 1787              		.cfi_offset 10, -12
 1788              		.cfi_offset 9, -16
 1789              		.cfi_offset 8, -20
 1790              		.cfi_offset 7, -24
 1791              		.cfi_offset 6, -28
 1792              		.cfi_offset 5, -32
 1793              		.cfi_offset 4, -36
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1794              		.loc 1 734 0
 1795 0e50 2CD04DE2 		sub	sp, sp, #44
 1796              	.LCFI17:
 1797              		.cfi_def_cfa_offset 80
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1798              		.loc 1 734 0
 1799 0e54 0040A0E1 		mov	r4, r0
 740:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1800              		.loc 1 740 0
 1801 0e58 FF7007E2 		and	r7, r7, #255
 1802              	.LVL135:
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1803              		.loc 1 741 0
 1804 0e5c 2400009A 		bls	.L132
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1805              		.loc 1 742 0
 1806 0e60 586F9FE5 		ldr	r6, .L272
 1807 0e64 872087E0 		add	r2, r7, r7, asl #1
 1808 0e68 8221A0E1 		mov	r2, r2, asl #3
 1809 0e6c 023086E0 		add	r3, r6, r2
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1810              		.loc 1 743 0
 1811 0e70 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1812              		.loc 1 744 0
 1813 0e74 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1814              		.loc 1 745 0
 1815 0e78 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 756:../uvc.c      ****     reqData = bRequest;
 1816              		.loc 1 756 0
 1817 0e7c 403F9FE5 		ldr	r3, .L272+4
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1818              		.loc 1 742 0
 1819 0e80 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 1820              	.LVL136:
 756:../uvc.c      ****     reqData = bRequest;
 1821              		.loc 1 756 0
 1822 0e84 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1823              	.LVL137:
 764:../uvc.c      ****     switch (bRequest)
 1824              		.loc 1 764 0
 1825 0e88 830055E3 		cmp	r5, #131
 1826 0e8c 2300000A 		beq	.L138
 1827              	.LVL138:
 1828              	.L264:
 1829 0e90 2C00009A 		bls	.L262
 1830 0e94 850055E3 		cmp	r5, #133
 1831 0e98 8B00000A 		beq	.L140
 1832 0e9c 7900003A 		bcc	.L139
 1833 0ea0 860055E3 		cmp	r5, #134
 1834 0ea4 C800000A 		beq	.L141
 1835 0ea8 870055E3 		cmp	r5, #135
 1836 0eac BC00000A 		beq	.L263
 1837              	.L134:
1447:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1838              		.loc 1 1447 0
 1839 0eb0 0000A0E3 		mov	r0, #0
 1840 0eb4 0110A0E3 		mov	r1, #1
 1841 0eb8 0020A0E1 		mov	r2, r0
 1842 0ebc FEFFFFEB 		bl	CyU3PUsbStall
1448:../uvc.c      **** 			  break;
 1843              		.loc 1 1448 0
 1844 0ec0 FFC0A0E3 		mov	ip, #255
 1845 0ec4 0C40A0E1 		mov	r4, ip
 1846 0ec8 0C70A0E1 		mov	r7, ip
 1847              	.LVL139:
 1848 0ecc 0C80A0E1 		mov	r8, ip
 1849              	.LVL140:
 1850              	.L144:
1450:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1851              		.loc 1 1450 0
 1852 0ed0 F01E9FE5 		ldr	r1, .L272+8
 1853 0ed4 0520A0E1 		mov	r2, r5
 1854 0ed8 0830A0E1 		mov	r3, r8
 1855 0edc 0400A0E3 		mov	r0, #4
 1856 0ee0 00708DE5 		str	r7, [sp, #0]
 1857 0ee4 10108DE9 		stmib	sp, {r4, ip}	@ phole stm
 1858 0ee8 FEFFFFEB 		bl	CyU3PDebugPrint
1451:../uvc.c      **** }
 1859              		.loc 1 1451 0
 1860 0eec 2CD08DE2 		add	sp, sp, #44
 1861 0ef0 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1862              	.LVL141:
 1863              	.L132:
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1864              		.loc 1 747 0
 1865 0ef4 C46E9FE5 		ldr	r6, .L272
 756:../uvc.c      ****     reqData = bRequest;
 1866              		.loc 1 756 0
 1867 0ef8 C43E9FE5 		ldr	r3, .L272+4
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1868              		.loc 1 747 0
 1869 0efc 805080E0 		add	r5, r0, r0, asl #1
 1870 0f00 850186E0 		add	r0, r6, r5, asl #3
 1871              	.LVL142:
 756:../uvc.c      ****     reqData = bRequest;
 1872              		.loc 1 756 0
 1873 0f04 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 747:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1874              		.loc 1 747 0
 1875 0f08 80A1D0E5 		ldrb	sl, [r0, #384]	@ zero_extendqisi2
 1876              	.LVL143:
 764:../uvc.c      ****     switch (bRequest)
 1877              		.loc 1 764 0
 1878 0f0c 830055E3 		cmp	r5, #131
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1879              		.loc 1 748 0
 1880 0f10 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1881              	.LVL144:
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1882              		.loc 1 749 0
 1883 0f14 8F91D0E5 		ldrb	r9, [r0, #399]	@ zero_extendqisi2
 1884              	.LVL145:
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1885              		.loc 1 750 0
 1886 0f18 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1887              	.LVL146:
 764:../uvc.c      ****     switch (bRequest)
 1888              		.loc 1 764 0
 1889 0f1c DBFFFF1A 		bne	.L264
 1890              	.LVL147:
 1891              	.L138:
 936:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1892              		.loc 1 936 0
 1893 0f20 230054E3 		cmp	r4, #35
 1894 0f24 C600009A 		bls	.L173
 937:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1895              		.loc 1 937 0
 1896 0f28 870087E0 		add	r0, r7, r7, asl #1
 1897 0f2c 806186E0 		add	r6, r6, r0, asl #3
 1898 0f30 D0AE9FE5 		ldr	sl, .L272+72
 1899 0f34 05C0D6E5 		ldrb	ip, [r6, #5]	@ zero_extendqisi2
 938:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1900              		.loc 1 938 0
 1901 0f38 0670D6E5 		ldrb	r7, [r6, #6]	@ zero_extendqisi2
 1902              	.LVL148:
 937:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1903              		.loc 1 937 0
 1904 0f3c 5CC0CAE5 		strb	ip, [sl, #92]
 938:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1905              		.loc 1 938 0
 1906 0f40 5D70CAE5 		strb	r7, [sl, #93]
 1907 0f44 0B0000EA 		b	.L181
 1908              	.LVL149:
 1909              	.L262:
 764:../uvc.c      ****     switch (bRequest)
 1910              		.loc 1 764 0
 1911 0f48 810055E3 		cmp	r5, #129
 1912 0f4c 6A00000A 		beq	.L136
 1913 0f50 1000009A 		bls	.L265
 917:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1914              		.loc 1 917 0
 1915 0f54 230054E3 		cmp	r4, #35
 1916 0f58 AD00009A 		bls	.L170
 918:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1917              		.loc 1 918 0
 1918 0f5c 87A087E0 		add	sl, r7, r7, asl #1
 1919 0f60 8A6186E0 		add	r6, r6, sl, asl #3
 1920 0f64 0320D6E5 		ldrb	r2, [r6, #3]	@ zero_extendqisi2
 1921 0f68 98AE9FE5 		ldr	sl, .L272+72
 919:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1922              		.loc 1 919 0
 1923 0f6c 0440D6E5 		ldrb	r4, [r6, #4]	@ zero_extendqisi2
 918:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1924              		.loc 1 918 0
 1925 0f70 5C20CAE5 		strb	r2, [sl, #92]
 919:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1926              		.loc 1 919 0
 1927 0f74 5D40CAE5 		strb	r4, [sl, #93]
 1928              	.LVL150:
 1929              	.L181:
 994:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1930              		.loc 1 994 0
 1931 0f78 0800A0E1 		mov	r0, r8
 1932 0f7c 481E9FE5 		ldr	r1, .L272+12
 1933 0f80 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1934              	.LVL151:
 996:../uvc.c      **** 			  break;
 1935              		.loc 1 996 0
 1936 0f84 FFC0A0E3 		mov	ip, #255
 994:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1937              		.loc 1 994 0
 1938 0f88 5C40DAE5 		ldrb	r4, [sl, #92]	@ zero_extendqisi2
 996:../uvc.c      **** 			  break;
 1939              		.loc 1 996 0
 1940 0f8c 0C70A0E1 		mov	r7, ip
 1941 0f90 0C80A0E1 		mov	r8, ip
 1942 0f94 CDFFFFEA 		b	.L144
 1943              	.LVL152:
 1944              	.L265:
 764:../uvc.c      ****     switch (bRequest)
 1945              		.loc 1 764 0
 1946 0f98 010055E3 		cmp	r5, #1
 1947 0f9c C3FFFF1A 		bne	.L134
 998:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1948              		.loc 1 998 0
 1949 0fa0 601E9FE5 		ldr	r1, .L272+72
 1950 0fa4 26208DE2 		add	r2, sp, #38
 1951 0fa8 2000A0E3 		mov	r0, #32
 1952 0fac 5C1081E2 		add	r1, r1, #92
 1953 0fb0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1954              	.LVL153:
1000:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1955              		.loc 1 1000 0
 1956 0fb4 002050E2 		subs	r2, r0, #0
 1957 0fb8 E703001A 		bne	.L183
1002:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1958              		.loc 1 1002 0
 1959 0fbc 443E9FE5 		ldr	r3, .L272+72
1003:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1960              		.loc 1 1003 0
 1961 0fc0 40CE9FE5 		ldr	ip, .L272+72
1005:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1962              		.loc 1 1005 0
 1963 0fc4 3C0E9FE5 		ldr	r0, .L272+72
 1964              	.LVL154:
1002:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1965              		.loc 1 1002 0
 1966 0fc8 5C30D3E5 		ldrb	r3, [r3, #92]	@ zero_extendqisi2
1003:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1967              		.loc 1 1003 0
 1968 0fcc 5DC0DCE5 		ldrb	ip, [ip, #93]	@ zero_extendqisi2
1005:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1969              		.loc 1 1005 0
 1970 0fd0 5EE0D0E5 		ldrb	lr, [r0, #94]	@ zero_extendqisi2
1002:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1971              		.loc 1 1002 0
 1972 0fd4 14308DE5 		str	r3, [sp, #20]
 1973              	.LVL155:
1003:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1974              		.loc 1 1003 0
 1975 0fd8 1CC08DE5 		str	ip, [sp, #28]
 1976              	.LVL156:
1005:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1977              		.loc 1 1005 0
 1978 0fdc 18E08DE5 		str	lr, [sp, #24]
 1979              	.LVL157:
1009:../uvc.c      **** 				  switch(CtrlID)
 1980              		.loc 1 1009 0
 1981 0fe0 260054E3 		cmp	r4, #38
 1982 0fe4 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1983 0fe8 3A0300EA 		b	.L184
 1984              	.L202:
 1985 0fec 6C1C0000 		.word	.L185
 1986 0ff0 001C0000 		.word	.L186
 1987 0ff4 D41A0000 		.word	.L187
 1988 0ff8 D81C0000 		.word	.L184
 1989 0ffc 841A0000 		.word	.L188
 1990 1000 48190000 		.word	.L189
 1991 1004 CC180000 		.word	.L190
 1992 1008 0C1E0000 		.word	.L191
 1993 100c D81C0000 		.word	.L184
 1994 1010 D81C0000 		.word	.L184
 1995 1014 D81C0000 		.word	.L184
 1996 1018 3C1D0000 		.word	.L192
 1997 101c D81C0000 		.word	.L184
 1998 1020 D81C0000 		.word	.L184
 1999 1024 D81C0000 		.word	.L184
 2000 1028 D81C0000 		.word	.L184
 2001 102c 8C1E0000 		.word	.L193
 2002 1030 D81C0000 		.word	.L184
 2003 1034 D81C0000 		.word	.L184
 2004 1038 D81C0000 		.word	.L184
 2005 103c D81C0000 		.word	.L184
 2006 1040 D81C0000 		.word	.L184
 2007 1044 D81C0000 		.word	.L184
 2008 1048 D81C0000 		.word	.L184
 2009 104c D81C0000 		.word	.L184
 2010 1050 301B0000 		.word	.L194
 2011 1054 D41A0000 		.word	.L187
 2012 1058 38180000 		.word	.L195
 2013 105c AC170000 		.word	.L196
 2014 1060 D81C0000 		.word	.L184
 2015 1064 50170000 		.word	.L197
 2016 1068 CC160000 		.word	.L198
 2017 106c D81C0000 		.word	.L184
 2018 1070 D81C0000 		.word	.L184
 2019 1074 D81C0000 		.word	.L184
 2020 1078 D81C0000 		.word	.L184
 2021 107c B4150000 		.word	.L199
 2022 1080 40150000 		.word	.L200
 2023 1084 50160000 		.word	.L201
 2024              	.LVL158:
 2025              	.L139:
 954:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2026              		.loc 1 954 0
 2027 1088 230054E3 		cmp	r4, #35
 955:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2028              		.loc 1 955 0
 2029 108c 87708780 		addhi	r7, r7, r7, asl #1
 2030              	.LVL159:
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2031              		.loc 1 961 0
 2032 1090 84408490 		addls	r4, r4, r4, asl #1
 955:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2033              		.loc 1 955 0
 2034 1094 87618680 		addhi	r6, r6, r7, asl #3
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2035              		.loc 1 961 0
 2036 1098 84618690 		addls	r6, r6, r4, asl #3
 955:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2037              		.loc 1 955 0
 2038 109c 64AD9F85 		ldrhi	sl, .L272+72
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2039              		.loc 1 961 0
 2040 10a0 60AD9F95 		ldrls	sl, .L272+72
 955:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2041              		.loc 1 955 0
 2042 10a4 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 956:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2043              		.loc 1 956 0
 2044 10a8 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2045              		.loc 1 961 0
 2046 10ac 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 962:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2047              		.loc 1 962 0
 2048 10b0 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 963:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2049              		.loc 1 963 0
 2050 10b4 0030A0E3 		mov	r3, #0
 961:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2051              		.loc 1 961 0
 2052 10b8 5C10CAE5 		strb	r1, [sl, #92]
 962:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2053              		.loc 1 962 0
 2054 10bc 5D20CAE5 		strb	r2, [sl, #93]
 963:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2055              		.loc 1 963 0
 2056 10c0 5E30CAE5 		strb	r3, [sl, #94]
 964:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2057              		.loc 1 964 0
 2058 10c4 5F30CAE5 		strb	r3, [sl, #95]
 2059 10c8 AAFFFFEA 		b	.L181
 2060              	.LVL160:
 2061              	.L140:
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2062              		.loc 1 768 0
 2063 10cc 344D9FE5 		ldr	r4, .L272+72
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2064              		.loc 1 770 0
 2065 10d0 0200A0E3 		mov	r0, #2
 768:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2066              		.loc 1 768 0
 2067 10d4 5C80C4E5 		strb	r8, [r4, #92]
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2068              		.loc 1 769 0
 2069 10d8 0080A0E3 		mov	r8, #0
 2070 10dc 5D80C4E5 		strb	r8, [r4, #93]
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2071              		.loc 1 770 0
 2072 10e0 5C1084E2 		add	r1, r4, #92
 2073 10e4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2074              	.LVL161:
 772:../uvc.c      **** 			  break;
 2075              		.loc 1 772 0
 2076 10e8 FFC0A0E3 		mov	ip, #255
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2077              		.loc 1 770 0
 2078 10ec 5C40D4E5 		ldrb	r4, [r4, #92]	@ zero_extendqisi2
 772:../uvc.c      **** 			  break;
 2079              		.loc 1 772 0
 2080 10f0 0C70A0E1 		mov	r7, ip
 2081              	.LVL162:
 2082 10f4 0C80A0E1 		mov	r8, ip
 2083 10f8 74FFFFEA 		b	.L144
 2084              	.LVL163:
 2085              	.L136:
 775:../uvc.c      **** 			 switch(CtrlID)
 2086              		.loc 1 775 0
 2087 10fc 260054E3 		cmp	r4, #38
 2088 1100 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2089 1104 040100EA 		b	.L145
 2090              	.L158:
 2091 1108 F0140000 		.word	.L146
 2092 110c C4140000 		.word	.L147
 2093 1110 A8140000 		.word	.L148
 2094 1114 1C150000 		.word	.L145
 2095 1118 1C150000 		.word	.L145
 2096 111c 88140000 		.word	.L149
 2097 1120 1C150000 		.word	.L145
 2098 1124 F0140000 		.word	.L146
 2099 1128 1C150000 		.word	.L145
 2100 112c 1C150000 		.word	.L145
 2101 1130 1C150000 		.word	.L145
 2102 1134 20140000 		.word	.L150
 2103 1138 1C150000 		.word	.L145
 2104 113c 1C150000 		.word	.L145
 2105 1140 1C150000 		.word	.L145
 2106 1144 1C150000 		.word	.L145
 2107 1148 00140000 		.word	.L151
 2108 114c 1C150000 		.word	.L145
 2109 1150 1C150000 		.word	.L145
 2110 1154 1C150000 		.word	.L145
 2111 1158 1C150000 		.word	.L145
 2112 115c 1C150000 		.word	.L145
 2113 1160 1C150000 		.word	.L145
 2114 1164 1C150000 		.word	.L145
 2115 1168 1C150000 		.word	.L145
 2116 116c 44140000 		.word	.L152
 2117 1170 A8140000 		.word	.L148
 2118 1174 E0130000 		.word	.L153
 2119 1178 B8130000 		.word	.L154
 2120 117c 1C150000 		.word	.L145
 2121 1180 1C150000 		.word	.L145
 2122 1184 1C130000 		.word	.L155
 2123 1188 1C150000 		.word	.L145
 2124 118c 1C150000 		.word	.L145
 2125 1190 1C150000 		.word	.L145
 2126 1194 1C150000 		.word	.L145
 2127 1198 F0120000 		.word	.L156
 2128 119c F0120000 		.word	.L156
 2129 11a0 C0120000 		.word	.L157
 2130              	.L263:
 981:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2131              		.loc 1 981 0
 2132 11a4 230054E3 		cmp	r4, #35
 2133 11a8 3100009A 		bls	.L180
 982:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2134              		.loc 1 982 0
 2135 11ac 874087E0 		add	r4, r7, r7, asl #1
 2136 11b0 846186E0 		add	r6, r6, r4, asl #3
 2137 11b4 4CAC9FE5 		ldr	sl, .L272+72
 2138 11b8 0BE0D6E5 		ldrb	lr, [r6, #11]	@ zero_extendqisi2
 983:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2139              		.loc 1 983 0
 2140 11bc 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 982:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2141              		.loc 1 982 0
 2142 11c0 5CE0CAE5 		strb	lr, [sl, #92]
 983:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2143              		.loc 1 983 0
 2144 11c4 5D10CAE5 		strb	r1, [sl, #93]
 2145 11c8 6AFFFFEA 		b	.L181
 2146              	.L141:
 970:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2147              		.loc 1 970 0
 2148 11cc 230054E3 		cmp	r4, #35
 971:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2149              		.loc 1 971 0
 2150 11d0 87708780 		addhi	r7, r7, r7, asl #1
 2151              	.LVL164:
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2152              		.loc 1 974 0
 2153 11d4 84408490 		addls	r4, r4, r4, asl #1
 971:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2154              		.loc 1 971 0
 2155 11d8 87618680 		addhi	r6, r6, r7, asl #3
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2156              		.loc 1 974 0
 2157 11dc 84618690 		addls	r6, r6, r4, asl #3
 971:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2158              		.loc 1 971 0
 2159 11e0 208C9F85 		ldrhi	r8, .L272+72
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2160              		.loc 1 974 0
 2161 11e4 1C8C9F95 		ldrls	r8, .L272+72
 971:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2162              		.loc 1 971 0
 2163 11e8 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2164              		.loc 1 974 0
 2165 11ec 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 976:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2166              		.loc 1 976 0
 2167 11f0 0100A0E3 		mov	r0, #1
 974:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2168              		.loc 1 974 0
 2169 11f4 5C30C8E5 		strb	r3, [r8, #92]
 976:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2170              		.loc 1 976 0
 2171 11f8 CC1B9FE5 		ldr	r1, .L272+12
 2172 11fc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2173              	.LVL165:
 979:../uvc.c      **** 			  break;
 2174              		.loc 1 979 0
 2175 1200 FFC0A0E3 		mov	ip, #255
 976:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2176              		.loc 1 976 0
 2177 1204 5C40D8E5 		ldrb	r4, [r8, #92]	@ zero_extendqisi2
 979:../uvc.c      **** 			  break;
 2178              		.loc 1 979 0
 2179 1208 0C70A0E1 		mov	r7, ip
 2180 120c 0C80A0E1 		mov	r8, ip
 2181 1210 2EFFFFEA 		b	.L144
 2182              	.LVL166:
 2183              	.L170:
 922:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2184              		.loc 1 922 0
 2185 1214 0B0054E3 		cmp	r4, #11
 929:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2186              		.loc 1 929 0
 2187 1218 84408410 		addne	r4, r4, r4, asl #1
 2188 121c 84618610 		addne	r6, r6, r4, asl #3
 2189 1220 E0AB9F15 		ldrne	sl, .L272+72
 923:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2190              		.loc 1 923 0
 2191 1224 DCAB9F05 		ldreq	sl, .L272+72
 2192 1228 A03B9F05 		ldreq	r3, .L272+16
 929:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2193              		.loc 1 929 0
 2194 122c 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 930:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2195              		.loc 1 930 0
 2196 1230 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 923:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2197              		.loc 1 923 0
 2198 1234 5C308A05 		streq	r3, [sl, #92]
 929:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2199              		.loc 1 929 0
 2200 1238 5C20CA15 		strneb	r2, [sl, #92]
 930:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2201              		.loc 1 930 0
 2202 123c 5D30CA15 		strneb	r3, [sl, #93]
 2203 1240 4CFFFFEA 		b	.L181
 2204              	.L173:
 940:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2205              		.loc 1 940 0
 2206 1244 0B0054E3 		cmp	r4, #11
 947:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2207              		.loc 1 947 0
 2208 1248 84408410 		addne	r4, r4, r4, asl #1
 2209 124c 84618610 		addne	r6, r6, r4, asl #3
 2210 1250 B0AB9F15 		ldrne	sl, .L272+72
 941:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2211              		.loc 1 941 0
 2212 1254 ACAB9F05 		ldreq	sl, .L272+72
 2213 1258 743B9F05 		ldreq	r3, .L272+20
 947:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2214              		.loc 1 947 0
 2215 125c 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 948:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2216              		.loc 1 948 0
 2217 1260 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 941:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2218              		.loc 1 941 0
 2219 1264 5C308A05 		streq	r3, [sl, #92]
 947:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2220              		.loc 1 947 0
 2221 1268 5C20CA15 		strneb	r2, [sl, #92]
 948:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2222              		.loc 1 948 0
 2223 126c 5D30CA15 		strneb	r3, [sl, #93]
 2224 1270 40FFFFEA 		b	.L181
 2225              	.L180:
 985:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2226              		.loc 1 985 0
 2227 1274 0B0054E3 		cmp	r4, #11
 2228 1278 0700000A 		beq	.L266
 991:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2229              		.loc 1 991 0
 2230 127c 84A084E0 		add	sl, r4, r4, asl #1
 2231 1280 8A6186E0 		add	r6, r6, sl, asl #3
 2232 1284 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 2233 1288 78AB9FE5 		ldr	sl, .L272+72
 992:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2234              		.loc 1 992 0
 2235 128c 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 991:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2236              		.loc 1 991 0
 2237 1290 5C30CAE5 		strb	r3, [sl, #92]
 992:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2238              		.loc 1 992 0
 2239 1294 5D00CAE5 		strb	r0, [sl, #93]
 2240 1298 36FFFFEA 		b	.L181
 2241              	.L266:
 986:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2242              		.loc 1 986 0
 2243 129c 64AB9FE5 		ldr	sl, .L272+72
 2244 12a0 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 988:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2245              		.loc 1 988 0
 2246 12a4 9422D6E5 		ldrb	r2, [r6, #660]	@ zero_extendqisi2
 987:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2247              		.loc 1 987 0
 2248 12a8 0070A0E3 		mov	r7, #0
 2249              	.LVL167:
 986:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2250              		.loc 1 986 0
 2251 12ac 5CC0CAE5 		strb	ip, [sl, #92]
 987:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2252              		.loc 1 987 0
 2253 12b0 5D70CAE5 		strb	r7, [sl, #93]
 988:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2254              		.loc 1 988 0
 2255 12b4 5E20CAE5 		strb	r2, [sl, #94]
 989:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2256              		.loc 1 989 0
 2257 12b8 5F70CAE5 		strb	r7, [sl, #95]
 2258 12bc 2DFFFFEA 		b	.L181
 2259              	.LVL168:
 2260              	.L157:
 788:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 2261              		.loc 1 788 0
 2262 12c0 402B9FE5 		ldr	r2, .L272+72
 2263 12c4 9D43D6E5 		ldrb	r4, [r6, #925]	@ zero_extendqisi2
 790:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 2264              		.loc 1 790 0
 2265 12c8 9E63D6E5 		ldrb	r6, [r6, #926]	@ zero_extendqisi2
 788:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 2266              		.loc 1 788 0
 2267 12cc 5C40C2E5 		strb	r4, [r2, #92]
 790:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 2268              		.loc 1 790 0
 2269 12d0 5D60C2E5 		strb	r6, [r2, #93]
 2270              	.LVL169:
 2271              	.L161:
 910:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2272              		.loc 1 910 0
 2273 12d4 0800A0E1 		mov	r0, r8
 2274 12d8 EC1A9FE5 		ldr	r1, .L272+12
 2275 12dc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 915:../uvc.c      **** 			  break;
 2276              		.loc 1 915 0
 2277 12e0 FF70A0E3 		mov	r7, #255
 910:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2278              		.loc 1 910 0
 2279 12e4 06C0A0E1 		mov	ip, r6
 915:../uvc.c      **** 			  break;
 2280              		.loc 1 915 0
 2281 12e8 0780A0E1 		mov	r8, r7
 2282 12ec F7FEFFEA 		b	.L144
 2283              	.LVL170:
 2284              	.L156:
 782:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2285              		.loc 1 782 0
 2286 12f0 E03A9FE5 		ldr	r3, .L272+24
 2287 12f4 0C1B9FE5 		ldr	r1, .L272+72
 2288 12f8 047183E0 		add	r7, r3, r4, asl #2
 2289              	.LVL171:
 2290 12fc 20C017E5 		ldr	ip, [r7, #-32]
 2291 1300 0DE0DCE5 		ldrb	lr, [ip, #13]	@ zero_extendqisi2
 2292 1304 FF400EE2 		and	r4, lr, #255
 2293 1308 5C40C1E5 		strb	r4, [r1, #92]
 783:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2294              		.loc 1 783 0
 2295 130c 0E60DCE5 		ldrb	r6, [ip, #14]	@ zero_extendqisi2
 2296 1310 FF6006E2 		and	r6, r6, #255
 2297 1314 5D60C1E5 		strb	r6, [r1, #93]
 2298              	.LVL172:
 786:../uvc.c      **** 			 	 		 break;
 2299              		.loc 1 786 0
 2300 1318 EDFFFFEA 		b	.L161
 2301              	.LVL173:
 2302              	.L155:
 823:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2303              		.loc 1 823 0 discriminator 1
 2304 131c 000058E3 		cmp	r8, #0
 2305 1320 AF03000A 		beq	.L259
 821:../uvc.c      **** 					 break;
 2306              		.loc 1 821 0
 2307 1324 28E1A0E1 		mov	lr, r8, lsr #2
 2308 1328 00005EE3 		cmp	lr, #0
 2309 132c 03005813 		cmpne	r8, #3
 2310 1330 0020A083 		movhi	r2, #0
 2311 1334 0120A093 		movls	r2, #1
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2312              		.loc 1 734 0
 2313 1338 0E31A0E1 		mov	r3, lr, asl #2
 821:../uvc.c      **** 					 break;
 2314              		.loc 1 821 0
 2315 133c BF03009A 		bls	.L239
 2316 1340 841A9FE5 		ldr	r1, .L272+12
 2317 1344 100041E2 		sub	r0, r1, #16
 2318              	.LVL174:
 2319              	.L165:
 824:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2320              		.loc 1 824 0 discriminator 2
 2321 1348 047090E4 		ldr	r7, [r0], #4
 2322 134c 014082E2 		add	r4, r2, #1
 2323 1350 FF2004E2 		and	r2, r4, #255
 2324 1354 0E0052E1 		cmp	r2, lr
 2325 1358 047081E4 		str	r7, [r1], #4
 2326 135c F9FFFF3A 		bcc	.L165
 824:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2327              		.loc 1 824 0 is_stmt 0
 2328 1360 030058E1 		cmp	r8, r3
 2329 1364 9C0A9F15 		ldrne	r0, .L272+72
 2330 1368 9D03000A 		beq	.L259
 2331              	.L252:
 2332 136c 03C080E0 		add	ip, r0, r3
 2333 1370 4C60DCE5 		ldrb	r6, [ip, #76]	@ zero_extendqisi2
 823:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2334              		.loc 1 823 0 is_stmt 1
 2335 1374 01E083E2 		add	lr, r3, #1
 2336 1378 FF300EE2 		and	r3, lr, #255
 2337              	.LVL175:
 2338 137c 030058E1 		cmp	r8, r3
 824:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2339              		.loc 1 824 0
 2340 1380 5C60CCE5 		strb	r6, [ip, #92]
 823:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2341              		.loc 1 823 0
 2342 1384 F8FFFF8A 		bhi	.L252
 2343              	.LVL176:
 2344              	.L160:
 833:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2345              		.loc 1 833 0
 2346 1388 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 826:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2347              		.loc 1 826 0
 2348 138c 743A9FE5 		ldr	r3, .L272+72
 833:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2349              		.loc 1 833 0
 2350 1390 FF0052E3 		cmp	r2, #255
 826:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2351              		.loc 1 826 0
 2352 1394 6540D0E5 		ldrb	r4, [r0, #101]	@ zero_extendqisi2
 2353              	.LVL177:
 827:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2354              		.loc 1 827 0
 2355 1398 6660D0E5 		ldrb	r6, [r0, #102]	@ zero_extendqisi2
 2356              	.LVL178:
 833:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2357              		.loc 1 833 0
 2358 139c CCFFFF0A 		beq	.L161
 835:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2359              		.loc 1 835 0
 2360 13a0 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 2361 13a4 301A9FE5 		ldr	r1, .L272+28
 2362 13a8 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 2363 13ac 0400A0E3 		mov	r0, #4
 2364 13b0 FEFFFFEB 		bl	CyU3PDebugPrint
 2365 13b4 C6FFFFEA 		b	.L161
 2366              	.LVL179:
 2367              	.L154:
 810:../uvc.c      **** 					 if(CamMode == 1){//720p
 2368              		.loc 1 810 0
 2369 13b8 487A9FE5 		ldr	r7, .L272+72
 2370              	.LVL180:
 809:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2371              		.loc 1 809 0
 2372 13bc 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 2373              	.LVL181:
 810:../uvc.c      **** 					 if(CamMode == 1){//720p
 2374              		.loc 1 810 0
 2375 13c0 7C20D7E5 		ldrb	r2, [r7, #124]	@ zero_extendqisi2
 2376 13c4 010052E3 		cmp	r2, #1
 2377 13c8 EB02000A 		beq	.L267
 2378              	.LVL182:
 2379              	.L162:
 820:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2380              		.loc 1 820 0
 2381 13cc 0010A0E3 		mov	r1, #0
 819:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 2382              		.loc 1 819 0
 2383 13d0 5C40C7E5 		strb	r4, [r7, #92]
 820:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2384              		.loc 1 820 0
 2385 13d4 5D10C7E5 		strb	r1, [r7, #93]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2386              		.loc 1 752 0
 2387 13d8 FF60A0E3 		mov	r6, #255
 821:../uvc.c      **** 					 break;
 2388              		.loc 1 821 0
 2389 13dc BCFFFFEA 		b	.L161
 2390              	.LVL183:
 2391              	.L153:
 803:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2392              		.loc 1 803 0
 2393 13e0 B1E4D6E5 		ldrb	lr, [r6, #1201]	@ zero_extendqisi2
 2394 13e4 1CCA9FE5 		ldr	ip, .L272+72
 805:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2395              		.loc 1 805 0
 2396 13e8 B264D6E5 		ldrb	r6, [r6, #1202]	@ zero_extendqisi2
 803:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2397              		.loc 1 803 0
 2398 13ec FF400EE2 		and	r4, lr, #255
 805:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2399              		.loc 1 805 0
 2400 13f0 5D60CCE5 		strb	r6, [ip, #93]
 2401              	.LVL184:
 803:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2402              		.loc 1 803 0
 2403 13f4 5C40CCE5 		strb	r4, [ip, #92]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2404              		.loc 1 752 0
 2405 13f8 FF60A0E3 		mov	r6, #255
 807:../uvc.c      **** 			 		 break;
 2406              		.loc 1 807 0
 2407 13fc B4FFFFEA 		b	.L161
 2408              	.LVL185:
 2409              	.L151:
 797:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2410              		.loc 1 797 0
 2411 1400 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 2412 1404 FC199FE5 		ldr	r1, .L272+72
 799:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2413              		.loc 1 799 0
 2414 1408 9E04D6E5 		ldrb	r0, [r6, #1182]	@ zero_extendqisi2
 797:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2415              		.loc 1 797 0
 2416 140c FF4004E2 		and	r4, r4, #255
 2417 1410 5C40C1E5 		strb	r4, [r1, #92]
 799:../uvc.c      **** 					 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2418              		.loc 1 799 0
 2419 1414 5D00C1E5 		strb	r0, [r1, #93]
 2420              	.LVL186:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2421              		.loc 1 752 0
 2422 1418 FF60A0E3 		mov	r6, #255
 801:../uvc.c      **** 			 		 break;
 2423              		.loc 1 801 0
 2424 141c ACFFFFEA 		b	.L161
 2425              	.LVL187:
 2426              	.L150:
 881:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2427              		.loc 1 881 0
 2428 1420 E0399FE5 		ldr	r3, .L272+72
 2429 1424 CC44D6E5 		ldrb	r4, [r6, #1228]	@ zero_extendqisi2
 883:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2430              		.loc 1 883 0
 2431 1428 CE64D6E5 		ldrb	r6, [r6, #1230]	@ zero_extendqisi2
 882:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2432              		.loc 1 882 0
 2433 142c 00C0A0E3 		mov	ip, #0
 881:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2434              		.loc 1 881 0
 2435 1430 5C40C3E5 		strb	r4, [r3, #92]
 882:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2436              		.loc 1 882 0
 2437 1434 5DC0C3E5 		strb	ip, [r3, #93]
 883:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2438              		.loc 1 883 0
 2439 1438 5E60C3E5 		strb	r6, [r3, #94]
 884:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2440              		.loc 1 884 0
 2441 143c 5FC0C3E5 		strb	ip, [r3, #95]
 2442              	.LVL188:
 887:../uvc.c      **** 					 break;
 2443              		.loc 1 887 0
 2444 1440 A3FFFFEA 		b	.L161
 2445              	.LVL189:
 2446              	.L152:
 839:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2447              		.loc 1 839 0
 2448 1444 C504D6E5 		ldrb	r0, [r6, #1221]	@ zero_extendqisi2
 840:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2449              		.loc 1 840 0
 2450 1448 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 839:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2451              		.loc 1 839 0
 2452 144c B4C99FE5 		ldr	ip, .L272+72
 843:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2453              		.loc 1 843 0
 2454 1450 0070A0E3 		mov	r7, #0
 2455              	.LVL190:
 839:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2456              		.loc 1 839 0
 2457 1454 FF4000E2 		and	r4, r0, #255
 840:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2458              		.loc 1 840 0
 2459 1458 FF6003E2 		and	r6, r3, #255
 839:../uvc.c      **** 					 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 2460              		.loc 1 839 0
 2461 145c 5C40CCE5 		strb	r4, [ip, #92]
 840:../uvc.c      **** 					 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2462              		.loc 1 840 0
 2463 1460 5E60CCE5 		strb	r6, [ip, #94]
 843:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2464              		.loc 1 843 0
 2465 1464 5D70CCE5 		strb	r7, [ip, #93]
 845:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2466              		.loc 1 845 0
 2467 1468 5F70CCE5 		strb	r7, [ip, #95]
 2468              	.LVL191:
 848:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2469              		.loc 1 848 0
 2470 146c 6C199FE5 		ldr	r1, .L272+32
 2471 1470 0420A0E1 		mov	r2, r4
 2472 1474 0730A0E1 		mov	r3, r7
 2473 1478 0400A0E3 		mov	r0, #4
 2474 147c C0008DE8 		stmia	sp, {r6, r7}	@ phole stm
 2475 1480 FEFFFFEB 		bl	CyU3PDebugPrint
 849:../uvc.c      **** 					 break;
 2476              		.loc 1 849 0
 2477 1484 92FFFFEA 		b	.L161
 2478              	.LVL192:
 2479              	.L149:
 876:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2480              		.loc 1 876 0
 2481 1488 0572D6E5 		ldrb	r7, [r6, #517]	@ zero_extendqisi2
 2482              	.LVL193:
 2483 148c 74299FE5 		ldr	r2, .L272+72
 2484 1490 804027E2 		eor	r4, r7, #128
 877:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2485              		.loc 1 877 0
 2486 1494 00E0A0E3 		mov	lr, #0
 876:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2487              		.loc 1 876 0
 2488 1498 5C40C2E5 		strb	r4, [r2, #92]
 877:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2489              		.loc 1 877 0
 2490 149c 5DE0C2E5 		strb	lr, [r2, #93]
 2491              	.LVL194:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2492              		.loc 1 752 0
 2493 14a0 FF60A0E3 		mov	r6, #255
 879:../uvc.c      **** 					 break;
 2494              		.loc 1 879 0
 2495 14a4 8AFFFFEA 		b	.L161
 2496              	.LVL195:
 2497              	.L148:
 898:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 2498              		.loc 1 898 0
 2499 14a8 58C99FE5 		ldr	ip, .L272+72
 2500 14ac BD41D6E5 		ldrb	r4, [r6, #445]	@ zero_extendqisi2
 899:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2501              		.loc 1 899 0
 2502 14b0 0070A0E3 		mov	r7, #0
 2503              	.LVL196:
 898:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
 2504              		.loc 1 898 0
 2505 14b4 5C40CCE5 		strb	r4, [ip, #92]
 899:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2506              		.loc 1 899 0
 2507 14b8 5D70CCE5 		strb	r7, [ip, #93]
 2508              	.LVL197:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2509              		.loc 1 752 0
 2510 14bc FF60A0E3 		mov	r6, #255
 901:../uvc.c      **** 					 break;
 2511              		.loc 1 901 0
 2512 14c0 83FFFFEA 		b	.L161
 2513              	.LVL198:
 2514              	.L147:
 864:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2515              		.loc 1 864 0
 2516 14c4 A541D6E5 		ldrb	r4, [r6, #421]	@ zero_extendqisi2
 2517              	.LVL199:
 870:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2518              		.loc 1 870 0
 2519 14c8 38699FE5 		ldr	r6, .L272+72
 865:../uvc.c      **** 					  if(Data0&0x80){
 2520              		.loc 1 865 0
 2521 14cc 800014E3 		tst	r4, #128
 866:../uvc.c      **** 						  Data0 = ~Data0;
 2522              		.loc 1 866 0
 2523 14d0 0440E011 		mvnne	r4, r4
 2524              	.LVL200:
 868:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2525              		.loc 1 868 0
 2526 14d4 80404402 		subeq	r4, r4, #128
 2527 14d8 FF4004E2 		and	r4, r4, #255
 2528              	.LVL201:
 871:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2529              		.loc 1 871 0
 2530 14dc 0010A0E3 		mov	r1, #0
 870:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 2531              		.loc 1 870 0
 2532 14e0 5C40C6E5 		strb	r4, [r6, #92]
 871:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2533              		.loc 1 871 0
 2534 14e4 5D10C6E5 		strb	r1, [r6, #93]
 2535              	.LVL202:
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2536              		.loc 1 752 0
 2537 14e8 FF60A0E3 		mov	r6, #255
 873:../uvc.c      **** 			 		 break;
 2538              		.loc 1 873 0
 2539 14ec 78FFFFEA 		b	.L161
 2540              	.LVL203:
 2541              	.L146:
 890:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2542              		.loc 1 890 0
 2543 14f0 E0289FE5 		ldr	r2, .L272+24
 2544 14f4 0C199FE5 		ldr	r1, .L272+72
 2545 14f8 046182E0 		add	r6, r2, r4, asl #2
 2546 14fc A0E096E5 		ldr	lr, [r6, #160]
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2547              		.loc 1 752 0
 2548 1500 FF60A0E3 		mov	r6, #255
 890:../uvc.c      **** 					 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
 2549              		.loc 1 890 0
 2550 1504 0D40DEE5 		ldrb	r4, [lr, #13]	@ zero_extendqisi2
 2551 1508 064004E0 		and	r4, r4, r6
 2552 150c 5C40C1E5 		strb	r4, [r1, #92]
 892:../uvc.c      **** 					 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2553              		.loc 1 892 0
 2554 1510 0E00DEE5 		ldrb	r0, [lr, #14]	@ zero_extendqisi2
 2555 1514 5D00C1E5 		strb	r0, [r1, #93]
 2556              	.LVL204:
 894:../uvc.c      **** 					 break;
 2557              		.loc 1 894 0
 2558 1518 6DFFFFEA 		b	.L161
 2559              	.LVL205:
 2560              	.L145:
 904:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2561              		.loc 1 904 0
 2562 151c 84E084E0 		add	lr, r4, r4, asl #1
 2563 1520 8E1186E0 		add	r1, r6, lr, asl #3
 2564 1524 DC389FE5 		ldr	r3, .L272+72
 2565 1528 8D41D1E5 		ldrb	r4, [r1, #397]	@ zero_extendqisi2
 905:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2566              		.loc 1 905 0
 2567 152c 0000A0E3 		mov	r0, #0
 752:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2568              		.loc 1 752 0
 2569 1530 FF60A0E3 		mov	r6, #255
 904:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2570              		.loc 1 904 0
 2571 1534 5C40C3E5 		strb	r4, [r3, #92]
 905:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2572              		.loc 1 905 0
 2573 1538 5D00C3E5 		strb	r0, [r3, #93]
 2574              	.LVL206:
 907:../uvc.c      **** 					 break;
 2575              		.loc 1 907 0
 2576 153c 64FFFFEA 		b	.L161
 2577              	.LVL207:
 2578              	.L200:
1207:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2579              		.loc 1 1207 0
 2580 1540 E424D6E5 		ldrb	r2, [r6, #1252]	@ zero_extendqisi2
 2581              	.LVL208:
1212:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2582              		.loc 1 1212 0
 2583 1544 B0489FE5 		ldr	r4, .L272+60
1208:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2584              		.loc 1 1208 0
 2585 1548 E534D6E5 		ldrb	r3, [r6, #1253]	@ zero_extendqisi2
1209:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2586              		.loc 1 1209 0
 2587 154c F3C4D6E5 		ldrb	ip, [r6, #1267]	@ zero_extendqisi2
1207:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2588              		.loc 1 1207 0
 2589 1550 FF8002E2 		and	r8, r2, #255
 2590              	.LVL209:
1212:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2591              		.loc 1 1212 0
 2592 1554 0010E0E3 		mvn	r1, #0
 2593 1558 1C0094E5 		ldr	r0, [r4, #28]
1209:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 2594              		.loc 1 1209 0
 2595 155c FF700CE2 		and	r7, ip, #255
 2596              	.LVL210:
1212:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2597              		.loc 1 1212 0
 2598 1560 FEFFFFEB 		bl	_txe_mutex_get
1213:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2599              		.loc 1 1213 0
 2600 1564 0820A0E1 		mov	r2, r8
 2601 1568 14809DE5 		ldr	r8, [sp, #20]
 2602              	.LVL211:
 2603 156c 0730A0E1 		mov	r3, r7
 2604 1570 2510A0E3 		mov	r1, #37
 2605 1574 0400A0E1 		mov	r0, r4
 2606 1578 0070A0E3 		mov	r7, #0
 2607              	.LVL212:
 2608 157c 00808DE5 		str	r8, [sp, #0]
 2609 1580 04708DE5 		str	r7, [sp, #4]
 2610 1584 FEFFFFEB 		bl	cmdSet
 2611              	.LVL213:
1214:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2612              		.loc 1 1214 0
 2613 1588 1C0094E5 		ldr	r0, [r4, #28]
 2614 158c FEFFFFEB 		bl	_txe_mutex_put
1215:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2615              		.loc 1 1215 0
 2616 1590 14309DE5 		ldr	r3, [sp, #20]
1219:../uvc.c      **** 							 break;
 2617              		.loc 1 1219 0
 2618 1594 FFC0A0E3 		mov	ip, #255
1216:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2619              		.loc 1 1216 0
 2620 1598 0100A0E3 		mov	r0, #1
1215:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 2621              		.loc 1 1215 0
 2622 159c F134C6E5 		strb	r3, [r6, #1265]
1216:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 2623              		.loc 1 1216 0
 2624 15a0 0380A0E1 		mov	r8, r3
 2625 15a4 F504C6E5 		strb	r0, [r6, #1269]
 2626 15a8 18709DE5 		ldr	r7, [sp, #24]
1219:../uvc.c      **** 							 break;
 2627              		.loc 1 1219 0
 2628 15ac 0C40A0E1 		mov	r4, ip
 2629 15b0 46FEFFEA 		b	.L144
 2630              	.LVL214:
 2631              	.L199:
1167:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2632              		.loc 1 1167 0
 2633 15b4 D0E4D6E5 		ldrb	lr, [r6, #1232]	@ zero_extendqisi2
1194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2634              		.loc 1 1194 0
 2635 15b8 3C489FE5 		ldr	r4, .L272+60
1168:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2636              		.loc 1 1168 0
 2637 15bc D124D6E5 		ldrb	r2, [r6, #1233]	@ zero_extendqisi2
 2638              	.LVL215:
1169:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2639              		.loc 1 1169 0
 2640 15c0 DF14D6E5 		ldrb	r1, [r6, #1247]	@ zero_extendqisi2
1194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2641              		.loc 1 1194 0
 2642 15c4 1C0094E5 		ldr	r0, [r4, #28]
1169:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 2643              		.loc 1 1169 0
 2644 15c8 FF7001E2 		and	r7, r1, #255
 2645              	.LVL216:
1194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2646              		.loc 1 1194 0
 2647 15cc 0010E0E3 		mvn	r1, #0
1167:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2648              		.loc 1 1167 0
 2649 15d0 FFA00EE2 		and	sl, lr, #255
 2650              	.LVL217:
1168:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 2651              		.loc 1 1168 0
 2652 15d4 FF8002E2 		and	r8, r2, #255
 2653              	.LVL218:
1194:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2654              		.loc 1 1194 0
 2655 15d8 FEFFFFEB 		bl	_txe_mutex_get
1196:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2656              		.loc 1 1196 0
 2657 15dc 14C09DE5 		ldr	ip, [sp, #20]
 2658 15e0 0A20A0E1 		mov	r2, sl
 2659 15e4 0730A0E1 		mov	r3, r7
 2660 15e8 2410A0E3 		mov	r1, #36
 2661 15ec 0400A0E1 		mov	r0, r4
 2662 15f0 00C08DE5 		str	ip, [sp, #0]
 2663 15f4 00C0A0E3 		mov	ip, #0
 2664 15f8 04C08DE5 		str	ip, [sp, #4]
 2665 15fc FEFFFFEB 		bl	cmdSet
 2666              	.LVL219:
1198:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2667              		.loc 1 1198 0
 2668 1600 1CC09DE5 		ldr	ip, [sp, #28]
 2669 1604 0730A0E1 		mov	r3, r7
 2670 1608 0820A0E1 		mov	r2, r8
 2671 160c 01A0A0E3 		mov	sl, #1
 2672              	.LVL220:
 2673 1610 2410A0E3 		mov	r1, #36
 2674 1614 0400A0E1 		mov	r0, r4
 2675 1618 00C08DE5 		str	ip, [sp, #0]
 2676 161c 04A08DE5 		str	sl, [sp, #4]
 2677 1620 FEFFFFEB 		bl	cmdSet
1199:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2678              		.loc 1 1199 0
 2679 1624 1C0094E5 		ldr	r0, [r4, #28]
 2680 1628 FEFFFFEB 		bl	_txe_mutex_put
 2681              	.LVL221:
1203:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2682              		.loc 1 1203 0
 2683 162c 1C309DE5 		ldr	r3, [sp, #28]
1202:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2684              		.loc 1 1202 0
 2685 1630 14809DE5 		ldr	r8, [sp, #20]
 2686              	.LVL222:
1205:../uvc.c      **** 							 break;
 2687              		.loc 1 1205 0
 2688 1634 FFC0A0E3 		mov	ip, #255
1202:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 2689              		.loc 1 1202 0
 2690 1638 DD84C6E5 		strb	r8, [r6, #1245]
1204:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2691              		.loc 1 1204 0
 2692 163c 0370A0E1 		mov	r7, r3
 2693              	.LVL223:
1203:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 2694              		.loc 1 1203 0
 2695 1640 DE34C6E5 		strb	r3, [r6, #1246]
1205:../uvc.c      **** 							 break;
 2696              		.loc 1 1205 0
 2697 1644 0C40A0E1 		mov	r4, ip
1204:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2698              		.loc 1 1204 0
 2699 1648 E1A4C6E5 		strb	sl, [r6, #1249]
1205:../uvc.c      **** 							 break;
 2700              		.loc 1 1205 0
 2701 164c 1FFEFFEA 		b	.L144
 2702              	.LVL224:
 2703              	.L201:
1222:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2704              		.loc 1 1222 0
 2705 1650 8780A0E1 		mov	r8, r7, asl #1
 2706 1654 64B79FE5 		ldr	fp, .L272
 2707 1658 071088E0 		add	r1, r8, r7
 2708 165c 812186E0 		add	r2, r6, r1, asl #3
 2709              	.LVL225:
1228:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2710              		.loc 1 1228 0
 2711 1660 94479FE5 		ldr	r4, .L272+60
1222:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2712              		.loc 1 1222 0
 2713 1664 0D30C2E5 		strb	r3, [r2, #13]
1224:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 2714              		.loc 1 1224 0
 2715 1668 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1223:../uvc.c      **** 							 if(Data0 == 1){
 2716              		.loc 1 1223 0
 2717 166c 010053E3 		cmp	r3, #1
1228:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2718              		.loc 1 1228 0
 2719 1670 0010E0E3 		mvn	r1, #0
 2720 1674 1C0094E5 		ldr	r0, [r4, #28]
1224:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 2721              		.loc 1 1224 0
 2722 1678 80B08B03 		orreq	fp, fp, #128
 2723              	.LVL226:
1226:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 2724              		.loc 1 1226 0
 2725 167c 7FB00B12 		andne	fp, fp, #127
 2726              	.LVL227:
1228:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2727              		.loc 1 1228 0
 2728 1680 FEFFFFEB 		bl	_txe_mutex_get
1229:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2729              		.loc 1 1229 0
 2730 1684 00C0A0E3 		mov	ip, #0
 2731 1688 2610A0E3 		mov	r1, #38
 2732 168c 0A20A0E1 		mov	r2, sl
 2733 1690 0930A0E1 		mov	r3, r9
 2734 1694 0400A0E1 		mov	r0, r4
 2735 1698 00188DE8 		stmia	sp, {fp, ip}	@ phole stm
 2736 169c FEFFFFEB 		bl	cmdSet
1230:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2737              		.loc 1 1230 0
 2738 16a0 1C0094E5 		ldr	r0, [r4, #28]
 2739 16a4 FEFFFFEB 		bl	_txe_mutex_put
1232:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2740              		.loc 1 1232 0
 2741 16a8 070088E0 		add	r0, r8, r7
 2742 16ac 806186E0 		add	r6, r6, r0, asl #3
1233:../uvc.c      **** 							 break;
 2743              		.loc 1 1233 0
 2744 16b0 FFC0A0E3 		mov	ip, #255
1232:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2745              		.loc 1 1232 0
 2746 16b4 0110A0E3 		mov	r1, #1
 2747 16b8 1010C6E5 		strb	r1, [r6, #16]
 2748 16bc 14809DE5 		ldr	r8, [sp, #20]
 2749 16c0 18709DE5 		ldr	r7, [sp, #24]
 2750              	.LVL228:
1233:../uvc.c      **** 							 break;
 2751              		.loc 1 1233 0
 2752 16c4 0C40A0E1 		mov	r4, ip
 2753 16c8 00FEFFEA 		b	.L144
 2754              	.LVL229:
 2755              	.L198:
1161:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2756              		.loc 1 1161 0 discriminator 1
 2757 16cc 000058E3 		cmp	r8, #0
 2758 16d0 1800000A 		beq	.L204
1159:../uvc.c      **** 							 break;
 2759              		.loc 1 1159 0
 2760 16d4 28E1A0E1 		mov	lr, r8, lsr #2
 2761 16d8 00005EE3 		cmp	lr, #0
 2762 16dc 03005813 		cmpne	r8, #3
 2763 16e0 0020A083 		movhi	r2, #0
 2764 16e4 0120A093 		movls	r2, #1
 2765              	.LVL230:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2766              		.loc 1 734 0
 2767 16e8 0E31A0E1 		mov	r3, lr, asl #2
1159:../uvc.c      **** 							 break;
 2768              		.loc 1 1159 0
 2769 16ec D102009A 		bls	.L241
 2770 16f0 EC169FE5 		ldr	r1, .L272+36
 2771 16f4 100081E2 		add	r0, r1, #16
 2772              	.LVL231:
 2773              	.L214:
1162:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2774              		.loc 1 1162 0 discriminator 2
 2775 16f8 044090E4 		ldr	r4, [r0], #4
 2776 16fc 012082E2 		add	r2, r2, #1
 2777 1700 FF2002E2 		and	r2, r2, #255
 2778 1704 02005EE1 		cmp	lr, r2
 2779 1708 044081E4 		str	r4, [r1], #4
 2780 170c F9FFFF8A 		bhi	.L214
1162:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2781              		.loc 1 1162 0 is_stmt 0
 2782 1710 030058E1 		cmp	r8, r3
 2783 1714 0700000A 		beq	.L204
 2784              	.LVL232:
 2785              	.L253:
 2786 1718 E8769FE5 		ldr	r7, .L272+72
1161:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2787              		.loc 1 1161 0 is_stmt 1
 2788 171c 010083E2 		add	r0, r3, #1
1162:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2789              		.loc 1 1162 0
 2790 1720 03E087E0 		add	lr, r7, r3
 2791 1724 5C10DEE5 		ldrb	r1, [lr, #92]	@ zero_extendqisi2
1161:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2792              		.loc 1 1161 0
 2793 1728 FF3000E2 		and	r3, r0, #255
 2794              	.LVL233:
 2795 172c 030058E1 		cmp	r8, r3
1162:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2796              		.loc 1 1162 0
 2797 1730 4C10CEE5 		strb	r1, [lr, #76]
1161:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2798              		.loc 1 1161 0
 2799 1734 F7FFFF8A 		bhi	.L253
 2800              	.LVL234:
 2801              	.L204:
1164:../uvc.c      **** 					 		I2CCmdHandler();
 2802              		.loc 1 1164 0
 2803 1738 FEFFFFEB 		bl	I2CCmdHandler
1165:../uvc.c      **** 							 break;
 2804              		.loc 1 1165 0
 2805 173c FFC0A0E3 		mov	ip, #255
1164:../uvc.c      **** 					 		I2CCmdHandler();
 2806              		.loc 1 1164 0
 2807 1740 14809DE5 		ldr	r8, [sp, #20]
 2808 1744 18709DE5 		ldr	r7, [sp, #24]
1165:../uvc.c      **** 							 break;
 2809              		.loc 1 1165 0
 2810 1748 0C40A0E1 		mov	r4, ip
 2811 174c DFFDFFEA 		b	.L144
 2812              	.LVL235:
 2813              	.L197:
1155:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2814              		.loc 1 1155 0
 2815 1750 A4469FE5 		ldr	r4, .L272+60
 2816 1754 0010E0E3 		mvn	r1, #0
 2817 1758 1C0094E5 		ldr	r0, [r4, #28]
 2818 175c FEFFFFEB 		bl	_txe_mutex_get
 2819              	.LVL236:
1156:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2820              		.loc 1 1156 0
 2821 1760 14C09DE5 		ldr	ip, [sp, #20]
 2822 1764 0930A0E1 		mov	r3, r9
 2823 1768 01707CE2 		rsbs	r7, ip, #1
 2824              	.LVL237:
 2825 176c 0070A033 		movcc	r7, #0
 2826 1770 1E10A0E3 		mov	r1, #30
 2827 1774 0A20A0E1 		mov	r2, sl
 2828 1778 0400A0E1 		mov	r0, r4
 2829 177c 0080A0E3 		mov	r8, #0
 2830 1780 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 2831 1784 FEFFFFEB 		bl	cmdSet
1157:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2832              		.loc 1 1157 0
 2833 1788 1C0094E5 		ldr	r0, [r4, #28]
 2834 178c FEFFFFEB 		bl	_txe_mutex_put
1159:../uvc.c      **** 							 break;
 2835              		.loc 1 1159 0
 2836 1790 FFC0A0E3 		mov	ip, #255
1158:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2837              		.loc 1 1158 0
 2838 1794 0130A0E3 		mov	r3, #1
 2839 1798 6034C6E5 		strb	r3, [r6, #1120]
 2840 179c 14809DE5 		ldr	r8, [sp, #20]
 2841 17a0 18709DE5 		ldr	r7, [sp, #24]
1159:../uvc.c      **** 							 break;
 2842              		.loc 1 1159 0
 2843 17a4 0C40A0E1 		mov	r4, ip
 2844 17a8 C8FDFFEA 		b	.L144
 2845              	.LVL238:
 2846              	.L196:
1133:../uvc.c      **** 							 if(Data0 <= 3){
 2847              		.loc 1 1133 0
 2848 17ac 030053E3 		cmp	r3, #3
1134:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2849              		.loc 1 1134 0
 2850 17b0 50169F95 		ldrls	r1, .L272+72
1137:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2851              		.loc 1 1137 0
 2852 17b4 4CC69F85 		ldrhi	ip, .L272+72
1143:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2853              		.loc 1 1143 0
 2854 17b8 3C869FE5 		ldr	r8, .L272+60
1140:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2855              		.loc 1 1140 0
 2856 17bc 14E09DE5 		ldr	lr, [sp, #20]
 2857 17c0 0300A0E1 		mov	r0, r3
 2858              	.LVL239:
1137:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2859              		.loc 1 1137 0
 2860 17c4 0120A083 		movhi	r2, #1
 2861              	.LVL240:
1134:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2862              		.loc 1 1134 0
 2863 17c8 0030A093 		movls	r3, #0
 2864 17cc 7C30C195 		strlsb	r3, [r1, #124]
 2865              	.LVL241:
1138:../uvc.c      **** 								 Data1 = Data0-4;
 2866              		.loc 1 1138 0
 2867 17d0 04304382 		subhi	r3, r3, #4
1134:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2868              		.loc 1 1134 0
 2869 17d4 0030A091 		movls	r3, r0
1137:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2870              		.loc 1 1137 0
 2871 17d8 7C20CC85 		strhib	r2, [ip, #124]
 2872              	.LVL242:
1142:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2873              		.loc 1 1142 0
 2874 17dc 0120A0E3 		mov	r2, #1
1143:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2875              		.loc 1 1143 0
 2876 17e0 0010E0E3 		mvn	r1, #0
1140:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2877              		.loc 1 1140 0
 2878 17e4 2DE4C6E5 		strb	lr, [r6, #1069]
1141:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2879              		.loc 1 1141 0
 2880 17e8 8D31C6E5 		strb	r3, [r6, #397]
1142:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2881              		.loc 1 1142 0
 2882 17ec 3024C6E5 		strb	r2, [r6, #1072]
1143:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2883              		.loc 1 1143 0
 2884 17f0 1C0098E5 		ldr	r0, [r8, #28]
 2885 17f4 FEFFFFEB 		bl	_txe_mutex_get
 2886              	.LVL243:
1144:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2887              		.loc 1 1144 0
 2888 17f8 14C09DE5 		ldr	ip, [sp, #20]
 2889 17fc 1C10A0E3 		mov	r1, #28
 2890 1800 0A20A0E1 		mov	r2, sl
 2891 1804 0930A0E1 		mov	r3, r9
 2892 1808 0800A0E1 		mov	r0, r8
 2893 180c 0070A0E3 		mov	r7, #0
 2894              	.LVL244:
 2895 1810 00C08DE5 		str	ip, [sp, #0]
 2896 1814 04708DE5 		str	r7, [sp, #4]
 2897 1818 FEFFFFEB 		bl	cmdSet
1145:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2898              		.loc 1 1145 0
 2899 181c 1C0098E5 		ldr	r0, [r8, #28]
 2900              	.LVL245:
 2901              	.L261:
1407:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2902              		.loc 1 1407 0
 2903 1820 FEFFFFEB 		bl	_txe_mutex_put
 2904 1824 FFC0A0E3 		mov	ip, #255
 2905 1828 14809DE5 		ldr	r8, [sp, #20]
 2906 182c 18709DE5 		ldr	r7, [sp, #24]
 2907 1830 0C40A0E1 		mov	r4, ip
 2908 1834 A5FDFFEA 		b	.L144
 2909              	.LVL246:
 2910              	.L195:
1110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2911              		.loc 1 1110 0
 2912 1838 BC459FE5 		ldr	r4, .L272+60
1106:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2913              		.loc 1 1106 0
 2914 183c A4A4D6E5 		ldrb	sl, [r6, #1188]	@ zero_extendqisi2
1107:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2915              		.loc 1 1107 0
 2916 1840 A584D6E5 		ldrb	r8, [r6, #1189]	@ zero_extendqisi2
1108:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2917              		.loc 1 1108 0
 2918 1844 B334D6E5 		ldrb	r3, [r6, #1203]	@ zero_extendqisi2
1110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2919              		.loc 1 1110 0
 2920 1848 1C0094E5 		ldr	r0, [r4, #28]
 2921 184c 0010E0E3 		mvn	r1, #0
1108:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 2922              		.loc 1 1108 0
 2923 1850 FF7003E2 		and	r7, r3, #255
 2924              	.LVL247:
1110:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2925              		.loc 1 1110 0
 2926 1854 FEFFFFEB 		bl	_txe_mutex_get
 2927              	.LVL248:
1118:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2928              		.loc 1 1118 0
 2929 1858 B124D6E5 		ldrb	r2, [r6, #1201]	@ zero_extendqisi2
 2930 185c 14009DE5 		ldr	r0, [sp, #20]
1106:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2931              		.loc 1 1106 0
 2932 1860 FFA00AE2 		and	sl, sl, #255
 2933              	.LVL249:
1118:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2934              		.loc 1 1118 0
 2935 1864 020050E1 		cmp	r0, r2
1107:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 2936              		.loc 1 1107 0
 2937 1868 FF8008E2 		and	r8, r8, #255
 2938              	.LVL250:
1106:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 2939              		.loc 1 1106 0
 2940 186c 4C359FE5 		ldr	r3, .L272
1118:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 2941              		.loc 1 1118 0
 2942 1870 0600000A 		beq	.L209
1119:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 2943              		.loc 1 1119 0
 2944 1874 B104C3E5 		strb	r0, [r3, #1201]
1120:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2945              		.loc 1 1120 0
 2946 1878 C504D3E5 		ldrb	r0, [r3, #1221]	@ zero_extendqisi2
 2947 187c 010050E3 		cmp	r0, #1
 2948 1880 4502000A 		beq	.L210
1120:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 2949              		.loc 1 1120 0 is_stmt 0 discriminator 1
 2950 1884 C514D3E5 		ldrb	r1, [r3, #1221]	@ zero_extendqisi2
 2951 1888 030051E3 		cmp	r1, #3
 2952 188c 4202000A 		beq	.L210
 2953              	.LVL251:
 2954              	.L209:
1127:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2955              		.loc 1 1127 0 is_stmt 1
 2956 1890 1C0094E5 		ldr	r0, [r4, #28]
 2957 1894 FEFFFFEB 		bl	_txe_mutex_put
1129:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2958              		.loc 1 1129 0
 2959 1898 C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1128:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2960              		.loc 1 1128 0
 2961 189c 14809DE5 		ldr	r8, [sp, #20]
 2962              	.LVL252:
1129:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2963              		.loc 1 1129 0
 2964 18a0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
1128:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2965              		.loc 1 1128 0
 2966 18a4 18709DE5 		ldr	r7, [sp, #24]
1129:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 2967              		.loc 1 1129 0
 2968 18a8 B144D6E5 		ldrb	r4, [r6, #1201]	@ zero_extendqisi2
1128:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 2969              		.loc 1 1128 0
 2970 18ac 0400A0E3 		mov	r0, #4
 2971 18b0 30159FE5 		ldr	r1, .L272+40
 2972 18b4 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 2973 18b8 08708DE5 		str	r7, [sp, #8]
 2974 18bc FEFFFFEB 		bl	CyU3PDebugPrint
1130:../uvc.c      **** 							 break;
 2975              		.loc 1 1130 0
 2976 18c0 FFC0A0E3 		mov	ip, #255
 2977 18c4 0C40A0E1 		mov	r4, ip
 2978 18c8 80FDFFEA 		b	.L144
 2979              	.LVL253:
 2980              	.L190:
1296:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2981              		.loc 1 1296 0
 2982 18cc 28459FE5 		ldr	r4, .L272+60
 2983 18d0 0010E0E3 		mvn	r1, #0
 2984 18d4 1C0094E5 		ldr	r0, [r4, #28]
 2985 18d8 FEFFFFEB 		bl	_txe_mutex_get
 2986              	.LVL254:
1297:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2987              		.loc 1 1297 0
 2988 18dc 14C09DE5 		ldr	ip, [sp, #20]
 2989 18e0 0610A0E3 		mov	r1, #6
 2990 18e4 0A20A0E1 		mov	r2, sl
 2991 18e8 0930A0E1 		mov	r3, r9
 2992 18ec 0400A0E1 		mov	r0, r4
 2993 18f0 0080A0E3 		mov	r8, #0
 2994 18f4 00C08DE5 		str	ip, [sp, #0]
 2995 18f8 04808DE5 		str	r8, [sp, #4]
 2996 18fc FEFFFFEB 		bl	cmdSet
 2997              	.LVL255:
1299:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2998              		.loc 1 1299 0
 2999 1900 14C09DE5 		ldr	ip, [sp, #20]
 3000 1904 0170A0E3 		mov	r7, #1
 3001              	.LVL256:
 3002 1908 0610A0E3 		mov	r1, #6
 3003 190c 0B20A0E1 		mov	r2, fp
 3004 1910 0930A0E1 		mov	r3, r9
 3005 1914 0400A0E1 		mov	r0, r4
 3006 1918 00C08DE5 		str	ip, [sp, #0]
 3007 191c 04708DE5 		str	r7, [sp, #4]
 3008 1920 FEFFFFEB 		bl	cmdSet
1300:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3009              		.loc 1 1300 0
 3010 1924 1C0094E5 		ldr	r0, [r4, #28]
 3011 1928 FEFFFFEB 		bl	_txe_mutex_put
1301:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3012              		.loc 1 1301 0
 3013 192c 14809DE5 		ldr	r8, [sp, #20]
1303:../uvc.c      **** 							 break;
 3014              		.loc 1 1303 0
 3015 1930 FFC0A0E3 		mov	ip, #255
1302:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3016              		.loc 1 1302 0
 3017 1934 2072C6E5 		strb	r7, [r6, #544]
1301:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3018              		.loc 1 1301 0
 3019 1938 1D82C6E5 		strb	r8, [r6, #541]
1302:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3020              		.loc 1 1302 0
 3021 193c 18709DE5 		ldr	r7, [sp, #24]
1303:../uvc.c      **** 							 break;
 3022              		.loc 1 1303 0
 3023 1940 0C40A0E1 		mov	r4, ip
 3024 1944 61FDFFEA 		b	.L144
 3025              	.LVL257:
 3026              	.L189:
1276:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3027              		.loc 1 1276 0
 3028 1948 AC849FE5 		ldr	r8, .L272+60
 3029 194c 0010E0E3 		mvn	r1, #0
 3030 1950 1C0098E5 		ldr	r0, [r8, #28]
 3031 1954 FEFFFFEB 		bl	_txe_mutex_get
 3032              	.LVL258:
1277:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3033              		.loc 1 1277 0
 3034 1958 14109DE5 		ldr	r1, [sp, #20]
 3035 195c 0930A0E1 		mov	r3, r9
 3036 1960 802041E2 		sub	r2, r1, #128
 3037 1964 FFC002E2 		and	ip, r2, #255
 3038 1968 0510A0E3 		mov	r1, #5
 3039 196c 0A20A0E1 		mov	r2, sl
 3040 1970 0800A0E1 		mov	r0, r8
 3041 1974 0040A0E3 		mov	r4, #0
 3042 1978 00C08DE5 		str	ip, [sp, #0]
 3043 197c 04408DE5 		str	r4, [sp, #4]
 3044 1980 FEFFFFEB 		bl	cmdSet
 3045              	.LVL259:
1279:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3046              		.loc 1 1279 0
 3047 1984 14009DE5 		ldr	r0, [sp, #20]
 3048 1988 0510A0E3 		mov	r1, #5
 3049 198c 767040E2 		sub	r7, r0, #118
 3050              	.LVL260:
 3051 1990 FFC007E2 		and	ip, r7, #255
 3052 1994 DC20A0E3 		mov	r2, #220
 3053 1998 0170A0E3 		mov	r7, #1
 3054 199c 0930A0E1 		mov	r3, r9
 3055 19a0 0800A0E1 		mov	r0, r8
 3056 19a4 00C08DE5 		str	ip, [sp, #0]
 3057 19a8 04708DE5 		str	r7, [sp, #4]
 3058 19ac FEFFFFEB 		bl	cmdSet
 3059              	.LVL261:
1281:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3060              		.loc 1 1281 0
 3061 19b0 14309DE5 		ldr	r3, [sp, #20]
 3062 19b4 02C0A0E3 		mov	ip, #2
 3063 19b8 7E1083E2 		add	r1, r3, #126
 3064 19bc FF4001E2 		and	r4, r1, #255
 3065 19c0 DE20A0E3 		mov	r2, #222
 3066 19c4 0510A0E3 		mov	r1, #5
 3067 19c8 0930A0E1 		mov	r3, r9
 3068 19cc 0800A0E1 		mov	r0, r8
 3069 19d0 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3070 19d4 FEFFFFEB 		bl	cmdSet
 3071              	.LVL262:
1283:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3072              		.loc 1 1283 0
 3073 19d8 14209DE5 		ldr	r2, [sp, #20]
 3074 19dc 03C0A0E3 		mov	ip, #3
 3075 19e0 720082E2 		add	r0, r2, #114
 3076 19e4 FF4000E2 		and	r4, r0, #255
 3077 19e8 0510A0E3 		mov	r1, #5
 3078 19ec E020A0E3 		mov	r2, #224
 3079 19f0 0930A0E1 		mov	r3, r9
 3080 19f4 0800A0E1 		mov	r0, r8
 3081 19f8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3082 19fc FEFFFFEB 		bl	cmdSet
 3083              	.LVL263:
1285:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3084              		.loc 1 1285 0
 3085 1a00 14309DE5 		ldr	r3, [sp, #20]
 3086 1a04 04C0A0E3 		mov	ip, #4
 3087 1a08 6F1043E2 		sub	r1, r3, #111
 3088 1a0c FF4001E2 		and	r4, r1, #255
 3089 1a10 DD20A0E3 		mov	r2, #221
 3090 1a14 0510A0E3 		mov	r1, #5
 3091 1a18 0930A0E1 		mov	r3, r9
 3092 1a1c 0800A0E1 		mov	r0, r8
 3093 1a20 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3094 1a24 FEFFFFEB 		bl	cmdSet
 3095              	.LVL264:
1287:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3096              		.loc 1 1287 0
 3097 1a28 D8239FE5 		ldr	r2, .L272+72
 3098 1a2c 05E0A0E3 		mov	lr, #5
 3099 1a30 5C00D2E5 		ldrb	r0, [r2, #92]	@ zero_extendqisi2
 3100 1a34 0E10A0E1 		mov	r1, lr
 3101 1a38 7F3080E2 		add	r3, r0, #127
 3102 1a3c FF4003E2 		and	r4, r3, #255
 3103 1a40 0B20A0E1 		mov	r2, fp
 3104 1a44 0930A0E1 		mov	r3, r9
 3105 1a48 0800A0E1 		mov	r0, r8
 3106 1a4c 10408DE8 		stmia	sp, {r4, lr}	@ phole stm
 3107 1a50 FEFFFFEB 		bl	cmdSet
1288:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3108              		.loc 1 1288 0
 3109 1a54 1C0098E5 		ldr	r0, [r8, #28]
 3110 1a58 FEFFFFEB 		bl	_txe_mutex_put
1290:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3111              		.loc 1 1290 0
 3112 1a5c A4C39FE5 		ldr	ip, .L272+72
1291:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3113              		.loc 1 1291 0
 3114 1a60 0872C6E5 		strb	r7, [r6, #520]
1290:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3115              		.loc 1 1290 0
 3116 1a64 5C10DCE5 		ldrb	r1, [ip, #92]	@ zero_extendqisi2
1292:../uvc.c      **** 							 break;
 3117              		.loc 1 1292 0
 3118 1a68 FFC0A0E3 		mov	ip, #255
1290:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3119              		.loc 1 1290 0
 3120 1a6c 802041E2 		sub	r2, r1, #128
 3121 1a70 0522C6E5 		strb	r2, [r6, #517]
1291:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3122              		.loc 1 1291 0
 3123 1a74 14809DE5 		ldr	r8, [sp, #20]
 3124 1a78 18709DE5 		ldr	r7, [sp, #24]
1292:../uvc.c      **** 							 break;
 3125              		.loc 1 1292 0
 3126 1a7c 0C40A0E1 		mov	r4, ip
 3127 1a80 12FDFFEA 		b	.L144
 3128              	.LVL265:
 3129              	.L188:
1323:../uvc.c      **** 							 Data0 = Data0 - 1;
 3130              		.loc 1 1323 0
 3131 1a84 010043E2 		sub	r0, r3, #1
 3132 1a88 0320A0E1 		mov	r2, r3
 3133              	.LVL266:
1324:../uvc.c      **** 							 is60Hz = Data0;
 3134              		.loc 1 1324 0
 3135 1a8c 74139FE5 		ldr	r1, .L272+72
1323:../uvc.c      **** 							 Data0 = Data0 - 1;
 3136              		.loc 1 1323 0
 3137 1a90 FF3000E2 		and	r3, r0, #255
 3138              	.LVL267:
1336:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3139              		.loc 1 1336 0
 3140 1a94 6C039FE5 		ldr	r0, .L272+72
1330:../uvc.c      **** 							 else if(Data0 >2)
 3141              		.loc 1 1330 0
 3142 1a98 020053E3 		cmp	r3, #2
1322:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3143              		.loc 1 1322 0
 3144 1a9c ED21C6E5 		strb	r2, [r6, #493]
1333:../uvc.c      **** 								 is60Hz = CyTrue;
 3145              		.loc 1 1333 0
 3146 1aa0 0120A083 		movhi	r2, #1
1324:../uvc.c      **** 							 is60Hz = Data0;
 3147              		.loc 1 1324 0
 3148 1aa4 583081E5 		str	r3, [r1, #88]
 3149              	.LVL268:
1333:../uvc.c      **** 								 is60Hz = CyTrue;
 3150              		.loc 1 1333 0
 3151 1aa8 58208185 		strhi	r2, [r1, #88]
1336:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3152              		.loc 1 1336 0
 3153 1aac 28E090E5 		ldr	lr, [r0, #40]
 3154 1ab0 01005EE3 		cmp	lr, #1
 3155 1ab4 4801000A 		beq	.L268
 3156              	.LVL269:
 3157              	.L222:
1366:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3158              		.loc 1 1366 0
 3159 1ab8 0140A0E3 		mov	r4, #1
1367:../uvc.c      **** 							 break;
 3160              		.loc 1 1367 0
 3161 1abc FFC0A0E3 		mov	ip, #255
1366:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3162              		.loc 1 1366 0
 3163 1ac0 F041C6E5 		strb	r4, [r6, #496]
 3164 1ac4 14809DE5 		ldr	r8, [sp, #20]
 3165 1ac8 18709DE5 		ldr	r7, [sp, #24]
1367:../uvc.c      **** 							 break;
 3166              		.loc 1 1367 0
 3167 1acc 0C40A0E1 		mov	r4, ip
 3168 1ad0 FEFCFFEA 		b	.L144
 3169              	.LVL270:
 3170              	.L187:
1417:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3171              		.loc 1 1417 0
 3172 1ad4 20839FE5 		ldr	r8, .L272+60
 3173 1ad8 0010E0E3 		mvn	r1, #0
 3174 1adc 1C0098E5 		ldr	r0, [r8, #28]
 3175 1ae0 FEFFFFEB 		bl	_txe_mutex_get
 3176              	.LVL271:
1418:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3177              		.loc 1 1418 0
 3178 1ae4 0410A0E1 		mov	r1, r4
 3179 1ae8 14409DE5 		ldr	r4, [sp, #20]
 3180 1aec 00C0A0E3 		mov	ip, #0
 3181 1af0 0930A0E1 		mov	r3, r9
 3182 1af4 0A20A0E1 		mov	r2, sl
 3183 1af8 0800A0E1 		mov	r0, r8
 3184 1afc 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3185 1b00 FEFFFFEB 		bl	cmdSet
1419:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3186              		.loc 1 1419 0
 3187 1b04 1C0098E5 		ldr	r0, [r8, #28]
 3188 1b08 FEFFFFEB 		bl	_txe_mutex_put
1421:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3189              		.loc 1 1421 0
 3190 1b0c 14109DE5 		ldr	r1, [sp, #20]
1426:../uvc.c      **** 							 break;
 3191              		.loc 1 1426 0
 3192 1b10 FFC0A0E3 		mov	ip, #255
1422:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3193              		.loc 1 1422 0
 3194 1b14 0130A0E3 		mov	r3, #1
1421:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3195              		.loc 1 1421 0
 3196 1b18 BD11C6E5 		strb	r1, [r6, #445]
1422:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3197              		.loc 1 1422 0
 3198 1b1c C031C6E5 		strb	r3, [r6, #448]
 3199 1b20 0180A0E1 		mov	r8, r1
 3200 1b24 18709DE5 		ldr	r7, [sp, #24]
 3201              	.LVL272:
1426:../uvc.c      **** 							 break;
 3202              		.loc 1 1426 0
 3203 1b28 0C40A0E1 		mov	r4, ip
 3204 1b2c E7FCFFEA 		b	.L144
 3205              	.LVL273:
 3206              	.L194:
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3207              		.loc 1 1076 0
 3208 1b30 C4429FE5 		ldr	r4, .L272+60
1072:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3209              		.loc 1 1072 0
 3210 1b34 B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
1073:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3211              		.loc 1 1073 0
 3212 1b38 B974D6E5 		ldrb	r7, [r6, #1209]	@ zero_extendqisi2
 3213              	.LVL274:
1074:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3214              		.loc 1 1074 0
 3215 1b3c C734D6E5 		ldrb	r3, [r6, #1223]	@ zero_extendqisi2
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3216              		.loc 1 1076 0
 3217 1b40 1C0094E5 		ldr	r0, [r4, #28]
 3218 1b44 0010E0E3 		mvn	r1, #0
1073:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3219              		.loc 1 1073 0
 3220 1b48 FF9007E2 		and	r9, r7, #255
1074:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3221              		.loc 1 1074 0
 3222 1b4c FF7003E2 		and	r7, r3, #255
1076:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3223              		.loc 1 1076 0
 3224 1b50 FEFFFFEB 		bl	_txe_mutex_get
 3225              	.LVL275:
1077:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3226              		.loc 1 1077 0
 3227 1b54 14C09DE5 		ldr	ip, [sp, #20]
 3228 1b58 C504D6E5 		ldrb	r0, [r6, #1221]	@ zero_extendqisi2
1072:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3229              		.loc 1 1072 0
 3230 1b5c FFA00AE2 		and	sl, sl, #255
 3231              	.LVL276:
1077:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3232              		.loc 1 1077 0
 3233 1b60 00005CE1 		cmp	ip, r0
1072:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3234              		.loc 1 1072 0
 3235 1b64 54329FE5 		ldr	r3, .L272
 3236 1b68 0C80A001 		moveq	r8, ip
1077:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3237              		.loc 1 1077 0
 3238 1b6c 0A00000A 		beq	.L207
1079:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3239              		.loc 1 1079 0
 3240 1b70 C5C4C3E5 		strb	ip, [r3, #1221]
1080:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3241              		.loc 1 1080 0
 3242 1b74 9D24D3E5 		ldrb	r2, [r3, #1181]	@ zero_extendqisi2
1081:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3243              		.loc 1 1081 0
 3244 1b78 0400A0E1 		mov	r0, r4
1080:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3245              		.loc 1 1080 0
 3246 1b7c 02E28CE1 		orr	lr, ip, r2, asl #4
 3247 1b80 FF800EE2 		and	r8, lr, #255
 3248              	.LVL277:
1081:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3249              		.loc 1 1081 0
 3250 1b84 00C0A0E3 		mov	ip, #0
 3251 1b88 1910A0E3 		mov	r1, #25
 3252 1b8c 0A20A0E1 		mov	r2, sl
 3253 1b90 0730A0E1 		mov	r3, r7
 3254 1b94 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3255 1b98 FEFFFFEB 		bl	cmdSet
 3256              	.LVL278:
 3257              	.L207:
1093:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3258              		.loc 1 1093 0
 3259 1b9c C614D6E5 		ldrb	r1, [r6, #1222]	@ zero_extendqisi2
 3260 1ba0 18009DE5 		ldr	r0, [sp, #24]
 3261 1ba4 000051E1 		cmp	r1, r0
 3262 1ba8 0500000A 		beq	.L208
1095:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3263              		.loc 1 1095 0
 3264 1bac 14E09DE5 		ldr	lr, [sp, #20]
1094:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3265              		.loc 1 1094 0
 3266 1bb0 08329FE5 		ldr	r3, .L272
1095:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3267              		.loc 1 1095 0
 3268 1bb4 02C04EE2 		sub	ip, lr, #2
 3269 1bb8 01005CE3 		cmp	ip, #1
1094:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3270              		.loc 1 1094 0
 3271 1bbc C604C3E5 		strb	r0, [r3, #1222]
1095:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3272              		.loc 1 1095 0
 3273 1bc0 8901009A 		bls	.L269
 3274              	.LVL279:
 3275              	.L208:
1100:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3276              		.loc 1 1100 0
 3277 1bc4 1C0094E5 		ldr	r0, [r4, #28]
 3278 1bc8 FEFFFFEB 		bl	_txe_mutex_put
1102:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3279              		.loc 1 1102 0
 3280 1bcc C524D6E5 		ldrb	r2, [r6, #1221]	@ zero_extendqisi2
1101:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3281              		.loc 1 1101 0
 3282 1bd0 18709DE5 		ldr	r7, [sp, #24]
1102:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3283              		.loc 1 1102 0
 3284 1bd4 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 3285 1bd8 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
1101:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3286              		.loc 1 1101 0
 3287 1bdc 0400A0E3 		mov	r0, #4
 3288 1be0 04129FE5 		ldr	r1, .L272+44
 3289 1be4 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3290 1be8 08708DE5 		str	r7, [sp, #8]
 3291 1bec FEFFFFEB 		bl	CyU3PDebugPrint
1103:../uvc.c      **** 							 break;
 3292              		.loc 1 1103 0
 3293 1bf0 FFC0A0E3 		mov	ip, #255
1101:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3294              		.loc 1 1101 0
 3295 1bf4 14809DE5 		ldr	r8, [sp, #20]
 3296              	.LVL280:
1103:../uvc.c      **** 							 break;
 3297              		.loc 1 1103 0
 3298 1bf8 0C40A0E1 		mov	r4, ip
 3299 1bfc B3FCFFEA 		b	.L144
 3300              	.LVL281:
 3301              	.L186:
1258:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3302              		.loc 1 1258 0
 3303 1c00 F4819FE5 		ldr	r8, .L272+60
 3304 1c04 0010E0E3 		mvn	r1, #0
 3305 1c08 1C0098E5 		ldr	r0, [r8, #28]
 3306 1c0c FEFFFFEB 		bl	_txe_mutex_get
 3307              	.LVL282:
1260:../uvc.c      **** 							  if(Data0&0x80){
 3308              		.loc 1 1260 0
 3309 1c10 14009DE5 		ldr	r0, [sp, #20]
1265:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3310              		.loc 1 1265 0
 3311 1c14 0930A0E1 		mov	r3, r9
1260:../uvc.c      **** 							  if(Data0&0x80){
 3312              		.loc 1 1260 0
 3313 1c18 800010E3 		tst	r0, #128
1261:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3314              		.loc 1 1261 0
 3315 1c1c 80704012 		subne	r7, r0, #128
 3316              	.LVL283:
1263:../uvc.c      **** 								  Data0 = ~Data0;
 3317              		.loc 1 1263 0
 3318 1c20 0070E001 		mvneq	r7, r0
 3319 1c24 FF7007E2 		and	r7, r7, #255
 3320              	.LVL284:
1265:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3321              		.loc 1 1265 0
 3322 1c28 0110A0E3 		mov	r1, #1
 3323 1c2c 0B20A0E1 		mov	r2, fp
 3324 1c30 0040A0E3 		mov	r4, #0
 3325 1c34 C0019FE5 		ldr	r0, .L272+60
 3326 1c38 00708DE5 		str	r7, [sp, #0]
 3327 1c3c 04408DE5 		str	r4, [sp, #4]
 3328 1c40 FEFFFFEB 		bl	cmdSet
1266:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3329              		.loc 1 1266 0
 3330 1c44 1C0098E5 		ldr	r0, [r8, #28]
 3331 1c48 FEFFFFEB 		bl	_txe_mutex_put
1272:../uvc.c      **** 							 break;
 3332              		.loc 1 1272 0
 3333 1c4c FFC0A0E3 		mov	ip, #255
1269:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3334              		.loc 1 1269 0
 3335 1c50 0130A0E3 		mov	r3, #1
1268:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3336              		.loc 1 1268 0
 3337 1c54 A571C6E5 		strb	r7, [r6, #421]
1269:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3338              		.loc 1 1269 0
 3339 1c58 A831C6E5 		strb	r3, [r6, #424]
 3340 1c5c 14809DE5 		ldr	r8, [sp, #20]
 3341 1c60 18709DE5 		ldr	r7, [sp, #24]
 3342              	.LVL285:
1272:../uvc.c      **** 							 break;
 3343              		.loc 1 1272 0
 3344 1c64 0C40A0E1 		mov	r4, ip
 3345 1c68 98FCFFEA 		b	.L144
 3346              	.LVL286:
 3347              	.L185:
1379:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3348              		.loc 1 1379 0
 3349 1c6c 94219FE5 		ldr	r2, .L272+72
 3350              	.LVL287:
1369:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3351              		.loc 1 1369 0
 3352 1c70 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3353              	.LVL288:
1379:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3354              		.loc 1 1379 0
 3355 1c74 7C20D2E5 		ldrb	r2, [r2, #124]	@ zero_extendqisi2
 3356 1c78 03C0A0E1 		mov	ip, r3
1370:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3357              		.loc 1 1370 0
 3358 1c7c F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1371:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3359              		.loc 1 1371 0
 3360 1c80 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1379:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3361              		.loc 1 1379 0
 3362 1c84 010052E3 		cmp	r2, #1
1377:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3363              		.loc 1 1377 0
 3364 1c88 0110A0E3 		mov	r1, #1
1376:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3365              		.loc 1 1376 0
 3366 1c8c 05C5C6E5 		strb	ip, [r6, #1285]
1369:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3367              		.loc 1 1369 0
 3368 1c90 FF7007E2 		and	r7, r7, #255
 3369              	.LVL289:
1377:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3370              		.loc 1 1377 0
 3371 1c94 0915C6E5 		strb	r1, [r6, #1289]
1371:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3372              		.loc 1 1371 0
 3373 1c98 FF8008E2 		and	r8, r8, #255
 3374              	.LVL290:
 3375 1c9c 0C60A011 		movne	r6, ip
1379:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3376              		.loc 1 1379 0
 3377 1ca0 3301000A 		beq	.L270
 3378              	.LVL291:
 3379              	.L236:
1390:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3380              		.loc 1 1390 0
 3381 1ca4 50419FE5 		ldr	r4, .L272+60
 3382 1ca8 0010E0E3 		mvn	r1, #0
 3383 1cac 1C0094E5 		ldr	r0, [r4, #28]
 3384 1cb0 FEFFFFEB 		bl	_txe_mutex_get
1391:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3385              		.loc 1 1391 0
 3386 1cb4 00C0A0E3 		mov	ip, #0
 3387 1cb8 0C10A0E1 		mov	r1, ip
 3388 1cbc 0720A0E1 		mov	r2, r7
 3389 1cc0 0830A0E1 		mov	r3, r8
 3390 1cc4 0400A0E1 		mov	r0, r4
 3391 1cc8 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3392 1ccc FEFFFFEB 		bl	cmdSet
1392:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3393              		.loc 1 1392 0
 3394 1cd0 1C0094E5 		ldr	r0, [r4, #28]
 3395 1cd4 D1FEFFEA 		b	.L261
 3396              	.LVL292:
 3397              	.L184:
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3398              		.loc 1 1430 0
 3399 1cd8 1C819FE5 		ldr	r8, .L272+60
 3400 1cdc 0010E0E3 		mvn	r1, #0
 3401 1ce0 1C0098E5 		ldr	r0, [r8, #28]
 3402 1ce4 FEFFFFEB 		bl	_txe_mutex_get
 3403              	.LVL293:
1431:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3404              		.loc 1 1431 0
 3405 1ce8 14709DE5 		ldr	r7, [sp, #20]
 3406              	.LVL294:
 3407 1cec 00C0A0E3 		mov	ip, #0
 3408 1cf0 0410A0E1 		mov	r1, r4
 3409 1cf4 0A20A0E1 		mov	r2, sl
 3410 1cf8 0930A0E1 		mov	r3, r9
 3411 1cfc 0800A0E1 		mov	r0, r8
 3412 1d00 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3413 1d04 FEFFFFEB 		bl	cmdSet
1432:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3414              		.loc 1 1432 0
 3415 1d08 1C0098E5 		ldr	r0, [r8, #28]
 3416 1d0c FEFFFFEB 		bl	_txe_mutex_put
1434:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3417              		.loc 1 1434 0
 3418 1d10 14209DE5 		ldr	r2, [sp, #20]
 3419 1d14 847084E0 		add	r7, r4, r4, asl #1
 3420 1d18 876186E0 		add	r6, r6, r7, asl #3
1436:../uvc.c      **** 							 break;
 3421              		.loc 1 1436 0
 3422 1d1c FFC0A0E3 		mov	ip, #255
1435:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3423              		.loc 1 1435 0
 3424 1d20 0100A0E3 		mov	r0, #1
1434:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3425              		.loc 1 1434 0
 3426 1d24 8D21C6E5 		strb	r2, [r6, #397]
1435:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3427              		.loc 1 1435 0
 3428 1d28 9001C6E5 		strb	r0, [r6, #400]
 3429 1d2c 0280A0E1 		mov	r8, r2
 3430 1d30 18709DE5 		ldr	r7, [sp, #24]
1436:../uvc.c      **** 							 break;
 3431              		.loc 1 1436 0
 3432 1d34 0C40A0E1 		mov	r4, ip
 3433 1d38 64FCFFEA 		b	.L144
 3434              	.LVL295:
 3435              	.L192:
1310:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3436              		.loc 1 1310 0
 3437 1d3c B8409FE5 		ldr	r4, .L272+60
 3438 1d40 0010E0E3 		mvn	r1, #0
 3439 1d44 1C0094E5 		ldr	r0, [r4, #28]
 3440 1d48 FEFFFFEB 		bl	_txe_mutex_get
 3441              	.LVL296:
1311:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3442              		.loc 1 1311 0
 3443 1d4c 14809DE5 		ldr	r8, [sp, #20]
 3444 1d50 00C0A0E3 		mov	ip, #0
 3445 1d54 0B10A0E3 		mov	r1, #11
 3446 1d58 0A20A0E1 		mov	r2, sl
 3447 1d5c 0930A0E1 		mov	r3, r9
 3448 1d60 0400A0E1 		mov	r0, r4
 3449 1d64 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 3450 1d68 FEFFFFEB 		bl	cmdSet
 3451              	.LVL297:
1313:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3452              		.loc 1 1313 0
 3453 1d6c 18809DE5 		ldr	r8, [sp, #24]
 3454 1d70 0170A0E3 		mov	r7, #1
 3455              	.LVL298:
 3456 1d74 0930A0E1 		mov	r3, r9
 3457 1d78 0B10A0E3 		mov	r1, #11
 3458 1d7c 0B20A0E1 		mov	r2, fp
 3459 1d80 0400A0E1 		mov	r0, r4
 3460 1d84 00808DE5 		str	r8, [sp, #0]
 3461 1d88 04708DE5 		str	r7, [sp, #4]
 3462 1d8c FEFFFFEB 		bl	cmdSet
1314:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3463              		.loc 1 1314 0
 3464 1d90 1C0094E5 		ldr	r0, [r4, #28]
 3465 1d94 FEFFFFEB 		bl	_txe_mutex_put
1316:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3466              		.loc 1 1316 0
 3467 1d98 14009DE5 		ldr	r0, [sp, #20]
1317:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3468              		.loc 1 1317 0
 3469 1d9c 18309DE5 		ldr	r3, [sp, #24]
1319:../uvc.c      **** 							 break;
 3470              		.loc 1 1319 0
 3471 1da0 FFC0A0E3 		mov	ip, #255
1318:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3472              		.loc 1 1318 0
 3473 1da4 9872C6E5 		strb	r7, [r6, #664]
1316:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3474              		.loc 1 1316 0
 3475 1da8 CC04C6E5 		strb	r0, [r6, #1228]
1317:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3476              		.loc 1 1317 0
 3477 1dac CE34C6E5 		strb	r3, [r6, #1230]
1318:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3478              		.loc 1 1318 0
 3479 1db0 0080A0E1 		mov	r8, r0
 3480 1db4 0370A0E1 		mov	r7, r3
1319:../uvc.c      **** 							 break;
 3481              		.loc 1 1319 0
 3482 1db8 0C40A0E1 		mov	r4, ip
 3483 1dbc 43FCFFEA 		b	.L144
 3484              	.L273:
 3485              		.align	2
 3486              	.L272:
 3487 1dc0 00000000 		.word	.LANCHOR1
 3488 1dc4 00000000 		.word	bRequest
 3489 1dc8 44040000 		.word	.LC26
 3490 1dcc 5C000000 		.word	.LANCHOR0+92
 3491 1dd0 01000100 		.word	65537
 3492 1dd4 FF00FF00 		.word	16711935
 3493 1dd8 00000000 		.word	.LANCHOR2
 3494 1ddc F4020000 		.word	.LC19
 3495 1de0 30030000 		.word	.LC20
 3496 1de4 4C000000 		.word	.LANCHOR0+76
 3497 1de8 B8030000 		.word	.LC23
 3498 1dec 84030000 		.word	.LC22
 3499 1df0 58030000 		.word	.LC21
 3500 1df4 14040000 		.word	.LC25
 3501 1df8 F0030000 		.word	.LC24
 3502 1dfc 00000000 		.word	cmdQu
 3503 1e00 BC020000 		.word	.LC18
 3504 1e04 00000000 		.word	.LANCHOR1
 3505 1e08 00000000 		.word	.LANCHOR0
 3506              	.LVL299:
 3507              	.L191:
1396:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3508              		.loc 1 1396 0
 3509 1e0c 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1397:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3510              		.loc 1 1397 0
 3511 1e10 0DA5D6E5 		ldrb	sl, [r6, #1293]	@ zero_extendqisi2
1398:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3512              		.loc 1 1398 0
 3513 1e14 1BE5D6E5 		ldrb	lr, [r6, #1307]	@ zero_extendqisi2
1401:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3514              		.loc 1 1401 0
 3515 1e18 0140A0E3 		mov	r4, #1
1402:../uvc.c      **** 							 if(Data0 != 0){
 3516              		.loc 1 1402 0
 3517 1e1c 000053E3 		cmp	r3, #0
1400:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3518              		.loc 1 1400 0
 3519 1e20 1935C6E5 		strb	r3, [r6, #1305]
1396:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3520              		.loc 1 1396 0
 3521 1e24 FF8000E2 		and	r8, r0, #255
 3522              	.LVL300:
1397:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3523              		.loc 1 1397 0
 3524 1e28 FFA00AE2 		and	sl, sl, #255
 3525              	.LVL301:
1398:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3526              		.loc 1 1398 0
 3527 1e2c FF700EE2 		and	r7, lr, #255
 3528              	.LVL302:
1401:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3529              		.loc 1 1401 0
 3530 1e30 1D45C6E5 		strb	r4, [r6, #1309]
1402:../uvc.c      **** 							 if(Data0 != 0){
 3531              		.loc 1 1402 0
 3532 1e34 5500000A 		beq	.L238
1403:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3533              		.loc 1 1403 0
 3534 1e38 44601FE5 		ldr	r6, .L272+60
 3535 1e3c 0010E0E3 		mvn	r1, #0
 3536 1e40 1C0096E5 		ldr	r0, [r6, #28]
 3537 1e44 FEFFFFEB 		bl	_txe_mutex_get
 3538              	.LVL303:
1404:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 3539              		.loc 1 1404 0
 3540 1e48 0820A0E1 		mov	r2, r8
 3541 1e4c 00C0A0E3 		mov	ip, #0
 3542 1e50 0710A0E3 		mov	r1, #7
 3543 1e54 0730A0E1 		mov	r3, r7
 3544 1e58 0600A0E1 		mov	r0, r6
 3545 1e5c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3546 1e60 FEFFFFEB 		bl	cmdSet
 3547              	.LVL304:
1406:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 3548              		.loc 1 1406 0
 3549 1e64 14809DE5 		ldr	r8, [sp, #20]
 3550              	.LVL305:
 3551 1e68 0710A0E3 		mov	r1, #7
 3552 1e6c 0A20A0E1 		mov	r2, sl
 3553 1e70 0730A0E1 		mov	r3, r7
 3554 1e74 0600A0E1 		mov	r0, r6
 3555 1e78 00808DE5 		str	r8, [sp, #0]
 3556 1e7c 04408DE5 		str	r4, [sp, #4]
 3557 1e80 FEFFFFEB 		bl	cmdSet
1407:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3558              		.loc 1 1407 0
 3559 1e84 1C0096E5 		ldr	r0, [r6, #28]
 3560 1e88 64FEFFEA 		b	.L261
 3561              	.LVL306:
 3562              	.L193:
1012:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3563              		.loc 1 1012 0
 3564 1e8c 9074D6E5 		ldrb	r7, [r6, #1168]	@ zero_extendqisi2
 3565              	.LVL307:
 3566 1e90 0310A0E1 		mov	r1, r3
1013:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3567              		.loc 1 1013 0
 3568 1e94 9184D6E5 		ldrb	r8, [r6, #1169]	@ zero_extendqisi2
1014:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3569              		.loc 1 1014 0
 3570 1e98 9F44D6E5 		ldrb	r4, [r6, #1183]	@ zero_extendqisi2
1015:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3571              		.loc 1 1015 0
 3572 1e9c 9D34C6E5 		strb	r3, [r6, #1181]
1017:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3573              		.loc 1 1017 0
 3574 1ea0 C534D6E5 		ldrb	r3, [r6, #1221]	@ zero_extendqisi2
1012:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3575              		.loc 1 1012 0
 3576 1ea4 FF7007E2 		and	r7, r7, #255
 3577              	.LVL308:
1017:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3578              		.loc 1 1017 0
 3579 1ea8 030013E3 		tst	r3, #3
1013:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3580              		.loc 1 1013 0
 3581 1eac FF8008E2 		and	r8, r8, #255
 3582              	.LVL309:
1014:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3583              		.loc 1 1014 0
 3584 1eb0 FF4004E2 		and	r4, r4, #255
 3585              	.LVL310:
1017:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3586              		.loc 1 1017 0
 3587 1eb4 0130A001 		moveq	r3, r1
 3588 1eb8 1A00000A 		beq	.L206
 3589 1ebc 0120A0E1 		mov	r2, r1
 3590              	.LVL311:
1019:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3591              		.loc 1 1019 0
 3592 1ec0 C4101FE5 		ldr	r1, .L272+68
1021:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3593              		.loc 1 1021 0
 3594 1ec4 D0A01FE5 		ldr	sl, .L272+60
1019:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3595              		.loc 1 1019 0
 3596 1ec8 C5E4D1E5 		ldrb	lr, [r1, #1221]	@ zero_extendqisi2
1021:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3597              		.loc 1 1021 0
 3598 1ecc 1C009AE5 		ldr	r0, [sl, #28]
 3599 1ed0 0010E0E3 		mvn	r1, #0
1019:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3600              		.loc 1 1019 0
 3601 1ed4 02928EE1 		orr	r9, lr, r2, asl #4
1021:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3602              		.loc 1 1021 0
 3603 1ed8 FEFFFFEB 		bl	_txe_mutex_get
1022:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3604              		.loc 1 1022 0
 3605 1edc 00C0A0E3 		mov	ip, #0
 3606 1ee0 1010A0E3 		mov	r1, #16
 3607 1ee4 0820A0E1 		mov	r2, r8
 3608 1ee8 0430A0E1 		mov	r3, r4
 3609 1eec 0A00A0E1 		mov	r0, sl
1019:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3610              		.loc 1 1019 0
 3611 1ef0 FF9009E2 		and	r9, r9, #255
 3612              	.LVL312:
1022:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3613              		.loc 1 1022 0
 3614 1ef4 00C08DE5 		str	ip, [sp, #0]
 3615 1ef8 04C08DE5 		str	ip, [sp, #4]
 3616 1efc FEFFFFEB 		bl	cmdSet
 3617              	.LVL313:
1024:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3618              		.loc 1 1024 0
 3619 1f00 0430A0E1 		mov	r3, r4
 3620 1f04 01C0A0E3 		mov	ip, #1
 3621 1f08 1010A0E3 		mov	r1, #16
 3622 1f0c 0720A0E1 		mov	r2, r7
 3623 1f10 0A00A0E1 		mov	r0, sl
 3624 1f14 00128DE8 		stmia	sp, {r9, ip}	@ phole stm
 3625 1f18 FEFFFFEB 		bl	cmdSet
1025:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3626              		.loc 1 1025 0
 3627 1f1c 1C009AE5 		ldr	r0, [sl, #28]
 3628 1f20 FEFFFFEB 		bl	_txe_mutex_put
 3629 1f24 0930A0E1 		mov	r3, r9
 3630              	.LVL314:
 3631              	.L206:
1028:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3632              		.loc 1 1028 0
 3633 1f28 C584D6E5 		ldrb	r8, [r6, #1221]	@ zero_extendqisi2
 3634              	.LVL315:
 3635 1f2c 9D44D6E5 		ldrb	r4, [r6, #1181]	@ zero_extendqisi2
 3636              	.LVL316:
1027:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3637              		.loc 1 1027 0
 3638 1f30 0400A0E3 		mov	r0, #4
 3639 1f34 4C111FE5 		ldr	r1, .L272+48
 3640 1f38 1C209DE5 		ldr	r2, [sp, #28]
 3641 1f3c 00808DE5 		str	r8, [sp, #0]
 3642 1f40 04408DE5 		str	r4, [sp, #4]
 3643 1f44 FEFFFFEB 		bl	CyU3PDebugPrint
1029:../uvc.c      **** 						     break;
 3644              		.loc 1 1029 0
 3645 1f48 FFC0A0E3 		mov	ip, #255
1027:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3646              		.loc 1 1027 0
 3647 1f4c 14809DE5 		ldr	r8, [sp, #20]
 3648 1f50 18709DE5 		ldr	r7, [sp, #24]
 3649              	.LVL317:
1029:../uvc.c      **** 						     break;
 3650              		.loc 1 1029 0
 3651 1f54 0C40A0E1 		mov	r4, ip
 3652 1f58 DCFBFFEA 		b	.L144
 3653              	.LVL318:
 3654              	.L183:
1439:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 3655              		.loc 1 1439 0
 3656 1f5c 0400A0E3 		mov	r0, #4
 3657              	.LVL319:
 3658 1f60 74111FE5 		ldr	r1, .L272+52
 3659 1f64 FEFFFFEB 		bl	CyU3PDebugPrint
 3660              	.LVL320:
 3661 1f68 FFC0A0E3 		mov	ip, #255
 3662 1f6c 0C40A0E1 		mov	r4, ip
 3663 1f70 0C70A0E1 		mov	r7, ip
 3664              	.LVL321:
 3665 1f74 0C80A0E1 		mov	r8, ip
 3666 1f78 D4FBFFEA 		b	.L144
 3667              	.LVL322:
 3668              	.L267:
 811:../uvc.c      **** 						if(sendData >= 3){
 3669              		.loc 1 811 0
 3670 1f7c 020054E3 		cmp	r4, #2
 3671 1f80 A300008A 		bhi	.L271
 3672              	.LVL323:
 3673              	.L163:
 816:../uvc.c      **** 						sendData += 4;
 3674              		.loc 1 816 0
 3675 1f84 040084E2 		add	r0, r4, #4
 3676 1f88 FF4000E2 		and	r4, r0, #255
 3677              	.LVL324:
 3678 1f8c 0EFDFFEA 		b	.L162
 3679              	.LVL325:
 3680              	.L238:
1409:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3681              		.loc 1 1409 0
 3682 1f90 9C411FE5 		ldr	r4, .L272+60
 3683 1f94 0010E0E3 		mvn	r1, #0
 3684 1f98 1C0094E5 		ldr	r0, [r4, #28]
 3685 1f9c FEFFFFEB 		bl	_txe_mutex_get
 3686              	.LVL326:
1410:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 3687              		.loc 1 1410 0
 3688 1fa0 0730A0E1 		mov	r3, r7
 3689 1fa4 14709DE5 		ldr	r7, [sp, #20]
 3690              	.LVL327:
 3691 1fa8 0820A0E1 		mov	r2, r8
 3692 1fac 0710A0E3 		mov	r1, #7
 3693 1fb0 0400A0E1 		mov	r0, r4
 3694 1fb4 00708DE5 		str	r7, [sp, #0]
 3695 1fb8 04708DE5 		str	r7, [sp, #4]
 3696 1fbc FEFFFFEB 		bl	cmdSet
 3697              	.LVL328:
1411:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3698              		.loc 1 1411 0
 3699 1fc0 1C0094E5 		ldr	r0, [r4, #28]
 3700 1fc4 FEFFFFEB 		bl	_txe_mutex_put
 3701 1fc8 FFC0A0E3 		mov	ip, #255
 3702 1fcc 18709DE5 		ldr	r7, [sp, #24]
 3703 1fd0 0C40A0E1 		mov	r4, ip
 3704 1fd4 14809DE5 		ldr	r8, [sp, #20]
 3705              	.LVL329:
 3706 1fd8 BCFBFFEA 		b	.L144
 3707              	.LVL330:
 3708              	.L268:
1339:../uvc.c      **** 			                       switch (setRes)
 3709              		.loc 1 1339 0
 3710 1fdc 7D40D0E5 		ldrb	r4, [r0, #125]	@ zero_extendqisi2
 3711 1fe0 017044E2 		sub	r7, r4, #1
 3712              	.LVL331:
 3713 1fe4 030057E3 		cmp	r7, #3
 3714 1fe8 07F19F97 		ldrls	pc, [pc, r7, asl #2]
 3715 1fec B1FEFFEA 		b	.L222
 3716              	.L227:
 3717 1ff0 20210000 		.word	.L223
 3718 1ff4 CC200000 		.word	.L224
 3719 1ff8 64200000 		.word	.L225
 3720 1ffc 00200000 		.word	.L226
 3721              	.L226:
1357:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 3722              		.loc 1 1357 0
 3723 2000 00321FE5 		ldr	r3, .L272+72
 3724 2004 3010A0E3 		mov	r1, #48
 3725 2008 58E093E5 		ldr	lr, [r3, #88]
 3726 200c 8C04D6E5 		ldrb	r0, [r6, #1164]	@ zero_extendqisi2
 3727 2010 00005EE3 		cmp	lr, #0
 3728 2014 F4E0A003 		moveq	lr, #244
 3729 2018 74E0A013 		movne	lr, #116
 3730 201c 00208EE1 		orr	r2, lr, r0
 3731 2020 5230A0E3 		mov	r3, #82
 3732 2024 0100A0E3 		mov	r0, #1
 3733 2028 FEFFFFEB 		bl	SensorSetIrisControl
1358:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3734              		.loc 1 1358 0
 3735 202c 7D0FA0E3 		mov	r0, #500
 3736 2030 FEFFFFEB 		bl	_tx_thread_sleep
1359:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3737              		.loc 1 1359 0
 3738 2034 34121FE5 		ldr	r1, .L272+72
 3739 2038 0400A0E3 		mov	r0, #4
 3740 203c 587091E5 		ldr	r7, [r1, #88]
 3741 2040 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3742 2044 000057E3 		cmp	r7, #0
 3743 2048 F470A003 		moveq	r7, #244
 3744 204c 7470A013 		movne	r7, #116
 3745 2050 583091E5 		ldr	r3, [r1, #88]
 3746 2054 022087E1 		orr	r2, r7, r2
 3747 2058 68121FE5 		ldr	r1, .L272+56
 3748 205c FEFFFFEB 		bl	CyU3PDebugPrint
 3749 2060 94FEFFEA 		b	.L222
 3750              	.L225:
1352:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3751              		.loc 1 1352 0
 3752 2064 64821FE5 		ldr	r8, .L272+72
1354:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3753              		.loc 1 1354 0
 3754 2068 68721FE5 		ldr	r7, .L272+72
1352:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 3755              		.loc 1 1352 0
 3756 206c 584098E5 		ldr	r4, [r8, #88]
 3757 2070 8CC4D6E5 		ldrb	ip, [r6, #1164]	@ zero_extendqisi2
 3758 2074 000054E3 		cmp	r4, #0
 3759 2078 C440A003 		moveq	r4, #196
 3760 207c 4440A013 		movne	r4, #68
 3761 2080 0C2084E1 		orr	r2, r4, ip
 3762 2084 3010A0E3 		mov	r1, #48
 3763 2088 5230A0E3 		mov	r3, #82
 3764 208c 0100A0E3 		mov	r0, #1
 3765 2090 FEFFFFEB 		bl	SensorSetIrisControl
1353:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3766              		.loc 1 1353 0
 3767 2094 7D0FA0E3 		mov	r0, #500
 3768 2098 FEFFFFEB 		bl	_tx_thread_sleep
1354:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 3769              		.loc 1 1354 0
 3770 209c 580097E5 		ldr	r0, [r7, #88]
 3771 20a0 A0321FE5 		ldr	r3, .L272+72
 3772 20a4 8C24D6E5 		ldrb	r2, [r6, #1164]	@ zero_extendqisi2
 3773 20a8 000050E3 		cmp	r0, #0
 3774 20ac C400A003 		moveq	r0, #196
 3775 20b0 4400A013 		movne	r0, #68
 3776 20b4 022080E1 		orr	r2, r0, r2
 3777 20b8 583093E5 		ldr	r3, [r3, #88]
 3778 20bc CC121FE5 		ldr	r1, .L272+56
 3779 20c0 0400A0E3 		mov	r0, #4
 3780 20c4 FEFFFFEB 		bl	CyU3PDebugPrint
1355:../uvc.c      **** 			                         		break;
 3781              		.loc 1 1355 0
 3782 20c8 7AFEFFEA 		b	.L222
 3783              	.L224:
1347:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 3784              		.loc 1 1347 0
 3785 20cc CCE21FE5 		ldr	lr, .L272+72
 3786 20d0 3010A0E3 		mov	r1, #48
 3787 20d4 58209EE5 		ldr	r2, [lr, #88]
 3788 20d8 5230A0E3 		mov	r3, #82
 3789 20dc 000052E3 		cmp	r2, #0
 3790 20e0 D420A003 		moveq	r2, #212
 3791 20e4 5420A013 		movne	r2, #84
 3792 20e8 0100A0E3 		mov	r0, #1
 3793 20ec FEFFFFEB 		bl	SensorSetIrisControl
1348:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3794              		.loc 1 1348 0
 3795 20f0 7D0FA0E3 		mov	r0, #500
 3796 20f4 FEFFFFEB 		bl	_tx_thread_sleep
1349:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3797              		.loc 1 1349 0
 3798 20f8 F8121FE5 		ldr	r1, .L272+72
 3799 20fc 0400A0E3 		mov	r0, #4
 3800 2100 582091E5 		ldr	r2, [r1, #88]
 3801 2104 583091E5 		ldr	r3, [r1, #88]
 3802 2108 000052E3 		cmp	r2, #0
 3803 210c 1C131FE5 		ldr	r1, .L272+56
 3804 2110 D420A003 		moveq	r2, #212
 3805 2114 5420A013 		movne	r2, #84
 3806 2118 FEFFFFEB 		bl	CyU3PDebugPrint
1350:../uvc.c      **** 			                         		break;
 3807              		.loc 1 1350 0
 3808 211c 65FEFFEA 		b	.L222
 3809              	.L223:
1342:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 3810              		.loc 1 1342 0
 3811 2120 20831FE5 		ldr	r8, .L272+72
 3812 2124 3010A0E3 		mov	r1, #48
 3813 2128 582098E5 		ldr	r2, [r8, #88]
 3814 212c 5230A0E3 		mov	r3, #82
 3815 2130 000052E3 		cmp	r2, #0
 3816 2134 E420A003 		moveq	r2, #228
 3817 2138 6420A013 		movne	r2, #100
 3818 213c 0100A0E3 		mov	r0, #1
 3819 2140 FEFFFFEB 		bl	SensorSetIrisControl
1343:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 3820              		.loc 1 1343 0
 3821 2144 7D0FA0E3 		mov	r0, #500
 3822 2148 FEFFFFEB 		bl	_tx_thread_sleep
1344:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 3823              		.loc 1 1344 0
 3824 214c 4CC31FE5 		ldr	ip, .L272+72
 3825 2150 60131FE5 		ldr	r1, .L272+56
 3826 2154 58209CE5 		ldr	r2, [ip, #88]
 3827 2158 0400A0E3 		mov	r0, #4
 3828 215c 000052E3 		cmp	r2, #0
 3829 2160 58309CE5 		ldr	r3, [ip, #88]
 3830 2164 E420A003 		moveq	r2, #228
 3831 2168 6420A013 		movne	r2, #100
 3832 216c FEFFFFEB 		bl	CyU3PDebugPrint
1345:../uvc.c      **** 			                         		break;
 3833              		.loc 1 1345 0
 3834 2170 50FEFFEA 		b	.L222
 3835              	.LVL332:
 3836              	.L270:
1381:../uvc.c      **** 								 if(Data0 < 3){
 3837              		.loc 1 1381 0
 3838 2174 02005CE3 		cmp	ip, #2
1382:../uvc.c      **** 					 				 Data0 += 4;
 3839              		.loc 1 1382 0
 3840 2178 04608C92 		addls	r6, ip, #4
 3841 217c FF600692 		andls	r6, r6, #255
1381:../uvc.c      **** 								 if(Data0 < 3){
 3842              		.loc 1 1381 0
 3843 2180 C7FEFF9A 		bls	.L236
1384:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 3844              		.loc 1 1384 0
 3845 2184 0400A0E3 		mov	r0, #4
 3846 2188 90131FE5 		ldr	r1, .L272+64
 3847 218c 14309DE5 		ldr	r3, [sp, #20]
 3848 2190 FEFFFFEB 		bl	CyU3PDebugPrint
 3849              	.LVL333:
1385:../uvc.c      **** 									Data0 = 4; //set to default.
 3850              		.loc 1 1385 0
 3851 2194 0460A0E3 		mov	r6, #4
 3852 2198 C1FEFFEA 		b	.L236
 3853              	.LVL334:
 3854              	.L210:
1121:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 3855              		.loc 1 1121 0
 3856 219c 0A20A0E1 		mov	r2, sl
 3857 21a0 0730A0E1 		mov	r3, r7
 3858 21a4 80C0A0E3 		mov	ip, #128
 3859 21a8 00E0A0E3 		mov	lr, #0
 3860 21ac 1B10A0E3 		mov	r1, #27
 3861 21b0 BC031FE5 		ldr	r0, .L272+60
 3862 21b4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3863 21b8 FEFFFFEB 		bl	cmdSet
 3864              	.LVL335:
1123:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 3865              		.loc 1 1123 0
 3866 21bc 14C09DE5 		ldr	ip, [sp, #20]
 3867 21c0 0730A0E1 		mov	r3, r7
 3868 21c4 1B10A0E3 		mov	r1, #27
 3869 21c8 0170A0E3 		mov	r7, #1
 3870              	.LVL336:
 3871 21cc 0820A0E1 		mov	r2, r8
 3872 21d0 DC031FE5 		ldr	r0, .L272+60
 3873 21d4 00C08DE5 		str	ip, [sp, #0]
 3874 21d8 04708DE5 		str	r7, [sp, #4]
 3875 21dc FEFFFFEB 		bl	cmdSet
 3876              	.LVL337:
 3877 21e0 AAFDFFEA 		b	.L209
 3878              	.LVL338:
 3879              	.L259:
 3880 21e4 E4031FE5 		ldr	r0, .L272+72
 3881 21e8 66FCFFEA 		b	.L160
 3882              	.LVL339:
 3883              	.L269:
1096:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3884              		.loc 1 1096 0
 3885 21ec 18C09DE5 		ldr	ip, [sp, #24]
 3886 21f0 0730A0E1 		mov	r3, r7
 3887 21f4 1910A0E3 		mov	r1, #25
 3888 21f8 0070A0E3 		mov	r7, #0
 3889              	.LVL340:
 3890 21fc 0920A0E1 		mov	r2, r9
 3891 2200 0C041FE5 		ldr	r0, .L272+60
 3892 2204 00C08DE5 		str	ip, [sp, #0]
 3893 2208 04708DE5 		str	r7, [sp, #4]
 3894 220c FEFFFFEB 		bl	cmdSet
 3895              	.LVL341:
 3896 2210 6BFEFFEA 		b	.L208
 3897              	.LVL342:
 3898              	.L271:
 812:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 3899              		.loc 1 812 0
 3900 2214 0430A0E1 		mov	r3, r4
 3901 2218 0400A0E3 		mov	r0, #4
 3902 221c 24141FE5 		ldr	r1, .L272+64
 3903 2220 FEFFFFEB 		bl	CyU3PDebugPrint
 3904              	.LVL343:
 814:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3905              		.loc 1 814 0
 3906 2224 28241FE5 		ldr	r2, .L272+68
 3907 2228 0030A0E3 		mov	r3, #0
 813:../uvc.c      **** 							sendData = 0; //set back to default
 3908              		.loc 1 813 0
 3909 222c 0340A0E1 		mov	r4, r3
 814:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 3910              		.loc 1 814 0
 3911 2230 2D34C2E5 		strb	r3, [r2, #1069]
 3912 2234 52FFFFEA 		b	.L163
 3913              	.LVL344:
 3914              	.L241:
 734:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 3915              		.loc 1 734 0
 3916 2238 0030A0E3 		mov	r3, #0
 3917 223c 35FDFFEA 		b	.L253
 3918              	.LVL345:
 3919              	.L239:
 3920 2240 40041FE5 		ldr	r0, .L272+72
 3921 2244 0030A0E3 		mov	r3, #0
 3922 2248 47FCFFEA 		b	.L252
 3923              		.cfi_endproc
 3924              	.LFE3:
 3926              		.align	2
 3927              		.global	CTControlHandle
 3929              	CTControlHandle:
 3930              	.LFB4:
1455:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3931              		.loc 1 1455 0
 3932              		.cfi_startproc
 3933              		@ args = 0, pretend = 0, frame = 64
 3934              		@ frame_needed = 0, uses_anonymous_args = 0
 3935              	.LVL346:
 3936 224c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3937              	.LCFI18:
 3938              		.cfi_def_cfa_offset 36
1474:../uvc.c      ****     reqData = bRequest;
 3939              		.loc 1 1474 0
 3940 2250 64A99FE5 		ldr	sl, .L359
 3941              		.cfi_offset 14, -4
 3942              		.cfi_offset 11, -8
 3943              		.cfi_offset 10, -12
 3944              		.cfi_offset 9, -16
 3945              		.cfi_offset 8, -20
 3946              		.cfi_offset 7, -24
 3947              		.cfi_offset 6, -28
 3948              		.cfi_offset 5, -32
 3949              		.cfi_offset 4, -36
1466:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3950              		.loc 1 1466 0
 3951 2254 64899FE5 		ldr	r8, .L359+4
1474:../uvc.c      ****     reqData = bRequest;
 3952              		.loc 1 1474 0
 3953 2258 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1466:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3954              		.loc 1 1466 0
 3955 225c 8090A0E1 		mov	r9, r0, asl #1
 3956 2260 002089E0 		add	r2, r9, r0
 3957 2264 822188E0 		add	r2, r8, r2, asl #3
1476:../uvc.c      ****     switch (bRequest)
 3958              		.loc 1 1476 0
 3959 2268 830055E3 		cmp	r5, #131
1455:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3960              		.loc 1 1455 0
 3961 226c 5CD04DE2 		sub	sp, sp, #92
 3962              	.LCFI19:
 3963              		.cfi_def_cfa_offset 128
1455:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3964              		.loc 1 1455 0
 3965 2270 0060A0E1 		mov	r6, r0
1466:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3966              		.loc 1 1466 0
 3967 2274 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 3968              	.LVL347:
1467:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3969              		.loc 1 1467 0
 3970 2278 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 3971              	.LVL348:
1469:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3972              		.loc 1 1469 0
 3973 227c 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 3974              	.LVL349:
1476:../uvc.c      ****     switch (bRequest)
 3975              		.loc 1 1476 0
 3976 2280 7600000A 		beq	.L279
 3977 2284 2100009A 		bls	.L354
 3978 2288 850055E3 		cmp	r5, #133
 3979 228c 5900000A 		beq	.L281
 3980 2290 4E00003A 		bcc	.L280
 3981 2294 860055E3 		cmp	r5, #134
 3982 2298 8000000A 		beq	.L282
 3983 229c 870055E3 		cmp	r5, #135
 3984 22a0 7600000A 		beq	.L355
 3985              	.L275:
1683:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3986              		.loc 1 1683 0
 3987 22a4 0000A0E3 		mov	r0, #0
 3988              	.LVL350:
 3989 22a8 0110A0E3 		mov	r1, #1
 3990 22ac 0020A0E1 		mov	r2, r0
 3991 22b0 FEFFFFEB 		bl	CyU3PUsbStall
 3992              	.LVL351:
 3993 22b4 08499FE5 		ldr	r4, .L359+8
1684:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3994              		.loc 1 1684 0
 3995 22b8 0620A0E1 		mov	r2, r6
 3996 22bc 0400A0E3 		mov	r0, #4
 3997 22c0 00199FE5 		ldr	r1, .L359+12
 3998 22c4 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3999 22c8 FEFFFFEB 		bl	CyU3PDebugPrint
1685:../uvc.c      **** 			  break;
 4000              		.loc 1 1685 0
 4001 22cc FFC0A0E3 		mov	ip, #255
 4002 22d0 0C60A0E1 		mov	r6, ip
 4003 22d4 0C80A0E1 		mov	r8, ip
 4004              	.LVL352:
 4005              	.L285:
1689:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4006              		.loc 1 1689 0
 4007 22d8 5EE0D4E5 		ldrb	lr, [r4, #94]	@ zero_extendqisi2
 4008 22dc 08C08DE5 		str	ip, [sp, #8]
 4009 22e0 E4189FE5 		ldr	r1, .L359+16
 4010 22e4 FFC0A0E3 		mov	ip, #255
 4011 22e8 0520A0E1 		mov	r2, r5
 4012 22ec 0830A0E1 		mov	r3, r8
 4013 22f0 0400A0E3 		mov	r0, #4
 4014 22f4 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4015 22f8 0CC08DE5 		str	ip, [sp, #12]
 4016 22fc 10E08DE5 		str	lr, [sp, #16]
 4017 2300 14708DE5 		str	r7, [sp, #20]
 4018 2304 FEFFFFEB 		bl	CyU3PDebugPrint
1690:../uvc.c      **** }
 4019              		.loc 1 1690 0
 4020 2308 5CD08DE2 		add	sp, sp, #92
 4021 230c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4022              	.LVL353:
 4023              	.L354:
1476:../uvc.c      ****     switch (bRequest)
 4024              		.loc 1 1476 0
 4025 2310 810055E3 		cmp	r5, #129
 4026 2314 4200000A 		beq	.L277
 4027 2318 1100009A 		bls	.L356
1505:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4028              		.loc 1 1505 0
 4029 231c A0489FE5 		ldr	r4, .L359+8
 4030 2320 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1506:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4031              		.loc 1 1506 0
 4032 2324 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1507:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4033              		.loc 1 1507 0
 4034 2328 0A0050E3 		cmp	r0, #10
1505:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4035              		.loc 1 1505 0
 4036 232c 5C10C4E5 		strb	r1, [r4, #92]
1506:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4037              		.loc 1 1506 0
 4038 2330 5D60C4E5 		strb	r6, [r4, #93]
1507:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4039              		.loc 1 1507 0
 4040 2334 2C00000A 		beq	.L353
 4041              	.LVL354:
 4042              	.L292:
1541:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4043              		.loc 1 1541 0
 4044 2338 00E0A0E3 		mov	lr, #0
 4045 233c 5EE0C4E5 		strb	lr, [r4, #94]
 4046              	.L293:
1542:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4047              		.loc 1 1542 0
 4048 2340 0030A0E3 		mov	r3, #0
1543:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4049              		.loc 1 1543 0
 4050 2344 0700A0E1 		mov	r0, r7
 4051              	.LVL355:
 4052 2348 80189FE5 		ldr	r1, .L359+20
1545:../uvc.c      **** 			  break;
 4053              		.loc 1 1545 0
 4054 234c FF60A0E3 		mov	r6, #255
1542:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4055              		.loc 1 1542 0
 4056 2350 5F30C4E5 		strb	r3, [r4, #95]
1545:../uvc.c      **** 			  break;
 4057              		.loc 1 1545 0
 4058 2354 0680A0E1 		mov	r8, r6
1543:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4059              		.loc 1 1543 0
 4060 2358 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4061              	.LVL356:
 4062 235c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1545:../uvc.c      **** 			  break;
 4063              		.loc 1 1545 0
 4064 2360 DCFFFFEA 		b	.L285
 4065              	.LVL357:
 4066              	.L356:
1476:../uvc.c      ****     switch (bRequest)
 4067              		.loc 1 1476 0
 4068 2364 010055E3 		cmp	r5, #1
 4069 2368 CDFFFF1A 		bne	.L275
1547:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4070              		.loc 1 1547 0
 4071 236c 50489FE5 		ldr	r4, .L359+8
 4072 2370 56208DE2 		add	r2, sp, #86
 4073 2374 2000A0E3 		mov	r0, #32
 4074              	.LVL358:
 4075 2378 5C1084E2 		add	r1, r4, #92
 4076 237c 2C308DE5 		str	r3, [sp, #44]
 4077 2380 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4078              	.LVL359:
1549:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4079              		.loc 1 1549 0
 4080 2384 5C00D4E5 		ldrb	r0, [r4, #92]	@ zero_extendqisi2
1550:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4081              		.loc 1 1550 0
 4082 2388 5DC0D4E5 		ldrb	ip, [r4, #93]	@ zero_extendqisi2
1553:../uvc.c      **** 			  switch(CtrlID)
 4083              		.loc 1 1553 0
 4084 238c 012046E2 		sub	r2, r6, #1
1549:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4085              		.loc 1 1549 0
 4086 2390 30008DE5 		str	r0, [sp, #48]
 4087              	.LVL360:
1550:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4088              		.loc 1 1550 0
 4089 2394 34C08DE5 		str	ip, [sp, #52]
 4090              	.LVL361:
1553:../uvc.c      **** 			  switch(CtrlID)
 4091              		.loc 1 1553 0
 4092 2398 2C309DE5 		ldr	r3, [sp, #44]
 4093 239c 090052E3 		cmp	r2, #9
 4094 23a0 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4095 23a4 550100EA 		b	.L294
 4096              	.L299:
 4097 23a8 BC280000 		.word	.L295
 4098 23ac 00290000 		.word	.L294
 4099 23b0 CC250000 		.word	.L296
 4100 23b4 00290000 		.word	.L294
 4101 23b8 00290000 		.word	.L294
 4102 23bc 00290000 		.word	.L294
 4103 23c0 48250000 		.word	.L297
 4104 23c4 00290000 		.word	.L294
 4105 23c8 00290000 		.word	.L294
 4106 23cc CC240000 		.word	.L298
 4107              	.LVL362:
 4108              	.L280:
1523:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4109              		.loc 1 1523 0
 4110 23d0 EC479FE5 		ldr	r4, .L359+8
 4111 23d4 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1524:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4112              		.loc 1 1524 0
 4113 23d8 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1525:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4114              		.loc 1 1525 0
 4115 23dc 0A0050E3 		cmp	r0, #10
1523:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4116              		.loc 1 1523 0
 4117 23e0 5C80C4E5 		strb	r8, [r4, #92]
1524:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4118              		.loc 1 1524 0
 4119 23e4 5D20C4E5 		strb	r2, [r4, #93]
1525:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4120              		.loc 1 1525 0
 4121 23e8 D2FFFF1A 		bne	.L292
 4122              	.LVL363:
 4123              	.L353:
1540:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4124              		.loc 1 1540 0 discriminator 1
 4125 23ec 0110A0E3 		mov	r1, #1
 4126 23f0 5E10C4E5 		strb	r1, [r4, #94]
 4127 23f4 D1FFFFEA 		b	.L293
 4128              	.LVL364:
 4129              	.L281:
1480:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4130              		.loc 1 1480 0
 4131 23f8 C4479FE5 		ldr	r4, .L359+8
1481:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4132              		.loc 1 1481 0
 4133 23fc 0030A0E3 		mov	r3, #0
 4134              	.LVL365:
1482:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4135              		.loc 1 1482 0
 4136 2400 0200A0E3 		mov	r0, #2
 4137              	.LVL366:
 4138 2404 5C1084E2 		add	r1, r4, #92
1484:../uvc.c      **** 			  break;
 4139              		.loc 1 1484 0
 4140 2408 FF60A0E3 		mov	r6, #255
1480:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4141              		.loc 1 1480 0
 4142 240c 5C70C4E5 		strb	r7, [r4, #92]
1481:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4143              		.loc 1 1481 0
 4144 2410 5D30C4E5 		strb	r3, [r4, #93]
1484:../uvc.c      **** 			  break;
 4145              		.loc 1 1484 0
 4146 2414 0680A0E1 		mov	r8, r6
1482:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4147              		.loc 1 1482 0
 4148 2418 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4149              	.LVL367:
 4150 241c 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1484:../uvc.c      **** 			  break;
 4151              		.loc 1 1484 0
 4152 2420 ACFFFFEA 		b	.L285
 4153              	.LVL368:
 4154              	.L277:
1490:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4155              		.loc 1 1490 0
 4156 2424 98479FE5 		ldr	r4, .L359+8
 4157 2428 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1491:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4158              		.loc 1 1491 0
 4159 242c 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1492:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4160              		.loc 1 1492 0
 4161 2430 0080A0E3 		mov	r8, #0
1498:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4162              		.loc 1 1498 0
 4163 2434 0700A0E1 		mov	r0, r7
 4164              	.LVL369:
 4165 2438 5C1084E2 		add	r1, r4, #92
1503:../uvc.c      **** 			  break;
 4166              		.loc 1 1503 0
 4167 243c FF60A0E3 		mov	r6, #255
1491:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4168              		.loc 1 1491 0
 4169 2440 5DC0C4E5 		strb	ip, [r4, #93]
1492:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4170              		.loc 1 1492 0
 4171 2444 5E80C4E5 		strb	r8, [r4, #94]
1493:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4172              		.loc 1 1493 0
 4173 2448 5F80C4E5 		strb	r8, [r4, #95]
 4174              	.LVL370:
1490:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4175              		.loc 1 1490 0
 4176 244c 5CA0C4E5 		strb	sl, [r4, #92]
1503:../uvc.c      **** 			  break;
 4177              		.loc 1 1503 0
 4178 2450 0680A0E1 		mov	r8, r6
1498:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4179              		.loc 1 1498 0
 4180 2454 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4181              	.LVL371:
 4182 2458 0AC0A0E1 		mov	ip, sl
1503:../uvc.c      **** 			  break;
 4183              		.loc 1 1503 0
 4184 245c 9DFFFFEA 		b	.L285
 4185              	.LVL372:
 4186              	.L279:
1514:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4187              		.loc 1 1514 0
 4188 2460 5C479FE5 		ldr	r4, .L359+8
 4189 2464 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4190              	.LVL373:
1515:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4191              		.loc 1 1515 0
 4192 2468 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1516:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4193              		.loc 1 1516 0
 4194 246c 0A0050E3 		cmp	r0, #10
1514:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4195              		.loc 1 1514 0
 4196 2470 5C30C4E5 		strb	r3, [r4, #92]
1515:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4197              		.loc 1 1515 0
 4198 2474 5DE0C4E5 		strb	lr, [r4, #93]
1516:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4199              		.loc 1 1516 0
 4200 2478 AEFFFF1A 		bne	.L292
 4201 247c DAFFFFEA 		b	.L353
 4202              	.LVL374:
 4203              	.L355:
1538:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4204              		.loc 1 1538 0
 4205 2480 3C479FE5 		ldr	r4, .L359+8
 4206 2484 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1539:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4207              		.loc 1 1539 0
 4208 2488 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1540:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4209              		.loc 1 1540 0
 4210 248c 0A0050E3 		cmp	r0, #10
1538:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4211              		.loc 1 1538 0
 4212 2490 5C60C4E5 		strb	r6, [r4, #92]
1539:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4213              		.loc 1 1539 0
 4214 2494 5DC0C4E5 		strb	ip, [r4, #93]
1540:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4215              		.loc 1 1540 0
 4216 2498 A6FFFF1A 		bne	.L292
 4217 249c D2FFFFEA 		b	.L353
 4218              	.L282:
1532:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 4219              		.loc 1 1532 0
 4220 24a0 1C479FE5 		ldr	r4, .L359+8
 4221 24a4 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 4222              	.LVL375:
 4223 24a8 0410A0E1 		mov	r1, r4
 4224 24ac 5C00E1E5 		strb	r0, [r1, #92]!
1536:../uvc.c      **** 			  break;
 4225              		.loc 1 1536 0
 4226 24b0 FF60A0E3 		mov	r6, #255
1533:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4227              		.loc 1 1533 0
 4228 24b4 0100A0E3 		mov	r0, #1
 4229 24b8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4230              	.LVL376:
1536:../uvc.c      **** 			  break;
 4231              		.loc 1 1536 0
 4232 24bc 0680A0E1 		mov	r8, r6
1533:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4233              		.loc 1 1533 0
 4234 24c0 5CC0D4E5 		ldrb	ip, [r4, #92]	@ zero_extendqisi2
1536:../uvc.c      **** 			  break;
 4235              		.loc 1 1536 0
 4236 24c4 0170A0E3 		mov	r7, #1
 4237 24c8 82FFFFEA 		b	.L285
 4238              	.LVL377:
 4239              	.L298:
1662:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4240              		.loc 1 1662 0
 4241 24cc 00679FE5 		ldr	r6, .L359+24
 4242 24d0 0010E0E3 		mvn	r1, #0
 4243 24d4 1C0096E5 		ldr	r0, [r6, #28]
 4244 24d8 2C308DE5 		str	r3, [sp, #44]
 4245 24dc FEFFFFEB 		bl	_txe_mutex_get
1663:../uvc.c      **** 					  if(getData == 1)
 4246              		.loc 1 1663 0
 4247 24e0 30E09DE5 		ldr	lr, [sp, #48]
 4248 24e4 2C309DE5 		ldr	r3, [sp, #44]
 4249 24e8 01005EE3 		cmp	lr, #1
 4250 24ec AA01000A 		beq	.L357
1665:../uvc.c      **** 					  else if(getData == 0xff)
 4251              		.loc 1 1665 0
 4252 24f0 FF005EE3 		cmp	lr, #255
 4253 24f4 9F01000A 		beq	.L358
1668:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 4254              		.loc 1 1668 0
 4255 24f8 0080A0E3 		mov	r8, #0
 4256 24fc 0600A0E1 		mov	r0, r6
 4257 2500 2310A0E3 		mov	r1, #35
 4258 2504 0B20A0E1 		mov	r2, fp
 4259 2508 00808DE5 		str	r8, [sp, #0]
 4260 250c 04808DE5 		str	r8, [sp, #4]
 4261 2510 FEFFFFEB 		bl	cmdSet
 4262              	.L351:
1671:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4263              		.loc 1 1671 0
 4264 2514 1C0096E5 		ldr	r0, [r6, #28]
 4265 2518 FEFFFFEB 		bl	_txe_mutex_put
1673:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 4266              		.loc 1 1673 0
 4267 251c 30809DE5 		ldr	r8, [sp, #48]
 4268 2520 34609DE5 		ldr	r6, [sp, #52]
 4269 2524 5EC0D4E5 		ldrb	ip, [r4, #94]	@ zero_extendqisi2
 4270 2528 0400A0E3 		mov	r0, #4
 4271 252c A4169FE5 		ldr	r1, .L359+28
 4272 2530 0820A0E1 		mov	r2, r8
 4273 2534 0630A0E1 		mov	r3, r6
 4274 2538 00C08DE5 		str	ip, [sp, #0]
 4275 253c FEFFFFEB 		bl	CyU3PDebugPrint
1674:../uvc.c      **** 					  break;
 4276              		.loc 1 1674 0
 4277 2540 FFC0A0E3 		mov	ip, #255
 4278 2544 63FFFFEA 		b	.L285
 4279              	.LVL378:
 4280              	.L297:
1639:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 4281              		.loc 1 1639 0
 4282 2548 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 4283 254c 010058E3 		cmp	r8, #1
 4284 2550 08005813 		cmpne	r8, #8
 4285 2554 0000A013 		movne	r0, #0
 4286 2558 0100A003 		moveq	r0, #1
 4287 255c 8101001A 		bne	.L348
 4288              	.LVL379:
1642:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4289              		.loc 1 1642 0
 4290 2560 6C869FE5 		ldr	r8, .L359+24
 4291 2564 0010E0E3 		mvn	r1, #0
 4292 2568 1C0098E5 		ldr	r0, [r8, #28]
 4293 256c 2C308DE5 		str	r3, [sp, #44]
 4294 2570 FEFFFFEB 		bl	_txe_mutex_get
1643:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 4295              		.loc 1 1643 0
 4296 2574 30A09DE5 		ldr	sl, [sp, #48]
 4297 2578 2210A0E3 		mov	r1, #34
 4298 257c 0B20A0E1 		mov	r2, fp
 4299 2580 2C309DE5 		ldr	r3, [sp, #44]
 4300 2584 00C0A0E3 		mov	ip, #0
 4301 2588 0800A0E1 		mov	r0, r8
 4302 258c 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 4303 2590 FEFFFFEB 		bl	cmdSet
1644:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4304              		.loc 1 1644 0
 4305 2594 1C0098E5 		ldr	r0, [r8, #28]
 4306 2598 FEFFFFEB 		bl	_txe_mutex_put
1647:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4307              		.loc 1 1647 0
 4308 259c 1C069FE5 		ldr	r0, .L359+4
1648:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4309              		.loc 1 1648 0
 4310 25a0 34209DE5 		ldr	r2, [sp, #52]
1647:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4311              		.loc 1 1647 0
 4312 25a4 061089E0 		add	r1, r9, r6
 4313 25a8 813180E0 		add	r3, r0, r1, asl #3
1649:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4314              		.loc 1 1649 0
 4315 25ac 0160A0E3 		mov	r6, #1
1647:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 4316              		.loc 1 1647 0
 4317 25b0 2DA5C3E5 		strb	sl, [r3, #1325]
1648:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 4318              		.loc 1 1648 0
 4319 25b4 2E25C3E5 		strb	r2, [r3, #1326]
1649:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 4320              		.loc 1 1649 0
 4321 25b8 3065C3E5 		strb	r6, [r3, #1328]
 4322              	.LVL380:
 4323              	.L349:
1651:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4324              		.loc 1 1651 0
 4325 25bc 5C80D4E5 		ldrb	r8, [r4, #92]	@ zero_extendqisi2
 4326 25c0 5D60D4E5 		ldrb	r6, [r4, #93]	@ zero_extendqisi2
1656:../uvc.c      **** 					  break;
 4327              		.loc 1 1656 0
 4328 25c4 FFC0A0E3 		mov	ip, #255
 4329 25c8 42FFFFEA 		b	.L285
 4330              	.LVL381:
 4331              	.L296:
1605:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 4332              		.loc 1 1605 0
 4333 25cc 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 4334 25d0 010050E3 		cmp	r0, #1
 4335 25d4 04005013 		cmpne	r0, #4
 4336 25d8 5D01001A 		bne	.L306
1604:../uvc.c      **** 					  value = (value << 8)|Data0;
 4337              		.loc 1 1604 0
 4338 25dc 30109DE5 		ldr	r1, [sp, #48]
 4339 25e0 34E09DE5 		ldr	lr, [sp, #52]
 4340 25e4 0E2481E1 		orr	r2, r1, lr, asl #8
1606:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 4341              		.loc 1 1606 0
 4342 25e8 F90052E3 		cmp	r2, #249
 4343 25ec 5801008A 		bhi	.L306
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4344              		.loc 1 1611 0
 4345 25f0 C8A042E2 		sub	sl, r2, #200
 4346 25f4 0AC8A0E1 		mov	ip, sl, asl #16
 4347 25f8 3CC08DE5 		str	ip, [sp, #60]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4348              		.loc 1 1613 0
 4349 25fc 27A062E2 		rsb	sl, r2, #39
 4350 2600 38A08DE5 		str	sl, [sp, #56]
 4351 2604 3CA09DE5 		ldr	sl, [sp, #60]
 4352 2608 C81062E2 		rsb	r1, r2, #200
 4353 260c C80052E3 		cmp	r2, #200
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4354              		.loc 1 1611 0
 4355 2610 640042E2 		sub	r0, r2, #100
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4356              		.loc 1 1613 0
 4357 2614 0118A0E1 		mov	r1, r1, asl #16
 4358 2618 64E062E2 		rsb	lr, r2, #100
 4359 261c 2A18A081 		movhi	r1, sl, lsr #16
 4360 2620 2118A091 		movls	r1, r1, lsr #16
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4361              		.loc 1 1611 0
 4362 2624 00C8A0E1 		mov	ip, r0, asl #16
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4363              		.loc 1 1613 0
 4364 2628 640052E3 		cmp	r2, #100
 4365 262c 0E08A0E1 		mov	r0, lr, asl #16
 4366 2630 2C08A081 		movhi	r0, ip, lsr #16
 4367 2634 38C09DE5 		ldr	ip, [sp, #56]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4368              		.loc 1 1611 0
 4369 2638 14A042E2 		sub	sl, r2, #20
 4370 263c 38A08DE5 		str	sl, [sp, #56]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4371              		.loc 1 1613 0
 4372 2640 2008A091 		movls	r0, r0, lsr #16
 4373 2644 14A062E2 		rsb	sl, r2, #20
 4374 2648 3CA08DE5 		str	sl, [sp, #60]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4375              		.loc 1 1611 0
 4376 264c 27E042E2 		sub	lr, r2, #39
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4377              		.loc 1 1613 0
 4378 2650 000051E1 		cmp	r1, r0
 4379 2654 01A0A031 		movcc	sl, r1
 4380 2658 00A0A021 		movcs	sl, r0
 4381 265c 0CC8A0E1 		mov	ip, ip, asl #16
 4382 2660 270052E3 		cmp	r2, #39
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4383              		.loc 1 1611 0
 4384 2664 0EE8A0E1 		mov	lr, lr, asl #16
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4385              		.loc 1 1613 0
 4386 2668 2CE8A091 		movls	lr, ip, lsr #16
 4387 266c 68C59FE5 		ldr	ip, .L359+32
 4388 2670 20A08DE5 		str	sl, [sp, #32]
 4389 2674 01A06CE0 		rsb	sl, ip, r1
 4390 2678 2EE8A081 		movhi	lr, lr, lsr #16
 4391 267c 00C07AE2 		rsbs	ip, sl, #0
 4392 2680 0AC0ACE0 		adc	ip, ip, sl
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4393              		.loc 1 1611 0
 4394 2684 38A09DE5 		ldr	sl, [sp, #56]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4395              		.loc 1 1613 0
 4396 2688 44C08DE5 		str	ip, [sp, #68]
 4397              	.LVL382:
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4398              		.loc 1 1611 0
 4399 268c 0AC8A0E1 		mov	ip, sl, asl #16
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4400              		.loc 1 1613 0
 4401 2690 3CA09DE5 		ldr	sl, [sp, #60]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4402              		.loc 1 1611 0
 4403 2694 4CC08DE5 		str	ip, [sp, #76]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4404              		.loc 1 1613 0
 4405 2698 0AC8A0E1 		mov	ip, sl, asl #16
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4406              		.loc 1 1611 0
 4407 269c 0AA042E2 		sub	sl, r2, #10
 4408 26a0 48A08DE5 		str	sl, [sp, #72]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4409              		.loc 1 1613 0
 4410 26a4 20A09DE5 		ldr	sl, [sp, #32]
 4411 26a8 3CC08DE5 		str	ip, [sp, #60]
 4412 26ac 0A005EE1 		cmp	lr, sl
 4413 26b0 0EA0A031 		movcc	sl, lr
 4414 26b4 0AC062E2 		rsb	ip, r2, #10
 4415 26b8 40C08DE5 		str	ip, [sp, #64]
 4416 26bc 38A08DE5 		str	sl, [sp, #56]
 4417 26c0 3CC09DE5 		ldr	ip, [sp, #60]
 4418 26c4 4CA09DE5 		ldr	sl, [sp, #76]
 4419 26c8 140052E3 		cmp	r2, #20
 4420 26cc 2CA8A091 		movls	sl, ip, lsr #16
 4421 26d0 2AA8A081 		movhi	sl, sl, lsr #16
 4422 26d4 44C09DE5 		ldr	ip, [sp, #68]
 4423 26d8 010050E1 		cmp	r0, r1
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4424              		.loc 1 1611 0
 4425 26dc 48109DE5 		ldr	r1, [sp, #72]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4426              		.loc 1 1613 0
 4427 26e0 01C0A033 		movcc	ip, #1
 4428 26e4 3CA08DE5 		str	sl, [sp, #60]
 4429 26e8 24C08DE5 		str	ip, [sp, #36]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4430              		.loc 1 1611 0
 4431 26ec 01A8A0E1 		mov	sl, r1, asl #16
 4432 26f0 05C042E2 		sub	ip, r2, #5
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4433              		.loc 1 1613 0
 4434 26f4 051062E2 		rsb	r1, r2, #5
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4435              		.loc 1 1611 0
 4436 26f8 48A08DE5 		str	sl, [sp, #72]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4437              		.loc 1 1613 0
 4438 26fc 40009DE5 		ldr	r0, [sp, #64]
 4439 2700 38A09DE5 		ldr	sl, [sp, #56]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4440              		.loc 1 1611 0
 4441 2704 40C08DE5 		str	ip, [sp, #64]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4442              		.loc 1 1613 0
 4443 2708 3CC09DE5 		ldr	ip, [sp, #60]
 4444 270c 4C108DE5 		str	r1, [sp, #76]
 4445 2710 48109DE5 		ldr	r1, [sp, #72]
 4446 2714 0008A0E1 		mov	r0, r0, asl #16
 4447 2718 0A005CE1 		cmp	ip, sl
 4448 271c 0AC0A021 		movcs	ip, sl
 4449 2720 0A0052E3 		cmp	r2, #10
 4450 2724 20A09DE5 		ldr	sl, [sp, #32]
 4451 2728 2108A081 		movhi	r0, r1, lsr #16
 4452 272c 2008A091 		movls	r0, r0, lsr #16
 4453 2730 48008DE5 		str	r0, [sp, #72]
 4454 2734 24009DE5 		ldr	r0, [sp, #36]
 4455 2738 0A005EE1 		cmp	lr, sl
 4456 273c 0200A033 		movcc	r0, #2
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4457              		.loc 1 1611 0
 4458 2740 02E042E2 		sub	lr, r2, #2
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4459              		.loc 1 1613 0
 4460 2744 44C08DE5 		str	ip, [sp, #68]
 4461 2748 24008DE5 		str	r0, [sp, #36]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4462              		.loc 1 1611 0
 4463 274c 40C09DE5 		ldr	ip, [sp, #64]
 4464 2750 1CE08DE5 		str	lr, [sp, #28]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4465              		.loc 1 1613 0
 4466 2754 44009DE5 		ldr	r0, [sp, #68]
 4467 2758 48E09DE5 		ldr	lr, [sp, #72]
 4468 275c 4C109DE5 		ldr	r1, [sp, #76]
 4469 2760 02A062E2 		rsb	sl, r2, #2
 4470 2764 00005EE1 		cmp	lr, r0
 4471 2768 00E0A021 		movcs	lr, r0
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4472              		.loc 1 1611 0
 4473 276c 0CC8A0E1 		mov	ip, ip, asl #16
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4474              		.loc 1 1613 0
 4475 2770 050052E3 		cmp	r2, #5
 4476 2774 40A08DE5 		str	sl, [sp, #64]
 4477 2778 0118A0E1 		mov	r1, r1, asl #16
 4478 277c 3CA09DE5 		ldr	sl, [sp, #60]
 4479 2780 2C18A081 		movhi	r1, ip, lsr #16
 4480 2784 38C09DE5 		ldr	ip, [sp, #56]
 4481 2788 4CE08DE5 		str	lr, [sp, #76]
 4482 278c 24009DE5 		ldr	r0, [sp, #36]
 4483 2790 40E09DE5 		ldr	lr, [sp, #64]
 4484 2794 2118A091 		movls	r1, r1, lsr #16
 4485 2798 0C005AE1 		cmp	sl, ip
 4486 279c 20108DE5 		str	r1, [sp, #32]
 4487 27a0 0300A033 		movcc	r0, #3
 4488 27a4 38008DE5 		str	r0, [sp, #56]
 4489 27a8 4CA09DE5 		ldr	sl, [sp, #76]
 4490 27ac 0E08A0E1 		mov	r0, lr, asl #16
 4491 27b0 20E09DE5 		ldr	lr, [sp, #32]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4492              		.loc 1 1611 0
 4493 27b4 1C109DE5 		ldr	r1, [sp, #28]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4494              		.loc 1 1613 0
 4495 27b8 0A005EE1 		cmp	lr, sl
 4496 27bc 0AE0A021 		movcs	lr, sl
 4497 27c0 44C09DE5 		ldr	ip, [sp, #68]
 4498 27c4 48A09DE5 		ldr	sl, [sp, #72]
 4499 27c8 020052E3 		cmp	r2, #2
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4500              		.loc 1 1611 0
 4501 27cc 0118A0E1 		mov	r1, r1, asl #16
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4502              		.loc 1 1613 0
 4503 27d0 2018A091 		movls	r1, r0, lsr #16
 4504 27d4 38009DE5 		ldr	r0, [sp, #56]
 4505 27d8 2118A081 		movhi	r1, r1, lsr #16
 4506 27dc 0C005AE1 		cmp	sl, ip
 4507 27e0 0400A033 		movcc	r0, #4
 4508 27e4 40008DE5 		str	r0, [sp, #64]
1611:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 4509              		.loc 1 1611 0
 4510 27e8 010042E2 		sub	r0, r2, #1
 4511 27ec 38008DE5 		str	r0, [sp, #56]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4512              		.loc 1 1613 0
 4513 27f0 4CA09DE5 		ldr	sl, [sp, #76]
 4514 27f4 20009DE5 		ldr	r0, [sp, #32]
 4515 27f8 01C062E2 		rsb	ip, r2, #1
 4516 27fc 3CC08DE5 		str	ip, [sp, #60]
 4517 2800 0A0050E1 		cmp	r0, sl
1620:../uvc.c      **** 						  shutter = shutter+index;
 4518              		.loc 1 1620 0
 4519 2804 38A09DE5 		ldr	sl, [sp, #56]
 4520 2808 3C009DE5 		ldr	r0, [sp, #60]
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4521              		.loc 1 1613 0
 4522 280c 40C09DE5 		ldr	ip, [sp, #64]
 4523 2810 05C0A033 		movcc	ip, #5
1620:../uvc.c      **** 						  shutter = shutter+index;
 4524              		.loc 1 1620 0
 4525 2814 010052E3 		cmp	r2, #1
 4526 2818 0028A091 		movls	r2, r0, asl #16
 4527 281c 0A28A081 		movhi	r2, sl, asl #16
 4528 2820 0E0051E1 		cmp	r1, lr
 4529 2824 01A0A031 		movcc	sl, r1
 4530 2828 0EA0A021 		movcs	sl, lr
1613:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 4531              		.loc 1 1613 0
 4532 282c 0E0051E1 		cmp	r1, lr
 4533 2830 0C10A021 		movcs	r1, ip
 4534 2834 0610A033 		movcc	r1, #6
1620:../uvc.c      **** 						  shutter = shutter+index;
 4535              		.loc 1 1620 0
 4536 2838 22085AE1 		cmp	sl, r2, lsr #16
1623:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4537              		.loc 1 1623 0
 4538 283c 90A39FE5 		ldr	sl, .L359+24
1620:../uvc.c      **** 						  shutter = shutter+index;
 4539              		.loc 1 1620 0
 4540 2840 0120A091 		movls	r2, r1
 4541 2844 0720A083 		movhi	r2, #7
 4542 2848 012082E2 		add	r2, r2, #1
 4543 284c FFE002E2 		and	lr, r2, #255
1623:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4544              		.loc 1 1623 0
 4545 2850 0010E0E3 		mvn	r1, #0
 4546 2854 1C009AE5 		ldr	r0, [sl, #28]
1620:../uvc.c      **** 						  shutter = shutter+index;
 4547              		.loc 1 1620 0
 4548 2858 38E08DE5 		str	lr, [sp, #56]
 4549              	.LVL383:
1623:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4550              		.loc 1 1623 0
 4551 285c 2C308DE5 		str	r3, [sp, #44]
 4552 2860 FEFFFFEB 		bl	_txe_mutex_get
1624:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 4553              		.loc 1 1624 0
 4554 2864 38C09DE5 		ldr	ip, [sp, #56]
 4555 2868 0310A0E3 		mov	r1, #3
 4556 286c 0B20A0E1 		mov	r2, fp
 4557 2870 2C309DE5 		ldr	r3, [sp, #44]
 4558 2874 00C08DE5 		str	ip, [sp, #0]
 4559 2878 0A00A0E1 		mov	r0, sl
 4560 287c 00C0A0E3 		mov	ip, #0
 4561 2880 04C08DE5 		str	ip, [sp, #4]
 4562 2884 FEFFFFEB 		bl	cmdSet
1625:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4563              		.loc 1 1625 0
 4564 2888 1C009AE5 		ldr	r0, [sl, #28]
 4565 288c FEFFFFEB 		bl	_txe_mutex_put
1628:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4566              		.loc 1 1628 0
 4567 2890 30009DE5 		ldr	r0, [sp, #48]
1629:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4568              		.loc 1 1629 0
 4569 2894 34C09DE5 		ldr	ip, [sp, #52]
1631:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4570              		.loc 1 1631 0
 4571 2898 38309DE5 		ldr	r3, [sp, #56]
1628:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4572              		.loc 1 1628 0
 4573 289c 061089E0 		add	r1, r9, r6
 4574 28a0 816188E0 		add	r6, r8, r1, asl #3
1630:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4575              		.loc 1 1630 0
 4576 28a4 0120A0E3 		mov	r2, #1
1628:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 4577              		.loc 1 1628 0
 4578 28a8 2D05C6E5 		strb	r0, [r6, #1325]
1629:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 4579              		.loc 1 1629 0
 4580 28ac 2EC5C6E5 		strb	ip, [r6, #1326]
1630:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 4581              		.loc 1 1630 0
 4582 28b0 3025C6E5 		strb	r2, [r6, #1328]
1631:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 4583              		.loc 1 1631 0
 4584 28b4 0D33C8E5 		strb	r3, [r8, #781]
 4585 28b8 3FFFFFEA 		b	.L349
 4586              	.LVL384:
 4587              	.L295:
1558:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4588              		.loc 1 1558 0
 4589 28bc 062089E0 		add	r2, r9, r6
 4590 28c0 826188E0 		add	r6, r8, r2, asl #3
1559:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4591              		.loc 1 1559 0
 4592 28c4 0110A0E3 		mov	r1, #1
1562:../uvc.c      **** 		  		    switch (getData){
 4593              		.loc 1 1562 0
 4594 28c8 01E040E2 		sub	lr, r0, #1
1558:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 4595              		.loc 1 1558 0
 4596 28cc 2D05C6E5 		strb	r0, [r6, #1325]
1559:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 4597              		.loc 1 1559 0
 4598 28d0 3015C6E5 		strb	r1, [r6, #1328]
 4599              	.LVL385:
1562:../uvc.c      **** 		  		    switch (getData){
 4600              		.loc 1 1562 0
 4601 28d4 07005EE3 		cmp	lr, #7
 4602 28d8 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 4603 28dc 980000EA 		b	.L300
 4604              	.L305:
 4605 28e0 D82A0000 		.word	.L301
 4606 28e4 3C2A0000 		.word	.L302
 4607 28e8 442B0000 		.word	.L300
 4608 28ec D4290000 		.word	.L303
 4609 28f0 442B0000 		.word	.L300
 4610 28f4 442B0000 		.word	.L300
 4611 28f8 442B0000 		.word	.L300
 4612 28fc 34290000 		.word	.L304
 4613              	.LVL386:
 4614              	.L294:
1678:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4615              		.loc 1 1678 0
 4616 2900 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1677:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4617              		.loc 1 1677 0
 4618 2904 30A09DE5 		ldr	sl, [sp, #48]
 4619 2908 069089E0 		add	r9, r9, r6
 4620 290c 89E188E0 		add	lr, r8, r9, asl #3
1678:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4621              		.loc 1 1678 0
 4622 2910 0620A0E1 		mov	r2, r6
 4623 2914 0400A0E3 		mov	r0, #4
 4624 2918 C0129FE5 		ldr	r1, .L359+36
1677:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4625              		.loc 1 1677 0
 4626 291c 2DA5CEE5 		strb	sl, [lr, #1325]
1678:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 4627              		.loc 1 1678 0
 4628 2920 FEFFFFEB 		bl	CyU3PDebugPrint
1679:../uvc.c      **** 			  		 break;
 4629              		.loc 1 1679 0
 4630 2924 FFC0A0E3 		mov	ip, #255
 4631 2928 0C60A0E1 		mov	r6, ip
 4632 292c 0C80A0E1 		mov	r8, ip
 4633 2930 68FEFFEA 		b	.L285
 4634              	.LVL387:
 4635              	.L304:
1581:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4636              		.loc 1 1581 0
 4637 2934 98629FE5 		ldr	r6, .L359+24
1579:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4638              		.loc 1 1579 0
 4639 2938 00A0A0E3 		mov	sl, #0
1581:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4640              		.loc 1 1581 0
 4641 293c 1C0096E5 		ldr	r0, [r6, #28]
1579:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4642              		.loc 1 1579 0
 4643 2940 0DA3C8E5 		strb	sl, [r8, #781]
 4644              	.LVL388:
1581:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4645              		.loc 1 1581 0
 4646 2944 0010E0E3 		mvn	r1, #0
 4647 2948 2C308DE5 		str	r3, [sp, #44]
 4648 294c FEFFFFEB 		bl	_txe_mutex_get
1582:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4649              		.loc 1 1582 0
 4650 2950 0B20A0E1 		mov	r2, fp
 4651 2954 2C309DE5 		ldr	r3, [sp, #44]
 4652 2958 1010A0E3 		mov	r1, #16
 4653 295c 0600A0E1 		mov	r0, r6
 4654 2960 00A08DE5 		str	sl, [sp, #0]
 4655 2964 04A08DE5 		str	sl, [sp, #4]
 4656 2968 FEFFFFEB 		bl	cmdSet
1583:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4657              		.loc 1 1583 0
 4658 296c 1C0096E5 		ldr	r0, [r6, #28]
 4659 2970 FEFFFFEB 		bl	_txe_mutex_put
 4660              	.LVL389:
 4661              	.LBB68:
 4662              	.LBB69:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4663              		.loc 1 679 0
 4664 2974 0010E0E3 		mvn	r1, #0
 4665 2978 1C0096E5 		ldr	r0, [r6, #28]
 4666 297c FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4667              		.loc 1 680 0
 4668 2980 01C0A0E3 		mov	ip, #1
 4669 2984 2010A0E3 		mov	r1, #32
 4670 2988 2720A0E3 		mov	r2, #39
 4671 298c 3030A0E3 		mov	r3, #48
 4672 2990 0600A0E1 		mov	r0, r6
 4673 2994 00C08DE5 		str	ip, [sp, #0]
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4674              		.loc 1 681 0
 4675 2998 0280A0E3 		mov	r8, #2
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4676              		.loc 1 680 0
 4677 299c 04A08DE5 		str	sl, [sp, #4]
 4678 29a0 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4679              		.loc 1 681 0
 4680 29a4 2110A0E3 		mov	r1, #33
 4681 29a8 2520A0E3 		mov	r2, #37
 4682 29ac 3030A0E3 		mov	r3, #48
 4683 29b0 0600A0E1 		mov	r0, r6
 4684 29b4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4685 29b8 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4686              		.loc 1 682 0
 4687 29bc 1C0096E5 		ldr	r0, [r6, #28]
 4688 29c0 FEFFFFEB 		bl	_txe_mutex_put
 4689              	.LBE69:
 4690              	.LBE68:
1585:../uvc.c      **** 							break;
 4691              		.loc 1 1585 0
 4692 29c4 FFC0A0E3 		mov	ip, #255
 4693 29c8 0C60A0E1 		mov	r6, ip
 4694 29cc 0880A0E3 		mov	r8, #8
 4695 29d0 40FEFFEA 		b	.L285
 4696              	.LVL390:
 4697              	.L303:
 4698              	.LBB70:
 4699              	.LBB71:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4700              		.loc 1 679 0
 4701 29d4 F8619FE5 		ldr	r6, .L359+24
 4702 29d8 0010E0E3 		mvn	r1, #0
 4703 29dc 1C0096E5 		ldr	r0, [r6, #28]
 4704 29e0 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4705              		.loc 1 680 0
 4706 29e4 0080A0E3 		mov	r8, #0
 4707 29e8 2010A0E3 		mov	r1, #32
 4708 29ec 2720A0E3 		mov	r2, #39
 4709 29f0 3030A0E3 		mov	r3, #48
 4710 29f4 0600A0E1 		mov	r0, r6
 4711 29f8 00808DE5 		str	r8, [sp, #0]
 4712 29fc 04808DE5 		str	r8, [sp, #4]
 4713 2a00 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4714              		.loc 1 681 0
 4715 2a04 01C0A0E3 		mov	ip, #1
 4716 2a08 2110A0E3 		mov	r1, #33
 4717 2a0c 2520A0E3 		mov	r2, #37
 4718 2a10 3030A0E3 		mov	r3, #48
 4719 2a14 0600A0E1 		mov	r0, r6
 4720 2a18 00C08DE5 		str	ip, [sp, #0]
 4721 2a1c 04808DE5 		str	r8, [sp, #4]
 4722 2a20 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4723              		.loc 1 682 0
 4724 2a24 1C0096E5 		ldr	r0, [r6, #28]
 4725 2a28 FEFFFFEB 		bl	_txe_mutex_put
 4726 2a2c FFC0A0E3 		mov	ip, #255
 4727 2a30 0C60A0E1 		mov	r6, ip
 4728 2a34 0480A0E3 		mov	r8, #4
 4729 2a38 26FEFFEA 		b	.L285
 4730              	.LVL391:
 4731              	.L302:
 4732              	.LBE71:
 4733              	.LBE70:
1569:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4734              		.loc 1 1569 0
 4735 2a3c 90619FE5 		ldr	r6, .L359+24
1567:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4736              		.loc 1 1567 0
 4737 2a40 00A0A0E3 		mov	sl, #0
1569:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4738              		.loc 1 1569 0
 4739 2a44 1C0096E5 		ldr	r0, [r6, #28]
1567:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 4740              		.loc 1 1567 0
 4741 2a48 0DA3C8E5 		strb	sl, [r8, #781]
 4742              	.LVL392:
1569:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4743              		.loc 1 1569 0
 4744 2a4c 0010E0E3 		mvn	r1, #0
 4745 2a50 2C308DE5 		str	r3, [sp, #44]
 4746 2a54 FEFFFFEB 		bl	_txe_mutex_get
1570:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 4747              		.loc 1 1570 0
 4748 2a58 0B20A0E1 		mov	r2, fp
 4749 2a5c 2C309DE5 		ldr	r3, [sp, #44]
 4750 2a60 1010A0E3 		mov	r1, #16
 4751 2a64 0600A0E1 		mov	r0, r6
 4752 2a68 00A08DE5 		str	sl, [sp, #0]
 4753 2a6c 04A08DE5 		str	sl, [sp, #4]
 4754 2a70 FEFFFFEB 		bl	cmdSet
1571:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4755              		.loc 1 1571 0
 4756 2a74 1C0096E5 		ldr	r0, [r6, #28]
 4757 2a78 FEFFFFEB 		bl	_txe_mutex_put
 4758              	.LVL393:
 4759              	.LBB72:
 4760              	.LBB73:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4761              		.loc 1 679 0
 4762 2a7c 0010E0E3 		mvn	r1, #0
 4763 2a80 1C0096E5 		ldr	r0, [r6, #28]
 4764 2a84 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4765              		.loc 1 680 0
 4766 2a88 2010A0E3 		mov	r1, #32
 4767 2a8c 2720A0E3 		mov	r2, #39
 4768 2a90 3030A0E3 		mov	r3, #48
 4769 2a94 0600A0E1 		mov	r0, r6
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4770              		.loc 1 681 0
 4771 2a98 0180A0E3 		mov	r8, #1
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4772              		.loc 1 680 0
 4773 2a9c 00A08DE5 		str	sl, [sp, #0]
 4774 2aa0 04A08DE5 		str	sl, [sp, #4]
 4775 2aa4 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4776              		.loc 1 681 0
 4777 2aa8 2110A0E3 		mov	r1, #33
 4778 2aac 2520A0E3 		mov	r2, #37
 4779 2ab0 3030A0E3 		mov	r3, #48
 4780 2ab4 0600A0E1 		mov	r0, r6
 4781 2ab8 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4782 2abc FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4783              		.loc 1 682 0
 4784 2ac0 1C0096E5 		ldr	r0, [r6, #28]
 4785 2ac4 FEFFFFEB 		bl	_txe_mutex_put
 4786 2ac8 FFC0A0E3 		mov	ip, #255
 4787 2acc 0C60A0E1 		mov	r6, ip
 4788 2ad0 0280A0E3 		mov	r8, #2
 4789 2ad4 FFFDFFEA 		b	.L285
 4790              	.LVL394:
 4791              	.L301:
 4792              	.LBE73:
 4793              	.LBE72:
 4794              	.LBB74:
 4795              	.LBB75:
 679:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4796              		.loc 1 679 0
 4797 2ad8 F4609FE5 		ldr	r6, .L359+24
 4798 2adc 0010E0E3 		mvn	r1, #0
 4799 2ae0 1C0096E5 		ldr	r0, [r6, #28]
 4800 2ae4 FEFFFFEB 		bl	_txe_mutex_get
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 4801              		.loc 1 680 0
 4802 2ae8 0080A0E3 		mov	r8, #0
 4803 2aec 01A0A0E3 		mov	sl, #1
 4804 2af0 2010A0E3 		mov	r1, #32
 4805 2af4 2720A0E3 		mov	r2, #39
 4806 2af8 3030A0E3 		mov	r3, #48
 4807 2afc 0600A0E1 		mov	r0, r6
 4808 2b00 04808DE5 		str	r8, [sp, #4]
 4809 2b04 00A08DE5 		str	sl, [sp, #0]
 4810 2b08 FEFFFFEB 		bl	cmdSet
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 4811              		.loc 1 681 0
 4812 2b0c 02C0A0E3 		mov	ip, #2
 4813 2b10 2110A0E3 		mov	r1, #33
 4814 2b14 2520A0E3 		mov	r2, #37
 4815 2b18 3030A0E3 		mov	r3, #48
 4816 2b1c 0600A0E1 		mov	r0, r6
 4817 2b20 00C08DE5 		str	ip, [sp, #0]
 4818 2b24 04808DE5 		str	r8, [sp, #4]
 4819 2b28 FEFFFFEB 		bl	cmdSet
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4820              		.loc 1 682 0
 4821 2b2c 1C0096E5 		ldr	r0, [r6, #28]
 4822 2b30 FEFFFFEB 		bl	_txe_mutex_put
 4823              	.LBE75:
 4824              	.LBE74:
1565:../uvc.c      **** 							break;
 4825              		.loc 1 1565 0
 4826 2b34 FFC0A0E3 		mov	ip, #255
 4827 2b38 0C60A0E1 		mov	r6, ip
 4828 2b3c 0A80A0E1 		mov	r8, sl
 4829 2b40 E4FDFFEA 		b	.L285
 4830              	.LVL395:
 4831              	.L300:
1562:../uvc.c      **** 		  		    switch (getData){
 4832              		.loc 1 1562 0
 4833 2b44 FFC0A0E3 		mov	ip, #255
 4834 2b48 0080A0E1 		mov	r8, r0
 4835 2b4c 0C60A0E1 		mov	r6, ip
 4836 2b50 E0FDFFEA 		b	.L285
 4837              	.LVL396:
 4838              	.L306:
1633:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4839              		.loc 1 1633 0
 4840 2b54 0000A0E3 		mov	r0, #0
 4841 2b58 0110A0E3 		mov	r1, #1
 4842 2b5c 0020A0E1 		mov	r2, r0
 4843 2b60 FEFFFFEB 		bl	CyU3PUsbStall
 4844              	.LVL397:
 4845 2b64 94FEFFEA 		b	.L349
 4846              	.LVL398:
 4847              	.L348:
1651:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 4848              		.loc 1 1651 0
 4849 2b68 0110A0E3 		mov	r1, #1
 4850 2b6c 0020A0E1 		mov	r2, r0
 4851 2b70 FEFFFFEB 		bl	CyU3PUsbStall
 4852 2b74 90FEFFEA 		b	.L349
 4853              	.LVL399:
 4854              	.L358:
1666:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 4855              		.loc 1 1666 0
 4856 2b78 08E0A0E3 		mov	lr, #8
 4857 2b7c 00C0A0E3 		mov	ip, #0
 4858 2b80 0600A0E1 		mov	r0, r6
 4859 2b84 2310A0E3 		mov	r1, #35
 4860 2b88 0B20A0E1 		mov	r2, fp
 4861 2b8c 00E08DE5 		str	lr, [sp, #0]
 4862 2b90 04C08DE5 		str	ip, [sp, #4]
 4863 2b94 FEFFFFEB 		bl	cmdSet
 4864 2b98 5DFEFFEA 		b	.L351
 4865              	.L357:
1664:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 4866              		.loc 1 1664 0
 4867 2b9c 0480A0E3 		mov	r8, #4
 4868 2ba0 00E0A0E3 		mov	lr, #0
 4869 2ba4 0600A0E1 		mov	r0, r6
 4870 2ba8 2310A0E3 		mov	r1, #35
 4871 2bac 0B20A0E1 		mov	r2, fp
 4872 2bb0 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 4873 2bb4 FEFFFFEB 		bl	cmdSet
 4874 2bb8 55FEFFEA 		b	.L351
 4875              	.L360:
 4876              		.align	2
 4877              	.L359:
 4878 2bbc 00000000 		.word	bRequest
 4879 2bc0 00000000 		.word	.LANCHOR1
 4880 2bc4 00000000 		.word	.LANCHOR0
 4881 2bc8 E0040000 		.word	.LC29
 4882 2bcc 04050000 		.word	.LC30
 4883 2bd0 5C000000 		.word	.LANCHOR0+92
 4884 2bd4 00000000 		.word	cmdQu
 4885 2bd8 94040000 		.word	.LC27
 4886 2bdc FFFF0000 		.word	65535
 4887 2be0 BC040000 		.word	.LC28
 4888              		.cfi_endproc
 4889              	.LFE4:
 4891              		.align	2
 4892              		.global	UVCAppEP0Thread_Entry
 4894              	UVCAppEP0Thread_Entry:
 4895              	.LFB25:
3844:../uvc.c      **** {
 4896              		.loc 1 3844 0
 4897              		.cfi_startproc
 4898              		@ args = 0, pretend = 0, frame = 24
 4899              		@ frame_needed = 0, uses_anonymous_args = 0
 4900              	.LVL400:
 4901 2be4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4902              	.LCFI20:
 4903              		.cfi_def_cfa_offset 36
 4904 2be8 644D9FE5 		ldr	r4, .L556
 4905              		.cfi_offset 14, -4
 4906              		.cfi_offset 11, -8
 4907              		.cfi_offset 10, -12
 4908              		.cfi_offset 9, -16
 4909              		.cfi_offset 8, -20
 4910              		.cfi_offset 7, -24
 4911              		.cfi_offset 6, -28
 4912              		.cfi_offset 5, -32
 4913              		.cfi_offset 4, -36
 4914 2bec 645D9FE5 		ldr	r5, .L556+4
 4915 2bf0 648D9FE5 		ldr	r8, .L556+8
 4916 2bf4 64AD9FE5 		ldr	sl, .L556+12
 4917 2bf8 64BD9FE5 		ldr	fp, .L556+16
 4918 2bfc 647D9FE5 		ldr	r7, .L556+20
 4919 2c00 34D04DE2 		sub	sp, sp, #52
 4920              	.LCFI21:
 4921              		.cfi_def_cfa_offset 88
 4922              	.LVL401:
3866:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4923              		.loc 1 3866 0
 4924 2c04 0460A0E1 		mov	r6, r4
 4925              	.LVL402:
 4926              	.L516:
 4927 2c08 00C0E0E3 		mvn	ip, #0
 4928 2c0c 400D9FE5 		ldr	r0, .L556
 4929 2c10 4C10A0E3 		mov	r1, #76
 4930 2c14 0120A0E3 		mov	r2, #1
 4931 2c18 28308DE2 		add	r3, sp, #40
 4932 2c1c 00C08DE5 		str	ip, [sp, #0]
 4933 2c20 FEFFFFEB 		bl	_txe_event_flags_get
 4934 2c24 000050E3 		cmp	r0, #0
 4935 2c28 3000001A 		bne	.L362
3870:../uvc.c      ****             if (!isUsbConnected)
 4936              		.loc 1 3870 0
 4937 2c2c 303096E5 		ldr	r3, [r6, #48]
 4938 2c30 000053E3 		cmp	r3, #0
 4939 2c34 8C00000A 		beq	.L545
 4940              	.L363:
3879:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4941              		.loc 1 3879 0
 4942 2c38 28309DE5 		ldr	r3, [sp, #40]
 4943 2c3c 0C0013E3 		tst	r3, #12
 4944 2c40 7500001A 		bne	.L546
 4945              	.L364:
3886:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4946              		.loc 1 3886 0
 4947 2c44 040013E3 		tst	r3, #4
 4948 2c48 1C00000A 		beq	.L365
3888:../uvc.c      ****             	switch ((wIndex >> 8))
 4949              		.loc 1 3888 0
 4950 2c4c B0E0DBE1 		ldrh	lr, [fp, #0]
 4951 2c50 2E24A0E1 		mov	r2, lr, lsr #8
 4952 2c54 030052E3 		cmp	r2, #3
 4953 2c58 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4954 2c5c 120000EA 		b	.L366
 4955              	.L371:
 4956 2c60 AC2C0000 		.word	.L366
 4957 2c64 9C2D0000 		.word	.L368
 4958 2c68 702C0000 		.word	.L369
 4959 2c6c D82D0000 		.word	.L370
 4960              	.L369:
 4961              	.LBB90:
 4962              	.LBB94:
3092:../uvc.c      ****     switch (wValue)
 4963              		.loc 1 3092 0
 4964 2c70 B020DAE1 		ldrh	r2, [sl, #0]
 4965 2c74 060C52E3 		cmp	r2, #1536
 4966 2c78 9902000A 		beq	.L377
 4967 2c7c D900008A 		bhi	.L383
 4968 2c80 030C52E3 		cmp	r2, #768
 4969 2c84 9202000A 		beq	.L375
 4970 2c88 A001008A 		bhi	.L384
 4971 2c8c 010C52E3 		cmp	r2, #256
 4972 2c90 B602000A 		beq	.L373
 4973 2c94 020C52E3 		cmp	r2, #512
 4974 2c98 B002000A 		beq	.L547
 4975              	.L386:
 4976              	.LBE94:
 4977              	.LBE90:
 4978              	.LBB98:
 4979              	.LBB103:
3224:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4980              		.loc 1 3224 0
 4981 2c9c C81C9FE5 		ldr	r1, .L556+24
 4982 2ca0 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4983 2ca4 0400A0E3 		mov	r0, #4
 4984 2ca8 FEFFFFEB 		bl	CyU3PDebugPrint
 4985              	.L366:
 4986              	.LBE103:
 4987              	.LBE98:
3909:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4988              		.loc 1 3909 0
 4989 2cac 0000A0E3 		mov	r0, #0
 4990 2cb0 0110A0E3 		mov	r1, #1
 4991 2cb4 0020A0E1 		mov	r2, r0
 4992 2cb8 FEFFFFEB 		bl	CyU3PUsbStall
 4993 2cbc 28309DE5 		ldr	r3, [sp, #40]
 4994              	.L365:
3914:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4995              		.loc 1 3914 0
 4996 2cc0 080013E3 		tst	r3, #8
 4997 2cc4 0700000A 		beq	.L429
3918:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4998              		.loc 1 3918 0
 4999 2cc8 B030DBE1 		ldrh	r3, [fp, #0]
 5000 2ccc 010053E3 		cmp	r3, #1
 5001 2cd0 6B00000A 		beq	.L430
 5002              	.L431:
 5003              	.LBB109:
 5004              	.LBB113:
3833:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5005              		.loc 1 3833 0
 5006 2cd4 0000A0E3 		mov	r0, #0
 5007 2cd8 0110A0E3 		mov	r1, #1
 5008 2cdc 0020A0E1 		mov	r2, r0
 5009 2ce0 FEFFFFEB 		bl	CyU3PUsbStall
 5010              	.L535:
 5011 2ce4 28309DE5 		ldr	r3, [sp, #40]
 5012              	.L429:
 5013              	.LBE113:
 5014              	.LBE109:
3929:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5015              		.loc 1 3929 0
 5016 2ce8 400013E3 		tst	r3, #64
 5017 2cec 0100001A 		bne	.L548
 5018              	.L362:
4142:../uvc.c      ****         CyU3PThreadRelinquish ();
 5019              		.loc 1 4142 0
 5020 2cf0 FEFFFFEB 		bl	_txe_thread_relinquish
4143:../uvc.c      ****     }
 5021              		.loc 1 4143 0
 5022 2cf4 C3FFFFEA 		b	.L516
 5023              	.L548:
3934:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5024              		.loc 1 3934 0
 5025 2cf8 1800A0E3 		mov	r0, #24
 5026 2cfc 24108DE2 		add	r1, sp, #36
 5027 2d00 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3991:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5028              		.loc 1 3991 0
 5029 2d04 0B37D5E5 		ldrb	r3, [r5, #1803]	@ zero_extendqisi2
 5030 2d08 0F0053E3 		cmp	r3, #15
 5031 2d0c 9400000A 		beq	.L549
4018:../uvc.c      **** 				}else if(!snapButFlag){
 5032              		.loc 1 4018 0
 5033 2d10 000053E3 		cmp	r3, #0
 5034 2d14 F5FFFF1A 		bne	.L362
4020:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5035              		.loc 1 4020 0
 5036 2d18 002097E5 		ldr	r2, [r7, #0]
 5037 2d1c 0290A0E3 		mov	r9, #2
 5038 2d20 0090C2E5 		strb	r9, [r2, #0]
4021:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5039              		.loc 1 4021 0
 5040 2d24 001097E5 		ldr	r1, [r7, #0]
 5041 2d28 0190A0E3 		mov	r9, #1
 5042 2d2c 0190C1E5 		strb	r9, [r1, #1]
4022:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5043              		.loc 1 4022 0
 5044 2d30 000097E5 		ldr	r0, [r7, #0]
4026:../uvc.c      **** 					interStabuf.size   = 1024;
 5045              		.loc 1 4026 0
 5046 2d34 01CBA0E3 		mov	ip, #1024	@ movhi
4022:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5047              		.loc 1 4022 0
 5048 2d38 0230C0E5 		strb	r3, [r0, #2]
4023:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5049              		.loc 1 4023 0
 5050 2d3c 00E097E5 		ldr	lr, [r7, #0]
4032:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5051              		.loc 1 4032 0
 5052 2d40 0010E0E3 		mvn	r1, #0
4023:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 5053              		.loc 1 4023 0
 5054 2d44 0390CEE5 		strb	r9, [lr, #3]
4025:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5055              		.loc 1 4025 0
 5056 2d48 002097E5 		ldr	r2, [r7, #0]
4029:../uvc.c      **** 					interStabuf.count = 4;
 5057              		.loc 1 4029 0
 5058 2d4c 04E0A0E3 		mov	lr, #4	@ movhi
4032:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5059              		.loc 1 4032 0
 5060 2d50 180C9FE5 		ldr	r0, .L556+28
4025:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5061              		.loc 1 4025 0
 5062 2d54 18208DE5 		str	r2, [sp, #24]
4026:../uvc.c      **** 					interStabuf.size   = 1024;
 5063              		.loc 1 4026 0
 5064 2d58 BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4027:../uvc.c      **** 					interStabuf.status = 0;
 5065              		.loc 1 4027 0
 5066 2d5c B032CDE1 		strh	r3, [sp, #32]	@ movhi
4029:../uvc.c      **** 					interStabuf.count = 4;
 5067              		.loc 1 4029 0
 5068 2d60 BCE1CDE1 		strh	lr, [sp, #28]	@ movhi
4032:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5069              		.loc 1 4032 0
 5070 2d64 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4035:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5071              		.loc 1 4035 0
 5072 2d68 000C9FE5 		ldr	r0, .L556+28
 5073 2d6c 18108DE2 		add	r1, sp, #24
 5074 2d70 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5075              	.LVL403:
4037:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5076              		.loc 1 4037 0
 5077 2d74 002050E2 		subs	r2, r0, #0
 5078 2d78 5B01001A 		bne	.L550
4043:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 5079              		.loc 1 4043 0
 5080 2d7c 3010A0E3 		mov	r1, #48
 5081 2d80 0920A0E1 		mov	r2, r9
 5082 2d84 0500A0E3 		mov	r0, #5
 5083              	.LVL404:
 5084 2d88 FEFFFFEB 		bl	SensorSetControl
4044:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 5085              		.loc 1 4044 0
 5086 2d8c C43B9FE5 		ldr	r3, .L556+4
 5087 2d90 0B97C3E5 		strb	r9, [r3, #1803]
4142:../uvc.c      ****         CyU3PThreadRelinquish ();
 5088              		.loc 1 4142 0
 5089 2d94 FEFFFFEB 		bl	_txe_thread_relinquish
 5090 2d98 9AFFFFEA 		b	.L516
 5091              	.L368:
 5092              	.LBB118:
 5093              	.LBB104:
3167:../uvc.c      ****     switch (wValue)
 5094              		.loc 1 3167 0
 5095 2d9c B020DAE1 		ldrh	r2, [sl, #0]
 5096 2da0 060C52E3 		cmp	r2, #1536
 5097 2da4 7502000A 		beq	.L392
 5098 2da8 9900008A 		bhi	.L398
 5099 2dac 030C52E3 		cmp	r2, #768
 5100 2db0 5B02000A 		beq	.L389
 5101 2db4 8101008A 		bhi	.L399
 5102 2db8 010C52E3 		cmp	r2, #256
 5103 2dbc 5402000A 		beq	.L387
 5104 2dc0 020C52E3 		cmp	r2, #512
 5105 2dc4 B4FFFF1A 		bne	.L386
 5106              	.LVL405:
3175:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 5107              		.loc 1 3175 0
 5108 2dc8 0100A0E3 		mov	r0, #1
 5109 2dcc FEFFFFEB 		bl	CTControlHandle
 5110              	.LVL406:
 5111 2dd0 28309DE5 		ldr	r3, [sp, #40]
 5112 2dd4 B9FFFFEA 		b	.L365
 5113              	.L370:
 5114              	.LBE104:
 5115              	.LBE118:
 5116              	.LBB119:
 5117              	.LBB125:
3392:../uvc.c      ****     switch (wValue)
 5118              		.loc 1 3392 0
 5119 2dd8 B030DAE1 		ldrh	r3, [sl, #0]
 5120 2ddc 090C53E3 		cmp	r3, #2304
 5121 2de0 4702000A 		beq	.L413
 5122 2de4 9200008A 		bhi	.L423
 5123 2de8 010B53E3 		cmp	r3, #1024
 5124 2dec 4002000A 		beq	.L408
 5125 2df0 5701008A 		bhi	.L424
 5126 2df4 020C53E3 		cmp	r3, #512
 5127 2df8 C101000A 		beq	.L406
 5128 2dfc 030C53E3 		cmp	r3, #768
 5129 2e00 BB01000A 		beq	.L407
 5130 2e04 010C53E3 		cmp	r3, #256
 5131 2e08 A7FFFF1A 		bne	.L366
 5132              	.LVL407:
3396:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 5133              		.loc 1 3396 0
 5134 2e0c 1000A0E3 		mov	r0, #16
 5135 2e10 FEFFFFEB 		bl	ControlHandle
 5136              	.LVL408:
 5137 2e14 28309DE5 		ldr	r3, [sp, #40]
 5138 2e18 A8FFFFEA 		b	.L365
 5139              	.L546:
 5140              	.LBE125:
 5141              	.LBE119:
3880:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 5142              		.loc 1 3880 0
 5143 2e1c B0C0DAE1 		ldrh	ip, [sl, #0]
 5144 2e20 4C9B9FE5 		ldr	r9, .L556+32
 5145 2e24 4C1B9FE5 		ldr	r1, .L556+36
 5146 2e28 00E0D9E5 		ldrb	lr, [r9, #0]	@ zero_extendqisi2
 5147 2e2c 08C08DE5 		str	ip, [sp, #8]
 5148 2e30 B000DBE1 		ldrh	r0, [fp, #0]
 5149 2e34 0090D8E5 		ldrb	r9, [r8, #0]	@ zero_extendqisi2
 5150 2e38 0C008DE5 		str	r0, [sp, #12]
 5151 2e3c B0C0D1E1 		ldrh	ip, [r1, #0]
 5152 2e40 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 5153 2e44 04908DE5 		str	r9, [sp, #4]
 5154 2e48 0400A0E3 		mov	r0, #4
 5155 2e4c 281B9FE5 		ldr	r1, .L556+40
 5156 2e50 0090A0E3 		mov	r9, #0
 5157 2e54 00E08DE5 		str	lr, [sp, #0]
 5158 2e58 10C08DE5 		str	ip, [sp, #16]
 5159 2e5c 14908DE5 		str	r9, [sp, #20]
 5160 2e60 FEFFFFEB 		bl	CyU3PDebugPrint
 5161 2e64 28309DE5 		ldr	r3, [sp, #40]
 5162 2e68 75FFFFEA 		b	.L364
 5163              	.L545:
3872:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5164              		.loc 1 3872 0
 5165 2e6c FEFFFFEB 		bl	CyU3PUsbGetSpeed
3873:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5166              		.loc 1 3873 0
 5167 2e70 000050E3 		cmp	r0, #0
3872:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5168              		.loc 1 3872 0
 5169 2e74 4800C6E5 		strb	r0, [r6, #72]
3875:../uvc.c      ****                     isUsbConnected = CyTrue;
 5170              		.loc 1 3875 0
 5171 2e78 0100A013 		movne	r0, #1
 5172 2e7c 30008615 		strne	r0, [r6, #48]
 5173 2e80 6CFFFFEA 		b	.L363
 5174              	.L430:
 5175              	.LVL409:
 5176              	.LBB132:
 5177              	.LBB114:
3493:../uvc.c      ****     switch (wValue)
 5178              		.loc 1 3493 0
 5179 2e84 B020DAE1 		ldrh	r2, [sl, #0]
 5180 2e88 030C52E3 		cmp	r2, #768
 5181 2e8c CD00000A 		beq	.L434
 5182 2e90 0F00008A 		bhi	.L437
 5183 2e94 010C52E3 		cmp	r2, #256
 5184 2e98 8600000A 		beq	.L432
 5185 2e9c 020C52E3 		cmp	r2, #512
 5186 2ea0 8BFFFF1A 		bne	.L431
3558:../uvc.c      ****             switch (bRequest)
 5187              		.loc 1 3558 0
 5188 2ea4 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 5189 2ea8 810053E3 		cmp	r3, #129
 5190 2eac 8301000A 		beq	.L503
 5191 2eb0 D100008A 		bhi	.L452
 5192 2eb4 010053E3 		cmp	r3, #1
 5193 2eb8 7101000A 		beq	.L551
 5194              	.L479:
3771:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5195              		.loc 1 3771 0
 5196 2ebc 0000A0E3 		mov	r0, #0
 5197 2ec0 0110A0E3 		mov	r1, #1
 5198 2ec4 0020A0E1 		mov	r2, r0
 5199 2ec8 FEFFFFEB 		bl	CyU3PUsbStall
 5200 2ecc 28309DE5 		ldr	r3, [sp, #40]
 5201 2ed0 84FFFFEA 		b	.L429
 5202              	.L437:
3493:../uvc.c      ****     switch (wValue)
 5203              		.loc 1 3493 0
 5204 2ed4 010B52E3 		cmp	r2, #1024
 5205 2ed8 6100000A 		beq	.L435
 5206 2edc 050C52E3 		cmp	r2, #1280
 5207 2ee0 7BFFFF1A 		bne	.L431
3778:../uvc.c      ****             	switch (bRequest)
 5208              		.loc 1 3778 0
 5209 2ee4 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5210 2ee8 810052E3 		cmp	r2, #129
 5211 2eec 7301000A 		beq	.L503
 5212 2ef0 4401008A 		bhi	.L506
 5213 2ef4 010052E3 		cmp	r2, #1
 5214 2ef8 75FFFF1A 		bne	.L431
3803:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5215              		.loc 1 3803 0
 5216 2efc 2000A0E3 		mov	r0, #32
 5217 2f00 781A9FE5 		ldr	r1, .L556+44
 5218 2f04 2E208DE2 		add	r2, sp, #46
 5219 2f08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5220              	.LVL410:
3805:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5221              		.loc 1 3805 0
 5222 2f0c 000050E3 		cmp	r0, #0
 5223 2f10 5501001A 		bne	.L508
3809:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 5224              		.loc 1 3809 0
 5225 2f14 0020A0E3 		mov	r2, #0
 5226 2f18 340A9FE5 		ldr	r0, .L556
 5227              	.LVL411:
 5228 2f1c 8010A0E3 		mov	r1, #128
 5229 2f20 FEFFFFEB 		bl	_txe_event_flags_set
 5230              	.LVL412:
3810:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5231              		.loc 1 3810 0
 5232 2f24 002050E2 		subs	r2, r0, #0
3816:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 5233              		.loc 1 3816 0
 5234 2f28 0FC0E003 		mvneq	ip, #15
 5235 2f2c 3AC0C605 		streqb	ip, [r6, #58]
3810:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 5236              		.loc 1 3810 0
 5237 2f30 0200000A 		beq	.L510
3812:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 5238              		.loc 1 3812 0
 5239 2f34 481A9FE5 		ldr	r1, .L556+48
 5240 2f38 0400A0E3 		mov	r0, #4
 5241              	.LVL413:
 5242 2f3c FEFFFFEB 		bl	CyU3PDebugPrint
 5243              	.LVL414:
 5244              	.L510:
3819:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 5245              		.loc 1 3819 0
 5246 2f40 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
 5247 2f44 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5248 2f48 BE22DDE1 		ldrh	r2, [sp, #46]
 5249              	.LVL415:
 5250 2f4c 0400A0E3 		mov	r0, #4
 5251 2f50 301A9FE5 		ldr	r1, .L556+52
 5252 2f54 00E08DE5 		str	lr, [sp, #0]
 5253 2f58 FEFFFFEB 		bl	CyU3PDebugPrint
 5254 2f5c 28309DE5 		ldr	r3, [sp, #40]
 5255 2f60 60FFFFEA 		b	.L429
 5256              	.LVL416:
 5257              	.L549:
 5258              	.LBE114:
 5259              	.LBE132:
3993:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 5260              		.loc 1 3993 0
 5261 2f64 003097E5 		ldr	r3, [r7, #0]
 5262 2f68 0290A0E3 		mov	r9, #2
 5263 2f6c 0090C3E5 		strb	r9, [r3, #0]
3994:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 5264              		.loc 1 3994 0
 5265 2f70 002097E5 		ldr	r2, [r7, #0]
 5266 2f74 0190A0E3 		mov	r9, #1
 5267 2f78 0190C2E5 		strb	r9, [r2, #1]
3995:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 5268              		.loc 1 3995 0
 5269 2f7c 001097E5 		ldr	r1, [r7, #0]
 5270 2f80 0030A0E3 		mov	r3, #0
 5271 2f84 0230C1E5 		strb	r3, [r1, #2]
3996:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5272              		.loc 1 3996 0
 5273 2f88 000097E5 		ldr	r0, [r7, #0]
4002:../uvc.c      **** 					interStabuf.count = 4;
 5274              		.loc 1 4002 0
 5275 2f8c 0420A0E3 		mov	r2, #4	@ movhi
3996:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 5276              		.loc 1 3996 0
 5277 2f90 0330C0E5 		strb	r3, [r0, #3]
3998:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5278              		.loc 1 3998 0
 5279 2f94 00E097E5 		ldr	lr, [r7, #0]
3999:../uvc.c      **** 					interStabuf.size   = 1024;
 5280              		.loc 1 3999 0
 5281 2f98 01CBA0E3 		mov	ip, #1024	@ movhi
4005:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5282              		.loc 1 4005 0
 5283 2f9c 0010E0E3 		mvn	r1, #0
 5284 2fa0 C8099FE5 		ldr	r0, .L556+28
4002:../uvc.c      **** 					interStabuf.count = 4;
 5285              		.loc 1 4002 0
 5286 2fa4 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
3998:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 5287              		.loc 1 3998 0
 5288 2fa8 18E08DE5 		str	lr, [sp, #24]
3999:../uvc.c      **** 					interStabuf.size   = 1024;
 5289              		.loc 1 3999 0
 5290 2fac BEC1CDE1 		strh	ip, [sp, #30]	@ movhi
4000:../uvc.c      **** 					interStabuf.status = 0;
 5291              		.loc 1 4000 0
 5292 2fb0 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4005:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 5293              		.loc 1 4005 0
 5294 2fb4 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4008:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 5295              		.loc 1 4008 0
 5296 2fb8 B0099FE5 		ldr	r0, .L556+28
 5297 2fbc 18108DE2 		add	r1, sp, #24
 5298 2fc0 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5299              	.LVL417:
4010:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 5300              		.loc 1 4010 0
 5301 2fc4 002050E2 		subs	r2, r0, #0
 5302 2fc8 D800001A 		bne	.L552
4015:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 5303              		.loc 1 4015 0
 5304 2fcc 3010A0E3 		mov	r1, #48
 5305 2fd0 0500A0E3 		mov	r0, #5
 5306              	.LVL418:
 5307 2fd4 FEFFFFEB 		bl	SensorSetControl
 5308              	.LVL419:
4017:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 5309              		.loc 1 4017 0
 5310 2fd8 78C99FE5 		ldr	ip, .L556+4
 5311 2fdc 0B97CCE5 		strb	r9, [ip, #1803]
4142:../uvc.c      ****         CyU3PThreadRelinquish ();
 5312              		.loc 1 4142 0
 5313 2fe0 FEFFFFEB 		bl	_txe_thread_relinquish
 5314 2fe4 07FFFFEA 		b	.L516
 5315              	.L383:
 5316              	.LBB133:
 5317              	.LBB93:
3092:../uvc.c      ****     switch (wValue)
 5318              		.loc 1 3092 0
 5319 2fe8 0A0C52E3 		cmp	r2, #2560
 5320 2fec 1A01000A 		beq	.L380
 5321 2ff0 FA00008A 		bhi	.L385
 5322 2ff4 070C52E3 		cmp	r2, #1792
 5323 2ff8 1301000A 		beq	.L378
 5324 2ffc 020B52E3 		cmp	r2, #2048
 5325 3000 25FFFF1A 		bne	.L386
 5326              	.LVL420:
3123:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 5327              		.loc 1 3123 0
 5328 3004 0700A0E3 		mov	r0, #7
 5329 3008 FEFFFFEB 		bl	ControlHandle
 5330              	.LVL421:
 5331 300c 28309DE5 		ldr	r3, [sp, #40]
 5332 3010 2AFFFFEA 		b	.L365
 5333              	.L398:
 5334              	.LBE93:
 5335              	.LBE133:
 5336              	.LBB134:
 5337              	.LBB102:
3167:../uvc.c      ****     switch (wValue)
 5338              		.loc 1 3167 0
 5339 3014 090C52E3 		cmp	r2, #2304
 5340 3018 A901000A 		beq	.L394
 5341 301c D500008A 		bhi	.L400
 5342 3020 070C52E3 		cmp	r2, #1792
 5343 3024 A201000A 		beq	.L393
 5344 3028 020B52E3 		cmp	r2, #2048
 5345 302c 1AFFFF1A 		bne	.L386
 5346 3030 22FFFFEA 		b	.L365
 5347              	.L423:
 5348              	.LBE102:
 5349              	.LBE134:
 5350              	.LBB135:
 5351              	.LBB126:
3392:../uvc.c      ****     switch (wValue)
 5352              		.loc 1 3392 0
 5353 3034 0F0C53E3 		cmp	r3, #3840
 5354 3038 9901000A 		beq	.L418
 5355 303c A100008A 		bhi	.L426
 5356 3040 0B0C53E3 		cmp	r3, #2816
 5357 3044 FC00000A 		beq	.L415
 5358 3048 9600008A 		bhi	.L427
 5359 304c 0A0C53E3 		cmp	r3, #2560
 5360 3050 15FFFF1A 		bne	.L366
 5361              	.LVL422:
3433:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5362              		.loc 1 3433 0
 5363 3054 1900A0E3 		mov	r0, #25
 5364 3058 FEFFFFEB 		bl	ControlHandle
 5365              	.LVL423:
 5366 305c 28309DE5 		ldr	r3, [sp, #40]
 5367 3060 16FFFFEA 		b	.L365
 5368              	.LVL424:
 5369              	.L435:
 5370              	.LBE126:
 5371              	.LBE135:
 5372              	.LBB136:
 5373              	.LBB112:
3692:../uvc.c      ****                 switch (bRequest)
 5374              		.loc 1 3692 0
 5375 3064 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5376 3068 810052E3 		cmp	r2, #129
 5377 306c 5A00000A 		beq	.L481
 5378 3070 2100008A 		bhi	.L484
 5379 3074 010052E3 		cmp	r2, #1
 5380 3078 8FFFFF1A 		bne	.L479
3717:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5381              		.loc 1 3717 0
 5382 307c 2000A0E3 		mov	r0, #32
 5383 3080 F8189FE5 		ldr	r1, .L556+44
 5384 3084 2E208DE2 		add	r2, sp, #46
 5385 3088 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5386              	.LVL425:
3719:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5387              		.loc 1 3719 0
 5388 308c 000050E3 		cmp	r0, #0
 5389 3090 13FFFF1A 		bne	.L535
3738:../uvc.c      ****                            switch (glCommitCtrl[1])
 5390              		.loc 1 3738 0
 5391 3094 8120D6E5 		ldrb	r2, [r6, #129]	@ zero_extendqisi2
 5392 3098 011042E2 		sub	r1, r2, #1
 5393 309c 030051E3 		cmp	r1, #3
 5394 30a0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5395 30a4 C90100EA 		b	.L487
 5396              	.L492:
 5397 30a8 3C380000 		.word	.L488
 5398 30ac 90380000 		.word	.L489
 5399 30b0 F8370000 		.word	.L490
 5400 30b4 90370000 		.word	.L491
 5401              	.LVL426:
 5402              	.L432:
3496:../uvc.c      ****             switch (bRequest)
 5403              		.loc 1 3496 0
 5404 30b8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5405 30bc 830052E3 		cmp	r2, #131
 5406 30c0 3100008A 		bhi	.L443
 5407 30c4 810052E3 		cmp	r2, #129
 5408 30c8 1600003A 		bcc	.L553
 5409              	.L440:
3511:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 5410              		.loc 1 3511 0
 5411 30cc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 5412 30d0 030053E3 		cmp	r3, #3
 5413 30d4 FC00001A 		bne	.L507
3513:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 5414              		.loc 1 3513 0
 5415 30d8 AC189FE5 		ldr	r1, .L556+56
 5416 30dc 1A00A0E3 		mov	r0, #26
 5417 30e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3514:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 5418              		.loc 1 3514 0
 5419 30e4 0400A0E3 		mov	r0, #4
 5420 30e8 A0189FE5 		ldr	r1, .L556+60
 5421 30ec 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5422 30f0 FEFFFFEB 		bl	CyU3PDebugPrint
 5423 30f4 28309DE5 		ldr	r3, [sp, #40]
 5424 30f8 FAFEFFEA 		b	.L429
 5425              	.L484:
3692:../uvc.c      ****                 switch (bRequest)
 5426              		.loc 1 3692 0
 5427 30fc 850052E3 		cmp	r2, #133
 5428 3100 2700000A 		beq	.L482
 5429 3104 860052E3 		cmp	r2, #134
 5430 3108 6BFFFF1A 		bne	.L479
 5431              	.L539:
3696:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5432              		.loc 1 3696 0
 5433 310c 0300A0E1 		mov	r0, r3
 5434              	.L534:
3562:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5435              		.loc 1 3562 0
 5436 3110 7C189FE5 		ldr	r1, .L556+64
3561:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 5437              		.loc 1 3561 0
 5438 3114 0390A0E3 		mov	r9, #3
 5439 3118 5C90C4E5 		strb	r9, [r4, #92]
3562:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5440              		.loc 1 3562 0
 5441 311c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5442 3120 28309DE5 		ldr	r3, [sp, #40]
 5443 3124 EFFEFFEA 		b	.L429
 5444              	.L553:
3496:../uvc.c      ****             switch (bRequest)
 5445              		.loc 1 3496 0
 5446 3128 010052E3 		cmp	r2, #1
 5447 312c 62FFFF1A 		bne	.L479
3523:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5448              		.loc 1 3523 0
 5449 3130 2000A0E3 		mov	r0, #32
 5450 3134 44189FE5 		ldr	r1, .L556+44
 5451 3138 2E208DE2 		add	r2, sp, #46
 5452 313c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5453              	.LVL427:
3525:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5454              		.loc 1 3525 0
 5455 3140 000050E3 		cmp	r0, #0
 5456 3144 E6FEFF1A 		bne	.L535
3527:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5457              		.loc 1 3527 0
 5458 3148 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5459 314c 030051E3 		cmp	r1, #3
 5460 3150 E3FEFF1A 		bne	.L535
3534:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5461              		.loc 1 3534 0
 5462 3154 8530D4E5 		ldrb	r3, [r4, #133]	@ zero_extendqisi2
3531:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5463              		.loc 1 3531 0
 5464 3158 82E0D4E5 		ldrb	lr, [r4, #130]	@ zero_extendqisi2
3532:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5465              		.loc 1 3532 0
 5466 315c 83C0D4E5 		ldrb	ip, [r4, #131]	@ zero_extendqisi2
3533:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5467              		.loc 1 3533 0
 5468 3160 8400D4E5 		ldrb	r0, [r4, #132]	@ zero_extendqisi2
 5469              	.LVL428:
3535:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5470              		.loc 1 3535 0
 5471 3164 8620D4E5 		ldrb	r2, [r4, #134]	@ zero_extendqisi2
3536:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5472              		.loc 1 3536 0
 5473 3168 8790D4E5 		ldrb	r9, [r4, #135]	@ zero_extendqisi2
3534:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 5474              		.loc 1 3534 0
 5475 316c A536C5E5 		strb	r3, [r5, #1701]
3531:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 5476              		.loc 1 3531 0
 5477 3170 A2E6C5E5 		strb	lr, [r5, #1698]
3532:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 5478              		.loc 1 3532 0
 5479 3174 A3C6C5E5 		strb	ip, [r5, #1699]
3533:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 5480              		.loc 1 3533 0
 5481 3178 A406C5E5 		strb	r0, [r5, #1700]
3535:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 5482              		.loc 1 3535 0
 5483 317c A626C5E5 		strb	r2, [r5, #1702]
3536:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 5484              		.loc 1 3536 0
 5485 3180 A796C5E5 		strb	r9, [r5, #1703]
 5486 3184 28309DE5 		ldr	r3, [sp, #40]
 5487 3188 D6FEFFEA 		b	.L429
 5488              	.LVL429:
 5489              	.L443:
3496:../uvc.c      ****             switch (bRequest)
 5490              		.loc 1 3496 0
 5491 318c 860052E3 		cmp	r2, #134
 5492 3190 DDFFFF0A 		beq	.L539
 5493 3194 870052E3 		cmp	r2, #135
 5494 3198 CBFFFF0A 		beq	.L440
 5495              	.L544:
3642:../uvc.c      ****                 switch (bRequest)
 5496              		.loc 1 3642 0
 5497 319c 850052E3 		cmp	r2, #133
 5498 31a0 45FFFF1A 		bne	.L479
 5499              	.L482:
3701:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5500              		.loc 1 3701 0
 5501 31a4 E8179FE5 		ldr	r1, .L556+64
 5502 31a8 0200A0E3 		mov	r0, #2
3699:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 5503              		.loc 1 3699 0
 5504 31ac 1A30A0E3 		mov	r3, #26
 5505              	.L536:
3786:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5506              		.loc 1 3786 0
 5507 31b0 0090A0E3 		mov	r9, #0
3785:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 5508              		.loc 1 3785 0
 5509 31b4 5C30C4E5 		strb	r3, [r4, #92]
3786:../uvc.c      ****                         glEp0Buffer[1] = 0;
 5510              		.loc 1 3786 0
 5511 31b8 5D90C4E5 		strb	r9, [r4, #93]
3787:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5512              		.loc 1 3787 0
 5513 31bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5514 31c0 28309DE5 		ldr	r3, [sp, #40]
 5515 31c4 C7FEFFEA 		b	.L429
 5516              	.L434:
3642:../uvc.c      ****                 switch (bRequest)
 5517              		.loc 1 3642 0
 5518 31c8 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 5519 31cc 830052E3 		cmp	r2, #131
 5520 31d0 2F00008A 		bhi	.L475
 5521 31d4 810052E3 		cmp	r2, #129
 5522 31d8 0D00003A 		bcc	.L554
 5523              	.L481:
3704:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5524              		.loc 1 3704 0
 5525 31dc 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
3706:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5526              		.loc 1 3706 0
 5527 31e0 0B00A0E3 		mov	r0, #11
3704:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5528              		.loc 1 3704 0
 5529 31e4 030053E3 		cmp	r3, #3
3706:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5530              		.loc 1 3706 0
 5531 31e8 A8179F05 		ldreq	r1, .L556+68
3710:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 5532              		.loc 1 3710 0
 5533 31ec A8179F15 		ldrne	r1, .L556+72
 5534 31f0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5535 31f4 28309DE5 		ldr	r3, [sp, #40]
 5536 31f8 BAFEFFEA 		b	.L429
 5537              	.L452:
3558:../uvc.c      ****             switch (bRequest)
 5538              		.loc 1 3558 0
 5539 31fc 850053E3 		cmp	r3, #133
 5540 3200 E7FFFF0A 		beq	.L482
 5541 3204 860053E3 		cmp	r3, #134
 5542 3208 2BFFFF1A 		bne	.L479
 5543              	.L540:
3562:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5544              		.loc 1 3562 0
 5545 320c 0100A0E3 		mov	r0, #1
 5546 3210 BEFFFFEA 		b	.L534
 5547              	.L554:
3642:../uvc.c      ****                 switch (bRequest)
 5548              		.loc 1 3642 0
 5549 3214 010052E3 		cmp	r2, #1
 5550 3218 27FFFF1A 		bne	.L479
3667:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5551              		.loc 1 3667 0
 5552 321c 2000A0E3 		mov	r0, #32
 5553 3220 58179FE5 		ldr	r1, .L556+44
 5554 3224 2E208DE2 		add	r2, sp, #46
 5555 3228 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5556              	.LVL430:
3669:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 5557              		.loc 1 3669 0
 5558 322c 000050E3 		cmp	r0, #0
 5559 3230 ABFEFF1A 		bne	.L535
3671:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 5560              		.loc 1 3671 0
 5561 3234 4810D6E5 		ldrb	r1, [r6, #72]	@ zero_extendqisi2
 5562 3238 030051E3 		cmp	r1, #3
 5563 323c 0B00001A 		bne	.L478
3675:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5564              		.loc 1 3675 0
 5565 3240 81E0D6E5 		ldrb	lr, [r6, #129]	@ zero_extendqisi2
3676:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5566              		.loc 1 3676 0
 5567 3244 82C0D6E5 		ldrb	ip, [r6, #130]	@ zero_extendqisi2
3677:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5568              		.loc 1 3677 0
 5569 3248 8300D6E5 		ldrb	r0, [r6, #131]	@ zero_extendqisi2
 5570              	.LVL431:
3678:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5571              		.loc 1 3678 0
 5572 324c 8420D6E5 		ldrb	r2, [r6, #132]	@ zero_extendqisi2
3679:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5573              		.loc 1 3679 0
 5574 3250 8590D6E5 		ldrb	r9, [r6, #133]	@ zero_extendqisi2
3680:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5575              		.loc 1 3680 0
 5576 3254 8630D6E5 		ldrb	r3, [r6, #134]	@ zero_extendqisi2
3675:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 5577              		.loc 1 3675 0
 5578 3258 F5E6C5E5 		strb	lr, [r5, #1781]
3676:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 5579              		.loc 1 3676 0
 5580 325c F6C6C5E5 		strb	ip, [r5, #1782]
3677:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 5581              		.loc 1 3677 0
 5582 3260 F706C5E5 		strb	r0, [r5, #1783]
3678:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 5583              		.loc 1 3678 0
 5584 3264 F826C5E5 		strb	r2, [r5, #1784]
3679:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 5585              		.loc 1 3679 0
 5586 3268 F996C5E5 		strb	r9, [r5, #1785]
3680:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 5587              		.loc 1 3680 0
 5588 326c FA36C5E5 		strb	r3, [r5, #1786]
 5589              	.L478:
3682:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 5590              		.loc 1 3682 0
 5591 3270 8190D4E5 		ldrb	r9, [r4, #129]	@ zero_extendqisi2
 5592 3274 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5593 3278 BE22DDE1 		ldrh	r2, [sp, #46]
 5594              	.LVL432:
 5595 327c 0400A0E3 		mov	r0, #4
 5596 3280 18179FE5 		ldr	r1, .L556+76
 5597 3284 00908DE5 		str	r9, [sp, #0]
 5598 3288 FEFFFFEB 		bl	CyU3PDebugPrint
 5599 328c 28309DE5 		ldr	r3, [sp, #40]
 5600 3290 94FEFFEA 		b	.L429
 5601              	.LVL433:
 5602              	.L475:
3642:../uvc.c      ****                 switch (bRequest)
 5603              		.loc 1 3642 0
 5604 3294 860052E3 		cmp	r2, #134
 5605 3298 9BFFFF0A 		beq	.L539
 5606 329c 870052E3 		cmp	r2, #135
 5607 32a0 BDFFFF1A 		bne	.L544
 5608 32a4 CCFFFFEA 		b	.L481
 5609              	.LVL434:
 5610              	.L427:
 5611              	.LBE112:
 5612              	.LBE136:
 5613              	.LBB137:
 5614              	.LBB124:
3392:../uvc.c      ****     switch (wValue)
 5615              		.loc 1 3392 0
 5616 32a8 030B53E3 		cmp	r3, #3072
 5617 32ac A401000A 		beq	.L416
 5618 32b0 0D0C53E3 		cmp	r3, #3328
 5619 32b4 7CFEFF1A 		bne	.L366
 5620              	.LVL435:
3449:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5621              		.loc 1 3449 0
 5622 32b8 1C00A0E3 		mov	r0, #28
 5623 32bc FEFFFFEB 		bl	ControlHandle
 5624              	.LVL436:
 5625 32c0 28309DE5 		ldr	r3, [sp, #40]
 5626 32c4 7DFEFFEA 		b	.L365
 5627              	.L426:
3392:../uvc.c      ****     switch (wValue)
 5628              		.loc 1 3392 0
 5629 32c8 110C53E3 		cmp	r3, #4352
 5630 32cc 9801000A 		beq	.L420
 5631 32d0 5100008A 		bhi	.L428
 5632 32d4 010A53E3 		cmp	r3, #4096
 5633 32d8 73FEFF1A 		bne	.L366
 5634              	.LVL437:
3461:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 5635              		.loc 1 3461 0
 5636 32dc 1F00A0E3 		mov	r0, #31
 5637 32e0 FEFFFFEB 		bl	ControlHandle
 5638              	.LVL438:
 5639 32e4 28309DE5 		ldr	r3, [sp, #40]
 5640 32e8 74FEFFEA 		b	.L365
 5641              	.LVL439:
 5642              	.L550:
 5643              	.LBE124:
 5644              	.LBE137:
4039:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5645              		.loc 1 4039 0
 5646 32ec 0400A0E3 		mov	r0, #4
 5647              	.LVL440:
 5648 32f0 AC169FE5 		ldr	r1, .L556+80
 5649 32f4 FEFFFFEB 		bl	CyU3PDebugPrint
 5650              	.LVL441:
 5651              	.L515:
 5652              	.LBB138:
 5653              	.LBB139:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5654              		.loc 1 1801 0
 5655 32f8 A8169FE5 		ldr	r1, .L556+84
 5656 32fc 0400A0E3 		mov	r0, #4
 5657 3300 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 5658              		.loc 1 1802 0
 5659 3304 FA0FA0E3 		mov	r0, #1000
 5660 3308 FEFFFFEB 		bl	_tx_thread_sleep
 5661 330c F9FFFFEA 		b	.L515
 5662              	.L384:
 5663              	.LBE139:
 5664              	.LBE138:
 5665              	.LBB140:
 5666              	.LBB95:
3092:../uvc.c      ****     switch (wValue)
 5667              		.loc 1 3092 0
 5668 3310 010B52E3 		cmp	r2, #1024
 5669 3314 69FEFF0A 		beq	.L365
 5670 3318 050C52E3 		cmp	r2, #1280
 5671 331c 5EFEFF1A 		bne	.L386
 5672              	.LVL442:
3111:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 5673              		.loc 1 3111 0
 5674 3320 0400A0E3 		mov	r0, #4
 5675 3324 FEFFFFEB 		bl	ControlHandle
 5676              	.LVL443:
 5677 3328 28309DE5 		ldr	r3, [sp, #40]
 5678 332c 63FEFFEA 		b	.L365
 5679              	.LVL444:
 5680              	.L552:
 5681              	.LBE95:
 5682              	.LBE140:
4012:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 5683              		.loc 1 4012 0
 5684 3330 0400A0E3 		mov	r0, #4
 5685              	.LVL445:
 5686 3334 68169FE5 		ldr	r1, .L556+80
 5687 3338 FEFFFFEB 		bl	CyU3PDebugPrint
 5688              	.LVL446:
 5689              	.L513:
 5690              	.LBB141:
 5691              	.LBB142:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5692              		.loc 1 1801 0
 5693 333c 64169FE5 		ldr	r1, .L556+84
 5694 3340 0400A0E3 		mov	r0, #4
 5695 3344 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 5696              		.loc 1 1802 0
 5697 3348 FA0FA0E3 		mov	r0, #1000
 5698 334c FEFFFFEB 		bl	_tx_thread_sleep
 5699 3350 F9FFFFEA 		b	.L513
 5700              	.L424:
 5701              	.LBE142:
 5702              	.LBE141:
 5703              	.LBB143:
 5704              	.LBB127:
3392:../uvc.c      ****     switch (wValue)
 5705              		.loc 1 3392 0
 5706 3354 060C53E3 		cmp	r3, #1536
 5707 3358 7101000A 		beq	.L410
 5708 335c 0F00008A 		bhi	.L425
 5709 3360 050C53E3 		cmp	r3, #1280
 5710 3364 50FEFF1A 		bne	.L366
 5711              	.LVL447:
3412:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 5712              		.loc 1 3412 0
 5713 3368 1400A0E3 		mov	r0, #20
 5714 336c FEFFFFEB 		bl	ControlHandle
 5715              	.LVL448:
 5716 3370 28309DE5 		ldr	r3, [sp, #40]
 5717 3374 51FEFFEA 		b	.L365
 5718              	.L400:
 5719              	.LBE127:
 5720              	.LBE143:
 5721              	.LBB144:
 5722              	.LBB105:
3167:../uvc.c      ****     switch (wValue)
 5723              		.loc 1 3167 0
 5724 3378 0B0C52E3 		cmp	r2, #2816
 5725 337c 6401000A 		beq	.L396
 5726 3380 030B52E3 		cmp	r2, #3072
 5727 3384 5E01000A 		beq	.L397
 5728 3388 0A0C52E3 		cmp	r2, #2560
 5729 338c 42FEFF1A 		bne	.L386
 5730              	.LVL449:
3208:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 5731              		.loc 1 3208 0
 5732 3390 0800A0E3 		mov	r0, #8
 5733 3394 FEFFFFEB 		bl	CTControlHandle
 5734              	.LVL450:
 5735 3398 28309DE5 		ldr	r3, [sp, #40]
 5736 339c 47FEFFEA 		b	.L365
 5737              	.L425:
 5738              	.LBE105:
 5739              	.LBE144:
 5740              	.LBB145:
 5741              	.LBB123:
3392:../uvc.c      ****     switch (wValue)
 5742              		.loc 1 3392 0
 5743 33a0 070C53E3 		cmp	r3, #1792
 5744 33a4 5201000A 		beq	.L411
 5745 33a8 020B53E3 		cmp	r3, #2048
 5746 33ac 3EFEFF1A 		bne	.L366
 5747              	.LVL451:
3424:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 5748              		.loc 1 3424 0
 5749 33b0 1700A0E3 		mov	r0, #23
 5750 33b4 FEFFFFEB 		bl	ControlHandle
 5751              	.LVL452:
 5752 33b8 28309DE5 		ldr	r3, [sp, #40]
 5753 33bc 3FFEFFEA 		b	.L365
 5754              	.L399:
 5755              	.LBE123:
 5756              	.LBE145:
 5757              	.LBB146:
 5758              	.LBB101:
3167:../uvc.c      ****     switch (wValue)
 5759              		.loc 1 3167 0
 5760 33c0 010B52E3 		cmp	r2, #1024
 5761 33c4 4601000A 		beq	.L390
 5762 33c8 050C52E3 		cmp	r2, #1280
 5763 33cc 32FEFF1A 		bne	.L386
 5764              	.LVL453:
3189:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 5765              		.loc 1 3189 0
 5766 33d0 0400A0E3 		mov	r0, #4
 5767 33d4 FEFFFFEB 		bl	CTControlHandle
 5768              	.LVL454:
 5769 33d8 28309DE5 		ldr	r3, [sp, #40]
 5770 33dc 37FEFFEA 		b	.L365
 5771              	.L385:
 5772              	.LBE101:
 5773              	.LBE146:
 5774              	.LBB147:
 5775              	.LBB92:
3092:../uvc.c      ****     switch (wValue)
 5776              		.loc 1 3092 0
 5777 33e0 0D0C52E3 		cmp	r2, #3328
 5778 33e4 1C00000A 		beq	.L380
 5779 33e8 0E0C52E3 		cmp	r2, #3584
 5780 33ec D700000A 		beq	.L382
 5781 33f0 030B52E3 		cmp	r2, #3072
 5782 33f4 28FEFF1A 		bne	.L386
 5783              	.LVL455:
3133:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 5784              		.loc 1 3133 0
 5785 33f8 0B00A0E3 		mov	r0, #11
 5786 33fc FEFFFFEB 		bl	ControlHandle
 5787              	.LVL456:
 5788 3400 28309DE5 		ldr	r3, [sp, #40]
 5789 3404 2DFEFFEA 		b	.L365
 5790              	.LVL457:
 5791              	.L506:
 5792              	.LBE92:
 5793              	.LBE147:
 5794              	.LBB148:
 5795              	.LBB115:
3778:../uvc.c      ****             	switch (bRequest)
 5796              		.loc 1 3778 0
 5797 3408 850052E3 		cmp	r2, #133
 5798 340c CC00000A 		beq	.L504
 5799 3410 860052E3 		cmp	r2, #134
 5800 3414 2EFEFF1A 		bne	.L431
 5801 3418 7BFFFFEA 		b	.L540
 5802              	.LVL458:
 5803              	.L428:
 5804              	.LBE115:
 5805              	.LBE148:
 5806              	.LBB149:
 5807              	.LBB128:
3392:../uvc.c      ****     switch (wValue)
 5808              		.loc 1 3392 0
 5809 341c 120C53E3 		cmp	r3, #4608
 5810 3420 C300000A 		beq	.L421
 5811 3424 130C53E3 		cmp	r3, #4864
 5812 3428 1FFEFF1A 		bne	.L366
 5813              	.LVL459:
3473:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 5814              		.loc 1 3473 0
 5815 342c 2600A0E3 		mov	r0, #38
 5816 3430 FEFFFFEB 		bl	ControlHandle
 5817              	.LVL460:
 5818 3434 28309DE5 		ldr	r3, [sp, #40]
 5819 3438 20FEFFEA 		b	.L365
 5820              	.L415:
 5821              	.LVL461:
3439:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5822              		.loc 1 3439 0
 5823 343c 1A00A0E3 		mov	r0, #26
 5824 3440 FEFFFFEB 		bl	ControlHandle
 5825              	.LVL462:
 5826 3444 28309DE5 		ldr	r3, [sp, #40]
 5827 3448 1CFEFFEA 		b	.L365
 5828              	.L378:
 5829              	.LVL463:
 5830              	.LBE128:
 5831              	.LBE149:
 5832              	.LBB150:
 5833              	.LBB96:
3119:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 5834              		.loc 1 3119 0
 5835 344c 0600A0E3 		mov	r0, #6
 5836 3450 FEFFFFEB 		bl	ControlHandle
 5837              	.LVL464:
 5838 3454 28309DE5 		ldr	r3, [sp, #40]
 5839 3458 18FEFFEA 		b	.L365
 5840              	.L380:
 5841              	.LVL465:
3129:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 5842              		.loc 1 3129 0
 5843 345c 0900A0E3 		mov	r0, #9
 5844 3460 FEFFFFEB 		bl	ControlHandle
 5845              	.LVL466:
 5846 3464 28309DE5 		ldr	r3, [sp, #40]
 5847 3468 14FEFFEA 		b	.L365
 5848              	.LVL467:
 5849              	.L508:
 5850              	.LBE96:
 5851              	.LBE150:
 5852              	.LBB151:
 5853              	.LBB111:
3821:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5854              		.loc 1 3821 0
 5855 346c 38159FE5 		ldr	r1, .L556+88
 5856 3470 BE22DDE1 		ldrh	r2, [sp, #46]
 5857 3474 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 5858 3478 0400A0E3 		mov	r0, #4
 5859              	.LVL468:
 5860 347c FEFFFFEB 		bl	CyU3PDebugPrint
 5861 3480 13FEFFEA 		b	.L431
 5862              	.LVL469:
 5863              	.L551:
3583:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5864              		.loc 1 3583 0
 5865 3484 2000A0E3 		mov	r0, #32
 5866 3488 F0149FE5 		ldr	r1, .L556+44
 5867 348c 2E208DE2 		add	r2, sp, #46
 5868 3490 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5869              	.LVL470:
3585:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5870              		.loc 1 3585 0
 5871 3494 000050E3 		cmp	r0, #0
 5872 3498 11FEFF1A 		bne	.L535
3587:../uvc.c      ****                         switch (glCommitCtrl[3])
 5873              		.loc 1 3587 0
 5874 349c 8320D4E5 		ldrb	r2, [r4, #131]	@ zero_extendqisi2
 5875 34a0 011042E2 		sub	r1, r2, #1
 5876 34a4 030051E3 		cmp	r1, #3
 5877 34a8 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 5878 34ac 2E0000EA 		b	.L455
 5879              	.L460:
 5880 34b0 0C360000 		.word	.L456
 5881 34b4 58360000 		.word	.L457
 5882 34b8 B0350000 		.word	.L458
 5883 34bc 14350000 		.word	.L459
 5884              	.LVL471:
 5885              	.L503:
3790:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 5886              		.loc 1 3790 0
 5887 34c0 4810D4E5 		ldrb	r1, [r4, #72]	@ zero_extendqisi2
 5888 34c4 030051E3 		cmp	r1, #3
 5889 34c8 0400000A 		beq	.L555
 5890              	.L507:
3796:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5891              		.loc 1 3796 0
 5892 34cc 1A00A0E3 		mov	r0, #26
 5893 34d0 D8149FE5 		ldr	r1, .L556+92
 5894 34d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5895 34d8 28309DE5 		ldr	r3, [sp, #40]
 5896 34dc 01FEFFEA 		b	.L429
 5897              	.L555:
3792:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 5898              		.loc 1 3792 0
 5899 34e0 1A00A0E3 		mov	r0, #26
 5900 34e4 C8149FE5 		ldr	r1, .L556+96
 5901 34e8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5902 34ec 28309DE5 		ldr	r3, [sp, #40]
 5903 34f0 FCFDFFEA 		b	.L429
 5904              	.LVL472:
 5905              	.L407:
 5906              	.LBE111:
 5907              	.LBE151:
 5908              	.LBB152:
 5909              	.LBB122:
3404:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5910              		.loc 1 3404 0
 5911 34f4 1200A0E3 		mov	r0, #18
 5912 34f8 FEFFFFEB 		bl	ControlHandle
 5913              	.LVL473:
 5914 34fc 28309DE5 		ldr	r3, [sp, #40]
 5915 3500 EEFDFFEA 		b	.L365
 5916              	.L406:
 5917              	.LVL474:
3400:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5918              		.loc 1 3400 0
 5919 3504 1100A0E3 		mov	r0, #17
 5920 3508 FEFFFFEB 		bl	ControlHandle
 5921              	.LVL475:
 5922 350c 28309DE5 		ldr	r3, [sp, #40]
 5923 3510 EAFDFFEA 		b	.L365
 5924              	.LVL476:
 5925              	.L459:
 5926              	.LBE122:
 5927              	.LBE152:
 5928              	.LBB153:
 5929              	.LBB116:
3605:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 5930              		.loc 1 3605 0
 5931 3514 58C094E5 		ldr	ip, [r4, #88]
 5932 3518 8C04D5E5 		ldrb	r0, [r5, #1164]	@ zero_extendqisi2
 5933              	.LVL477:
 5934 351c 00005CE3 		cmp	ip, #0
 5935 3520 F4C0A003 		moveq	ip, #244
 5936 3524 74C0A013 		movne	ip, #116
 5937 3528 00208CE1 		orr	r2, ip, r0
 5938 352c 3010A0E3 		mov	r1, #48
 5939 3530 5230A0E3 		mov	r3, #82
 5940 3534 0100A0E3 		mov	r0, #1
 5941 3538 FEFFFFEB 		bl	SensorSetIrisControl
3606:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5942              		.loc 1 3606 0
 5943 353c 7D0FA0E3 		mov	r0, #500
 5944 3540 FEFFFFEB 		bl	_tx_thread_sleep
3607:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 5945              		.loc 1 3607 0
 5946 3544 582094E5 		ldr	r2, [r4, #88]
 5947 3548 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 5948 354c 000052E3 		cmp	r2, #0
 5949 3550 F420A003 		moveq	r2, #244
 5950 3554 7420A013 		movne	r2, #116
 5951 3558 583094E5 		ldr	r3, [r4, #88]
 5952 355c 0400A0E3 		mov	r0, #4
 5953 3560 50149FE5 		ldr	r1, .L556+100
 5954 3564 092082E1 		orr	r2, r2, r9
 5955 3568 FEFFFFEB 		bl	CyU3PDebugPrint
 5956              	.L455:
3612:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5957              		.loc 1 3612 0
 5958 356c 83E0D4E5 		ldrb	lr, [r4, #131]	@ zero_extendqisi2
3613:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5959              		.loc 1 3613 0
 5960 3570 44149FE5 		ldr	r1, .L556+104
 5961 3574 0E20A0E1 		mov	r2, lr
 5962 3578 0400A0E3 		mov	r0, #4
3612:../uvc.c      ****                         setRes = glCommitCtrl[3];
 5963              		.loc 1 3612 0
 5964 357c 7DE0C4E5 		strb	lr, [r4, #125]
3613:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 5965              		.loc 1 3613 0
 5966 3580 FEFFFFEB 		bl	CyU3PDebugPrint
3626:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5967              		.loc 1 3626 0
 5968 3584 0020A0E3 		mov	r2, #0
 5969 3588 C4039FE5 		ldr	r0, .L556
 5970 358c 0110A0E3 		mov	r1, #1
 5971 3590 FEFFFFEB 		bl	_txe_event_flags_set
 5972              	.LVL478:
3627:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5973              		.loc 1 3627 0
 5974 3594 002050E2 		subs	r2, r0, #0
 5975 3598 D1FDFF0A 		beq	.L535
3629:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 5976              		.loc 1 3629 0
 5977 359c 0400A0E3 		mov	r0, #4
 5978              	.LVL479:
 5979 35a0 18149FE5 		ldr	r1, .L556+108
 5980 35a4 FEFFFFEB 		bl	CyU3PDebugPrint
 5981              	.LVL480:
 5982 35a8 28309DE5 		ldr	r3, [sp, #40]
 5983 35ac CDFDFFEA 		b	.L429
 5984              	.LVL481:
 5985              	.L458:
3600:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 5986              		.loc 1 3600 0
 5987 35b0 58E094E5 		ldr	lr, [r4, #88]
 5988 35b4 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 5989 35b8 00005EE3 		cmp	lr, #0
 5990 35bc C4E0A003 		moveq	lr, #196
 5991 35c0 44E0A013 		movne	lr, #68
 5992 35c4 03208EE1 		orr	r2, lr, r3
 5993 35c8 3010A0E3 		mov	r1, #48
 5994 35cc 5230A0E3 		mov	r3, #82
 5995 35d0 0100A0E3 		mov	r0, #1
 5996              	.LVL482:
 5997 35d4 FEFFFFEB 		bl	SensorSetIrisControl
3601:../uvc.c      ****                          		CyU3PThreadSleep(500);
 5998              		.loc 1 3601 0
 5999 35d8 7D0FA0E3 		mov	r0, #500
 6000 35dc FEFFFFEB 		bl	_tx_thread_sleep
3602:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6001              		.loc 1 3602 0
 6002 35e0 580094E5 		ldr	r0, [r4, #88]
 6003 35e4 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6004 35e8 000050E3 		cmp	r0, #0
 6005 35ec C400A003 		moveq	r0, #196
 6006 35f0 4400A013 		movne	r0, #68
 6007 35f4 0C2080E1 		orr	r2, r0, ip
 6008 35f8 583094E5 		ldr	r3, [r4, #88]
 6009 35fc B4139FE5 		ldr	r1, .L556+100
 6010 3600 0400A0E3 		mov	r0, #4
 6011 3604 FEFFFFEB 		bl	CyU3PDebugPrint
 6012 3608 D7FFFFEA 		b	.L455
 6013              	.LVL483:
 6014              	.L456:
3590:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6015              		.loc 1 3590 0
 6016 360c 582094E5 		ldr	r2, [r4, #88]
 6017 3610 3010A0E3 		mov	r1, #48
 6018 3614 000052E3 		cmp	r2, #0
 6019 3618 E420A003 		moveq	r2, #228
 6020 361c 6420A013 		movne	r2, #100
 6021 3620 5230A0E3 		mov	r3, #82
 6022 3624 0100A0E3 		mov	r0, #1
 6023              	.LVL484:
 6024 3628 FEFFFFEB 		bl	SensorSetIrisControl
3591:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6025              		.loc 1 3591 0
 6026 362c 7D0FA0E3 		mov	r0, #500
 6027 3630 FEFFFFEB 		bl	_tx_thread_sleep
3592:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6028              		.loc 1 3592 0
 6029 3634 582094E5 		ldr	r2, [r4, #88]
 6030 3638 78139FE5 		ldr	r1, .L556+100
 6031 363c 000052E3 		cmp	r2, #0
 6032 3640 583094E5 		ldr	r3, [r4, #88]
 6033 3644 E420A003 		moveq	r2, #228
 6034 3648 6420A013 		movne	r2, #100
 6035 364c 0400A0E3 		mov	r0, #4
 6036 3650 FEFFFFEB 		bl	CyU3PDebugPrint
 6037 3654 C4FFFFEA 		b	.L455
 6038              	.LVL485:
 6039              	.L457:
3595:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6040              		.loc 1 3595 0
 6041 3658 582094E5 		ldr	r2, [r4, #88]
 6042 365c 3010A0E3 		mov	r1, #48
 6043 3660 000052E3 		cmp	r2, #0
 6044 3664 D420A003 		moveq	r2, #212
 6045 3668 5420A013 		movne	r2, #84
 6046 366c 5230A0E3 		mov	r3, #82
 6047 3670 0100A0E3 		mov	r0, #1
 6048              	.LVL486:
 6049 3674 FEFFFFEB 		bl	SensorSetIrisControl
3596:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6050              		.loc 1 3596 0
 6051 3678 7D0FA0E3 		mov	r0, #500
 6052 367c FEFFFFEB 		bl	_tx_thread_sleep
3597:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6053              		.loc 1 3597 0
 6054 3680 582094E5 		ldr	r2, [r4, #88]
 6055 3684 2C139FE5 		ldr	r1, .L556+100
 6056 3688 000052E3 		cmp	r2, #0
 6057 368c 583094E5 		ldr	r3, [r4, #88]
 6058 3690 D420A003 		moveq	r2, #212
 6059 3694 5420A013 		movne	r2, #84
 6060 3698 0400A0E3 		mov	r0, #4
 6061 369c FEFFFFEB 		bl	CyU3PDebugPrint
 6062 36a0 B1FFFFEA 		b	.L455
 6063              	.L418:
 6064              	.LVL487:
 6065              	.LBE116:
 6066              	.LBE153:
 6067              	.LBB154:
 6068              	.LBB129:
3457:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 6069              		.loc 1 3457 0
 6070 36a4 1E00A0E3 		mov	r0, #30
 6071 36a8 FEFFFFEB 		bl	ControlHandle
 6072              	.LVL488:
 6073 36ac 28309DE5 		ldr	r3, [sp, #40]
 6074 36b0 82FDFFEA 		b	.L365
 6075              	.L393:
 6076              	.LVL489:
 6077              	.LBE129:
 6078              	.LBE154:
 6079              	.LBB155:
 6080              	.LBB106:
3197:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 6081              		.loc 1 3197 0
 6082 36b4 0600A0E3 		mov	r0, #6
 6083 36b8 FEFFFFEB 		bl	CTControlHandle
 6084              	.LVL490:
 6085 36bc 28309DE5 		ldr	r3, [sp, #40]
 6086 36c0 7EFDFFEA 		b	.L365
 6087              	.L394:
 6088              	.LVL491:
3203:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 6089              		.loc 1 3203 0
 6090 36c4 0700A0E3 		mov	r0, #7
 6091 36c8 FEFFFFEB 		bl	CTControlHandle
 6092              	.LVL492:
 6093 36cc 28309DE5 		ldr	r3, [sp, #40]
 6094 36d0 7AFDFFEA 		b	.L365
 6095              	.L375:
 6096              	.LVL493:
 6097              	.LBE106:
 6098              	.LBE155:
 6099              	.LBB156:
 6100              	.LBB91:
3104:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 6101              		.loc 1 3104 0
 6102 36d4 0200A0E3 		mov	r0, #2
 6103 36d8 FEFFFFEB 		bl	ControlHandle
 6104              	.LVL494:
 6105 36dc 28309DE5 		ldr	r3, [sp, #40]
 6106 36e0 76FDFFEA 		b	.L365
 6107              	.L377:
 6108              	.LVL495:
3115:../uvc.c      ****      		ControlHandle(HueCtlID5);
 6109              		.loc 1 3115 0
 6110 36e4 0500A0E3 		mov	r0, #5
 6111 36e8 FEFFFFEB 		bl	ControlHandle
 6112              	.LVL496:
 6113 36ec 28309DE5 		ldr	r3, [sp, #40]
 6114 36f0 72FDFFEA 		b	.L365
 6115              	.L408:
 6116              	.LVL497:
 6117              	.LBE91:
 6118              	.LBE156:
 6119              	.LBB157:
 6120              	.LBB121:
3408:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 6121              		.loc 1 3408 0
 6122 36f4 1300A0E3 		mov	r0, #19
 6123 36f8 FEFFFFEB 		bl	ControlHandle
 6124              	.LVL498:
 6125 36fc 28309DE5 		ldr	r3, [sp, #40]
 6126 3700 6EFDFFEA 		b	.L365
 6127              	.L413:
 6128              	.LVL499:
3428:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6129              		.loc 1 3428 0
 6130 3704 1800A0E3 		mov	r0, #24
 6131 3708 FEFFFFEB 		bl	ControlHandle
 6132              	.LVL500:
 6133 370c 28309DE5 		ldr	r3, [sp, #40]
 6134 3710 6AFDFFEA 		b	.L365
 6135              	.L387:
 6136              	.LVL501:
 6137              	.LBE121:
 6138              	.LBE157:
 6139              	.LBB158:
 6140              	.LBB100:
3171:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 6141              		.loc 1 3171 0
 6142 3714 0000A0E3 		mov	r0, #0
 6143 3718 FEFFFFEB 		bl	CTControlHandle
 6144              	.LVL502:
 6145 371c 28309DE5 		ldr	r3, [sp, #40]
 6146 3720 66FDFFEA 		b	.L365
 6147              	.L389:
 6148              	.LVL503:
3179:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 6149              		.loc 1 3179 0
 6150 3724 0200A0E3 		mov	r0, #2
 6151 3728 FEFFFFEB 		bl	CTControlHandle
 6152              	.LVL504:
 6153 372c 28309DE5 		ldr	r3, [sp, #40]
 6154 3730 62FDFFEA 		b	.L365
 6155              	.L421:
 6156              	.LVL505:
 6157              	.LBE100:
 6158              	.LBE158:
 6159              	.LBB159:
 6160              	.LBB130:
3469:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6161              		.loc 1 3469 0
 6162 3734 2500A0E3 		mov	r0, #37
 6163 3738 FEFFFFEB 		bl	ControlHandle
 6164              	.LVL506:
 6165 373c 28309DE5 		ldr	r3, [sp, #40]
 6166 3740 5EFDFFEA 		b	.L365
 6167              	.LVL507:
 6168              	.L504:
 6169              	.LBE130:
 6170              	.LBE159:
 6171              	.LBB160:
 6172              	.LBB110:
3787:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6173              		.loc 1 3787 0
 6174 3744 0200A0E3 		mov	r0, #2
 6175 3748 44129FE5 		ldr	r1, .L556+64
 6176 374c 97FEFFEA 		b	.L536
 6177              	.LVL508:
 6178              	.L382:
 6179              	.LBE110:
 6180              	.LBE160:
 6181              	.LBB161:
 6182              	.LBB97:
3137:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 6183              		.loc 1 3137 0
 6184 3750 0E00A0E3 		mov	r0, #14
 6185 3754 FEFFFFEB 		bl	ControlHandle
 6186              	.LVL509:
 6187 3758 28309DE5 		ldr	r3, [sp, #40]
 6188 375c 57FDFFEA 		b	.L365
 6189              	.L547:
 6190              	.LVL510:
3100:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 6191              		.loc 1 3100 0
 6192 3760 0100A0E3 		mov	r0, #1
 6193 3764 FEFFFFEB 		bl	ControlHandle
 6194              	.LVL511:
 6195 3768 28309DE5 		ldr	r3, [sp, #40]
 6196 376c 53FDFFEA 		b	.L365
 6197              	.L373:
 6198              	.LVL512:
3096:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 6199              		.loc 1 3096 0
 6200 3770 0000A0E3 		mov	r0, #0
 6201 3774 FEFFFFEB 		bl	ControlHandle
 6202              	.LVL513:
 6203 3778 28309DE5 		ldr	r3, [sp, #40]
 6204 377c 4FFDFFEA 		b	.L365
 6205              	.L392:
 6206              	.LVL514:
 6207              	.LBE97:
 6208              	.LBE161:
 6209              	.LBB162:
 6210              	.LBB107:
3193:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 6211              		.loc 1 3193 0
 6212 3780 0500A0E3 		mov	r0, #5
 6213 3784 FEFFFFEB 		bl	CTControlHandle
 6214              	.LVL515:
 6215 3788 28309DE5 		ldr	r3, [sp, #40]
 6216 378c 4BFDFFEA 		b	.L365
 6217              	.LVL516:
 6218              	.L491:
 6219              	.LBE107:
 6220              	.LBE162:
 6221              	.LBB163:
 6222              	.LBB117:
3741:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6223              		.loc 1 3741 0
 6224 3790 582094E5 		ldr	r2, [r4, #88]
 6225 3794 3010A0E3 		mov	r1, #48
 6226 3798 000052E3 		cmp	r2, #0
 6227 379c E420A003 		moveq	r2, #228
 6228 37a0 6420A013 		movne	r2, #100
 6229 37a4 5230A0E3 		mov	r3, #82
 6230 37a8 0100A0E3 		mov	r0, #1
 6231              	.LVL517:
 6232 37ac FEFFFFEB 		bl	SensorSetIrisControl
3743:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6233              		.loc 1 3743 0
 6234 37b0 582094E5 		ldr	r2, [r4, #88]
 6235 37b4 08129FE5 		ldr	r1, .L556+112
 6236 37b8 000052E3 		cmp	r2, #0
 6237 37bc 583094E5 		ldr	r3, [r4, #88]
 6238 37c0 E420A003 		moveq	r2, #228
 6239 37c4 6420A013 		movne	r2, #100
 6240 37c8 0400A0E3 		mov	r0, #4
 6241 37cc FEFFFFEB 		bl	CyU3PDebugPrint
 6242              	.L487:
3763:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6243              		.loc 1 3763 0
 6244 37d0 81E0D4E5 		ldrb	lr, [r4, #129]	@ zero_extendqisi2
3765:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6245              		.loc 1 3765 0
 6246 37d4 8030D4E5 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 6247 37d8 BE22DDE1 		ldrh	r2, [sp, #46]
 6248              	.LVL518:
 6249 37dc 0400A0E3 		mov	r0, #4
 6250 37e0 E0119FE5 		ldr	r1, .L556+116
3763:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6251              		.loc 1 3763 0
 6252 37e4 A0E0C4E5 		strb	lr, [r4, #160]
3765:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6253              		.loc 1 3765 0
 6254 37e8 00E08DE5 		str	lr, [sp, #0]
 6255 37ec FEFFFFEB 		bl	CyU3PDebugPrint
 6256 37f0 28309DE5 		ldr	r3, [sp, #40]
 6257 37f4 3BFDFFEA 		b	.L429
 6258              	.LVL519:
 6259              	.L490:
3746:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6260              		.loc 1 3746 0
 6261 37f8 582094E5 		ldr	r2, [r4, #88]
 6262 37fc 3010A0E3 		mov	r1, #48
 6263 3800 000052E3 		cmp	r2, #0
 6264 3804 D420A003 		moveq	r2, #212
 6265 3808 5420A013 		movne	r2, #84
 6266 380c 5230A0E3 		mov	r3, #82
 6267 3810 0100A0E3 		mov	r0, #1
 6268              	.LVL520:
 6269 3814 FEFFFFEB 		bl	SensorSetIrisControl
3748:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6270              		.loc 1 3748 0
 6271 3818 582094E5 		ldr	r2, [r4, #88]
 6272 381c A0119FE5 		ldr	r1, .L556+112
 6273 3820 000052E3 		cmp	r2, #0
 6274 3824 583094E5 		ldr	r3, [r4, #88]
 6275 3828 D420A003 		moveq	r2, #212
 6276 382c 5420A013 		movne	r2, #84
 6277 3830 0400A0E3 		mov	r0, #4
 6278 3834 FEFFFFEB 		bl	CyU3PDebugPrint
 6279 3838 E4FFFFEA 		b	.L487
 6280              	.LVL521:
 6281              	.L488:
3756:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6282              		.loc 1 3756 0
 6283 383c 580094E5 		ldr	r0, [r4, #88]
 6284              	.LVL522:
 6285 3840 8C34D5E5 		ldrb	r3, [r5, #1164]	@ zero_extendqisi2
 6286 3844 000050E3 		cmp	r0, #0
 6287 3848 F400A003 		moveq	r0, #244
 6288 384c 7400A013 		movne	r0, #116
 6289 3850 032080E1 		orr	r2, r0, r3
 6290 3854 3010A0E3 		mov	r1, #48
 6291 3858 5230A0E3 		mov	r3, #82
 6292 385c 0100A0E3 		mov	r0, #1
 6293 3860 FEFFFFEB 		bl	SensorSetIrisControl
3758:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6294              		.loc 1 3758 0
 6295 3864 58C094E5 		ldr	ip, [r4, #88]
 6296 3868 8C24D5E5 		ldrb	r2, [r5, #1164]	@ zero_extendqisi2
 6297 386c 00005CE3 		cmp	ip, #0
 6298 3870 F4C0A003 		moveq	ip, #244
 6299 3874 74C0A013 		movne	ip, #116
 6300 3878 583094E5 		ldr	r3, [r4, #88]
 6301 387c 40119FE5 		ldr	r1, .L556+112
 6302 3880 02208CE1 		orr	r2, ip, r2
 6303 3884 0400A0E3 		mov	r0, #4
 6304 3888 FEFFFFEB 		bl	CyU3PDebugPrint
 6305 388c CFFFFFEA 		b	.L487
 6306              	.LVL523:
 6307              	.L489:
3751:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6308              		.loc 1 3751 0
 6309 3890 58E094E5 		ldr	lr, [r4, #88]
 6310 3894 8C94D5E5 		ldrb	r9, [r5, #1164]	@ zero_extendqisi2
 6311 3898 00005EE3 		cmp	lr, #0
 6312 389c C4E0A003 		moveq	lr, #196
 6313 38a0 44E0A013 		movne	lr, #68
 6314 38a4 09208EE1 		orr	r2, lr, r9
 6315 38a8 3010A0E3 		mov	r1, #48
 6316 38ac 5230A0E3 		mov	r3, #82
 6317 38b0 0100A0E3 		mov	r0, #1
 6318              	.LVL524:
 6319 38b4 FEFFFFEB 		bl	SensorSetIrisControl
3753:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6320              		.loc 1 3753 0
 6321 38b8 580094E5 		ldr	r0, [r4, #88]
 6322 38bc 8CC4D5E5 		ldrb	ip, [r5, #1164]	@ zero_extendqisi2
 6323 38c0 000050E3 		cmp	r0, #0
 6324 38c4 C400A003 		moveq	r0, #196
 6325 38c8 4400A013 		movne	r0, #68
 6326 38cc 0C2080E1 		orr	r2, r0, ip
 6327 38d0 583094E5 		ldr	r3, [r4, #88]
 6328 38d4 E8109FE5 		ldr	r1, .L556+112
 6329 38d8 0400A0E3 		mov	r0, #4
 6330 38dc FEFFFFEB 		bl	CyU3PDebugPrint
 6331 38e0 BAFFFFEA 		b	.L487
 6332              	.L390:
 6333              	.LVL525:
 6334              	.LBE117:
 6335              	.LBE163:
 6336              	.LBB164:
 6337              	.LBB99:
3184:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 6338              		.loc 1 3184 0
 6339 38e4 0300A0E3 		mov	r0, #3
 6340 38e8 FEFFFFEB 		bl	CTControlHandle
 6341              	.LVL526:
 6342 38ec 28309DE5 		ldr	r3, [sp, #40]
 6343 38f0 F2FCFFEA 		b	.L365
 6344              	.L411:
 6345              	.LVL527:
 6346              	.LBE99:
 6347              	.LBE164:
 6348              	.LBB165:
 6349              	.LBB120:
3420:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 6350              		.loc 1 3420 0
 6351 38f4 1600A0E3 		mov	r0, #22
 6352 38f8 FEFFFFEB 		bl	ControlHandle
 6353              	.LVL528:
 6354 38fc 28309DE5 		ldr	r3, [sp, #40]
 6355 3900 EEFCFFEA 		b	.L365
 6356              	.L397:
 6357              	.LVL529:
 6358              	.LBE120:
 6359              	.LBE165:
 6360              	.LBB166:
 6361              	.LBB108:
3216:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 6362              		.loc 1 3216 0
 6363 3904 0A00A0E3 		mov	r0, #10
 6364 3908 FEFFFFEB 		bl	CTControlHandle
 6365              	.LVL530:
 6366 390c 28309DE5 		ldr	r3, [sp, #40]
 6367 3910 EAFCFFEA 		b	.L365
 6368              	.L396:
 6369              	.LVL531:
3212:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 6370              		.loc 1 3212 0
 6371 3914 0900A0E3 		mov	r0, #9
 6372 3918 FEFFFFEB 		bl	CTControlHandle
 6373              	.LVL532:
 6374 391c 28309DE5 		ldr	r3, [sp, #40]
 6375 3920 E6FCFFEA 		b	.L365
 6376              	.L410:
 6377              	.LVL533:
 6378              	.LBE108:
 6379              	.LBE166:
 6380              	.LBB167:
 6381              	.LBB131:
3416:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 6382              		.loc 1 3416 0
 6383 3924 1500A0E3 		mov	r0, #21
 6384 3928 FEFFFFEB 		bl	ControlHandle
 6385              	.LVL534:
 6386 392c 28309DE5 		ldr	r3, [sp, #40]
 6387 3930 E2FCFFEA 		b	.L365
 6388              	.L420:
 6389              	.LVL535:
3465:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 6390              		.loc 1 3465 0
 6391 3934 2400A0E3 		mov	r0, #36
 6392 3938 FEFFFFEB 		bl	ControlHandle
 6393              	.LVL536:
 6394 393c 28309DE5 		ldr	r3, [sp, #40]
 6395 3940 DEFCFFEA 		b	.L365
 6396              	.L416:
 6397              	.LVL537:
3443:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 6398              		.loc 1 3443 0
 6399 3944 1B00A0E3 		mov	r0, #27
 6400 3948 FEFFFFEB 		bl	ControlHandle
 6401              	.LVL538:
 6402 394c 28309DE5 		ldr	r3, [sp, #40]
 6403 3950 DAFCFFEA 		b	.L365
 6404              	.L557:
 6405              		.align	2
 6406              	.L556:
 6407 3954 00000000 		.word	.LANCHOR0
 6408 3958 00000000 		.word	.LANCHOR1
 6409 395c 00000000 		.word	bRequest
 6410 3960 00000000 		.word	wValue
 6411 3964 00000000 		.word	wIndex
 6412 3968 00000000 		.word	glInterStaBuffer
 6413 396c E4050000 		.word	.LC32
 6414 3970 00000000 		.word	glChHandleInterStat
 6415 3974 00000000 		.word	bmReqType
 6416 3978 00000000 		.word	wLength
 6417 397c 68050000 		.word	.LC31
 6418 3980 80000000 		.word	.LANCHOR0+128
 6419 3984 24070000 		.word	.LC40
 6420 3988 48070000 		.word	.LC41
 6421 398c A0060000 		.word	.LANCHOR1+1696
 6422 3990 10060000 		.word	.LC33
 6423 3994 5C000000 		.word	.LANCHOR0+92
 6424 3998 F4060000 		.word	.LANCHOR1+1780
 6425 399c 00070000 		.word	.LANCHOR1+1792
 6426 39a0 AC060000 		.word	.LC37
 6427 39a4 9C070000 		.word	.LC43
 6428 39a8 F0010000 		.word	.LC13
 6429 39ac 74070000 		.word	.LC42
 6430 39b0 BC060000 		.word	.LANCHOR1+1724
 6431 39b4 D8060000 		.word	.LANCHOR1+1752
 6432 39b8 38060000 		.word	.LC34
 6433 39bc 5C060000 		.word	.LC35
 6434 39c0 84060000 		.word	.LC36
 6435 39c4 D8060000 		.word	.LC38
 6436 39c8 FC060000 		.word	.LC39
 6437              	.LBE131:
 6438              	.LBE167:
 6439              		.cfi_endproc
 6440              	.LFE25:
 6442              		.align	2
 6443              		.global	CamDefSet
 6445              	CamDefSet:
 6446              	.LFB5:
1694:../uvc.c      **** {
 6447              		.loc 1 1694 0
 6448              		.cfi_startproc
 6449              		@ args = 0, pretend = 0, frame = 24
 6450              		@ frame_needed = 0, uses_anonymous_args = 0
 6451              	.LVL539:
 6452 39cc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 6453              	.LCFI22:
 6454              		.cfi_def_cfa_offset 36
1701:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6455              		.loc 1 1701 0
 6456 39d0 B0429FE5 		ldr	r4, .L561
 6457              		.cfi_offset 14, -4
 6458              		.cfi_offset 11, -8
 6459              		.cfi_offset 10, -12
 6460              		.cfi_offset 9, -16
 6461              		.cfi_offset 8, -20
 6462              		.cfi_offset 7, -24
 6463              		.cfi_offset 6, -28
 6464              		.cfi_offset 5, -32
 6465              		.cfi_offset 4, -36
1706:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6466              		.loc 1 1706 0
 6467 39d4 B0229FE5 		ldr	r2, .L561+4
1703:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 6468              		.loc 1 1703 0
 6469 39d8 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1694:../uvc.c      **** {
 6470              		.loc 1 1694 0
 6471 39dc 2CD04DE2 		sub	sp, sp, #44
 6472              	.LCFI23:
 6473              		.cfi_def_cfa_offset 80
1706:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6474              		.loc 1 1706 0
 6475 39e0 1C0092E5 		ldr	r0, [r2, #28]
 6476 39e4 0010E0E3 		mvn	r1, #0
1708:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6477              		.loc 1 1708 0
 6478 39e8 2963A0E1 		mov	r6, r9, lsr #6
1702:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6479              		.loc 1 1702 0
 6480 39ec A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1701:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 6481              		.loc 1 1701 0
 6482 39f0 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 6483              	.LVL540:
1706:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 6484              		.loc 1 1706 0
 6485 39f4 FEFFFFEB 		bl	_txe_mutex_get
1707:../uvc.c      ****     if(Data1&0x80){
 6486              		.loc 1 1707 0
 6487 39f8 800019E3 		tst	r9, #128
1708:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 6488              		.loc 1 1708 0
 6489 39fc 01600612 		andne	r6, r6, #1
 6490 3a00 0660E011 		mvnne	r6, r6
 6491 3a04 3B600612 		andne	r6, r6, #59
 6492 3a08 0660E011 		mvnne	r6, r6
 6493 3a0c FF600612 		andne	r6, r6, #255
 6494              	.LVL541:
1710:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 6495              		.loc 1 1710 0
 6496 3a10 C6608603 		orreq	r6, r6, #198
 6497              	.LVL542:
1714:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6498              		.loc 1 1714 0
 6499 3a14 0080A0E3 		mov	r8, #0
 6500 3a18 0A20A0E1 		mov	r2, sl
 6501 3a1c 0730A0E1 		mov	r3, r7
 6502 3a20 0110A0E3 		mov	r1, #1
1712:../uvc.c      ****     Data0 = (Data0 << 2);
 6503              		.loc 1 1712 0
 6504 3a24 0951A0E1 		mov	r5, r9, asl #2
1714:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6505              		.loc 1 1714 0
 6506 3a28 5C029FE5 		ldr	r0, .L561+4
1717:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6507              		.loc 1 1717 0
 6508 3a2c 0190A0E3 		mov	r9, #1
 6509              	.LVL543:
1712:../uvc.c      ****     Data0 = (Data0 << 2);
 6510              		.loc 1 1712 0
 6511 3a30 FF5005E2 		and	r5, r5, #255
 6512              	.LVL544:
1714:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 6513              		.loc 1 1714 0
 6514 3a34 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6515 3a38 FEFFFFEB 		bl	cmdSet
 6516              	.LVL545:
1717:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 6517              		.loc 1 1717 0
 6518 3a3c 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 6519 3a40 0910A0E1 		mov	r1, r9
 6520 3a44 0730A0E1 		mov	r3, r7
 6521 3a48 3C029FE5 		ldr	r0, .L561+4
 6522 3a4c 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 6523 3a50 FEFFFFEB 		bl	cmdSet
 6524              	.LVL546:
1720:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6525              		.loc 1 1720 0
 6526 3a54 0620A0E1 		mov	r2, r6
 6527 3a58 0530A0E1 		mov	r3, r5
 6528 3a5c 2C129FE5 		ldr	r1, .L561+8
 6529 3a60 0400A0E3 		mov	r0, #4
1719:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6530              		.loc 1 1719 0
 6531 3a64 A661C4E5 		strb	r6, [r4, #422]
1718:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6532              		.loc 1 1718 0
 6533 3a68 A551C4E5 		strb	r5, [r4, #421]
1720:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6534              		.loc 1 1720 0
 6535 3a6c FEFFFFEB 		bl	CyU3PDebugPrint
 6536              	.LVL547:
1725:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6537              		.loc 1 1725 0
 6538 3a70 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 6539              	.LVL548:
1726:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6540              		.loc 1 1726 0
 6541 3a74 B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 6542 3a78 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 6543 3a7c 0210A0E3 		mov	r1, #2
 6544 3a80 04029FE5 		ldr	r0, .L561+4
 6545 3a84 00B08DE5 		str	fp, [sp, #0]
 6546 3a88 04808DE5 		str	r8, [sp, #4]
 6547 3a8c FEFFFFEB 		bl	cmdSet
 6548              	.LVL549:
1729:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6549              		.loc 1 1729 0
 6550 3a90 0B20A0E1 		mov	r2, fp
 6551 3a94 0530A0E1 		mov	r3, r5
 6552 3a98 F0119FE5 		ldr	r1, .L561+8
 6553 3a9c 0400A0E3 		mov	r0, #4
1727:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6554              		.loc 1 1727 0
 6555 3aa0 BD51C4E5 		strb	r5, [r4, #445]
1728:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 6556              		.loc 1 1728 0
 6557 3aa4 FD53C4E5 		strb	r5, [r4, #1021]
1729:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6558              		.loc 1 1729 0
 6559 3aa8 FEFFFFEB 		bl	CyU3PDebugPrint
 6560              	.LVL550:
1734:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6561              		.loc 1 1734 0
 6562 3aac 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1733:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6563              		.loc 1 1733 0
 6564 3ab0 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 6565              	.LVL551:
1735:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6566              		.loc 1 1735 0
 6567 3ab4 80B047E2 		sub	fp, r7, #128
 6568 3ab8 FF100BE2 		and	r1, fp, #255
 6569 3abc 14108DE5 		str	r1, [sp, #20]
 6570 3ac0 14C09DE5 		ldr	ip, [sp, #20]
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6571              		.loc 1 1736 0
 6572 3ac4 760047E2 		sub	r0, r7, #118
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6573              		.loc 1 1737 0
 6574 3ac8 7EE087E2 		add	lr, r7, #126
1735:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6575              		.loc 1 1735 0
 6576 3acc 0630A0E1 		mov	r3, r6
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6577              		.loc 1 1736 0
 6578 3ad0 18008DE5 		str	r0, [sp, #24]
1735:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6579              		.loc 1 1735 0
 6580 3ad4 0510A0E3 		mov	r1, #5
 6581 3ad8 DF20A0E3 		mov	r2, #223
 6582 3adc A8019FE5 		ldr	r0, .L561+4
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6583              		.loc 1 1737 0
 6584 3ae0 1CE08DE5 		str	lr, [sp, #28]
1735:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6585              		.loc 1 1735 0
 6586 3ae4 00C08DE5 		str	ip, [sp, #0]
 6587 3ae8 04808DE5 		str	r8, [sp, #4]
 6588 3aec FEFFFFEB 		bl	cmdSet
 6589              	.LVL552:
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6590              		.loc 1 1736 0
 6591 3af0 18A09DE5 		ldr	sl, [sp, #24]
1738:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6592              		.loc 1 1738 0
 6593 3af4 72E087E2 		add	lr, r7, #114
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6594              		.loc 1 1736 0
 6595 3af8 FFC00AE2 		and	ip, sl, #255
 6596 3afc 0630A0E1 		mov	r3, r6
 6597 3b00 0510A0E3 		mov	r1, #5
 6598 3b04 DC20A0E3 		mov	r2, #220
 6599 3b08 7C019FE5 		ldr	r0, .L561+4
1738:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6600              		.loc 1 1738 0
 6601 3b0c 20E08DE5 		str	lr, [sp, #32]
1736:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6602              		.loc 1 1736 0
 6603 3b10 00C08DE5 		str	ip, [sp, #0]
 6604 3b14 04908DE5 		str	r9, [sp, #4]
 6605 3b18 FEFFFFEB 		bl	cmdSet
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6606              		.loc 1 1737 0
 6607 3b1c 1C009DE5 		ldr	r0, [sp, #28]
 6608 3b20 02E0A0E3 		mov	lr, #2
 6609 3b24 FFC000E2 		and	ip, r0, #255
 6610 3b28 0630A0E1 		mov	r3, r6
1739:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6611              		.loc 1 1739 0
 6612 3b2c 6FA047E2 		sub	sl, r7, #111
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6613              		.loc 1 1737 0
 6614 3b30 0510A0E3 		mov	r1, #5
 6615 3b34 DE20A0E3 		mov	r2, #222
 6616 3b38 4C019FE5 		ldr	r0, .L561+4
 6617 3b3c 04E08DE5 		str	lr, [sp, #4]
1739:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6618              		.loc 1 1739 0
 6619 3b40 24A08DE5 		str	sl, [sp, #36]
1737:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6620              		.loc 1 1737 0
 6621 3b44 00C08DE5 		str	ip, [sp, #0]
 6622 3b48 FEFFFFEB 		bl	cmdSet
1738:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6623              		.loc 1 1738 0
 6624 3b4c 20A09DE5 		ldr	sl, [sp, #32]
 6625 3b50 0630A0E1 		mov	r3, r6
 6626 3b54 FFC00AE2 		and	ip, sl, #255
 6627 3b58 00C08DE5 		str	ip, [sp, #0]
 6628 3b5c 0510A0E3 		mov	r1, #5
 6629 3b60 03C0A0E3 		mov	ip, #3
 6630 3b64 E020A0E3 		mov	r2, #224
 6631 3b68 1C019FE5 		ldr	r0, .L561+4
 6632 3b6c 04C08DE5 		str	ip, [sp, #4]
 6633 3b70 FEFFFFEB 		bl	cmdSet
1739:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6634              		.loc 1 1739 0
 6635 3b74 24009DE5 		ldr	r0, [sp, #36]
 6636 3b78 04A0A0E3 		mov	sl, #4
 6637 3b7c FFC000E2 		and	ip, r0, #255
 6638 3b80 0630A0E1 		mov	r3, r6
 6639 3b84 0510A0E3 		mov	r1, #5
 6640 3b88 DD20A0E3 		mov	r2, #221
 6641 3b8c F8009FE5 		ldr	r0, .L561+4
 6642 3b90 00C08DE5 		str	ip, [sp, #0]
1740:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6643              		.loc 1 1740 0
 6644 3b94 7F7087E2 		add	r7, r7, #127
 6645              	.LVL553:
1739:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6646              		.loc 1 1739 0
 6647 3b98 04A08DE5 		str	sl, [sp, #4]
 6648 3b9c FEFFFFEB 		bl	cmdSet
1740:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6649              		.loc 1 1740 0
 6650 3ba0 05E0A0E3 		mov	lr, #5
 6651 3ba4 0E10A0E1 		mov	r1, lr
 6652 3ba8 0630A0E1 		mov	r3, r6
 6653 3bac E120A0E3 		mov	r2, #225
 6654 3bb0 FF6007E2 		and	r6, r7, #255
 6655              	.LVL554:
 6656 3bb4 D0009FE5 		ldr	r0, .L561+4
 6657 3bb8 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 6658 3bbc FEFFFFEB 		bl	cmdSet
 6659              	.LVL555:
1741:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6660              		.loc 1 1741 0
 6661 3bc0 14C09DE5 		ldr	ip, [sp, #20]
1742:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6662              		.loc 1 1742 0
 6663 3bc4 24E09DE5 		ldr	lr, [sp, #36]
 6664 3bc8 1C609DE5 		ldr	r6, [sp, #28]
1741:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6665              		.loc 1 1741 0
 6666 3bcc 05C2C4E5 		strb	ip, [r4, #517]
1742:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6667              		.loc 1 1742 0
 6668 3bd0 20C09DE5 		ldr	ip, [sp, #32]
 6669 3bd4 0B20A0E1 		mov	r2, fp
 6670 3bd8 18309DE5 		ldr	r3, [sp, #24]
 6671 3bdc B0109FE5 		ldr	r1, .L561+12
 6672 3be0 0A00A0E1 		mov	r0, sl
 6673 3be4 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 6674 3be8 0C708DE5 		str	r7, [sp, #12]
 6675 3bec FEFFFFEB 		bl	CyU3PDebugPrint
 6676              	.LVL556:
1746:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 6677              		.loc 1 1746 0
 6678 3bf0 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 6679              	.LVL557:
1747:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6680              		.loc 1 1747 0
 6681 3bf4 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 6682              	.LVL558:
1748:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6683              		.loc 1 1748 0
 6684 3bf8 0730A0E1 		mov	r3, r7
 6685 3bfc 0610A0E3 		mov	r1, #6
 6686 3c00 8520A0E3 		mov	r2, #133
 6687 3c04 80009FE5 		ldr	r0, .L561+4
 6688 3c08 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6689 3c0c FEFFFFEB 		bl	cmdSet
1749:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6690              		.loc 1 1749 0
 6691 3c10 0730A0E1 		mov	r3, r7
 6692 3c14 0610A0E3 		mov	r1, #6
 6693 3c18 8620A0E3 		mov	r2, #134
 6694 3c1c 68009FE5 		ldr	r0, .L561+4
 6695 3c20 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 6696 3c24 FEFFFFEB 		bl	cmdSet
1751:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6697              		.loc 1 1751 0
 6698 3c28 0620A0E1 		mov	r2, r6
 6699 3c2c 0530A0E1 		mov	r3, r5
 6700 3c30 58109FE5 		ldr	r1, .L561+8
 6701 3c34 0A00A0E1 		mov	r0, sl
1750:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6702              		.loc 1 1750 0
 6703 3c38 1D62C4E5 		strb	r6, [r4, #541]
1751:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6704              		.loc 1 1751 0
 6705 3c3c FEFFFFEB 		bl	CyU3PDebugPrint
 6706              	.LVL559:
1756:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6707              		.loc 1 1756 0
 6708 3c40 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 6709              	.LVL560:
1757:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6710              		.loc 1 1757 0
 6711 3c44 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 6712 3c48 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 6713 3c4c 0710A0E3 		mov	r1, #7
 6714 3c50 34009FE5 		ldr	r0, .L561+4
 6715 3c54 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 6716 3c58 FEFFFFEB 		bl	cmdSet
 6717              	.LVL561:
1759:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6718              		.loc 1 1759 0
 6719 3c5c 0530A0E1 		mov	r3, r5
 6720 3c60 0A00A0E1 		mov	r0, sl
 6721 3c64 24109FE5 		ldr	r1, .L561+8
 6722 3c68 0620A0E1 		mov	r2, r6
1758:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6723              		.loc 1 1758 0
 6724 3c6c 3552C4E5 		strb	r5, [r4, #565]
1759:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6725              		.loc 1 1759 0
 6726 3c70 FEFFFFEB 		bl	CyU3PDebugPrint
1761:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 6727              		.loc 1 1761 0
 6728 3c74 10309FE5 		ldr	r3, .L561+4
 6729 3c78 1C0093E5 		ldr	r0, [r3, #28]
1764:../uvc.c      **** }
 6730              		.loc 1 1764 0
 6731 3c7c 2CD08DE2 		add	sp, sp, #44
 6732 3c80 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1761:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 6733              		.loc 1 1761 0
 6734 3c84 FEFFFFEA 		b	_txe_mutex_put
 6735              	.L562:
 6736              		.align	2
 6737              	.L561:
 6738 3c88 00000000 		.word	.LANCHOR1
 6739 3c8c 00000000 		.word	statQu
 6740 3c90 D0070000 		.word	.LC44
 6741 3c94 F0070000 		.word	.LC45
 6742              		.cfi_endproc
 6743              	.LFE5:
 6745              		.align	2
 6746              		.global	CyFxUVCAddHeader
 6748              	CyFxUVCAddHeader:
 6749              	.LFB6:
1772:../uvc.c      **** {
 6750              		.loc 1 1772 0
 6751              		.cfi_startproc
 6752              		@ args = 0, pretend = 0, frame = 0
 6753              		@ frame_needed = 0, uses_anonymous_args = 0
 6754              	.LVL562:
 6755 3c98 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6756              	.LCFI24:
 6757              		.cfi_def_cfa_offset 16
1772:../uvc.c      **** {
 6758              		.loc 1 1772 0
 6759 3c9c 0040A0E1 		mov	r4, r0
 6760              		.cfi_offset 14, -4
 6761              		.cfi_offset 5, -8
 6762              		.cfi_offset 4, -12
 6763              		.cfi_offset 3, -16
 6764 3ca0 0150A0E1 		mov	r5, r1
1774:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 6765              		.loc 1 1774 0
 6766 3ca4 30009FE5 		ldr	r0, .L565
 6767              	.LVL563:
 6768 3ca8 0010E0E3 		mvn	r1, #0
 6769              	.LVL564:
 6770 3cac FEFFFFEB 		bl	_txe_mutex_get
1775:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6771              		.loc 1 1775 0
 6772 3cb0 0400A0E1 		mov	r0, r4
 6773 3cb4 24109FE5 		ldr	r1, .L565+4
 6774 3cb8 0C20A0E3 		mov	r2, #12
 6775 3cbc FEFFFFEB 		bl	CyU3PMemCopy
1776:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6776              		.loc 1 1776 0
 6777 3cc0 14009FE5 		ldr	r0, .L565
 6778 3cc4 FEFFFFEB 		bl	_txe_mutex_put
1779:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 6779              		.loc 1 1779 0
 6780 3cc8 020015E3 		tst	r5, #2
1781:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 6781              		.loc 1 1781 0
 6782 3ccc 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6783 3cd0 02308313 		orrne	r3, r3, #2
 6784 3cd4 0130C415 		strneb	r3, [r4, #1]
 6785 3cd8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6786              	.L566:
 6787              		.align	2
 6788              	.L565:
 6789 3cdc 00000000 		.word	imgHdMux
 6790 3ce0 80040000 		.word	.LANCHOR1+1152
 6791              		.cfi_endproc
 6792              	.LFE6:
 6794              		.align	2
 6795              		.global	CyFxAppErrorHandler
 6797              	CyFxAppErrorHandler:
 6798              	.LFB7:
1791:../uvc.c      **** {
 6799              		.loc 1 1791 0
 6800              		.cfi_startproc
 6801              		@ args = 0, pretend = 0, frame = 0
 6802              		@ frame_needed = 0, uses_anonymous_args = 0
 6803              	.LVL565:
 6804 3ce4 08402DE9 		stmfd	sp!, {r3, lr}
 6805              	.LCFI25:
 6806              		.cfi_def_cfa_offset 8
 6807              	.LVL566:
 6808              	.L568:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6809              		.loc 1 1801 0 discriminator 1
 6810 3ce8 10109FE5 		ldr	r1, .L569
 6811 3cec 0400A0E3 		mov	r0, #4
 6812              		.cfi_offset 14, -4
 6813              		.cfi_offset 3, -8
 6814 3cf0 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 6815              		.loc 1 1802 0 discriminator 1
 6816 3cf4 FA0FA0E3 		mov	r0, #1000
 6817 3cf8 FEFFFFEB 		bl	_tx_thread_sleep
 6818 3cfc F9FFFFEA 		b	.L568
 6819              	.L570:
 6820              		.align	2
 6821              	.L569:
 6822 3d00 F0010000 		.word	.LC13
 6823              		.cfi_endproc
 6824              	.LFE7:
 6826              		.align	2
 6827              		.global	UVCAppThread_Entry
 6829              	UVCAppThread_Entry:
 6830              	.LFB19:
2778:../uvc.c      **** {
 6831              		.loc 1 2778 0
 6832              		.cfi_startproc
 6833              		@ args = 0, pretend = 0, frame = 176
 6834              		@ frame_needed = 0, uses_anonymous_args = 0
 6835              	.LVL567:
 6836 3d04 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 6837              	.LCFI26:
 6838              		.cfi_def_cfa_offset 28
 6839 3d08 BCD04DE2 		sub	sp, sp, #188
 6840              	.LCFI27:
 6841              		.cfi_def_cfa_offset 216
 6842              	.LBB220:
 6843              	.LBB221:
2234:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 6844              		.loc 1 2234 0
 6845              		.cfi_offset 14, -4
 6846              		.cfi_offset 10, -8
 6847              		.cfi_offset 8, -12
 6848              		.cfi_offset 7, -16
 6849              		.cfi_offset 6, -20
 6850              		.cfi_offset 5, -24
 6851              		.cfi_offset 4, -28
 6852 3d0c FEFFFFEB 		bl	CyU3PUartInit
 6853              	.LVL568:
2235:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6854              		.loc 1 2235 0
 6855 3d10 004050E2 		subs	r4, r0, #0
 6856 3d14 0400000A 		beq	.L572
2237:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 6857              		.loc 1 2237 0
 6858 3d18 0400A0E3 		mov	r0, #4
 6859              	.LVL569:
 6860 3d1c F81B9FE5 		ldr	r1, .L688
 6861 3d20 FEFFFFEB 		bl	CyU3PDebugPrint
2238:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6862              		.loc 1 2238 0
 6863 3d24 0400A0E1 		mov	r0, r4
 6864 3d28 FEFFFFEB 		bl	CyFxAppErrorHandler
 6865              	.L572:
2242:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6866              		.loc 1 2242 0
 6867 3d2c ECCB9FE5 		ldr	ip, .L688+4
2244:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6868              		.loc 1 2244 0
 6869 3d30 0030A0E3 		mov	r3, #0
2243:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6870              		.loc 1 2243 0
 6871 3d34 0120A0E3 		mov	r2, #1
2251:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6872              		.loc 1 2251 0
 6873 3d38 50008DE2 		add	r0, sp, #80
 6874 3d3c 0310A0E1 		mov	r1, r3
2242:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 6875              		.loc 1 2242 0
 6876 3d40 60C08DE5 		str	ip, [sp, #96]
2243:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6877              		.loc 1 2243 0
 6878 3d44 6420CDE5 		strb	r2, [sp, #100]
2244:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6879              		.loc 1 2244 0
 6880 3d48 6530CDE5 		strb	r3, [sp, #101]
2245:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6881              		.loc 1 2245 0
 6882 3d4c 50208DE5 		str	r2, [sp, #80]
2246:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6883              		.loc 1 2246 0
 6884 3d50 54308DE5 		str	r3, [sp, #84]
2247:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6885              		.loc 1 2247 0
 6886 3d54 58308DE5 		str	r3, [sp, #88]
2248:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6887              		.loc 1 2248 0
 6888 3d58 5C208DE5 		str	r2, [sp, #92]
2251:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 6889              		.loc 1 2251 0
 6890 3d5c FEFFFFEB 		bl	CyU3PUartSetConfig
 6891              	.LVL570:
2252:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6892              		.loc 1 2252 0
 6893 3d60 000050E3 		cmp	r0, #0
 6894 3d64 0000000A 		beq	.L573
2254:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6895              		.loc 1 2254 0
 6896 3d68 FEFFFFEB 		bl	CyFxAppErrorHandler
 6897              	.LVL571:
 6898              	.L573:
2258:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 6899              		.loc 1 2258 0
 6900 3d6c 0000E0E3 		mvn	r0, #0
 6901 3d70 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6902              	.LVL572:
2259:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6903              		.loc 1 2259 0
 6904 3d74 000050E3 		cmp	r0, #0
 6905 3d78 0000000A 		beq	.L574
2261:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6906              		.loc 1 2261 0
 6907 3d7c FEFFFFEB 		bl	CyFxAppErrorHandler
 6908              	.LVL573:
 6909              	.L574:
2265:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 6910              		.loc 1 2265 0
 6911 3d80 0300A0E3 		mov	r0, #3
 6912 3d84 0410A0E3 		mov	r1, #4
 6913 3d88 FEFFFFEB 		bl	CyU3PDebugInit
 6914              	.LVL574:
2266:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6915              		.loc 1 2266 0
 6916 3d8c 000050E3 		cmp	r0, #0
 6917 3d90 0000000A 		beq	.L575
2268:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6918              		.loc 1 2268 0
 6919 3d94 FEFFFFEB 		bl	CyFxAppErrorHandler
 6920              	.LVL575:
 6921              	.L575:
2272:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 6922              		.loc 1 2272 0
 6923 3d98 0000A0E3 		mov	r0, #0
 6924 3d9c FEFFFFEB 		bl	CyU3PDebugPreamble
 6925              	.LVL576:
 6926              	.LBE221:
 6927              	.LBE220:
2794:../uvc.c      **** 		CyU3PThreadSleep(500);
 6928              		.loc 1 2794 0
 6929 3da0 7D0FA0E3 		mov	r0, #500
 6930 3da4 FEFFFFEB 		bl	_tx_thread_sleep
 6931              	.LVL577:
 6932 3da8 7D0FA0E3 		mov	r0, #500
 6933 3dac FEFFFFEB 		bl	_tx_thread_sleep
 6934 3db0 7D0FA0E3 		mov	r0, #500
 6935 3db4 FEFFFFEB 		bl	_tx_thread_sleep
 6936 3db8 7D0FA0E3 		mov	r0, #500
 6937 3dbc FEFFFFEB 		bl	_tx_thread_sleep
 6938 3dc0 7D0FA0E3 		mov	r0, #500
 6939 3dc4 FEFFFFEB 		bl	_tx_thread_sleep
 6940 3dc8 7D0FA0E3 		mov	r0, #500
 6941 3dcc FEFFFFEB 		bl	_tx_thread_sleep
 6942              	.LBB222:
 6943              	.LBB223:
2282:../uvc.c      ****     status = CyU3PI2cInit ();
 6944              		.loc 1 2282 0
 6945 3dd0 FEFFFFEB 		bl	CyU3PI2cInit
 6946              	.LVL578:
2283:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6947              		.loc 1 2283 0
 6948 3dd4 004050E2 		subs	r4, r0, #0
 6949 3dd8 0400000A 		beq	.L576
2285:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 6950              		.loc 1 2285 0
 6951 3ddc 0400A0E3 		mov	r0, #4
 6952              	.LVL579:
 6953 3de0 3C1B9FE5 		ldr	r1, .L688+8
 6954 3de4 FEFFFFEB 		bl	CyU3PDebugPrint
2286:../uvc.c      ****         CyFxAppErrorHandler (status);
 6955              		.loc 1 2286 0
 6956 3de8 0400A0E1 		mov	r0, r4
 6957 3dec FEFFFFEB 		bl	CyFxAppErrorHandler
 6958              	.L576:
2290:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6959              		.loc 1 2290 0
 6960 3df0 306B9FE5 		ldr	r6, .L688+12
2291:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6961              		.loc 1 2291 0
 6962 3df4 0050A0E3 		mov	r5, #0
2292:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6963              		.loc 1 2292 0
 6964 3df8 0040E0E3 		mvn	r4, #0
 6965              	.LVL580:
2295:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6966              		.loc 1 2295 0
 6967 3dfc 8C008DE2 		add	r0, sp, #140
 6968 3e00 0510A0E1 		mov	r1, r5
2292:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6969              		.loc 1 2292 0
 6970 3e04 94408DE5 		str	r4, [sp, #148]
2293:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6971              		.loc 1 2293 0
 6972 3e08 B849CDE1 		strh	r4, [sp, #152]	@ movhi
2290:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 6973              		.loc 1 2290 0
 6974 3e0c 8C608DE5 		str	r6, [sp, #140]
2291:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6975              		.loc 1 2291 0
 6976 3e10 90508DE5 		str	r5, [sp, #144]
2295:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 6977              		.loc 1 2295 0
 6978 3e14 FEFFFFEB 		bl	CyU3PI2cSetConfig
 6979              	.LVL581:
2296:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6980              		.loc 1 2296 0
 6981 3e18 004050E2 		subs	r4, r0, #0
 6982 3e1c 0400000A 		beq	.L577
2298:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 6983              		.loc 1 2298 0
 6984 3e20 0400A0E3 		mov	r0, #4
 6985              	.LVL582:
 6986 3e24 001B9FE5 		ldr	r1, .L688+16
 6987 3e28 FEFFFFEB 		bl	CyU3PDebugPrint
2299:../uvc.c      ****         CyFxAppErrorHandler (status);
 6988              		.loc 1 2299 0
 6989 3e2c 0400A0E1 		mov	r0, r4
 6990 3e30 FEFFFFEB 		bl	CyFxAppErrorHandler
 6991              	.L577:
 6992              	.LBE223:
 6993              	.LBE222:
 6994              	.LBB224:
 6995              	.LBB227:
2369:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 6996              		.loc 1 2369 0
 6997 3e34 F44A9FE5 		ldr	r4, .L688+20
 6998              	.LVL583:
 6999 3e38 2820A0E3 		mov	r2, #40
 7000 3e3c 0010A0E3 		mov	r1, #0
 7001 3e40 0400A0E1 		mov	r0, r4
 7002 3e44 FEFFFFEB 		bl	_txe_event_flags_create
 7003              	.LVL584:
2370:../uvc.c      ****     if (apiRetStatus != 0)
 7004              		.loc 1 2370 0
 7005 3e48 002050E2 		subs	r2, r0, #0
 7006 3e4c F800001A 		bne	.L662
2384:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7007              		.loc 1 2384 0
 7008 3e50 0260A0E3 		mov	r6, #2
2391:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7009              		.loc 1 2391 0
 7010 3e54 0210A0E1 		mov	r1, r2
2380:../uvc.c      ****     isUsbConnected = CyFalse;
 7011              		.loc 1 2380 0
 7012 3e58 302084E5 		str	r2, [r4, #48]
2381:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7013              		.loc 1 2381 0
 7014 3e5c 442084E5 		str	r2, [r4, #68]
2387:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7015              		.loc 1 2387 0
 7016 3e60 0370A0E3 		mov	r7, #3
2391:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7017              		.loc 1 2391 0
 7018 3e64 9C008DE2 		add	r0, sp, #156
 7019              	.LVL585:
2386:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 7020              		.loc 1 2386 0
 7021 3e68 A420CDE5 		strb	r2, [sp, #164]
2388:../uvc.c      ****     gpioClock.halfDiv    = 0;
 7022              		.loc 1 2388 0
 7023 3e6c A0208DE5 		str	r2, [sp, #160]
2384:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7024              		.loc 1 2384 0
 7025 3e70 9C60CDE5 		strb	r6, [sp, #156]
2385:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 7026              		.loc 1 2385 0
 7027 3e74 9D60CDE5 		strb	r6, [sp, #157]
2387:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 7028              		.loc 1 2387 0
 7029 3e78 A570CDE5 		strb	r7, [sp, #165]
2391:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7030              		.loc 1 2391 0
 7031 3e7c FEFFFFEB 		bl	CyU3PGpioInit
 7032              	.LVL586:
2392:../uvc.c      ****     if (apiRetStatus != 0)
 7033              		.loc 1 2392 0
 7034 3e80 002050E2 		subs	r2, r0, #0
 7035 3e84 FC00001A 		bne	.L663
2400:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 7036              		.loc 1 2400 0
 7037 3e88 1600A0E3 		mov	r0, #22
 7038              	.LVL587:
 7039 3e8c 0110A0E3 		mov	r1, #1
 7040 3e90 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7041              	.LVL588:
2401:../uvc.c      ****     if (apiRetStatus != 0)
 7042              		.loc 1 2401 0
 7043 3e94 002050E2 		subs	r2, r0, #0
 7044 3e98 EE00001A 		bne	.L664
2406:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 7045              		.loc 1 2406 0
 7046 3e9c 1400A0E3 		mov	r0, #20
 7047              	.LVL589:
 7048 3ea0 0110A0E3 		mov	r1, #1
 7049 3ea4 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7050              	.LVL590:
2407:../uvc.c      ****     if (apiRetStatus != 0)
 7051              		.loc 1 2407 0
 7052 3ea8 002050E2 		subs	r2, r0, #0
 7053 3eac FB00001A 		bne	.L665
2412:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 7054              		.loc 1 2412 0
 7055 3eb0 1800A0E3 		mov	r0, #24
 7056              	.LVL591:
 7057 3eb4 0110A0E3 		mov	r1, #1
 7058 3eb8 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 7059              	.LVL592:
2413:../uvc.c      ****     if (apiRetStatus != 0)
 7060              		.loc 1 2413 0
 7061 3ebc 002050E2 		subs	r2, r0, #0
 7062 3ec0 D601001A 		bne	.L666
2420:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7063              		.loc 1 2420 0
 7064 3ec4 0150A0E3 		mov	r5, #1
2425:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7065              		.loc 1 2425 0
 7066 3ec8 1600A0E3 		mov	r0, #22
 7067              	.LVL593:
 7068 3ecc 68108DE2 		add	r1, sp, #104
2423:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7069              		.loc 1 2423 0
 7070 3ed0 74208DE5 		str	r2, [sp, #116]
2424:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7071              		.loc 1 2424 0
 7072 3ed4 7820CDE5 		strb	r2, [sp, #120]
2420:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7073              		.loc 1 2420 0
 7074 3ed8 68508DE5 		str	r5, [sp, #104]
2421:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7075              		.loc 1 2421 0
 7076 3edc 6C508DE5 		str	r5, [sp, #108]
2422:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7077              		.loc 1 2422 0
 7078 3ee0 70508DE5 		str	r5, [sp, #112]
2425:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 7079              		.loc 1 2425 0
 7080 3ee4 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7081              	.LVL594:
2426:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7082              		.loc 1 2426 0
 7083 3ee8 002050E2 		subs	r2, r0, #0
 7084 3eec C201001A 		bne	.L667
2439:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7085              		.loc 1 2439 0
 7086 3ef0 1400A0E3 		mov	r0, #20
 7087              	.LVL595:
 7088 3ef4 68108DE2 		add	r1, sp, #104
2437:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 7089              		.loc 1 2437 0
 7090 3ef8 74208DE5 		str	r2, [sp, #116]
2438:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7091              		.loc 1 2438 0
 7092 3efc 7820CDE5 		strb	r2, [sp, #120]
2434:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 7093              		.loc 1 2434 0
 7094 3f00 68508DE5 		str	r5, [sp, #104]
2435:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 7095              		.loc 1 2435 0
 7096 3f04 6C508DE5 		str	r5, [sp, #108]
2436:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 7097              		.loc 1 2436 0
 7098 3f08 70508DE5 		str	r5, [sp, #112]
2439:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 7099              		.loc 1 2439 0
 7100 3f0c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7101              	.LVL596:
2440:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7102              		.loc 1 2440 0
 7103 3f10 002050E2 		subs	r2, r0, #0
 7104 3f14 CA01001A 		bne	.L668
2453:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7105              		.loc 1 2453 0
 7106 3f18 1800A0E3 		mov	r0, #24
 7107              	.LVL597:
 7108 3f1c 68108DE2 		add	r1, sp, #104
2448:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 7109              		.loc 1 2448 0
 7110 3f20 68208DE5 		str	r2, [sp, #104]
2449:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 7111              		.loc 1 2449 0
 7112 3f24 6C208DE5 		str	r2, [sp, #108]
2450:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 7113              		.loc 1 2450 0
 7114 3f28 70208DE5 		str	r2, [sp, #112]
2452:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 7115              		.loc 1 2452 0
 7116 3f2c 7820CDE5 		strb	r2, [sp, #120]
2451:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 7117              		.loc 1 2451 0
 7118 3f30 74508DE5 		str	r5, [sp, #116]
2453:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 7119              		.loc 1 2453 0
 7120 3f34 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 7121              	.LVL598:
2454:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7122              		.loc 1 2454 0
 7123 3f38 002050E2 		subs	r2, r0, #0
 7124 3f3c A501001A 		bne	.L669
2466:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7125              		.loc 1 2466 0
 7126 3f40 0500A0E1 		mov	r0, r5
 7127              	.LVL599:
 7128 3f44 7C108DE2 		add	r1, sp, #124
2463:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 7129              		.loc 1 2463 0
 7130 3f48 84208DE5 		str	r2, [sp, #132]
2464:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 7131              		.loc 1 2464 0
 7132 3f4c 80208DE5 		str	r2, [sp, #128]
2461:../uvc.c      ****     pibclock.clkDiv      = 2;
 7133              		.loc 1 2461 0
 7134 3f50 BC67CDE1 		strh	r6, [sp, #124]	@ movhi
2462:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 7135              		.loc 1 2462 0
 7136 3f54 8870CDE5 		strb	r7, [sp, #136]
2466:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 7137              		.loc 1 2466 0
 7138 3f58 FEFFFFEB 		bl	CyU3PPibInit
 7139              	.LVL600:
2467:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7140              		.loc 1 2467 0
 7141 3f5c 002050E2 		subs	r2, r0, #0
 7142 3f60 9301001A 		bne	.L670
2474:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 7143              		.loc 1 2474 0
 7144 3f64 C8099FE5 		ldr	r0, .L688+24
 7145              	.LVL601:
 7146 3f68 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 7147              	.LVL602:
2482:../uvc.c      ****     SensorReset ();
 7148              		.loc 1 2482 0
 7149 3f6c FEFFFFEB 		bl	SensorReset
2483:../uvc.c      ****     CyU3PThreadSleep(5000);
 7150              		.loc 1 2483 0
 7151 3f70 C0099FE5 		ldr	r0, .L688+28
 7152 3f74 FEFFFFEB 		bl	_tx_thread_sleep
2487:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 7153              		.loc 1 2487 0
 7154 3f78 FEFFFFEB 		bl	CyU3PUsbStart
 7155              	.LVL603:
2488:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7156              		.loc 1 2488 0
 7157 3f7c 002050E2 		subs	r2, r0, #0
 7158 3f80 8201001A 		bne	.L671
2494:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 7159              		.loc 1 2494 0
 7160 3f84 0010A0E3 		mov	r1, #0
 7161 3f88 AC099FE5 		ldr	r0, .L688+32
 7162              	.LVL604:
 7163 3f8c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 7164              	.LVL605:
2497:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 7165              		.loc 1 2497 0
 7166 3f90 A8099FE5 		ldr	r0, .L688+36
 7167 3f94 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2503:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 7168              		.loc 1 2503 0
 7169 3f98 0010A0E3 		mov	r1, #0
 7170 3f9c A0299FE5 		ldr	r2, .L688+40
 7171 3fa0 0100A0E3 		mov	r0, #1
 7172 3fa4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2504:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 7173              		.loc 1 2504 0
 7174 3fa8 0000A0E3 		mov	r0, #0
 7175 3fac 0010A0E1 		mov	r1, r0
 7176 3fb0 90299FE5 		ldr	r2, .L688+44
 7177 3fb4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2507:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 7178              		.loc 1 2507 0
 7179 3fb8 0010A0E3 		mov	r1, #0
 7180 3fbc 88299FE5 		ldr	r2, .L688+48
 7181 3fc0 0200A0E3 		mov	r0, #2
 7182 3fc4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2508:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 7183              		.loc 1 2508 0
 7184 3fc8 0010A0E3 		mov	r1, #0
 7185 3fcc 7C299FE5 		ldr	r2, .L688+52
 7186 3fd0 0700A0E3 		mov	r0, #7
 7187 3fd4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2511:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 7188              		.loc 1 2511 0
 7189 3fd8 0010A0E3 		mov	r1, #0
 7190 3fdc 70299FE5 		ldr	r2, .L688+56
 7191 3fe0 0400A0E3 		mov	r0, #4
 7192 3fe4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2512:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 7193              		.loc 1 2512 0
 7194 3fe8 0010A0E3 		mov	r1, #0
 7195 3fec 64299FE5 		ldr	r2, .L688+60
 7196 3ff0 0300A0E3 		mov	r0, #3
 7197 3ff4 FEFFFFEB 		bl	CyU3PUsbSetDesc
2513:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 7198              		.loc 1 2513 0
 7199 3ff8 0010A0E3 		mov	r1, #0
 7200 3ffc 58299FE5 		ldr	r2, .L688+64
 7201 4000 0600A0E3 		mov	r0, #6
 7202 4004 FEFFFFEB 		bl	CyU3PUsbSetDesc
2516:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 7203              		.loc 1 2516 0
 7204 4008 0010A0E3 		mov	r1, #0
 7205 400c 4C299FE5 		ldr	r2, .L688+68
 7206 4010 0500A0E3 		mov	r0, #5
 7207 4014 FEFFFFEB 		bl	CyU3PUsbSetDesc
2517:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 7208              		.loc 1 2517 0
 7209 4018 0110A0E3 		mov	r1, #1
 7210 401c 40299FE5 		ldr	r2, .L688+72
 7211 4020 0500A0E3 		mov	r0, #5
 7212 4024 FEFFFFEB 		bl	CyU3PUsbSetDesc
2518:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 7213              		.loc 1 2518 0
 7214 4028 0210A0E3 		mov	r1, #2
 7215 402c 34299FE5 		ldr	r2, .L688+76
 7216 4030 0500A0E3 		mov	r0, #5
 7217 4034 FEFFFFEB 		bl	CyU3PUsbSetDesc
2528:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7218              		.loc 1 2528 0
 7219 4038 0080A0E3 		mov	r8, #0
2525:../uvc.c      ****     endPointConfig.enable   = 1;
 7220              		.loc 1 2525 0
 7221 403c 0150A0E3 		mov	r5, #1
2527:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7222              		.loc 1 2527 0
 7223 4040 4070A0E3 		mov	r7, #64	@ movhi
2531:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7224              		.loc 1 2531 0
 7225 4044 8200A0E3 		mov	r0, #130
 7226 4048 A8108DE2 		add	r1, sp, #168
2526:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7227              		.loc 1 2526 0
 7228 404c 03A0A0E3 		mov	sl, #3
2527:../uvc.c      ****     endPointConfig.pcktSize = 64;
 7229              		.loc 1 2527 0
 7230 4050 B07BCDE1 		strh	r7, [sp, #176]	@ movhi
2525:../uvc.c      ****     endPointConfig.enable   = 1;
 7231              		.loc 1 2525 0
 7232 4054 A8508DE5 		str	r5, [sp, #168]
2526:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 7233              		.loc 1 2526 0
 7234 4058 ACA0CDE5 		strb	sl, [sp, #172]
2528:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 7235              		.loc 1 2528 0
 7236 405c B380CDE5 		strb	r8, [sp, #179]
2529:../uvc.c      ****     endPointConfig.streams  = 0;
 7237              		.loc 1 2529 0
 7238 4060 BE8ACDE1 		strh	r8, [sp, #174]	@ movhi
2530:../uvc.c      ****     endPointConfig.burstLen = 1;
 7239              		.loc 1 2530 0
 7240 4064 B250CDE5 		strb	r5, [sp, #178]
2531:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 7241              		.loc 1 2531 0
 7242 4068 FEFFFFEB 		bl	CyU3PSetEpConfig
 7243              	.LVL606:
2529:../uvc.c      ****     endPointConfig.streams  = 0;
 7244              		.loc 1 2529 0
 7245 406c 0870A0E1 		mov	r7, r8	@ movhi
2532:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7246              		.loc 1 2532 0
 7247 4070 003050E2 		subs	r3, r0, #0
 7248 4074 3B01001A 		bne	.L672
2542:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7249              		.loc 1 2542 0
 7250 4078 ECC89FE5 		ldr	ip, .L688+80
2543:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7251              		.loc 1 2543 0
 7252 407c ECE89FE5 		ldr	lr, .L688+84
2540:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7253              		.loc 1 2540 0
 7254 4080 016BA0E3 		mov	r6, #1024	@ movhi
2549:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7255              		.loc 1 2549 0
 7256 4084 1080A0E3 		mov	r8, #16
2551:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7257              		.loc 1 2551 0
 7258 4088 E4089FE5 		ldr	r0, .L688+88
 7259              	.LVL607:
 7260 408c 0410A0E3 		mov	r1, #4
 7261 4090 34208DE2 		add	r2, sp, #52
2540:../uvc.c      ****     dmaInterConfig.size           = 1024;
 7262              		.loc 1 2540 0
 7263 4094 B463CDE1 		strh	r6, [sp, #52]	@ movhi
2541:../uvc.c      ****     dmaInterConfig.count          = 1;
 7264              		.loc 1 2541 0
 7265 4098 B653CDE1 		strh	r5, [sp, #54]	@ movhi
2542:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 7266              		.loc 1 2542 0
 7267 409c B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
2543:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 7268              		.loc 1 2543 0
 7269 40a0 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
2544:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 7270              		.loc 1 2544 0
 7271 40a4 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2545:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 7272              		.loc 1 2545 0
 7273 40a8 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2546:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 7274              		.loc 1 2546 0
 7275 40ac B034CDE1 		strh	r3, [sp, #64]	@ movhi
2547:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 7276              		.loc 1 2547 0
 7277 40b0 B234CDE1 		strh	r3, [sp, #66]	@ movhi
2548:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7278              		.loc 1 2548 0
 7279 40b4 4470CDE5 		strb	r7, [sp, #68]
2549:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 7280              		.loc 1 2549 0
 7281 40b8 48808DE5 		str	r8, [sp, #72]
2550:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 7282              		.loc 1 2550 0
 7283 40bc 4C308DE5 		str	r3, [sp, #76]
2551:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 7284              		.loc 1 2551 0
 7285 40c0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 7286              	.LVL608:
2553:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7287              		.loc 1 2553 0
 7288 40c4 006050E2 		subs	r6, r0, #0
 7289 40c8 DF00001A 		bne	.L673
2560:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7290              		.loc 1 2560 0
 7291 40cc 010BA0E3 		mov	r0, #1024
 7292              	.LVL609:
 7293 40d0 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 7294 40d4 9C189FE5 		ldr	r1, .L688+92
2561:../uvc.c      ****     if (glInterStaBuffer == 0)
 7295              		.loc 1 2561 0
 7296 40d8 000050E3 		cmp	r0, #0
2560:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 7297              		.loc 1 2560 0
 7298 40dc 000081E5 		str	r0, [r1, #0]
2561:../uvc.c      ****     if (glInterStaBuffer == 0)
 7299              		.loc 1 2561 0
 7300 40e0 D000000A 		beq	.L674
2568:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 7301              		.loc 1 2568 0
 7302 40e4 0610A0E1 		mov	r1, r6
 7303 40e8 0620A0E1 		mov	r2, r6
 7304 40ec 3830A0E3 		mov	r3, #56
 7305 40f0 84089FE5 		ldr	r0, .L688+96
 7306 40f4 FEFFFFEB 		bl	_txe_mutex_create
2570:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 7307              		.loc 1 2570 0
 7308 40f8 0430A0E3 		mov	r3, #4	@ movhi
 7309 40fc BE30CDE1 		strh	r3, [sp, #14]	@ movhi
2573:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7310              		.loc 1 2573 0
 7311 4100 78389FE5 		ldr	r3, .L688+100
2569:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 7312              		.loc 1 2569 0
 7313 4104 01C9A0E3 		mov	ip, #16384	@ movhi
 7314 4108 BCC0CDE1 		strh	ip, [sp, #12]	@ movhi
2572:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 7315              		.loc 1 2572 0
 7316 410c 01CCA0E3 		mov	ip, #256	@ movhi
 7317 4110 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
2573:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 7318              		.loc 1 2573 0
 7319 4114 B431CDE1 		strh	r3, [sp, #20]	@ movhi
2574:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7320              		.loc 1 2574 0
 7321 4118 64C89FE5 		ldr	ip, .L688+104
2576:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 7322              		.loc 1 2576 0
 7323 411c 0C30A0E3 		mov	r3, #12	@ movhi
 7324 4120 B432CDE1 		strh	r3, [sp, #36]	@ movhi
2581:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7325              		.loc 1 2581 0
 7326 4124 5C389FE5 		ldr	r3, .L688+108
2582:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7327              		.loc 1 2582 0
 7328 4128 0C208DE2 		add	r2, sp, #12
2574:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 7329              		.loc 1 2574 0
 7330 412c BAC1CDE1 		strh	ip, [sp, #26]	@ movhi
2579:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 7331              		.loc 1 2579 0
 7332 4130 2A70CDE5 		strb	r7, [sp, #42]
2577:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7333              		.loc 1 2577 0
 7334 4134 04C0A0E3 		mov	ip, #4	@ movhi
2571:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7335              		.loc 1 2571 0
 7336 4138 02A0A0E3 		mov	sl, #2	@ movhi
2582:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7337              		.loc 1 2582 0
 7338 413c 48089FE5 		ldr	r0, .L688+112
 7339 4140 0710A0E3 		mov	r1, #7
2580:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7340              		.loc 1 2580 0
 7341 4144 1870A0E3 		mov	r7, #24
2571:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 7342              		.loc 1 2571 0
 7343 4148 B0A1CDE1 		strh	sl, [sp, #16]	@ movhi
2575:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 7344              		.loc 1 2575 0
 7345 414c B262CDE1 		strh	r6, [sp, #34]	@ movhi
2577:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 7346              		.loc 1 2577 0
 7347 4150 B6C2CDE1 		strh	ip, [sp, #38]	@ movhi
2578:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 7348              		.loc 1 2578 0
 7349 4154 B862CDE1 		strh	r6, [sp, #40]	@ movhi
2580:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 7350              		.loc 1 2580 0
 7351 4158 2C708DE5 		str	r7, [sp, #44]
2581:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 7352              		.loc 1 2581 0
 7353 415c 30308DE5 		str	r3, [sp, #48]
2582:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 7354              		.loc 1 2582 0
 7355 4160 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 7356              	.LVL610:
2584:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7357              		.loc 1 2584 0
 7358 4164 002050E2 		subs	r2, r0, #0
 7359 4168 A500001A 		bne	.L675
2675:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 7360              		.loc 1 2675 0
 7361 416c 0500A0E1 		mov	r0, r5
 7362              	.LVL611:
 7363 4170 0510A0E1 		mov	r1, r5
 7364 4174 FEFFFFEB 		bl	CyU3PConnectState
 7365              	.LVL612:
2676:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7366              		.loc 1 2676 0
 7367 4178 002050E2 		subs	r2, r0, #0
 7368 417c 9700001A 		bne	.L676
2682:../uvc.c      ****     CyU3PBusyWait(100);
 7369              		.loc 1 2682 0
 7370 4180 6400A0E3 		mov	r0, #100
 7371              	.LVL613:
 7372 4184 FEFFFFEB 		bl	CyU3PBusyWait
 7373              	.LVL614:
2684:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7374              		.loc 1 2684 0
 7375 4188 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2698:../uvc.c      ****     endPointConfig.streams  = 0;
 7376              		.loc 1 2698 0
 7377 418c 0020A0E3 		mov	r2, #0	@ movhi
2687:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 7378              		.loc 1 2687 0
 7379 4190 ACA0CDE5 		strb	sl, [sp, #172]
2699:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7380              		.loc 1 2699 0
 7381 4194 A8108DE2 		add	r1, sp, #168
2698:../uvc.c      ****     endPointConfig.streams  = 0;
 7382              		.loc 1 2698 0
 7383 4198 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2686:../uvc.c      ****     endPointConfig.enable   = 1;
 7384              		.loc 1 2686 0
 7385 419c A8508DE5 		str	r5, [sp, #168]
2688:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 7386              		.loc 1 2688 0
 7387 41a0 030050E3 		cmp	r0, #3
2684:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 7388              		.loc 1 2684 0
 7389 41a4 4800C4E5 		strb	r0, [r4, #72]
2695:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7390              		.loc 1 2695 0
 7391 41a8 020CA013 		movne	r0, #512	@ movhi
2690:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7392              		.loc 1 2690 0
 7393 41ac 01ABA003 		moveq	sl, #1024	@ movhi
2695:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 7394              		.loc 1 2695 0
 7395 41b0 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2699:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7396              		.loc 1 2699 0
 7397 41b4 8300A0E3 		mov	r0, #131
2690:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 7398              		.loc 1 2690 0
 7399 41b8 B0ABCD01 		streqh	sl, [sp, #176]	@ movhi
2691:../uvc.c      ****     	endPointConfig.burstLen = 16;
 7400              		.loc 1 2691 0
 7401 41bc B280CD05 		streqb	r8, [sp, #178]
2696:../uvc.c      ****     	endPointConfig.burstLen = 1;
 7402              		.loc 1 2696 0
 7403 41c0 B250CD15 		strneb	r5, [sp, #178]
2699:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 7404              		.loc 1 2699 0
 7405 41c4 FEFFFFEB 		bl	CyU3PSetEpConfig
 7406              	.LVL615:
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7407              		.loc 1 2700 0
 7408 41c8 002050E2 		subs	r2, r0, #0
 7409 41cc 4F00001A 		bne	.L659
 7410 41d0 B8779FE5 		ldr	r7, .L688+116
 7411              	.LBE227:
 7412              	.LBE224:
2823:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7413              		.loc 1 2823 0
 7414 41d4 54579FE5 		ldr	r5, .L688+20
 7415 41d8 0260A0E1 		mov	r6, r2
3012:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7416              		.loc 1 3012 0
 7417 41dc 0080E0E3 		mvn	r8, #0
 7418              	.LVL616:
 7419              	.L610:
2823:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 7420              		.loc 1 2823 0
 7421 41e0 48079FE5 		ldr	r0, .L688+20
 7422 41e4 0110A0E3 		mov	r1, #1
 7423 41e8 0220A0E3 		mov	r2, #2
 7424 41ec B4308DE2 		add	r3, sp, #180
 7425 41f0 00608DE5 		str	r6, [sp, #0]
 7426 41f4 FEFFFFEB 		bl	_txe_event_flags_get
 7427 41f8 000050E3 		cmp	r0, #0
 7428 41fc 3000001A 		bne	.L612
2869:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7429              		.loc 1 2869 0
 7430 4200 3CE095E5 		ldr	lr, [r5, #60]
 7431 4204 00005EE3 		cmp	lr, #0
 7432 4208 0300000A 		beq	.L613
2869:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 7433              		.loc 1 2869 0 is_stmt 0 discriminator 1
 7434 420c B014D5E1 		ldrh	r1, [r5, #64]
 7435 4210 B234D5E1 		ldrh	r3, [r5, #66]
 7436 4214 030051E1 		cmp	r1, r3
 7437 4218 1201000A 		beq	.L677
 7438              	.L613:
3073:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 7439              		.loc 1 3073 0 is_stmt 1
 7440 421c 4010A0E3 		mov	r1, #64
 7441 4220 0020A0E3 		mov	r2, #0
 7442 4224 04079FE5 		ldr	r0, .L688+20
 7443 4228 FEFFFFEB 		bl	_txe_event_flags_set
3076:../uvc.c      ****         CyU3PThreadRelinquish ();
 7444              		.loc 1 3076 0
 7445 422c FEFFFFEB 		bl	_txe_thread_relinquish
3077:../uvc.c      ****     }
 7446              		.loc 1 3077 0
 7447 4230 EAFFFFEA 		b	.L610
 7448              	.LVL617:
 7449              	.L662:
 7450              	.LBB262:
 7451              	.LBB226:
2372:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 7452              		.loc 1 2372 0
 7453 4234 0400A0E3 		mov	r0, #4
 7454              	.LVL618:
 7455 4238 54179FE5 		ldr	r1, .L688+120
 7456 423c FEFFFFEB 		bl	CyU3PDebugPrint
 7457              	.LVL619:
 7458              	.L579:
 7459              	.LBB242:
 7460              	.LBB243:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7461              		.loc 1 1801 0
 7462 4240 50179FE5 		ldr	r1, .L688+124
 7463 4244 0400A0E3 		mov	r0, #4
 7464 4248 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7465              		.loc 1 1802 0
 7466 424c FA0FA0E3 		mov	r0, #1000
 7467 4250 FEFFFFEB 		bl	_tx_thread_sleep
 7468 4254 F9FFFFEA 		b	.L579
 7469              	.LVL620:
 7470              	.L664:
 7471              	.LBE243:
 7472              	.LBE242:
2403:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 7473              		.loc 1 2403 0
 7474 4258 0400A0E3 		mov	r0, #4
 7475              	.LVL621:
 7476 425c 38179FE5 		ldr	r1, .L688+128
 7477 4260 FEFFFFEB 		bl	CyU3PDebugPrint
 7478              	.LVL622:
 7479              	.L583:
 7480              	.LBB240:
 7481              	.LBB241:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7482              		.loc 1 1801 0
 7483 4264 2C179FE5 		ldr	r1, .L688+124
 7484 4268 0400A0E3 		mov	r0, #4
 7485 426c FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7486              		.loc 1 1802 0
 7487 4270 FA0FA0E3 		mov	r0, #1000
 7488 4274 FEFFFFEB 		bl	_tx_thread_sleep
 7489 4278 F9FFFFEA 		b	.L583
 7490              	.LVL623:
 7491              	.L663:
 7492              	.LBE241:
 7493              	.LBE240:
2394:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 7494              		.loc 1 2394 0
 7495 427c 0400A0E3 		mov	r0, #4
 7496              	.LVL624:
 7497 4280 18179FE5 		ldr	r1, .L688+132
 7498 4284 FEFFFFEB 		bl	CyU3PDebugPrint
 7499              	.LVL625:
 7500              	.L581:
 7501              	.LBB238:
 7502              	.LBB239:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7503              		.loc 1 1801 0
 7504 4288 08179FE5 		ldr	r1, .L688+124
 7505 428c 0400A0E3 		mov	r0, #4
 7506 4290 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7507              		.loc 1 1802 0
 7508 4294 FA0FA0E3 		mov	r0, #1000
 7509 4298 FEFFFFEB 		bl	_tx_thread_sleep
 7510 429c F9FFFFEA 		b	.L581
 7511              	.LVL626:
 7512              	.L665:
 7513              	.LBE239:
 7514              	.LBE238:
2409:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 7515              		.loc 1 2409 0
 7516 42a0 0400A0E3 		mov	r0, #4
 7517              	.LVL627:
 7518 42a4 F8169FE5 		ldr	r1, .L688+136
 7519 42a8 FEFFFFEB 		bl	CyU3PDebugPrint
 7520              	.LVL628:
 7521              	.L585:
 7522              	.LBB236:
 7523              	.LBB237:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7524              		.loc 1 1801 0
 7525 42ac E4169FE5 		ldr	r1, .L688+124
 7526 42b0 0400A0E3 		mov	r0, #4
 7527 42b4 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7528              		.loc 1 1802 0
 7529 42b8 FA0FA0E3 		mov	r0, #1000
 7530 42bc FEFFFFEB 		bl	_tx_thread_sleep
 7531 42c0 F9FFFFEA 		b	.L585
 7532              	.LVL629:
 7533              	.L612:
 7534              	.LBE237:
 7535              	.LBE236:
 7536              	.LBE226:
 7537              	.LBE262:
2980:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 7538              		.loc 1 2980 0
 7539 42c4 64069FE5 		ldr	r0, .L688+20
 7540 42c8 0210A0E3 		mov	r1, #2
 7541 42cc 0320A0E3 		mov	r2, #3
 7542 42d0 B4308DE2 		add	r3, sp, #180
 7543 42d4 00608DE5 		str	r6, [sp, #0]
 7544 42d8 FEFFFFEB 		bl	_txe_event_flags_get
 7545 42dc 000050E3 		cmp	r0, #0
 7546 42e0 2500001A 		bne	.L635
2995:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7547              		.loc 1 2995 0
 7548 42e4 441095E5 		ldr	r1, [r5, #68]
2983:../uvc.c      ****                 hitFV     = CyFalse;
 7549              		.loc 1 2983 0
 7550 42e8 3C6085E5 		str	r6, [r5, #60]
2995:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7551              		.loc 1 2995 0
 7552 42ec 000051E3 		cmp	r1, #0
2984:../uvc.c      ****                 prodCount = 0;
 7553              		.loc 1 2984 0
 7554 42f0 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2991:../uvc.c      ****                 fb=0;
 7555              		.loc 1 2991 0
 7556 42f4 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2985:../uvc.c      ****                 consCount = 0;
 7557              		.loc 1 2985 0
 7558 42f8 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2992:../uvc.c      ****                 pb=0;
 7559              		.loc 1 2992 0
 7560 42fc B663C5E1 		strh	r6, [r5, #54]	@ movhi
2993:../uvc.c      ****                 pbc=0;
 7561              		.loc 1 2993 0
 7562 4300 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2995:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 7563              		.loc 1 2995 0
 7564 4304 0A00000A 		beq	.L678
 7565              	.L636:
3007:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 7566              		.loc 1 3007 0
 7567 4308 446084E5 		str	r6, [r4, #68]
 7568 430c C2FFFFEA 		b	.L613
 7569              	.LVL630:
 7570              	.L659:
 7571              	.LBB263:
 7572              	.LBB260:
2703:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7573              		.loc 1 2703 0
 7574 4310 0400A0E3 		mov	r0, #4
 7575              	.LVL631:
 7576 4314 8C169FE5 		ldr	r1, .L688+140
 7577 4318 FEFFFFEB 		bl	CyU3PDebugPrint
 7578              	.LVL632:
 7579              	.L611:
 7580              	.LBB244:
 7581              	.LBB245:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7582              		.loc 1 1801 0
 7583 431c 74169FE5 		ldr	r1, .L688+124
 7584 4320 0400A0E3 		mov	r0, #4
 7585 4324 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7586              		.loc 1 1802 0
 7587 4328 FA0FA0E3 		mov	r0, #1000
 7588 432c FEFFFFEB 		bl	_tx_thread_sleep
 7589 4330 F9FFFFEA 		b	.L611
 7590              	.LVL633:
 7591              	.L678:
 7592              	.LBE245:
 7593              	.LBE244:
 7594              	.LBE260:
 7595              	.LBE263:
2997:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 7596              		.loc 1 2997 0
 7597 4334 50069FE5 		ldr	r0, .L688+112
 7598 4338 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7599              	.LVL634:
2998:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7600              		.loc 1 2998 0
 7601 433c 000050E3 		cmp	r0, #0
 7602 4340 0200001A 		bne	.L660
3004:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 7603              		.loc 1 3004 0
 7604 4344 8300A0E3 		mov	r0, #131
 7605              	.LVL635:
 7606 4348 FEFFFFEB 		bl	CyU3PUsbFlushEp
 7607 434c EDFFFFEA 		b	.L636
 7608              	.L660:
 7609              	.LBB264:
 7610              	.LBB265:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7611              		.loc 1 1801 0
 7612 4350 40169FE5 		ldr	r1, .L688+124
 7613 4354 0400A0E3 		mov	r0, #4
 7614 4358 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7615              		.loc 1 1802 0
 7616 435c FA0FA0E3 		mov	r0, #1000
 7617 4360 FEFFFFEB 		bl	_tx_thread_sleep
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7618              		.loc 1 1801 0
 7619 4364 2C169FE5 		ldr	r1, .L688+124
 7620 4368 0400A0E3 		mov	r0, #4
 7621 436c FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7622              		.loc 1 1802 0
 7623 4370 FA0FA0E3 		mov	r0, #1000
 7624 4374 FEFFFFEB 		bl	_tx_thread_sleep
 7625 4378 F4FFFFEA 		b	.L660
 7626              	.L635:
 7627              	.LBE265:
 7628              	.LBE264:
3012:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 7629              		.loc 1 3012 0
 7630 437c 0110A0E3 		mov	r1, #1
 7631 4380 0220A0E3 		mov	r2, #2
 7632 4384 B4308DE2 		add	r3, sp, #180
 7633 4388 A0059FE5 		ldr	r0, .L688+20
 7634 438c 00808DE5 		str	r8, [sp, #0]
 7635 4390 FEFFFFEB 		bl	_txe_event_flags_get
3016:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 7636              		.loc 1 3016 0
 7637 4394 0620A0E1 		mov	r2, r6
 7638 4398 EC059FE5 		ldr	r0, .L688+112
 7639 439c 0610A0E1 		mov	r1, r6
 7640 43a0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7641              	.LVL636:
3017:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7642              		.loc 1 3017 0
 7643 43a4 002050E2 		subs	r2, r0, #0
 7644 43a8 6500001A 		bne	.L679
3025:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 7645              		.loc 1 3025 0
 7646 43ac 280095E5 		ldr	r0, [r5, #40]
 7647              	.LVL637:
 7648 43b0 000050E3 		cmp	r0, #0
 7649 43b4 5A00001A 		bne	.L641
 7650              	.LVL638:
 7651              	.LBB266:
 7652              	.LBB267:
2728:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7653              		.loc 1 2728 0
 7654 43b8 4830D5E5 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 7655 43bc 030053E3 		cmp	r3, #3
 7656 43c0 4700000A 		beq	.L680
2733:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 7657              		.loc 1 2733 0
 7658 43c4 020053E3 		cmp	r3, #2
 7659 43c8 2900000A 		beq	.L681
 7660              	.LVL639:
 7661              	.L644:
 7662              	.LBE267:
 7663              	.LBE266:
3061:../uvc.c      ****                     gpif_initialized = CyTrue;
 7664              		.loc 1 3061 0
 7665 43cc 0120A0E3 		mov	r2, #1
 7666 43d0 282084E5 		str	r2, [r4, #40]
3062:../uvc.c      ****                     CyU3PThreadSleep(200);
 7667              		.loc 1 3062 0
 7668 43d4 C800A0E3 		mov	r0, #200
 7669 43d8 FEFFFFEB 		bl	_tx_thread_sleep
 7670 43dc 8EFFFFEA 		b	.L613
 7671              	.LVL640:
 7672              	.L676:
 7673              	.LBB273:
 7674              	.LBB225:
2678:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 7675              		.loc 1 2678 0
 7676 43e0 0400A0E3 		mov	r0, #4
 7677              	.LVL641:
 7678 43e4 C0159FE5 		ldr	r1, .L688+144
 7679 43e8 FEFFFFEB 		bl	CyU3PDebugPrint
 7680              	.LVL642:
 7681              	.L607:
 7682              	.LBB234:
 7683              	.LBB235:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7684              		.loc 1 1801 0
 7685 43ec A4159FE5 		ldr	r1, .L688+124
 7686 43f0 0400A0E3 		mov	r0, #4
 7687 43f4 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7688              		.loc 1 1802 0
 7689 43f8 FA0FA0E3 		mov	r0, #1000
 7690 43fc FEFFFFEB 		bl	_tx_thread_sleep
 7691 4400 F9FFFFEA 		b	.L607
 7692              	.LVL643:
 7693              	.L675:
 7694              	.LBE235:
 7695              	.LBE234:
2587:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 7696              		.loc 1 2587 0
 7697 4404 0400A0E3 		mov	r0, #4
 7698              	.LVL644:
 7699 4408 A0159FE5 		ldr	r1, .L688+148
 7700 440c FEFFFFEB 		bl	CyU3PDebugPrint
 7701              	.LVL645:
 7702              	.L605:
 7703              	.LBB232:
 7704              	.LBB233:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7705              		.loc 1 1801 0
 7706 4410 80159FE5 		ldr	r1, .L688+124
 7707 4414 0400A0E3 		mov	r0, #4
 7708 4418 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7709              		.loc 1 1802 0
 7710 441c FA0FA0E3 		mov	r0, #1000
 7711 4420 FEFFFFEB 		bl	_tx_thread_sleep
 7712 4424 F9FFFFEA 		b	.L605
 7713              	.LVL646:
 7714              	.L674:
 7715              	.LBE233:
 7716              	.LBE232:
2563:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 7717              		.loc 1 2563 0
 7718 4428 040080E2 		add	r0, r0, #4
 7719 442c 80159FE5 		ldr	r1, .L688+152
 7720 4430 FEFFFFEB 		bl	CyU3PDebugPrint
 7721              	.LVL647:
 7722              	.L603:
 7723              	.LBB230:
 7724              	.LBB231:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7725              		.loc 1 1801 0
 7726 4434 5C159FE5 		ldr	r1, .L688+124
 7727 4438 0400A0E3 		mov	r0, #4
 7728 443c FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7729              		.loc 1 1802 0
 7730 4440 FA0FA0E3 		mov	r0, #1000
 7731 4444 FEFFFFEB 		bl	_tx_thread_sleep
 7732 4448 F9FFFFEA 		b	.L603
 7733              	.LVL648:
 7734              	.L673:
 7735              	.LBE231:
 7736              	.LBE230:
2556:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 7737              		.loc 1 2556 0
 7738 444c 0400A0E3 		mov	r0, #4
 7739 4450 60159FE5 		ldr	r1, .L688+156
 7740 4454 0620A0E1 		mov	r2, r6
 7741 4458 FEFFFFEB 		bl	CyU3PDebugPrint
 7742              	.L601:
 7743              	.LBB228:
 7744              	.LBB229:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7745              		.loc 1 1801 0
 7746 445c 34159FE5 		ldr	r1, .L688+124
 7747 4460 0400A0E3 		mov	r0, #4
 7748 4464 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7749              		.loc 1 1802 0
 7750 4468 FA0FA0E3 		mov	r0, #1000
 7751 446c FEFFFFEB 		bl	_tx_thread_sleep
 7752 4470 F9FFFFEA 		b	.L601
 7753              	.LVL649:
 7754              	.L681:
 7755              	.LBE229:
 7756              	.LBE228:
 7757              	.LBE225:
 7758              	.LBE273:
 7759              	.LBB274:
 7760              	.LBB272:
2735:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 7761              		.loc 1 2735 0
 7762 4474 40159FE5 		ldr	r1, .L688+160
 7763 4478 0100A0E3 		mov	r0, #1
 7764 447c FEFFFFEB 		bl	CyU3PDebugPrint
 7765              	.LVL650:
2736:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7766              		.loc 1 2736 0
 7767 4480 38059FE5 		ldr	r0, .L688+164
 7768 4484 FEFFFFEB 		bl	CyU3PGpifLoad
 7769 4488 0020A0E1 		mov	r2, r0
 7770              	.LVL651:
 7771              	.L643:
2738:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7772              		.loc 1 2738 0
 7773 448c 000052E3 		cmp	r2, #0
 7774 4490 1A00001A 		bne	.L682
2746:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 7775              		.loc 1 2746 0
 7776 4494 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 7777 4498 030053E3 		cmp	r3, #3
 7778 449c 0100000A 		beq	.L661
2750:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 7779              		.loc 1 2750 0
 7780 44a0 020053E3 		cmp	r3, #2
 7781 44a4 C8FFFF1A 		bne	.L644
 7782              	.L661:
2752:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7783              		.loc 1 2752 0
 7784 44a8 0200A0E1 		mov	r0, r2
 7785              	.LVL652:
 7786 44ac 0210A0E1 		mov	r1, r2
 7787 44b0 FEFFFFEB 		bl	CyU3PGpifSMStart
 7788              	.LVL653:
2754:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7789              		.loc 1 2754 0
 7790 44b4 000050E3 		cmp	r0, #0
2752:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 7791              		.loc 1 2752 0
 7792 44b8 0020A0E1 		mov	r2, r0
 7793              	.LVL654:
2754:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7794              		.loc 1 2754 0
 7795 44bc C2FFFF0A 		beq	.L644
2757:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 7796              		.loc 1 2757 0
 7797 44c0 0400A0E3 		mov	r0, #4
 7798              	.LVL655:
 7799 44c4 F8149FE5 		ldr	r1, .L688+168
 7800 44c8 FEFFFFEB 		bl	CyU3PDebugPrint
 7801              	.LVL656:
 7802              	.L649:
 7803              	.LBB268:
 7804              	.LBB269:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7805              		.loc 1 1801 0
 7806 44cc C4149FE5 		ldr	r1, .L688+124
 7807 44d0 0400A0E3 		mov	r0, #4
 7808 44d4 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7809              		.loc 1 1802 0
 7810 44d8 FA0FA0E3 		mov	r0, #1000
 7811 44dc FEFFFFEB 		bl	_tx_thread_sleep
 7812 44e0 F9FFFFEA 		b	.L649
 7813              	.LVL657:
 7814              	.L680:
 7815              	.LBE269:
 7816              	.LBE268:
2730:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 7817              		.loc 1 2730 0
 7818 44e4 DC149FE5 		ldr	r1, .L688+172
 7819 44e8 0100A0E3 		mov	r0, #1
 7820 44ec FEFFFFEB 		bl	CyU3PDebugPrint
 7821              	.LVL658:
2731:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7822              		.loc 1 2731 0
 7823 44f0 D4049FE5 		ldr	r0, .L688+176
 7824 44f4 FEFFFFEB 		bl	CyU3PGpifLoad
 7825 44f8 0020A0E1 		mov	r2, r0
 7826              	.LVL659:
 7827 44fc E2FFFFEA 		b	.L643
 7828              	.L682:
2741:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 7829              		.loc 1 2741 0
 7830 4500 0400A0E3 		mov	r0, #4
 7831              	.LVL660:
 7832 4504 C4149FE5 		ldr	r1, .L688+180
 7833 4508 FEFFFFEB 		bl	CyU3PDebugPrint
 7834              	.LVL661:
 7835              	.L646:
 7836              	.LBB270:
 7837              	.LBB271:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7838              		.loc 1 1801 0
 7839 450c 84149FE5 		ldr	r1, .L688+124
 7840 4510 0400A0E3 		mov	r0, #4
 7841 4514 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7842              		.loc 1 1802 0
 7843 4518 FA0FA0E3 		mov	r0, #1000
 7844 451c FEFFFFEB 		bl	_tx_thread_sleep
 7845 4520 F9FFFFEA 		b	.L646
 7846              	.LVL662:
 7847              	.L641:
 7848              	.LBE271:
 7849              	.LBE270:
 7850              	.LBE272:
 7851              	.LBE274:
3069:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 7852              		.loc 1 3069 0
 7853 4524 54049FE5 		ldr	r0, .L688+100
 7854 4528 02C0A0E3 		mov	ip, #2
 7855 452c 0610A0E1 		mov	r1, r6
 7856 4530 0020A0E1 		mov	r2, r0
 7857              	.LVL663:
 7858 4534 0630A0E1 		mov	r3, r6
 7859 4538 00C08DE5 		str	ip, [sp, #0]
 7860 453c FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7861 4540 35FFFFEA 		b	.L613
 7862              	.LVL664:
 7863              	.L679:
3020:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 7864              		.loc 1 3020 0
 7865 4544 0400A0E3 		mov	r0, #4
 7866              	.LVL665:
 7867 4548 84149FE5 		ldr	r1, .L688+184
 7868 454c FEFFFFEB 		bl	CyU3PDebugPrint
 7869              	.LVL666:
 7870              	.L640:
 7871              	.LBB275:
 7872              	.LBB276:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7873              		.loc 1 1801 0
 7874 4550 40149FE5 		ldr	r1, .L688+124
 7875 4554 0400A0E3 		mov	r0, #4
 7876 4558 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7877              		.loc 1 1802 0
 7878 455c FA0FA0E3 		mov	r0, #1000
 7879 4560 FEFFFFEB 		bl	_tx_thread_sleep
 7880 4564 F9FFFFEA 		b	.L640
 7881              	.LVL667:
 7882              	.L672:
 7883              	.LBE276:
 7884              	.LBE275:
 7885              	.LBB277:
 7886              	.LBB261:
2535:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 7887              		.loc 1 2535 0
 7888 4568 0400A0E3 		mov	r0, #4
 7889              	.LVL668:
 7890 456c 34149FE5 		ldr	r1, .L688+140
 7891 4570 0320A0E1 		mov	r2, r3
 7892 4574 FEFFFFEB 		bl	CyU3PDebugPrint
 7893              	.LVL669:
 7894              	.L599:
 7895              	.LBB246:
 7896              	.LBB247:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7897              		.loc 1 1801 0
 7898 4578 18149FE5 		ldr	r1, .L688+124
 7899 457c 0400A0E3 		mov	r0, #4
 7900 4580 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7901              		.loc 1 1802 0
 7902 4584 FA0FA0E3 		mov	r0, #1000
 7903 4588 FEFFFFEB 		bl	_tx_thread_sleep
 7904 458c F9FFFFEA 		b	.L599
 7905              	.LVL670:
 7906              	.L671:
 7907              	.LBE247:
 7908              	.LBE246:
2490:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7909              		.loc 1 2490 0
 7910 4590 0400A0E3 		mov	r0, #4
 7911              	.LVL671:
 7912 4594 3C149FE5 		ldr	r1, .L688+188
 7913 4598 FEFFFFEB 		bl	CyU3PDebugPrint
 7914              	.LVL672:
 7915              	.L597:
 7916              	.LBB248:
 7917              	.LBB249:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7918              		.loc 1 1801 0
 7919 459c F4139FE5 		ldr	r1, .L688+124
 7920 45a0 0400A0E3 		mov	r0, #4
 7921 45a4 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7922              		.loc 1 1802 0
 7923 45a8 FA0FA0E3 		mov	r0, #1000
 7924 45ac FEFFFFEB 		bl	_tx_thread_sleep
 7925 45b0 F9FFFFEA 		b	.L597
 7926              	.LVL673:
 7927              	.L670:
 7928              	.LBE249:
 7929              	.LBE248:
2469:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 7930              		.loc 1 2469 0
 7931 45b4 0400A0E3 		mov	r0, #4
 7932              	.LVL674:
 7933 45b8 1C149FE5 		ldr	r1, .L688+192
 7934 45bc FEFFFFEB 		bl	CyU3PDebugPrint
 7935              	.LVL675:
 7936              	.L595:
 7937              	.LBB250:
 7938              	.LBB251:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7939              		.loc 1 1801 0
 7940 45c0 D0139FE5 		ldr	r1, .L688+124
 7941 45c4 0400A0E3 		mov	r0, #4
 7942 45c8 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7943              		.loc 1 1802 0
 7944 45cc FA0FA0E3 		mov	r0, #1000
 7945 45d0 FEFFFFEB 		bl	_tx_thread_sleep
 7946 45d4 F9FFFFEA 		b	.L595
 7947              	.LVL676:
 7948              	.L669:
 7949              	.LBE251:
 7950              	.LBE250:
2456:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 7951              		.loc 1 2456 0
 7952 45d8 0400A0E3 		mov	r0, #4
 7953              	.LVL677:
 7954 45dc FC139FE5 		ldr	r1, .L688+196
 7955 45e0 FEFFFFEB 		bl	CyU3PDebugPrint
 7956              	.LVL678:
 7957              	.L593:
 7958              	.LBB252:
 7959              	.LBB253:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7960              		.loc 1 1801 0
 7961 45e4 AC139FE5 		ldr	r1, .L688+124
 7962 45e8 0400A0E3 		mov	r0, #4
 7963 45ec FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7964              		.loc 1 1802 0
 7965 45f0 FA0FA0E3 		mov	r0, #1000
 7966 45f4 FEFFFFEB 		bl	_tx_thread_sleep
 7967 45f8 F9FFFFEA 		b	.L593
 7968              	.LVL679:
 7969              	.L667:
 7970              	.LBE253:
 7971              	.LBE252:
2428:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 7972              		.loc 1 2428 0
 7973 45fc 0400A0E3 		mov	r0, #4
 7974              	.LVL680:
 7975 4600 DC139FE5 		ldr	r1, .L688+200
 7976 4604 FEFFFFEB 		bl	CyU3PDebugPrint
 7977              	.LVL681:
 7978              	.L589:
 7979              	.LBB254:
 7980              	.LBB255:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7981              		.loc 1 1801 0
 7982 4608 88139FE5 		ldr	r1, .L688+124
 7983 460c 0400A0E3 		mov	r0, #4
 7984 4610 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 7985              		.loc 1 1802 0
 7986 4614 FA0FA0E3 		mov	r0, #1000
 7987 4618 FEFFFFEB 		bl	_tx_thread_sleep
 7988 461c F9FFFFEA 		b	.L589
 7989              	.LVL682:
 7990              	.L666:
 7991              	.LBE255:
 7992              	.LBE254:
2415:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 7993              		.loc 1 2415 0
 7994 4620 0400A0E3 		mov	r0, #4
 7995              	.LVL683:
 7996 4624 BC139FE5 		ldr	r1, .L688+204
 7997 4628 FEFFFFEB 		bl	CyU3PDebugPrint
 7998              	.LVL684:
 7999              	.L587:
 8000              	.LBB256:
 8001              	.LBB257:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8002              		.loc 1 1801 0
 8003 462c 64139FE5 		ldr	r1, .L688+124
 8004 4630 0400A0E3 		mov	r0, #4
 8005 4634 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 8006              		.loc 1 1802 0
 8007 4638 FA0FA0E3 		mov	r0, #1000
 8008 463c FEFFFFEB 		bl	_tx_thread_sleep
 8009 4640 F9FFFFEA 		b	.L587
 8010              	.LVL685:
 8011              	.L668:
 8012              	.LBE257:
 8013              	.LBE256:
2442:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 8014              		.loc 1 2442 0
 8015 4644 0400A0E3 		mov	r0, #4
 8016              	.LVL686:
 8017 4648 9C139FE5 		ldr	r1, .L688+208
 8018 464c FEFFFFEB 		bl	CyU3PDebugPrint
 8019              	.LVL687:
 8020              	.L591:
 8021              	.LBB258:
 8022              	.LBB259:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8023              		.loc 1 1801 0
 8024 4650 40139FE5 		ldr	r1, .L688+124
 8025 4654 0400A0E3 		mov	r0, #4
 8026 4658 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 8027              		.loc 1 1802 0
 8028 465c FA0FA0E3 		mov	r0, #1000
 8029 4660 FEFFFFEB 		bl	_tx_thread_sleep
 8030 4664 F9FFFFEA 		b	.L591
 8031              	.LVL688:
 8032              	.L677:
 8033              	.LBE259:
 8034              	.LBE258:
 8035              	.LBE261:
 8036              	.LBE277:
2879:../uvc.c      ****                 prodCount = 0;
 8037              		.loc 1 2879 0
 8038 4668 B064C5E1 		strh	r6, [r5, #64]	@ movhi
2894:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8039              		.loc 1 2894 0
 8040 466c 08039FE5 		ldr	r0, .L688+96
2880:../uvc.c      ****                 consCount = 0;
 8041              		.loc 1 2880 0
 8042 4670 B264C5E1 		strh	r6, [r5, #66]	@ movhi
2894:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8043              		.loc 1 2894 0
 8044 4674 0010E0E3 		mvn	r1, #0
2876:../uvc.c      ****             	fb=0;
 8045              		.loc 1 2876 0
 8046 4678 B463C5E1 		strh	r6, [r5, #52]	@ movhi
2877:../uvc.c      ****             	pb=0;
 8047              		.loc 1 2877 0
 8048 467c B663C5E1 		strh	r6, [r5, #54]	@ movhi
2878:../uvc.c      ****             	pbc=0;
 8049              		.loc 1 2878 0
 8050 4680 B863C5E1 		strh	r6, [r5, #56]	@ movhi
2881:../uvc.c      ****                 hitFV     = CyFalse;
 8051              		.loc 1 2881 0
 8052 4684 3C6085E5 		str	r6, [r5, #60]
2894:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 8053              		.loc 1 2894 0
 8054 4688 FEFFFFEB 		bl	_txe_mutex_get
2895:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 8055              		.loc 1 2895 0
 8056 468c 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 8057 4690 012020E2 		eor	r2, r0, #1
 8058 4694 8124C7E5 		strb	r2, [r7, #1153]
2897:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8059              		.loc 1 2897 0
 8060 4698 3AC0D5E5 		ldrb	ip, [r5, #58]	@ zero_extendqisi2
 8061 469c F0005CE3 		cmp	ip, #240
 8062 46a0 1800000A 		beq	.L683
 8063              	.L614:
2905:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 8064              		.loc 1 2905 0
 8065 46a4 3AA0D4E5 		ldrb	sl, [r4, #58]	@ zero_extendqisi2
 8066 46a8 FF005AE3 		cmp	sl, #255
 8067 46ac 4000000A 		beq	.L684
2917:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 8068              		.loc 1 2917 0
 8069 46b0 3A00D5E5 		ldrb	r0, [r5, #58]	@ zero_extendqisi2
 8070 46b4 AA0050E3 		cmp	r0, #170
 8071 46b8 2F00000A 		beq	.L685
 8072              	.L615:
2955:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 8073              		.loc 1 2955 0
 8074 46bc B8029FE5 		ldr	r0, .L688+96
 8075 46c0 FEFFFFEB 		bl	_txe_mutex_put
2957:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8076              		.loc 1 2957 0
 8077 46c4 C0029FE5 		ldr	r0, .L688+112
 8078 46c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8079              	.LVL689:
2958:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8080              		.loc 1 2958 0
 8081 46cc 002050E2 		subs	r2, r0, #0
 8082 46d0 2000001A 		bne	.L686
2965:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8083              		.loc 1 2965 0
 8084 46d4 0210A0E1 		mov	r1, r2
 8085 46d8 AC029FE5 		ldr	r0, .L688+112
 8086              	.LVL690:
 8087 46dc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8088              	.LVL691:
2966:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8089              		.loc 1 2966 0
 8090 46e0 002050E2 		subs	r2, r0, #0
 8091 46e4 1200001A 		bne	.L687
2974:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8092              		.loc 1 2974 0
 8093 46e8 90029FE5 		ldr	r0, .L688+100
 8094              	.LVL692:
 8095 46ec 0210A0E1 		mov	r1, r2
 8096 46f0 02A0A0E3 		mov	sl, #2
 8097 46f4 0020A0E1 		mov	r2, r0
 8098              	.LVL693:
 8099 46f8 0130A0E1 		mov	r3, r1
 8100 46fc 00A08DE5 		str	sl, [sp, #0]
 8101 4700 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8102              	.LVL694:
 8103 4704 C4FEFFEA 		b	.L613
 8104              	.L683:
2897:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8105              		.loc 1 2897 0 discriminator 1
 8106 4708 20029FE5 		ldr	r0, .L688+20
 8107 470c 8010A0E3 		mov	r1, #128
 8108 4710 0320A0E3 		mov	r2, #3
 8109 4714 B4308DE2 		add	r3, sp, #180
 8110 4718 00608DE5 		str	r6, [sp, #0]
 8111 471c FEFFFFEB 		bl	_txe_event_flags_get
 8112 4720 000050E3 		cmp	r0, #0
2902:../uvc.c      ****                 		stiflag = 0xFF;
 8113              		.loc 1 2902 0 discriminator 1
 8114 4724 3A80C505 		streqb	r8, [r5, #58]
2903:../uvc.c      ****                 		IMcount = 0;
 8115              		.loc 1 2903 0 discriminator 1
 8116 4728 A160C505 		streqb	r6, [r5, #161]
2897:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 8117              		.loc 1 2897 0 discriminator 1
 8118 472c E2FFFF0A 		beq	.L615
 8119 4730 DBFFFFEA 		b	.L614
 8120              	.LVL695:
 8121              	.L687:
2968:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 8122              		.loc 1 2968 0
 8123 4734 0400A0E3 		mov	r0, #4
 8124              	.LVL696:
 8125 4738 B0129FE5 		ldr	r1, .L688+212
 8126 473c FEFFFFEB 		bl	CyU3PDebugPrint
 8127              	.LVL697:
 8128              	.L634:
 8129              	.LBB278:
 8130              	.LBB279:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8131              		.loc 1 1801 0
 8132 4740 50129FE5 		ldr	r1, .L688+124
 8133 4744 0400A0E3 		mov	r0, #4
 8134 4748 FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 8135              		.loc 1 1802 0
 8136 474c FA0FA0E3 		mov	r0, #1000
 8137 4750 FEFFFFEB 		bl	_tx_thread_sleep
 8138 4754 F9FFFFEA 		b	.L634
 8139              	.LVL698:
 8140              	.L686:
 8141              	.LBE279:
 8142              	.LBE278:
2960:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 8143              		.loc 1 2960 0
 8144 4758 0400A0E3 		mov	r0, #4
 8145              	.LVL699:
 8146 475c 90129FE5 		ldr	r1, .L688+216
 8147 4760 FEFFFFEB 		bl	CyU3PDebugPrint
 8148              	.LVL700:
 8149              	.L632:
 8150              	.LBB280:
 8151              	.LBB281:
1801:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8152              		.loc 1 1801 0
 8153 4764 2C129FE5 		ldr	r1, .L688+124
 8154 4768 0400A0E3 		mov	r0, #4
 8155 476c FEFFFFEB 		bl	CyU3PDebugPrint
1802:../uvc.c      ****         CyU3PThreadSleep (1000);
 8156              		.loc 1 1802 0
 8157 4770 FA0FA0E3 		mov	r0, #1000
 8158 4774 FEFFFFEB 		bl	_tx_thread_sleep
 8159 4778 F9FFFFEA 		b	.L632
 8160              	.L685:
 8161              	.LBE281:
 8162              	.LBE280:
2923:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 8163              		.loc 1 2923 0
 8164 477c A1E0D5E5 		ldrb	lr, [r5, #161]	@ zero_extendqisi2
 8165 4780 01A08EE2 		add	sl, lr, #1
 8166 4784 02005EE3 		cmp	lr, #2
 8167 4788 A1A0C5E5 		strb	sl, [r5, #161]
 8168 478c CAFFFF9A 		bls	.L615
2925:../uvc.c      ****                     switch (setRes)
 8169              		.loc 1 2925 0
 8170 4790 7D30D5E5 		ldrb	r3, [r5, #125]	@ zero_extendqisi2
 8171 4794 011043E2 		sub	r1, r3, #1
 8172 4798 030051E3 		cmp	r1, #3
 8173 479c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 8174 47a0 230000EA 		b	.L617
 8175              	.L622:
 8176 47a4 94480000 		.word	.L618
 8177 47a8 D8480000 		.word	.L619
 8178 47ac 40480000 		.word	.L620
 8179 47b0 E4470000 		.word	.L621
 8180              	.L684:
2907:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 8181              		.loc 1 2907 0
 8182 47b4 A110D5E5 		ldrb	r1, [r5, #161]	@ zero_extendqisi2
 8183 47b8 01E081E2 		add	lr, r1, #1
 8184 47bc 020051E3 		cmp	r1, #2
 8185 47c0 A1E0C5E5 		strb	lr, [r5, #161]
 8186 47c4 BCFFFF9A 		bls	.L615
2908:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8187              		.loc 1 2908 0
 8188 47c8 8124D7E5 		ldrb	r2, [r7, #1153]	@ zero_extendqisi2
2909:../uvc.c      ****                 		stiflag = 0x0F;
 8189              		.loc 1 2909 0
 8190 47cc 0F30A0E3 		mov	r3, #15
2908:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 8191              		.loc 1 2908 0
 8192 47d0 20C082E3 		orr	ip, r2, #32
 8193 47d4 81C4C7E5 		strb	ip, [r7, #1153]
2910:../uvc.c      ****                 		IMcount = 0;
 8194              		.loc 1 2910 0
 8195 47d8 A160C5E5 		strb	r6, [r5, #161]
2909:../uvc.c      ****                 		stiflag = 0x0F;
 8196              		.loc 1 2909 0
 8197 47dc 3A30C5E5 		strb	r3, [r5, #58]
 8198 47e0 B5FFFFEA 		b	.L615
 8199              	.L621:
2943:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 8200              		.loc 1 2943 0
 8201 47e4 58E094E5 		ldr	lr, [r4, #88]
 8202 47e8 8C34D7E5 		ldrb	r3, [r7, #1164]	@ zero_extendqisi2
 8203 47ec 00005EE3 		cmp	lr, #0
 8204 47f0 F4E0A003 		moveq	lr, #244
 8205 47f4 74E0A013 		movne	lr, #116
 8206 47f8 03208EE1 		orr	r2, lr, r3
 8207 47fc 3010A0E3 		mov	r1, #48
 8208 4800 5230A0E3 		mov	r3, #82
 8209 4804 0100A0E3 		mov	r0, #1
 8210 4808 FEFFFFEB 		bl	SensorSetIrisControl
2945:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 8211              		.loc 1 2945 0
 8212 480c 58C094E5 		ldr	ip, [r4, #88]
 8213 4810 8C24D7E5 		ldrb	r2, [r7, #1164]	@ zero_extendqisi2
 8214 4814 00005CE3 		cmp	ip, #0
 8215 4818 F4C0A003 		moveq	ip, #244
 8216 481c 74C0A013 		movne	ip, #116
 8217 4820 583094E5 		ldr	r3, [r4, #88]
 8218 4824 0400A0E3 		mov	r0, #4
 8219 4828 C8119FE5 		ldr	r1, .L688+220
 8220 482c 02208CE1 		orr	r2, ip, r2
 8221 4830 FEFFFFEB 		bl	CyU3PDebugPrint
 8222              	.L617:
2950:../uvc.c      ****                     IMcount = 0;
 8223              		.loc 1 2950 0
 8224 4834 A160C4E5 		strb	r6, [r4, #161]
2952:../uvc.c      ****                 	stiflag = 0x0;
 8225              		.loc 1 2952 0
 8226 4838 3A60C4E5 		strb	r6, [r4, #58]
 8227 483c 9EFFFFEA 		b	.L615
 8228              	.L620:
2938:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 8229              		.loc 1 2938 0
 8230 4840 580094E5 		ldr	r0, [r4, #88]
 8231 4844 8CA4D7E5 		ldrb	sl, [r7, #1164]	@ zero_extendqisi2
 8232 4848 000050E3 		cmp	r0, #0
 8233 484c C400A003 		moveq	r0, #196
 8234 4850 4400A013 		movne	r0, #68
 8235 4854 0A2080E1 		orr	r2, r0, sl
 8236 4858 3010A0E3 		mov	r1, #48
 8237 485c 5230A0E3 		mov	r3, #82
 8238 4860 0100A0E3 		mov	r0, #1
 8239 4864 FEFFFFEB 		bl	SensorSetIrisControl
2940:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 8240              		.loc 1 2940 0
 8241 4868 582094E5 		ldr	r2, [r4, #88]
 8242 486c 8CC4D7E5 		ldrb	ip, [r7, #1164]	@ zero_extendqisi2
 8243 4870 000052E3 		cmp	r2, #0
 8244 4874 C420A003 		moveq	r2, #196
 8245 4878 4420A013 		movne	r2, #68
 8246 487c 583094E5 		ldr	r3, [r4, #88]
 8247 4880 70119FE5 		ldr	r1, .L688+220
 8248 4884 0C2082E1 		orr	r2, r2, ip
 8249 4888 0400A0E3 		mov	r0, #4
 8250 488c FEFFFFEB 		bl	CyU3PDebugPrint
2941:../uvc.c      ****                  		break;
 8251              		.loc 1 2941 0
 8252 4890 E7FFFFEA 		b	.L617
 8253              	.L618:
2928:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 8254              		.loc 1 2928 0
 8255 4894 582094E5 		ldr	r2, [r4, #88]
 8256 4898 3010A0E3 		mov	r1, #48
 8257 489c 000052E3 		cmp	r2, #0
 8258 48a0 E420A003 		moveq	r2, #228
 8259 48a4 6420A013 		movne	r2, #100
 8260 48a8 5230A0E3 		mov	r3, #82
 8261 48ac 0100A0E3 		mov	r0, #1
 8262 48b0 FEFFFFEB 		bl	SensorSetIrisControl
2930:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 8263              		.loc 1 2930 0
 8264 48b4 582094E5 		ldr	r2, [r4, #88]
 8265 48b8 38119FE5 		ldr	r1, .L688+220
 8266 48bc 000052E3 		cmp	r2, #0
 8267 48c0 583094E5 		ldr	r3, [r4, #88]
 8268 48c4 E420A003 		moveq	r2, #228
 8269 48c8 6420A013 		movne	r2, #100
 8270 48cc 0400A0E3 		mov	r0, #4
 8271 48d0 FEFFFFEB 		bl	CyU3PDebugPrint
2931:../uvc.c      ****                  		break;
 8272              		.loc 1 2931 0
 8273 48d4 D6FFFFEA 		b	.L617
 8274              	.L619:
2933:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 8275              		.loc 1 2933 0
 8276 48d8 582094E5 		ldr	r2, [r4, #88]
 8277 48dc 3010A0E3 		mov	r1, #48
 8278 48e0 000052E3 		cmp	r2, #0
 8279 48e4 D420A003 		moveq	r2, #212
 8280 48e8 5420A013 		movne	r2, #84
 8281 48ec 5230A0E3 		mov	r3, #82
 8282 48f0 0100A0E3 		mov	r0, #1
 8283 48f4 FEFFFFEB 		bl	SensorSetIrisControl
2935:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 8284              		.loc 1 2935 0
 8285 48f8 582094E5 		ldr	r2, [r4, #88]
 8286 48fc F4109FE5 		ldr	r1, .L688+220
 8287 4900 000052E3 		cmp	r2, #0
 8288 4904 583094E5 		ldr	r3, [r4, #88]
 8289 4908 D420A003 		moveq	r2, #212
 8290 490c 5420A013 		movne	r2, #84
 8291 4910 0400A0E3 		mov	r0, #4
 8292 4914 FEFFFFEB 		bl	CyU3PDebugPrint
2936:../uvc.c      ****                  		break;
 8293              		.loc 1 2936 0
 8294 4918 C5FFFFEA 		b	.L617
 8295              	.L689:
 8296              		.align	2
 8297              	.L688:
 8298 491c 28080000 		.word	.LC46
 8299 4920 00C20100 		.word	115200
 8300 4924 48080000 		.word	.LC47
 8301 4928 A0860100 		.word	100000
 8302 492c 64080000 		.word	.LC48
 8303 4930 00000000 		.word	.LANCHOR0
 8304 4934 00000000 		.word	CyFxGpifCB
 8305 4938 88130000 		.word	5000
 8306 493c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 8307 4940 00000000 		.word	CyFxUVCApplnUSBEventCB
 8308 4944 00000000 		.word	CyFxUSBDeviceDscr
 8309 4948 00000000 		.word	CyFxUSBDeviceDscrSS
 8310 494c 00000000 		.word	CyFxUSBDeviceQualDscr
 8311 4950 00000000 		.word	CyFxUSBBOSDscr
 8312 4954 00000000 		.word	CyFxUSBHSConfigDscr
 8313 4958 00000000 		.word	CyFxUSBFSConfigDscr
 8314 495c 00000000 		.word	CyFxUSBSSConfigDscr
 8315 4960 00000000 		.word	CyFxUSBStringLangIDDscr
 8316 4964 00000000 		.word	CyFxUSBManufactureDscr
 8317 4968 00000000 		.word	CyFxUSBProductDscr
 8318 496c 013F0000 		.word	16129
 8319 4970 02030000 		.word	770
 8320 4974 00000000 		.word	glChHandleInterStat
 8321 4978 00000000 		.word	glInterStaBuffer
 8322 497c 00000000 		.word	imgHdMux
 8323 4980 01010000 		.word	257
 8324 4984 03030000 		.word	771
 8325 4988 00000000 		.word	CyFxUvcApplnDmaCallback
 8326 498c 00000000 		.word	glChHandleUVCStream
 8327 4990 00000000 		.word	.LANCHOR1
 8328 4994 80080000 		.word	.LC49
 8329 4998 F0010000 		.word	.LC13
 8330 499c D0080000 		.word	.LC51
 8331 49a0 AC080000 		.word	.LC50
 8332 49a4 F8080000 		.word	.LC52
 8333 49a8 500A0000 		.word	.LC59
 8334 49ac 2C0B0000 		.word	.LC63
 8335 49b0 FC0A0000 		.word	.LC62
 8336 49b4 C40A0000 		.word	.LC61
 8337 49b8 840A0000 		.word	.LC60
 8338 49bc 1C0C0000 		.word	.LC69
 8339 49c0 FC000000 		.word	.LANCHOR2+252
 8340 49c4 640C0000 		.word	.LC71
 8341 49c8 0C0C0000 		.word	.LC68
 8342 49cc E0000000 		.word	.LANCHOR2+224
 8343 49d0 2C0C0000 		.word	.LC70
 8344 49d4 D80B0000 		.word	.LC67
 8345 49d8 200A0000 		.word	.LC58
 8346 49dc F0090000 		.word	.LC57
 8347 49e0 B8090000 		.word	.LC56
 8348 49e4 50090000 		.word	.LC54
 8349 49e8 24090000 		.word	.LC53
 8350 49ec 84090000 		.word	.LC55
 8351 49f0 A40B0000 		.word	.LC66
 8352 49f4 780B0000 		.word	.LC65
 8353 49f8 540B0000 		.word	.LC64
 8354              		.cfi_endproc
 8355              	.LFE19:
 8357              		.align	2
 8358              		.global	CyFxApplicationDefine
 8360              	CyFxApplicationDefine:
 8361              	.LFB27:
4409:../uvc.c      **** }
4410:../uvc.c      **** 
4411:../uvc.c      **** 
4412:../uvc.c      **** /*
4413:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4414:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4415:../uvc.c      ****  */
4416:../uvc.c      **** void
4417:../uvc.c      **** CyFxApplicationDefine (
4418:../uvc.c      ****         void)
4419:../uvc.c      **** {
 8362              		.loc 1 4419 0
 8363              		.cfi_startproc
 8364              		@ args = 0, pretend = 0, frame = 32
 8365              		@ frame_needed = 0, uses_anonymous_args = 0
 8366              	.LVL701:
 8367 49fc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8368              	.LCFI28:
 8369              		.cfi_def_cfa_offset 36
4420:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4421:../uvc.c      ****     uint32_t retThrdCreate;
4422:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4423:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4424:../uvc.c      **** 
4425:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4426:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8370              		.loc 1 4426 0
 8371 4a00 010AA0E3 		mov	r0, #4096
4419:../uvc.c      **** {
 8372              		.loc 1 4419 0
 8373 4a04 44D04DE2 		sub	sp, sp, #68
 8374              	.LCFI29:
 8375              		.cfi_def_cfa_offset 104
 8376              		.loc 1 4426 0
 8377              		.cfi_offset 14, -4
 8378              		.cfi_offset 11, -8
 8379              		.cfi_offset 10, -12
 8380              		.cfi_offset 9, -16
 8381              		.cfi_offset 8, -20
 8382              		.cfi_offset 7, -24
 8383              		.cfi_offset 6, -28
 8384              		.cfi_offset 5, -32
 8385              		.cfi_offset 4, -36
 8386 4a08 FEFFFFEB 		bl	CyU3PMemAlloc
 8387 4a0c 00A0A0E1 		mov	sl, r0
 8388              	.LVL702:
4427:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8389              		.loc 1 4427 0
 8390 4a10 010AA0E3 		mov	r0, #4096
 8391              	.LVL703:
 8392 4a14 FEFFFFEB 		bl	CyU3PMemAlloc
 8393 4a18 0090A0E1 		mov	r9, r0
 8394              	.LVL704:
4428:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8395              		.loc 1 4428 0
 8396 4a1c 010AA0E3 		mov	r0, #4096
 8397              	.LVL705:
 8398 4a20 FEFFFFEB 		bl	CyU3PMemAlloc
4429:../uvc.c      **** 
4430:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 8399              		.loc 1 4430 0
 8400 4a24 00005AE3 		cmp	sl, #0
 8401 4a28 00005913 		cmpne	r9, #0
 8402 4a2c 0070A013 		movne	r7, #0
 8403 4a30 0170A003 		moveq	r7, #1
4428:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 8404              		.loc 1 4428 0
 8405 4a34 00B0A0E1 		mov	fp, r0
 8406              	.LVL706:
 8407              		.loc 1 4430 0
 8408 4a38 0000001A 		bne	.L694
 8409              	.LVL707:
 8410              	.L691:
 8411              	.L693:
 8412 4a3c FEFFFFEA 		b	.L693
 8413              	.L694:
 8414              		.loc 1 4430 0 is_stmt 0 discriminator 1
 8415 4a40 000050E3 		cmp	r0, #0
 8416 4a44 FCFFFF0A 		beq	.L691
 8417              	.LVL708:
4431:../uvc.c      ****         goto fatalErrorHandler;
4432:../uvc.c      **** 
4433:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4434:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4435:../uvc.c      ****     char *staName = "I2CstaQue";
4436:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8418              		.loc 1 4436 0 is_stmt 1
 8419 4a48 38819FE5 		ldr	r8, .L695
 8420 4a4c 20408DE2 		add	r4, sp, #32
 8421 4a50 0400A0E1 		mov	r0, r4
 8422 4a54 4010A0E3 		mov	r1, #64
 8423 4a58 2C219FE5 		ldr	r2, .L695+4
 8424 4a5c 0730A0E1 		mov	r3, r7
 8425 4a60 0450A0E1 		mov	r5, r4
 8426 4a64 00808DE5 		str	r8, [sp, #0]
 8427 4a68 FEFFFFEB 		bl	cmdbufCreate
 8428 4a6c 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 8429 4a70 18619FE5 		ldr	r6, .L695+8
4437:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 8430              		.loc 1 4437 0
 8431 4a74 18C19FE5 		ldr	ip, .L695+12
4436:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8432              		.loc 1 4436 0
 8433 4a78 06E0A0E1 		mov	lr, r6
 8434 4a7c 0F00AEE8 		stmia	lr!, {r0, r1, r2, r3}
 8435              		.loc 1 4437 0
 8436 4a80 10819FE5 		ldr	r8, .L695+16
4436:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8437              		.loc 1 4436 0
 8438 4a84 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 8439              		.loc 1 4437 0
 8440 4a88 00C08DE5 		str	ip, [sp, #0]
4436:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 8441              		.loc 1 4436 0
 8442 4a8c 0F008EE8 		stmia	lr, {r0, r1, r2, r3}
 8443              		.loc 1 4437 0
 8444 4a90 04219FE5 		ldr	r2, .L695+20
 8445 4a94 0400A0E1 		mov	r0, r4
 8446 4a98 4010A0E3 		mov	r1, #64
 8447 4a9c 0130A0E3 		mov	r3, #1
 8448 4aa0 FEFFFFEB 		bl	cmdbufCreate
 8449 4aa4 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 8450 4aa8 08C0A0E1 		mov	ip, r8
 8451 4aac 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 8452 4ab0 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
4438:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4439:../uvc.c      **** 
4440:../uvc.c      **** 	/****** initialize command descriptor ***********/
4441:../uvc.c      **** 	cmdquInit(cmdQuptr);
4442:../uvc.c      **** 	cmdquInit(statQuptr);
4443:../uvc.c      **** 
4444:../uvc.c      ****     /* Create the UVC application thread. */
4445:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 8453              		.loc 1 4445 0
 8454 4ab4 0840A0E3 		mov	r4, #8
4437:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 8455              		.loc 1 4437 0
 8456 4ab8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4441:../uvc.c      **** 	cmdquInit(cmdQuptr);
 8457              		.loc 1 4441 0
 8458 4abc 0600A0E1 		mov	r0, r6
 8459 4ac0 FEFFFFEB 		bl	cmdquInit
4442:../uvc.c      **** 	cmdquInit(statQuptr);
 8460              		.loc 1 4442 0
 8461 4ac4 0800A0E1 		mov	r0, r8
 8462 4ac8 FEFFFFEB 		bl	cmdquInit
 8463              		.loc 1 4445 0
 8464 4acc 0150A0E3 		mov	r5, #1
 8465 4ad0 01CAA0E3 		mov	ip, #4096
 8466 4ad4 A860A0E3 		mov	r6, #168
 8467 4ad8 C0009FE5 		ldr	r0, .L695+24
 8468 4adc C0109FE5 		ldr	r1, .L695+28
 8469 4ae0 C0209FE5 		ldr	r2, .L695+32
 8470 4ae4 0730A0E1 		mov	r3, r7
 8471 4ae8 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 8472 4aec 08408DE5 		str	r4, [sp, #8]
 8473 4af0 0C408DE5 		str	r4, [sp, #12]
 8474 4af4 10708DE5 		str	r7, [sp, #16]
 8475 4af8 14508DE5 		str	r5, [sp, #20]
 8476 4afc 18608DE5 		str	r6, [sp, #24]
 8477 4b00 FEFFFFEB 		bl	_txe_thread_create
 8478              	.LVL709:
4446:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4447:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4448:../uvc.c      ****             0,                                          /* No input parameter to thread */
4449:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4450:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4451:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4452:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4453:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4454:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4455:../uvc.c      ****             );
4456:../uvc.c      ****     if (retThrdCreate != 0)
 8479              		.loc 1 4456 0
 8480 4b04 00C050E2 		subs	ip, r0, #0
 8481 4b08 CBFFFF1A 		bne	.L691
4457:../uvc.c      ****     {
4458:../uvc.c      ****         goto fatalErrorHandler;
4459:../uvc.c      ****     }
4460:../uvc.c      **** 
4461:../uvc.c      ****     /* Create the control request handling thread. */
4462:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 8482              		.loc 1 4462 0
 8483 4b0c 0C30A0E1 		mov	r3, ip
 8484 4b10 027BA0E3 		mov	r7, #2048
 8485 4b14 90009FE5 		ldr	r0, .L695+36
 8486              	.LVL710:
 8487 4b18 90109FE5 		ldr	r1, .L695+40
 8488 4b1c 90209FE5 		ldr	r2, .L695+44
 8489 4b20 10C08DE5 		str	ip, [sp, #16]
 8490 4b24 00908DE5 		str	r9, [sp, #0]
 8491 4b28 04708DE5 		str	r7, [sp, #4]
 8492 4b2c 08408DE5 		str	r4, [sp, #8]
 8493 4b30 0C408DE5 		str	r4, [sp, #12]
 8494 4b34 14508DE5 		str	r5, [sp, #20]
 8495 4b38 18608DE5 		str	r6, [sp, #24]
 8496 4b3c FEFFFFEB 		bl	_txe_thread_create
 8497              	.LVL711:
4463:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4464:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4465:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4466:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4467:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4468:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4469:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4470:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4471:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4472:../uvc.c      ****             );
4473:../uvc.c      ****     if (retThrdCreate != 0)
 8498              		.loc 1 4473 0
 8499 4b40 00C050E2 		subs	ip, r0, #0
 8500 4b44 BCFFFF1A 		bne	.L691
4474:../uvc.c      ****     {
4475:../uvc.c      ****         goto fatalErrorHandler;
4476:../uvc.c      ****     }
4477:../uvc.c      **** #if 1
4478:../uvc.c      ****     /* Create the I2C control command handling thread. */
4479:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 8501              		.loc 1 4479 0
 8502 4b48 68009FE5 		ldr	r0, .L695+48
 8503              	.LVL712:
 8504 4b4c 68109FE5 		ldr	r1, .L695+52
 8505 4b50 68209FE5 		ldr	r2, .L695+56
 8506 4b54 0C30A0E1 		mov	r3, ip
 8507 4b58 00B08DE5 		str	fp, [sp, #0]
 8508 4b5c 04708DE5 		str	r7, [sp, #4]
 8509 4b60 08408DE5 		str	r4, [sp, #8]
 8510 4b64 0C408DE5 		str	r4, [sp, #12]
 8511 4b68 10C08DE5 		str	ip, [sp, #16]
 8512 4b6c 14508DE5 		str	r5, [sp, #20]
 8513 4b70 18608DE5 		str	r6, [sp, #24]
 8514 4b74 FEFFFFEB 		bl	_txe_thread_create
 8515              	.LVL713:
4480:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4481:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4482:../uvc.c      ****             0,                                          /* No input parameter to thread */
4483:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4484:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4485:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4486:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4487:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4488:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4489:../uvc.c      ****             );
4490:../uvc.c      ****     if (retThrdCreate != 0)
 8516              		.loc 1 4490 0
 8517 4b78 000050E3 		cmp	r0, #0
 8518 4b7c AEFFFF1A 		bne	.L691
4491:../uvc.c      ****     {
4492:../uvc.c      ****         goto fatalErrorHandler;
4493:../uvc.c      ****     }
4494:../uvc.c      **** #endif
4495:../uvc.c      **** 
4496:../uvc.c      ****     return;
4497:../uvc.c      **** 
4498:../uvc.c      **** fatalErrorHandler:
4499:../uvc.c      ****     /* Add custom recovery or debug actions here */
4500:../uvc.c      ****     /* Loop indefinitely */
4501:../uvc.c      ****     while (1);
4502:../uvc.c      **** }
 8519              		.loc 1 4502 0
 8520 4b80 44D08DE2 		add	sp, sp, #68
 8521 4b84 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8522              	.L696:
 8523              		.align	2
 8524              	.L695:
 8525 4b88 00000000 		.word	cmdQuMux
 8526 4b8c 9C0C0000 		.word	.LC72
 8527 4b90 00000000 		.word	cmdQu
 8528 4b94 00000000 		.word	staQuMux
 8529 4b98 00000000 		.word	statQu
 8530 4b9c A80C0000 		.word	.LC73
 8531 4ba0 A4000000 		.word	.LANCHOR0+164
 8532 4ba4 B40C0000 		.word	.LC74
 8533 4ba8 00000000 		.word	UVCAppThread_Entry
 8534 4bac 4C010000 		.word	.LANCHOR0+332
 8535 4bb0 C80C0000 		.word	.LC75
 8536 4bb4 00000000 		.word	UVCAppEP0Thread_Entry
 8537 4bb8 F4010000 		.word	.LANCHOR0+500
 8538 4bbc E00C0000 		.word	.LC76
 8539 4bc0 00000000 		.word	I2cAppThread_Entry
 8540              		.cfi_endproc
 8541              	.LFE27:
 8543              		.align	2
 8544              		.global	main
 8546              	main:
 8547              	.LFB28:
4503:../uvc.c      **** 
4504:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4505:../uvc.c      ****  * the ThreadX RTOS here.
4506:../uvc.c      ****  */
4507:../uvc.c      **** int
4508:../uvc.c      **** main (
4509:../uvc.c      ****         void)
4510:../uvc.c      **** {
 8548              		.loc 1 4510 0
 8549              		.cfi_startproc
 8550              		@ args = 0, pretend = 0, frame = 56
 8551              		@ frame_needed = 0, uses_anonymous_args = 0
 8552 4bc4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 8553              	.LCFI30:
 8554              		.cfi_def_cfa_offset 12
4511:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4512:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4513:../uvc.c      **** 
4514:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4515:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4516:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4517:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4518:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4519:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8555              		.loc 1 4519 0
 8556 4bc8 0010A0E3 		mov	r1, #0
4510:../uvc.c      **** {
 8557              		.loc 1 4510 0
 8558 4bcc 3CD04DE2 		sub	sp, sp, #60
 8559              	.LCFI31:
 8560              		.cfi_def_cfa_offset 72
4516:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8561              		.loc 1 4516 0
 8562 4bd0 0220A0E3 		mov	r2, #2
4520:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8563              		.loc 1 4520 0
 8564 4bd4 033081E2 		add	r3, r1, #3
4515:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8565              		.loc 1 4515 0
 8566 4bd8 0150A0E3 		mov	r5, #1
 8567              		.cfi_offset 14, -4
 8568              		.cfi_offset 5, -8
 8569              		.cfi_offset 4, -12
4521:../uvc.c      **** 
4522:../uvc.c      ****     /* Initialize the device */
4523:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 8570              		.loc 1 4523 0
 8571 4bdc 28008DE2 		add	r0, sp, #40
4515:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 8572              		.loc 1 4515 0
 8573 4be0 28508DE5 		str	r5, [sp, #40]
4516:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 8574              		.loc 1 4516 0
 8575 4be4 2C20CDE5 		strb	r2, [sp, #44]
4517:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 8576              		.loc 1 4517 0
 8577 4be8 2D20CDE5 		strb	r2, [sp, #45]
4518:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 8578              		.loc 1 4518 0
 8579 4bec 2E20CDE5 		strb	r2, [sp, #46]
4519:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 8580              		.loc 1 4519 0
 8581 4bf0 30108DE5 		str	r1, [sp, #48]
4520:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 8582              		.loc 1 4520 0
 8583 4bf4 3430CDE5 		strb	r3, [sp, #52]
 8584              		.loc 1 4523 0
 8585 4bf8 FEFFFFEB 		bl	CyU3PDeviceInit
 8586              	.LVL714:
4524:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8587              		.loc 1 4524 0
 8588 4bfc 004050E2 		subs	r4, r0, #0
 8589 4c00 0000000A 		beq	.L700
 8590              	.L698:
 8591              	.L699:
 8592 4c04 FEFFFFEA 		b	.L699
 8593              	.L700:
4525:../uvc.c      ****     {
4526:../uvc.c      ****         goto handle_fatal_error;
4527:../uvc.c      ****     }
4528:../uvc.c      **** 
4529:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4530:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 8594              		.loc 1 4530 0
 8595 4c08 0410A0E1 		mov	r1, r4
 8596 4c0c 0420A0E1 		mov	r2, r4
 8597 4c10 0500A0E1 		mov	r0, r5
 8598              	.LVL715:
 8599 4c14 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 8600              	.LVL716:
4531:../uvc.c      **** 
4532:../uvc.c      ****     /* Configure the IO matrix for the device. */
4533:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4534:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4535:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4536:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4537:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4538:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4539:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4540:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4541:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4542:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4543:../uvc.c      **** 
4544:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 8601              		.loc 1 4544 0
 8602 4c18 0D00A0E1 		mov	r0, sp
4534:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 8603              		.loc 1 4534 0
 8604 4c1c 1640CDE5 		strb	r4, [sp, #22]
4535:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 8605              		.loc 1 4535 0
 8606 4c20 18408DE5 		str	r4, [sp, #24]
4536:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 8607              		.loc 1 4536 0
 8608 4c24 1C408DE5 		str	r4, [sp, #28]
4537:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 8609              		.loc 1 4537 0
 8610 4c28 20408DE5 		str	r4, [sp, #32]
4538:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 8611              		.loc 1 4538 0
 8612 4c2c 24408DE5 		str	r4, [sp, #36]
4541:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 8613              		.loc 1 4541 0
 8614 4c30 0C408DE5 		str	r4, [sp, #12]
4542:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 8615              		.loc 1 4542 0
 8616 4c34 10408DE5 		str	r4, [sp, #16]
4533:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 8617              		.loc 1 4533 0
 8618 4c38 00508DE5 		str	r5, [sp, #0]
4539:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 8619              		.loc 1 4539 0
 8620 4c3c 04508DE5 		str	r5, [sp, #4]
4540:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 8621              		.loc 1 4540 0
 8622 4c40 08508DE5 		str	r5, [sp, #8]
 8623              		.loc 1 4544 0
 8624 4c44 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 8625              	.LVL717:
4545:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8626              		.loc 1 4545 0
 8627 4c48 004050E2 		subs	r4, r0, #0
 8628 4c4c ECFFFF1A 		bne	.L698
4546:../uvc.c      ****     {
4547:../uvc.c      ****         goto handle_fatal_error;
4548:../uvc.c      ****     }
4549:../uvc.c      **** 
4550:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4551:../uvc.c      ****     CyU3PKernelEntry ();
 8629              		.loc 1 4551 0
 8630 4c50 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 8631              	.LVL718:
4552:../uvc.c      **** 
4553:../uvc.c      ****     /* Dummy return to make the compiler happy */
4554:../uvc.c      ****     return 0;
4555:../uvc.c      **** 
4556:../uvc.c      **** handle_fatal_error:
4557:../uvc.c      ****     /* Cannot recover from this error. */
4558:../uvc.c      ****     while (1);
4559:../uvc.c      **** }
 8632              		.loc 1 4559 0
 8633 4c54 0400A0E1 		mov	r0, r4
 8634 4c58 3CD08DE2 		add	sp, sp, #60
 8635 4c5c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 8636              		.cfi_endproc
 8637              	.LFE28:
 8639              		.global	CyFxGpifTransition
 8640              		.global	CyFxGpifWavedata
 8641              		.global	CyFxGpifWavedataPosition
 8642              		.global	CyFxGpifRegValue
 8643              		.global	CyFxGpifConfig
 8644              		.global	CyFxGpifTransition_usb2
 8645              		.global	CyFxGpifWavedata_usb2
 8646              		.global	CyFxGpifWavedataPosition_usb2
 8647              		.global	CyFxGpifRegValue_usb2
 8648              		.global	CyFxGpifConfig_usb2
 8649              		.global	snapButFlag
 8650              		.global	testSnap
 8651              		.global	fb
 8652              		.global	pb
 8653              		.global	pbc
 8654              		.global	fbbak
 8655              		.global	pbbak
 8656              		.global	pbcbak
 8657              		.global	pbcpbak
 8658              		.global	isUsbConnected
 8659              		.global	usbSpeed
 8660              		.global	clearFeatureRqtReceived
 8661              		.global	streamingStarted
 8662              		.global	glProbeCtrl
 8663              		.global	glProbeCtrlFull
 8664              		.global	glProbeStilCtrl
 8665              		.global	glProbeCtrl20
 8666              		.global	glProbeStilCtrl20
 8667              		.global	glUVCHeader
 8668              		.comm	glChHandleUVCStream,220,4
 8669              		.comm	glChHandleStillStream,220,4
 8670              		.comm	glChHandleInterStat,160,4
 8671              		.comm	glInterStaBuffer,4,4
 8672              		.comm	cmdQu,32,4
 8673              		.comm	statQu,32,4
 8674              		.comm	cmdQuMux,56,4
 8675              		.comm	staQuMux,56,4
 8676              		.comm	timMux,56,4
 8677              		.comm	imgHdMux,56,4
 8678              		.comm	bmReqType,1,1
 8679              		.comm	bRequest,1,1
 8680              		.comm	wValue,2,2
 8681              		.comm	wIndex,2,2
 8682              		.comm	wLength,2,2
 8683              		.comm	posTick,4,4
 8684              		.comm	I2CCmdTimer,44,4
 8685              		.section	.rodata
 8686              		.align	2
 8687              		.set	.LANCHOR2,. + 0
 8690              	ShutSp:
 8691 0000 3582     		.short	-32203
 8692 0002 1B41     		.short	16667
 8693 0004 8D20     		.short	8333
 8694 0006 A00F     		.short	4000
 8695 0008 D007     		.short	2000
 8696 000a E803     		.short	1000
 8697 000c F401     		.short	500
 8698 000e C800     		.short	200
 8699 0010 6400     		.short	100
 8700 0012 0A00     		.short	10
 8701 0014 0000     		.short	0
 8702 0016 00000000 		.space	10
 8702      00000000 
 8702      0000
 8705              	pEXTSenCtrl:
 8706 0020 90040000 		.word	EXTShutter
 8707 0024 00000000 		.word	0
 8708 0028 00000000 		.word	0
 8709 002c 00000000 		.word	0
 8710 0030 00000000 		.word	0
 8711 0034 00000000 		.word	0
 8712 0038 00000000 		.word	0
 8713 003c 00000000 		.word	0
 8714 0040 00000000 		.word	0
 8715 0044 B8040000 		.word	EXTAexModGainlev
 8716 0048 00000000 		.word	0
 8717 004c A4040000 		.word	EXTShutlev
 8718 0050 00000000 		.word	0
 8719 0054 00000000 		.word	0
 8720 0058 00000000 		.word	0
 8721 005c 00000000 		.word	0
 8722 0060 00000000 		.word	0
 8723 0064 00000000 		.word	0
 8724 0068 00000000 		.word	0
 8725 006c 00000000 		.word	0
 8726 0070 D0040000 		.word	EXTBLCWinPos
 8727 0074 E4040000 		.word	EXTBLCWeight
 8728 0078 00000000 		.word	0
 8729 007c 00000000 		.word	0
 8730 0080 00000000 		.space	32
 8730      00000000 
 8730      00000000 
 8730      00000000 
 8730      00000000 
 8733              	pPUCSenCtrl:
 8734 00a0 F8040000 		.word	PUCBLC
 8735 00a4 00000000 		.word	0
 8736 00a8 00000000 		.word	0
 8737 00ac 00000000 		.word	0
 8738 00b0 00000000 		.word	0
 8739 00b4 00000000 		.word	0
 8740 00b8 00000000 		.word	0
 8741 00bc 0C050000 		.word	PUCSharp
 8742 00c0 00000000 		.word	0
 8743 00c4 00000000 		.word	0
 8744 00c8 00000000 		.word	0
 8745 00cc 00000000 		.word	0
 8746 00d0 00000000 		.word	0
 8747 00d4 00000000 		.word	0
 8748 00d8 00000000 		.word	0
 8749 00dc 00000000 		.word	0
 8752              	CyFxGpifConfig:
 8753 00e0 0F00     		.short	15
 8754 00e2 0000     		.space	2
 8755 00e4 00000000 		.word	CyFxGpifWavedata
 8756 00e8 00000000 		.word	CyFxGpifWavedataPosition
 8757 00ec 0500     		.short	5
 8758 00ee 0000     		.space	2
 8759 00f0 00000000 		.word	CyFxGpifTransition
 8760 00f4 4C00     		.short	76
 8761 00f6 0000     		.space	2
 8762 00f8 00000000 		.word	CyFxGpifRegValue
 8765              	CyFxGpifConfig_usb2:
 8766 00fc 9300     		.short	147
 8767 00fe 0000     		.space	2
 8768 0100 00000000 		.word	CyFxGpifWavedata_usb2
 8769 0104 00000000 		.word	CyFxGpifWavedataPosition_usb2
 8770 0108 0800     		.short	8
 8771 010a 0000     		.space	2
 8772 010c 00000000 		.word	CyFxGpifTransition_usb2
 8773 0110 4C00     		.short	76
 8774 0112 0000     		.space	2
 8775 0114 00000000 		.word	CyFxGpifRegValue_usb2
 8776              		.data
 8777              		.align	2
 8778              		.set	.LANCHOR1,. + 0
 8781              	ExUCtrlParArry:
 8782 0000 00       		.byte	0
 8783 0001 00       		.byte	0
 8784 0002 04       		.byte	4
 8785 0003 01       		.byte	1
 8786 0004 00       		.byte	0
 8787 0005 38       		.byte	56
 8788 0006 01       		.byte	1
 8789 0007 01       		.byte	1
 8790 0008 00       		.byte	0
 8791 0009 03       		.byte	3
 8792 000a 00       		.byte	0
 8793 000b 4E       		.byte	78
 8794 000c 00       		.byte	0
 8795 000d 4E       		.byte	78
 8796 000e 00       		.byte	0
 8797 000f 30       		.byte	48
 8798 0010 01       		.byte	1
 8799 0011 00       		.byte	0
 8800 0012 00       		.byte	0
 8801 0013 00000000 		.space	5
 8801      00
 8802 0018 00       		.byte	0
 8803 0019 00       		.byte	0
 8804 001a 01       		.byte	1
 8805 001b 00       		.byte	0
 8806 001c 00       		.byte	0
 8807 001d 00       		.byte	0
 8808 001e 00       		.byte	0
 8809 001f 01       		.byte	1
 8810 0020 00       		.byte	0
 8811 0021 03       		.byte	3
 8812 0022 00       		.byte	0
 8813 0023 00       		.byte	0
 8814 0024 00       		.byte	0
 8815 0025 00       		.byte	0
 8816 0026 00       		.byte	0
 8817 0027 30       		.byte	48
 8818 0028 01       		.byte	1
 8819 0029 00       		.byte	0
 8820 002a 00       		.byte	0
 8821 002b 00000000 		.space	5
 8821      00
 8822 0030 00       		.byte	0
 8823 0031 00       		.byte	0
 8824 0032 02       		.byte	2
 8825 0033 00       		.byte	0
 8826 0034 00       		.byte	0
 8827 0035 FF       		.byte	-1
 8828 0036 00       		.byte	0
 8829 0037 01       		.byte	1
 8830 0038 00       		.byte	0
 8831 0039 03       		.byte	3
 8832 003a 00       		.byte	0
 8833 003b 01       		.byte	1
 8834 003c 00       		.byte	0
 8835 003d 00       		.byte	0
 8836 003e 00       		.byte	0
 8837 003f 30       		.byte	48
 8838 0040 01       		.byte	1
 8839 0041 01       		.byte	1
 8840 0042 00       		.byte	0
 8841 0043 00000000 		.space	5
 8841      00
 8842 0048 00       		.byte	0
 8843 0049 00       		.byte	0
 8844 004a 02       		.byte	2
 8845 004b 00       		.byte	0
 8846 004c 00       		.byte	0
 8847 004d 00       		.byte	0
 8848 004e 00       		.byte	0
 8849 004f 00       		.byte	0
 8850 0050 00       		.byte	0
 8851 0051 03       		.byte	3
 8852 0052 00       		.byte	0
 8853 0053 00       		.byte	0
 8854 0054 00       		.byte	0
 8855 0055 00       		.byte	0
 8856 0056 00       		.byte	0
 8857 0057 30       		.byte	48
 8858 0058 01       		.byte	1
 8859 0059 01       		.byte	1
 8860 005a 00       		.byte	0
 8861 005b 00000000 		.space	5
 8861      00
 8862 0060 13       		.byte	19
 8863 0061 14       		.byte	20
 8864 0062 02       		.byte	2
 8865 0063 00       		.byte	0
 8866 0064 00       		.byte	0
 8867 0065 FF       		.byte	-1
 8868 0066 FF       		.byte	-1
 8869 0067 01       		.byte	1
 8870 0068 00       		.byte	0
 8871 0069 03       		.byte	3
 8872 006a 00       		.byte	0
 8873 006b 66       		.byte	102
 8874 006c 66       		.byte	102
 8875 006d 66       		.byte	102
 8876 006e 66       		.byte	102
 8877 006f 30       		.byte	48
 8878 0070 01       		.byte	1
 8879 0071 00       		.byte	0
 8880 0072 00       		.byte	0
 8881 0073 00000000 		.space	5
 8881      00
 8882 0078 11       		.byte	17
 8883 0079 00       		.byte	0
 8884 007a 02       		.byte	2
 8885 007b 01       		.byte	1
 8886 007c 00       		.byte	0
 8887 007d 03       		.byte	3
 8888 007e 00       		.byte	0
 8889 007f 01       		.byte	1
 8890 0080 00       		.byte	0
 8891 0081 03       		.byte	3
 8892 0082 00       		.byte	0
 8893 0083 80       		.byte	-128
 8894 0084 00       		.byte	0
 8895 0085 80       		.byte	-128
 8896 0086 00       		.byte	0
 8897 0087 30       		.byte	48
 8898 0088 01       		.byte	1
 8899 0089 01       		.byte	1
 8900 008a 00       		.byte	0
 8901 008b 00000000 		.space	5
 8901      00
 8902 0090 10       		.byte	16
 8903 0091 00       		.byte	0
 8904 0092 01       		.byte	1
 8905 0093 01       		.byte	1
 8906 0094 00       		.byte	0
 8907 0095 02       		.byte	2
 8908 0096 00       		.byte	0
 8909 0097 01       		.byte	1
 8910 0098 00       		.byte	0
 8911 0099 03       		.byte	3
 8912 009a 00       		.byte	0
 8913 009b 00       		.byte	0
 8914 009c 00       		.byte	0
 8915 009d 00       		.byte	0
 8916 009e 00       		.byte	0
 8917 009f 30       		.byte	48
 8918 00a0 01       		.byte	1
 8919 00a1 01       		.byte	1
 8920 00a2 00       		.byte	0
 8921 00a3 00000000 		.space	5
 8921      00
 8922 00a8 00       		.byte	0
 8923 00a9 00       		.byte	0
 8924 00aa 04       		.byte	4
 8925 00ab 01       		.byte	1
 8926 00ac 00       		.byte	0
 8927 00ad 38       		.byte	56
 8928 00ae 01       		.byte	1
 8929 00af 01       		.byte	1
 8930 00b0 00       		.byte	0
 8931 00b1 03       		.byte	3
 8932 00b2 00       		.byte	0
 8933 00b3 4E       		.byte	78
 8934 00b4 00       		.byte	0
 8935 00b5 4E       		.byte	78
 8936 00b6 00       		.byte	0
 8937 00b7 30       		.byte	48
 8938 00b8 01       		.byte	1
 8939 00b9 00       		.byte	0
 8940 00ba 00       		.byte	0
 8941 00bb 00000000 		.space	5
 8941      00
 8942 00c0 00       		.byte	0
 8943 00c1 00       		.byte	0
 8944 00c2 01       		.byte	1
 8945 00c3 00       		.byte	0
 8946 00c4 00       		.byte	0
 8947 00c5 00       		.byte	0
 8948 00c6 00       		.byte	0
 8949 00c7 01       		.byte	1
 8950 00c8 00       		.byte	0
 8951 00c9 03       		.byte	3
 8952 00ca 00       		.byte	0
 8953 00cb 00       		.byte	0
 8954 00cc 00       		.byte	0
 8955 00cd 00       		.byte	0
 8956 00ce 00       		.byte	0
 8957 00cf 30       		.byte	48
 8958 00d0 01       		.byte	1
 8959 00d1 00       		.byte	0
 8960 00d2 00       		.byte	0
 8961 00d3 00000000 		.space	5
 8961      00
 8962 00d8 00       		.byte	0
 8963 00d9 00       		.byte	0
 8964 00da 02       		.byte	2
 8965 00db 00       		.byte	0
 8966 00dc 00       		.byte	0
 8967 00dd 05       		.byte	5
 8968 00de 00       		.byte	0
 8969 00df 01       		.byte	1
 8970 00e0 00       		.byte	0
 8971 00e1 03       		.byte	3
 8972 00e2 00       		.byte	0
 8973 00e3 00       		.byte	0
 8974 00e4 00       		.byte	0
 8975 00e5 00       		.byte	0
 8976 00e6 00       		.byte	0
 8977 00e7 30       		.byte	48
 8978 00e8 01       		.byte	1
 8979 00e9 00       		.byte	0
 8980 00ea 00       		.byte	0
 8981 00eb 00000000 		.space	5
 8981      00
 8982 00f0 00       		.byte	0
 8983 00f1 00       		.byte	0
 8984 00f2 03       		.byte	3
 8985 00f3 00       		.byte	0
 8986 00f4 00       		.byte	0
 8987 00f5 0A       		.byte	10
 8988 00f6 00       		.byte	0
 8989 00f7 01       		.byte	1
 8990 00f8 00       		.byte	0
 8991 00f9 03       		.byte	3
 8992 00fa 00       		.byte	0
 8993 00fb 00       		.byte	0
 8994 00fc 00       		.byte	0
 8995 00fd 00       		.byte	0
 8996 00fe 00       		.byte	0
 8997 00ff 30       		.byte	48
 8998 0100 01       		.byte	1
 8999 0101 00       		.byte	0
 9000 0102 00       		.byte	0
 9001 0103 00000000 		.space	5
 9001      00
 9002 0108 00       		.byte	0
 9003 0109 00       		.byte	0
 9004 010a 02       		.byte	2
 9005 010b 00       		.byte	0
 9006 010c 00       		.byte	0
 9007 010d 40       		.byte	64
 9008 010e 00       		.byte	0
 9009 010f 01       		.byte	1
 9010 0110 00       		.byte	0
 9011 0111 03       		.byte	3
 9012 0112 00       		.byte	0
 9013 0113 0F       		.byte	15
 9014 0114 11       		.byte	17
 9015 0115 00       		.byte	0
 9016 0116 00       		.byte	0
 9017 0117 30       		.byte	48
 9018 0118 01       		.byte	1
 9019 0119 00       		.byte	0
 9020 011a 00       		.byte	0
 9021 011b 00000000 		.space	5
 9021      00
 9022 0120 00       		.byte	0
 9023 0121 00       		.byte	0
 9024 0122 02       		.byte	2
 9025 0123 00       		.byte	0
 9026 0124 00       		.byte	0
 9027 0125 64       		.byte	100
 9028 0126 00       		.byte	0
 9029 0127 01       		.byte	1
 9030 0128 00       		.byte	0
 9031 0129 03       		.byte	3
 9032 012a 00       		.byte	0
 9033 012b 00       		.byte	0
 9034 012c 00       		.byte	0
 9035 012d 00       		.byte	0
 9036 012e 00       		.byte	0
 9037 012f 30       		.byte	48
 9038 0130 01       		.byte	1
 9039 0131 00       		.byte	0
 9040 0132 00       		.byte	0
 9041 0133 00000000 		.space	5
 9041      00
 9042 0138 00       		.byte	0
 9043 0139 00       		.byte	0
 9044 013a 02       		.byte	2
 9045 013b 00       		.byte	0
 9046 013c 00       		.byte	0
 9047 013d 64       		.byte	100
 9048 013e 00       		.byte	0
 9049 013f 01       		.byte	1
 9050 0140 00       		.byte	0
 9051 0141 03       		.byte	3
 9052 0142 00       		.byte	0
 9053 0143 00       		.byte	0
 9054 0144 00       		.byte	0
 9055 0145 00       		.byte	0
 9056 0146 00       		.byte	0
 9057 0147 30       		.byte	48
 9058 0148 01       		.byte	1
 9059 0149 00       		.byte	0
 9060 014a 00       		.byte	0
 9061 014b 00000000 		.space	5
 9061      00
 9062 0150 00       		.byte	0
 9063 0151 00       		.byte	0
 9064 0152 02       		.byte	2
 9065 0153 00       		.byte	0
 9066 0154 00       		.byte	0
 9067 0155 64       		.byte	100
 9068 0156 00       		.byte	0
 9069 0157 01       		.byte	1
 9070 0158 00       		.byte	0
 9071 0159 03       		.byte	3
 9072 015a 00       		.byte	0
 9073 015b 00       		.byte	0
 9074 015c 00       		.byte	0
 9075 015d 00       		.byte	0
 9076 015e 00       		.byte	0
 9077 015f 30       		.byte	48
 9078 0160 01       		.byte	1
 9079 0161 00       		.byte	0
 9080 0162 00       		.byte	0
 9081 0163 00000000 		.space	5
 9081      00
 9082 0168 00       		.byte	0
 9083 0169 00       		.byte	0
 9084 016a 02       		.byte	2
 9085 016b 00       		.byte	0
 9086 016c 00       		.byte	0
 9087 016d 64       		.byte	100
 9088 016e 00       		.byte	0
 9089 016f 01       		.byte	1
 9090 0170 00       		.byte	0
 9091 0171 03       		.byte	3
 9092 0172 00       		.byte	0
 9093 0173 00       		.byte	0
 9094 0174 00       		.byte	0
 9095 0175 00       		.byte	0
 9096 0176 00       		.byte	0
 9097 0177 30       		.byte	48
 9098 0178 01       		.byte	1
 9099 0179 00       		.byte	0
 9100 017a 00       		.byte	0
 9101 017b 00000000 		.space	5
 9101      00
 9104              	CtrlParArry:
 9105 0180 10       		.byte	16
 9106 0181 10       		.byte	16
 9107 0182 02       		.byte	2
 9108 0183 00       		.byte	0
 9109 0184 00       		.byte	0
 9110 0185 03       		.byte	3
 9111 0186 00       		.byte	0
 9112 0187 01       		.byte	1
 9113 0188 00       		.byte	0
 9114 0189 03       		.byte	3
 9115 018a 00       		.byte	0
 9116 018b 03       		.byte	3
 9117 018c 00       		.byte	0
 9118 018d 03       		.byte	3
 9119 018e 00       		.byte	0
 9120 018f 30       		.byte	48
 9121 0190 01       		.byte	1
 9122 0191 00       		.byte	0
 9123 0192 00       		.byte	0
 9124 0193 00000000 		.space	5
 9124      00
 9125 0198 15       		.byte	21
 9126 0199 15       		.byte	21
 9127 019a 02       		.byte	2
 9128 019b 00       		.byte	0
 9129 019c 00       		.byte	0
 9130 019d FF       		.byte	-1
 9131 019e 00       		.byte	0
 9132 019f 01       		.byte	1
 9133 01a0 00       		.byte	0
 9134 01a1 03       		.byte	3
 9135 01a2 00       		.byte	0
 9136 01a3 76       		.byte	118
 9137 01a4 00       		.byte	0
 9138 01a5 76       		.byte	118
 9139 01a6 C7       		.byte	-57
 9140 01a7 30       		.byte	48
 9141 01a8 01       		.byte	1
 9142 01a9 01       		.byte	1
 9143 01aa 00       		.byte	0
 9144 01ab 00000000 		.space	5
 9144      00
 9145 01b0 04       		.byte	4
 9146 01b1 04       		.byte	4
 9147 01b2 02       		.byte	2
 9148 01b3 00       		.byte	0
 9149 01b4 00       		.byte	0
 9150 01b5 FF       		.byte	-1
 9151 01b6 00       		.byte	0
 9152 01b7 01       		.byte	1
 9153 01b8 00       		.byte	0
 9154 01b9 03       		.byte	3
 9155 01ba 00       		.byte	0
 9156 01bb 70       		.byte	112
 9157 01bc 00       		.byte	0
 9158 01bd 70       		.byte	112
 9159 01be 00       		.byte	0
 9160 01bf 30       		.byte	48
 9161 01c0 01       		.byte	1
 9162 01c1 01       		.byte	1
 9163 01c2 00       		.byte	0
 9164 01c3 00000000 		.space	5
 9164      00
 9165 01c8 00       		.byte	0
 9166 01c9 00       		.byte	0
 9167 01ca 02       		.byte	2
 9168 01cb 00       		.byte	0
 9169 01cc 00       		.byte	0
 9170 01cd 64       		.byte	100
 9171 01ce 00       		.byte	0
 9172 01cf 01       		.byte	1
 9173 01d0 00       		.byte	0
 9174 01d1 03       		.byte	3
 9175 01d2 00       		.byte	0
 9176 01d3 00       		.byte	0
 9177 01d4 00       		.byte	0
 9178 01d5 00       		.byte	0
 9179 01d6 00       		.byte	0
 9180 01d7 30       		.byte	48
 9181 01d8 01       		.byte	1
 9182 01d9 00       		.byte	0
 9183 01da 00       		.byte	0
 9184 01db 00000000 		.space	5
 9184      00
 9185 01e0 07       		.byte	7
 9186 01e1 07       		.byte	7
 9187 01e2 02       		.byte	2
 9188 01e3 00       		.byte	0
 9189 01e4 00       		.byte	0
 9190 01e5 01       		.byte	1
 9191 01e6 00       		.byte	0
 9192 01e7 01       		.byte	1
 9193 01e8 00       		.byte	0
 9194 01e9 03       		.byte	3
 9195 01ea 00       		.byte	0
 9196 01eb 01       		.byte	1
 9197 01ec 00       		.byte	0
 9198 01ed 01       		.byte	1
 9199 01ee 00       		.byte	0
 9200 01ef 30       		.byte	48
 9201 01f0 01       		.byte	1
 9202 01f1 00       		.byte	0
 9203 01f2 00       		.byte	0
 9204 01f3 00000000 		.space	5
 9204      00
 9205 01f8 DF       		.byte	-33
 9206 01f9 E1       		.byte	-31
 9207 01fa 02       		.byte	2
 9208 01fb 00       		.byte	0
 9209 01fc 00       		.byte	0
 9210 01fd FF       		.byte	-1
 9211 01fe 00       		.byte	0
 9212 01ff 01       		.byte	1
 9213 0200 00       		.byte	0
 9214 0201 03       		.byte	3
 9215 0202 00       		.byte	0
 9216 0203 80       		.byte	-128
 9217 0204 00       		.byte	0
 9218 0205 00       		.byte	0
 9219 0206 00       		.byte	0
 9220 0207 C6       		.byte	-58
 9221 0208 01       		.byte	1
 9222 0209 01       		.byte	1
 9223 020a 00       		.byte	0
 9224 020b 00000000 		.space	5
 9224      00
 9225 0210 85       		.byte	-123
 9226 0211 86       		.byte	-122
 9227 0212 02       		.byte	2
 9228 0213 00       		.byte	0
 9229 0214 00       		.byte	0
 9230 0215 64       		.byte	100
 9231 0216 00       		.byte	0
 9232 0217 01       		.byte	1
 9233 0218 00       		.byte	0
 9234 0219 03       		.byte	3
 9235 021a 00       		.byte	0
 9236 021b 32       		.byte	50
 9237 021c 00       		.byte	0
 9238 021d 32       		.byte	50
 9239 021e 00       		.byte	0
 9240 021f F2       		.byte	-14
 9241 0220 01       		.byte	1
 9242 0221 01       		.byte	1
 9243 0222 00       		.byte	0
 9244 0223 00000000 		.space	5
 9244      00
 9245 0228 06       		.byte	6
 9246 0229 06       		.byte	6
 9247 022a 02       		.byte	2
 9248 022b 00       		.byte	0
 9249 022c 00       		.byte	0
 9250 022d FF       		.byte	-1
 9251 022e 00       		.byte	0
 9252 022f 01       		.byte	1
 9253 0230 00       		.byte	0
 9254 0231 03       		.byte	3
 9255 0232 00       		.byte	0
 9256 0233 20       		.byte	32
 9257 0234 00       		.byte	0
 9258 0235 20       		.byte	32
 9259 0236 00       		.byte	0
 9260 0237 30       		.byte	48
 9261 0238 01       		.byte	1
 9262 0239 01       		.byte	1
 9263 023a 00       		.byte	0
 9264 023b 00000000 		.space	5
 9264      00
 9265 0240 00       		.byte	0
 9266 0241 00       		.byte	0
 9267 0242 02       		.byte	2
 9268 0243 00       		.byte	0
 9269 0244 00       		.byte	0
 9270 0245 64       		.byte	100
 9271 0246 00       		.byte	0
 9272 0247 01       		.byte	1
 9273 0248 00       		.byte	0
 9274 0249 03       		.byte	3
 9275 024a 00       		.byte	0
 9276 024b 00       		.byte	0
 9277 024c 00       		.byte	0
 9278 024d 00       		.byte	0
 9279 024e 00       		.byte	0
 9280 024f 30       		.byte	48
 9281 0250 01       		.byte	1
 9282 0251 00       		.byte	0
 9283 0252 00       		.byte	0
 9284 0253 00000000 		.space	5
 9284      00
 9285 0258 08       		.byte	8
 9286 0259 08       		.byte	8
 9287 025a 02       		.byte	2
 9288 025b 00       		.byte	0
 9289 025c 00       		.byte	0
 9290 025d 05       		.byte	5
 9291 025e 00       		.byte	0
 9292 025f 01       		.byte	1
 9293 0260 00       		.byte	0
 9294 0261 03       		.byte	3
 9295 0262 00       		.byte	0
 9296 0263 00       		.byte	0
 9297 0264 00       		.byte	0
 9298 0265 00       		.byte	0
 9299 0266 00       		.byte	0
 9300 0267 30       		.byte	48
 9301 0268 01       		.byte	1
 9302 0269 00       		.byte	0
 9303 026a 00       		.byte	0
 9304 026b 00000000 		.space	5
 9304      00
 9305 0270 00       		.byte	0
 9306 0271 00       		.byte	0
 9307 0272 02       		.byte	2
 9308 0273 00       		.byte	0
 9309 0274 00       		.byte	0
 9310 0275 40       		.byte	64
 9311 0276 00       		.byte	0
 9312 0277 01       		.byte	1
 9313 0278 00       		.byte	0
 9314 0279 03       		.byte	3
 9315 027a 00       		.byte	0
 9316 027b 00       		.byte	0
 9317 027c 00       		.byte	0
 9318 027d 00       		.byte	0
 9319 027e 00       		.byte	0
 9320 027f 30       		.byte	48
 9321 0280 01       		.byte	1
 9322 0281 00       		.byte	0
 9323 0282 00       		.byte	0
 9324 0283 00000000 		.space	5
 9324      00
 9325 0288 09       		.byte	9
 9326 0289 0A       		.byte	10
 9327 028a 04       		.byte	4
 9328 028b 00       		.byte	0
 9329 028c 00       		.byte	0
 9330 028d 40       		.byte	64
 9331 028e 00       		.byte	0
 9332 028f 01       		.byte	1
 9333 0290 00       		.byte	0
 9334 0291 03       		.byte	3
 9335 0292 00       		.byte	0
 9336 0293 20       		.byte	32
 9337 0294 38       		.byte	56
 9338 0295 20       		.byte	32
 9339 0296 38       		.byte	56
 9340 0297 30       		.byte	48
 9341 0298 01       		.byte	1
 9342 0299 00       		.byte	0
 9343 029a 00       		.byte	0
 9344 029b 00000000 		.space	5
 9344      00
 9345 02a0 00       		.byte	0
 9346 02a1 00       		.byte	0
 9347 02a2 02       		.byte	2
 9348 02a3 00       		.byte	0
 9349 02a4 00       		.byte	0
 9350 02a5 64       		.byte	100
 9351 02a6 00       		.byte	0
 9352 02a7 01       		.byte	1
 9353 02a8 00       		.byte	0
 9354 02a9 03       		.byte	3
 9355 02aa 00       		.byte	0
 9356 02ab 00       		.byte	0
 9357 02ac 00       		.byte	0
 9358 02ad 00       		.byte	0
 9359 02ae 00       		.byte	0
 9360 02af 30       		.byte	48
 9361 02b0 01       		.byte	1
 9362 02b1 00       		.byte	0
 9363 02b2 00       		.byte	0
 9364 02b3 00000000 		.space	5
 9364      00
 9365 02b8 00       		.byte	0
 9366 02b9 00       		.byte	0
 9367 02ba 02       		.byte	2
 9368 02bb 00       		.byte	0
 9369 02bc 00       		.byte	0
 9370 02bd 64       		.byte	100
 9371 02be 00       		.byte	0
 9372 02bf 01       		.byte	1
 9373 02c0 00       		.byte	0
 9374 02c1 03       		.byte	3
 9375 02c2 00       		.byte	0
 9376 02c3 00       		.byte	0
 9377 02c4 00       		.byte	0
 9378 02c5 00       		.byte	0
 9379 02c6 00       		.byte	0
 9380 02c7 30       		.byte	48
 9381 02c8 01       		.byte	1
 9382 02c9 00       		.byte	0
 9383 02ca 00       		.byte	0
 9384 02cb 00000000 		.space	5
 9384      00
 9385 02d0 2A       		.byte	42
 9386 02d1 2A       		.byte	42
 9387 02d2 02       		.byte	2
 9388 02d3 00       		.byte	0
 9389 02d4 00       		.byte	0
 9390 02d5 1B       		.byte	27
 9391 02d6 00       		.byte	0
 9392 02d7 01       		.byte	1
 9393 02d8 00       		.byte	0
 9394 02d9 03       		.byte	3
 9395 02da 00       		.byte	0
 9396 02db 00       		.byte	0
 9397 02dc 00       		.byte	0
 9398 02dd 00       		.byte	0
 9399 02de 00       		.byte	0
 9400 02df 30       		.byte	48
 9401 02e0 01       		.byte	1
 9402 02e1 00       		.byte	0
 9403 02e2 00       		.byte	0
 9404 02e3 00000000 		.space	5
 9404      00
 9405 02e8 00       		.byte	0
 9406 02e9 00       		.byte	0
 9407 02ea 02       		.byte	2
 9408 02eb 00       		.byte	0
 9409 02ec 00       		.byte	0
 9410 02ed 64       		.byte	100
 9411 02ee 00       		.byte	0
 9412 02ef 01       		.byte	1
 9413 02f0 00       		.byte	0
 9414 02f1 03       		.byte	3
 9415 02f2 00       		.byte	0
 9416 02f3 00       		.byte	0
 9417 02f4 00       		.byte	0
 9418 02f5 00       		.byte	0
 9419 02f6 00       		.byte	0
 9420 02f7 30       		.byte	48
 9421 02f8 01       		.byte	1
 9422 02f9 00       		.byte	0
 9423 02fa 00       		.byte	0
 9424 02fb 00000000 		.space	5
 9424      00
 9425 0300 00       		.byte	0
 9426 0301 00       		.byte	0
 9427 0302 02       		.byte	2
 9428 0303 00       		.byte	0
 9429 0304 00       		.byte	0
 9430 0305 12       		.byte	18
 9431 0306 00       		.byte	0
 9432 0307 01       		.byte	1
 9433 0308 00       		.byte	0
 9434 0309 03       		.byte	3
 9435 030a 00       		.byte	0
 9436 030b 00       		.byte	0
 9437 030c 00       		.byte	0
 9438 030d 00       		.byte	0
 9439 030e 00       		.byte	0
 9440 030f 30       		.byte	48
 9441 0310 01       		.byte	1
 9442 0311 00       		.byte	0
 9443 0312 00       		.byte	0
 9444 0313 00000000 		.space	5
 9444      00
 9445 0318 01       		.byte	1
 9446 0319 01       		.byte	1
 9447 031a 02       		.byte	2
 9448 031b 00       		.byte	0
 9449 031c 00       		.byte	0
 9450 031d 09       		.byte	9
 9451 031e 00       		.byte	0
 9452 031f 01       		.byte	1
 9453 0320 00       		.byte	0
 9454 0321 03       		.byte	3
 9455 0322 00       		.byte	0
 9456 0323 00       		.byte	0
 9457 0324 00       		.byte	0
 9458 0325 01       		.byte	1
 9459 0326 00       		.byte	0
 9460 0327 30       		.byte	48
 9461 0328 01       		.byte	1
 9462 0329 00       		.byte	0
 9463 032a 00       		.byte	0
 9464 032b 00000000 		.space	5
 9464      00
 9465 0330 05       		.byte	5
 9466 0331 05       		.byte	5
 9467 0332 02       		.byte	2
 9468 0333 00       		.byte	0
 9469 0334 00       		.byte	0
 9470 0335 03       		.byte	3
 9471 0336 00       		.byte	0
 9472 0337 01       		.byte	1
 9473 0338 00       		.byte	0
 9474 0339 03       		.byte	3
 9475 033a 00       		.byte	0
 9476 033b 00       		.byte	0
 9477 033c 00       		.byte	0
 9478 033d 00       		.byte	0
 9479 033e 00       		.byte	0
 9480 033f 30       		.byte	48
 9481 0340 01       		.byte	1
 9482 0341 00       		.byte	0
 9483 0342 00       		.byte	0
 9484 0343 00000000 		.space	5
 9484      00
 9485 0348 18       		.byte	24
 9486 0349 18       		.byte	24
 9487 034a 02       		.byte	2
 9488 034b 00       		.byte	0
 9489 034c 00       		.byte	0
 9490 034d 01       		.byte	1
 9491 034e 00       		.byte	0
 9492 034f 01       		.byte	1
 9493 0350 00       		.byte	0
 9494 0351 03       		.byte	3
 9495 0352 00       		.byte	0
 9496 0353 00       		.byte	0
 9497 0354 00       		.byte	0
 9498 0355 00       		.byte	0
 9499 0356 00       		.byte	0
 9500 0357 30       		.byte	48
 9501 0358 01       		.byte	1
 9502 0359 00       		.byte	0
 9503 035a 00       		.byte	0
 9504 035b 00000000 		.space	5
 9504      00
 9505 0360 19       		.byte	25
 9506 0361 19       		.byte	25
 9507 0362 01       		.byte	1
 9508 0363 00       		.byte	0
 9509 0364 00       		.byte	0
 9510 0365 40       		.byte	64
 9511 0366 00       		.byte	0
 9512 0367 01       		.byte	1
 9513 0368 00       		.byte	0
 9514 0369 03       		.byte	3
 9515 036a 00       		.byte	0
 9516 036b 20       		.byte	32
 9517 036c 00       		.byte	0
 9518 036d 20       		.byte	32
 9519 036e 00       		.byte	0
 9520 036f 30       		.byte	48
 9521 0370 01       		.byte	1
 9522 0371 00       		.byte	0
 9523 0372 00       		.byte	0
 9524 0373 00000000 		.space	5
 9524      00
 9525 0378 20       		.byte	32
 9526 0379 20       		.byte	32
 9527 037a 02       		.byte	2
 9528 037b 00       		.byte	0
 9529 037c 00       		.byte	0
 9530 037d 02       		.byte	2
 9531 037e 00       		.byte	0
 9532 037f 01       		.byte	1
 9533 0380 00       		.byte	0
 9534 0381 03       		.byte	3
 9535 0382 00       		.byte	0
 9536 0383 00       		.byte	0
 9537 0384 00       		.byte	0
 9538 0385 00       		.byte	0
 9539 0386 00       		.byte	0
 9540 0387 30       		.byte	48
 9541 0388 01       		.byte	1
 9542 0389 00       		.byte	0
 9543 038a 00       		.byte	0
 9544 038b 00000000 		.space	5
 9544      00
 9545 0390 22       		.byte	34
 9546 0391 22       		.byte	34
 9547 0392 02       		.byte	2
 9548 0393 00       		.byte	0
 9549 0394 00       		.byte	0
 9550 0395 3F       		.byte	63
 9551 0396 00       		.byte	0
 9552 0397 01       		.byte	1
 9553 0398 00       		.byte	0
 9554 0399 03       		.byte	3
 9555 039a 00       		.byte	0
 9556 039b 00       		.byte	0
 9557 039c 00       		.byte	0
 9558 039d 00       		.byte	0
 9559 039e 00       		.byte	0
 9560 039f 30       		.byte	48
 9561 03a0 01       		.byte	1
 9562 03a1 00       		.byte	0
 9563 03a2 00       		.byte	0
 9564 03a3 00000000 		.space	5
 9564      00
 9565 03a8 23       		.byte	35
 9566 03a9 23       		.byte	35
 9567 03aa 02       		.byte	2
 9568 03ab 00       		.byte	0
 9569 03ac 00       		.byte	0
 9570 03ad 64       		.byte	100
 9571 03ae 00       		.byte	0
 9572 03af 01       		.byte	1
 9573 03b0 00       		.byte	0
 9574 03b1 03       		.byte	3
 9575 03b2 00       		.byte	0
 9576 03b3 10       		.byte	16
 9577 03b4 00       		.byte	0
 9578 03b5 10       		.byte	16
 9579 03b6 00       		.byte	0
 9580 03b7 30       		.byte	48
 9581 03b8 01       		.byte	1
 9582 03b9 00       		.byte	0
 9583 03ba 00       		.byte	0
 9584 03bb 00000000 		.space	5
 9584      00
 9585 03c0 24       		.byte	36
 9586 03c1 24       		.byte	36
 9587 03c2 02       		.byte	2
 9588 03c3 00       		.byte	0
 9589 03c4 00       		.byte	0
 9590 03c5 64       		.byte	100
 9591 03c6 00       		.byte	0
 9592 03c7 01       		.byte	1
 9593 03c8 00       		.byte	0
 9594 03c9 03       		.byte	3
 9595 03ca 00       		.byte	0
 9596 03cb 10       		.byte	16
 9597 03cc 00       		.byte	0
 9598 03cd 10       		.byte	16
 9599 03ce 00       		.byte	0
 9600 03cf 30       		.byte	48
 9601 03d0 01       		.byte	1
 9602 03d1 00       		.byte	0
 9603 03d2 00       		.byte	0
 9604 03d3 00000000 		.space	5
 9604      00
 9605 03d8 02       		.byte	2
 9606 03d9 03       		.byte	3
 9607 03da 04       		.byte	4
 9608 03db 00       		.byte	0
 9609 03dc 00       		.byte	0
 9610 03dd 7F       		.byte	127
 9611 03de 00       		.byte	0
 9612 03df 01       		.byte	1
 9613 03e0 00       		.byte	0
 9614 03e1 03       		.byte	3
 9615 03e2 00       		.byte	0
 9616 03e3 00       		.byte	0
 9617 03e4 20       		.byte	32
 9618 03e5 00       		.byte	0
 9619 03e6 20       		.byte	32
 9620 03e7 30       		.byte	48
 9621 03e8 01       		.byte	1
 9622 03e9 00       		.byte	0
 9623 03ea 00       		.byte	0
 9624 03eb 00000000 		.space	5
 9624      00
 9625 03f0 04       		.byte	4
 9626 03f1 04       		.byte	4
 9627 03f2 02       		.byte	2
 9628 03f3 00       		.byte	0
 9629 03f4 00       		.byte	0
 9630 03f5 FF       		.byte	-1
 9631 03f6 00       		.byte	0
 9632 03f7 01       		.byte	1
 9633 03f8 00       		.byte	0
 9634 03f9 03       		.byte	3
 9635 03fa 00       		.byte	0
 9636 03fb 60       		.byte	96
 9637 03fc 00       		.byte	0
 9638 03fd 60       		.byte	96
 9639 03fe 00       		.byte	0
 9640 03ff 30       		.byte	48
 9641 0400 01       		.byte	1
 9642 0401 00       		.byte	0
 9643 0402 00       		.byte	0
 9644 0403 00000000 		.space	5
 9644      00
 9645 0408 00       		.byte	0
 9646 0409 00       		.byte	0
 9647 040a 02       		.byte	2
 9648 040b 00       		.byte	0
 9649 040c 00       		.byte	0
 9650 040d 19       		.byte	25
 9651 040e 00       		.byte	0
 9652 040f 01       		.byte	1
 9653 0410 00       		.byte	0
 9654 0411 03       		.byte	3
 9655 0412 00       		.byte	0
 9656 0413 00       		.byte	0
 9657 0414 00       		.byte	0
 9658 0415 00       		.byte	0
 9659 0416 00       		.byte	0
 9660 0417 30       		.byte	48
 9661 0418 01       		.byte	1
 9662 0419 00       		.byte	0
 9663 041a 00       		.byte	0
 9664 041b 00000000 		.space	5
 9664      00
 9665 0420 10       		.byte	16
 9666 0421 10       		.byte	16
 9667 0422 02       		.byte	2
 9668 0423 00       		.byte	0
 9669 0424 00       		.byte	0
 9670 0425 06       		.byte	6
 9671 0426 00       		.byte	0
 9672 0427 01       		.byte	1
 9673 0428 00       		.byte	0
 9674 0429 03       		.byte	3
 9675 042a 00       		.byte	0
 9676 042b 03       		.byte	3
 9677 042c 00       		.byte	0
 9678 042d 03       		.byte	3
 9679 042e 00       		.byte	0
 9680 042f 30       		.byte	48
 9681 0430 01       		.byte	1
 9682 0431 00       		.byte	0
 9683 0432 00       		.byte	0
 9684 0433 00000000 		.space	5
 9684      00
 9685 0438 00       		.byte	0
 9686 0439 00       		.byte	0
 9687 043a 02       		.byte	2
 9688 043b 00       		.byte	0
 9689 043c 00       		.byte	0
 9690 043d 03       		.byte	3
 9691 043e 00       		.byte	0
 9692 043f 01       		.byte	1
 9693 0440 00       		.byte	0
 9694 0441 03       		.byte	3
 9695 0442 00       		.byte	0
 9696 0443 00       		.byte	0
 9697 0444 00       		.byte	0
 9698 0445 00       		.byte	0
 9699 0446 00       		.byte	0
 9700 0447 30       		.byte	48
 9701 0448 01       		.byte	1
 9702 0449 00       		.byte	0
 9703 044a 00       		.byte	0
 9704 044b 00000000 		.space	5
 9704      00
 9705 0450 50       		.byte	80
 9706 0451 50       		.byte	80
 9707 0452 01       		.byte	1
 9708 0453 00       		.byte	0
 9709 0454 00       		.byte	0
 9710 0455 03       		.byte	3
 9711 0456 00       		.byte	0
 9712 0457 01       		.byte	1
 9713 0458 00       		.byte	0
 9714 0459 03       		.byte	3
 9715 045a 00       		.byte	0
 9716 045b 00       		.byte	0
 9717 045c 00       		.byte	0
 9718 045d 00       		.byte	0
 9719 045e 00       		.byte	0
 9720 045f 30       		.byte	48
 9721 0460 01       		.byte	1
 9722 0461 00       		.byte	0
 9723 0462 00       		.byte	0
 9724 0463 00000000 		.space	5
 9724      00
 9725 0468 00       		.byte	0
 9726 0469 00       		.byte	0
 9727 046a 0B       		.byte	11
 9728 046b 00       		.byte	0
 9729 046c 00       		.byte	0
 9730 046d FF       		.byte	-1
 9731 046e FF       		.byte	-1
 9732 046f 01       		.byte	1
 9733 0470 00       		.byte	0
 9734 0471 03       		.byte	3
 9735 0472 00       		.byte	0
 9736 0473 00       		.byte	0
 9737 0474 00       		.byte	0
 9738 0475 00       		.byte	0
 9739 0476 00       		.byte	0
 9740 0477 00       		.byte	0
 9741 0478 01       		.byte	1
 9742 0479 00       		.byte	0
 9743 047a 00       		.byte	0
 9744 047b 00000000 		.space	5
 9744      00
 9747              	glUVCHeader:
 9748 0480 0C       		.byte	12
 9749 0481 8C       		.byte	-116
 9750 0482 00       		.byte	0
 9751 0483 00       		.byte	0
 9752 0484 00       		.byte	0
 9753 0485 00       		.byte	0
 9754 0486 00       		.byte	0
 9755 0487 00       		.byte	0
 9756 0488 00       		.byte	0
 9757 0489 00       		.byte	0
 9758 048a 00       		.byte	0
 9759 048b 00       		.byte	0
 9762              	ROIMode:
 9763 048c 01       		.byte	1
 9764 048d 000000   		.space	3
 9767              	EXTShutter:
 9768 0490 00       		.byte	0
 9769 0491 02       		.byte	2
 9770 0492 02       		.byte	2
 9771 0493 00       		.byte	0
 9772 0494 00       		.byte	0
 9773 0495 08       		.byte	8
 9774 0496 00       		.byte	0
 9775 0497 01       		.byte	1
 9776 0498 00       		.byte	0
 9777 0499 03       		.byte	3
 9778 049a 00       		.byte	0
 9779 049b 00       		.byte	0
 9780 049c 00       		.byte	0
 9781 049d 00       		.byte	0
 9782 049e 00       		.byte	0
 9783 049f 30       		.byte	48
 9784 04a0 01       		.byte	1
 9785 04a1 00       		.byte	0
 9786 04a2 0000     		.space	2
 9789              	EXTShutlev:
 9790 04a4 02       		.byte	2
 9791 04a5 12       		.byte	18
 9792 04a6 02       		.byte	2
 9793 04a7 00       		.byte	0
 9794 04a8 00       		.byte	0
 9795 04a9 FF       		.byte	-1
 9796 04aa 7F       		.byte	127
 9797 04ab 01       		.byte	1
 9798 04ac 00       		.byte	0
 9799 04ad 03       		.byte	3
 9800 04ae 00       		.byte	0
 9801 04af 3F       		.byte	63
 9802 04b0 00       		.byte	0
 9803 04b1 3F       		.byte	63
 9804 04b2 00       		.byte	0
 9805 04b3 30       		.byte	48
 9806 04b4 01       		.byte	1
 9807 04b5 00       		.byte	0
 9808 04b6 0000     		.space	2
 9811              	EXTAexModGainlev:
 9812 04b8 00       		.byte	0
 9813 04b9 03       		.byte	3
 9814 04ba 04       		.byte	4
 9815 04bb 00       		.byte	0
 9816 04bc 00       		.byte	0
 9817 04bd 03       		.byte	3
 9818 04be 7F       		.byte	127
 9819 04bf 01       		.byte	1
 9820 04c0 00       		.byte	0
 9821 04c1 03       		.byte	3
 9822 04c2 00       		.byte	0
 9823 04c3 00       		.byte	0
 9824 04c4 3F       		.byte	63
 9825 04c5 00       		.byte	0
 9826 04c6 3F       		.byte	63
 9827 04c7 30       		.byte	48
 9828 04c8 01       		.byte	1
 9829 04c9 00       		.byte	0
 9830 04ca 0000     		.space	2
 9833              	WBMenuCmpArry:
 9834 04cc 20       		.byte	32
 9835 04cd 0F       		.byte	15
 9836 04ce 38       		.byte	56
 9837 04cf F0       		.byte	-16
 9840              	EXTBLCWinPos:
 9841 04d0 14       		.byte	20
 9842 04d1 13       		.byte	19
 9843 04d2 02       		.byte	2
 9844 04d3 00       		.byte	0
 9845 04d4 00       		.byte	0
 9846 04d5 FF       		.byte	-1
 9847 04d6 FF       		.byte	-1
 9848 04d7 01       		.byte	1
 9849 04d8 00       		.byte	0
 9850 04d9 03       		.byte	3
 9851 04da 00       		.byte	0
 9852 04db 66       		.byte	102
 9853 04dc 66       		.byte	102
 9854 04dd 66       		.byte	102
 9855 04de 66       		.byte	102
 9856 04df 30       		.byte	48
 9857 04e0 01       		.byte	1
 9858 04e1 00       		.byte	0
 9859 04e2 0000     		.space	2
 9862              	EXTBLCWeight:
 9863 04e4 11       		.byte	17
 9864 04e5 11       		.byte	17
 9865 04e6 02       		.byte	2
 9866 04e7 00       		.byte	0
 9867 04e8 00       		.byte	0
 9868 04e9 FF       		.byte	-1
 9869 04ea 00       		.byte	0
 9870 04eb 01       		.byte	1
 9871 04ec 00       		.byte	0
 9872 04ed 03       		.byte	3
 9873 04ee 00       		.byte	0
 9874 04ef 80       		.byte	-128
 9875 04f0 00       		.byte	0
 9876 04f1 80       		.byte	-128
 9877 04f2 00       		.byte	0
 9878 04f3 30       		.byte	48
 9879 04f4 01       		.byte	1
 9880 04f5 00       		.byte	0
 9881 04f6 0000     		.space	2
 9884              	PUCBLC:
 9885 04f8 10       		.byte	16
 9886 04f9 11       		.byte	17
 9887 04fa 02       		.byte	2
 9888 04fb 00       		.byte	0
 9889 04fc 00       		.byte	0
 9890 04fd 03       		.byte	3
 9891 04fe 00       		.byte	0
 9892 04ff 01       		.byte	1
 9893 0500 00       		.byte	0
 9894 0501 03       		.byte	3
 9895 0502 00       		.byte	0
 9896 0503 03       		.byte	3
 9897 0504 00       		.byte	0
 9898 0505 03       		.byte	3
 9899 0506 00       		.byte	0
 9900 0507 30       		.byte	48
 9901 0508 01       		.byte	1
 9902 0509 00       		.byte	0
 9903 050a 0000     		.space	2
 9906              	PUCSharp:
 9907 050c 06       		.byte	6
 9908 050d 07       		.byte	7
 9909 050e 02       		.byte	2
 9910 050f 00       		.byte	0
 9911 0510 00       		.byte	0
 9912 0511 08       		.byte	8
 9913 0512 00       		.byte	0
 9914 0513 01       		.byte	1
 9915 0514 00       		.byte	0
 9916 0515 03       		.byte	3
 9917 0516 00       		.byte	0
 9918 0517 00       		.byte	0
 9919 0518 00       		.byte	0
 9920 0519 00       		.byte	0
 9921 051a 00       		.byte	0
 9922 051b 30       		.byte	48
 9923 051c 01       		.byte	1
 9924 051d 00       		.byte	0
 9925 051e 0000     		.space	2
 9928              	CTCtrlParArry:
 9929 0520 00       		.byte	0
 9930 0521 00       		.byte	0
 9931 0522 01       		.byte	1
 9932 0523 00       		.byte	0
 9933 0524 00       		.byte	0
 9934 0525 03       		.byte	3
 9935 0526 00       		.byte	0
 9936 0527 01       		.byte	1
 9937 0528 00       		.byte	0
 9938 0529 03       		.byte	3
 9939 052a 00       		.byte	0
 9940 052b 03       		.byte	3
 9941 052c 00       		.byte	0
 9942 052d 03       		.byte	3
 9943 052e 00       		.byte	0
 9944 052f 30       		.byte	48
 9945 0530 01       		.byte	1
 9946 0531 00       		.byte	0
 9947 0532 00       		.byte	0
 9948 0533 00000000 		.space	5
 9948      00
 9949 0538 00       		.byte	0
 9950 0539 00       		.byte	0
 9951 053a 01       		.byte	1
 9952 053b 01       		.byte	1
 9953 053c 00       		.byte	0
 9954 053d 0F       		.byte	15
 9955 053e 00       		.byte	0
 9956 053f 0F       		.byte	15
 9957 0540 00       		.byte	0
 9958 0541 03       		.byte	3
 9959 0542 00       		.byte	0
 9960 0543 02       		.byte	2
 9961 0544 00       		.byte	0
 9962 0545 02       		.byte	2
 9963 0546 00       		.byte	0
 9964 0547 30       		.byte	48
 9965 0548 01       		.byte	1
 9966 0549 01       		.byte	1
 9967 054a 00       		.byte	0
 9968 054b 00000000 		.space	5
 9968      00
 9969 0550 02       		.byte	2
 9970 0551 00       		.byte	0
 9971 0552 01       		.byte	1
 9972 0553 00       		.byte	0
 9973 0554 00       		.byte	0
 9974 0555 01       		.byte	1
 9975 0556 00       		.byte	0
 9976 0557 01       		.byte	1
 9977 0558 00       		.byte	0
 9978 0559 03       		.byte	3
 9979 055a 00       		.byte	0
 9980 055b 00       		.byte	0
 9981 055c 00       		.byte	0
 9982 055d 00       		.byte	0
 9983 055e 00       		.byte	0
 9984 055f 30       		.byte	48
 9985 0560 01       		.byte	1
 9986 0561 01       		.byte	1
 9987 0562 00       		.byte	0
 9988 0563 00000000 		.space	5
 9988      00
 9989 0568 00       		.byte	0
 9990 0569 00       		.byte	0
 9991 056a 04       		.byte	4
 9992 056b 01       		.byte	1
 9993 056c 00       		.byte	0
 9994 056d 38       		.byte	56
 9995 056e 01       		.byte	1
 9996 056f 01       		.byte	1
 9997 0570 00       		.byte	0
 9998 0571 03       		.byte	3
 9999 0572 00       		.byte	0
 10000 0573 4E       		.byte	78
 10001 0574 00       		.byte	0
 10002 0575 4E       		.byte	78
 10003 0576 00       		.byte	0
 10004 0577 30       		.byte	48
 10005 0578 01       		.byte	1
 10006 0579 00       		.byte	0
 10007 057a 00       		.byte	0
 10008 057b 00000000 		.space	5
 10008      00
 10009 0580 04       		.byte	4
 10010 0581 00       		.byte	0
 10011 0582 01       		.byte	1
 10012 0583 00       		.byte	0
 10013 0584 00       		.byte	0
 10014 0585 00       		.byte	0
 10015 0586 00       		.byte	0
 10016 0587 01       		.byte	1
 10017 0588 00       		.byte	0
 10018 0589 03       		.byte	3
 10019 058a 00       		.byte	0
 10020 058b 00       		.byte	0
 10021 058c 00       		.byte	0
 10022 058d 00       		.byte	0
 10023 058e 00       		.byte	0
 10024 058f 30       		.byte	48
 10025 0590 01       		.byte	1
 10026 0591 00       		.byte	0
 10027 0592 00       		.byte	0
 10028 0593 00000000 		.space	5
 10028      00
 10029 0598 05       		.byte	5
 10030 0599 00       		.byte	0
 10031 059a 02       		.byte	2
 10032 059b 00       		.byte	0
 10033 059c 00       		.byte	0
 10034 059d FF       		.byte	-1
 10035 059e 00       		.byte	0
 10036 059f 01       		.byte	1
 10037 05a0 00       		.byte	0
 10038 05a1 03       		.byte	3
 10039 05a2 00       		.byte	0
 10040 05a3 01       		.byte	1
 10041 05a4 00       		.byte	0
 10042 05a5 00       		.byte	0
 10043 05a6 00       		.byte	0
 10044 05a7 30       		.byte	48
 10045 05a8 01       		.byte	1
 10046 05a9 01       		.byte	1
 10047 05aa 00       		.byte	0
 10048 05ab 00000000 		.space	5
 10048      00
 10049 05b0 06       		.byte	6
 10050 05b1 00       		.byte	0
 10051 05b2 02       		.byte	2
 10052 05b3 00       		.byte	0
 10053 05b4 00       		.byte	0
 10054 05b5 00       		.byte	0
 10055 05b6 00       		.byte	0
 10056 05b7 00       		.byte	0
 10057 05b8 00       		.byte	0
 10058 05b9 03       		.byte	3
 10059 05ba 00       		.byte	0
 10060 05bb 00       		.byte	0
 10061 05bc 00       		.byte	0
 10062 05bd 00       		.byte	0
 10063 05be 00       		.byte	0
 10064 05bf 30       		.byte	48
 10065 05c0 01       		.byte	1
 10066 05c1 01       		.byte	1
 10067 05c2 00       		.byte	0
 10068 05c3 00000000 		.space	5
 10068      00
 10069 05c8 23       		.byte	35
 10070 05c9 00       		.byte	0
 10071 05ca 02       		.byte	2
 10072 05cb 00       		.byte	0
 10073 05cc 00       		.byte	0
 10074 05cd 30       		.byte	48
 10075 05ce 00       		.byte	0
 10076 05cf 01       		.byte	1
 10077 05d0 00       		.byte	0
 10078 05d1 03       		.byte	3
 10079 05d2 0A       		.byte	10
 10080 05d3 00       		.byte	0
 10081 05d4 00       		.byte	0
 10082 05d5 0A       		.byte	10
 10083 05d6 00       		.byte	0
 10084 05d7 30       		.byte	48
 10085 05d8 01       		.byte	1
 10086 05d9 01       		.byte	1
 10087 05da 00       		.byte	0
 10088 05db 00000000 		.space	5
 10088      00
 10089 05e0 08       		.byte	8
 10090 05e1 00       		.byte	0
 10091 05e2 01       		.byte	1
 10092 05e3 00       		.byte	0
 10093 05e4 00       		.byte	0
 10094 05e5 7F       		.byte	127
 10095 05e6 00       		.byte	0
 10096 05e7 01       		.byte	1
 10097 05e8 00       		.byte	0
 10098 05e9 03       		.byte	3
 10099 05ea 00       		.byte	0
 10100 05eb 00       		.byte	0
 10101 05ec 00       		.byte	0
 10102 05ed 00       		.byte	0
 10103 05ee 00       		.byte	0
 10104 05ef 30       		.byte	48
 10105 05f0 01       		.byte	1
 10106 05f1 00       		.byte	0
 10107 05f2 00       		.byte	0
 10108 05f3 00000000 		.space	5
 10108      00
 10109 05f8 09       		.byte	9
 10110 05f9 00       		.byte	0
 10111 05fa 02       		.byte	2
 10112 05fb 00       		.byte	0
 10113 05fc 00       		.byte	0
 10114 05fd 05       		.byte	5
 10115 05fe 00       		.byte	0
 10116 05ff 01       		.byte	1
 10117 0600 00       		.byte	0
 10118 0601 03       		.byte	3
 10119 0602 00       		.byte	0
 10120 0603 00       		.byte	0
 10121 0604 00       		.byte	0
 10122 0605 00       		.byte	0
 10123 0606 00       		.byte	0
 10124 0607 30       		.byte	48
 10125 0608 01       		.byte	1
 10126 0609 00       		.byte	0
 10127 060a 00       		.byte	0
 10128 060b 00000000 		.space	5
 10128      00
 10129 0610 10       		.byte	16
 10130 0611 00       		.byte	0
 10131 0612 03       		.byte	3
 10132 0613 00       		.byte	0
 10133 0614 00       		.byte	0
 10134 0615 00       		.byte	0
 10135 0616 00       		.byte	0
 10136 0617 00       		.byte	0
 10137 0618 00       		.byte	0
 10138 0619 03       		.byte	3
 10139 061a 00       		.byte	0
 10140 061b 00       		.byte	0
 10141 061c 00       		.byte	0
 10142 061d 00       		.byte	0
 10143 061e 00       		.byte	0
 10144 061f 30       		.byte	48
 10145 0620 01       		.byte	1
 10146 0621 00       		.byte	0
 10147 0622 00       		.byte	0
 10148 0623 00000000 		.space	5
 10148      00
 10149 0628 00       		.byte	0
 10150 0629 00       		.byte	0
 10151 062a 02       		.byte	2
 10152 062b 00       		.byte	0
 10153 062c 00       		.byte	0
 10154 062d 40       		.byte	64
 10155 062e 00       		.byte	0
 10156 062f 01       		.byte	1
 10157 0630 00       		.byte	0
 10158 0631 03       		.byte	3
 10159 0632 00       		.byte	0
 10160 0633 0F       		.byte	15
 10161 0634 11       		.byte	17
 10162 0635 00       		.byte	0
 10163 0636 00       		.byte	0
 10164 0637 30       		.byte	48
 10165 0638 01       		.byte	1
 10166 0639 00       		.byte	0
 10167 063a 00       		.byte	0
 10168 063b 00000000 		.space	5
 10168      00
 10169 0640 00       		.byte	0
 10170 0641 00       		.byte	0
 10171 0642 02       		.byte	2
 10172 0643 00       		.byte	0
 10173 0644 00       		.byte	0
 10174 0645 64       		.byte	100
 10175 0646 00       		.byte	0
 10176 0647 01       		.byte	1
 10177 0648 00       		.byte	0
 10178 0649 03       		.byte	3
 10179 064a 00       		.byte	0
 10180 064b 00       		.byte	0
 10181 064c 00       		.byte	0
 10182 064d 00       		.byte	0
 10183 064e 00       		.byte	0
 10184 064f 30       		.byte	48
 10185 0650 01       		.byte	1
 10186 0651 00       		.byte	0
 10187 0652 00       		.byte	0
 10188 0653 00000000 		.space	5
 10188      00
 10189 0658 00       		.byte	0
 10190 0659 00       		.byte	0
 10191 065a 02       		.byte	2
 10192 065b 00       		.byte	0
 10193 065c 00       		.byte	0
 10194 065d 64       		.byte	100
 10195 065e 00       		.byte	0
 10196 065f 01       		.byte	1
 10197 0660 00       		.byte	0
 10198 0661 03       		.byte	3
 10199 0662 00       		.byte	0
 10200 0663 00       		.byte	0
 10201 0664 00       		.byte	0
 10202 0665 00       		.byte	0
 10203 0666 00       		.byte	0
 10204 0667 30       		.byte	48
 10205 0668 01       		.byte	1
 10206 0669 00       		.byte	0
 10207 066a 00       		.byte	0
 10208 066b 00000000 		.space	5
 10208      00
 10209 0670 00       		.byte	0
 10210 0671 00       		.byte	0
 10211 0672 02       		.byte	2
 10212 0673 00       		.byte	0
 10213 0674 00       		.byte	0
 10214 0675 64       		.byte	100
 10215 0676 00       		.byte	0
 10216 0677 01       		.byte	1
 10217 0678 00       		.byte	0
 10218 0679 03       		.byte	3
 10219 067a 00       		.byte	0
 10220 067b 00       		.byte	0
 10221 067c 00       		.byte	0
 10222 067d 00       		.byte	0
 10223 067e 00       		.byte	0
 10224 067f 30       		.byte	48
 10225 0680 01       		.byte	1
 10226 0681 00       		.byte	0
 10227 0682 00       		.byte	0
 10228 0683 00000000 		.space	5
 10228      00
 10229 0688 00       		.byte	0
 10230 0689 00       		.byte	0
 10231 068a 02       		.byte	2
 10232 068b 00       		.byte	0
 10233 068c 00       		.byte	0
 10234 068d 64       		.byte	100
 10235 068e 00       		.byte	0
 10236 068f 01       		.byte	1
 10237 0690 00       		.byte	0
 10238 0691 03       		.byte	3
 10239 0692 00       		.byte	0
 10240 0693 00       		.byte	0
 10241 0694 00       		.byte	0
 10242 0695 00       		.byte	0
 10243 0696 00       		.byte	0
 10244 0697 30       		.byte	48
 10245 0698 01       		.byte	1
 10246 0699 00       		.byte	0
 10247 069a 00       		.byte	0
 10248 069b 00000000 		.space	5
 10248      00
 10251              	glProbeCtrlFull:
 10252 06a0 00       		.byte	0
 10253 06a1 00       		.byte	0
 10254 06a2 01       		.byte	1
 10255 06a3 01       		.byte	1
 10256 06a4 15       		.byte	21
 10257 06a5 16       		.byte	22
 10258 06a6 05       		.byte	5
 10259 06a7 00       		.byte	0
 10260 06a8 00       		.byte	0
 10261 06a9 00       		.byte	0
 10262 06aa 00       		.byte	0
 10263 06ab 00       		.byte	0
 10264 06ac 00       		.byte	0
 10265 06ad 00       		.byte	0
 10266 06ae 00       		.byte	0
 10267 06af 00       		.byte	0
 10268 06b0 00       		.byte	0
 10269 06b1 00       		.byte	0
 10270 06b2 00       		.byte	0
 10271 06b3 C6       		.byte	-58
 10272 06b4 99       		.byte	-103
 10273 06b5 00       		.byte	0
 10274 06b6 00       		.byte	0
 10275 06b7 40       		.byte	64
 10276 06b8 00       		.byte	0
 10277 06b9 00       		.byte	0
 10278 06ba 0000     		.space	2
 10281              	glProbeCtrl20:
 10282 06bc 00       		.byte	0
 10283 06bd 00       		.byte	0
 10284 06be 01       		.byte	1
 10285 06bf 01       		.byte	1
 10286 06c0 80       		.byte	-128
 10287 06c1 1A       		.byte	26
 10288 06c2 06       		.byte	6
 10289 06c3 00       		.byte	0
 10290 06c4 00       		.byte	0
 10291 06c5 00       		.byte	0
 10292 06c6 00       		.byte	0
 10293 06c7 00       		.byte	0
 10294 06c8 00       		.byte	0
 10295 06c9 00       		.byte	0
 10296 06ca 00       		.byte	0
 10297 06cb 00       		.byte	0
 10298 06cc 00       		.byte	0
 10299 06cd 00       		.byte	0
 10300 06ce 00       		.byte	0
 10301 06cf D2       		.byte	-46
 10302 06d0 0F       		.byte	15
 10303 06d1 00       		.byte	0
 10304 06d2 00       		.byte	0
 10305 06d3 40       		.byte	64
 10306 06d4 00       		.byte	0
 10307 06d5 00       		.byte	0
 10308 06d6 0000     		.space	2
 10311              	glProbeCtrl:
 10312 06d8 00       		.byte	0
 10313 06d9 00       		.byte	0
 10314 06da 01       		.byte	1
 10315 06db 01       		.byte	1
 10316 06dc 15       		.byte	21
 10317 06dd 16       		.byte	22
 10318 06de 05       		.byte	5
 10319 06df 00       		.byte	0
 10320 06e0 00       		.byte	0
 10321 06e1 00       		.byte	0
 10322 06e2 00       		.byte	0
 10323 06e3 00       		.byte	0
 10324 06e4 00       		.byte	0
 10325 06e5 00       		.byte	0
 10326 06e6 00       		.byte	0
 10327 06e7 00       		.byte	0
 10328 06e8 00       		.byte	0
 10329 06e9 00       		.byte	0
 10330 06ea 00       		.byte	0
 10331 06eb 48       		.byte	72
 10332 06ec 3F       		.byte	63
 10333 06ed 00       		.byte	0
 10334 06ee 00       		.byte	0
 10335 06ef 40       		.byte	64
 10336 06f0 00       		.byte	0
 10337 06f1 00       		.byte	0
 10338 06f2 0000     		.space	2
 10341              	glProbeStilCtrl:
 10342 06f4 01       		.byte	1
 10343 06f5 02       		.byte	2
 10344 06f6 00       		.byte	0
 10345 06f7 00       		.byte	0
 10346 06f8 C6       		.byte	-58
 10347 06f9 99       		.byte	-103
 10348 06fa 00       		.byte	0
 10349 06fb 00       		.byte	0
 10350 06fc 40       		.byte	64
 10351 06fd 00       		.byte	0
 10352 06fe 00       		.byte	0
 10353 06ff 00       		.space	1
 10356              	glProbeStilCtrl20:
 10357 0700 01       		.byte	1
 10358 0701 01       		.byte	1
 10359 0702 00       		.byte	0
 10360 0703 00       		.byte	0
 10361 0704 D2       		.byte	-46
 10362 0705 0F       		.byte	15
 10363 0706 00       		.byte	0
 10364 0707 00       		.byte	0
 10365 0708 40       		.byte	64
 10366 0709 00       		.byte	0
 10367 070a 00       		.byte	0
 10370              	snapButFlag:
 10371 070b 01       		.byte	1
 10374              	CyFxGpifTransition:
 10375 070c 0000     		.short	0
 10376 070e 5555     		.short	21845
 10377 0710 8888     		.short	-30584
 10378 0712 AAAA     		.short	-21846
 10379 0714 3333     		.short	13107
 10380 0716 0000     		.space	2
 10383              	CyFxGpifWavedata:
 10384 0718 0181731E 		.word	510886145
 10385 071c 00000000 		.word	0
 10386 0720 00000080 		.word	-2147483648
 10387 0724 00000000 		.word	0
 10388 0728 00000000 		.word	0
 10389 072c 00000000 		.word	0
 10390 0730 0201702E 		.word	779092226
 10391 0734 00010000 		.word	256
 10392 0738 A0000080 		.word	-2147483488
 10393 073c 00000000 		.word	0
 10394 0740 00000000 		.word	0
 10395 0744 00000000 		.word	0
 10396 0748 0380722E 		.word	779255811
 10397 074c 02010020 		.word	536871170
 10398 0750 60000080 		.word	-2147483552
 10399 0754 00000000 		.word	0
 10400 0758 00000000 		.word	0
 10401 075c 00000000 		.word	0
 10402 0760 0460722E 		.word	779247620
 10403 0764 02010024 		.word	603980034
 10404 0768 90000080 		.word	-2147483504
 10405 076c 0594731E 		.word	510891013
 10406 0770 06000000 		.word	6
 10407 0774 00000080 		.word	-2147483648
 10408 0778 0380722E 		.word	779255811
 10409 077c 02010020 		.word	536871170
 10410 0780 60000080 		.word	-2147483552
 10411 0784 0693731E 		.word	510890758
 10412 0788 06000000 		.word	6
 10413 078c 00000080 		.word	-2147483648
 10414 0790 0720703E 		.word	1047535623
 10415 0794 08010000 		.word	264
 10416 0798 00000080 		.word	-2147483648
 10417 079c 0820703E 		.word	1047535624
 10418 07a0 08010000 		.word	264
 10419 07a4 00000080 		.word	-2147483648
 10420 07a8 0920703E 		.word	1047535625
 10421 07ac 08010000 		.word	264
 10422 07b0 00000080 		.word	-2147483648
 10423 07b4 0A20703E 		.word	1047535626
 10424 07b8 08010000 		.word	264
 10425 07bc 00000080 		.word	-2147483648
 10426 07c0 0380722E 		.word	779255811
 10427 07c4 02010020 		.word	536871170
 10428 07c8 60000080 		.word	-2147483552
 10429 07cc 0B000000 		.word	11
 10430 07d0 00000000 		.word	0
 10431 07d4 00010080 		.word	-2147483392
 10432 07d8 0460722E 		.word	779247620
 10433 07dc 02010024 		.word	603980034
 10434 07e0 90000080 		.word	-2147483504
 10435 07e4 0D000000 		.word	13
 10436 07e8 00000000 		.word	0
 10437 07ec 00010080 		.word	-2147483392
 10438 07f0 0460722E 		.word	779247620
 10439 07f4 02010024 		.word	603980034
 10440 07f8 90000080 		.word	-2147483504
 10441 07fc 0C000000 		.word	12
 10442 0800 00000000 		.word	0
 10443 0804 00010080 		.word	-2147483392
 10444 0808 0380722E 		.word	779255811
 10445 080c 02010020 		.word	536871170
 10446 0810 60000080 		.word	-2147483552
 10447 0814 0E000000 		.word	14
 10448 0818 00000000 		.word	0
 10449 081c 00010080 		.word	-2147483392
 10450 0820 00000000 		.word	0
 10451 0824 00000000 		.word	0
 10452 0828 00000000 		.word	0
 10453 082c 00000000 		.word	0
 10454 0830 00000000 		.word	0
 10455 0834 00000000 		.word	0
 10458              	CyFxGpifWavedataPosition:
 10459 0838 00       		.byte	0
 10460 0839 01       		.byte	1
 10461 083a 02       		.byte	2
 10462 083b 03       		.byte	3
 10463 083c 04       		.byte	4
 10464 083d 05       		.byte	5
 10465 083e 06       		.byte	6
 10466 083f 07       		.byte	7
 10467 0840 08       		.byte	8
 10468 0841 09       		.byte	9
 10469 0842 0A       		.byte	10
 10470 0843 0B       		.byte	11
 10471 0844 0B       		.byte	11
 10472 0845 0B       		.byte	11
 10473 0846 0B       		.byte	11
 10474 0847 00       		.space	1
 10477              	CyFxGpifRegValue:
 10478 0848 08830080 		.word	-2147450104
 10479 084c 67000000 		.word	103
 10480 0850 00000000 		.word	0
 10481 0854 46000000 		.word	70
 10482 0858 00000000 		.word	0
 10483 085c 00000000 		.word	0
 10484 0860 02000000 		.word	2
 10485 0864 82000000 		.word	130
 10486 0868 82070000 		.word	1922
 10487 086c 40040000 		.word	1088
 10488 0870 FCFF0000 		.word	65532
 10489 0874 28000000 		.word	40
 10490 0878 00000000 		.word	0
 10491 087c 00000000 		.word	0
 10492 0880 00000000 		.word	0
 10493 0884 00000000 		.word	0
 10494 0888 01000000 		.word	1
 10495 088c 00000000 		.word	0
 10496 0890 00000000 		.word	0
 10497 0894 00000000 		.word	0
 10498 0898 00000000 		.word	0
 10499 089c 00000000 		.word	0
 10500 08a0 00000000 		.word	0
 10501 08a4 00000000 		.word	0
 10502 08a8 00000000 		.word	0
 10503 08ac 00000000 		.word	0
 10504 08b0 00000000 		.word	0
 10505 08b4 00000000 		.word	0
 10506 08b8 00000000 		.word	0
 10507 08bc 06000000 		.word	6
 10508 08c0 00000000 		.word	0
 10509 08c4 FFFF0000 		.word	65535
 10510 08c8 09010000 		.word	265
 10511 08cc 00000000 		.word	0
 10512 08d0 F71F0000 		.word	8183
 10513 08d4 00000000 		.word	0
 10514 08d8 FFFF0000 		.word	65535
 10515 08dc 09010000 		.word	265
 10516 08e0 00000000 		.word	0
 10517 08e4 F71F0000 		.word	8183
 10518 08e8 00000000 		.word	0
 10519 08ec 00000000 		.word	0
 10520 08f0 00000000 		.word	0
 10521 08f4 00000000 		.word	0
 10522 08f8 00000000 		.word	0
 10523 08fc 00000000 		.word	0
 10524 0900 00000000 		.word	0
 10525 0904 00000000 		.word	0
 10526 0908 00000000 		.word	0
 10527 090c 00000000 		.word	0
 10528 0910 00000000 		.word	0
 10529 0914 00000000 		.word	0
 10530 0918 00000000 		.word	0
 10531 091c 00000000 		.word	0
 10532 0920 00000000 		.word	0
 10533 0924 00000000 		.word	0
 10534 0928 00000000 		.word	0
 10535 092c 00000000 		.word	0
 10536 0930 00000000 		.word	0
 10537 0934 00000000 		.word	0
 10538 0938 00000000 		.word	0
 10539 093c 00000000 		.word	0
 10540 0940 00000000 		.word	0
 10541 0944 00040180 		.word	-2147417088
 10542 0948 01040180 		.word	-2147417087
 10543 094c 02040180 		.word	-2147417086
 10544 0950 03040180 		.word	-2147417085
 10545 0954 00000000 		.word	0
 10546 0958 00000000 		.word	0
 10547 095c 00000000 		.word	0
 10548 0960 00000000 		.word	0
 10549 0964 00000000 		.word	0
 10550 0968 00000000 		.word	0
 10551 096c 00000000 		.word	0
 10552 0970 00000000 		.word	0
 10553 0974 C1FFFFFF 		.word	-63
 10556              	CyFxGpifTransition_usb2:
 10557 0978 0000     		.short	0
 10558 097a 5555     		.short	21845
 10559 097c AAAA     		.short	-21846
 10560 097e 8888     		.short	-30584
 10561 0980 1111     		.short	4369
 10562 0982 4444     		.short	17476
 10563 0984 3333     		.short	13107
 10564 0986 CCCC     		.short	-13108
 10567              	CyFxGpifWavedata_usb2:
 10568 0988 0181731E 		.word	510886145
 10569 098c 00000000 		.word	0
 10570 0990 00000080 		.word	-2147483648
 10571 0994 00000000 		.word	0
 10572 0998 00000000 		.word	0
 10573 099c 00000000 		.word	0
 10574 09a0 0201703E 		.word	1047527682
 10575 09a4 00010000 		.word	256
 10576 09a8 A00000C0 		.word	-1073741664
 10577 09ac 00000000 		.word	0
 10578 09b0 00000000 		.word	0
 10579 09b4 00000000 		.word	0
 10580 09b8 0394731E 		.word	510891011
 10581 09bc 04000020 		.word	536870916
 10582 09c0 60004080 		.word	-2143289248
 10583 09c4 00000000 		.word	0
 10584 09c8 00000000 		.word	0
 10585 09cc 00000000 		.word	0
 10586 09d0 0620702E 		.word	779100166
 10587 09d4 0C000000 		.word	12
 10588 09d8 00000080 		.word	-2147483648
 10589 09dc 0620702E 		.word	779100166
 10590 09e0 0C000000 		.word	12
 10591 09e4 00000080 		.word	-2147483648
 10592 09e8 0394731E 		.word	510891011
 10593 09ec 04000020 		.word	536870916
 10594 09f0 60004080 		.word	-2143289248
 10595 09f4 0620702E 		.word	779100166
 10596 09f8 0C000000 		.word	12
 10597 09fc 00000080 		.word	-2147483648
 10598 0a00 0C93731E 		.word	510890764
 10599 0a04 04000024 		.word	603979780
 10600 0a08 90004080 		.word	-2143289200
 10601 0a0c 0D20702E 		.word	779100173
 10602 0a10 0C000000 		.word	12
 10603 0a14 00000080 		.word	-2147483648
 10604 0a18 0780724E 		.word	1316126727
 10605 0a1c 0A000000 		.word	10
 10606 0a20 00000080 		.word	-2147483648
 10607 0a24 08000000 		.word	8
 10608 0a28 00000000 		.word	0
 10609 0a2c 00010080 		.word	-2147483392
 10610 0a30 0920702E 		.word	779100169
 10611 0a34 0C010000 		.word	268
 10612 0a38 00000080 		.word	-2147483648
 10613 0a3c 0A01701E 		.word	510656778
 10614 0a40 0E000100 		.word	65550
 10615 0a44 00000080 		.word	-2147483648
 10616 0a48 00000000 		.word	0
 10617 0a4c 00000000 		.word	0
 10618 0a50 00000000 		.word	0
 10619 0a54 00000000 		.word	0
 10620 0a58 00000000 		.word	0
 10621 0a5c 00000000 		.word	0
 10622 0a60 0394731E 		.word	510891011
 10623 0a64 04000020 		.word	536870916
 10624 0a68 60004080 		.word	-2143289248
 10625 0a6c 08000000 		.word	8
 10626 0a70 00000000 		.word	0
 10627 0a74 00010080 		.word	-2147483392
 10628 0a78 0B000000 		.word	11
 10629 0a7c 00000000 		.word	0
 10630 0a80 00010080 		.word	-2147483392
 10631 0a84 0C93731E 		.word	510890764
 10632 0a88 04000024 		.word	603979780
 10633 0a8c 90004080 		.word	-2143289200
 10634 0a90 0D20702E 		.word	779100173
 10635 0a94 0C000000 		.word	12
 10636 0a98 00000080 		.word	-2147483648
 10637 0a9c 0D20702E 		.word	779100173
 10638 0aa0 0C000000 		.word	12
 10639 0aa4 00000080 		.word	-2147483648
 10640 0aa8 0E60724E 		.word	1316118542
 10641 0aac 0A000000 		.word	10
 10642 0ab0 00000080 		.word	-2147483648
 10643 0ab4 0F000000 		.word	15
 10644 0ab8 00000000 		.word	0
 10645 0abc 00010080 		.word	-2147483392
 10646 0ac0 1020702E 		.word	779100176
 10647 0ac4 0C010000 		.word	268
 10648 0ac8 00000080 		.word	-2147483648
 10649 0acc 1101701E 		.word	510656785
 10650 0ad0 0E000100 		.word	65550
 10651 0ad4 00000080 		.word	-2147483648
 10652 0ad8 0C93731E 		.word	510890764
 10653 0adc 04000024 		.word	603979780
 10654 0ae0 90004080 		.word	-2143289200
 10655 0ae4 0F000000 		.word	15
 10656 0ae8 00000000 		.word	0
 10657 0aec 00010080 		.word	-2147483392
 10658 0af0 12000000 		.word	18
 10659 0af4 00000000 		.word	0
 10660 0af8 00010080 		.word	-2147483392
 10661 0afc 0394731E 		.word	510891011
 10662 0b00 04000020 		.word	536870916
 10663 0b04 60004080 		.word	-2143289248
 10664 0b08 0480732E 		.word	779321348
 10665 0b0c 02010000 		.word	258
 10666 0b10 0000C0C0 		.word	-1061158912
 10667 0b14 0580732E 		.word	779321349
 10668 0b18 02010000 		.word	258
 10669 0b1c 0000C0C0 		.word	-1061158912
 10670 0b20 0580732E 		.word	779321349
 10671 0b24 02010000 		.word	258
 10672 0b28 0000C0C0 		.word	-1061158912
 10673 0b2c 0480732E 		.word	779321348
 10674 0b30 02010000 		.word	258
 10675 0b34 0000C0C0 		.word	-1061158912
 10678              	CyFxGpifWavedataPosition_usb2:
 10679 0b38 00       		.byte	0
 10680 0b39 01       		.byte	1
 10681 0b3a 02       		.byte	2
 10682 0b3b 03       		.byte	3
 10683 0b3c 04       		.byte	4
 10684 0b3d 05       		.byte	5
 10685 0b3e 06       		.byte	6
 10686 0b3f 07       		.byte	7
 10687 0b40 08       		.byte	8
 10688 0b41 09       		.byte	9
 10689 0b42 0A       		.byte	10
 10690 0b43 08       		.byte	8
 10691 0b44 0B       		.byte	11
 10692 0b45 0C       		.byte	12
 10693 0b46 0D       		.byte	13
 10694 0b47 08       		.byte	8
 10695 0b48 0E       		.byte	14
 10696 0b49 0F       		.byte	15
 10697 0b4a 08       		.byte	8
 10698 0b4b 08       		.byte	8
 10699 0b4c 08       		.byte	8
 10700 0b4d 08       		.byte	8
 10701 0b4e 08       		.byte	8
 10702 0b4f 08       		.byte	8
 10703 0b50 08       		.byte	8
 10704 0b51 08       		.byte	8
 10705 0b52 08       		.byte	8
 10706 0b53 08       		.byte	8
 10707 0b54 08       		.byte	8
 10708 0b55 08       		.byte	8
 10709 0b56 08       		.byte	8
 10710 0b57 08       		.byte	8
 10711 0b58 08       		.byte	8
 10712 0b59 08       		.byte	8
 10713 0b5a 08       		.byte	8
 10714 0b5b 08       		.byte	8
 10715 0b5c 08       		.byte	8
 10716 0b5d 08       		.byte	8
 10717 0b5e 08       		.byte	8
 10718 0b5f 08       		.byte	8
 10719 0b60 08       		.byte	8
 10720 0b61 08       		.byte	8
 10721 0b62 08       		.byte	8
 10722 0b63 08       		.byte	8
 10723 0b64 08       		.byte	8
 10724 0b65 08       		.byte	8
 10725 0b66 08       		.byte	8
 10726 0b67 08       		.byte	8
 10727 0b68 08       		.byte	8
 10728 0b69 08       		.byte	8
 10729 0b6a 08       		.byte	8
 10730 0b6b 08       		.byte	8
 10731 0b6c 08       		.byte	8
 10732 0b6d 08       		.byte	8
 10733 0b6e 08       		.byte	8
 10734 0b6f 08       		.byte	8
 10735 0b70 08       		.byte	8
 10736 0b71 08       		.byte	8
 10737 0b72 08       		.byte	8
 10738 0b73 08       		.byte	8
 10739 0b74 08       		.byte	8
 10740 0b75 08       		.byte	8
 10741 0b76 08       		.byte	8
 10742 0b77 08       		.byte	8
 10743 0b78 08       		.byte	8
 10744 0b79 08       		.byte	8
 10745 0b7a 08       		.byte	8
 10746 0b7b 08       		.byte	8
 10747 0b7c 08       		.byte	8
 10748 0b7d 08       		.byte	8
 10749 0b7e 08       		.byte	8
 10750 0b7f 08       		.byte	8
 10751 0b80 08       		.byte	8
 10752 0b81 08       		.byte	8
 10753 0b82 08       		.byte	8
 10754 0b83 08       		.byte	8
 10755 0b84 08       		.byte	8
 10756 0b85 08       		.byte	8
 10757 0b86 08       		.byte	8
 10758 0b87 08       		.byte	8
 10759 0b88 08       		.byte	8
 10760 0b89 08       		.byte	8
 10761 0b8a 08       		.byte	8
 10762 0b8b 08       		.byte	8
 10763 0b8c 08       		.byte	8
 10764 0b8d 08       		.byte	8
 10765 0b8e 08       		.byte	8
 10766 0b8f 08       		.byte	8
 10767 0b90 08       		.byte	8
 10768 0b91 08       		.byte	8
 10769 0b92 08       		.byte	8
 10770 0b93 08       		.byte	8
 10771 0b94 08       		.byte	8
 10772 0b95 08       		.byte	8
 10773 0b96 08       		.byte	8
 10774 0b97 08       		.byte	8
 10775 0b98 08       		.byte	8
 10776 0b99 08       		.byte	8
 10777 0b9a 08       		.byte	8
 10778 0b9b 08       		.byte	8
 10779 0b9c 08       		.byte	8
 10780 0b9d 08       		.byte	8
 10781 0b9e 08       		.byte	8
 10782 0b9f 08       		.byte	8
 10783 0ba0 08       		.byte	8
 10784 0ba1 08       		.byte	8
 10785 0ba2 08       		.byte	8
 10786 0ba3 08       		.byte	8
 10787 0ba4 08       		.byte	8
 10788 0ba5 08       		.byte	8
 10789 0ba6 08       		.byte	8
 10790 0ba7 08       		.byte	8
 10791 0ba8 08       		.byte	8
 10792 0ba9 08       		.byte	8
 10793 0baa 08       		.byte	8
 10794 0bab 08       		.byte	8
 10795 0bac 08       		.byte	8
 10796 0bad 08       		.byte	8
 10797 0bae 08       		.byte	8
 10798 0baf 08       		.byte	8
 10799 0bb0 08       		.byte	8
 10800 0bb1 08       		.byte	8
 10801 0bb2 08       		.byte	8
 10802 0bb3 08       		.byte	8
 10803 0bb4 08       		.byte	8
 10804 0bb5 08       		.byte	8
 10805 0bb6 08       		.byte	8
 10806 0bb7 08       		.byte	8
 10807 0bb8 00       		.byte	0
 10808 0bb9 01       		.byte	1
 10809 0bba 02       		.byte	2
 10810 0bbb 10       		.byte	16
 10811 0bbc 04       		.byte	4
 10812 0bbd 05       		.byte	5
 10813 0bbe 06       		.byte	6
 10814 0bbf 07       		.byte	7
 10815 0bc0 08       		.byte	8
 10816 0bc1 09       		.byte	9
 10817 0bc2 0A       		.byte	10
 10818 0bc3 08       		.byte	8
 10819 0bc4 11       		.byte	17
 10820 0bc5 0C       		.byte	12
 10821 0bc6 0D       		.byte	13
 10822 0bc7 08       		.byte	8
 10823 0bc8 0E       		.byte	14
 10824 0bc9 0F       		.byte	15
 10825 0bca 08       		.byte	8
 10826 0bcb 00       		.space	1
 10829              	CyFxGpifRegValue_usb2:
 10830 0bcc 08830080 		.word	-2147450104
 10831 0bd0 67000000 		.word	103
 10832 0bd4 01000000 		.word	1
 10833 0bd8 46000000 		.word	70
 10834 0bdc 00000000 		.word	0
 10835 0be0 00000000 		.word	0
 10836 0be4 02000000 		.word	2
 10837 0be8 82000000 		.word	130
 10838 0bec 82070000 		.word	1922
 10839 0bf0 40040000 		.word	1088
 10840 0bf4 FCFF0000 		.word	65532
 10841 0bf8 28000000 		.word	40
 10842 0bfc 00000000 		.word	0
 10843 0c00 00000000 		.word	0
 10844 0c04 00000000 		.word	0
 10845 0c08 00000000 		.word	0
 10846 0c0c 01000000 		.word	1
 10847 0c10 00000000 		.word	0
 10848 0c14 00000000 		.word	0
 10849 0c18 00000000 		.word	0
 10850 0c1c 00000000 		.word	0
 10851 0c20 00000000 		.word	0
 10852 0c24 00000000 		.word	0
 10853 0c28 00000000 		.word	0
 10854 0c2c 00000000 		.word	0
 10855 0c30 00000000 		.word	0
 10856 0c34 00000000 		.word	0
 10857 0c38 00000000 		.word	0
 10858 0c3c 00000000 		.word	0
 10859 0c40 06000000 		.word	6
 10860 0c44 00000000 		.word	0
 10861 0c48 FFFF0000 		.word	65535
 10862 0c4c 09010000 		.word	265
 10863 0c50 00000000 		.word	0
 10864 0c54 F71F0000 		.word	8183
 10865 0c58 00000000 		.word	0
 10866 0c5c FFFF0000 		.word	65535
 10867 0c60 09010000 		.word	265
 10868 0c64 00000000 		.word	0
 10869 0c68 F71F0000 		.word	8183
 10870 0c6c 00000000 		.word	0
 10871 0c70 00000000 		.word	0
 10872 0c74 00000000 		.word	0
 10873 0c78 00000000 		.word	0
 10874 0c7c 00000000 		.word	0
 10875 0c80 00000000 		.word	0
 10876 0c84 00000000 		.word	0
 10877 0c88 00000000 		.word	0
 10878 0c8c 00000000 		.word	0
 10879 0c90 00000000 		.word	0
 10880 0c94 00000000 		.word	0
 10881 0c98 00000000 		.word	0
 10882 0c9c 00000000 		.word	0
 10883 0ca0 00000000 		.word	0
 10884 0ca4 00000000 		.word	0
 10885 0ca8 00000000 		.word	0
 10886 0cac 00000000 		.word	0
 10887 0cb0 00000000 		.word	0
 10888 0cb4 00000000 		.word	0
 10889 0cb8 00000000 		.word	0
 10890 0cbc 00000000 		.word	0
 10891 0cc0 00000000 		.word	0
 10892 0cc4 00000000 		.word	0
 10893 0cc8 00040180 		.word	-2147417088
 10894 0ccc 01040180 		.word	-2147417087
 10895 0cd0 02040180 		.word	-2147417086
 10896 0cd4 03040180 		.word	-2147417085
 10897 0cd8 00000000 		.word	0
 10898 0cdc 00000000 		.word	0
 10899 0ce0 00000000 		.word	0
 10900 0ce4 00000000 		.word	0
 10901 0ce8 00000000 		.word	0
 10902 0cec 00000000 		.word	0
 10903 0cf0 00000000 		.word	0
 10904 0cf4 00000000 		.word	0
 10905 0cf8 C1FFFFFF 		.word	-63
 10906              		.section	.rodata.str1.4,"aMS",%progbits,1
 10907              		.align	2
 10908              	.LC0:
 10909 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 10909      7065722D 
 10909      74696D65 
 10909      72202564 
 10909      0D0A00
 10910 0013 00       		.space	1
 10911              	.LC1:
 10912 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 10912      636F6D6D 
 10912      616E6420 
 10912      71756575 
 10912      65206973 
 10913 0037 00       		.space	1
 10914              	.LC2:
 10915 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 10915      706F732D 
 10915      74696D65 
 10915      72202564 
 10915      2025640D 
 10916 004e 0000     		.space	2
 10917              	.LC3:
 10918 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 10918      5420656E 
 10918      636F756E 
 10918      74657265 
 10918      642E2E2E 
 10919              	.LC4:
 10920 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 10920      454E4420 
 10920      656E636F 
 10920      756E7465 
 10920      7265642E 
 10921 0092 0000     		.space	2
 10922              	.LC5:
 10923 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 10923      64697363 
 10923      6F6E6E65 
 10923      63746564 
 10923      2E2E2E30 
 10924 00b3 00       		.space	1
 10925              	.LC6:
 10926 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 10926      7220696E 
 10926      206D756C 
 10926      74696368 
 10926      616E6E65 
 10927 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 10927      2025782C 
 10927      20646D61 
 10927      446F6E65 
 10927      20256420 
 10928              	.LC7:
 10929 0100 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 10929      43595F46 
 10929      585F5556 
 10929      435F5649 
 10929      44454F5F 
 10930 0133 0A00     		.ascii	"\012\000"
 10931 0135 000000   		.space	3
 10932              	.LC8:
 10933 0138 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 10933      43595F46 
 10933      585F5556 
 10933      435F5649 
 10933      44454F5F 
 10934 016b 00       		.ascii	"\000"
 10935              	.LC9:
 10936 016c 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 10936      726E6174 
 10936      65207365 
 10936      7474696E 
 10936      6720302E 
 10937              	.LC10:
 10938 0184 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 10938      72206665 
 10938      61747572 
 10938      65207265 
 10938      71756573 
 10939 01a7 00       		.space	1
 10940              	.LC11:
 10941 01a8 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 10941      6F6D6D69 
 10941      74656F66 
 10941      20737461 
 10941      7465203D 
 10942              	.LC12:
 10943 01c0 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 10943      6E656C20 
 10943      53657420 
 10943      57726170 
 10943      55702066 
 10944 01ed 000000   		.space	3
 10945              	.LC13:
 10946 01f0 4572726F 		.ascii	"Error handler...\015\012\000"
 10946      72206861 
 10946      6E646C65 
 10946      722E2E2E 
 10946      0D0A00
 10947 0203 00       		.space	1
 10948              	.LC14:
 10949 0204 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 10949      69742045 
 10949      4F462066 
 10949      61696C65 
 10949      64210D0A 
 10950 0219 000000   		.space	3
 10951              	.LC15:
 10952 021c 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 10952      49324320 
 10952      636F6D6D 
 10952      616E6420 
 10952      69732030 
 10953 024f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10953      78257820 
 10953      30782578 
 10953      20307825 
 10953      78203078 
 10954              	.LC16:
 10955 0268 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 10955      49324320 
 10955      636F6D6D 
 10955      616E6420 
 10955      73657474 
 10956 028e 0000     		.space	2
 10957              	.LC17:
 10958 0290 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 10958      73687574 
 10958      74657220 
 10958      73657420 
 10958      76616C75 
 10959 02ba 0000     		.space	2
 10960              	.LC18:
 10961 02bc 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 10961      206C6967 
 10961      68742063 
 10961      6F6D7065 
 10961      6E736174 
 10962 02ef 25640D0A 		.ascii	"%d\015\012\000"
 10962      00
 10963              	.LC19:
 10964 02f4 54686520 		.ascii	"The I2C current data is not available. try again. %"
 10964      49324320 
 10964      63757272 
 10964      656E7420 
 10964      64617461 
 10965 0327 64202564 		.ascii	"d %d\015\012\000"
 10965      0D0A00
 10966 032e 0000     		.space	2
 10967              	.LC20:
 10968 0330 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 10968      26414743 
 10968      2073656E 
 10968      7420746F 
 10968      20686F73 
 10969 0356 0000     		.space	2
 10970              	.LC21:
 10971 0358 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 10971      73687574 
 10971      74657226 
 10971      6578706F 
 10971      73757265 
 10972 0383 00       		.space	1
 10973              	.LC22:
 10974 0384 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 10974      26414743 
 10974      20676F74 
 10974      74656E20 
 10974      66726F6D 
 10975 03b5 0A00     		.ascii	"\012\000"
 10976 03b7 00       		.space	1
 10977              	.LC23:
 10978 03b8 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 10978      74657220 
 10978      6C657665 
 10978      6C20676F 
 10978      7474656E 
 10979 03eb 25640D0A 		.ascii	"%d\015\012\000"
 10979      00
 10980              	.LC24:
 10981 03f0 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 10981      20746865 
 10981      20766964 
 10981      656F206D 
 10981      6F646520 
 10982 0412 0000     		.space	2
 10983              	.LC25:
 10984 0414 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 10984      67657420 
 10984      64617461 
 10984      2066726F 
 10984      6D20686F 
 10985 0441 000000   		.space	3
 10986              	.LC26:
 10987 0444 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 10987      52657175 
 10987      65737420 
 10987      30782578 
 10987      20706172 
 10988 0477 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 10988      6E642074 
 10988      6F20686F 
 10988      73742030 
 10988      78257820 
 10989 0492 0000     		.space	2
 10990              	.LC27:
 10991 0494 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 10991      204F7020 
 10991      72656365 
 10991      69766573 
 10991      20284354 
 10992 04bb 00       		.space	1
 10993              	.LC28:
 10994 04bc 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 10994      756C7420 
 10994      73656C65 
 10994      63746F72 
 10994      20284354 
 10995 04de 0000     		.space	2
 10996              	.LC29:
 10997 04e0 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 10997      756C7420 
 10997      72657175 
 10997      65737420 
 10997      28435429 
 10998 0501 000000   		.space	3
 10999              	.LC30:
 11000 0504 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 11000      52657175 
 11000      65737420 
 11000      30782578 
 11000      20706172 
 11001 0537 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 11001      20307825 
 11001      78202F20 
 11001      73656E64 
 11001      20746F20 
 11002 0564 00       		.ascii	"\000"
 11003 0565 000000   		.space	3
 11004              	.LC31:
 11005 0568 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 11005      73706565 
 11005      64203D20 
 11005      25642065 
 11005      76656E66 
 11006 0598 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 11006      71756573 
 11006      74203D20 
 11006      30782578 
 11006      20775661 
 11007 05c8 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 11007      203D2030 
 11007      78257820 
 11007      6973666C 
 11007      61672030 
 11008 05e2 0000     		.space	2
 11009              	.LC32:
 11010 05e4 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 11010      64656661 
 11010      756C7420 
 11010      73657475 
 11010      70207265 
 11011              	.LC33:
 11012 0610 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 11012      6F207374 
 11012      7265616D 
 11012      20474554 
 11012      20726571 
 11013 0635 000000   		.space	3
 11014              	.LC34:
 11015 0638 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 11015      74686520 
 11015      76696465 
 11015      6F206D6F 
 11015      64652066 
 11016 0659 000000   		.space	3
 11017              	.LC35:
 11018 065c 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 11018      74686520 
 11018      76696465 
 11018      6F206D6F 
 11018      64652066 
 11019 0681 000000   		.space	3
 11020              	.LC36:
 11021 0684 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 11021      43595F46 
 11021      585F5556 
 11021      435F5354 
 11021      5245414D 
 11022 06aa 0000     		.space	2
 11023              	.LC37:
 11024 06ac 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 11024      55564320 
 11024      7374696C 
 11024      6C205072 
 11024      6F622873 
 11025 06d7 00       		.space	1
 11026              	.LC38:
 11027 06d8 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 11027      74686520 
 11027      7374696C 
 11027      6C206D6F 
 11027      64652066 
 11028 06f9 000000   		.space	3
 11029              	.LC39:
 11030 06fc 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 11030      7374696C 
 11030      6C20636F 
 11030      6D6D6974 
 11030      20636F6E 
 11031              	.LC40:
 11032 0724 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 11032      43595F46 
 11032      585F5556 
 11032      435F5354 
 11032      494C5F45 
 11033              	.LC41:
 11034 0748 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 11034      55564320 
 11034      7374696C 
 11034      6C207472 
 11034      69676765 
 11035 0771 000000   		.space	3
 11036              	.LC42:
 11037 0774 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 11037      7374696C 
 11037      6C207472 
 11037      69676765 
 11037      7220636F 
 11038 079b 00       		.space	1
 11039              	.LC43:
 11040 079c 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 11040      65642074 
 11040      6F207365 
 11040      6E642069 
 11040      6E746572 
 11041 07cd 0A00     		.ascii	"\012\000"
 11042 07cf 00       		.space	1
 11043              	.LC44:
 11044 07d0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 11044      73657420 
 11044      64656620 
 11044      64617461 
 11044      20307825 
 11045 07ef 00       		.space	1
 11046              	.LC45:
 11047 07f0 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 11047      73657420 
 11047      64656620 
 11047      64617461 
 11047      20307825 
 11048 0823 2E0D0A00 		.ascii	".\015\012\000"
 11049 0827 00       		.space	1
 11050              	.LC46:
 11051 0828 55415254 		.ascii	"UART initialization failed!\012\000"
 11051      20696E69 
 11051      7469616C 
 11051      697A6174 
 11051      696F6E20 
 11052 0845 000000   		.space	3
 11053              	.LC47:
 11054 0848 49324320 		.ascii	"I2C initialization failed!\012\000"
 11054      696E6974 
 11054      69616C69 
 11054      7A617469 
 11054      6F6E2066 
 11055              	.LC48:
 11056 0864 49324320 		.ascii	"I2C configuration failed!\012\000"
 11056      636F6E66 
 11056      69677572 
 11056      6174696F 
 11056      6E206661 
 11057 087f 00       		.space	1
 11058              	.LC49:
 11059 0880 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 11059      43726561 
 11059      74652045 
 11059      76656E74 
 11059      20666169 
 11060 08aa 0000     		.space	2
 11061              	.LC50:
 11062 08ac 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 11062      20496E69 
 11062      74206661 
 11062      696C6564 
 11062      2C204572 
 11063 08cf 00       		.space	1
 11064              	.LC51:
 11065 08d0 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 11065      204F7665 
 11065      72726964 
 11065      65206661 
 11065      696C6564 
 11066 08f7 00       		.space	1
 11067              	.LC52:
 11068 08f8 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 11068      28323029 
 11068      204F7665 
 11068      72726964 
 11068      65206661 
 11069 0923 00       		.space	1
 11070              	.LC53:
 11071 0924 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 11071      28323429 
 11071      204F7665 
 11071      72726964 
 11071      65206661 
 11072 094f 00       		.space	1
 11073              	.LC54:
 11074 0950 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 11074      20536574 
 11074      20287265 
 11074      73657420 
 11074      32322920 
 11075 0982 00       		.ascii	"\000"
 11076 0983 00       		.space	1
 11077              	.LC55:
 11078 0984 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 11078      20536574 
 11078      2028706F 
 11078      77657220 
 11078      32302920 
 11079 09b6 00       		.ascii	"\000"
 11080 09b7 00       		.space	1
 11081              	.LC56:
 11082 09b8 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 11082      20536574 
 11082      2028736E 
 11082      61702073 
 11082      686F7420 
 11083 09eb 25640A00 		.ascii	"%d\012\000"
 11084 09ef 00       		.space	1
 11085              	.LC57:
 11086 09f0 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 11086      46756E63 
 11086      74696F6E 
 11086      20466169 
 11086      6C656420 
 11087 0a1f 00       		.space	1
 11088              	.LC58:
 11089 0a20 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 11089      46756E63 
 11089      74696F6E 
 11089      20466169 
 11089      6C656420 
 11090 0a4f 00       		.space	1
 11091              	.LC59:
 11092 0a50 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 11092      53657420 
 11092      456E6470 
 11092      6F696E74 
 11092      20636F6E 
 11093 0a80 00       		.ascii	"\000"
 11094 0a81 000000   		.space	3
 11095              	.LC60:
 11096 0a84 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 11096      496E7465 
 11096      72727570 
 11096      74205374 
 11096      61747573 
 11097 0ab7 20436F64 		.ascii	" Code = %d\012\000"
 11097      65203D20 
 11097      25640A00 
 11098 0ac3 00       		.space	1
 11099              	.LC61:
 11100 0ac4 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 11100      65642074 
 11100      6F20616C 
 11100      6C6F6361 
 11100      7465206D 
 11101 0af7 65720D0A 		.ascii	"er\015\012\000"
 11101      00
 11102              	.LC62:
 11103 0afc 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 11103      4368616E 
 11103      6E656C20 
 11103      43726561 
 11103      74696F6E 
 11104 0b2a 0000     		.space	2
 11105              	.LC63:
 11106 0b2c 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 11106      436F6E6E 
 11106      65637420 
 11106      6661696C 
 11106      65642C20 
 11107 0b51 000000   		.space	3
 11108              	.LC64:
 11109 0b54 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 11109      74686520 
 11109      76696465 
 11109      6F206D6F 
 11109      64652066 
 11110 0b76 0000     		.space	2
 11111              	.LC65:
 11112 0b78 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 11112      4368616E 
 11112      6E656C20 
 11112      52657365 
 11112      74204661 
 11113 0ba3 00       		.space	1
 11114              	.LC66:
 11115 0ba4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 11115      4368616E 
 11115      6E656C20 
 11115      53657420 
 11115      5472616E 
 11116 0bd5 00       		.ascii	"\000"
 11117 0bd6 0000     		.space	2
 11118              	.LC67:
 11119 0bd8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 11119      4368616E 
 11119      6E656C20 
 11119      53657420 
 11119      5472616E 
 11120 0c09 0A00     		.ascii	"\012\000"
 11121 0c0b 00       		.space	1
 11122              	.LC68:
 11123 0c0c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 11123      75706572 
 11123      20677069 
 11123      6600
 11124 0c1a 0000     		.space	2
 11125              	.LC69:
 11126 0c1c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 11126      69676820 
 11126      67706966 
 11126      00
 11127 0c29 000000   		.space	3
 11128              	.LC70:
 11129 0c2c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 11129      696E6720 
 11129      47504946 
 11129      20436F6E 
 11129      66696775 
 11130 0c5f 0A00     		.ascii	"\012\000"
 11131 0c61 000000   		.space	3
 11132              	.LC71:
 11133 0c64 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 11133      74696E67 
 11133      20475049 
 11133      46207374 
 11133      61746520 
 11134 0c97 0D0A00   		.ascii	"\015\012\000"
 11135 0c9a 0000     		.space	2
 11136              	.LC72:
 11137 0c9c 49324363 		.ascii	"I2CcmdQue\000"
 11137      6D645175 
 11137      6500
 11138 0ca6 0000     		.space	2
 11139              	.LC73:
 11140 0ca8 49324373 		.ascii	"I2CstaQue\000"
 11140      74615175 
 11140      6500
 11141 0cb2 0000     		.space	2
 11142              	.LC74:
 11143 0cb4 33303A55 		.ascii	"30:UVC App Thread\000"
 11143      56432041 
 11143      70702054 
 11143      68726561 
 11143      6400
 11144 0cc6 0000     		.space	2
 11145              	.LC75:
 11146 0cc8 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 11146      56432041 
 11146      70702045 
 11146      50302054 
 11146      68726561 
 11147 0cde 0000     		.space	2
 11148              	.LC76:
 11149 0ce0 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 11149      32432041 
 11149      70702043 
 11149      54524C20 
 11149      54687265 
 11150 0cf7 00       		.bss
 11151              		.align	2
 11152              		.set	.LANCHOR0,. + 0
 11155              	glFxUVCEvent:
 11156 0000 00000000 		.space	40
 11156      00000000 
 11156      00000000 
 11156      00000000 
 11156      00000000 
 11159              	gpif_initialized:
 11160 0028 00000000 		.space	4
 11163              	streamingStarted:
 11164 002c 00000000 		.space	4
 11167              	isUsbConnected:
 11168 0030 00000000 		.space	4
 11171              	fb:
 11172 0034 0000     		.space	2
 11175              	pb:
 11176 0036 0000     		.space	2
 11179              	pbc:
 11180 0038 0000     		.space	2
 11183              	stiflag:
 11184 003a 00       		.space	1
 11185 003b 00       		.space	1
 11188              	hitFV:
 11189 003c 00000000 		.space	4
 11192              	prodCount:
 11193 0040 0000     		.space	2
 11196              	consCount:
 11197 0042 0000     		.space	2
 11200              	clearFeatureRqtReceived:
 11201 0044 00000000 		.space	4
 11204              	usbSpeed:
 11205 0048 00       		.space	1
 11206 0049 000000   		.space	3
 11209              	I2CCMDArry:
 11210 004c 00000000 		.space	12
 11210      00000000 
 11210      00000000 
 11213              	is60Hz:
 11214 0058 00000000 		.space	4
 11217              	glEp0Buffer:
 11218 005c 00000000 		.space	32
 11218      00000000 
 11218      00000000 
 11218      00000000 
 11218      00000000 
 11221              	CamMode:
 11222 007c 00       		.space	1
 11225              	setRes:
 11226 007d 00       		.space	1
 11227 007e 0000     		.space	2
 11230              	glCommitCtrl:
 11231 0080 00000000 		.space	32
 11231      00000000 
 11231      00000000 
 11231      00000000 
 11231      00000000 
 11234              	setstilRes:
 11235 00a0 00       		.space	1
 11238              	IMcount.7855:
 11239 00a1 00       		.space	1
 11240 00a2 0000     		.space	2
 11243              	uvcAppThread:
 11244 00a4 00000000 		.space	168
 11244      00000000 
 11244      00000000 
 11244      00000000 
 11244      00000000 
 11247              	uvcAppEP0Thread:
 11248 014c 00000000 		.space	168
 11248      00000000 
 11248      00000000 
 11248      00000000 
 11248      00000000 
 11251              	i2cAppThread:
 11252 01f4 00000000 		.space	168
 11252      00000000 
 11252      00000000 
 11252      00000000 
 11252      00000000 
 11255              	testSnap:
 11256 029c 00       		.space	1
 11257 029d 00       		.space	1
 11260              	fbbak:
 11261 029e 0000     		.space	2
 11264              	pbbak:
 11265 02a0 0000     		.space	2
 11268              	pbcbak:
 11269 02a2 0000     		.space	2
 11272              	pbcpbak:
 11273 02a4 0000     		.space	2
 11274 02a6 0000     		.text
 11275              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:201    .text:0000016c $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:207    .text:0000017c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:357    .text:000002a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:371    .text:000002c4 I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:368    .text:000002c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:405    .text:000002f4 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:411    .text:00000300 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:413    .text:00000300 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:592    .text:00000460 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:601    .text:00000470 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:604    .text:00000470 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:826    .text:00000610 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:836    .text:0000062c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:838    .text:0000062c CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1163   .text:000008f4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1179   .text:00000920 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1182   .text:00000920 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1219   .text:00000958 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1232   .text:00000984 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1279   .text:000009d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1286   .text:000009e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1304   .text:00000a04 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1313   .text:00000a1c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1316   .text:00000a1c I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1544   .text:00000c68 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1552   .text:00000c7c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1555   .text:00000c7c setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1618   .text:00000cfc getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1641   .text:00000d14 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1654   .text:00000d3c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1760   .text:00000e30 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1768   .text:00000e44 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1771   .text:00000e44 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:1985   .text:00000fec $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:2027   .text:00001088 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:2091   .text:00001108 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:2132   .text:000011a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:3487   .text:00001dc0 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:3509   .text:00001e0c $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:3717   .text:00001ff0 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:3723   .text:00002000 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:3929   .text:0000224c CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4097   .text:000023a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4110   .text:000023d0 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4605   .text:000028e0 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4616   .text:00002900 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4878   .text:00002bbc $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4891   .text:00002be4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4894   .text:00002be4 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4956   .text:00002c60 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:4964   .text:00002c70 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:5397   .text:000030a8 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:5404   .text:000030b8 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:5880   .text:000034b0 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:5887   .text:000034c0 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6407   .text:00003954 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6442   .text:000039cc $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6445   .text:000039cc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6738   .text:00003c88 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6745   .text:00003c98 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6748   .text:00003c98 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6789   .text:00003cdc $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6794   .text:00003ce4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6797   .text:00003ce4 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6822   .text:00003d00 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6826   .text:00003d04 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:6829   .text:00003d04 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8176   .text:000047a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8182   .text:000047b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8298   .text:0000491c $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8357   .text:000049fc $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8360   .text:000049fc CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8525   .text:00004b88 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8543   .text:00004bc4 $a
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8546   .text:00004bc4 main
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10374  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10383  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10458  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10477  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8752   .rodata:000000e0 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10556  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10567  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10678  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10829  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8765   .rodata:000000fc CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10370  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11255  .bss:0000029c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11171  .bss:00000034 fb
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11175  .bss:00000036 pb
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11179  .bss:00000038 pbc
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11260  .bss:0000029e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11264  .bss:000002a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11268  .bss:000002a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11272  .bss:000002a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11167  .bss:00000030 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11204  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11200  .bss:00000044 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11163  .bss:0000002c streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10311  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10251  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10341  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10281  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10356  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9747   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8686   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8690   .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8705   .rodata:00000020 pEXTSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9767   .data:00000490 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9811   .data:000004b8 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9789   .data:000004a4 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9840   .data:000004d0 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9862   .data:000004e4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8733   .rodata:000000a0 pPUCSenCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9884   .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9906   .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8777   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:8781   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9104   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9762   .data:0000048c ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9833   .data:000004cc WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:9928   .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:10907  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11151  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11155  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11159  .bss:00000028 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11183  .bss:0000003a stiflag
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11188  .bss:0000003c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11192  .bss:00000040 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11196  .bss:00000042 consCount
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11209  .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11213  .bss:00000058 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11217  .bss:0000005c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11221  .bss:0000007c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11225  .bss:0000007d setRes
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11230  .bss:00000080 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11234  .bss:000000a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11238  .bss:000000a1 IMcount.7855
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11243  .bss:000000a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11247  .bss:0000014c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccWZjmb4.s:11251  .bss:000001f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
SensorGetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
