   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB27:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      **** CyBool_t        streamingRecove = CyFalse;              /* start streaming again */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static CyBool_t stream_start = CyFalse;
 214:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 215:../uvc.c      ****                                                            the current video frame. */
 216:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 217:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 218:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 219:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 220:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 221:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 222:../uvc.c      **** 
 223:../uvc.c      **** /************ control parameters array ***********
 224:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 225:../uvc.c      ****  *    e.g.
 226:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 227:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 228:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 229:../uvc.c      ****  **************************************************/
 230:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 231:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 232:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 233:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 234:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 236:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 237:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 238:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 239:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 240:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 241:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 244:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 245:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 249:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 253:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 254:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 256:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 258:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 259:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 260:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 261:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 262:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 264:../uvc.c      **** 		/**********************************
 265:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 266:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 267:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 268:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 269:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 270:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 271:../uvc.c      **** 		 *
 272:../uvc.c      **** 		 *********************************/
 273:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 274:../uvc.c      **** };
 275:../uvc.c      **** #if 1 // the new control structure
 276:../uvc.c      **** /* the processing unit control request */
 277:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 278:../uvc.c      **** 
 279:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 280:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 281:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 282:../uvc.c      **** 		 2,					//UVCLn: the command length
 283:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 284:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 285:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 286:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 287:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 288:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 289:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 290:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 291:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 292:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 293:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 294:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 295:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 296:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 297:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 298:../uvc.c      **** 		}; //
 299:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 300:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 301:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 302:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 303:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 304:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 305:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 306:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 307:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 308:../uvc.c      **** 		 2,					//UVCLn: the command length
 309:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 310:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 311:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 312:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 313:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 314:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 315:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 316:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 317:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 318:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 319:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 320:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 321:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 322:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 323:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 324:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 325:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 326:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 327:../uvc.c      **** 
 328:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 329:../uvc.c      **** 	&PUCBLC,
 330:../uvc.c      **** 	0, //&PUCBright,
 331:../uvc.c      **** 	0, //&PUCContrast,
 332:../uvc.c      **** 	0, //&PUCGain (AGC?)
 333:../uvc.c      **** 	0, //&PUCPLFreq,
 334:../uvc.c      **** 	0, //&PUCHueC,
 335:../uvc.c      **** 	0, //&PUCSaturation,
 336:../uvc.c      **** 	&PUCSharp,
 337:../uvc.c      **** 	0, //&PUCGamGain,
 338:../uvc.c      **** 	0, //&PUCWBMd,
 339:../uvc.c      **** 	0, //UVCCtlID10,
 340:../uvc.c      **** 	0, //&PUCWBLC,
 341:../uvc.c      **** 	0, //UVCCtlID12,
 342:../uvc.c      **** 	0, //UVCCtlID13,
 343:../uvc.c      **** 	0, //&PUCDZoom,
 344:../uvc.c      **** 	0 //UVCCtlID15
 345:../uvc.c      **** };
 346:../uvc.c      **** 
 347:../uvc.c      **** /* the Camera terminal control request */
 348:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 349:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 350:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 351:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 352:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 353:../uvc.c      **** 
 354:../uvc.c      **** /* the Extentsion control request */
 355:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 356:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 357:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 358:../uvc.c      **** 		 2,					//UVCLn: the command length
 359:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 360:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 361:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 362:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 363:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 364:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 365:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 366:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 367:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 368:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 369:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 370:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 371:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 372:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 373:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 374:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 375:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 376:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 377:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 378:../uvc.c      **** 		 2,					//UVCLn: the command length
 379:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 380:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 381:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 382:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 383:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 384:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 385:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 386:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 387:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 388:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 389:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 390:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 391:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 392:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 393:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 394:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 395:../uvc.c      **** */
 396:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 397:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 398:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 399:../uvc.c      **** 		 2,					//UVCLn: the command length
 400:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 401:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 402:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 403:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 404:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 405:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 406:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 407:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 408:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 409:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 410:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 411:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 412:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 413:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 414:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 415:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 416:../uvc.c      **** */
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 418:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 421:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 422:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 423:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 424:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 425:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 426:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 427:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 428:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 429:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 430:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 431:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 432:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 433:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 434:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 435:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 436:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 437:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 438:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 439:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 440:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 441:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 442:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 443:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 444:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 445:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 447:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 448:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 449:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 450:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 451:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 452:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 453:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 454:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 456:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 457:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 458:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 459:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 460:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 461:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 462:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 464:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 465:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 466:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 467:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 468:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 469:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 470:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 471:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 472:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 473:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 474:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 475:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 476:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 477:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 478:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 479:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 480:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 481:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 482:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 483:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 484:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 485:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 486:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 487:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 488:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 489:../uvc.c      **** 		}; //
 490:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 491:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 492:../uvc.c      **** 
 493:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 494:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 495:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 496:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 497:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 498:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 499:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 500:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 501:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 502:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 503:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 504:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 505:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 506:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 507:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 508:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 509:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 510:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 511:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 512:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 513:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 514:../uvc.c      **** 
 515:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 516:../uvc.c      **** 		&EXTShutter,
 517:../uvc.c      **** 		0, //&EXTSensUp,
 518:../uvc.c      **** 		0, //&EXTMirror,
 519:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 520:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 521:../uvc.c      **** 		0, //&EXTDayNightMode,
 522:../uvc.c      **** 		0, //&EXTDayNightdely,
 523:../uvc.c      **** 		0, //&EXTDayNightlev,
 524:../uvc.c      **** 		0, //&EXTNightDaylev,
 525:../uvc.c      **** 		&EXTAexModGainlev,
 526:../uvc.c      **** 		0, //&EXTExpReflev,
 527:../uvc.c      **** 		&EXTShutlev,
 528:../uvc.c      **** 		0, //&EXTCamMode,
 529:../uvc.c      **** 		0, //&EXTSnapshot,
 530:../uvc.c      **** 		0, //&EXTSensorPare,
 531:../uvc.c      **** 		0, //&EXTI2Ccmd,
 532:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 533:../uvc.c      **** 		0, //&Ext1CtlID1,
 534:../uvc.c      **** 		0, //&Ext1CtlID2,
 535:../uvc.c      **** 		0, //&Ext1CtlID3,
 536:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 537:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 538:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 539:../uvc.c      **** 		0
 540:../uvc.c      **** };
 541:../uvc.c      **** 
 542:../uvc.c      **** #endif //end of the new control structure
 543:../uvc.c      **** 
 544:../uvc.c      **** #ifndef CAM720
 545:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 546:../uvc.c      **** #else
 547:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 548:../uvc.c      **** #endif
 549:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 550:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 551:../uvc.c      **** 
 552:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 553:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 554:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 555:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 556:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 557:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 558:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 559:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 560:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 561:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 564:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 565:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 569:../uvc.c      **** };
 570:../uvc.c      **** 
 571:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 572:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 573:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 574:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 575:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 576:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 577:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 578:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 579:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 580:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 581:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 582:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 590:../uvc.c      **** };
 591:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 592:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 593:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 594:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 595:../uvc.c      **** 
 596:../uvc.c      **** static uint8_t debugData[64][2] = {{0,0}};
 597:../uvc.c      **** static uint8_t dbgIdx = 2;
 598:../uvc.c      **** static uint8_t value[32][2] = {{0,0}};
 599:../uvc.c      **** static uint8_t valIdx = 1;
 600:../uvc.c      **** 
 601:../uvc.c      **** /*
 602:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 603:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 604:../uvc.c      ****  */
 605:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 606:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 607:../uvc.c      **** };
 608:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 609:../uvc.c      **** 		0 //bit0:0-read; 1-write. bit1:number of addr. bit2:device addr. bit3:board addr. bit4:DSP addr. 
 610:../uvc.c      **** 			//bit8:number of data. bit9:data0. bit10:data1. ......
 611:../uvc.c      **** };
 612:../uvc.c      **** 
 613:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 614:../uvc.c      **** 
 615:../uvc.c      **** void I2CCmdHandler(){
 616:../uvc.c      **** 	uint8_t buf[2];
 617:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 621:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 622:../uvc.c      **** 	uint8_t i;
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 624:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 625:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 627:../uvc.c      **** 	{
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 630:../uvc.c      **** 			{
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 632:../uvc.c      **** 			}
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 634:../uvc.c      **** 
 635:../uvc.c      **** 	}
 636:../uvc.c      **** 	else if(I2CCMDArry[2]!=0x70){//for get debug data
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 643:../uvc.c      **** 			}
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 647:../uvc.c      **** 			}
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 649:../uvc.c      **** 				CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 651:../uvc.c      **** 
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 653:../uvc.c      **** 				{
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 655:../uvc.c      **** 				}
 656:../uvc.c      **** 
 657:../uvc.c      **** 			}
 658:../uvc.c      **** 			else {
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 661:../uvc.c      **** 			}
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 663:../uvc.c      **** 			{
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 
 668:../uvc.c      **** 		}
 669:../uvc.c      **** 
 670:../uvc.c      **** 		I2CCMDArry[11] = 0xff;
 671:../uvc.c      **** 		//CmdType = 0xf;//end the routine
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 676:../uvc.c      **** 			dbgIdx = 2;
 677:../uvc.c      **** 			valIdx = 1;
 678:../uvc.c      **** 			value[0][1] = valIdx;
 679:../uvc.c      **** 			//CmdType = 0xf;//end the routine
 680:../uvc.c      **** 		}
 681:../uvc.c      **** 		CmdType = 0xf;//end the routine
 682:../uvc.c      **** 	}
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 684:../uvc.c      **** 	{
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 686:../uvc.c      **** #if 0 //for debugging
 687:../uvc.c      **** 		/* test still image operation */
 688:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 689:../uvc.c      **** 			snapButFlag = 0; //press
 690:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 691:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 692:../uvc.c      **** 			snapButFlag = 0xf; //release
 693:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 694:../uvc.c      **** 		}
 695:../uvc.c      **** 
 696:../uvc.c      **** 		/* end of the test */
 697:../uvc.c      **** #endif
 698:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 703:../uvc.c      **** 				}
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 705:../uvc.c      **** 		}else{//not support currently
 706:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 707:../uvc.c      **** 		}
 708:../uvc.c      **** 	}else if(CmdType == 1){
 709:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 711:../uvc.c      **** 				for(i = 0; i<4; i++)
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 713:../uvc.c      **** 			}
 714:../uvc.c      **** 			else{
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 719:../uvc.c      **** 				}
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 721:../uvc.c      **** 				//if(I2CCMDArry[5] == 1) stream_start = CyFalse; //clear stream start flag
 722:../uvc.c      **** 			}
 723:../uvc.c      **** 		}else{//not support currently
 724:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 725:../uvc.c      **** 		}
 726:../uvc.c      **** 
 727:../uvc.c      **** 	}
 728:../uvc.c      **** }
 729:../uvc.c      **** 
 730:../uvc.c      **** /************************************
 731:../uvc.c      ****  * set Iris mode
 732:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 733:../uvc.c      ****  */
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 735:../uvc.c      **** 	uint8_t dataIdx = 0;
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 740:../uvc.c      **** }
 741:../uvc.c      **** 
 742:../uvc.c      **** 
 743:../uvc.c      **** 
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 745:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 746:../uvc.c      **** 	uint16_t NumLn;
 747:../uvc.c      **** 	uint16_t fRate, shutTm;
 748:../uvc.c      **** 	uint8_t LnVal;
 749:../uvc.c      **** 	switch (Data){
 750:../uvc.c      **** 	case 1:
 751:../uvc.c      **** 	case 2:
 752:../uvc.c      **** 	case 3:
 753:../uvc.c      **** 	case 4:
 754:../uvc.c      **** 	case 5:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 756:../uvc.c      **** 		fRate = 30;
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 758:../uvc.c      **** 		if(NumLn > 1944)
 759:../uvc.c      **** 			NumLn =1944;
 760:../uvc.c      **** 		else if(NumLn < 8)
 761:../uvc.c      **** 			NumLn = 8;
 762:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 763:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 764:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 765:../uvc.c      **** 		break;
 766:../uvc.c      **** 	case 6:
 767:../uvc.c      **** 	case 7:
 768:../uvc.c      **** 	case 8:
 769:../uvc.c      **** 	case 9:
 770:../uvc.c      **** 	case 10:
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 772:../uvc.c      **** 		fRate = 30;
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 774:../uvc.c      **** 		if(NumLn > 1944)
 775:../uvc.c      **** 			NumLn =1944;
 776:../uvc.c      **** 		else if(NumLn < 8)
 777:../uvc.c      **** 			NumLn = 8;
 778:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 781:../uvc.c      **** 		break;
 782:../uvc.c      **** 	case 0: //auto
 783:../uvc.c      **** 	default:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 785:../uvc.c      **** 		LnVal = 1;
 786:../uvc.c      **** 		break;
 787:../uvc.c      **** 	}
 788:../uvc.c      **** 	return LnVal;
 789:../uvc.c      **** }
 790:../uvc.c      **** 
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 792:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 793:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 794:../uvc.c      ****     uint16_t readCount;
 795:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 796:../uvc.c      ****     uint8_t devAdd;
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 803:../uvc.c      ****     }else{
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 808:../uvc.c      ****     }
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 810:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 811:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 812:../uvc.c      **** #endif
 813:../uvc.c      ****     reqData = bRequest;
 814:../uvc.c      ****     /*
 815:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 816:../uvc.c      ****      */
 817:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 818:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 819:../uvc.c      ****     	goto EndofSet;
 820:../uvc.c      ****     }
 821:../uvc.c      ****     switch (bRequest)
 822:../uvc.c      **** 		 {
 823:../uvc.c      **** 
 824:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 828:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 829:../uvc.c      **** 			  break;
 830:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 831:../uvc.c      **** 
 832:../uvc.c      **** 			 switch(CtrlID)
 833:../uvc.c      **** 			 {
 834:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 835:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 839:../uvc.c      **** 			 	 		 }else{
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 844:../uvc.c      **** 			 	 		 }
 845:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 846:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 847:../uvc.c      **** 						 break;
 848:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 849:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 850:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 854:../uvc.c      **** 			 	 		 }else{
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 860:../uvc.c      **** 			 	 		 }
 861:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 862:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 863:../uvc.c      **** 			 	 		 break;
 864:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 865:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 866:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 867:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 868:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 872:../uvc.c      **** 			 	 		 }else{
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 876:../uvc.c      **** 			 	 			else
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 881:../uvc.c      **** 			 	 		 }
 882:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 883:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 884:../uvc.c      **** 			 	 		 break;
 885:../uvc.c      **** 			 	 }
 886:../uvc.c      **** 			 	 case ExtShutCtlID0:
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 890:../uvc.c      **** 
 891:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 892:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 893:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 897:../uvc.c      **** 		 	 		 }else{
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 903:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 905:../uvc.c      **** 
 906:../uvc.c      **** 		 	 		 }
 907:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 910:../uvc.c      **** 			 		 break;
 911:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 915:../uvc.c      **** 
 916:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 917:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 922:../uvc.c      **** 		 	 		 }else{
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 927:../uvc.c      **** 		 	 		 }
 928:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 929:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 930:../uvc.c      **** 			 		 break;
 931:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 933:../uvc.c      **** 
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 935:../uvc.c      **** 						if(sendData >= 3){
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 937:../uvc.c      **** 							sendData = 0; //set back to default
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 939:../uvc.c      **** 						}
 940:../uvc.c      **** 						sendData += 4;
 941:../uvc.c      **** 					 }
 942:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 943:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 944:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 945:../uvc.c      **** 					 break;
 946:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 949:../uvc.c      **** 			 		 }
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 952:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 953:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 954:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 955:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 956:../uvc.c      **** #endif
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 958:../uvc.c      **** 			 		 {
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 960:../uvc.c      **** 			 		 }
 961:../uvc.c      **** 			 		 break;
 962:../uvc.c      **** 				 case ExtAexModCtlID9:
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 966:../uvc.c      **** 
 967:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 968:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 972:../uvc.c      **** 		 	 		 }else{
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 976:../uvc.c      **** 
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 980:../uvc.c      **** 		 	 		 }
 981:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 982:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 983:../uvc.c      **** 
 984:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 986:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 991:../uvc.c      **** 					 break;
 992:../uvc.c      **** 
 993:../uvc.c      **** 			 	 case BrgtCtlID1:
 994:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 995:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 996:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 997:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 998:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 999:../uvc.c      **** 					 }else{
1000:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
1001:../uvc.c      **** 					 }
1002:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
1003:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1004:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1005:../uvc.c      **** 					 */
1006:../uvc.c      **** 
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1009:../uvc.c      **** 		 	 		 }else{
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
1015:../uvc.c      **** 					  if(Data0&0x80){
1016:../uvc.c      **** 						  Data0 = ~Data0;
1017:../uvc.c      **** 					  }else{
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
1019:../uvc.c      **** 					  }
1020:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
1021:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1022:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1023:../uvc.c      **** 			 		 break;
1024:../uvc.c      **** 				 case HueCtlID5:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
1027:../uvc.c      **** 		 	 		 }else{
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1031:../uvc.c      **** 		 	 		 }
1032:../uvc.c      **** 
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1035:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1036:../uvc.c      **** 					 break;
1037:../uvc.c      **** 				 case WBTLevCtlID11:
1038:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1039:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1040:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1041:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
1045:../uvc.c      **** 		 	 		 }else{
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1053:../uvc.c      **** 		 	 		 }
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1056:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1057:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1058:../uvc.c      **** 					 break;
1059:../uvc.c      **** 				 case BLCCtlID0:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1063:../uvc.c      **** 		 	 		 }else{
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1069:../uvc.c      **** 		 	 		 }
1070:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1071:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1072:../uvc.c      **** 					 break;
1073:../uvc.c      **** 				 case ShapCtlID7:
1074:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1075:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1076:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1080:../uvc.c      **** 		 	 		 }else{
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1085:../uvc.c      **** 		 	 		 }
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case ExtExRefCtlID10:
1090:../uvc.c      **** 				 case ConsCtlID2:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1093:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1097:../uvc.c      **** 		 	 		 }else{
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1102:../uvc.c      **** 		 	 		 }
1103:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1104:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1105:../uvc.c      **** 					 break;
1106:../uvc.c      **** 				 case WBTMdCtlID9:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1108:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1111:../uvc.c      **** 		 	 		 }else{
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1116:../uvc.c      **** 
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1118:../uvc.c      **** 		 	 		 }
1119:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1120:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1121:../uvc.c      **** 					 break;
1122:../uvc.c      **** 				 case MFreqCtlID4:
1123:../uvc.c      **** 
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1125:../uvc.c      **** 
1126:../uvc.c      **** 		 	 			 if(is60Hz)
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1128:../uvc.c      **** 		 	 			 else
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1130:../uvc.c      **** 
1131:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1133:../uvc.c      **** 		 	 		 }else{
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1140:../uvc.c      **** 		 	 		 }
1141:../uvc.c      **** 
1142:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1143:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1144:../uvc.c      **** 					 break;
1145:../uvc.c      **** 				 case SaturCtlID6:
1146:../uvc.c      **** 				 default:
1147:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1148:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1152:../uvc.c      **** 		 	 		 }else{
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1157:../uvc.c      **** 		 	 		 }
1158:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1159:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1160:../uvc.c      **** 
1161:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1162:../uvc.c      **** 					 break;
1163:../uvc.c      **** 			 }
1164:../uvc.c      **** 
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 
1167:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1168:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1169:../uvc.c      **** #endif
1170:../uvc.c      **** 			  break;
1171:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1175:../uvc.c      **** 		 	 }
1176:../uvc.c      **** 
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1179:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1180:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1181:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1182:../uvc.c      **** 			 }else
1183:../uvc.c      **** 			 {
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1186:../uvc.c      **** 			 }
1187:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1188:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1189:../uvc.c      **** 			  break;
1190:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1194:../uvc.c      **** 		 	 }
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1197:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1198:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1199:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1200:../uvc.c      **** 			 }else
1201:../uvc.c      **** 			 {
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1204:../uvc.c      **** 			 }
1205:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1206:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1207:../uvc.c      **** 			  break;
1208:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1212:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1213:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1214:../uvc.c      **** 		 	 }
1215:../uvc.c      **** 		 	 else{
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1220:../uvc.c      **** 		 	 }
1221:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1222:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1223:../uvc.c      **** 			  break;
1224:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1227:../uvc.c      **** 		 	 }
1228:../uvc.c      **** 		 	 else{
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1230:../uvc.c      **** 		 	 }
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1232:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1233:../uvc.c      **** 			  Len = 1;
1234:../uvc.c      **** 			  break;
1235:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1239:../uvc.c      **** 		 	 }
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1245:../uvc.c      **** 			 }else{
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1248:../uvc.c      **** 			 }
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1250:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1251:../uvc.c      **** 			  break;
1252:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1254:../uvc.c      **** 				  glEp0Buffer, &readCount);
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1256:../uvc.c      **** 			   {
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1259:../uvc.c      **** 				  getData = glEp0Buffer[0];
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1261:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1262:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1263:../uvc.c      **** #endif
1264:../uvc.c      **** 				  switch(CtrlID)
1265:../uvc.c      **** 					 {
1266:../uvc.c      **** 						 case ExtShutCtlID0:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1271:../uvc.c      **** #if 1	// register setting directly
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1273:../uvc.c      **** 						     {
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1275:../uvc.c      **** 						    	 dataIdx = 0;
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1278:../uvc.c      **** 								 dataIdx++;
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1281:../uvc.c      **** 						     }
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1284:../uvc.c      **** 						     break;
1285:../uvc.c      **** #else	// old fashion
1286:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1287:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1288:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1289:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1290:../uvc.c      **** 									 }else{
1291:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1292:../uvc.c      **** 									 }
1293:../uvc.c      **** 								 }
1294:../uvc.c      **** 							 }else{
1295:../uvc.c      **** 								 Data1 = Data0 - 1;
1296:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1297:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1298:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1299:../uvc.c      **** 									 }else{
1300:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1301:../uvc.c      **** 									 }
1302:../uvc.c      **** 								 }
1303:../uvc.c      **** 								 if(Data1 < 8){
1304:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1305:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1306:../uvc.c      **** 								 }else{
1307:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1308:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1309:../uvc.c      **** 								 }
1310:../uvc.c      **** 							 }
1311:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1312:../uvc.c      **** 							 dataIdx = 0;
1313:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1314:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1315:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1316:../uvc.c      **** 							 if(AxMode){
1317:../uvc.c      **** 								 dataIdx++;
1318:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1319:../uvc.c      **** 								 dataIdx++;
1320:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1321:../uvc.c      **** 							 }
1322:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1323:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1324:../uvc.c      **** 							 break;
1325:../uvc.c      **** #endif
1326:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1330:../uvc.c      **** 						     dataIdx = 0;
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1333:../uvc.c      **** 							 {
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1337:../uvc.c      **** 								 /*
1338:../uvc.c      **** 								 dataIdx++;
1339:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1340:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1341:../uvc.c      **** 									 dataIdx++;
1342:../uvc.c      **** 								 }else{
1343:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1344:../uvc.c      **** 									 dataIdx++;
1345:../uvc.c      **** 								 }
1346:../uvc.c      **** 								 */
1347:../uvc.c      **** 							 }
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1352:../uvc.c      **** 								 }
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 
1360:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1364:../uvc.c      **** 						     dataIdx = 0;
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1366:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1367:../uvc.c      **** 							 {
1368:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1369:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1370:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1371:../uvc.c      **** 								 dataIdx++;
1372:../uvc.c      **** 							 }
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1377:../uvc.c      **** 									 dataIdx++;
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1379:../uvc.c      **** 								 }
1380:../uvc.c      **** 							 }
1381:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1385:../uvc.c      **** 							 break;
1386:../uvc.c      **** 						 case ExtCamMCtlID12:
1387:../uvc.c      **** 							 dataIdx = 0;
1388:../uvc.c      **** 							 if(Data0 <= 3){
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1390:../uvc.c      **** 								 Data1 = Data0;
1391:../uvc.c      **** 							 }else{
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1393:../uvc.c      **** 								 Data1 = Data0-4;
1394:../uvc.c      **** 							 }
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1401:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1402:../uvc.c      **** 							 break;
1403:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1404:../uvc.c      **** 							 dataIdx = 0;
1405:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1406:../uvc.c      **** 								 Data0 = 1;
1407:../uvc.c      **** 							 }else{ //save current sensor parameters.
1408:../uvc.c      **** 								 Data0 = 0;
1409:../uvc.c      **** 							 }
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1414:../uvc.c      **** 							 break;
1415:../uvc.c      **** 						 case ExtI2CCtlID15:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1418:../uvc.c      **** 					 		 }
1419:../uvc.c      **** 					 		I2CCmdHandler();
1420:../uvc.c      **** 							 break;
1421:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1425:../uvc.c      **** 
1426:../uvc.c      **** 							 dataIdx = 0;
1427:../uvc.c      **** #if 0 //seperate version
1428:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1429:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1430:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1431:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1432:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1433:../uvc.c      **** 							 }else{ //disable BLD window
1434:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1435:../uvc.c      **** 							 }
1436:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1437:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1438:../uvc.c      **** 							 dataIdx++;
1439:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1440:../uvc.c      **** 							 dataIdx++;
1441:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1442:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1443:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1444:../uvc.c      **** 							 dataIdx++;
1445:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1446:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1447:../uvc.c      **** #else //combination version
1448:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1450:../uvc.c      **** 						     /* end test */
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1452:../uvc.c      **** 							 dataIdx++;
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1455:../uvc.c      **** 							 getData1 = Data1;
1456:../uvc.c      **** #endif
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1460:../uvc.c      **** 							 break;
1461:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1465:../uvc.c      **** 
1466:../uvc.c      **** 							 dataIdx = 0;
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1472:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1473:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1474:../uvc.c      **** 							 break;
1475:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1476:../uvc.c      **** 							 dataIdx = 0;
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1478:../uvc.c      **** 							 if(Data0 == 1){
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1480:../uvc.c      **** 							 }else{
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1482:../uvc.c      **** 							 }
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1486:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1488:../uvc.c      **** 							 break;
1489:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1490:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1491:../uvc.c      **** 							 dataIdx = 0;
1492:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1493:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1494:../uvc.c      **** 							  if(Data0&0x80){
1495:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1496:../uvc.c      **** 							  }else{
1497:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1498:../uvc.c      **** 							  }
1499:../uvc.c      **** 							 Data1 |= ~0x03;
1500:../uvc.c      **** 							 Data1 &= 0xC7;
1501:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1502:../uvc.c      **** 						  	 dataIdx++;
1503:../uvc.c      **** 
1504:../uvc.c      **** 							 Data0 = (Data0 << 2);
1505:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1506:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1507:../uvc.c      **** 
1508:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1509:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1510:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1511:../uvc.c      **** #endif
1512:../uvc.c      **** 							 dataIdx = 0;
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1514:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1515:../uvc.c      **** 							  if(Data0&0x80){
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1517:../uvc.c      **** 							  }else{
1518:../uvc.c      **** 								  Data0 = ~Data0;
1519:../uvc.c      **** 							  }
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1522:../uvc.c      **** 
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1525:../uvc.c      **** 
1526:../uvc.c      **** 
1527:../uvc.c      **** 							 break;
1528:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1529:../uvc.c      **** 							 dataIdx = 0;
1530:../uvc.c      **** 
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1533:../uvc.c      **** 							 dataIdx++;
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1535:../uvc.c      **** 							 dataIdx++;
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1537:../uvc.c      **** 							 dataIdx++;
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1539:../uvc.c      **** 							 dataIdx++;
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1541:../uvc.c      **** 							 dataIdx++;
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1544:../uvc.c      **** 
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1547:../uvc.c      **** 							 break;
1548:../uvc.c      **** 						 case SaturCtlID6:
1549:../uvc.c      **** 							 dataIdx = 0;
1550:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1553:../uvc.c      **** 							 dataIdx++;
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1558:../uvc.c      **** 							 break;
1559:../uvc.c      **** 
1560:../uvc.c      **** 						 case WBTLevCtlID11:
1561:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1562:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1563:../uvc.c      **** 							 dataIdx = 0;
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1567:../uvc.c      **** 							 dataIdx++;
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1570:../uvc.c      **** 
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1574:../uvc.c      **** 							 break;
1575:../uvc.c      **** 						 case MFreqCtlID4:
1576:../uvc.c      **** 							 dataIdx = 0;
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
1579:../uvc.c      **** 							 is60Hz = Data0;
1580:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1581:../uvc.c      **** 							 {
1582:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1583:../uvc.c      **** 								 is60Hz = CyFalse;
1584:../uvc.c      **** 							 }
1585:../uvc.c      **** 							 else if(Data0 >2)
1586:../uvc.c      **** 							 {
1587:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1588:../uvc.c      **** 								 is60Hz = CyTrue;
1589:../uvc.c      **** 							 }
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1592:../uvc.c      **** 							 {
1593:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1594:../uvc.c      **** 			                       switch (setRes)
1595:../uvc.c      **** 			                         {
1596:../uvc.c      **** 			                         	case 1: //1944
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1600:../uvc.c      **** 			                         		break;
1601:../uvc.c      **** 			                         	case 2: //1080
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1605:../uvc.c      **** 			                         		break;
1606:../uvc.c      **** 			                         	case 3: //720
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1610:../uvc.c      **** 			                         		break;
1611:../uvc.c      **** 			                         	case 4: //VGA
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1615:../uvc.c      **** 			                         	default:
1616:../uvc.c      **** 			                         		break;
1617:../uvc.c      **** 			                         }
1618:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1619:../uvc.c      **** 							 }
1620:../uvc.c      **** 
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1622:../uvc.c      **** 							 break;
1623:../uvc.c      **** 					 	 case BLCCtlID0:
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1627:../uvc.c      **** 						     dataIdx = 0;
1628:../uvc.c      **** 
1629:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1630:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1635:../uvc.c      **** 							 {
1636:../uvc.c      **** 								 if(Data0 < 3){
1637:../uvc.c      **** 					 				 Data0 += 4;
1638:../uvc.c      **** 					 			 }else{
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1640:../uvc.c      **** 									Data0 = 4; //set to default.
1641:../uvc.c      **** 					 			 }
1642:../uvc.c      **** 					 		 }
1643:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1644:../uvc.c      **** 							 dataIdx = 0;
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1648:../uvc.c      **** 
1649:../uvc.c      **** 					 		 break;
1650:../uvc.c      **** 					 	 case ShapCtlID7:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1654:../uvc.c      **** 						     dataIdx = 0;
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1657:../uvc.c      **** 							 if(Data0 != 0){
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1659:../uvc.c      **** #ifdef COLOR
1660:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1661:../uvc.c      **** #else
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1663:../uvc.c      **** 								 dataIdx++;
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1665:../uvc.c      **** #endif
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1667:../uvc.c      **** 							 }else{
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1671:../uvc.c      **** 
1672:../uvc.c      **** 							 }
1673:../uvc.c      **** 							 break;
1674:../uvc.c      **** 						 case ExtExRefCtlID10:
1675:../uvc.c      **** 						 case ConsCtlID2:
1676:../uvc.c      **** 							 dataIdx = 0;
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1680:../uvc.c      **** 
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1683:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1684:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1685:../uvc.c      **** 
1686:../uvc.c      **** 							 break;
1687:../uvc.c      **** 						 default:
1688:../uvc.c      **** 							 dataIdx = 0;
1689:../uvc.c      **** 
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1693:../uvc.c      **** 
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1696:../uvc.c      **** 							 break;
1697:../uvc.c      **** 					 }
1698:../uvc.c      **** 			   }else{
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1700:../uvc.c      **** 			   }
1701:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1702:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1703:../uvc.c      **** #endif
1704:../uvc.c      **** 
1705:../uvc.c      **** 			  break;
1706:../uvc.c      **** 		  default:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1708:../uvc.c      **** 			  break;
1709:../uvc.c      **** 		 }
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1711:../uvc.c      **** }
1712:../uvc.c      **** /************** CT control requests handler *************************/
1713:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1714:../uvc.c      **** 
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1716:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1717:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1718:../uvc.c      ****     uint16_t readCount;
1719:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1720:../uvc.c      ****     uint16_t diff, value, diffRd;
1721:../uvc.c      ****     uint8_t i, shutter, index;
1722:../uvc.c      ****     diff = 0xffff;
1723:../uvc.c      ****     shutter = 1;
1724:../uvc.c      ****     index = 1;
1725:../uvc.c      **** 
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1728:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1730:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1731:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1732:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1733:../uvc.c      **** #endif
1734:../uvc.c      ****     reqData = bRequest;
1735:../uvc.c      **** 
1736:../uvc.c      ****     switch (bRequest)
1737:../uvc.c      **** 		 {
1738:../uvc.c      **** 
1739:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1743:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1744:../uvc.c      **** 			  break;
1745:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1746:../uvc.c      **** 
1747:../uvc.c      **** 			 switch(CtrlID)
1748:../uvc.c      **** 			 {
1749:../uvc.c      **** 				 default:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1754:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1755:../uvc.c      **** 					 break;
1756:../uvc.c      **** 			 }
1757:../uvc.c      **** 
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1759:../uvc.c      **** 
1760:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1761:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1762:../uvc.c      **** #endif
1763:../uvc.c      **** 			  break;
1764:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1768:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1769:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1772:../uvc.c      **** 			  break;
1773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1777:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1778:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1779:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1780:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1781:../uvc.c      **** 			  break;
1782:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1786:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1787:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1788:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1789:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1790:../uvc.c      **** 			  break;
1791:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1794:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1795:../uvc.c      **** 			  Len = 1;
1796:../uvc.c      **** 			  break;
1797:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1804:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1805:../uvc.c      **** 			  break;
1806:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1808:../uvc.c      **** 			  glEp0Buffer, &readCount);
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1811:../uvc.c      **** 			  value = Data1;
1812:../uvc.c      **** 
1813:../uvc.c      **** 			  switch(CtrlID)
1814:../uvc.c      **** 			  {
1815:../uvc.c      **** 		  	      case AutoExMCtlID1:
1816:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1817:../uvc.c      **** 
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1820:../uvc.c      **** 				    getData = glEp0Buffer[0];
1821:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1822:../uvc.c      **** 		  		    switch (getData){
1823:../uvc.c      **** 						case 1:
1824:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1825:../uvc.c      **** 							break;
1826:../uvc.c      **** 						case 2:
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1828:../uvc.c      **** 							dataIdx = 0;
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1832:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1833:../uvc.c      **** 
1834:../uvc.c      **** 							break;
1835:../uvc.c      **** 						case 4:
1836:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1837:../uvc.c      **** 							break;
1838:../uvc.c      **** 						case 8:
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1840:../uvc.c      **** 			  		    	dataIdx = 0;
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1844:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1845:../uvc.c      **** 							break;
1846:../uvc.c      **** 		  		    }
1847:../uvc.c      **** #if 0
1848:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1849:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1850:../uvc.c      **** 						  dataIdx = 0;
1851:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1852:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1853:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1854:../uvc.c      **** 		  		    }
1855:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1856:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1857:../uvc.c      **** 		  		    }
1858:../uvc.c      **** #endif
1859:../uvc.c      **** 				    break;
1860:../uvc.c      **** 
1861:../uvc.c      **** 			  	  case ExTmACtlID3:
1862:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1863:../uvc.c      **** 
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1867:../uvc.c      **** 					  {
1868:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1869:../uvc.c      **** 						  {
1870:../uvc.c      **** 							if(value > ShutValueArry[i]){
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1872:../uvc.c      **** 							}else{
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1874:../uvc.c      **** 							}
1875:../uvc.c      **** 							  if(diff > diffRd){
1876:../uvc.c      **** 								  diff = diffRd;
1877:../uvc.c      **** 								  index = i;
1878:../uvc.c      **** 							  }
1879:../uvc.c      **** 						  }
1880:../uvc.c      **** 						  shutter = shutter+index;
1881:../uvc.c      **** 
1882:../uvc.c      **** 						  dataIdx = 0;
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1886:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1887:../uvc.c      **** 
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1892:../uvc.c      **** 					  }else{
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1894:../uvc.c      **** 					  }
1895:../uvc.c      **** 					  getData = glEp0Buffer[0];
1896:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1897:../uvc.c      **** 					  break;
1898:../uvc.c      **** 			  	  case IriACtlID7:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1900:../uvc.c      **** 					  {
1901:../uvc.c      **** 							 dataIdx = 0;
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1905:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1906:../uvc.c      **** 
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1910:../uvc.c      **** 					  }else{
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1912:../uvc.c      **** 					  }
1913:../uvc.c      **** 					  getData = glEp0Buffer[0];
1914:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1915:../uvc.c      **** 
1916:../uvc.c      **** 					  break;
1917:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1918:../uvc.c      **** 					  getData = glEp0Buffer[0];
1919:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1920:../uvc.c      **** #if 1
1921:../uvc.c      **** 					  dataIdx = 0;
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1923:../uvc.c      **** 					  if(getData == 1)
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1925:../uvc.c      **** 					  else if(getData == 0xff)
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1927:../uvc.c      **** 					  else
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1929:../uvc.c      **** 					  //dataIdx++;
1930:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1932:../uvc.c      **** #endif
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1934:../uvc.c      **** 					  break;
1935:../uvc.c      **** 
1936:../uvc.c      **** 			  	  default:
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1939:../uvc.c      **** 			  		 break;
1940:../uvc.c      **** 			  }
1941:../uvc.c      **** 			  break;
1942:../uvc.c      **** 		  default:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1945:../uvc.c      **** 			  break;
1946:../uvc.c      **** 		 }
1947:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1948:../uvc.c      **** 
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1950:../uvc.c      **** }
1951:../uvc.c      **** 
1952:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1953:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1954:../uvc.c      **** {
1955:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1956:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1957:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1958:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1959:../uvc.c      **** 
1960:../uvc.c      ****     CtrlID = BrgtCtlID1;
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1964:../uvc.c      ****     Data1 = Data0;
1965:../uvc.c      **** 
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1967:../uvc.c      ****     if(Data1&0x80){
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1969:../uvc.c      ****     }else{
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1971:../uvc.c      ****     }
1972:../uvc.c      ****     Data0 = (Data0 << 2);
1973:../uvc.c      **** 
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1975:../uvc.c      **** 
1976:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1981:../uvc.c      **** 
1982:../uvc.c      ****     CtrlID = ConsCtlID2;
1983:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1984:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1990:../uvc.c      **** 
1991:../uvc.c      ****     CtrlID = HueCtlID5;
1992:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
2003:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
2004:../uvc.c      **** 
2005:../uvc.c      ****     CtrlID = SaturCtlID6;
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2012:../uvc.c      **** 
2013:../uvc.c      ****     CtrlID = ShapCtlID7;
2014:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
2015:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
2020:../uvc.c      **** 
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
2022:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
2023:../uvc.c      **** 	return;
2024:../uvc.c      **** }
2025:../uvc.c      **** 
2026:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
2027:../uvc.c      **** void
2028:../uvc.c      **** CyFxUVCAddHeader (
2029:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
2030:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
2031:../uvc.c      ****         )
2032:../uvc.c      **** {
2033:../uvc.c      ****     /* Copy header to buffer */
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
2037:../uvc.c      **** 
2038:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
2042:../uvc.c      ****     }
2043:../uvc.c      **** }
2044:../uvc.c      **** 
2045:../uvc.c      **** 
2046:../uvc.c      **** /* Application Error Handler */
2047:../uvc.c      **** void
2048:../uvc.c      **** CyFxAppErrorHandler (
2049:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
2050:../uvc.c      ****         )
2051:../uvc.c      **** {
2052:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
2053:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
2054:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
2055:../uvc.c      **** 
2056:../uvc.c      ****        This function can be modified to take additional error handling actions such
2057:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2058:../uvc.c      ****      */
2059:../uvc.c      ****     for (;;)
2060:../uvc.c      ****     {
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
2063:../uvc.c      ****     }
2064:../uvc.c      **** }
2065:../uvc.c      **** 
2066:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2067:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2068:../uvc.c      ****  */
2069:../uvc.c      **** static void
2070:../uvc.c      **** CyFxUVCApplnAbortHandler (
2071:../uvc.c      ****         void)
2072:../uvc.c      **** {
2073:../uvc.c      **** 	uint32_t flag;
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2075:../uvc.c      **** 	{
2076:../uvc.c      ****         /* Clear the Video Stream Request Event */
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2078:../uvc.c      **** 
2079:../uvc.c      ****         /* Set Video Stream Abort Event */
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2081:../uvc.c      **** 	}
2082:../uvc.c      **** }
2083:../uvc.c      **** 
2084:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2085:../uvc.c      **** static void
2086:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2087:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2088:../uvc.c      ****         uint16_t             evdata  /* Event data */
2089:../uvc.c      ****         )
2090:../uvc.c      **** {
2091:../uvc.c      ****     switch (evtype)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
2097:../uvc.c      ****             gpif_initialized = 0;
2098:../uvc.c      ****             streamingStarted = CyFalse;
2099:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2100:../uvc.c      ****             break;
2101:../uvc.c      **** 
2102:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
2106:../uvc.c      ****             gpif_initialized = 0;
2107:../uvc.c      ****             streamingStarted = CyFalse;
2108:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2109:../uvc.c      ****             break;
2110:../uvc.c      **** 
2111:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
2115:../uvc.c      ****             gpif_initialized = 0;
2116:../uvc.c      ****             isUsbConnected = CyFalse;
2117:../uvc.c      ****             streamingStarted = CyFalse;
2118:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2119:../uvc.c      ****             break;
2120:../uvc.c      **** 
2121:../uvc.c      **** #ifdef BACKFLOW_DETECT
2122:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2123:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2124:../uvc.c      ****             break;
2125:../uvc.c      **** #endif
2126:../uvc.c      **** 
2127:../uvc.c      ****         default:
2128:../uvc.c      ****             break;
2129:../uvc.c      ****     }
2130:../uvc.c      **** }
2131:../uvc.c      **** 
2132:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2133:../uvc.c      **** static CyBool_t
2134:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2135:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2136:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2137:../uvc.c      ****         )
2138:../uvc.c      **** {
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2140:../uvc.c      ****     uint32_t status;
2141:../uvc.c      ****     //CyU3PDebugPrint (4, "The USB setup Requests and UVC events 0x%x, 0x%x\r\n", setupdat0, setupd
2142:../uvc.c      ****     /* Obtain Request Type and Request */
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
2149:../uvc.c      ****     		bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* additional debug message */
2150:../uvc.c      ****     if(dbgIdx < 63){
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
2154:../uvc.c      **** 		dbgIdx++;
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
2157:../uvc.c      **** 
2158:../uvc.c      ****     /* Check for UVC Class Requests */
2159:../uvc.c      ****     switch (bmReqType)
2160:../uvc.c      ****     {
2161:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2162:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2163:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2164:../uvc.c      ****             switch (wIndex & 0xFF)
2165:../uvc.c      ****             {
2166:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2167:../uvc.c      ****                     {
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2170:../uvc.c      ****                                 CYU3P_EVENT_OR);
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2172:../uvc.c      ****                         {
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2175:../uvc.c      ****                         }
2176:../uvc.c      ****                     }
2177:../uvc.c      ****                     break;
2178:../uvc.c      **** 
2179:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2180:../uvc.c      ****                     {
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2183:../uvc.c      ****                                 CYU3P_EVENT_OR);
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2185:../uvc.c      ****                         {
2186:../uvc.c      ****                             /* Error handling */
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2189:../uvc.c      ****                         }
2190:../uvc.c      ****                     }
2191:../uvc.c      ****                     break;
2192:../uvc.c      **** 
2193:../uvc.c      ****                 default:
2194:../uvc.c      ****                     break;
2195:../uvc.c      ****             }
2196:../uvc.c      ****             break;
2197:../uvc.c      **** 
2198:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2200:../uvc.c      ****             {
2201:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2202:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2204:../uvc.c      ****                 {
2205:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2208:../uvc.c      ****                     gpif_initialized = 0;
2209:../uvc.c      ****                     streamingStarted = CyFalse;
2210:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2212:../uvc.c      ****                     CyU3PBusyWait (100);
2213:../uvc.c      **** 
2214:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2218:../uvc.c      ****                     CyU3PBusyWait (100);
2219:../uvc.c      **** 
2220:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
2223:../uvc.c      ****                     /* Complete Control request handshake */
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
2225:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2228:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2229:../uvc.c      **** 
2230:../uvc.c      ****                 }
2231:../uvc.c      ****             }
2232:../uvc.c      ****             break;
2233:../uvc.c      **** 
2234:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2236:../uvc.c      ****             {
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2238:../uvc.c      ****                 {
2239:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2240:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2241:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2242:../uvc.c      ****                 	 * has started. */
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
2244:../uvc.c      ****                     {
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2246:../uvc.c      **** 
2247:../uvc.c      ****                         /* Disable the GPIF state machine. */
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2249:../uvc.c      ****                         gpif_initialized = 0;
2250:../uvc.c      ****                         streamingStarted = CyFalse;
2251:../uvc.c      **** 
2252:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2254:../uvc.c      ****                         CyU3PBusyWait (100);
2255:../uvc.c      **** 
2256:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2260:../uvc.c      ****                         CyU3PBusyWait (100);
2261:../uvc.c      **** 
2262:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2264:../uvc.c      **** 
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
2266:../uvc.c      ****                         /* Complete Control request handshake */
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
2268:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
2271:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2272:../uvc.c      ****                     }
2273:../uvc.c      ****                     else
2274:../uvc.c      ****                     {
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
2277:../uvc.c      ****                     }
2278:../uvc.c      ****                 }
2279:../uvc.c      ****             }
2280:../uvc.c      ****             break;
2281:../uvc.c      **** 
2282:../uvc.c      ****         default:
2283:../uvc.c      ****             break;
2284:../uvc.c      ****     }
2285:../uvc.c      **** 
2286:../uvc.c      ****     /* Return status of request handling to the USB driver */
2287:../uvc.c      ****     return uvcHandleReq;
2288:../uvc.c      **** }
2289:../uvc.c      **** 
2290:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2291:../uvc.c      **** 
2292:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2293:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2294:../uvc.c      ****  */
2295:../uvc.c      **** void
2296:../uvc.c      **** CyFxUvcApplnDmaCallback (
2297:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2298:../uvc.c      ****         CyU3PDmaCbType_t      type,
2299:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2300:../uvc.c      ****         )
2301:../uvc.c      **** {
2302:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2303:../uvc.c      **** #if 1
2304:../uvc.c      ****     CyU3PReturnStatus_t status;
2305:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2306:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2307:../uvc.c      **** 
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2309:../uvc.c      ****     {
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2311:../uvc.c      ****             {
2312:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2313:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2314:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2315:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2316:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2317:../uvc.c      ****                 	stiflag = 0x03;
2318:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2319:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2320:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2321:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2322:../uvc.c      ****                 }
2323:../uvc.c      **** #endif
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2325:../uvc.c      ****                 fb++;
2326:../uvc.c      ****             }
2327:../uvc.c      ****             else
2328:../uvc.c      ****             {
2329:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2331:../uvc.c      ****                 pb++;
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
2333:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2334:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2335:../uvc.c      ****                 //lineCount = 0; //res test
2336:../uvc.c      **** #if 1   //remove the still flag clearing here
2337:../uvc.c      ****                 if(stiflag == 0x0F){
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2341:../uvc.c      ****                 	stiflag = 0xAA;
2342:../uvc.c      ****                 }
2343:../uvc.c      **** #endif
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2345:../uvc.c      ****             }
2346:../uvc.c      **** 
2347:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2348:../uvc.c      ****             prodCount++;
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2350:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2351:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2353:../uvc.c      ****             {
2354:../uvc.c      ****                 prodCount--;
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2356:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2357:../uvc.c      ****             }
2358:../uvc.c      ****     }
2359:../uvc.c      **** #endif
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2361:../uvc.c      ****     {
2362:../uvc.c      ****         consCount++;
2363:../uvc.c      ****         streamingStarted = CyTrue;
2364:../uvc.c      ****     }
2365:../uvc.c      **** }
2366:../uvc.c      **** 
2367:../uvc.c      **** /*
2368:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2369:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2370:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2371:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2372:../uvc.c      ****  * to commit the buffer.
2373:../uvc.c      ****  */
2374:../uvc.c      **** static uint8_t
2375:../uvc.c      **** CyFxUvcAppCommitEOF (
2376:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2377:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2378:../uvc.c      ****         )
2379:../uvc.c      **** {
2380:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2381:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2382:../uvc.c      **** 
2383:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2384:../uvc.c      **** 
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2386:../uvc.c      ****     {
2387:../uvc.c      ****         switch (stateId)
2388:../uvc.c      ****         {
2389:../uvc.c      **** 
2390:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2391:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2392:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2393:../uvc.c      ****                 break;
2394:../uvc.c      **** 
2395:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2396:../uvc.c      ****                 socket = 0;
2397:../uvc.c      ****                 break;
2398:../uvc.c      **** 
2399:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2400:../uvc.c      ****                 socket = 1;
2401:../uvc.c      ****                 break;
2402:../uvc.c      **** 
2403:../uvc.c      ****             default:
2404:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2405:../uvc.c      ****                 /* Unexpected current state. Return error. */
2406:../uvc.c      ****             	//lineCount++;
2407:../uvc.c      ****             	return 1;
2408:../uvc.c      ****         }
2409:../uvc.c      ****     }
2410:../uvc.c      **** 
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2412:../uvc.c      ****     {
2413:../uvc.c      ****         switch (stateId)
2414:../uvc.c      ****         {
2415:../uvc.c      **** #ifndef CAM720
2416:../uvc.c      **** #ifdef GPIFIIM
2417:../uvc.c      ****             case 13:
2418:../uvc.c      ****             case 24:
2419:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2420:../uvc.c      ****                 break;
2421:../uvc.c      **** 
2422:../uvc.c      ****             case 8:
2423:../uvc.c      ****                 socket = 0;
2424:../uvc.c      ****                 break;
2425:../uvc.c      **** 
2426:../uvc.c      ****             case 20:
2427:../uvc.c      ****                 socket = 1;
2428:../uvc.c      ****                 break;
2429:../uvc.c      **** #else
2430:../uvc.c      ****             case 11:
2431:../uvc.c      ****             case 18:
2432:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2433:../uvc.c      ****                 break;
2434:../uvc.c      **** 
2435:../uvc.c      ****             case 8:
2436:../uvc.c      ****                 socket = 0;
2437:../uvc.c      ****                 break;
2438:../uvc.c      **** 
2439:../uvc.c      ****             case 15:
2440:../uvc.c      ****                 socket = 1;
2441:../uvc.c      ****                 break;
2442:../uvc.c      **** #endif
2443:../uvc.c      **** #else
2444:../uvc.c      ****             case 11:
2445:../uvc.c      ****             case 18:
2446:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2447:../uvc.c      ****                 break;
2448:../uvc.c      **** 
2449:../uvc.c      ****             case 8:
2450:../uvc.c      ****                 socket = 0;
2451:../uvc.c      ****                 break;
2452:../uvc.c      **** 
2453:../uvc.c      ****             case 15:
2454:../uvc.c      ****                 socket = 1;
2455:../uvc.c      ****                 break;
2456:../uvc.c      **** 
2457:../uvc.c      **** #endif
2458:../uvc.c      ****              default:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2460:../uvc.c      ****                 /* Unexpected current state. Return error. */
2461:../uvc.c      ****                return 1;
2462:../uvc.c      ****         }
2463:../uvc.c      ****     }
2464:../uvc.c      **** 
2465:../uvc.c      ****     if (socket != 0xFF)
2466:../uvc.c      ****     {
2467:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2468:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2469:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2472:../uvc.c      ****         {
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2474:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2475:../uvc.c      ****         }
2476:../uvc.c      ****     }
2477:../uvc.c      **** 
2478:../uvc.c      ****     return 0;
2479:../uvc.c      **** }
2480:../uvc.c      **** 
2481:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2482:../uvc.c      **** void
2483:../uvc.c      **** CyFxGpifCB (
2484:../uvc.c      ****         CyU3PGpifEventType event,
2485:../uvc.c      ****         uint8_t currentState
2486:../uvc.c      ****         )
2487:../uvc.c      **** {
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2489:../uvc.c      ****     {
2490:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2491:../uvc.c      ****     	           in the UVC implementation. */
2492:../uvc.c      ****     	//hitFV = CyTrue;
2493:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2495:../uvc.c      ****     }
2496:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2497:../uvc.c      **** }
2498:../uvc.c      **** 
2499:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2500:../uvc.c      **** static void
2501:../uvc.c      **** CyFxUVCApplnDebugInit (
2502:../uvc.c      ****         void)
2503:../uvc.c      **** {
2504:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2505:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2506:../uvc.c      **** 
2507:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2510:../uvc.c      ****     {
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2513:../uvc.c      ****     }
2514:../uvc.c      **** 
2515:../uvc.c      ****     /* Set UART Configuration */
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2523:../uvc.c      **** 
2524:../uvc.c      ****     /* Set the UART configuration */
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2527:../uvc.c      ****     {
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2529:../uvc.c      ****     }
2530:../uvc.c      **** 
2531:../uvc.c      ****     /* Set the UART transfer */
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2534:../uvc.c      ****     {
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2536:../uvc.c      ****     }
2537:../uvc.c      **** 
2538:../uvc.c      ****     /* Initialize the Debug logger module. */
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2541:../uvc.c      ****     {
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2543:../uvc.c      ****     }
2544:../uvc.c      **** 
2545:../uvc.c      ****     /* Disable log message headers. */
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2547:../uvc.c      **** }
2548:../uvc.c      **** 
2549:../uvc.c      **** /* I2C initialization. */
2550:../uvc.c      **** static void
2551:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2552:../uvc.c      **** {
2553:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2554:../uvc.c      ****     CyU3PReturnStatus_t status;
2555:../uvc.c      **** 
2556:../uvc.c      ****     status = CyU3PI2cInit ();
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2558:../uvc.c      ****     {
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
2561:../uvc.c      ****     }
2562:../uvc.c      **** 
2563:../uvc.c      ****     /*  Set I2C Configuration */
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2568:../uvc.c      **** 
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2571:../uvc.c      ****     {
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
2574:../uvc.c      ****     }
2575:../uvc.c      **** }
2576:../uvc.c      **** 
2577:../uvc.c      **** #ifdef BACKFLOW_DETECT
2578:../uvc.c      **** static void CyFxUvcAppPibCallback (
2579:../uvc.c      ****         CyU3PPibIntrType cbType,
2580:../uvc.c      ****         uint16_t cbArg)
2581:../uvc.c      **** {
2582:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2583:../uvc.c      ****     {
2584:../uvc.c      ****         if (!back_flow_detected)
2585:../uvc.c      ****         {
2586:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2587:../uvc.c      ****             back_flow_detected = 1;
2588:../uvc.c      ****         }
2589:../uvc.c      ****     }
2590:../uvc.c      **** }
2591:../uvc.c      **** #endif
2592:../uvc.c      **** 
2593:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2594:../uvc.c      **** static void
2595:../uvc.c      **** CyFxUvcAppDebugCallback (
2596:../uvc.c      ****         CyU3PDmaChannel   *handle,
2597:../uvc.c      ****         CyU3PDmaCbType_t   type,
2598:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2599:../uvc.c      **** {
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2601:../uvc.c      ****     {
2602:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2604:../uvc.c      ****     }
2605:../uvc.c      **** }
2606:../uvc.c      **** #endif
2607:../uvc.c      **** 
2608:../uvc.c      **** #if 0
2609:../uvc.c      **** static void CyFxAppIntEpCb(
2610:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2611:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2612:../uvc.c      **** 		uint8_t  ebNum)
2613:../uvc.c      **** 		{
2614:../uvc.c      **** 			//CyBool_t value;
2615:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2616:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2617:../uvc.c      **** 
2618:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2619:../uvc.c      **** 		}
2620:../uvc.c      **** #endif
2621:../uvc.c      **** 
2622:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2623:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2624:../uvc.c      ****    configures the DMA module for the UVC Application */
2625:../uvc.c      **** static void
2626:../uvc.c      **** CyFxUVCApplnInit (void)
2627:../uvc.c      **** {
2628:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2629:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2630:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2631:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2632:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2633:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2634:../uvc.c      **** 
2635:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2636:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2637:../uvc.c      **** 
2638:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2639:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2640:../uvc.c      **** #endif
2641:../uvc.c      **** 
2642:../uvc.c      ****     /* Create UVC event group */
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2644:../uvc.c      ****     if (apiRetStatus != 0)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2651:../uvc.c      ****     CyFxUvcAppPTZInit ();
2652:../uvc.c      **** #endif
2653:../uvc.c      **** 
2654:../uvc.c      ****     isUsbConnected = CyFalse;
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2656:../uvc.c      **** 
2657:../uvc.c      ****     /* Init the GPIO module */
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize Gpio interface */
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2666:../uvc.c      ****     if (apiRetStatus != 0)
2667:../uvc.c      ****     {
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2669:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2670:../uvc.c      ****     }
2671:../uvc.c      **** 
2672:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2673:../uvc.c      ****      * must use GpioOverride to configure it */
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2675:../uvc.c      ****     if (apiRetStatus != 0)
2676:../uvc.c      ****     {
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2678:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2679:../uvc.c      ****     }
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2681:../uvc.c      ****     if (apiRetStatus != 0)
2682:../uvc.c      ****     {
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2684:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2685:../uvc.c      ****     }
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2687:../uvc.c      ****     if (apiRetStatus != 0)
2688:../uvc.c      ****     {
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2690:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2691:../uvc.c      ****     }
2692:../uvc.c      **** 
2693:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2701:../uvc.c      ****     {
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2703:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2704:../uvc.c      ****     }
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2707:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2715:../uvc.c      ****     {
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2717:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2718:../uvc.c      ****     }
2719:../uvc.c      **** 
2720:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2721:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2729:../uvc.c      ****     {
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2731:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2732:../uvc.c      ****     }
2733:../uvc.c      **** 
2734:../uvc.c      ****     /* Initialize the P-port. */
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2739:../uvc.c      **** 
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2742:../uvc.c      ****     {
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2744:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2745:../uvc.c      ****     }
2746:../uvc.c      **** 
2747:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2749:../uvc.c      **** 
2750:../uvc.c      **** #ifdef BACKFLOW_DETECT
2751:../uvc.c      ****     back_flow_detected = 0;
2752:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2753:../uvc.c      **** #endif
2754:../uvc.c      **** 
2755:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2756:../uvc.c      ****     SensorReset ();
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
2758:../uvc.c      ****     //SensorInit ();
2759:../uvc.c      **** 
2760:../uvc.c      ****     /* USB initialization. */
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2763:../uvc.c      ****     {
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2765:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2766:../uvc.c      ****     }
2767:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2769:../uvc.c      **** 
2770:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2772:../uvc.c      **** 
2773:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2774:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2775:../uvc.c      **** 
2776:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2779:../uvc.c      **** 
2780:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2783:../uvc.c      **** 
2784:../uvc.c      ****     /* Configuration descriptors. */
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2788:../uvc.c      **** 
2789:../uvc.c      ****     /* String Descriptors */
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2793:../uvc.c      **** 
2794:../uvc.c      ****     /* Configure the status interrupt endpoint.
2795:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2796:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2797:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2798:../uvc.c      ****      */
2799:../uvc.c      ****     endPointConfig.enable   = 1;
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2803:../uvc.c      ****     endPointConfig.streams  = 0;
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2807:../uvc.c      ****     {
2808:../uvc.c      ****         /* Error Handling */
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2811:../uvc.c      ****     }
2812:../uvc.c      **** 
2813:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2826:../uvc.c      ****             &dmaInterConfig);
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2828:../uvc.c      ****     {
2829:../uvc.c      ****         /* Error handling */
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2831:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2832:../uvc.c      ****     }
2833:../uvc.c      **** 
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
2836:../uvc.c      ****     {
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2838:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2839:../uvc.c      ****     }
2840:../uvc.c      **** 
2841:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2857:../uvc.c      ****             &dmaMultiConfig);
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2859:../uvc.c      ****     {
2860:../uvc.c      ****         /* Error handling */
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2862:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2863:../uvc.c      ****     }
2864:../uvc.c      **** 
2865:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2866:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2867:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2868:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2869:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2870:../uvc.c      ****      */
2871:../uvc.c      **** 
2872:../uvc.c      ****     endPointConfig.enable   = 1;
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2876:../uvc.c      ****     endPointConfig.streams  = 0;
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
2878:../uvc.c      **** 
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2887:../uvc.c      **** 
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2890:../uvc.c      ****     {
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2892:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2893:../uvc.c      ****     }
2894:../uvc.c      **** 
2895:../uvc.c      ****     channelConfig.size           = 1024;
2896:../uvc.c      ****     channelConfig.count          = 1;
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2906:../uvc.c      **** 
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2909:../uvc.c      ****     {
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2911:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2912:../uvc.c      ****     }
2913:../uvc.c      **** 
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2916:../uvc.c      ****     {
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2918:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2919:../uvc.c      ****     }
2920:../uvc.c      **** 
2921:../uvc.c      ****     channelConfig.size           = 1024;
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2930:../uvc.c      ****     channelConfig.notification   = 0;
2931:../uvc.c      ****     channelConfig.cb             = 0;
2932:../uvc.c      **** 
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2935:../uvc.c      ****     {
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2938:../uvc.c      ****     }
2939:../uvc.c      **** 
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
2942:../uvc.c      ****     {
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2944:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2945:../uvc.c      ****     }
2946:../uvc.c      **** #endif
2947:../uvc.c      **** 
2948:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2951:../uvc.c      ****     {
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2953:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2954:../uvc.c      ****     }
2955:../uvc.c      **** 
2956:../uvc.c      ****     CyU3PBusyWait(100);
2957:../uvc.c      **** 
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2959:../uvc.c      **** 
2960:../uvc.c      ****     endPointConfig.enable   = 1;
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2963:../uvc.c      ****     {
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
2966:../uvc.c      ****     }
2967:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2968:../uvc.c      ****     {
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
2971:../uvc.c      ****     }
2972:../uvc.c      ****     endPointConfig.streams  = 0;
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2975:../uvc.c      ****     {
2976:../uvc.c      ****         /* Error Handling */
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2978:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2979:../uvc.c      ****     }
2980:../uvc.c      **** #if 0    //for still image method 3 using
2981:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2982:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2983:../uvc.c      ****     {
2984:../uvc.c      ****         /* Error Handling */
2985:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2986:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2987:../uvc.c      ****     }
2988:../uvc.c      **** #endif
2989:../uvc.c      **** 
2990:../uvc.c      **** }
2991:../uvc.c      **** 
2992:../uvc.c      **** /*
2993:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2994:../uvc.c      ****  * streaming session is started.
2995:../uvc.c      ****  */
2996:../uvc.c      **** static void
2997:../uvc.c      **** CyFxUvcAppGpifInit (
2998:../uvc.c      ****         void)
2999:../uvc.c      **** {
3000:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
3001:../uvc.c      **** 
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3003:../uvc.c      ****     {
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
3006:../uvc.c      ****     }
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
3008:../uvc.c      ****     {
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
3011:../uvc.c      ****     }
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3013:../uvc.c      ****     {
3014:../uvc.c      ****         /* Error Handling */
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
3016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3017:../uvc.c      ****     }
3018:../uvc.c      **** 
3019:../uvc.c      ****     /* Start the state machine from the designated start state. */
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
3021:../uvc.c      ****     {
3022:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
3023:../uvc.c      ****     }
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
3025:../uvc.c      ****     {
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
3027:../uvc.c      ****     }
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
3029:../uvc.c      ****     {
3030:../uvc.c      ****         /* Error Handling */
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
3032:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
3033:../uvc.c      ****     }
3034:../uvc.c      **** }
3035:../uvc.c      **** 
3036:../uvc.c      **** /*
3037:../uvc.c      ****  * Entry function for the UVC Application Thread
3038:../uvc.c      ****  */
3039:../uvc.c      **** 
3040:../uvc.c      **** uint32_t posTick;
3041:../uvc.c      **** CyU3PTimer I2CCmdTimer;
3042:../uvc.c      **** 
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
3046:../uvc.c      **** }
3047:../uvc.c      **** 
3048:../uvc.c      **** 
3049:../uvc.c      **** void
3050:../uvc.c      **** UVCAppThread_Entry (
3051:../uvc.c      ****         uint32_t input)
3052:../uvc.c      **** {
3053:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
3054:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
3055:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
3056:../uvc.c      ****     uint8_t i = 0;
3057:../uvc.c      ****     uint32_t flag;
3058:../uvc.c      ****     uint32_t prinflag = 0;
3059:../uvc.c      **** static uint8_t IMcount = 0;
3060:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
3061:../uvc.c      ****     uint32_t frameCnt = 0;
3062:../uvc.c      **** #endif
3063:../uvc.c      ****     /* Initialize the Uart Debug Module */
3064:../uvc.c      ****     CyFxUVCApplnDebugInit ();
3065:../uvc.c      **** 
3066:../uvc.c      ****     /* Initialize the I2C interface */
3067:../uvc.c      **** 	while (i++ < 6){
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
3069:../uvc.c      **** 	}
3070:../uvc.c      **** 
3071:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3072:../uvc.c      **** 
3073:../uvc.c      ****     /* Initialize the UVC Application */
3074:../uvc.c      ****     CyFxUVCApplnInit ();
3075:../uvc.c      ****     /*
3076:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3077:../uvc.c      **** 
3078:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3079:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3080:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3081:../uvc.c      **** 
3082:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3083:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3084:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3085:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3086:../uvc.c      **** 
3087:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3088:../uvc.c      ****        of handling the abort request.
3089:../uvc.c      ****      */
3090:../uvc.c      **** 
3091:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3092:../uvc.c      ****     //CyU3PThreadSleep(1000);
3093:../uvc.c      **** 
3094:../uvc.c      ****     for (;;)
3095:../uvc.c      ****     {
3096:../uvc.c      ****         /* Waiting for the Video Stream Event */
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3098:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3099:../uvc.c      ****         {
3100:../uvc.c      ****         	debugData[0][1] = debugData[0][1]&0xFF;
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
3102:../uvc.c      ****         	//CyU3PDebugPrint (4, "stream ready %x\n", apiRetStatus);
3103:../uvc.c      **** #if 0 //test for new firmware no video bring up
3104:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3105:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3106:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3107:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3108:../uvc.c      ****             {
3109:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3110:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3111:../uvc.c      ****                 {
3112:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3113:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3114:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3115:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3116:../uvc.c      **** #endif
3117:../uvc.c      **** #endif
3118:../uvc.c      ****                     }
3119:../uvc.c      ****                 else
3120:../uvc.c      ****                 {
3121:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3122:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3123:../uvc.c      **** #ifdef USB_LOWRES_IMG
3124:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3125:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3126:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3127:../uvc.c      **** #endif
3128:../uvc.c      **** #endif
3129:../uvc.c      ****                 }
3130:../uvc.c      **** 
3131:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3132:../uvc.c      ****                 prodCount++;
3133:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3134:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3135:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3136:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3137:../uvc.c      ****                 {
3138:../uvc.c      ****                     prodCount--;
3139:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3140:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3141:../uvc.c      ****                 }
3142:../uvc.c      ****             }
3143:../uvc.c      **** #endif
3144:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3145:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3147:../uvc.c      ****             {
3148:../uvc.c      ****             	if(0&&(prinflag == 0)){
3149:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3150:../uvc.c      ****             		prinflag = 1;
3151:../uvc.c      ****             	}
3152:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3153:../uvc.c      ****             	debugData[0][0]++;
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
3155:../uvc.c      ****             	fb=0;
3156:../uvc.c      ****             	pb=0;
3157:../uvc.c      ****             	pbc=0;
3158:../uvc.c      ****                 prodCount = 0;
3159:../uvc.c      ****                 consCount = 0;
3160:../uvc.c      ****                 hitFV     = CyFalse;
3161:../uvc.c      **** 
3162:../uvc.c      **** #ifdef BACKFLOW_DETECT
3163:../uvc.c      ****                 back_flow_detected = 0;
3164:../uvc.c      **** #endif
3165:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3166:../uvc.c      ****                 frameCnt++;
3167:../uvc.c      **** #endif
3168:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3169:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3170:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3171:../uvc.c      ****                 //}
3172:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3174:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3175:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3177:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3178:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3179:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3180:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3181:../uvc.c      ****                 		stiflag = 0xFF;
3182:../uvc.c      ****                 		IMcount = 0;
3183:../uvc.c      ****                 	}
3184:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3185:../uvc.c      **** 
3186:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3188:../uvc.c      ****                 		stiflag = 0x0F;
3189:../uvc.c      ****                 		IMcount = 0;
3190:../uvc.c      ****                 		}
3191:../uvc.c      ****                  		/*if(IMcount > 0x4){
3192:../uvc.c      ****                 			stiflag = 0x0F;
3193:../uvc.c      ****                 			IMcount = 0;
3194:../uvc.c      ****                 		}*/
3195:../uvc.c      **** 
3196:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3197:../uvc.c      ****                     //CyU3PThreadSleep(400);
3198:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3199:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3200:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3201:../uvc.c      **** 
3202:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3203:../uvc.c      ****                 	{
3204:../uvc.c      ****                     switch (setRes)
3205:../uvc.c      ****                      {
3206:../uvc.c      ****                  	case 1: //1944
3207:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3208:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3209:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3210:../uvc.c      ****                  		break;
3211:../uvc.c      ****                  	case 2: //1080
3212:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3213:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3214:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3215:../uvc.c      ****                  		break;
3216:../uvc.c      ****                  	case 3: //720
3217:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3218:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3219:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3220:../uvc.c      ****                  		break;
3221:../uvc.c      ****                  	case 4: //VGA
3222:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3223:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3224:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3225:../uvc.c      ****                  		break;
3226:../uvc.c      ****                  	default:
3227:../uvc.c      ****                  		break;
3228:../uvc.c      ****                      }
3229:../uvc.c      ****                     IMcount = 0;
3230:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3231:../uvc.c      ****                 	stiflag = 0x0;
3232:../uvc.c      ****                 	}
3233:../uvc.c      ****                 }
3234:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3235:../uvc.c      ****                 /* Reset the DMA channel. */
3236:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3237:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3238:../uvc.c      ****                 {
3239:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3240:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3241:../uvc.c      ****                 }
3242:../uvc.c      **** 
3243:../uvc.c      ****                 /* Start Channel Immediately */
3244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3245:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3246:../uvc.c      ****                 {
3247:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3248:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3249:../uvc.c      ****                 }
3250:../uvc.c      **** 
3251:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3252:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3253:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3254:../uvc.c      ****                 }
3255:../uvc.c      ****         }
3256:../uvc.c      ****         else
3257:../uvc.c      ****         {
3258:../uvc.c      ****             /* If we have a stream abort request pending. */
3259:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3260:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3261:../uvc.c      ****             {
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
3264:../uvc.c      ****             	hitFV     = CyFalse;
3265:../uvc.c      ****                 prodCount = 0;
3266:../uvc.c      ****                 consCount = 0;
3267:../uvc.c      ****                 if(0&&(prinflag == 0)){
3268:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3269:../uvc.c      ****                 	prinflag = 1;
3270:../uvc.c      ****                 }
3271:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3272:../uvc.c      ****                 fb=0;
3273:../uvc.c      ****                 pb=0;
3274:../uvc.c      ****                 pbc=0;
3275:../uvc.c      **** 
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3277:../uvc.c      ****                 {
3278:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3279:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3280:../uvc.c      ****                     {
3281:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3282:../uvc.c      ****                     }
3283:../uvc.c      **** 
3284:../uvc.c      ****                     /* Flush the Endpoint memory */
3285:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3286:../uvc.c      ****                 }/*else{
3287:../uvc.c      ****                     apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT
3288:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]&0x7F;
3289:../uvc.c      ****                 	debugData[0][1] = debugData[0][1]|0x10;
3290:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3291:../uvc.c      ****                     {
3292:../uvc.c      ****                         CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus)
3293:../uvc.c      ****                     }
3294:../uvc.c      ****                     CyU3PDebugPrint (4, "clear feature stream set %x\n", apiRetStatus);
3295:../uvc.c      ****                 }*/
3296:../uvc.c      **** 
3297:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3298:../uvc.c      ****             }
3299:../uvc.c      ****             else
3300:../uvc.c      ****             {
3301:../uvc.c      **** #if 0
3302:../uvc.c      ****                 if(stream_start == CyTrue){
3303:../uvc.c      ****                     if(CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND,
3304:../uvc.c      ****                     		&flag, CYU3P_NO_WAIT != CY_U3P_SUCCESS)){
3305:../uvc.c      ****     					if(1||clearFeatureRqtReceived){
3306:../uvc.c      ****     						CyU3PThreadSleep(3000);
3307:../uvc.c      ****     						//if(stream_start == CyTrue){
3308:../uvc.c      ****     							streamingRecove = CyTrue;
3309:../uvc.c      ****     							debugData[1][1]++;
3310:../uvc.c      ****     						//}
3311:../uvc.c      ****     						clearFeatureRqtReceived = CyFalse;
3312:../uvc.c      ****     						stream_start == CyFalse;
3313:../uvc.c      ****     					}
3314:../uvc.c      ****                     }
3315:../uvc.c      **** 
3316:../uvc.c      ****                 }
3317:../uvc.c      **** #endif
3318:../uvc.c      **** 
3319:../uvc.c      ****             	/* We are essentially idle at this point. Wait for the reception of a start streaming 
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
3323:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
3324:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS){
3325:../uvc.c      ****                     		CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
3326:../uvc.c      ****             	}
3327:../uvc.c      ****             	else
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
3329:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3330:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3331:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3332:../uvc.c      ****             	CyU3PDebugPrint (4, "post wait stream set %x\n", apiRetStatus);
3333:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3334:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3335:../uvc.c      ****                 {
3336:../uvc.c      ****                     /* Error handling */
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3338:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3339:../uvc.c      ****                 }
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
3342:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3344:../uvc.c      ****                 {
3345:../uvc.c      **** #if 0
3346:../uvc.c      ****                 	//for start up of the AF Lens
3347:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3348:../uvc.c      ****                     CyU3PThreadSleep(500);
3349:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3350:../uvc.c      ****                     CyU3PThreadSleep(500);
3351:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3352:../uvc.c      ****                    	CyU3PThreadSleep(300);
3353:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3354:../uvc.c      ****                     CyU3PThreadSleep(500);
3355:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3356:../uvc.c      ****                     CyU3PThreadSleep(500);
3357:../uvc.c      **** #endif
3358:../uvc.c      **** #if 0
3359:../uvc.c      ****                     if(streamingRecove){
3360:../uvc.c      ****                     switch (setRes)
3361:../uvc.c      ****                     {
3362:../uvc.c      ****                      	case 1: //1944
3363:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boa
3364:../uvc.c      ****                      		CyU3PThreadSleep(100);
3365:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:
3366:../uvc.c      ****                      		break;
3367:../uvc.c      ****                      	case 2: //1080
3368:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boa
3369:../uvc.c      ****                      		CyU3PThreadSleep(100);
3370:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:
3371:../uvc.c      ****                      		break;
3372:../uvc.c      ****                      	case 3: //720
3373:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPB
3374:../uvc.c      ****                      		CyU3PThreadSleep(100);
3375:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x4
3376:../uvc.c      ****                      		break;
3377:../uvc.c      ****                      	case 4: //VGA
3378:../uvc.c      ****                      		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPB
3379:../uvc.c      ****                      		CyU3PThreadSleep(100);
3380:../uvc.c      ****                             CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x7
3381:../uvc.c      ****                      		break;
3382:../uvc.c      ****                      	default:
3383:../uvc.c      ****                      		break;
3384:../uvc.c      **** 
3385:../uvc.c      ****                     }
3386:../uvc.c      ****                     streamingRecove = CyFalse;
3387:../uvc.c      ****                     }
3388:../uvc.c      **** #endif
3389:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3390:../uvc.c      **** 
3391:../uvc.c      ****                     gpif_initialized = CyTrue;
3392:../uvc.c      ****                     //stream_start = CyTrue;
3393:../uvc.c      ****                     CyU3PThreadSleep(200);
3394:../uvc.c      ****                     
3395:../uvc.c      ****                 }
3396:../uvc.c      ****                 else
3397:../uvc.c      ****                 {
3398:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3399:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3401:../uvc.c      ****                 }
3402:../uvc.c      ****             }
3403:../uvc.c      ****         }
3404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3405:../uvc.c      **** 
3406:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3407:../uvc.c      ****         CyU3PThreadRelinquish ();
3408:../uvc.c      ****     }
3409:../uvc.c      **** }
3410:../uvc.c      **** 
3411:../uvc.c      **** /*
3412:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3413:../uvc.c      ****  */
3414:../uvc.c      **** 
3415:../uvc.c      **** static void
3416:../uvc.c      **** UVCHandleProcessingUnitRqts (
3417:../uvc.c      ****         void)
3418:../uvc.c      **** {
3419:../uvc.c      ****     uint8_t CtrlAdd;
3420:../uvc.c      **** #ifdef DbgInfo
3421:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3422:../uvc.c      **** #endif
3423:../uvc.c      ****     switch (wValue)
3424:../uvc.c      ****     {
3425:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3426:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3428:../uvc.c      ****     		break;
3429:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3430:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3432:../uvc.c      ****     		break;
3433:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3434:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3436:../uvc.c      **** 			break;
3437:../uvc.c      **** 
3438:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3439:../uvc.c      **** 
3440:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3441:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3443:../uvc.c      ****       		break;
3444:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3445:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3446:../uvc.c      ****      		ControlHandle(HueCtlID5);
3447:../uvc.c      ****      		break;
3448:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3449:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3451:../uvc.c      ****           		break;
3452:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3453:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3455:../uvc.c      ****           		break;
3456:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3457:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3458:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3459:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3461:../uvc.c      ****     		break;
3462:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3463:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3465:../uvc.c      ****     		break;
3466:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3467:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3469:../uvc.c      ****     		break;
3470:../uvc.c      **** 
3471:../uvc.c      ****         default:
3472:../uvc.c      ****             /*
3473:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3474:../uvc.c      ****              * other controls.
3475:../uvc.c      ****              */
3476:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3477:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3478:../uvc.c      ****             break;
3479:../uvc.c      ****     }
3480:../uvc.c      **** }
3481:../uvc.c      **** 
3482:../uvc.c      **** /*
3483:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3484:../uvc.c      ****  */
3485:../uvc.c      **** static void
3486:../uvc.c      **** UVCHandleCameraTerminalRqts (
3487:../uvc.c      ****         void)
3488:../uvc.c      **** {
3489:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3490:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3491:../uvc.c      ****     uint16_t readCount;
3492:../uvc.c      ****     uint16_t zoomVal;
3493:../uvc.c      ****     int32_t  panVal, tiltVal;
3494:../uvc.c      ****     CyBool_t sendData = CyFalse;
3495:../uvc.c      **** #endif
3496:../uvc.c      ****     uint8_t CtrlAdd;
3497:../uvc.c      **** 
3498:../uvc.c      ****     switch (wValue)
3499:../uvc.c      ****     {
3500:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3501:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3503:../uvc.c      ****     		break;
3504:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3505:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3507:../uvc.c      ****     		break;
3508:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3509:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3511:../uvc.c      **** 			break;
3512:../uvc.c      **** 
3513:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3514:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3516:../uvc.c      **** 			break;
3517:../uvc.c      **** 
3518:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3519:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3521:../uvc.c      ****       		break;
3522:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3523:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3525:../uvc.c      ****      		break;
3526:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3527:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3529:../uvc.c      ****           		break;
3530:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3531:../uvc.c      ****           		break;
3532:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3533:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3535:../uvc.c      ****      		break;
3536:../uvc.c      **** 
3537:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3538:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3540:../uvc.c      ****     		break;
3541:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3542:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3544:../uvc.c      ****     		break;
3545:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3546:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3548:../uvc.c      ****     		break;
3549:../uvc.c      **** 
3550:../uvc.c      ****         default:
3551:../uvc.c      ****             /*
3552:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3553:../uvc.c      ****              * other controls.
3554:../uvc.c      ****              */
3555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3556:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3557:../uvc.c      ****             break;
3558:../uvc.c      ****     }
3559:../uvc.c      **** 
3560:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3561:../uvc.c      ****     switch (wValue)
3562:../uvc.c      ****     {
3563:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3564:../uvc.c      ****             switch (bRequest)
3565:../uvc.c      ****             {
3566:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3567:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3568:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3569:../uvc.c      ****                     break;
3570:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3571:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3572:../uvc.c      ****                     sendData = CyTrue;
3573:../uvc.c      ****                     break;
3574:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3575:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3576:../uvc.c      ****                     sendData = CyTrue;
3577:../uvc.c      ****                     break;
3578:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3579:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3580:../uvc.c      ****                     sendData = CyTrue;
3581:../uvc.c      ****                     break;
3582:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3583:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3584:../uvc.c      ****                     sendData = CyTrue;
3585:../uvc.c      ****                     break;
3586:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3587:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3588:../uvc.c      ****                     sendData = CyTrue;
3589:../uvc.c      ****                     break;
3590:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3591:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3592:../uvc.c      ****                             glEp0Buffer, &readCount);
3593:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3594:../uvc.c      ****                     {
3595:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3596:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3597:../uvc.c      ****                     }
3598:../uvc.c      ****                     break;
3599:../uvc.c      ****                 default:
3600:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3601:../uvc.c      ****                     break;
3602:../uvc.c      ****             }
3603:../uvc.c      **** 
3604:../uvc.c      ****             if (sendData)
3605:../uvc.c      ****             {
3606:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3607:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3608:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3609:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3610:../uvc.c      ****             }
3611:../uvc.c      ****             break;
3612:../uvc.c      **** 
3613:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3614:../uvc.c      ****             switch (bRequest)
3615:../uvc.c      ****             {
3616:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3617:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3618:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3619:../uvc.c      ****                     break;
3620:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3621:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3622:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3623:../uvc.c      ****                     sendData = CyTrue;
3624:../uvc.c      ****                     break;
3625:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3626:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3627:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3628:../uvc.c      ****                     sendData = CyTrue;
3629:../uvc.c      ****                     break;
3630:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3631:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3632:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3633:../uvc.c      ****                     sendData = CyTrue;
3634:../uvc.c      ****                     break;
3635:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3636:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3637:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3638:../uvc.c      ****                     sendData = CyTrue;
3639:../uvc.c      ****                     break;
3640:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3641:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3642:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3643:../uvc.c      ****                     sendData = CyTrue;
3644:../uvc.c      ****                     break;
3645:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3646:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3647:../uvc.c      ****                             glEp0Buffer, &readCount);
3648:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3649:../uvc.c      ****                     {
3650:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3651:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3652:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3653:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3654:../uvc.c      **** 
3655:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3656:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3657:../uvc.c      ****                     }
3658:../uvc.c      ****                     break;
3659:../uvc.c      ****                 default:
3660:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3661:../uvc.c      ****                     break;
3662:../uvc.c      ****             }
3663:../uvc.c      **** 
3664:../uvc.c      ****             if (sendData)
3665:../uvc.c      ****             {
3666:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3667:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3668:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3669:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3670:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3671:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3672:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3673:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3674:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3675:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3676:../uvc.c      ****             }
3677:../uvc.c      ****             break;
3678:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3679:../uvc.c      ****         default:
3680:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3681:../uvc.c      ****             break;
3682:../uvc.c      ****     }
3683:../uvc.c      **** #endif
3684:../uvc.c      **** }
3685:../uvc.c      **** 
3686:../uvc.c      **** /*
3687:../uvc.c      ****  * Handler for UVC Interface control requests.
3688:../uvc.c      ****  */
3689:../uvc.c      **** static void
3690:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3691:../uvc.c      ****         void)
3692:../uvc.c      **** {
3693:../uvc.c      **** 	if(valIdx < 32){
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
3695:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
3696:../uvc.c      **** 		valIdx++;
3697:../uvc.c      **** 		value[0][1] = valIdx;
3698:../uvc.c      **** 	}
3699:../uvc.c      ****     switch (wValue)
3700:../uvc.c      ****     {
3701:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3702:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3703:../uvc.c      ****     		break;
3704:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3705:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3706:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3707:../uvc.c      ****     		break;
3708:../uvc.c      ****     	default:
3709:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3710:../uvc.c      ****      		break;
3711:../uvc.c      ****     }
3712:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3713:../uvc.c      **** 
3714:../uvc.c      **** }
3715:../uvc.c      **** 
3716:../uvc.c      **** /*
3717:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3718:../uvc.c      ****  */
3719:../uvc.c      **** static void
3720:../uvc.c      **** UVCHandleExtensionUnitRqts (
3721:../uvc.c      ****         void)
3722:../uvc.c      **** {
3723:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3724:../uvc.c      **** 
3725:../uvc.c      **** #ifdef DbgInfo
3726:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3727:../uvc.c      **** #endif
3728:../uvc.c      ****     switch (wValue)
3729:../uvc.c      ****     {
3730:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3731:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3732:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3733:../uvc.c      ****     		break;
3734:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3735:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3736:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3737:../uvc.c      ****     		break;
3738:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3739:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3740:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3741:../uvc.c      ****      		break;
3742:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3743:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3744:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3745:../uvc.c      ****     		break;
3746:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3747:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3748:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3749:../uvc.c      ****     		break;
3750:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3751:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3752:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3753:../uvc.c      ****      		break;
3754:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3755:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3756:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3757:../uvc.c      ****     		break;
3758:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3759:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3760:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3761:../uvc.c      ****     		break;
3762:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3763:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3764:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3765:../uvc.c      ****      		break;
3766:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3767:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3768:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3769:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3770:../uvc.c      ****     		}else/* no support for 1080p camera */
3771:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3772:../uvc.c      ****     		break;
3773:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3774:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3775:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3776:../uvc.c      ****     		break;
3777:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3778:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3779:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3780:../uvc.c      ****     		break;
3781:../uvc.c      **** 
3782:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3783:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3784:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3785:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3786:../uvc.c      ****     		break;
3787:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3788:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3789:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3790:../uvc.c      ****     		//break;
3791:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3792:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3793:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3794:../uvc.c      ****     		break;
3795:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3796:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3797:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3798:../uvc.c      ****     		break;
3799:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3800:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3801:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3802:../uvc.c      ****     		break;
3803:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3804:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3805:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3806:../uvc.c      ****     		break;
3807:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3808:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3809:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3810:../uvc.c      ****     		break;
3811:../uvc.c      ****    	default:
3812:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3813:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3814:../uvc.c      ****     		break;
3815:../uvc.c      ****     }
3816:../uvc.c      **** 
3817:../uvc.c      **** }
3818:../uvc.c      **** 
3819:../uvc.c      **** /*
3820:../uvc.c      ****  * Handler for the video streaming control requests.
3821:../uvc.c      ****  */
3822:../uvc.c      **** static void
3823:../uvc.c      **** UVCHandleVideoStreamingRqts (
3824:../uvc.c      ****         void)
3825:../uvc.c      **** {
3826:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3827:../uvc.c      ****     uint16_t readCount;
3828:../uvc.c      **** 
3829:../uvc.c      ****     switch (wValue)
3830:../uvc.c      ****     {
3831:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3832:../uvc.c      ****             switch (bRequest)
3833:../uvc.c      ****             {
3834:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3835:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3836:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3837:../uvc.c      ****                     break;
3838:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3839:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3840:../uvc.c      ****                     glEp0Buffer[1] = 0;
3841:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3842:../uvc.c      ****                     break;
3843:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3844:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3845:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3846:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3847:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3848:../uvc.c      ****                     {
3849:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3850:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3851:../uvc.c      **** 
3852:../uvc.c      ****                     }
3853:../uvc.c      ****                     else
3854:../uvc.c      ****                     {
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3856:../uvc.c      ****                     }
3857:../uvc.c      ****                     break;
3858:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3859:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3860:../uvc.c      ****                             glCommitCtrl, &readCount);
3861:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3862:../uvc.c      ****                     {
3863:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3864:../uvc.c      ****                         {
3865:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3866:../uvc.c      ****                                active data structure. */
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3873:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3874:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3875:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3876:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3877:../uvc.c      **** #if 0
3878:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3879:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3880:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3881:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3882:../uvc.c      **** #endif
3883:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3884:../uvc.c      ****                        }
3885:../uvc.c      ****                     }
3886:../uvc.c      ****                     break;
3887:../uvc.c      ****                 default:
3888:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3889:../uvc.c      ****                     break;
3890:../uvc.c      ****             }
3891:../uvc.c      ****             break;
3892:../uvc.c      **** 
3893:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3894:../uvc.c      ****             switch (bRequest)
3895:../uvc.c      ****             {
3896:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3899:../uvc.c      ****                     break;
3900:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3901:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3902:../uvc.c      ****                     glEp0Buffer[1] = 0;
3903:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3904:../uvc.c      ****                     break;
3905:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3906:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3907:../uvc.c      ****                     {
3908:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3909:../uvc.c      ****                     }
3910:../uvc.c      ****                     else
3911:../uvc.c      ****                     {
3912:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3913:../uvc.c      ****                     }
3914:../uvc.c      ****                     break;
3915:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3916:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3917:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3918:../uvc.c      ****                        */
3919:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3920:../uvc.c      ****                             glCommitCtrl, &readCount);
3921:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3922:../uvc.c      ****                     {
3923:../uvc.c      ****                         switch (glCommitCtrl[3])
3924:../uvc.c      ****                          {
3925:../uvc.c      ****                          	case 1: //1944
3926:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3927:../uvc.c      ****                          		CyU3PThreadSleep(500);
3928:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3929:../uvc.c      ****                          		break;
3930:../uvc.c      ****                          	case 2: //1080
3931:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3932:../uvc.c      ****                          		CyU3PThreadSleep(500);
3933:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3934:../uvc.c      ****                          		break;
3935:../uvc.c      ****                          	case 3: //720
3936:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3937:../uvc.c      ****                          		CyU3PThreadSleep(500);
3938:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3939:../uvc.c      ****                          		break;
3940:../uvc.c      ****                          	case 4: //VGA
3941:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3942:../uvc.c      ****                          		CyU3PThreadSleep(500);
3943:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3944:../uvc.c      ****                          		break;
3945:../uvc.c      ****                          	default:
3946:../uvc.c      ****                          		break;
3947:../uvc.c      ****                          }
3948:../uvc.c      ****                         setRes = glCommitCtrl[3];
3949:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3950:../uvc.c      **** 
3951:../uvc.c      **** #if 0
3952:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3953:../uvc.c      ****                         {
3954:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3955:../uvc.c      ****                         }
3956:../uvc.c      ****                         else
3957:../uvc.c      ****                         {
3958:../uvc.c      ****                             SensorScaling_VGA ();
3959:../uvc.c      ****                         }
3960:../uvc.c      **** #endif
3961:../uvc.c      ****                         /* We can start streaming video now. */
3962:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3963:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3964:../uvc.c      ****                         {
3965:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3966:../uvc.c      ****                         }
3967:../uvc.c      ****                     }
3968:../uvc.c      ****                     break;
3969:../uvc.c      **** 
3970:../uvc.c      ****                 default:
3971:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3972:../uvc.c      ****                     break;
3973:../uvc.c      ****             }
3974:../uvc.c      ****             break;
3975:../uvc.c      **** 
3976:../uvc.c      **** /* still image streaming handler */
3977:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3978:../uvc.c      ****                 switch (bRequest)
3979:../uvc.c      ****                 {
3980:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3981:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3982:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3983:../uvc.c      ****                         break;
3984:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3985:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3986:../uvc.c      ****                         glEp0Buffer[1] = 0;
3987:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3988:../uvc.c      ****                         break;
3989:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3990:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3991:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3992:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3993:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3994:../uvc.c      ****                         {
3995:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3996:../uvc.c      ****                         }
3997:../uvc.c      ****                         else
3998:../uvc.c      ****                         {
3999:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4000:../uvc.c      ****                         }
4001:../uvc.c      ****                         break;
4002:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4003:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4004:../uvc.c      ****                                 glCommitCtrl, &readCount);
4005:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4006:../uvc.c      ****                         {
4007:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
4008:../uvc.c      ****                             {
4009:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
4010:../uvc.c      ****                                    active data structure. */
4011:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
4012:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
4013:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
4014:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
4015:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
4016:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
4017:../uvc.c      ****                             }
4018:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
4019:../uvc.c      ****                         }
4020:../uvc.c      ****                         break;
4021:../uvc.c      ****                     default:
4022:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4023:../uvc.c      ****                         break;
4024:../uvc.c      ****                 }
4025:../uvc.c      ****                 break;
4026:../uvc.c      **** 
4027:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
4028:../uvc.c      ****                 switch (bRequest)
4029:../uvc.c      ****                 {
4030:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4031:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4032:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4033:../uvc.c      ****                         break;
4034:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4035:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
4036:../uvc.c      ****                         glEp0Buffer[1] = 0;
4037:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4038:../uvc.c      ****                         break;
4039:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
4040:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4041:../uvc.c      ****                         {
4042:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4043:../uvc.c      ****                         }
4044:../uvc.c      ****                         else
4045:../uvc.c      ****                         {
4046:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
4047:../uvc.c      ****                         }
4048:../uvc.c      ****                         break;
4049:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4050:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4051:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4052:../uvc.c      ****                            */
4053:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4054:../uvc.c      ****                                 glCommitCtrl, &readCount);
4055:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4056:../uvc.c      ****                         {
4057:../uvc.c      ****     #if 0
4058:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
4059:../uvc.c      ****                             {
4060:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
4061:../uvc.c      ****                             }
4062:../uvc.c      ****                             else
4063:../uvc.c      ****                             {
4064:../uvc.c      ****                                 SensorScaling_VGA ();
4065:../uvc.c      ****                             }
4066:../uvc.c      ****                             /* We can start streaming video now. */
4067:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
4068:../uvc.c      **** 
4069:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4070:../uvc.c      ****                             {
4071:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
4072:../uvc.c      ****                             }
4073:../uvc.c      **** 	#endif
4074:../uvc.c      ****                            switch (glCommitCtrl[1])
4075:../uvc.c      ****                              {
4076:../uvc.c      ****                              	case 4: //1944
4077:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
4078:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4079:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4080:../uvc.c      ****                              		break;
4081:../uvc.c      ****                              	case 3: //1080
4082:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
4083:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4084:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
4085:../uvc.c      ****                              		break;
4086:../uvc.c      ****                              	case 2: //720
4087:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
4088:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4089:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4090:../uvc.c      ****                              		break;
4091:../uvc.c      ****                             	case 1: //VGA
4092:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
4093:../uvc.c      ****                              		//CyU3PThreadSleep(500);
4094:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
4095:../uvc.c      ****                              		break;
4096:../uvc.c      ****                               	default:
4097:../uvc.c      ****                              		break;
4098:../uvc.c      ****                              }
4099:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
4100:../uvc.c      **** 
4101:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
4102:../uvc.c      **** 
4103:../uvc.c      ****                         }
4104:../uvc.c      ****                         break;
4105:../uvc.c      **** 
4106:../uvc.c      ****                     default:
4107:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4108:../uvc.c      ****                         break;
4109:../uvc.c      ****                 }
4110:../uvc.c      ****                 break;
4111:../uvc.c      **** 
4112:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
4113:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
4114:../uvc.c      ****             	switch (bRequest)
4115:../uvc.c      ****                 {
4116:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
4117:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
4118:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
4119:../uvc.c      ****                         break;
4120:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
4121:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
4122:../uvc.c      ****                         glEp0Buffer[1] = 0;
4123:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
4124:../uvc.c      ****                         break;
4125:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
4126:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
4127:../uvc.c      ****                         {
4128:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4129:../uvc.c      ****                         }
4130:../uvc.c      ****                         else
4131:../uvc.c      ****                         {
4132:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4133:../uvc.c      ****                         }
4134:../uvc.c      ****                         break;
4135:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4136:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4137:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4138:../uvc.c      ****                            */
4139:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4140:../uvc.c      ****                                 glCommitCtrl, &readCount);
4141:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4142:../uvc.c      ****                         {
4143:../uvc.c      ****     #if 1
4144:../uvc.c      ****                             /* We can start still streaming video now. */
4145:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4146:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4147:../uvc.c      ****                             {
4148:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4149:../uvc.c      ****                             }
4150:../uvc.c      ****     #endif
4151:../uvc.c      ****                             else{
4152:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4153:../uvc.c      ****                             //stillcont = 0;
4154:../uvc.c      ****                             }
4155:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4156:../uvc.c      ****                         }else{
4157:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4158:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4159:../uvc.c      ****                         }
4160:../uvc.c      ****                         break;
4161:../uvc.c      **** 
4162:../uvc.c      ****                     default:
4163:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4164:../uvc.c      ****                         break;
4165:../uvc.c      ****                 }
4166:../uvc.c      ****                 break;
4167:../uvc.c      **** 
4168:../uvc.c      ****         default:
4169:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4170:../uvc.c      ****             break;
4171:../uvc.c      ****     }
4172:../uvc.c      **** }
4173:../uvc.c      **** 
4174:../uvc.c      **** /*
4175:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4176:../uvc.c      ****  */
4177:../uvc.c      **** void
4178:../uvc.c      **** UVCAppEP0Thread_Entry (
4179:../uvc.c      ****         uint32_t input)
4180:../uvc.c      **** {
4181:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4182:../uvc.c      ****     uint32_t eventFlag;
4183:../uvc.c      **** 	CyBool_t value;
4184:../uvc.c      **** 	CyBool_t *valueptr = &value;
4185:../uvc.c      **** 
4186:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4187:../uvc.c      **** 
4188:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4189:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4190:../uvc.c      **** 
4191:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4192:../uvc.c      **** #endif
4193:../uvc.c      **** 
4194:../uvc.c      ****     /* for interrupt status test */
4195:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4196:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4197:../uvc.c      **** 
4198:../uvc.c      ****     for (;;)
4199:../uvc.c      ****     {
4200:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4201:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4202:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4203:../uvc.c      ****         {
4204:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4205:../uvc.c      ****             if (!isUsbConnected)
4206:../uvc.c      ****             {
4207:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4208:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4209:../uvc.c      ****                 {
4210:../uvc.c      ****                     isUsbConnected = CyTrue;
4211:../uvc.c      ****                 }
4212:../uvc.c      ****             }
4213:../uvc.c      **** #ifdef DbgInfo
4214:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4215:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4216:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4217:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4218:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4219:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4220:../uvc.c      **** #endif
4221:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4222:../uvc.c      ****             {
4223:../uvc.c      ****             	switch ((wIndex >> 8))
4224:../uvc.c      ****                 {
4225:../uvc.c      **** 
4226:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4227:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4228:../uvc.c      ****                         break;
4229:../uvc.c      **** 
4230:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4231:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4232:../uvc.c      ****                         break;
4233:../uvc.c      **** 
4234:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4235:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4236:../uvc.c      ****                         break;
4237:../uvc.c      **** 
4238:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4239:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4240:../uvc.c      ****                         break;
4241:../uvc.c      **** 
4242:../uvc.c      ****                     default:
4243:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4244:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4245:../uvc.c      ****                         break;
4246:../uvc.c      ****                 }
4247:../uvc.c      ****             }
4248:../uvc.c      **** 
4249:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4250:../uvc.c      ****             {
4251:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4252:../uvc.c      **** 
4253:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4254:../uvc.c      ****                 {
4255:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4256:../uvc.c      ****                 }
4257:../uvc.c      ****                 else
4258:../uvc.c      ****                 {
4259:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4260:../uvc.c      ****                 }
4261:../uvc.c      ****             }
4262:../uvc.c      **** 
4263:../uvc.c      ****             /* handle interrupt status event */
4264:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4265:../uvc.c      ****             {
4266:../uvc.c      **** 
4267:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4268:../uvc.c      ****             	/** preparing interrupt status data **/
4269:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4270:../uvc.c      **** 
4271:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4272:../uvc.c      **** 
4273:../uvc.c      **** #if 0 //for real button
4274:../uvc.c      **** 				if(value&&(!snapButFlag)){
4275:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4276:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4277:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4278:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4279:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4280:../uvc.c      **** 
4281:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4282:../uvc.c      **** 					interStabuf.size   = 1024;
4283:../uvc.c      **** 					interStabuf.status = 0;
4284:../uvc.c      **** 
4285:../uvc.c      **** 					interStabuf.count = 4;
4286:../uvc.c      **** 
4287:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4288:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4289:../uvc.c      **** 
4290:../uvc.c      **** 					/** send a interrupt status data **/
4291:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4292:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4293:../uvc.c      **** 					{
4294:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4295:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4296:../uvc.c      **** 					}
4297:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4298:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4299:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4300:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4301:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4302:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4303:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4304:../uvc.c      **** 
4305:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4306:../uvc.c      **** 					interStabuf.size   = 1024;
4307:../uvc.c      **** 					interStabuf.status = 0;
4308:../uvc.c      **** 
4309:../uvc.c      **** 					interStabuf.count = 4;
4310:../uvc.c      **** 
4311:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4312:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4313:../uvc.c      **** 
4314:../uvc.c      **** 					/** send a interrupt status data **/
4315:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4316:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4317:../uvc.c      **** 					{
4318:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4319:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4320:../uvc.c      **** 					}
4321:../uvc.c      **** 
4322:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4323:../uvc.c      **** 					stiflag = 0xFF;
4324:../uvc.c      **** 				}
4325:../uvc.c      **** #else			//for botton simulation
4326:../uvc.c      **** 				if(snapButFlag == 0x0f){
4327:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4328:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4329:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4330:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4331:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4332:../uvc.c      **** 
4333:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4334:../uvc.c      **** 					interStabuf.size   = 1024;
4335:../uvc.c      **** 					interStabuf.status = 0;
4336:../uvc.c      **** 
4337:../uvc.c      **** 					interStabuf.count = 4;
4338:../uvc.c      **** 
4339:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4340:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4341:../uvc.c      **** 
4342:../uvc.c      **** 					/** send a interrupt status data **/
4343:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4344:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4345:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4346:../uvc.c      **** 					{
4347:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4348:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4349:../uvc.c      **** 					}
4350:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4351:../uvc.c      **** 
4352:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4353:../uvc.c      **** 				}else if(!snapButFlag){
4354:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4355:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4356:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4357:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4358:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4359:../uvc.c      **** 
4360:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4361:../uvc.c      **** 					interStabuf.size   = 1024;
4362:../uvc.c      **** 					interStabuf.status = 0;
4363:../uvc.c      **** 
4364:../uvc.c      **** 					interStabuf.count = 4;
4365:../uvc.c      **** 
4366:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4367:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4368:../uvc.c      **** 
4369:../uvc.c      **** 					/** send a interrupt status data **/
4370:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4371:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4372:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4373:../uvc.c      **** 					{
4374:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4375:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4376:../uvc.c      **** 					}
4377:../uvc.c      **** 
4378:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4379:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4380:../uvc.c      **** 				}
4381:../uvc.c      **** #endif
4382:../uvc.c      **** 
4383:../uvc.c      ****             }
4384:../uvc.c      **** 
4385:../uvc.c      **** 
4386:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4387:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4388:../uvc.c      ****             {
4389:../uvc.c      ****                 /* Get the command buffer */
4390:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4391:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4392:../uvc.c      ****                 {
4393:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4394:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4395:../uvc.c      ****                 }
4396:../uvc.c      **** 
4397:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4398:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4399:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4400:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4401:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4402:../uvc.c      ****                  * register value high byte and register value low byte.
4403:../uvc.c      ****                  */
4404:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4405:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4406:../uvc.c      ****                 {
4407:../uvc.c      ****                     if (dmaInfo.count == 3)
4408:../uvc.c      ****                     {
4409:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4410:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4411:../uvc.c      ****                         dmaInfo.count = 3;
4412:../uvc.c      ****                     }
4413:../uvc.c      ****                     else if (dmaInfo.count == 4)
4414:../uvc.c      ****                     {
4415:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4416:../uvc.c      ****                         {
4417:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4418:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4419:../uvc.c      ****                         }
4420:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4421:../uvc.c      ****                     }
4422:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4423:../uvc.c      ****                 }
4424:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4425:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4426:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4427:../uvc.c      ****                  */
4428:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4429:../uvc.c      ****                 {
4430:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4431:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4432:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4433:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4434:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4435:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4436:../uvc.c      ****                         	break;
4437:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4438:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4439:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4440:../uvc.c      ****                         	break;*/
4441:../uvc.c      ****                     dmaInfo.count -= 2;
4442:../uvc.c      ****                 }
4443:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4444:../uvc.c      ****                 else
4445:../uvc.c      ****                 {
4446:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4447:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4448:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4449:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4450:../uvc.c      ****                 }
4451:../uvc.c      **** 
4452:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4453:../uvc.c      ****                 dmaInfo.size   = 1024;
4454:../uvc.c      ****                 dmaInfo.status = 0;
4455:../uvc.c      **** 
4456:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4457:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4458:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4459:../uvc.c      ****                 {
4460:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4461:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4462:../uvc.c      ****                 }
4463:../uvc.c      **** 
4464:../uvc.c      ****                 /* Wait until the response has gone out. */
4465:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4466:../uvc.c      **** 
4467:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4468:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4469:../uvc.c      ****                 {
4470:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4471:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4472:../uvc.c      ****                 }
4473:../uvc.c      ****             }
4474:../uvc.c      **** #endif
4475:../uvc.c      ****         }
4476:../uvc.c      ****         /* Allow other ready threads to run. */
4477:../uvc.c      ****         CyU3PThreadRelinquish ();
4478:../uvc.c      ****     }
4479:../uvc.c      **** }
4480:../uvc.c      **** 
4481:../uvc.c      **** /*
4482:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4483:../uvc.c      ****  * added 10/2013
4484:../uvc.c      ****  */
4485:../uvc.c      **** /*
4486:../uvc.c      **** static uint8_t timeDelay[64] = {
4487:../uvc.c      **** 
4488:../uvc.c      **** };
4489:../uvc.c      **** */
4490:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 4490 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
4491:../uvc.c      **** 
4492:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4493:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4494:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4495:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4496:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4497:../uvc.c      **** 	uint32_t flag = 0;
4498:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4499:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4500:../uvc.c      **** 	uint8_t i;
4501:../uvc.c      **** 	uint16_t delaytime;
4502:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4503:../uvc.c      **** 
4504:../uvc.c      **** #if 0 //for test the command queue
4505:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4506:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4507:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4508:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4509:../uvc.c      **** 		lcCmdDes += 1;
4510:../uvc.c      **** 	}
4511:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4512:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4513:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4514:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4515:../uvc.c      **** 		lcCmdDes += 1;
4516:../uvc.c      **** 	}
4517:../uvc.c      **** 
4518:../uvc.c      **** #endif
4519:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4520:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 4520 0
  36 0004 30229FE5 		ldr	r2, .L25
4497:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 4497 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
4490:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 4490 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 4520 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 18029FE5 		ldr	r0, .L25+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
4497:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 4497 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 4520 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
4521:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 4521 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 FC119FE5 		ldr	r1, .L25+8
  71 0044 FC519FE5 		ldr	r5, .L25+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
4522:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 4522 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
4523:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 4523 0
  79 005c DC019FE5 		ldr	r0, .L25+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
4524:../uvc.c      **** 
4525:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 4525 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
4526:../uvc.c      ****         /* Allow other ready threads to run. */
4527:../uvc.c      **** 
4528:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 4528 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
4525:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 4525 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
4529:../uvc.c      **** 	}
4530:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 4530 0
  92 0078 C8019FE5 		ldr	r0, .L25+12
  93 007c C8119FE5 		ldr	r1, .L25+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 B8619FE5 		ldr	r6, .L25+20
  99 0094 B8B19FE5 		ldr	fp, .L25+24
4531:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4532:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4533:../uvc.c      **** 	//CyU3PThreadSleep(100);
4534:../uvc.c      **** 	//SetCurCmd();
4535:../uvc.c      **** 	/*********** the loop of the thread ***********/
4536:../uvc.c      **** 	for(;;){
4537:../uvc.c      **** 
4538:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 4538 0
 101 0098 0070E0E3 		mvn	r7, #0
4539:../uvc.c      **** /*  // for test GPIO output
4540:../uvc.c      **** 		if(trigger)
4541:../uvc.c      **** 		{
4542:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4543:../uvc.c      **** 			{
4544:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4545:../uvc.c      **** 			}
4546:../uvc.c      **** 
4547:../uvc.c      **** 		}else{
4548:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4549:../uvc.c      **** 			{
4550:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4551:../uvc.c      **** 			}
4552:../uvc.c      **** 
4553:../uvc.c      **** 		}
4554:../uvc.c      **** */
4555:../uvc.c      **** 		if(0&&streamingRecove){//start stream again after the USB-pipe reset
4556:../uvc.c      **** 			CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
4557:../uvc.c      ****             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
4558:../uvc.c      **** 
4559:../uvc.c      ****             if (apiRetStatus != CY_U3P_SUCCESS)
4560:../uvc.c      ****             {
4561:../uvc.c      ****                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
4562:../uvc.c      ****             }
4563:../uvc.c      **** 		}
4564:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4565:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4566:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4567:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4568:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4569:../uvc.c      **** 				i = 0;
4570:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 4570 0
 103 009c 0090A0E3 		mov	r9, #0
4571:../uvc.c      **** 					i++;
4572:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4573:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4574:../uvc.c      **** 				}
4575:../uvc.c      **** #if 0
4576:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4577:../uvc.c      **** 				i = lcStaDes->curNum;
4578:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4579:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4580:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4581:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4582:../uvc.c      **** 
4583:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4584:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4585:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4586:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4587:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4588:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4589:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4590:../uvc.c      **** #endif
4591:../uvc.c      **** 				//}
4592:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4593:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4594:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4595:../uvc.c      **** 				/* setting delay */
4596:../uvc.c      **** 				delaytime = 300;
4597:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4598:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4599:../uvc.c      **** 			} //end of the if condition statment
4600:../uvc.c      **** #endif
4601:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
4602:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4603:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4604:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
4605:../uvc.c      **** 
4606:../uvc.c      **** 				/*
4607:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4608:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4609:../uvc.c      **** 				*/
4610:../uvc.c      **** 
4611:../uvc.c      **** 				/* find a available command */
4612:../uvc.c      **** 				i = 0;
4613:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
4614:../uvc.c      **** 					i++;
4615:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
4616:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4617:../uvc.c      **** 				}
4618:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4619:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4620:../uvc.c      **** 					i = lcCmdDes->curNum;
4621:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4622:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4623:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4624:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4625:../uvc.c      **** #if 1
4626:../uvc.c      **** 					switch(lcCmdDes->CmdID){
4627:../uvc.c      **** 						case 0x20:
4628:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4629:../uvc.c      **** 							delaytime = 500;
4630:../uvc.c      **** 							break;
4631:../uvc.c      **** 						case 0x21:
4632:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4633:../uvc.c      **** 							delaytime = 500;
4634:../uvc.c      **** 							break;
4635:../uvc.c      **** 						case 0x22:
4636:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4637:../uvc.c      **** 							delaytime = 300;
4638:../uvc.c      **** 							break;
4639:../uvc.c      **** 						case 0x23:
4640:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4641:../uvc.c      **** 							delaytime = 300;
4642:../uvc.c      **** 							break;
4643:../uvc.c      **** 						default:
4644:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4645:../uvc.c      **** 							break;
4646:../uvc.c      **** 					}
4647:../uvc.c      **** #endif
4648:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4649:../uvc.c      **** 					/** timer's ticket modify **/
4650:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4651:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4652:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4653:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4654:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4655:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4656:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4657:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4658:../uvc.c      **** #endif
4659:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
4660:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4661:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4662:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4663:../uvc.c      **** 						}else{
4664:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4665:../uvc.c      **** 						}
4666:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4667:../uvc.c      **** 					}else{
4668:../uvc.c      **** 						lcCmdDes->curNum ++;
4669:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 4669 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L20:
4538:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 4538 0
 108 00a4 14308DE2 		add	r3, sp, #20
 109 00a8 2010A0E3 		mov	r1, #32
 110 00ac 0320A0E3 		mov	r2, #3
 111 00b0 A0019FE5 		ldr	r0, .L25+28
 112 00b4 00708DE5 		str	r7, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
4564:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 4564 0
 115 00bc 0710A0E1 		mov	r1, r7
 116 00c0 1C0096E5 		ldr	r0, [r6, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
4570:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 119              		.loc 1 4570 0
 120 00c8 101096E5 		ldr	r1, [r6, #16]
 121 00cc 3C3091E5 		ldr	r3, [r1, #60]
 122 00d0 000053E3 		cmp	r3, #0
 123 00d4 0300001A 		bne	.L4
 124              	.LVL4:
 125              	.L5:
4571:../uvc.c      **** 					i++;
 126              		.loc 1 4571 0
 127 00d8 012083E2 		add	r2, r3, #1
 128 00dc FF3002E2 		and	r3, r2, #255
 129              	.LVL5:
4570:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 4570 0
 131 00e0 3F0053E3 		cmp	r3, #63
 132 00e4 FBFFFF9A 		bls	.L5
 133              	.LVL6:
 134              	.L4:
4601:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 135              		.loc 1 4601 0
 136 00e8 1C0096E5 		ldr	r0, [r6, #28]
 137 00ec FEFFFFEB 		bl	_txe_mutex_put
 138              	.LVL7:
4603:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 139              		.loc 1 4603 0
 140 00f0 1C0095E5 		ldr	r0, [r5, #28]
 141 00f4 0010E0E3 		mvn	r1, #0
 142 00f8 FEFFFFEB 		bl	_txe_mutex_get
4604:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 143              		.loc 1 4604 0
 144 00fc 104095E5 		ldr	r4, [r5, #16]
 145              	.LVL8:
4613:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 146              		.loc 1 4613 0
 147 0100 3C2094E5 		ldr	r2, [r4, #60]
 148 0104 000052E3 		cmp	r2, #0
 149 0108 0800001A 		bne	.L6
 150 010c 0030A0E3 		mov	r3, #0
 151              	.LVL9:
 152              	.L7:
4615:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 153              		.loc 1 4615 0
 154 0110 344094E5 		ldr	r4, [r4, #52]
 155              	.LVL10:
4614:../uvc.c      **** 					i++;
 156              		.loc 1 4614 0
 157 0114 01A083E2 		add	sl, r3, #1
4613:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 158              		.loc 1 4613 0
 159 0118 3C2094E5 		ldr	r2, [r4, #60]
4614:../uvc.c      **** 					i++;
 160              		.loc 1 4614 0
 161 011c FF300AE2 		and	r3, sl, #255
 162              	.LVL11:
4613:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 163              		.loc 1 4613 0
 164 0120 3F0053E3 		cmp	r3, #63
 165 0124 00005293 		cmpls	r2, #0
 166 0128 F8FFFF0A 		beq	.L7
 167 012c 104085E5 		str	r4, [r5, #16]
 168              	.LVL12:
 169              	.L6:
4619:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
 170              		.loc 1 4619 0
 171 0130 000052E3 		cmp	r2, #0
 172 0134 2D00000A 		beq	.L8
 173              	.LVL13:
4621:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 174              		.loc 1 4621 0
 175 0138 0110D4E5 		ldrb	r1, [r4, #1]	@ zero_extendqisi2
4626:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 176              		.loc 1 4626 0
 177 013c 0000D4E5 		ldrb	r0, [r4, #0]	@ zero_extendqisi2
4621:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 178              		.loc 1 4621 0
 179 0140 813081E0 		add	r3, r1, r1, asl #1
 180 0144 83E084E0 		add	lr, r4, r3, asl #1
4626:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 181              		.loc 1 4626 0
 182 0148 20C040E2 		sub	ip, r0, #32
4622:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 183              		.loc 1 4622 0
 184 014c 0510DEE5 		ldrb	r1, [lr, #5]	@ zero_extendqisi2
4621:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 185              		.loc 1 4621 0
 186 0150 0400DEE5 		ldrb	r0, [lr, #4]	@ zero_extendqisi2
 187              	.LVL14:
4623:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 188              		.loc 1 4623 0
 189 0154 0620DEE5 		ldrb	r2, [lr, #6]	@ zero_extendqisi2
 190              	.LVL15:
4624:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 191              		.loc 1 4624 0
 192 0158 B8A0DEE1 		ldrh	sl, [lr, #8]
 193              	.LVL16:
4626:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 194              		.loc 1 4626 0
 195 015c 03005CE3 		cmp	ip, #3
 196 0160 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 197 0164 1A0000EA 		b	.L9
 198              	.L14:
 199 0168 E0010000 		.word	.L10
 200 016c C4010000 		.word	.L11
 201 0170 78010000 		.word	.L13
 202 0174 78010000 		.word	.L13
 203              	.LVL17:
 204              	.L13:
4640:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 205              		.loc 1 4640 0
 206 0178 8230A0E3 		mov	r3, #130
 207 017c FEFFFFEB 		bl	SensorSetIrisControl
 208              	.LVL18:
4642:../uvc.c      **** 							break;
 209              		.loc 1 4642 0
 210 0180 4B1FA0E3 		mov	r1, #300
 211              	.LVL19:
 212              	.L15:
4651:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 213              		.loc 1 4651 0
 214 0184 0020A0E3 		mov	r2, #0
 215 0188 B0009FE5 		ldr	r0, .L25+4
 216 018c FEFFFFEB 		bl	_txe_timer_change
4652:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 217              		.loc 1 4652 0
 218 0190 A8009FE5 		ldr	r0, .L25+4
 219 0194 FEFFFFEB 		bl	_txe_timer_activate
 220              	.LVL20:
4659:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 221              		.loc 1 4659 0
 222 0198 01A0D4E5 		ldrb	sl, [r4, #1]	@ zero_extendqisi2
 223 019c 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 224 01a0 0A0052E1 		cmp	r2, sl
4668:../uvc.c      **** 						lcCmdDes->curNum ++;
 225              		.loc 1 4668 0
 226 01a4 01A08A12 		addne	sl, sl, #1
 227 01a8 01A0C415 		strneb	sl, [r4, #1]
 228              		.loc 1 4669 0
 229 01ac 3C808415 		strne	r8, [r4, #60]
4659:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 230              		.loc 1 4659 0
 231 01b0 1400000A 		beq	.L24
 232              	.LVL21:
 233              	.L19:
4670:../uvc.c      **** 					}
4671:../uvc.c      **** 				}else{
4672:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4673:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4674:../uvc.c      **** 				}
4675:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 234              		.loc 1 4675 0
 235 01b4 1C0095E5 		ldr	r0, [r5, #28]
 236 01b8 FEFFFFEB 		bl	_txe_mutex_put
 237              	.LVL22:
4676:../uvc.c      **** 			}
4677:../uvc.c      **** /*
4678:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4679:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4680:../uvc.c      **** */
4681:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4682:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4683:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4684:../uvc.c      **** #endif
4685:../uvc.c      **** 
4686:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4687:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4688:../uvc.c      **** #if 0
4689:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4690:../uvc.c      **** 
4691:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4692:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4693:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4694:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4695:../uvc.c      **** 			    i = 0;
4696:../uvc.c      **** 				 switch(cmdCopyIdx)
4697:../uvc.c      **** 				 {
4698:../uvc.c      **** 					 case BrgtCtlID1:
4699:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4700:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4701:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4702:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4703:../uvc.c      **** 							 i++;
4704:../uvc.c      **** 						 }
4705:../uvc.c      **** 						 else{
4706:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4707:../uvc.c      **** 						 }
4708:../uvc.c      **** 
4709:../uvc.c      **** 						 CyU3PBusyWait(500);
4710:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4711:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4712:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4713:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4714:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4715:../uvc.c      **** 						 }
4716:../uvc.c      **** 						 else{
4717:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4718:../uvc.c      **** 						 }
4719:../uvc.c      **** 						 break;
4720:../uvc.c      **** 					 case HueCtlID5:
4721:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4722:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4723:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4724:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4725:../uvc.c      **** 						 }
4726:../uvc.c      **** 						 else{
4727:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4728:../uvc.c      **** 						 }
4729:../uvc.c      **** 						 break;
4730:../uvc.c      **** 					 case SaturCtlID6:
4731:../uvc.c      **** 					 case WBTLevCtlID10:
4732:../uvc.c      **** 					 default:
4733:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4734:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4735:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4736:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4737:../uvc.c      **** 						 }
4738:../uvc.c      **** 						 else{
4739:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4740:../uvc.c      **** 						 }
4741:../uvc.c      **** 						 break;
4742:../uvc.c      **** 				 }
4743:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4744:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4745:../uvc.c      **** 			}
4746:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4747:../uvc.c      **** #endif
4748:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4749:../uvc.c      **** 		/* Allow other ready threads to run. */
4750:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4751:../uvc.c      **** 			CyU3PThreadRelinquish ();
 238              		.loc 1 4751 0
 239 01bc FEFFFFEB 		bl	_txe_thread_relinquish
4752:../uvc.c      **** 		}
 240              		.loc 1 4752 0
 241 01c0 B7FFFFEA 		b	.L20
 242              	.LVL23:
 243              	.L11:
4632:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 244              		.loc 1 4632 0
 245 01c4 5230A0E3 		mov	r3, #82
 246 01c8 FEFFFFEB 		bl	SensorSetIrisControl
 247              	.LVL24:
4634:../uvc.c      **** 							break;
 248              		.loc 1 4634 0
 249 01cc 7D1FA0E3 		mov	r1, #500
 250 01d0 EBFFFFEA 		b	.L15
 251              	.LVL25:
 252              	.L9:
4644:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 253              		.loc 1 4644 0
 254 01d4 FEFFFFEB 		bl	SensorSetControl
 255              	.LVL26:
 256 01d8 0A10A0E1 		mov	r1, sl
4645:../uvc.c      **** 							break;
 257              		.loc 1 4645 0
 258 01dc E8FFFFEA 		b	.L15
 259              	.LVL27:
 260              	.L10:
4628:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 261              		.loc 1 4628 0
 262 01e0 8230A0E3 		mov	r3, #130
 263 01e4 FEFFFFEB 		bl	SensorSetIrisControl
 264              	.LVL28:
4630:../uvc.c      **** 							break;
 265              		.loc 1 4630 0
 266 01e8 7D1FA0E3 		mov	r1, #500
 267 01ec E4FFFFEA 		b	.L15
 268              	.LVL29:
 269              	.L8:
4672:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 270              		.loc 1 4672 0
 271 01f0 FA1FA0E3 		mov	r1, #1000
 272 01f4 44009FE5 		ldr	r0, .L25+4
 273 01f8 FEFFFFEB 		bl	_txe_timer_change
4673:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 274              		.loc 1 4673 0
 275 01fc 3C009FE5 		ldr	r0, .L25+4
 276 0200 FEFFFFEB 		bl	_txe_timer_activate
 277 0204 EAFFFFEA 		b	.L19
 278              	.LVL30:
 279              	.L24:
4661:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 280              		.loc 1 4661 0
 281 0208 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
4660:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 282              		.loc 1 4660 0
 283 020c 3C9084E5 		str	r9, [r4, #60]
4661:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 284              		.loc 1 4661 0
 285 0210 23005CE3 		cmp	ip, #35
4662:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 286              		.loc 1 4662 0
 287 0214 24C04C82 		subhi	ip, ip, #36
 288 0218 8CC08C80 		addhi	ip, ip, ip, asl #1
4664:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 289              		.loc 1 4664 0
 290 021c 8CC08C90 		addls	ip, ip, ip, asl #1
4662:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 291              		.loc 1 4662 0
 292 0220 8CC18B80 		addhi	ip, fp, ip, asl #3
4664:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 293              		.loc 1 4664 0
 294 0224 8CC18B90 		addls	ip, fp, ip, asl #3
4662:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 295              		.loc 1 4662 0
 296 0228 1090CC85 		strhib	r9, [ip, #16]
4664:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 297              		.loc 1 4664 0
 298 022c 9091CC95 		strlsb	r9, [ip, #400]
4666:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 299              		.loc 1 4666 0
 300 0230 344094E5 		ldr	r4, [r4, #52]
 301              	.LVL31:
 302 0234 104085E5 		str	r4, [r5, #16]
 303 0238 DDFFFFEA 		b	.L19
 304              	.L26:
 305              		.align	2
 306              	.L25:
 307 023c 00000000 		.word	I2CCmdCb
 308 0240 00000000 		.word	I2CCmdTimer
 309 0244 00000000 		.word	.LC0
 310 0248 00000000 		.word	cmdQu
 311 024c 14000000 		.word	.LC1
 312 0250 00000000 		.word	statQu
 313 0254 00000000 		.word	.LANCHOR1
 314 0258 00000000 		.word	.LANCHOR0
 315              		.cfi_endproc
 316              	.LFE27:
 318              		.align	2
 320              	CyFxUvcAppDebugCallback:
 321              	.LFB16:
2599:../uvc.c      **** {
 322              		.loc 1 2599 0
 323              		.cfi_startproc
 324              		@ args = 0, pretend = 0, frame = 0
 325              		@ frame_needed = 0, uses_anonymous_args = 0
 326              		@ link register save eliminated.
 327              	.LVL32:
2600:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 328              		.loc 1 2600 0
 329 025c 080051E3 		cmp	r1, #8
 330 0260 1EFF2F11 		bxne	lr
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
 331              		.loc 1 2603 0
 332 0264 08009FE5 		ldr	r0, .L29
 333              	.LVL33:
 334 0268 1010A0E3 		mov	r1, #16
 335              	.LVL34:
 336 026c 0020A0E3 		mov	r2, #0
 337              	.LVL35:
2605:../uvc.c      **** }
 338              		.loc 1 2605 0
2603:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
 339              		.loc 1 2603 0
 340 0270 FEFFFFEA 		b	_txe_event_flags_set
 341              	.L30:
 342              		.align	2
 343              	.L29:
 344 0274 00000000 		.word	.LANCHOR0
 345              		.cfi_endproc
 346              	.LFE16:
 348              		.align	2
 349              		.global	I2CCmdCb
 351              	I2CCmdCb:
 352              	.LFB19:
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 353              		.loc 1 3043 0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              	.LVL36:
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 358              		.loc 1 3044 0
 359 0278 28209FE5 		ldr	r2, .L32
3043:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 360              		.loc 1 3043 0
 361 027c 0030A0E1 		mov	r3, r0
 362 0280 10402DE9 		stmfd	sp!, {r4, lr}
 363              	.LCFI2:
 364              		.cfi_def_cfa_offset 8
3044:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
 365              		.loc 1 3044 0
 366 0284 20109FE5 		ldr	r1, .L32+4
 367 0288 002092E5 		ldr	r2, [r2, #0]
 368 028c 0400A0E3 		mov	r0, #4
 369              	.LVL37:
 370              		.cfi_offset 14, -4
 371              		.cfi_offset 4, -8
 372 0290 FEFFFFEB 		bl	CyU3PDebugPrint
 373              	.LVL38:
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 374              		.loc 1 3045 0
 375 0294 14009FE5 		ldr	r0, .L32+8
 376 0298 2010A0E3 		mov	r1, #32
 377 029c 0020A0E3 		mov	r2, #0
3046:../uvc.c      **** }
 378              		.loc 1 3046 0
 379 02a0 1040BDE8 		ldmfd	sp!, {r4, lr}
3045:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 380              		.loc 1 3045 0
 381 02a4 FEFFFFEA 		b	_txe_event_flags_set
 382              	.L33:
 383              		.align	2
 384              	.L32:
 385 02a8 00000000 		.word	posTick
 386 02ac 38000000 		.word	.LC2
 387 02b0 00000000 		.word	.LANCHOR0
 388              		.cfi_endproc
 389              	.LFE19:
 391              		.align	2
 393              	CyFxUVCApplnUSBEventCB:
 394              	.LFB9:
2090:../uvc.c      **** {
 395              		.loc 1 2090 0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 8
 398              		@ frame_needed = 0, uses_anonymous_args = 0
 399              	.LVL39:
2091:../uvc.c      ****     switch (evtype)
 400              		.loc 1 2091 0
 401 02b4 020050E3 		cmp	r0, #2
2090:../uvc.c      **** {
 402              		.loc 1 2090 0
 403 02b8 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 404              	.LCFI3:
 405              		.cfi_def_cfa_offset 16
 406 02bc 0130A0E1 		mov	r3, r1
 407 02c0 10D04DE2 		sub	sp, sp, #16
 408              	.LCFI4:
 409              		.cfi_def_cfa_offset 32
2090:../uvc.c      **** {
 410              		.loc 1 2090 0
 411 02c4 0040A0E1 		mov	r4, r0
 412              		.cfi_offset 14, -4
 413              		.cfi_offset 6, -8
 414              		.cfi_offset 5, -12
 415              		.cfi_offset 4, -16
2091:../uvc.c      ****     switch (evtype)
 416              		.loc 1 2091 0
 417 02c8 3C00000A 		beq	.L37
 418 02cc 040050E3 		cmp	r0, #4
 419 02d0 2200000A 		beq	.L38
 420 02d4 010050E3 		cmp	r0, #1
 421 02d8 0100000A 		beq	.L40
 422              	.LVL40:
 423              	.L34:
2130:../uvc.c      **** }
 424              		.loc 1 2130 0
 425 02dc 10D08DE2 		add	sp, sp, #16
 426 02e0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 427              	.LVL41:
 428              	.L40:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 429              		.loc 1 2114 0
 430 02e4 4C519FE5 		ldr	r5, .L41
2112:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 431              		.loc 1 2112 0
 432 02e8 0020A0E1 		mov	r2, r0
 433 02ec 48119FE5 		ldr	r1, .L41+4
 434              	.LVL42:
 435 02f0 0400A0E3 		mov	r0, #4
 436              	.LVL43:
 437 02f4 FEFFFFEB 		bl	CyU3PDebugPrint
2113:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 438              		.loc 1 2113 0
 439 02f8 0400A0E1 		mov	r0, r4
 440 02fc FEFFFFEB 		bl	CyU3PGpifDisable
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 441              		.loc 1 2114 0
 442 0300 2A20D5E5 		ldrb	r2, [r5, #42]	@ zero_extendqisi2
2115:../uvc.c      ****             gpif_initialized = 0;
 443              		.loc 1 2115 0
 444 0304 00C0A0E3 		mov	ip, #0
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 445              		.loc 1 2114 0
 446 0308 04E082E3 		orr	lr, r2, #4
 447              	.LBB16:
 448              	.LBB17:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 449              		.loc 1 2074 0
 450 030c 0410A0E1 		mov	r1, r4
 451 0310 0500A0E1 		mov	r0, r5
 452 0314 0220A0E3 		mov	r2, #2
 453 0318 0C308DE2 		add	r3, sp, #12
 454              	.LBE17:
 455              	.LBE16:
2114:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x04; //set bit2
 456              		.loc 1 2114 0
 457 031c 2AE0C5E5 		strb	lr, [r5, #42]
2115:../uvc.c      ****             gpif_initialized = 0;
 458              		.loc 1 2115 0
 459 0320 A8C085E5 		str	ip, [r5, #168]
2116:../uvc.c      ****             isUsbConnected = CyFalse;
 460              		.loc 1 2116 0
 461 0324 B0C085E5 		str	ip, [r5, #176]
2117:../uvc.c      ****             streamingStarted = CyFalse;
 462              		.loc 1 2117 0
 463 0328 ACC085E5 		str	ip, [r5, #172]
 464              	.LBB19:
 465              	.LBB18:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 466              		.loc 1 2074 0
 467 032c 00C08DE5 		str	ip, [sp, #0]
 468 0330 FEFFFFEB 		bl	_txe_event_flags_get
 469 0334 004050E2 		subs	r4, r0, #0
 470 0338 E7FFFF1A 		bne	.L34
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 471              		.loc 1 2077 0
 472 033c 0110E0E3 		mvn	r1, #1
 473 0340 0220A0E3 		mov	r2, #2
 474 0344 0500A0E1 		mov	r0, r5
 475              	.L39:
 476 0348 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 477              		.loc 1 2080 0
 478 034c 0500A0E1 		mov	r0, r5
 479 0350 0210A0E3 		mov	r1, #2
 480 0354 0420A0E1 		mov	r2, r4
 481 0358 FEFFFFEB 		bl	_txe_event_flags_set
 482 035c DEFFFFEA 		b	.L34
 483              	.LVL44:
 484              	.L38:
 485              	.LBE18:
 486              	.LBE19:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 487              		.loc 1 2096 0
 488 0360 D0509FE5 		ldr	r5, .L41
2094:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 489              		.loc 1 2094 0
 490 0364 D4109FE5 		ldr	r1, .L41+8
 491              	.LVL45:
 492 0368 0020A0E1 		mov	r2, r0
 493 036c FEFFFFEB 		bl	CyU3PDebugPrint
 494              	.LVL46:
2095:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 495              		.loc 1 2095 0
 496 0370 0100A0E3 		mov	r0, #1
 497 0374 FEFFFFEB 		bl	CyU3PGpifDisable
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 498              		.loc 1 2096 0
 499 0378 2A00D5E5 		ldrb	r0, [r5, #42]	@ zero_extendqisi2
2097:../uvc.c      ****             gpif_initialized = 0;
 500              		.loc 1 2097 0
 501 037c 00C0A0E3 		mov	ip, #0
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 502              		.loc 1 2096 0
 503 0380 01E080E3 		orr	lr, r0, #1
 504              	.LBB20:
 505              	.LBB21:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 506              		.loc 1 2074 0
 507 0384 0110A0E3 		mov	r1, #1
 508 0388 0220A0E3 		mov	r2, #2
 509 038c 0500A0E1 		mov	r0, r5
 510 0390 0C308DE2 		add	r3, sp, #12
 511              	.LBE21:
 512              	.LBE20:
2096:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x01; //set bit0
 513              		.loc 1 2096 0
 514 0394 2AE0C5E5 		strb	lr, [r5, #42]
2097:../uvc.c      ****             gpif_initialized = 0;
 515              		.loc 1 2097 0
 516 0398 A8C085E5 		str	ip, [r5, #168]
2098:../uvc.c      ****             streamingStarted = CyFalse;
 517              		.loc 1 2098 0
 518 039c ACC085E5 		str	ip, [r5, #172]
 519              	.LBB23:
 520              	.LBB22:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 521              		.loc 1 2074 0
 522 03a0 00C08DE5 		str	ip, [sp, #0]
 523 03a4 FEFFFFEB 		bl	_txe_event_flags_get
 524 03a8 004050E2 		subs	r4, r0, #0
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 525              		.loc 1 2077 0
 526 03ac 0500A001 		moveq	r0, r5
 527 03b0 0110E003 		mvneq	r1, #1
 528 03b4 0220A003 		moveq	r2, #2
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 529              		.loc 1 2074 0
 530 03b8 C7FFFF1A 		bne	.L34
 531 03bc E1FFFFEA 		b	.L39
 532              	.LVL47:
 533              	.L37:
 534              	.LBE22:
 535              	.LBE23:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 536              		.loc 1 2105 0
 537 03c0 70509FE5 		ldr	r5, .L41
2103:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 538              		.loc 1 2103 0
 539 03c4 0020A0E1 		mov	r2, r0
 540 03c8 74109FE5 		ldr	r1, .L41+12
 541              	.LVL48:
 542 03cc 0400A0E3 		mov	r0, #4
 543              	.LVL49:
 544 03d0 FEFFFFEB 		bl	CyU3PDebugPrint
2104:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 545              		.loc 1 2104 0
 546 03d4 0100A0E3 		mov	r0, #1
 547 03d8 FEFFFFEB 		bl	CyU3PGpifDisable
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 548              		.loc 1 2105 0
 549 03dc 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2106:../uvc.c      ****             gpif_initialized = 0;
 550              		.loc 1 2106 0
 551 03e0 0060A0E3 		mov	r6, #0
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 552              		.loc 1 2105 0
 553 03e4 02C081E3 		orr	ip, r1, #2
 554              	.LBB24:
 555              	.LBB26:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 556              		.loc 1 2074 0
 557 03e8 0500A0E1 		mov	r0, r5
 558 03ec 0110A0E3 		mov	r1, #1
 559 03f0 0420A0E1 		mov	r2, r4
 560 03f4 0C308DE2 		add	r3, sp, #12
 561              	.LBE26:
 562              	.LBE24:
2106:../uvc.c      ****             gpif_initialized = 0;
 563              		.loc 1 2106 0
 564 03f8 A86085E5 		str	r6, [r5, #168]
2107:../uvc.c      ****             streamingStarted = CyFalse;
 565              		.loc 1 2107 0
 566 03fc AC6085E5 		str	r6, [r5, #172]
 567              	.LBB28:
 568              	.LBB25:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 569              		.loc 1 2074 0
 570 0400 00608DE5 		str	r6, [sp, #0]
 571              	.LBE25:
 572              	.LBE28:
2105:../uvc.c      ****             debugData[1][0] = debugData[1][0]|0x02; //set bit1
 573              		.loc 1 2105 0
 574 0404 2AC0C5E5 		strb	ip, [r5, #42]
 575              	.LBB29:
 576              	.LBB27:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 577              		.loc 1 2074 0
 578 0408 FEFFFFEB 		bl	_txe_event_flags_get
 579 040c 006050E2 		subs	r6, r0, #0
 580 0410 B1FFFF1A 		bne	.L34
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 581              		.loc 1 2077 0
 582 0414 0420A0E1 		mov	r2, r4
 583 0418 0500A0E1 		mov	r0, r5
 584 041c 0110E0E3 		mvn	r1, #1
 585 0420 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 586              		.loc 1 2080 0
 587 0424 0500A0E1 		mov	r0, r5
 588 0428 0410A0E1 		mov	r1, r4
 589 042c 0620A0E1 		mov	r2, r6
 590 0430 FEFFFFEB 		bl	_txe_event_flags_set
 591 0434 A8FFFFEA 		b	.L34
 592              	.L42:
 593              		.align	2
 594              	.L41:
 595 0438 00000000 		.word	.LANCHOR0
 596 043c 94000000 		.word	.LC5
 597 0440 50000000 		.word	.LC3
 598 0444 70000000 		.word	.LC4
 599              	.LBE27:
 600              	.LBE29:
 601              		.cfi_endproc
 602              	.LFE9:
 604              		.align	2
 605              		.global	CyFxUvcApplnDmaCallback
 607              	CyFxUvcApplnDmaCallback:
 608              	.LFB11:
2301:../uvc.c      **** {
 609              		.loc 1 2301 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 0
 612              		@ frame_needed = 0, uses_anonymous_args = 0
 613              	.LVL50:
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 614              		.loc 1 2308 0
 615 0448 080051E3 		cmp	r1, #8
2301:../uvc.c      **** {
 616              		.loc 1 2301 0
 617 044c F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 618              	.LCFI5:
 619              		.cfi_def_cfa_offset 20
 620 0450 0250A0E1 		mov	r5, r2
 621              		.cfi_offset 14, -4
 622              		.cfi_offset 7, -8
 623              		.cfi_offset 6, -12
 624              		.cfi_offset 5, -16
 625              		.cfi_offset 4, -20
 626 0454 0CD04DE2 		sub	sp, sp, #12
 627              	.LCFI6:
 628              		.cfi_def_cfa_offset 32
2308:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 629              		.loc 1 2308 0
 630 0458 0B00000A 		beq	.L49
2360:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 631              		.loc 1 2360 0
 632 045c 100051E3 		cmp	r1, #16
 633 0460 0700001A 		bne	.L43
2362:../uvc.c      ****         consCount++;
 634              		.loc 1 2362 0
 635 0464 7C319FE5 		ldr	r3, .L52
2363:../uvc.c      ****         streamingStarted = CyTrue;
 636              		.loc 1 2363 0
 637 0468 0120A0E3 		mov	r2, #1
 638              	.LVL51:
2362:../uvc.c      ****         consCount++;
 639              		.loc 1 2362 0
 640 046c B20CD3E1 		ldrh	r0, [r3, #194]
 641              	.LVL52:
2363:../uvc.c      ****         streamingStarted = CyTrue;
 642              		.loc 1 2363 0
 643 0470 AC2083E5 		str	r2, [r3, #172]
2362:../uvc.c      ****         consCount++;
 644              		.loc 1 2362 0
 645 0474 02C080E0 		add	ip, r0, r2
 646 0478 0C18A0E1 		mov	r1, ip, asl #16
 647              	.LVL53:
 648 047c 2128A0E1 		mov	r2, r1, lsr #16
 649 0480 B22CC3E1 		strh	r2, [r3, #194]	@ movhi
 650              	.L43:
2365:../uvc.c      **** }
 651              		.loc 1 2365 0
 652 0484 0CD08DE2 		add	sp, sp, #12
 653 0488 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 654              	.LVL54:
 655              	.L49:
2310:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 656              		.loc 1 2310 0
 657 048c B420D2E1 		ldrh	r2, [r2, #4]
 658 0490 54319FE5 		ldr	r3, .L52+4
 659 0494 030052E1 		cmp	r2, r3
 660 0498 3500000A 		beq	.L50
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 661              		.loc 1 2330 0
 662 049c 006095E5 		ldr	r6, [r5, #0]
 663              	.LBB34:
 664              	.LBB36:
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 665              		.loc 1 2035 0
 666 04a0 48719FE5 		ldr	r7, .L52+8
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 667              		.loc 1 2034 0
 668 04a4 0010E0E3 		mvn	r1, #0
 669              	.LVL55:
 670              	.LBE36:
 671              	.LBE34:
2330:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 672              		.loc 1 2330 0
 673 04a8 0C4046E2 		sub	r4, r6, #12
 674              	.LVL56:
 675              	.LBB38:
 676              	.LBB35:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 677              		.loc 1 2034 0
 678 04ac 40019FE5 		ldr	r0, .L52+12
 679              	.LVL57:
 680 04b0 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 681              		.loc 1 2035 0
 682 04b4 0400A0E1 		mov	r0, r4
 683 04b8 121D87E2 		add	r1, r7, #1152
 684 04bc 0C20A0E3 		mov	r2, #12
 685 04c0 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 686              		.loc 1 2036 0
 687 04c4 28019FE5 		ldr	r0, .L52+12
 688 04c8 FEFFFFEB 		bl	_txe_mutex_put
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 689              		.loc 1 2041 0
 690 04cc 0BC056E5 		ldrb	ip, [r6, #-11]	@ zero_extendqisi2
 691              	.LBE35:
 692              	.LBE38:
2331:../uvc.c      ****                 pb++;
 693              		.loc 1 2331 0
 694 04d0 10419FE5 		ldr	r4, .L52
 695              	.LVL58:
 696              	.LBB39:
 697              	.LBB37:
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 698              		.loc 1 2041 0
 699 04d4 02108CE3 		orr	r1, ip, #2
 700 04d8 0B1046E5 		strb	r1, [r6, #-11]
 701              	.LBE37:
 702              	.LBE39:
2331:../uvc.c      ****                 pb++;
 703              		.loc 1 2331 0
 704 04dc B60BD4E1 		ldrh	r0, [r4, #182]
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 705              		.loc 1 2337 0
 706 04e0 BA20D4E5 		ldrb	r2, [r4, #186]	@ zero_extendqisi2
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 707              		.loc 1 2332 0
 708 04e4 B410D5E1 		ldrh	r1, [r5, #4]
2331:../uvc.c      ****                 pb++;
 709              		.loc 1 2331 0
 710 04e8 013080E2 		add	r3, r0, #1
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 711              		.loc 1 2337 0
 712 04ec 0F0052E3 		cmp	r2, #15
2331:../uvc.c      ****                 pb++;
 713              		.loc 1 2331 0
 714 04f0 B63BC4E1 		strh	r3, [r4, #182]	@ movhi
2332:../uvc.c      ****                 pbc = input->buffer_p.count;
 715              		.loc 1 2332 0
 716 04f4 B81BC4E1 		strh	r1, [r4, #184]	@ movhi
2337:../uvc.c      ****                 if(stiflag == 0x0F){
 717              		.loc 1 2337 0
 718 04f8 2E00000A 		beq	.L51
 719              	.L47:
2344:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
 720              		.loc 1 2344 0
 721 04fc 01E0A0E3 		mov	lr, #1
 722 0500 BCE084E5 		str	lr, [r4, #188]
 723              	.LVL59:
 724              	.L46:
2348:../uvc.c      ****             prodCount++;
 725              		.loc 1 2348 0
 726 0504 B0ECD4E1 		ldrh	lr, [r4, #192]
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 727              		.loc 1 2349 0
 728 0508 0C1081E2 		add	r1, r1, #12
2348:../uvc.c      ****             prodCount++;
 729              		.loc 1 2348 0
 730 050c 01308EE2 		add	r3, lr, #1
 731 0510 0308A0E1 		mov	r0, r3, asl #16
 732 0514 20C8A0E1 		mov	ip, r0, lsr #16
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 733              		.loc 1 2349 0
 734 0518 0128A0E1 		mov	r2, r1, asl #16
 735 051c 2218A0E1 		mov	r1, r2, lsr #16
 736 0520 D0009FE5 		ldr	r0, .L52+16
 737 0524 0020A0E3 		mov	r2, #0
2348:../uvc.c      ****             prodCount++;
 738              		.loc 1 2348 0
 739 0528 B0CCC4E1 		strh	ip, [r4, #192]	@ movhi
2349:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 740              		.loc 1 2349 0
 741 052c FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 742              	.LVL60:
2348:../uvc.c      ****             prodCount++;
 743              		.loc 1 2348 0
 744 0530 B0109FE5 		ldr	r1, .L52
2352:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
 745              		.loc 1 2352 0
 746 0534 002050E2 		subs	r2, r0, #0
 747 0538 D1FFFF0A 		beq	.L43
2354:../uvc.c      ****                 prodCount--;
 748              		.loc 1 2354 0
 749 053c B00CD1E1 		ldrh	r0, [r1, #192]
 750              	.LVL61:
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 751              		.loc 1 2355 0
 752 0540 B430D5E1 		ldrh	r3, [r5, #4]
2354:../uvc.c      ****                 prodCount--;
 753              		.loc 1 2354 0
 754 0544 01E040E2 		sub	lr, r0, #1
 755 0548 0EC8A0E1 		mov	ip, lr, asl #16
 756 054c 2C08A0E1 		mov	r0, ip, lsr #16
 757 0550 B00CC1E1 		strh	r0, [r1, #192]	@ movhi
2355:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 758              		.loc 1 2355 0
 759 0554 B0ECD1E1 		ldrh	lr, [r1, #192]
 760 0558 B2CCD1E1 		ldrh	ip, [r1, #194]
 761 055c 0400A0E3 		mov	r0, #4
 762 0560 94109FE5 		ldr	r1, .L52+20
 763 0564 00E08DE5 		str	lr, [sp, #0]
 764 0568 04C08DE5 		str	ip, [sp, #4]
 765 056c FEFFFFEB 		bl	CyU3PDebugPrint
 766              	.LVL62:
 767 0570 C3FFFFEA 		b	.L43
 768              	.LVL63:
 769              	.L50:
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 770              		.loc 1 2324 0
 771 0574 006095E5 		ldr	r6, [r5, #0]
 772              	.LBB40:
 773              	.LBB41:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 774              		.loc 1 2034 0
 775 0578 0010E0E3 		mvn	r1, #0
 776              	.LVL64:
 777              	.LBE41:
 778              	.LBE40:
2325:../uvc.c      ****                 fb++;
 779              		.loc 1 2325 0
 780 057c 64409FE5 		ldr	r4, .L52
2324:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
 781              		.loc 1 2324 0
 782 0580 0C6046E2 		sub	r6, r6, #12
 783              	.LVL65:
 784              	.LBB43:
 785              	.LBB42:
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 786              		.loc 1 2034 0
 787 0584 68009FE5 		ldr	r0, .L52+12
 788              	.LVL66:
 789 0588 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 790              		.loc 1 2035 0
 791 058c 6C109FE5 		ldr	r1, .L52+24
 792 0590 0600A0E1 		mov	r0, r6
 793 0594 0C20A0E3 		mov	r2, #12
 794 0598 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 795              		.loc 1 2036 0
 796 059c 50009FE5 		ldr	r0, .L52+12
 797 05a0 FEFFFFEB 		bl	_txe_mutex_put
 798              	.LBE42:
 799              	.LBE43:
2325:../uvc.c      ****                 fb++;
 800              		.loc 1 2325 0
 801 05a4 B4CBD4E1 		ldrh	ip, [r4, #180]
 802 05a8 B410D5E1 		ldrh	r1, [r5, #4]
 803 05ac 01008CE2 		add	r0, ip, #1
 804 05b0 B40BC4E1 		strh	r0, [r4, #180]	@ movhi
 805 05b4 D2FFFFEA 		b	.L46
 806              	.LVL67:
 807              	.L51:
2338:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 808              		.loc 1 2338 0
 809 05b8 0010E0E3 		mvn	r1, #0
 810 05bc 30009FE5 		ldr	r0, .L52+12
 811 05c0 FEFFFFEB 		bl	_txe_mutex_get
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 812              		.loc 1 2339 0
 813 05c4 8114D7E5 		ldrb	r1, [r7, #1153]	@ zero_extendqisi2
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 814              		.loc 1 2340 0
 815 05c8 24009FE5 		ldr	r0, .L52+12
2339:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 816              		.loc 1 2339 0
 817 05cc DF2001E2 		and	r2, r1, #223
 818 05d0 8124C7E5 		strb	r2, [r7, #1153]
2340:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 819              		.loc 1 2340 0
 820 05d4 FEFFFFEB 		bl	_txe_mutex_put
2341:../uvc.c      ****                 	stiflag = 0xAA;
 821              		.loc 1 2341 0
 822 05d8 5530E0E3 		mvn	r3, #85
 823 05dc BA30C4E5 		strb	r3, [r4, #186]
 824 05e0 B410D5E1 		ldrh	r1, [r5, #4]
 825 05e4 C4FFFFEA 		b	.L47
 826              	.L53:
 827              		.align	2
 828              	.L52:
 829 05e8 00000000 		.word	.LANCHOR0
 830 05ec F03F0000 		.word	16368
 831 05f0 00000000 		.word	.LANCHOR1
 832 05f4 00000000 		.word	imgHdMux
 833 05f8 00000000 		.word	glChHandleUVCStream
 834 05fc B4000000 		.word	.LC6
 835 0600 80040000 		.word	.LANCHOR1+1152
 836              		.cfi_endproc
 837              	.LFE11:
 839              		.align	2
 841              	CyFxUVCApplnUSBSetupCB:
 842              	.LFB10:
2138:../uvc.c      **** {
 843              		.loc 1 2138 0
 844              		.cfi_startproc
 845              		@ args = 0, pretend = 0, frame = 8
 846              		@ frame_needed = 0, uses_anonymous_args = 0
 847              	.LVL68:
 848 0604 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 849              	.LCFI7:
 850              		.cfi_def_cfa_offset 32
2144:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 851              		.loc 1 2144 0
 852 0608 6C839FE5 		ldr	r8, .L83
 853              		.cfi_offset 14, -4
 854              		.cfi_offset 10, -8
 855              		.cfi_offset 9, -12
 856              		.cfi_offset 8, -16
 857              		.cfi_offset 7, -20
 858              		.cfi_offset 6, -24
 859              		.cfi_offset 5, -28
 860              		.cfi_offset 4, -32
 861 060c FF3C00E2 		and	r3, r0, #65280
 862 0610 2364A0E1 		mov	r6, r3, lsr #8
 863 0614 0060C8E5 		strb	r6, [r8, #0]
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 864              		.loc 1 2148 0
 865 0618 0630A0E1 		mov	r3, r6
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 866              		.loc 1 2143 0
 867 061c 5C439FE5 		ldr	r4, .L83+4
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 868              		.loc 1 2147 0
 869 0620 5C639FE5 		ldr	r6, .L83+8
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 870              		.loc 1 2145 0
 871 0624 5C939FE5 		ldr	r9, .L83+12
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 872              		.loc 1 2146 0
 873 0628 5CA39FE5 		ldr	sl, .L83+16
2138:../uvc.c      **** {
 874              		.loc 1 2138 0
 875 062c 18D04DE2 		sub	sp, sp, #24
 876              	.LCFI8:
 877              		.cfi_def_cfa_offset 56
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 878              		.loc 1 2147 0
 879 0630 21C8A0E1 		mov	ip, r1, lsr #16
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 880              		.loc 1 2143 0
 881 0634 FF7000E2 		and	r7, r0, #255
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 882              		.loc 1 2146 0
 883 0638 0128A0E1 		mov	r2, r1, asl #16
2147:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 884              		.loc 1 2147 0
 885 063c B0C0C6E1 		strh	ip, [r6, #0]	@ movhi
2143:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 886              		.loc 1 2143 0
 887 0640 0070C4E5 		strb	r7, [r4, #0]
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 888              		.loc 1 2146 0
 889 0644 22E8A0E1 		mov	lr, r2, lsr #16
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 890              		.loc 1 2145 0
 891 0648 2058A0E1 		mov	r5, r0, lsr #16
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 892              		.loc 1 2148 0
 893 064c 0720A0E1 		mov	r2, r7
 894 0650 08C08DE5 		str	ip, [sp, #8]
 895 0654 0400A0E3 		mov	r0, #4
 896              	.LVL69:
 897 0658 00C0A0E3 		mov	ip, #0
 898 065c 2C139FE5 		ldr	r1, .L83+20
 899              	.LVL70:
2145:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 900              		.loc 1 2145 0
 901 0660 B050C9E1 		strh	r5, [r9, #0]	@ movhi
2146:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 902              		.loc 1 2146 0
 903 0664 B0E0CAE1 		strh	lr, [sl, #0]	@ movhi
2148:../uvc.c      ****     CyU3PDebugPrint (4, "bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%
 904              		.loc 1 2148 0
 905 0668 20408DE8 		stmia	sp, {r5, lr}	@ phole stm
 906 066c 0CC08DE5 		str	ip, [sp, #12]
 907 0670 FEFFFFEB 		bl	CyU3PDebugPrint
2150:../uvc.c      ****     if(dbgIdx < 63){
 908              		.loc 1 2150 0
 909 0674 18239FE5 		ldr	r2, .L83+24
 910 0678 8C34D2E5 		ldrb	r3, [r2, #1164]	@ zero_extendqisi2
 911 067c 3E0053E3 		cmp	r3, #62
 912 0680 0D00008A 		bhi	.L55
2151:../uvc.c      ****     	if(!((bmReqType == 0xa1) || (bmReqType == 0x80))){
 913              		.loc 1 2151 0
 914 0684 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 915 0688 800054E3 		cmp	r4, #128
 916 068c A1005413 		cmpne	r4, #161
 917 0690 5800001A 		bne	.L77
 918              	.L56:
2159:../uvc.c      ****     switch (bmReqType)
 919              		.loc 1 2159 0
 920 0694 020054E3 		cmp	r4, #2
 921 0698 0D00000A 		beq	.L59
 922              	.L79:
 923 069c 1900009A 		bls	.L78
 924 06a0 210054E3 		cmp	r4, #33
 925 06a4 5C00000A 		beq	.L60
 926 06a8 A10054E3 		cmp	r4, #161
 927 06ac 5A00000A 		beq	.L60
 928              	.L74:
2139:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 929              		.loc 1 2139 0
 930 06b0 0000A0E3 		mov	r0, #0
 931              	.LVL71:
 932              	.L57:
2288:../uvc.c      **** }
 933              		.loc 1 2288 0
 934 06b4 18D08DE2 		add	sp, sp, #24
 935 06b8 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 936              	.LVL72:
 937              	.L55:
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 938              		.loc 1 2156 0
 939 06bc 0040D4E5 		ldrb	r4, [r4, #0]	@ zero_extendqisi2
 940 06c0 D0029FE5 		ldr	r0, .L83+28
 941 06c4 0020E0E3 		mvn	r2, #0
2159:../uvc.c      ****     switch (bmReqType)
 942              		.loc 1 2159 0
 943 06c8 020054E3 		cmp	r4, #2
2156:../uvc.c      ****     }else debugData[63][1] = 0xFF; //full symbol
 944              		.loc 1 2156 0
 945 06cc A720C0E5 		strb	r2, [r0, #167]
2159:../uvc.c      ****     switch (bmReqType)
 946              		.loc 1 2159 0
 947 06d0 F1FFFF1A 		bne	.L79
 948              	.L59:
2235:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 949              		.loc 1 2235 0
 950 06d4 0070D8E5 		ldrb	r7, [r8, #0]	@ zero_extendqisi2
 951 06d8 010057E3 		cmp	r7, #1
 952 06dc F3FFFF1A 		bne	.L74
2237:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 953              		.loc 1 2237 0
 954 06e0 B080DAE1 		ldrh	r8, [sl, #0]
 955 06e4 830058E3 		cmp	r8, #131
 956 06e8 F0FFFF1A 		bne	.L74
2243:../uvc.c      ****                     if (streamingStarted == CyTrue)
 957              		.loc 1 2243 0
 958 06ec A4529FE5 		ldr	r5, .L83+28
 959 06f0 AC6095E5 		ldr	r6, [r5, #172]
 960 06f4 010056E3 		cmp	r6, #1
 961 06f8 6D00000A 		beq	.L80
 962              	.LVL73:
2276:../uvc.c      ****                         CyU3PUsbAckSetup ();
 963              		.loc 1 2276 0
 964 06fc FEFFFFEB 		bl	CyU3PUsbAckSetup
2275:../uvc.c      ****                         uvcHandleReq = CyTrue;
 965              		.loc 1 2275 0
 966 0700 0700A0E1 		mov	r0, r7
 967 0704 EAFFFFEA 		b	.L57
 968              	.LVL74:
 969              	.L78:
2159:../uvc.c      ****     switch (bmReqType)
 970              		.loc 1 2159 0
 971 0708 010054E3 		cmp	r4, #1
 972 070c E7FFFF1A 		bne	.L74
2199:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 973              		.loc 1 2199 0
 974 0710 0010D8E5 		ldrb	r1, [r8, #0]	@ zero_extendqisi2
 975 0714 0B0051E3 		cmp	r1, #11
 976 0718 E4FFFF1A 		bne	.L74
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 977              		.loc 1 2203 0
 978 071c B030DAE1 		ldrh	r3, [sl, #0]
 979 0720 010053E3 		cmp	r3, #1
 980 0724 E1FFFF1A 		bne	.L74
2203:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 981              		.loc 1 2203 0 is_stmt 0 discriminator 1
 982 0728 B050D9E1 		ldrh	r5, [r9, #0]
 983 072c 000055E3 		cmp	r5, #0
 984 0730 DEFFFF1A 		bne	.L74
2208:../uvc.c      ****                     gpif_initialized = 0;
 985              		.loc 1 2208 0 is_stmt 1
 986 0734 5C629FE5 		ldr	r6, .L83+28
2206:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 987              		.loc 1 2206 0
 988 0738 5C129FE5 		ldr	r1, .L83+32
 989 073c 0400A0E3 		mov	r0, #4
 990 0740 FEFFFFEB 		bl	CyU3PDebugPrint
2207:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 991              		.loc 1 2207 0
 992 0744 0400A0E1 		mov	r0, r4
 993 0748 FEFFFFEB 		bl	CyU3PGpifDisable
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 994              		.loc 1 2211 0
 995 074c 0410A0E1 		mov	r1, r4
2208:../uvc.c      ****                     gpif_initialized = 0;
 996              		.loc 1 2208 0
 997 0750 A85086E5 		str	r5, [r6, #168]
2209:../uvc.c      ****                     streamingStarted = CyFalse;
 998              		.loc 1 2209 0
 999 0754 AC5086E5 		str	r5, [r6, #172]
2211:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1000              		.loc 1 2211 0
 1001 0758 8300A0E3 		mov	r0, #131
 1002 075c FEFFFFEB 		bl	CyU3PUsbSetEpNak
2212:../uvc.c      ****                     CyU3PBusyWait (100);
 1003              		.loc 1 2212 0
 1004 0760 6400A0E3 		mov	r0, #100
 1005 0764 FEFFFFEB 		bl	CyU3PBusyWait
2215:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1006              		.loc 1 2215 0
 1007 0768 30029FE5 		ldr	r0, .L83+36
 1008 076c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2216:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1009              		.loc 1 2216 0
 1010 0770 8300A0E3 		mov	r0, #131
 1011 0774 FEFFFFEB 		bl	CyU3PUsbFlushEp
2217:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1012              		.loc 1 2217 0
 1013 0778 0510A0E1 		mov	r1, r5
 1014 077c 8300A0E3 		mov	r0, #131
 1015 0780 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2218:../uvc.c      ****                     CyU3PBusyWait (100);
 1016              		.loc 1 2218 0
 1017 0784 6400A0E3 		mov	r0, #100
 1018 0788 FEFFFFEB 		bl	CyU3PBusyWait
2221:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1019              		.loc 1 2221 0
 1020 078c 0510A0E1 		mov	r1, r5
 1021 0790 0420A0E1 		mov	r2, r4
 1022 0794 8300A0E3 		mov	r0, #131
 1023 0798 FEFFFFEB 		bl	CyU3PUsbStall
 1024              	.LVL75:
2224:../uvc.c      ****                     CyU3PUsbAckSetup ();
 1025              		.loc 1 2224 0
 1026 079c FEFFFFEB 		bl	CyU3PUsbAckSetup
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 1027              		.loc 1 2226 0
 1028 07a0 2A20D6E5 		ldrb	r2, [r6, #42]	@ zero_extendqisi2
2227:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 1029              		.loc 1 2227 0
 1030 07a4 C44086E5 		str	r4, [r6, #196]
2226:../uvc.c      ****                     debugData[1][0] = debugData[1][0]|0x08; //set bit3
 1031              		.loc 1 2226 0
 1032 07a8 08C082E3 		orr	ip, r2, #8
 1033 07ac 2AC0C6E5 		strb	ip, [r6, #42]
 1034              	.LBB48:
 1035              	.LBB49:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1036              		.loc 1 2074 0
 1037 07b0 0600A0E1 		mov	r0, r6
 1038 07b4 0410A0E1 		mov	r1, r4
 1039 07b8 0220A0E3 		mov	r2, #2
 1040 07bc 14308DE2 		add	r3, sp, #20
 1041 07c0 00508DE5 		str	r5, [sp, #0]
 1042 07c4 FEFFFFEB 		bl	_txe_event_flags_get
 1043 07c8 005050E2 		subs	r5, r0, #0
 1044 07cc 2D00001A 		bne	.L72
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1045              		.loc 1 2077 0
 1046 07d0 0110E0E3 		mvn	r1, #1
 1047 07d4 0220A0E3 		mov	r2, #2
 1048 07d8 0600A0E1 		mov	r0, r6
 1049 07dc FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1050              		.loc 1 2080 0
 1051 07e0 0600A0E1 		mov	r0, r6
 1052 07e4 0210A0E3 		mov	r1, #2
 1053 07e8 0520A0E1 		mov	r2, r5
 1054 07ec FEFFFFEB 		bl	_txe_event_flags_set
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1055              		.loc 1 2222 0
 1056 07f0 0400A0E1 		mov	r0, r4
 1057 07f4 AEFFFFEA 		b	.L57
 1058              	.LVL76:
 1059              	.L77:
 1060              	.LBE49:
 1061              	.LBE48:
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1062              		.loc 1 2152 0
 1063 07f8 98119FE5 		ldr	r1, .L83+28
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1064              		.loc 1 2153 0
 1065 07fc 00C0D8E5 		ldrb	ip, [r8, #0]	@ zero_extendqisi2
2154:../uvc.c      **** 		dbgIdx++;
 1066              		.loc 1 2154 0
 1067 0800 010083E2 		add	r0, r3, #1
2152:../uvc.c      **** 		debugData[dbgIdx][0] = bmReqType;
 1068              		.loc 1 2152 0
 1069 0804 833081E0 		add	r3, r1, r3, asl #1
 1070 0808 2840C3E5 		strb	r4, [r3, #40]
2153:../uvc.c      **** 		debugData[dbgIdx][1] = bRequest;
 1071              		.loc 1 2153 0
 1072 080c 29C0C3E5 		strb	ip, [r3, #41]
2154:../uvc.c      **** 		dbgIdx++;
 1073              		.loc 1 2154 0
 1074 0810 8C04C2E5 		strb	r0, [r2, #1164]
2155:../uvc.c      **** 		debugData[63][1] = dbgIdx;}
 1075              		.loc 1 2155 0
 1076 0814 A700C1E5 		strb	r0, [r1, #167]
 1077 0818 9DFFFFEA 		b	.L56
 1078              	.L60:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1079              		.loc 1 2164 0
 1080 081c 0040DAE5 		ldrb	r4, [sl, #0]	@ zero_extendqisi2
 1081 0820 000054E3 		cmp	r4, #0
 1082 0824 0F00001A 		bne	.L81
 1083              	.LVL77:
2169:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1084              		.loc 1 2169 0
 1085 0828 0420A0E1 		mov	r2, r4
 1086 082c 64019FE5 		ldr	r0, .L83+28
 1087 0830 0410A0E3 		mov	r1, #4
 1088 0834 FEFFFFEB 		bl	_txe_event_flags_set
 1089              	.LVL78:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1090              		.loc 1 2171 0
 1091 0838 002050E2 		subs	r2, r0, #0
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1092              		.loc 1 2168 0
 1093 083c 0100A003 		moveq	r0, #1
 1094              	.LVL79:
2171:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1095              		.loc 1 2171 0
 1096 0840 9BFFFF0A 		beq	.L57
2173:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 1097              		.loc 1 2173 0
 1098 0844 58119FE5 		ldr	r1, .L83+40
 1099 0848 0400A0E3 		mov	r0, #4
 1100 084c FEFFFFEB 		bl	CyU3PDebugPrint
 1101              	.LVL80:
2174:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1102              		.loc 1 2174 0
 1103 0850 0400A0E1 		mov	r0, r4
 1104 0854 0110A0E3 		mov	r1, #1
 1105 0858 0420A0E1 		mov	r2, r4
 1106 085c FEFFFFEB 		bl	CyU3PUsbStall
2168:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1107              		.loc 1 2168 0
 1108 0860 0100A0E3 		mov	r0, #1
 1109 0864 92FFFFEA 		b	.L57
 1110              	.LVL81:
 1111              	.L81:
2164:../uvc.c      ****             switch (wIndex & 0xFF)
 1112              		.loc 1 2164 0
 1113 0868 010054E3 		cmp	r4, #1
 1114 086c 8FFFFF1A 		bne	.L74
 1115              	.LVL82:
2182:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1116              		.loc 1 2182 0
 1117 0870 0020A0E3 		mov	r2, #0
 1118 0874 1C019FE5 		ldr	r0, .L83+28
 1119 0878 0810A0E3 		mov	r1, #8
 1120 087c FEFFFFEB 		bl	_txe_event_flags_set
 1121              	.LVL83:
2184:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 1122              		.loc 1 2184 0
 1123 0880 002050E2 		subs	r2, r0, #0
 1124 0884 0100001A 		bne	.L82
 1125              	.LVL84:
 1126              	.L72:
 1127              	.LBB51:
 1128              	.LBB50:
2222:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1129              		.loc 1 2222 0
 1130 0888 0400A0E1 		mov	r0, r4
 1131 088c 88FFFFEA 		b	.L57
 1132              	.LVL85:
 1133              	.L82:
 1134              	.LBE50:
 1135              	.LBE51:
2187:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 1136              		.loc 1 2187 0
 1137 0890 10119FE5 		ldr	r1, .L83+44
 1138 0894 0400A0E3 		mov	r0, #4
 1139              	.LVL86:
 1140 0898 FEFFFFEB 		bl	CyU3PDebugPrint
 1141              	.LVL87:
2188:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1142              		.loc 1 2188 0
 1143 089c 0000A0E3 		mov	r0, #0
 1144 08a0 0410A0E1 		mov	r1, r4
 1145 08a4 0020A0E1 		mov	r2, r0
 1146 08a8 FEFFFFEB 		bl	CyU3PUsbStall
2181:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1147              		.loc 1 2181 0
 1148 08ac 0400A0E1 		mov	r0, r4
 1149 08b0 7FFFFFEA 		b	.L57
 1150              	.LVL88:
 1151              	.L80:
2245:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 1152              		.loc 1 2245 0
 1153 08b4 F0109FE5 		ldr	r1, .L83+48
 1154 08b8 0400A0E3 		mov	r0, #4
 1155 08bc FEFFFFEB 		bl	CyU3PDebugPrint
2249:../uvc.c      ****                         gpif_initialized = 0;
 1156              		.loc 1 2249 0
 1157 08c0 0070A0E3 		mov	r7, #0
2248:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 1158              		.loc 1 2248 0
 1159 08c4 0600A0E1 		mov	r0, r6
 1160 08c8 FEFFFFEB 		bl	CyU3PGpifDisable
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1161              		.loc 1 2253 0
 1162 08cc 0610A0E1 		mov	r1, r6
2249:../uvc.c      ****                         gpif_initialized = 0;
 1163              		.loc 1 2249 0
 1164 08d0 A87085E5 		str	r7, [r5, #168]
2250:../uvc.c      ****                         streamingStarted = CyFalse;
 1165              		.loc 1 2250 0
 1166 08d4 AC7085E5 		str	r7, [r5, #172]
2253:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 1167              		.loc 1 2253 0
 1168 08d8 0800A0E1 		mov	r0, r8
 1169 08dc FEFFFFEB 		bl	CyU3PUsbSetEpNak
2254:../uvc.c      ****                         CyU3PBusyWait (100);
 1170              		.loc 1 2254 0
 1171 08e0 6400A0E3 		mov	r0, #100
 1172 08e4 FEFFFFEB 		bl	CyU3PBusyWait
2257:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 1173              		.loc 1 2257 0
 1174 08e8 B0009FE5 		ldr	r0, .L83+36
 1175 08ec FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
2258:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1176              		.loc 1 2258 0
 1177 08f0 0800A0E1 		mov	r0, r8
 1178 08f4 FEFFFFEB 		bl	CyU3PUsbFlushEp
2259:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1179              		.loc 1 2259 0
 1180 08f8 0710A0E1 		mov	r1, r7
 1181 08fc 0800A0E1 		mov	r0, r8
 1182 0900 FEFFFFEB 		bl	CyU3PUsbSetEpNak
2260:../uvc.c      ****                         CyU3PBusyWait (100);
 1183              		.loc 1 2260 0
 1184 0904 6400A0E3 		mov	r0, #100
 1185 0908 FEFFFFEB 		bl	CyU3PBusyWait
2263:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 1186              		.loc 1 2263 0
 1187 090c 0710A0E1 		mov	r1, r7
 1188 0910 0620A0E1 		mov	r2, r6
 1189 0914 0800A0E1 		mov	r0, r8
 1190 0918 FEFFFFEB 		bl	CyU3PUsbStall
 1191              	.LVL89:
2267:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1192              		.loc 1 2267 0
 1193 091c FEFFFFEB 		bl	CyU3PUsbAckSetup
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1194              		.loc 1 2270 0
 1195 0920 2A10D5E5 		ldrb	r1, [r5, #42]	@ zero_extendqisi2
2269:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 1196              		.loc 1 2269 0
 1197 0924 C46085E5 		str	r6, [r5, #196]
2270:../uvc.c      ****                         debugData[1][0] = debugData[1][0]|0x10; //set bit0
 1198              		.loc 1 2270 0
 1199 0928 10C081E3 		orr	ip, r1, #16
 1200 092c 2AC0C5E5 		strb	ip, [r5, #42]
 1201              	.LBB52:
 1202              	.LBB53:
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1203              		.loc 1 2074 0
 1204 0930 0500A0E1 		mov	r0, r5
 1205 0934 0610A0E1 		mov	r1, r6
 1206 0938 0420A0E1 		mov	r2, r4
 1207 093c 14308DE2 		add	r3, sp, #20
 1208 0940 00708DE5 		str	r7, [sp, #0]
 1209 0944 FEFFFFEB 		bl	_txe_event_flags_get
 1210 0948 007050E2 		subs	r7, r0, #0
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1211              		.loc 1 2265 0
 1212 094c 0600A011 		movne	r0, r6
2074:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 1213              		.loc 1 2074 0
 1214 0950 57FFFF1A 		bne	.L57
2077:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 1215              		.loc 1 2077 0
 1216 0954 0110E0E3 		mvn	r1, #1
 1217 0958 0420A0E1 		mov	r2, r4
 1218 095c 0500A0E1 		mov	r0, r5
 1219 0960 FEFFFFEB 		bl	_txe_event_flags_set
2080:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1220              		.loc 1 2080 0
 1221 0964 0500A0E1 		mov	r0, r5
 1222 0968 0410A0E1 		mov	r1, r4
 1223 096c 0720A0E1 		mov	r2, r7
 1224 0970 FEFFFFEB 		bl	_txe_event_flags_set
2265:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1225              		.loc 1 2265 0
 1226 0974 0600A0E1 		mov	r0, r6
 1227 0978 4DFFFFEA 		b	.L57
 1228              	.L84:
 1229              		.align	2
 1230              	.L83:
 1231 097c 00000000 		.word	bRequest
 1232 0980 00000000 		.word	bmReqType
 1233 0984 00000000 		.word	wLength
 1234 0988 00000000 		.word	wValue
 1235 098c 00000000 		.word	wIndex
 1236 0990 00010000 		.word	.LC7
 1237 0994 00000000 		.word	.LANCHOR1
 1238 0998 00000000 		.word	.LANCHOR0
 1239 099c C8010000 		.word	.LC10
 1240 09a0 00000000 		.word	glChHandleUVCStream
 1241 09a4 5C010000 		.word	.LC8
 1242 09a8 94010000 		.word	.LC9
 1243 09ac E0010000 		.word	.LC11
 1244              	.LBE53:
 1245              	.LBE52:
 1246              		.cfi_endproc
 1247              	.LFE10:
 1249              		.align	2
 1250              		.global	CyFxGpifCB
 1252              	CyFxGpifCB:
 1253              	.LFB13:
2487:../uvc.c      **** {
 1254              		.loc 1 2487 0
 1255              		.cfi_startproc
 1256              		@ args = 0, pretend = 0, frame = 0
 1257              		@ frame_needed = 0, uses_anonymous_args = 0
 1258              	.LVL90:
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1259              		.loc 1 2488 0
 1260 09b0 010050E3 		cmp	r0, #1
2487:../uvc.c      **** {
 1261              		.loc 1 2487 0
 1262 09b4 10402DE9 		stmfd	sp!, {r4, lr}
 1263              	.LCFI9:
 1264              		.cfi_def_cfa_offset 8
2487:../uvc.c      **** {
 1265              		.loc 1 2487 0
 1266 09b8 0120A0E1 		mov	r2, r1
2488:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1267              		.loc 1 2488 0
 1268 09bc 1080BD18 		ldmnefd	sp!, {r4, pc}
 1269              		.cfi_offset 14, -4
 1270              		.cfi_offset 4, -8
 1271              	.LVL91:
 1272              	.LBB58:
 1273              	.LBB59:
2385:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1274              		.loc 1 2385 0
 1275 09c0 CC309FE5 		ldr	r3, .L100
 1276 09c4 C830D3E5 		ldrb	r3, [r3, #200]	@ zero_extendqisi2
 1277 09c8 030053E3 		cmp	r3, #3
 1278 09cc 2100000A 		beq	.L99
2411:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1279              		.loc 1 2411 0
 1280 09d0 020053E3 		cmp	r3, #2
 1281 09d4 1080BD18 		ldmnefd	sp!, {r4, pc}
2413:../uvc.c      ****         switch (stateId)
 1282              		.loc 1 2413 0
 1283 09d8 080041E2 		sub	r0, r1, #8
 1284              	.LVL92:
 1285 09dc 0A0050E3 		cmp	r0, #10
 1286 09e0 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1287 09e4 230000EA 		b	.L92
 1288              	.L94:
 1289 09e8 180A0000 		.word	.L89
 1290 09ec 780A0000 		.word	.L92
 1291 09f0 780A0000 		.word	.L92
 1292 09f4 140A0000 		.word	.L85
 1293 09f8 780A0000 		.word	.L92
 1294 09fc 780A0000 		.word	.L92
 1295 0a00 780A0000 		.word	.L92
 1296 0a04 500A0000 		.word	.L98
 1297 0a08 780A0000 		.word	.L92
 1298 0a0c 780A0000 		.word	.L92
 1299 0a10 140A0000 		.word	.L85
 1300              	.LVL93:
 1301              	.L85:
 1302 0a14 1080BDE8 		ldmfd	sp!, {r4, pc}
 1303              	.LVL94:
 1304              	.L89:
2396:../uvc.c      ****                 socket = 0;
 1305              		.loc 1 2396 0
 1306 0a18 0010A0E3 		mov	r1, #0
 1307              	.LVL95:
 1308              	.L90:
2470:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1309              		.loc 1 2470 0
 1310 0a1c 74009FE5 		ldr	r0, .L100+4
 1311 0a20 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1312              	.LVL96:
2471:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1313              		.loc 1 2471 0
 1314 0a24 002050E2 		subs	r2, r0, #0
 1315 0a28 F9FFFF0A 		beq	.L85
2473:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1316              		.loc 1 2473 0
 1317 0a2c 0400A0E3 		mov	r0, #4
 1318              	.LVL97:
 1319 0a30 64109FE5 		ldr	r1, .L100+8
 1320 0a34 FEFFFFEB 		bl	CyU3PDebugPrint
 1321              	.LVL98:
 1322              	.L95:
 1323              	.LBB60:
 1324              	.LBB61:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1325              		.loc 1 2061 0
 1326 0a38 60109FE5 		ldr	r1, .L100+12
 1327 0a3c 0400A0E3 		mov	r0, #4
 1328 0a40 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 1329              		.loc 1 2062 0
 1330 0a44 FA0FA0E3 		mov	r0, #1000
 1331 0a48 FEFFFFEB 		bl	_tx_thread_sleep
 1332 0a4c F9FFFFEA 		b	.L95
 1333              	.LVL99:
 1334              	.L98:
 1335              	.LBE61:
 1336              	.LBE60:
2440:../uvc.c      ****                 socket = 1;
 1337              		.loc 1 2440 0
 1338 0a50 0110A0E3 		mov	r1, #1
 1339              	.LVL100:
 1340 0a54 F0FFFFEA 		b	.L90
 1341              	.LVL101:
 1342              	.L99:
2387:../uvc.c      ****         switch (stateId)
 1343              		.loc 1 2387 0
 1344 0a58 0B2041E2 		sub	r2, r1, #11
 1345 0a5c 030052E3 		cmp	r2, #3
 1346 0a60 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 1347 0a64 060000EA 		b	.L88
 1348              	.L91:
 1349 0a68 180A0000 		.word	.L89
 1350 0a6c 500A0000 		.word	.L98
 1351 0a70 140A0000 		.word	.L85
 1352 0a74 140A0000 		.word	.L85
 1353              	.LVL102:
 1354              	.L92:
2459:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1355              		.loc 1 2459 0
 1356 0a78 24109FE5 		ldr	r1, .L100+16
 1357              	.LVL103:
 1358 0a7c 0100A0E3 		mov	r0, #1
 1359 0a80 FEFFFFEB 		bl	CyU3PDebugPrint
 1360              	.LVL104:
 1361              	.L88:
 1362              	.LBE59:
 1363              	.LBE58:
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1364              		.loc 1 2494 0
 1365 0a84 1C109FE5 		ldr	r1, .L100+20
 1366 0a88 0400A0E3 		mov	r0, #4
2497:../uvc.c      **** }
 1367              		.loc 1 2497 0
 1368 0a8c 1040BDE8 		ldmfd	sp!, {r4, lr}
2494:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
 1369              		.loc 1 2494 0
 1370 0a90 FEFFFFEA 		b	CyU3PDebugPrint
 1371              	.L101:
 1372              		.align	2
 1373              	.L100:
 1374 0a94 00000000 		.word	.LANCHOR0
 1375 0a98 00000000 		.word	glChHandleUVCStream
 1376 0a9c 1C020000 		.word	.LC13
 1377 0aa0 4C020000 		.word	.LC14
 1378 0aa4 04020000 		.word	.LC12
 1379 0aa8 60020000 		.word	.LC15
 1380              		.cfi_endproc
 1381              	.LFE13:
 1383              		.align	2
 1384              		.global	I2CCmdHandler
 1386              	I2CCmdHandler:
 1387              	.LFB0:
 615:../uvc.c      **** void I2CCmdHandler(){
 1388              		.loc 1 615 0
 1389              		.cfi_startproc
 1390              		@ args = 0, pretend = 0, frame = 16
 1391              		@ frame_needed = 0, uses_anonymous_args = 0
 1392 0aac F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1393              	.LCFI10:
 1394              		.cfi_def_cfa_offset 36
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1395              		.loc 1 618 0
 1396 0ab0 44439FE5 		ldr	r4, .L127
 1397              		.cfi_offset 14, -4
 1398              		.cfi_offset 11, -8
 1399              		.cfi_offset 10, -12
 1400              		.cfi_offset 9, -16
 1401              		.cfi_offset 8, -20
 1402              		.cfi_offset 7, -24
 1403              		.cfi_offset 6, -28
 1404              		.cfi_offset 5, -32
 1405              		.cfi_offset 4, -36
 615:../uvc.c      **** void I2CCmdHandler(){
 1406              		.loc 1 615 0
 1407 0ab4 3CD04DE2 		sub	sp, sp, #60
 1408              	.LCFI11:
 1409              		.cfi_def_cfa_offset 96
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1410              		.loc 1 623 0
 1411 0ab8 D310D4E5 		ldrb	r1, [r4, #211]	@ zero_extendqisi2
 618:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1412              		.loc 1 618 0
 1413 0abc CC50D4E5 		ldrb	r5, [r4, #204]	@ zero_extendqisi2
 1414              	.LVL105:
 619:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1415              		.loc 1 619 0
 1416 0ac0 CD70D4E5 		ldrb	r7, [r4, #205]	@ zero_extendqisi2
 1417              	.LVL106:
 620:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1418              		.loc 1 620 0
 1419 0ac4 D460D4E5 		ldrb	r6, [r4, #212]	@ zero_extendqisi2
 1420              	.LVL107:
 623:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1421              		.loc 1 623 0
 1422 0ac8 CEE0D4E5 		ldrb	lr, [r4, #206]	@ zero_extendqisi2
 1423 0acc CF80D4E5 		ldrb	r8, [r4, #207]	@ zero_extendqisi2
 1424 0ad0 D0A0D4E5 		ldrb	sl, [r4, #208]	@ zero_extendqisi2
 1425 0ad4 D190D4E5 		ldrb	r9, [r4, #209]	@ zero_extendqisi2
 1426 0ad8 D2B0D4E5 		ldrb	fp, [r4, #210]	@ zero_extendqisi2
 1427 0adc 14108DE5 		str	r1, [sp, #20]
 1428 0ae0 D530D4E5 		ldrb	r3, [r4, #213]	@ zero_extendqisi2
 1429 0ae4 0400A0E3 		mov	r0, #4
 1430 0ae8 1C308DE5 		str	r3, [sp, #28]
 1431 0aec D6C0D4E5 		ldrb	ip, [r4, #214]	@ zero_extendqisi2
 1432 0af0 0730A0E1 		mov	r3, r7
 1433 0af4 04139FE5 		ldr	r1, .L127+4
 1434 0af8 0520A0E1 		mov	r2, r5
 1435 0afc 00E08DE5 		str	lr, [sp, #0]
 1436 0b00 00058DE9 		stmib	sp, {r8, sl}	@ phole stm
 1437 0b04 0C908DE5 		str	r9, [sp, #12]
 1438 0b08 10B08DE5 		str	fp, [sp, #16]
 1439 0b0c 18608DE5 		str	r6, [sp, #24]
 1440 0b10 20C08DE5 		str	ip, [sp, #32]
 1441 0b14 FEFFFFEB 		bl	CyU3PDebugPrint
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1442              		.loc 1 626 0
 1443 0b18 CE30D4E5 		ldrb	r3, [r4, #206]	@ zero_extendqisi2
 1444 0b1c 700053E3 		cmp	r3, #112
 1445 0b20 1100000A 		beq	.L120
 637:../uvc.c      **** 		if(CmdType == 0){ //read
 1446              		.loc 1 637 0
 1447 0b24 000055E3 		cmp	r5, #0
 1448 0b28 0300000A 		beq	.L121
 672:../uvc.c      **** 		}else if(CmdType == 1){ //clear debug data
 1449              		.loc 1 672 0
 1450 0b2c 010055E3 		cmp	r5, #1
 1451 0b30 2E00000A 		beq	.L122
 1452              	.LVL108:
 1453              	.L102:
 728:../uvc.c      **** }
 1454              		.loc 1 728 0
 1455 0b34 3CD08DE2 		add	sp, sp, #60
 1456 0b38 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1457              	.LVL109:
 1458              	.L121:
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1459              		.loc 1 639 0
 1460 0b3c CF20D4E5 		ldrb	r2, [r4, #207]	@ zero_extendqisi2
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1461              		.loc 1 638 0
 1462 0b40 0F00A0E3 		mov	r0, #15
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1463              		.loc 1 639 0
 1464 0b44 000052E3 		cmp	r2, #0
 638:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1465              		.loc 1 638 0
 1466 0b48 D700C4E5 		strb	r0, [r4, #215]
 639:../uvc.c      **** 		if(I2CCMDArry[3] == 0){
 1467              		.loc 1 639 0
 1468 0b4c 1F00001A 		bne	.L107
 640:../uvc.c      **** 			if(I2CCMDArry[2] == 0){
 1469              		.loc 1 640 0
 1470 0b50 000053E3 		cmp	r3, #0
 1471 0b54 3200001A 		bne	.L108
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1472              		.loc 1 641 0
 1473 0b58 2820D4E5 		ldrb	r2, [r4, #40]	@ zero_extendqisi2
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1474              		.loc 1 642 0
 1475 0b5c 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
 641:../uvc.c      **** 				I2CCMDArry[10] = debugData[0][0]; //number of frame
 1476              		.loc 1 641 0
 1477 0b60 D620C4E5 		strb	r2, [r4, #214]
 642:../uvc.c      **** 				I2CCMDArry[9] = debugData[0][1];  // stream status
 1478              		.loc 1 642 0
 1479 0b64 D5C0C4E5 		strb	ip, [r4, #213]
 1480 0b68 150000EA 		b	.L114
 1481              	.L120:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1482              		.loc 1 626 0 discriminator 1
 1483 0b6c CF00D4E5 		ldrb	r0, [r4, #207]	@ zero_extendqisi2
 1484 0b70 520050E3 		cmp	r0, #82
 1485 0b74 3400000A 		beq	.L123
 1486              	.L104:
 683:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1487              		.loc 1 683 0
 1488 0b78 000055E3 		cmp	r5, #0
 1489 0b7c 5400001A 		bne	.L113
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1490              		.loc 1 699 0
 1491 0b80 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1492 0b84 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 685:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1493              		.loc 1 685 0
 1494 0b88 0FC0A0E3 		mov	ip, #15
 1495 0b8c D7C0C4E5 		strb	ip, [r4, #215]
 699:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 1496              		.loc 1 699 0
 1497 0b90 D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1498 0b94 D130D4E5 		ldrb	r3, [r4, #209]	@ zero_extendqisi2
 1499 0b98 34E08DE2 		add	lr, sp, #52
 1500 0b9c 010080E3 		orr	r0, r0, #1
 1501 0ba0 011081E3 		orr	r1, r1, #1
 1502 0ba4 00E08DE5 		str	lr, [sp, #0]
 1503 0ba8 FEFFFFEB 		bl	SensorRead2B
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1504              		.loc 1 700 0
 1505 0bac 34C0DDE5 		ldrb	ip, [sp, #52]	@ zero_extendqisi2
 701:../uvc.c      **** 				if(CmdDataLen == 2){
 1506              		.loc 1 701 0
 1507 0bb0 020056E3 		cmp	r6, #2
 700:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 1508              		.loc 1 700 0
 1509 0bb4 D5C0C4E5 		strb	ip, [r4, #213]
 702:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 1510              		.loc 1 702 0
 1511 0bb8 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 1512 0bbc 38C29F05 		ldreq	ip, .L127
 1513 0bc0 D600CC05 		streqb	r0, [ip, #214]
 1514              	.LVL110:
 1515              	.L114:
 704:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1516              		.loc 1 704 0
 1517 0bc4 0020E0E3 		mvn	r2, #0
 1518 0bc8 D720C4E5 		strb	r2, [r4, #215]
 1519 0bcc D8FFFFEA 		b	.L102
 1520              	.LVL111:
 1521              	.L107:
 662:../uvc.c      **** 		}else if(I2CCMDArry[3] == 1){
 1522              		.loc 1 662 0
 1523 0bd0 010052E3 		cmp	r2, #1
 1524 0bd4 FAFFFF1A 		bne	.L114
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1525              		.loc 1 664 0
 1526 0bd8 83C084E0 		add	ip, r4, r3, asl #1
 1527 0bdc DC00DCE5 		ldrb	r0, [ip, #220]	@ zero_extendqisi2
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1528              		.loc 1 665 0
 1529 0be0 DD10DCE5 		ldrb	r1, [ip, #221]	@ zero_extendqisi2
 664:../uvc.c      **** 				I2CCMDArry[9] = value[I2CCMDArry[2]][0];  // bmRequest
 1530              		.loc 1 664 0
 1531 0be4 D500C4E5 		strb	r0, [r4, #213]
 665:../uvc.c      **** 				I2CCMDArry[10] = value[I2CCMDArry[2]][1]; // bRequest
 1532              		.loc 1 665 0
 1533 0be8 D610C4E5 		strb	r1, [r4, #214]
 1534 0bec F4FFFFEA 		b	.L114
 1535              	.L122:
 676:../uvc.c      **** 			dbgIdx = 2;
 1536              		.loc 1 676 0
 1537 0bf0 0C229FE5 		ldr	r2, .L127+8
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1538              		.loc 1 673 0
 1539 0bf4 0010A0E3 		mov	r1, #0
 676:../uvc.c      **** 			dbgIdx = 2;
 1540              		.loc 1 676 0
 1541 0bf8 0230A0E3 		mov	r3, #2
 673:../uvc.c      **** 			debugData[0][0] = 0x00;  debugData[0][1] = 0x00;//
 1542              		.loc 1 673 0
 1543 0bfc 2810C4E5 		strb	r1, [r4, #40]
 1544 0c00 2910C4E5 		strb	r1, [r4, #41]
 674:../uvc.c      **** 			debugData[1][0] = 0x00;  debugData[1][1] = 0x00;//
 1545              		.loc 1 674 0
 1546 0c04 2A10C4E5 		strb	r1, [r4, #42]
 1547 0c08 2B10C4E5 		strb	r1, [r4, #43]
 675:../uvc.c      **** 			debugData[15][0] = 0x00;  debugData[15][1] = 0x00;//
 1548              		.loc 1 675 0
 1549 0c0c 4610C4E5 		strb	r1, [r4, #70]
 1550 0c10 4710C4E5 		strb	r1, [r4, #71]
 676:../uvc.c      **** 			dbgIdx = 2;
 1551              		.loc 1 676 0
 1552 0c14 8C34C2E5 		strb	r3, [r2, #1164]
 677:../uvc.c      **** 			valIdx = 1;
 1553              		.loc 1 677 0
 1554 0c18 8E54C2E5 		strb	r5, [r2, #1166]
 678:../uvc.c      **** 			value[0][1] = valIdx;
 1555              		.loc 1 678 0
 1556 0c1c DD50C4E5 		strb	r5, [r4, #221]
 1557 0c20 C3FFFFEA 		b	.L102
 1558              	.L108:
 644:../uvc.c      **** 			else if (I2CCMDArry[2] == 1){
 1559              		.loc 1 644 0
 1560 0c24 010053E3 		cmp	r3, #1
 1561 0c28 1A00000A 		beq	.L124
 648:../uvc.c      **** 			else if(I2CCMDArry[2] == 17){
 1562              		.loc 1 648 0
 1563 0c2c 110053E3 		cmp	r3, #17
 1564 0c30 1E00000A 		beq	.L125
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1565              		.loc 1 659 0
 1566 0c34 833084E0 		add	r3, r4, r3, asl #1
 1567 0c38 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1568              		.loc 1 660 0
 1569 0c3c 29C0D3E5 		ldrb	ip, [r3, #41]	@ zero_extendqisi2
 659:../uvc.c      **** 				I2CCMDArry[9] = debugData[I2CCMDArry[2]][0];  // bmRequest
 1570              		.loc 1 659 0
 1571 0c40 D520C4E5 		strb	r2, [r4, #213]
 660:../uvc.c      **** 				I2CCMDArry[10] = debugData[I2CCMDArry[2]][1]; // bRequest
 1572              		.loc 1 660 0
 1573 0c44 D6C0C4E5 		strb	ip, [r4, #214]
 1574 0c48 DDFFFFEA 		b	.L114
 1575              	.L123:
 626:../uvc.c      **** 	if((I2CCMDArry[2]==0x70) && (I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01
 1576              		.loc 1 626 0 discriminator 1
 1577 0c4c D020D4E5 		ldrb	r2, [r4, #208]	@ zero_extendqisi2
 1578 0c50 300052E3 		cmp	r2, #48
 1579 0c54 C7FFFF1A 		bne	.L104
 1580 0c58 D1C0D4E5 		ldrb	ip, [r4, #209]	@ zero_extendqisi2
 1581 0c5c 01005CE3 		cmp	ip, #1
 1582 0c60 C4FFFF1A 		bne	.L104
 628:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 1583              		.loc 1 628 0
 1584 0c64 D520D4E5 		ldrb	r2, [r4, #213]	@ zero_extendqisi2
 1585 0c68 94E19FE5 		ldr	lr, .L127+8
 1586 0c6c 031002E2 		and	r1, r2, #3
 1587 0c70 8D14CEE5 		strb	r1, [lr, #1165]
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1588              		.loc 1 629 0
 1589 0c74 D83094E5 		ldr	r3, [r4, #216]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1590              		.loc 1 633 0
 1591 0c78 88119FE5 		ldr	r1, .L127+12
 629:../uvc.c      **** 		if(is60Hz==CyFalse)
 1592              		.loc 1 629 0
 1593 0c7c 000053E3 		cmp	r3, #0
 631:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 1594              		.loc 1 631 0
 1595 0c80 80208203 		orreq	r2, r2, #128
 1596 0c84 D520C405 		streqb	r2, [r4, #213]
 633:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 1597              		.loc 1 633 0
 1598 0c88 8D34DEE5 		ldrb	r3, [lr, #1165]	@ zero_extendqisi2
 1599 0c8c 0400A0E3 		mov	r0, #4
 1600 0c90 FEFFFFEB 		bl	CyU3PDebugPrint
 1601 0c94 B7FFFFEA 		b	.L104
 1602              	.L124:
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1603              		.loc 1 646 0
 1604 0c98 64019FE5 		ldr	r0, .L127+8
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1605              		.loc 1 645 0
 1606 0c9c 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1607              		.loc 1 646 0
 1608 0ca0 8C34D0E5 		ldrb	r3, [r0, #1164]	@ zero_extendqisi2
 645:../uvc.c      **** 				I2CCMDArry[9] = debugData[1][0];  // abort code
 1609              		.loc 1 645 0
 1610 0ca4 D510C4E5 		strb	r1, [r4, #213]
 646:../uvc.c      **** 				I2CCMDArry[10] = dbgIdx; // freeze count
 1611              		.loc 1 646 0
 1612 0ca8 D630C4E5 		strb	r3, [r4, #214]
 1613 0cac C4FFFFEA 		b	.L114
 1614              	.L125:
 1615              	.LVL112:
 1616              	.LBB62:
 650:../uvc.c      **** 				apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 1617              		.loc 1 650 0
 1618 0cb0 0400A0E1 		mov	r0, r4
 1619 0cb4 0110A0E3 		mov	r1, #1
 1620 0cb8 FEFFFFEB 		bl	_txe_event_flags_set
 1621              	.LVL113:
 652:../uvc.c      **** 				if (apiRetStatus != CY_U3P_SUCCESS)
 1622              		.loc 1 652 0
 1623 0cbc 002050E2 		subs	r2, r0, #0
 1624 0cc0 BFFFFF0A 		beq	.L114
 654:../uvc.c      **** 					CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetStatus);
 1625              		.loc 1 654 0
 1626 0cc4 40119FE5 		ldr	r1, .L127+16
 1627 0cc8 0400A0E3 		mov	r0, #4
 1628              	.LVL114:
 1629 0ccc FEFFFFEB 		bl	CyU3PDebugPrint
 1630              	.LVL115:
 1631 0cd0 BBFFFFEA 		b	.L114
 1632              	.L113:
 1633              	.LBE62:
 708:../uvc.c      **** 	}else if(CmdType == 1){
 1634              		.loc 1 708 0
 1635 0cd4 010055E3 		cmp	r5, #1
 1636 0cd8 95FFFF1A 		bne	.L102
 710:../uvc.c      **** 			if(CmdRegLen == 2){
 1637              		.loc 1 710 0
 1638 0cdc 020057E3 		cmp	r7, #2
 1639 0ce0 2400000A 		beq	.L126
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1640              		.loc 1 715 0
 1641 0ce4 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1642 0ce8 0C319FE5 		ldr	r3, .L127
 1643 0cec FE1001E2 		and	r1, r1, #254
 1644 0cf0 820051E3 		cmp	r1, #130
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1645              		.loc 1 718 0
 1646 0cf4 D050D315 		ldrneb	r5, [r3, #208]	@ zero_extendqisi2
 1647              	.LVL116:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1648              		.loc 1 715 0
 1649 0cf8 0200001A 		bne	.L119
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1650              		.loc 1 715 0 is_stmt 0 discriminator 1
 1651 0cfc D050D3E5 		ldrb	r5, [r3, #208]	@ zero_extendqisi2
 1652 0d00 300055E3 		cmp	r5, #48
 1653 0d04 0700000A 		beq	.L117
 1654              	.L119:
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1655              		.loc 1 718 0 is_stmt 1
 1656 0d08 D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1657              	.L118:
 720:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 1658              		.loc 1 720 0
 1659 0d0c CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1660 0d10 D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1661 0d14 0520A0E1 		mov	r2, r5
 1662 0d18 FE0000E2 		and	r0, r0, #254
 1663 0d1c 00E08DE5 		str	lr, [sp, #0]
 1664 0d20 FEFFFFEB 		bl	SensorWrite2B
 1665 0d24 82FFFFEA 		b	.L102
 1666              	.L117:
 715:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1667              		.loc 1 715 0 discriminator 1
 1668 0d28 D130D3E5 		ldrb	r3, [r3, #209]	@ zero_extendqisi2
 1669 0d2c 100053E3 		cmp	r3, #16
 1670 0d30 F5FFFF1A 		bne	.L118
 716:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1671              		.loc 1 716 0
 1672 0d34 D4409FE5 		ldr	r4, .L127+20
 1673 0d38 0010E0E3 		mvn	r1, #0
 1674 0d3c 1C0094E5 		ldr	r0, [r4, #28]
 1675 0d40 2C308DE5 		str	r3, [sp, #44]
 1676 0d44 FEFFFFEB 		bl	_txe_mutex_get
 717:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1677              		.loc 1 717 0
 1678 0d48 2C309DE5 		ldr	r3, [sp, #44]
 1679 0d4c 00C0A0E3 		mov	ip, #0
 1680 0d50 0320A0E1 		mov	r2, r3
 1681 0d54 0400A0E1 		mov	r0, r4
 1682 0d58 1710A0E3 		mov	r1, #23
 1683 0d5c 0530A0E1 		mov	r3, r5
 1684 0d60 00C08DE5 		str	ip, [sp, #0]
 1685 0d64 04C08DE5 		str	ip, [sp, #4]
 1686 0d68 FEFFFFEB 		bl	cmdSet
 718:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 1687              		.loc 1 718 0
 1688 0d6c 1C0094E5 		ldr	r0, [r4, #28]
 1689 0d70 FEFFFFEB 		bl	_txe_mutex_put
 1690 0d74 6EFFFFEA 		b	.L102
 1691              	.LVL117:
 1692              	.L126:
 712:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 1693              		.loc 1 712 0
 1694 0d78 CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1695 0d7c D5E0D4E5 		ldrb	lr, [r4, #213]	@ zero_extendqisi2
 1696 0d80 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1697 0d84 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1698 0d88 FE0002E2 		and	r0, r2, #254
 1699 0d8c 0020A0E3 		mov	r2, #0
 1700 0d90 00E08DE5 		str	lr, [sp, #0]
 1701 0d94 FEFFFFEB 		bl	SensorWrite2B2
 1702 0d98 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1703 0d9c D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1704 0da0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1705 0da4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1706 0da8 0020A0E3 		mov	r2, #0
 1707 0dac FE0000E2 		and	r0, r0, #254
 1708 0db0 00C08DE5 		str	ip, [sp, #0]
 1709 0db4 FEFFFFEB 		bl	SensorWrite2B2
 1710              	.LVL118:
 1711 0db8 CE20D4E5 		ldrb	r2, [r4, #206]	@ zero_extendqisi2
 1712 0dbc D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1713 0dc0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1714 0dc4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1715 0dc8 FE0002E2 		and	r0, r2, #254
 1716 0dcc 0020A0E3 		mov	r2, #0
 1717 0dd0 00C08DE5 		str	ip, [sp, #0]
 1718 0dd4 FEFFFFEB 		bl	SensorWrite2B2
 1719 0dd8 CE00D4E5 		ldrb	r0, [r4, #206]	@ zero_extendqisi2
 1720 0ddc D5C0D4E5 		ldrb	ip, [r4, #213]	@ zero_extendqisi2
 1721 0de0 CF10D4E5 		ldrb	r1, [r4, #207]	@ zero_extendqisi2
 1722 0de4 D030D4E5 		ldrb	r3, [r4, #208]	@ zero_extendqisi2
 1723 0de8 0020A0E3 		mov	r2, #0
 1724 0dec FE0000E2 		and	r0, r0, #254
 1725 0df0 00C08DE5 		str	ip, [sp, #0]
 1726 0df4 FEFFFFEB 		bl	SensorWrite2B2
 1727 0df8 4DFFFFEA 		b	.L102
 1728              	.L128:
 1729              		.align	2
 1730              	.L127:
 1731 0dfc 00000000 		.word	.LANCHOR0
 1732 0e00 78020000 		.word	.LC16
 1733 0e04 00000000 		.word	.LANCHOR1
 1734 0e08 C4020000 		.word	.LC17
 1735 0e0c EC020000 		.word	.LC18
 1736 0e10 00000000 		.word	cmdQu
 1737              		.cfi_endproc
 1738              	.LFE0:
 1740              		.align	2
 1741              		.global	setIrisauto
 1743              	setIrisauto:
 1744              	.LFB1:
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1745              		.loc 1 734 0
 1746              		.cfi_startproc
 1747              		@ args = 0, pretend = 0, frame = 0
 1748              		@ frame_needed = 0, uses_anonymous_args = 0
 1749              	.LVL119:
 1750 0e14 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1751              	.LCFI12:
 1752              		.cfi_def_cfa_offset 16
 1753 0e18 0160A0E1 		mov	r6, r1
 1754              		.cfi_offset 14, -4
 1755              		.cfi_offset 6, -8
 1756              		.cfi_offset 5, -12
 1757              		.cfi_offset 4, -16
 1758 0e1c 08D04DE2 		sub	sp, sp, #8
 1759              	.LCFI13:
 1760              		.cfi_def_cfa_offset 24
 734:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1761              		.loc 1 734 0
 1762 0e20 0040A0E1 		mov	r4, r0
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1763              		.loc 1 737 0
 1764 0e24 0050A0E3 		mov	r5, #0
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1765              		.loc 1 736 0
 1766 0e28 0010E0E3 		mvn	r1, #0
 1767              	.LVL120:
 1768 0e2c 1C0090E5 		ldr	r0, [r0, #28]
 1769              	.LVL121:
 1770 0e30 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 1771              		.loc 1 737 0
 1772 0e34 060065E0 		rsb	r0, r5, r6
 1773 0e38 00C070E2 		rsbs	ip, r0, #0
 1774 0e3c 00C0ACE0 		adc	ip, ip, r0
 1775 0e40 2010A0E3 		mov	r1, #32
 1776 0e44 2720A0E3 		mov	r2, #39
 1777 0e48 3030A0E3 		mov	r3, #48
 1778 0e4c 0400A0E1 		mov	r0, r4
 1779 0e50 00C08DE5 		str	ip, [sp, #0]
 1780 0e54 04508DE5 		str	r5, [sp, #4]
 1781 0e58 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 1782              		.loc 1 738 0
 1783 0e5c 050056E1 		cmp	r6, r5
 1784 0e60 0260A003 		moveq	r6, #2
 1785 0e64 0160A013 		movne	r6, #1
 1786 0e68 0400A0E1 		mov	r0, r4
 1787 0e6c 2110A0E3 		mov	r1, #33
 1788 0e70 2520A0E3 		mov	r2, #37
 1789 0e74 3030A0E3 		mov	r3, #48
 1790 0e78 00608DE5 		str	r6, [sp, #0]
 1791 0e7c 04508DE5 		str	r5, [sp, #4]
 1792 0e80 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1793              		.loc 1 739 0
 1794 0e84 1C0094E5 		ldr	r0, [r4, #28]
 740:../uvc.c      **** }
 1795              		.loc 1 740 0
 1796 0e88 08D08DE2 		add	sp, sp, #8
 1797 0e8c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1798              		.loc 1 739 0
 1799 0e90 FEFFFFEA 		b	_txe_mutex_put
 1800              		.cfi_endproc
 1801              	.LFE1:
 1803              		.align	2
 1804              		.global	getShutCtrl
 1806              	getShutCtrl:
 1807              	.LFB2:
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1808              		.loc 1 744 0
 1809              		.cfi_startproc
 1810              		@ args = 0, pretend = 0, frame = 0
 1811              		@ frame_needed = 0, uses_anonymous_args = 0
 1812              	.LVL122:
 749:../uvc.c      **** 	switch (Data){
 1813              		.loc 1 749 0
 1814 0e94 013040E2 		sub	r3, r0, #1
 744:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 1815              		.loc 1 744 0
 1816 0e98 10402DE9 		stmfd	sp!, {r4, lr}
 1817              	.LCFI14:
 1818              		.cfi_def_cfa_offset 8
 1819 0e9c 08D04DE2 		sub	sp, sp, #8
 1820              	.LCFI15:
 1821              		.cfi_def_cfa_offset 16
 749:../uvc.c      **** 	switch (Data){
 1822              		.loc 1 749 0
 1823 0ea0 090053E3 		cmp	r3, #9
 1824 0ea4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1825 0ea8 380000EA 		b	.L133
 1826              		.cfi_offset 14, -4
 1827              		.cfi_offset 4, -8
 1828              	.L136:
 1829 0eac 440F0000 		.word	.L134
 1830 0eb0 440F0000 		.word	.L134
 1831 0eb4 440F0000 		.word	.L134
 1832 0eb8 440F0000 		.word	.L134
 1833 0ebc 440F0000 		.word	.L134
 1834 0ec0 D40E0000 		.word	.L135
 1835 0ec4 D40E0000 		.word	.L135
 1836 0ec8 D40E0000 		.word	.L135
 1837 0ecc D40E0000 		.word	.L135
 1838 0ed0 D40E0000 		.word	.L135
 1839              	.L135:
 1840              	.LVL123:
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1841              		.loc 1 773 0
 1842 0ed4 ECC09FE5 		ldr	ip, .L145
 771:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1843              		.loc 1 771 0
 1844 0ed8 8330A0E1 		mov	r3, r3, asl #1
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1845              		.loc 1 773 0
 1846 0edc B3309CE1 		ldrh	r3, [ip, r3]
 1847 0ee0 E4E09FE5 		ldr	lr, .L145+4
 1848 0ee4 032263E0 		rsb	r2, r3, r3, asl #4
 1849 0ee8 8240A0E1 		mov	r4, r2, asl #1
 1850 0eec 94CECEE0 		smull	ip, lr, r4, lr
 1851 0ef0 C4CFA0E1 		mov	ip, r4, asr #31
 1852 0ef4 4E246CE0 		rsb	r2, ip, lr, asr #8
 774:../uvc.c      **** 		if(NumLn > 1944)
 1853              		.loc 1 774 0
 1854 0ef8 D0E09FE5 		ldr	lr, .L145+8
 773:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 1855              		.loc 1 773 0
 1856 0efc 0228A0E1 		mov	r2, r2, asl #16
 1857 0f00 22C8A0E1 		mov	ip, r2, lsr #16
 1858              	.LVL124:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1859              		.loc 1 774 0
 1860 0f04 0E005CE1 		cmp	ip, lr
 1861 0f08 2600008A 		bhi	.L142
 776:../uvc.c      **** 		else if(NumLn < 8)
 1862              		.loc 1 776 0
 1863 0f0c 07005CE3 		cmp	ip, #7
 1864 0f10 2700008A 		bhi	.L144
 1865              	.LVL125:
 1866              	.L143:
 1867 0f14 01C0A0E3 		mov	ip, #1
 1868 0f18 08E0A0E3 		mov	lr, #8
 1869 0f1c 0C40A0E1 		mov	r4, ip
 1870              	.L139:
 1871              	.LVL126:
 779:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 1872              		.loc 1 779 0
 1873 0f20 0120A0E3 		mov	r2, #1
 1874 0f24 0020C1E5 		strb	r2, [r1, #0]
 780:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 1875              		.loc 1 780 0
 1876 0f28 0020A0E1 		mov	r2, r0
 1877 0f2c A0109FE5 		ldr	r1, .L145+12
 1878              	.LVL127:
 1879 0f30 0400A0E3 		mov	r0, #4
 1880              	.LVL128:
 1881 0f34 00E08DE5 		str	lr, [sp, #0]
 1882 0f38 04C08DE5 		str	ip, [sp, #4]
 1883 0f3c FEFFFFEB 		bl	CyU3PDebugPrint
 781:../uvc.c      **** 		break;
 1884              		.loc 1 781 0
 1885 0f40 150000EA 		b	.L138
 1886              	.LVL129:
 1887              	.L134:
 755:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 1888              		.loc 1 755 0
 1889 0f44 7CE09FE5 		ldr	lr, .L145
 1890 0f48 8330A0E1 		mov	r3, r3, asl #1
 1891 0f4c B3309EE1 		ldrh	r3, [lr, r3]
 1892              	.LVL130:
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1893              		.loc 1 757 0
 1894 0f50 80C09FE5 		ldr	ip, .L145+16
 758:../uvc.c      **** 		if(NumLn > 1944)
 1895              		.loc 1 758 0
 1896 0f54 74E09FE5 		ldr	lr, .L145+8
 757:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 1897              		.loc 1 757 0
 1898 0f58 932C8CE0 		umull	r2, ip, r3, ip
 1899 0f5c AC24A0E1 		mov	r2, ip, lsr #9
 1900 0f60 024262E0 		rsb	r4, r2, r2, asl #4
 1901 0f64 8448A0E1 		mov	r4, r4, asl #17
 1902 0f68 2428A0E1 		mov	r2, r4, lsr #16
 1903              	.LVL131:
 758:../uvc.c      **** 		if(NumLn > 1944)
 1904              		.loc 1 758 0
 1905 0f6c 0E0052E1 		cmp	r2, lr
 1906 0f70 0C00008A 		bhi	.L142
 760:../uvc.c      **** 		else if(NumLn < 8)
 1907              		.loc 1 760 0
 1908 0f74 070052E3 		cmp	r2, #7
 1909 0f78 E5FFFF9A 		bls	.L143
 1910 0f7c A449A0E1 		mov	r4, r4, lsr #19
 1911 0f80 FF4004E2 		and	r4, r4, #255
 1912 0f84 02E0A0E1 		mov	lr, r2
 1913 0f88 04C0A0E1 		mov	ip, r4
 1914 0f8c E3FFFFEA 		b	.L139
 1915              	.LVL132:
 1916              	.L133:
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1917              		.loc 1 784 0
 1918 0f90 0000A0E3 		mov	r0, #0
 1919              	.LVL133:
 785:../uvc.c      **** 		LnVal = 1;
 1920              		.loc 1 785 0
 1921 0f94 0140A0E3 		mov	r4, #1
 784:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 1922              		.loc 1 784 0
 1923 0f98 0000C1E5 		strb	r0, [r1, #0]
 1924              	.LVL134:
 1925              	.L138:
 789:../uvc.c      **** }
 1926              		.loc 1 789 0
 1927 0f9c 0400A0E1 		mov	r0, r4
 1928 0fa0 08D08DE2 		add	sp, sp, #8
 1929 0fa4 1080BDE8 		ldmfd	sp!, {r4, pc}
 1930              	.LVL135:
 1931              	.L142:
 774:../uvc.c      **** 		if(NumLn > 1944)
 1932              		.loc 1 774 0
 1933 0fa8 F3C0A0E3 		mov	ip, #243
 1934 0fac 0C40A0E1 		mov	r4, ip
 1935 0fb0 DAFFFFEA 		b	.L139
 1936              	.LVL136:
 1937              	.L144:
 776:../uvc.c      **** 		else if(NumLn < 8)
 1938              		.loc 1 776 0
 1939 0fb4 A2E9A0E1 		mov	lr, r2, lsr #19
 1940 0fb8 FF400EE2 		and	r4, lr, #255
 1941 0fbc 0CE0A0E1 		mov	lr, ip
 1942 0fc0 04C0A0E1 		mov	ip, r4
 1943              	.LVL137:
 1944 0fc4 D5FFFFEA 		b	.L139
 1945              	.L146:
 1946              		.align	2
 1947              	.L145:
 1948 0fc8 00000000 		.word	.LANCHOR2
 1949 0fcc 817F807F 		.word	2139127681
 1950 0fd0 98070000 		.word	1944
 1951 0fd4 14030000 		.word	.LC19
 1952 0fd8 01FF00FF 		.word	-16711935
 1953              		.cfi_endproc
 1954              	.LFE2:
 1956              		.align	2
 1957              		.global	ControlHandle
 1959              	ControlHandle:
 1960              	.LFB3:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1961              		.loc 1 791 0
 1962              		.cfi_startproc
 1963              		@ args = 0, pretend = 0, frame = 24
 1964              		@ frame_needed = 0, uses_anonymous_args = 0
 1965              	.LVL138:
 1966 0fdc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1967              	.LCFI16:
 1968              		.cfi_def_cfa_offset 36
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1969              		.loc 1 798 0
 1970 0fe0 230050E3 		cmp	r0, #35
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1971              		.loc 1 797 0
 1972 0fe4 207040E2 		sub	r7, r0, #32
 1973              		.cfi_offset 14, -4
 1974              		.cfi_offset 11, -8
 1975              		.cfi_offset 10, -12
 1976              		.cfi_offset 9, -16
 1977              		.cfi_offset 8, -20
 1978              		.cfi_offset 7, -24
 1979              		.cfi_offset 6, -28
 1980              		.cfi_offset 5, -32
 1981              		.cfi_offset 4, -36
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1982              		.loc 1 791 0
 1983 0fe8 2CD04DE2 		sub	sp, sp, #44
 1984              	.LCFI17:
 1985              		.cfi_def_cfa_offset 80
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1986              		.loc 1 791 0
 1987 0fec 0040A0E1 		mov	r4, r0
 797:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 1988              		.loc 1 797 0
 1989 0ff0 FF7007E2 		and	r7, r7, #255
 1990              	.LVL139:
 798:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1991              		.loc 1 798 0
 1992 0ff4 2300009A 		bls	.L148
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1993              		.loc 1 799 0
 1994 0ff8 586F9FE5 		ldr	r6, .L329+72
 1995 0ffc 872087E0 		add	r2, r7, r7, asl #1
 1996 1000 8221A0E1 		mov	r2, r2, asl #3
 1997 1004 023086E0 		add	r3, r6, r2
 800:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1998              		.loc 1 800 0
 1999 1008 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 801:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 2000              		.loc 1 801 0
 2001 100c 0F90D3E5 		ldrb	r9, [r3, #15]	@ zero_extendqisi2
 802:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 2002              		.loc 1 802 0
 2003 1010 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 813:../uvc.c      ****     reqData = bRequest;
 2004              		.loc 1 813 0
 2005 1014 F43E9FE5 		ldr	r3, .L329
 799:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2006              		.loc 1 799 0
 2007 1018 02A0D6E7 		ldrb	sl, [r6, r2]	@ zero_extendqisi2
 2008              	.LVL140:
 813:../uvc.c      ****     reqData = bRequest;
 2009              		.loc 1 813 0
 2010 101c 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 2011              	.LVL141:
 821:../uvc.c      ****     switch (bRequest)
 2012              		.loc 1 821 0
 2013 1020 830055E3 		cmp	r5, #131
 2014 1024 2200000A 		beq	.L154
 2015              	.LVL142:
 2016              	.L319:
 2017 1028 2B00009A 		bls	.L317
 2018 102c 850055E3 		cmp	r5, #133
 2019 1030 8800000A 		beq	.L156
 2020 1034 7600003A 		bcc	.L155
 2021 1038 860055E3 		cmp	r5, #134
 2022 103c C500000A 		beq	.L157
 2023 1040 870055E3 		cmp	r5, #135
 2024 1044 B900000A 		beq	.L318
 2025              	.L150:
1707:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 2026              		.loc 1 1707 0
 2027 1048 0000A0E3 		mov	r0, #0
 2028              	.LVL143:
 2029 104c 0110A0E3 		mov	r1, #1
 2030 1050 0020A0E1 		mov	r2, r0
 2031 1054 FEFFFFEB 		bl	CyU3PUsbStall
1708:../uvc.c      **** 			  break;
 2032              		.loc 1 1708 0
 2033 1058 FFA0A0E3 		mov	sl, #255
 2034 105c 0A70A0E1 		mov	r7, sl
 2035              	.LVL144:
 2036 1060 0A40A0E1 		mov	r4, sl
 2037 1064 0A80A0E1 		mov	r8, sl
 2038              	.LVL145:
 2039              	.L160:
1710:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 2040              		.loc 1 1710 0
 2041 1068 A41E9FE5 		ldr	r1, .L329+4
 2042 106c 0520A0E1 		mov	r2, r5
 2043 1070 0830A0E1 		mov	r3, r8
 2044 1074 0400A0E3 		mov	r0, #4
 2045 1078 90048DE8 		stmia	sp, {r4, r7, sl}	@ phole stm
 2046 107c FEFFFFEB 		bl	CyU3PDebugPrint
1711:../uvc.c      **** }
 2047              		.loc 1 1711 0
 2048 1080 2CD08DE2 		add	sp, sp, #44
 2049 1084 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 2050              	.LVL146:
 2051              	.L148:
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2052              		.loc 1 804 0
 2053 1088 C86E9FE5 		ldr	r6, .L329+72
 813:../uvc.c      ****     reqData = bRequest;
 2054              		.loc 1 813 0
 2055 108c 7C3E9FE5 		ldr	r3, .L329
 804:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 2056              		.loc 1 804 0
 2057 1090 808080E0 		add	r8, r0, r0, asl #1
 2058 1094 885186E0 		add	r5, r6, r8, asl #3
 2059 1098 80A1D5E5 		ldrb	sl, [r5, #384]	@ zero_extendqisi2
 2060              	.LVL147:
 805:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2061              		.loc 1 805 0
 2062 109c 81B1D5E5 		ldrb	fp, [r5, #385]	@ zero_extendqisi2
 2063              	.LVL148:
 806:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2064              		.loc 1 806 0
 2065 10a0 8F91D5E5 		ldrb	r9, [r5, #399]	@ zero_extendqisi2
 2066              	.LVL149:
 807:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2067              		.loc 1 807 0
 2068 10a4 8281D5E5 		ldrb	r8, [r5, #386]	@ zero_extendqisi2
 2069              	.LVL150:
 813:../uvc.c      ****     reqData = bRequest;
 2070              		.loc 1 813 0
 2071 10a8 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 2072              	.LVL151:
 821:../uvc.c      ****     switch (bRequest)
 2073              		.loc 1 821 0
 2074 10ac 830055E3 		cmp	r5, #131
 2075 10b0 DCFFFF1A 		bne	.L319
 2076              	.LVL152:
 2077              	.L154:
1191:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2078              		.loc 1 1191 0
 2079 10b4 230054E3 		cmp	r4, #35
 2080 10b8 C400009A 		bls	.L227
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2081              		.loc 1 1192 0
 2082 10bc 872087E0 		add	r2, r7, r7, asl #1
 2083 10c0 826186E0 		add	r6, r6, r2, asl #3
 2084 10c4 909E9FE5 		ldr	r9, .L329+76
 2085 10c8 0530D6E5 		ldrb	r3, [r6, #5]	@ zero_extendqisi2
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2086              		.loc 1 1193 0
 2087 10cc 0600D6E5 		ldrb	r0, [r6, #6]	@ zero_extendqisi2
 2088              	.LVL153:
1192:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2089              		.loc 1 1192 0
 2090 10d0 1C31C9E5 		strb	r3, [r9, #284]
1193:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2091              		.loc 1 1193 0
 2092 10d4 1D01C9E5 		strb	r0, [r9, #285]
 2093 10d8 0B0000EA 		b	.L235
 2094              	.LVL154:
 2095              	.L317:
 821:../uvc.c      ****     switch (bRequest)
 2096              		.loc 1 821 0
 2097 10dc 810055E3 		cmp	r5, #129
 2098 10e0 6800000A 		beq	.L152
 2099 10e4 1000009A 		bls	.L320
1172:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2100              		.loc 1 1172 0
 2101 10e8 230054E3 		cmp	r4, #35
 2102 10ec AB00009A 		bls	.L224
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2103              		.loc 1 1173 0
 2104 10f0 879087E0 		add	r9, r7, r7, asl #1
 2105 10f4 896186E0 		add	r6, r6, r9, asl #3
 2106 10f8 0370D6E5 		ldrb	r7, [r6, #3]	@ zero_extendqisi2
 2107              	.LVL155:
 2108 10fc 589E9FE5 		ldr	r9, .L329+76
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2109              		.loc 1 1174 0
 2110 1100 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
1173:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2111              		.loc 1 1173 0
 2112 1104 1C71C9E5 		strb	r7, [r9, #284]
1174:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2113              		.loc 1 1174 0
 2114 1108 1DE1C9E5 		strb	lr, [r9, #285]
 2115              	.LVL156:
 2116              	.L235:
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2117              		.loc 1 1249 0
 2118 110c 0800A0E1 		mov	r0, r8
1251:../uvc.c      **** 			  break;
 2119              		.loc 1 1251 0
 2120 1110 FFA0A0E3 		mov	sl, #255
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2121              		.loc 1 1249 0
 2122 1114 FC1D9FE5 		ldr	r1, .L329+8
 2123 1118 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2124              	.LVL157:
1251:../uvc.c      **** 			  break;
 2125              		.loc 1 1251 0
 2126 111c 0A40A0E1 		mov	r4, sl
1249:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2127              		.loc 1 1249 0
 2128 1120 1C71D9E5 		ldrb	r7, [r9, #284]	@ zero_extendqisi2
1251:../uvc.c      **** 			  break;
 2129              		.loc 1 1251 0
 2130 1124 0A80A0E1 		mov	r8, sl
 2131 1128 CEFFFFEA 		b	.L160
 2132              	.LVL158:
 2133              	.L320:
 821:../uvc.c      ****     switch (bRequest)
 2134              		.loc 1 821 0
 2135 112c 010055E3 		cmp	r5, #1
 2136 1130 C4FFFF1A 		bne	.L150
1253:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 2137              		.loc 1 1253 0
 2138 1134 201E9FE5 		ldr	r1, .L329+76
 2139 1138 26208DE2 		add	r2, sp, #38
 2140 113c 2000A0E3 		mov	r0, #32
 2141              	.LVL159:
 2142 1140 471F81E2 		add	r1, r1, #284
 2143 1144 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2144              	.LVL160:
1255:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 2145              		.loc 1 1255 0
 2146 1148 002050E2 		subs	r2, r0, #0
 2147 114c 4A04001A 		bne	.L237
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2148              		.loc 1 1257 0
 2149 1150 04CE9FE5 		ldr	ip, .L329+76
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2150              		.loc 1 1258 0
 2151 1154 00EE9FE5 		ldr	lr, .L329+76
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2152              		.loc 1 1257 0
 2153 1158 1C31DCE5 		ldrb	r3, [ip, #284]	@ zero_extendqisi2
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2154              		.loc 1 1260 0
 2155 115c 1E01DEE5 		ldrb	r0, [lr, #286]	@ zero_extendqisi2
 2156              	.LVL161:
1257:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 2157              		.loc 1 1257 0
 2158 1160 18308DE5 		str	r3, [sp, #24]
 2159              	.LVL162:
1258:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2160              		.loc 1 1258 0
 2161 1164 1DC1DEE5 		ldrb	ip, [lr, #285]	@ zero_extendqisi2
 2162              	.LVL163:
1260:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 2163              		.loc 1 1260 0
 2164 1168 1C008DE5 		str	r0, [sp, #28]
 2165              	.LVL164:
1264:../uvc.c      **** 				  switch(CtrlID)
 2166              		.loc 1 1264 0
 2167 116c 260054E3 		cmp	r4, #38
 2168 1170 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2169 1174 790300EA 		b	.L238
 2170              	.L256:
 2171 1178 A41E0000 		.word	.L239
 2172 117c 381E0000 		.word	.L240
 2173 1180 D81D0000 		.word	.L241
 2174 1184 601F0000 		.word	.L238
 2175 1188 741D0000 		.word	.L242
 2176 118c 341C0000 		.word	.L243
 2177 1190 BC1B0000 		.word	.L244
 2178 1194 FC210000 		.word	.L245
 2179 1198 601F0000 		.word	.L238
 2180 119c 601F0000 		.word	.L238
 2181 11a0 601F0000 		.word	.L238
 2182 11a4 78210000 		.word	.L246
 2183 11a8 601F0000 		.word	.L238
 2184 11ac 601F0000 		.word	.L238
 2185 11b0 601F0000 		.word	.L238
 2186 11b4 601F0000 		.word	.L238
 2187 11b8 9C200000 		.word	.L247
 2188 11bc 601F0000 		.word	.L238
 2189 11c0 601F0000 		.word	.L238
 2190 11c4 601F0000 		.word	.L238
 2191 11c8 601F0000 		.word	.L238
 2192 11cc 601F0000 		.word	.L238
 2193 11d0 601F0000 		.word	.L238
 2194 11d4 601F0000 		.word	.L238
 2195 11d8 601F0000 		.word	.L238
 2196 11dc C81F0000 		.word	.L248
 2197 11e0 D81D0000 		.word	.L241
 2198 11e4 98190000 		.word	.L249
 2199 11e8 10190000 		.word	.L250
 2200 11ec 601F0000 		.word	.L238
 2201 11f0 B4180000 		.word	.L251
 2202 11f4 30180000 		.word	.L252
 2203 11f8 601F0000 		.word	.L238
 2204 11fc 601F0000 		.word	.L238
 2205 1200 601F0000 		.word	.L238
 2206 1204 601F0000 		.word	.L238
 2207 1208 A01A0000 		.word	.L253
 2208 120c 2C1A0000 		.word	.L254
 2209 1210 3C1B0000 		.word	.L255
 2210              	.LVL165:
 2211              	.L155:
1209:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2212              		.loc 1 1209 0
 2213 1214 230054E3 		cmp	r4, #35
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2214              		.loc 1 1216 0
 2215 1218 84408490 		addls	r4, r4, r4, asl #1
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2216              		.loc 1 1210 0
 2217 121c 87708780 		addhi	r7, r7, r7, asl #1
 2218              	.LVL166:
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2219              		.loc 1 1216 0
 2220 1220 84618690 		addls	r6, r6, r4, asl #3
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2221              		.loc 1 1210 0
 2222 1224 87618680 		addhi	r6, r6, r7, asl #3
 2223 1228 2C9D9F85 		ldrhi	r9, .L329+76
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2224              		.loc 1 1216 0
 2225 122c 289D9F95 		ldrls	r9, .L329+76
1210:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2226              		.loc 1 1210 0
 2227 1230 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
1211:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2228              		.loc 1 1211 0
 2229 1234 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2230              		.loc 1 1216 0
 2231 1238 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2232              		.loc 1 1217 0
 2233 123c 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2234              		.loc 1 1218 0
 2235 1240 0040A0E3 		mov	r4, #0
1216:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 2236              		.loc 1 1216 0
 2237 1244 1C11C9E5 		strb	r1, [r9, #284]
1217:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2238              		.loc 1 1217 0
 2239 1248 1D21C9E5 		strb	r2, [r9, #285]
1218:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2240              		.loc 1 1218 0
 2241 124c 1E41C9E5 		strb	r4, [r9, #286]
1219:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2242              		.loc 1 1219 0
 2243 1250 1F41C9E5 		strb	r4, [r9, #287]
 2244 1254 ACFFFFEA 		b	.L235
 2245              	.LVL167:
 2246              	.L156:
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2247              		.loc 1 825 0
 2248 1258 FC4C9FE5 		ldr	r4, .L329+76
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2249              		.loc 1 826 0
 2250 125c 00A0A0E3 		mov	sl, #0
 825:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 2251              		.loc 1 825 0
 2252 1260 1C81C4E5 		strb	r8, [r4, #284]
 826:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2253              		.loc 1 826 0
 2254 1264 1DA1C4E5 		strb	sl, [r4, #285]
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2255              		.loc 1 827 0
 2256 1268 471F84E2 		add	r1, r4, #284
 829:../uvc.c      **** 			  break;
 2257              		.loc 1 829 0
 2258 126c FFA0A0E3 		mov	sl, #255
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2259              		.loc 1 827 0
 2260 1270 0200A0E3 		mov	r0, #2
 2261              	.LVL168:
 2262 1274 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2263              	.LVL169:
 829:../uvc.c      **** 			  break;
 2264              		.loc 1 829 0
 2265 1278 0A80A0E1 		mov	r8, sl
 827:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2266              		.loc 1 827 0
 2267 127c 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2268              	.LVL170:
 829:../uvc.c      **** 			  break;
 2269              		.loc 1 829 0
 2270 1280 0A40A0E1 		mov	r4, sl
 2271 1284 77FFFFEA 		b	.L160
 2272              	.LVL171:
 2273              	.L152:
 832:../uvc.c      **** 			 switch(CtrlID)
 2274              		.loc 1 832 0
 2275 1288 260054E3 		cmp	r4, #38
 2276 128c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2277 1290 DB0000EA 		b	.L161
 2278              	.L178:
 2279 1294 60170000 		.word	.L162
 2280 1298 A0160000 		.word	.L163
 2281 129c F4160000 		.word	.L164
 2282 12a0 04160000 		.word	.L161
 2283 12a4 A0150000 		.word	.L165
 2284 12a8 10180000 		.word	.L166
 2285 12ac 04160000 		.word	.L161
 2286 12b0 C8160000 		.word	.L167
 2287 12b4 04160000 		.word	.L161
 2288 12b8 8C170000 		.word	.L168
 2289 12bc 04160000 		.word	.L161
 2290 12c0 D4150000 		.word	.L169
 2291 12c4 04160000 		.word	.L161
 2292 12c8 04160000 		.word	.L161
 2293 12cc 04160000 		.word	.L161
 2294 12d0 04160000 		.word	.L161
 2295 12d4 B4170000 		.word	.L170
 2296 12d8 04160000 		.word	.L161
 2297 12dc 04160000 		.word	.L161
 2298 12e0 04160000 		.word	.L161
 2299 12e4 04160000 		.word	.L161
 2300 12e8 04160000 		.word	.L161
 2301 12ec 04160000 		.word	.L161
 2302 12f0 04160000 		.word	.L161
 2303 12f4 04160000 		.word	.L161
 2304 12f8 34160000 		.word	.L171
 2305 12fc F4160000 		.word	.L164
 2306 1300 1C170000 		.word	.L172
 2307 1304 78150000 		.word	.L173
 2308 1308 04160000 		.word	.L161
 2309 130c 04160000 		.word	.L161
 2310 1310 4C140000 		.word	.L174
 2311 1314 04160000 		.word	.L161
 2312 1318 04160000 		.word	.L161
 2313 131c 04160000 		.word	.L161
 2314 1320 04160000 		.word	.L161
 2315 1324 E8140000 		.word	.L175
 2316 1328 4C150000 		.word	.L176
 2317 132c 28150000 		.word	.L177
 2318              	.L318:
1236:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2319              		.loc 1 1236 0
 2320 1330 230054E3 		cmp	r4, #35
 2321 1334 3100009A 		bls	.L234
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2322              		.loc 1 1237 0
 2323 1338 87A087E0 		add	sl, r7, r7, asl #1
 2324 133c 8A6186E0 		add	r6, r6, sl, asl #3
 2325 1340 149C9FE5 		ldr	r9, .L329+76
 2326 1344 0BC0D6E5 		ldrb	ip, [r6, #11]	@ zero_extendqisi2
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2327              		.loc 1 1238 0
 2328 1348 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
1237:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2329              		.loc 1 1237 0
 2330 134c 1CC1C9E5 		strb	ip, [r9, #284]
1238:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2331              		.loc 1 1238 0
 2332 1350 1D11C9E5 		strb	r1, [r9, #285]
 2333 1354 6CFFFFEA 		b	.L235
 2334              	.L157:
1225:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 2335              		.loc 1 1225 0
 2336 1358 230054E3 		cmp	r4, #35
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2337              		.loc 1 1226 0
 2338 135c 87708780 		addhi	r7, r7, r7, asl #1
 2339              	.LVL172:
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2340              		.loc 1 1229 0
 2341 1360 84408490 		addls	r4, r4, r4, asl #1
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2342              		.loc 1 1226 0
 2343 1364 87618680 		addhi	r6, r6, r7, asl #3
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2344              		.loc 1 1229 0
 2345 1368 84618690 		addls	r6, r6, r4, asl #3
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2346              		.loc 1 1226 0
 2347 136c E88B9F85 		ldrhi	r8, .L329+76
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2348              		.loc 1 1229 0
 2349 1370 E48B9F95 		ldrls	r8, .L329+76
1226:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2350              		.loc 1 1226 0
 2351 1374 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2352              		.loc 1 1229 0
 2353 1378 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2354              		.loc 1 1234 0
 2355 137c FFA0A0E3 		mov	sl, #255
1229:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 2356              		.loc 1 1229 0
 2357 1380 1C31C8E5 		strb	r3, [r8, #284]
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2358              		.loc 1 1231 0
 2359 1384 0100A0E3 		mov	r0, #1
 2360              	.LVL173:
 2361 1388 881B9FE5 		ldr	r1, .L329+8
 2362 138c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2363              	.LVL174:
1234:../uvc.c      **** 			  break;
 2364              		.loc 1 1234 0
 2365 1390 0A40A0E1 		mov	r4, sl
1231:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 2366              		.loc 1 1231 0
 2367 1394 1C71D8E5 		ldrb	r7, [r8, #284]	@ zero_extendqisi2
1234:../uvc.c      **** 			  break;
 2368              		.loc 1 1234 0
 2369 1398 0A80A0E1 		mov	r8, sl
 2370 139c 31FFFFEA 		b	.L160
 2371              	.LVL175:
 2372              	.L224:
1177:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2373              		.loc 1 1177 0
 2374 13a0 0B0054E3 		cmp	r4, #11
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2375              		.loc 1 1184 0
 2376 13a4 84408410 		addne	r4, r4, r4, asl #1
 2377 13a8 84618610 		addne	r6, r6, r4, asl #3
 2378 13ac A89B9F15 		ldrne	r9, .L329+76
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2379              		.loc 1 1178 0
 2380 13b0 A49B9F05 		ldreq	r9, .L329+76
 2381 13b4 603B9F05 		ldreq	r3, .L329+12
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2382              		.loc 1 1184 0
 2383 13b8 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2384              		.loc 1 1185 0
 2385 13bc 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
1178:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2386              		.loc 1 1178 0
 2387 13c0 1C318905 		streq	r3, [r9, #284]
1184:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 2388              		.loc 1 1184 0
 2389 13c4 1C21C915 		strneb	r2, [r9, #284]
1185:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2390              		.loc 1 1185 0
 2391 13c8 1D31C915 		strneb	r3, [r9, #285]
 2392 13cc 4EFFFFEA 		b	.L235
 2393              	.L227:
1195:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2394              		.loc 1 1195 0
 2395 13d0 0B0054E3 		cmp	r4, #11
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2396              		.loc 1 1202 0
 2397 13d4 84408410 		addne	r4, r4, r4, asl #1
 2398 13d8 84618610 		addne	r6, r6, r4, asl #3
 2399 13dc 789B9F15 		ldrne	r9, .L329+76
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2400              		.loc 1 1196 0
 2401 13e0 749B9F05 		ldreq	r9, .L329+76
 2402 13e4 343B9F05 		ldreq	r3, .L329+16
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2403              		.loc 1 1202 0
 2404 13e8 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2405              		.loc 1 1203 0
 2406 13ec 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
1196:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2407              		.loc 1 1196 0
 2408 13f0 1C318905 		streq	r3, [r9, #284]
1202:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 2409              		.loc 1 1202 0
 2410 13f4 1C21C915 		strneb	r2, [r9, #284]
1203:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2411              		.loc 1 1203 0
 2412 13f8 1D31C915 		strneb	r3, [r9, #285]
 2413 13fc 42FFFFEA 		b	.L235
 2414              	.L234:
1240:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 2415              		.loc 1 1240 0
 2416 1400 0B0054E3 		cmp	r4, #11
 2417 1404 0700000A 		beq	.L321
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2418              		.loc 1 1246 0
 2419 1408 849084E0 		add	r9, r4, r4, asl #1
 2420 140c 896186E0 		add	r6, r6, r9, asl #3
 2421 1410 8B21D6E5 		ldrb	r2, [r6, #395]	@ zero_extendqisi2
 2422 1414 409B9FE5 		ldr	r9, .L329+76
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2423              		.loc 1 1247 0
 2424 1418 8C31D6E5 		ldrb	r3, [r6, #396]	@ zero_extendqisi2
1246:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2425              		.loc 1 1246 0
 2426 141c 1C21C9E5 		strb	r2, [r9, #284]
1247:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2427              		.loc 1 1247 0
 2428 1420 1D31C9E5 		strb	r3, [r9, #285]
 2429 1424 38FFFFEA 		b	.L235
 2430              	.L321:
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2431              		.loc 1 1241 0
 2432 1428 2C9B9FE5 		ldr	r9, .L329+76
 2433 142c 9302D6E5 		ldrb	r0, [r6, #659]	@ zero_extendqisi2
 2434              	.LVL176:
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2435              		.loc 1 1243 0
 2436 1430 9472D6E5 		ldrb	r7, [r6, #660]	@ zero_extendqisi2
 2437              	.LVL177:
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2438              		.loc 1 1242 0
 2439 1434 00E0A0E3 		mov	lr, #0
1241:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2440              		.loc 1 1241 0
 2441 1438 1C01C9E5 		strb	r0, [r9, #284]
1242:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2442              		.loc 1 1242 0
 2443 143c 1DE1C9E5 		strb	lr, [r9, #285]
1243:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2444              		.loc 1 1243 0
 2445 1440 1E71C9E5 		strb	r7, [r9, #286]
1244:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2446              		.loc 1 1244 0
 2447 1444 1FE1C9E5 		strb	lr, [r9, #287]
 2448 1448 2FFFFFEA 		b	.L235
 2449              	.LVL178:
 2450              	.L174:
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2451              		.loc 1 947 0 discriminator 1
 2452 144c 000058E3 		cmp	r8, #0
 2453 1450 EC04000A 		beq	.L313
 945:../uvc.c      **** 					 break;
 2454              		.loc 1 945 0
 2455 1454 28E1A0E1 		mov	lr, r8, lsr #2
 2456 1458 00005EE3 		cmp	lr, #0
 2457 145c 03005813 		cmpne	r8, #3
 2458 1460 0020A083 		movhi	r2, #0
 2459 1464 0120A093 		movls	r2, #1
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2460              		.loc 1 791 0
 2461 1468 0E31A0E1 		mov	r3, lr, asl #2
 945:../uvc.c      **** 					 break;
 2462              		.loc 1 945 0
 2463 146c F004009A 		bls	.L293
 2464 1470 A01A9FE5 		ldr	r1, .L329+8
 2465 1474 500041E2 		sub	r0, r1, #80
 2466              	.LVL179:
 2467              	.L197:
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2468              		.loc 1 948 0 discriminator 2
 2469 1478 044090E4 		ldr	r4, [r0], #4
 2470 147c 01A082E2 		add	sl, r2, #1
 2471 1480 FF200AE2 		and	r2, sl, #255
 2472 1484 0E0052E1 		cmp	r2, lr
 2473 1488 044081E4 		str	r4, [r1], #4
 2474 148c F9FFFF3A 		bcc	.L197
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2475              		.loc 1 948 0 is_stmt 0
 2476 1490 030058E1 		cmp	r8, r3
 2477 1494 C00A9F15 		ldrne	r0, .L329+76
 2478 1498 DA04000A 		beq	.L313
 2479              	.L306:
 2480 149c 03C080E0 		add	ip, r0, r3
 2481 14a0 CCE0DCE5 		ldrb	lr, [ip, #204]	@ zero_extendqisi2
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2482              		.loc 1 947 0 is_stmt 1
 2483 14a4 013083E2 		add	r3, r3, #1
 2484 14a8 FF3003E2 		and	r3, r3, #255
 2485              	.LVL180:
 2486 14ac 030058E1 		cmp	r8, r3
 948:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2487              		.loc 1 948 0
 2488 14b0 1CE1CCE5 		strb	lr, [ip, #284]
 947:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 2489              		.loc 1 947 0
 2490 14b4 F8FFFF8A 		bhi	.L306
 2491              	.LVL181:
 2492              	.L180:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2493              		.loc 1 957 0
 2494 14b8 D710D0E5 		ldrb	r1, [r0, #215]	@ zero_extendqisi2
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2495              		.loc 1 950 0
 2496 14bc 983A9FE5 		ldr	r3, .L329+76
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2497              		.loc 1 957 0
 2498 14c0 FF0051E3 		cmp	r1, #255
 950:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 2499              		.loc 1 950 0
 2500 14c4 2571D0E5 		ldrb	r7, [r0, #293]	@ zero_extendqisi2
 2501              	.LVL182:
 951:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2502              		.loc 1 951 0
 2503 14c8 26A1D0E5 		ldrb	sl, [r0, #294]	@ zero_extendqisi2
 2504              	.LVL183:
 957:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 2505              		.loc 1 957 0
 2506 14cc 0F00000A 		beq	.L183
 959:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 2507              		.loc 1 959 0
 2508 14d0 D520D3E5 		ldrb	r2, [r3, #213]	@ zero_extendqisi2
 2509 14d4 481A9FE5 		ldr	r1, .L329+20
 2510 14d8 D630D3E5 		ldrb	r3, [r3, #214]	@ zero_extendqisi2
 2511 14dc 0400A0E3 		mov	r0, #4
 2512 14e0 FEFFFFEB 		bl	CyU3PDebugPrint
 2513 14e4 090000EA 		b	.L183
 2514              	.LVL184:
 2515              	.L175:
 836:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2516              		.loc 1 836 0
 2517 14e8 6C4A9FE5 		ldr	r4, .L329+76
 2518 14ec 6001D4E5 		ldrb	r0, [r4, #352]	@ zero_extendqisi2
 2519              	.LVL185:
 2520 14f0 000050E3 		cmp	r0, #0
 2521 14f4 0004000A 		beq	.L181
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2522              		.loc 1 837 0
 2523 14f8 9DC4D6E5 		ldrb	ip, [r6, #1181]	@ zero_extendqisi2
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2524              		.loc 1 838 0
 2525 14fc 9E14D6E5 		ldrb	r1, [r6, #1182]	@ zero_extendqisi2
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2526              		.loc 1 837 0
 2527 1500 FF700CE2 		and	r7, ip, #255
 2528              	.LVL186:
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2529              		.loc 1 838 0
 2530 1504 FFA001E2 		and	sl, r1, #255
 837:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2531              		.loc 1 837 0
 2532 1508 1C71C4E5 		strb	r7, [r4, #284]
 838:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2533              		.loc 1 838 0
 2534 150c 1DA1C4E5 		strb	sl, [r4, #285]
 2535              	.LVL187:
 2536              	.L183:
1165:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 2537              		.loc 1 1165 0
 2538 1510 0800A0E1 		mov	r0, r8
 2539 1514 FC199FE5 		ldr	r1, .L329+8
 2540 1518 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
1170:../uvc.c      **** 			  break;
 2541              		.loc 1 1170 0
 2542 151c FF40A0E3 		mov	r4, #255
 2543 1520 0480A0E1 		mov	r8, r4
 2544 1524 CFFEFFEA 		b	.L160
 2545              	.LVL188:
 2546              	.L177:
 869:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2547              		.loc 1 869 0
 2548 1528 2C4A9FE5 		ldr	r4, .L329+76
 2549 152c 62B1D4E5 		ldrb	fp, [r4, #354]	@ zero_extendqisi2
 2550 1530 00005BE3 		cmp	fp, #0
 2551 1534 FF03000A 		beq	.L186
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2552              		.loc 1 870 0
 2553 1538 9D70D6E5 		ldrb	r7, [r6, #157]	@ zero_extendqisi2
 2554              	.LVL189:
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2555              		.loc 1 871 0
 2556 153c 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 870:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2557              		.loc 1 870 0
 2558 1540 1C71C4E5 		strb	r7, [r4, #284]
 871:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2559              		.loc 1 871 0
 2560 1544 1DA1C4E5 		strb	sl, [r4, #285]
 2561 1548 F0FFFFEA 		b	.L183
 2562              	.LVL190:
 2563              	.L176:
 851:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 2564              		.loc 1 851 0
 2565 154c 084A9FE5 		ldr	r4, .L329+76
 2566 1550 61E1D4E5 		ldrb	lr, [r4, #353]	@ zero_extendqisi2
 2567 1554 00005EE3 		cmp	lr, #0
 2568 1558 2704000A 		beq	.L184
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2569              		.loc 1 852 0
 2570 155c B1A4D6E5 		ldrb	sl, [r6, #1201]	@ zero_extendqisi2
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2571              		.loc 1 853 0
 2572 1560 B224D6E5 		ldrb	r2, [r6, #1202]	@ zero_extendqisi2
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2573              		.loc 1 852 0
 2574 1564 FF700AE2 		and	r7, sl, #255
 2575              	.LVL191:
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2576              		.loc 1 853 0
 2577 1568 FFA002E2 		and	sl, r2, #255
 852:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2578              		.loc 1 852 0
 2579 156c 1C71C4E5 		strb	r7, [r4, #284]
 853:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2580              		.loc 1 853 0
 2581 1570 1DA1C4E5 		strb	sl, [r4, #285]
 2582 1574 E5FFFFEA 		b	.L183
 2583              	.LVL192:
 2584              	.L173:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2585              		.loc 1 934 0
 2586 1578 DC499FE5 		ldr	r4, .L329+76
 932:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 2587              		.loc 1 932 0
 2588 157c 2D74D6E5 		ldrb	r7, [r6, #1069]	@ zero_extendqisi2
 2589              	.LVL193:
 934:../uvc.c      **** 					 if(CamMode == 1){//720p
 2590              		.loc 1 934 0
 2591 1580 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 2592 1584 010052E3 		cmp	r2, #1
 2593 1588 9004000A 		beq	.L322
 2594              	.LVL194:
 2595              	.L314:
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2596              		.loc 1 1034 0
 2597 158c 0030A0E3 		mov	r3, #0
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2598              		.loc 1 1033 0
 2599 1590 1C71C4E5 		strb	r7, [r4, #284]
1034:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2600              		.loc 1 1034 0
 2601 1594 1D31C4E5 		strb	r3, [r4, #285]
 2602              	.LVL195:
 809:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2603              		.loc 1 809 0
 2604 1598 FFA0A0E3 		mov	sl, #255
1036:../uvc.c      **** 					 break;
 2605              		.loc 1 1036 0
 2606 159c DBFFFFEA 		b	.L183
 2607              	.LVL196:
 2608              	.L165:
1124:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2609              		.loc 1 1124 0
 2610 15a0 B4499FE5 		ldr	r4, .L329+76
 2611 15a4 40E1D4E5 		ldrb	lr, [r4, #320]	@ zero_extendqisi2
 2612 15a8 00005EE3 		cmp	lr, #0
 2613 15ac 4304000A 		beq	.L218
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2614              		.loc 1 1126 0
 2615 15b0 D8C094E5 		ldr	ip, [r4, #216]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2616              		.loc 1 1132 0
 2617 15b4 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1126:../uvc.c      **** 		 	 			 if(is60Hz)
 2618              		.loc 1 1126 0
 2619 15b8 00005CE3 		cmp	ip, #0
1127:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2620              		.loc 1 1127 0
 2621 15bc 02C0A013 		movne	ip, #2
1129:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
 2622              		.loc 1 1129 0
 2623 15c0 01C0A003 		moveq	ip, #1
 2624 15c4 1CC1C4E5 		strb	ip, [r4, #284]
1132:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2625              		.loc 1 1132 0
 2626 15c8 1DA1C4E5 		strb	sl, [r4, #285]
 2627 15cc 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2628              	.LVL197:
 2629 15d0 CEFFFFEA 		b	.L183
 2630              	.LVL198:
 2631              	.L169:
1042:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2632              		.loc 1 1042 0
 2633 15d4 80499FE5 		ldr	r4, .L329+76
 2634 15d8 4721D4E5 		ldrb	r2, [r4, #327]	@ zero_extendqisi2
 2635 15dc 000052E3 		cmp	r2, #0
 2636 15e0 B603000A 		beq	.L208
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2637              		.loc 1 1043 0
 2638 15e4 F474D6E5 		ldrb	r7, [r6, #1268]	@ zero_extendqisi2
 2639              	.LVL199:
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2640              		.loc 1 1044 0
 2641 15e8 F6A4D6E5 		ldrb	sl, [r6, #1270]	@ zero_extendqisi2
1043:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2642              		.loc 1 1043 0
 2643 15ec 1C71C4E5 		strb	r7, [r4, #284]
1044:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2644              		.loc 1 1044 0
 2645 15f0 1EA1C4E5 		strb	sl, [r4, #286]
 2646              	.LVL200:
 2647              	.L209:
1054:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2648              		.loc 1 1054 0
 2649 15f4 00E0A0E3 		mov	lr, #0
 2650 15f8 1DE1C4E5 		strb	lr, [r4, #285]
1055:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2651              		.loc 1 1055 0
 2652 15fc 1FE1C4E5 		strb	lr, [r4, #287]
 2653              	.LVL201:
1058:../uvc.c      **** 					 break;
 2654              		.loc 1 1058 0
 2655 1600 C2FFFFEA 		b	.L183
 2656              	.LVL202:
 2657              	.L161:
1149:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2658              		.loc 1 1149 0
 2659 1604 50B99FE5 		ldr	fp, .L329+76
 2660 1608 04308BE0 		add	r3, fp, r4
 2661 160c 3C21D3E5 		ldrb	r2, [r3, #316]	@ zero_extendqisi2
 2662 1610 000052E3 		cmp	r2, #0
 2663 1614 0F04000A 		beq	.L222
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2664              		.loc 1 1150 0
 2665 1618 844084E0 		add	r4, r4, r4, asl #1
 2666 161c 846186E0 		add	r6, r6, r4, asl #3
 2667 1620 8D71D6E5 		ldrb	r7, [r6, #397]	@ zero_extendqisi2
 2668              	.LVL203:
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2669              		.loc 1 1151 0
 2670 1624 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1150:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 2671              		.loc 1 1150 0
 2672 1628 1C71CBE5 		strb	r7, [fp, #284]
1151:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2673              		.loc 1 1151 0
 2674 162c 1DA1CBE5 		strb	sl, [fp, #285]
 2675 1630 B6FFFFEA 		b	.L183
 2676              	.LVL204:
 2677              	.L171:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2678              		.loc 1 969 0
 2679 1634 20499FE5 		ldr	r4, .L329+76
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2680              		.loc 1 963 0
 2681 1638 E004D6E5 		ldrb	r0, [r6, #1248]	@ zero_extendqisi2
 2682              	.LVL205:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2683              		.loc 1 969 0
 2684 163c 55A1D4E5 		ldrb	sl, [r4, #341]	@ zero_extendqisi2
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2685              		.loc 1 964 0
 2686 1640 E174D6E5 		ldrb	r7, [r6, #1249]	@ zero_extendqisi2
 2687              	.LVL206:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2688              		.loc 1 965 0
 2689 1644 EF24D6E5 		ldrb	r2, [r6, #1263]	@ zero_extendqisi2
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2690              		.loc 1 969 0
 2691 1648 00005AE3 		cmp	sl, #0
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2692              		.loc 1 963 0
 2693 164c 04699FE5 		ldr	r6, .L329+72
 964:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2694              		.loc 1 964 0
 2695 1650 FFA007E2 		and	sl, r7, #255
 963:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2696              		.loc 1 963 0
 2697 1654 FF0000E2 		and	r0, r0, #255
 2698              	.LVL207:
 965:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2699              		.loc 1 965 0
 2700 1658 FF7002E2 		and	r7, r2, #255
 2701              	.LVL208:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2702              		.loc 1 969 0
 2703 165c CF03000A 		beq	.L200
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2704              		.loc 1 970 0
 2705 1660 EDC4D6E5 		ldrb	ip, [r6, #1261]	@ zero_extendqisi2
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2706              		.loc 1 971 0
 2707 1664 EEE4D6E5 		ldrb	lr, [r6, #1262]	@ zero_extendqisi2
 970:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2708              		.loc 1 970 0
 2709 1668 1CC1C4E5 		strb	ip, [r4, #284]
 971:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2710              		.loc 1 971 0
 2711 166c 1EE1C4E5 		strb	lr, [r4, #286]
 2712              	.LVL209:
 2713              	.L201:
 988:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2714              		.loc 1 988 0
 2715 1670 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 2716              	.LVL210:
 989:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 2717              		.loc 1 989 0
 2718 1674 1EA1D4E5 		ldrb	sl, [r4, #286]	@ zero_extendqisi2
 2719              	.LVL211:
 985:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2720              		.loc 1 985 0
 2721 1678 00E0A0E3 		mov	lr, #0
 2722 167c 1DE1C4E5 		strb	lr, [r4, #285]
 987:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2723              		.loc 1 987 0
 2724 1680 1FE1C4E5 		strb	lr, [r4, #287]
 990:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2725              		.loc 1 990 0
 2726 1684 9C189FE5 		ldr	r1, .L329+24
 2727 1688 0720A0E1 		mov	r2, r7
 2728 168c 0E30A0E1 		mov	r3, lr
 2729 1690 0400A0E3 		mov	r0, #4
 2730 1694 00448DE8 		stmia	sp, {sl, lr}	@ phole stm
 2731 1698 FEFFFFEB 		bl	CyU3PDebugPrint
 991:../uvc.c      **** 					 break;
 2732              		.loc 1 991 0
 2733 169c 9BFFFFEA 		b	.L183
 2734              	.LVL212:
 2735              	.L163:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2736              		.loc 1 1007 0
 2737 16a0 B4489FE5 		ldr	r4, .L329+76
 2738 16a4 3D11D4E5 		ldrb	r1, [r4, #317]	@ zero_extendqisi2
 2739 16a8 000051E3 		cmp	r1, #0
1008:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2740              		.loc 1 1008 0
 2741 16ac A501D615 		ldrneb	r0, [r6, #421]	@ zero_extendqisi2
 2742              	.LVL213:
1007:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2743              		.loc 1 1007 0
 2744 16b0 1B04000A 		beq	.L323
 2745              	.LVL214:
 2746              	.L203:
1015:../uvc.c      **** 					  if(Data0&0x80){
 2747              		.loc 1 1015 0
 2748 16b4 800010E3 		tst	r0, #128
1016:../uvc.c      **** 						  Data0 = ~Data0;
 2749              		.loc 1 1016 0
 2750 16b8 0000E011 		mvnne	r0, r0
 2751              	.LVL215:
1018:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 2752              		.loc 1 1018 0
 2753 16bc 80004002 		subeq	r0, r0, #128
 2754 16c0 FF7000E2 		and	r7, r0, #255
 2755              	.LVL216:
 2756 16c4 B0FFFFEA 		b	.L314
 2757              	.LVL217:
 2758              	.L167:
1077:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2759              		.loc 1 1077 0
 2760 16c8 8C489FE5 		ldr	r4, .L329+76
 2761 16cc 4321D4E5 		ldrb	r2, [r4, #323]	@ zero_extendqisi2
 2762 16d0 000052E3 		cmp	r2, #0
 2763 16d4 A503000A 		beq	.L212
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2764              		.loc 1 1078 0
 2765 16d8 19E5D6E5 		ldrb	lr, [r6, #1305]	@ zero_extendqisi2
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2766              		.loc 1 1079 0
 2767 16dc 1A15D6E5 		ldrb	r1, [r6, #1306]	@ zero_extendqisi2
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2768              		.loc 1 1078 0
 2769 16e0 FF700EE2 		and	r7, lr, #255
 2770              	.LVL218:
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2771              		.loc 1 1079 0
 2772 16e4 FFA001E2 		and	sl, r1, #255
1078:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2773              		.loc 1 1078 0
 2774 16e8 1C71C4E5 		strb	r7, [r4, #284]
1079:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2775              		.loc 1 1079 0
 2776 16ec 1DA1C4E5 		strb	sl, [r4, #285]
 2777 16f0 86FFFFEA 		b	.L183
 2778              	.LVL219:
 2779              	.L164:
1094:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2780              		.loc 1 1094 0
 2781 16f4 60B89FE5 		ldr	fp, .L329+76
 2782 16f8 04408BE0 		add	r4, fp, r4
 2783 16fc 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2784              	.LVL220:
 2785 1700 000057E3 		cmp	r7, #0
 2786 1704 C803000A 		beq	.L214
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2787              		.loc 1 1095 0
 2788 1708 BD71D6E5 		ldrb	r7, [r6, #445]	@ zero_extendqisi2
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2789              		.loc 1 1096 0
 2790 170c BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
1095:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 2791              		.loc 1 1095 0
 2792 1710 1C71CBE5 		strb	r7, [fp, #284]
1096:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 2793              		.loc 1 1096 0
 2794 1714 1DA1CBE5 		strb	sl, [fp, #285]
 2795 1718 7CFFFFEA 		b	.L183
 2796              	.LVL221:
 2797              	.L172:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2798              		.loc 1 919 0
 2799 171c 38489FE5 		ldr	r4, .L329+76
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2800              		.loc 1 912 0
 2801 1720 CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2802              		.loc 1 919 0
 2803 1724 5721D4E5 		ldrb	r2, [r4, #343]	@ zero_extendqisi2
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2804              		.loc 1 913 0
 2805 1728 CDE4D6E5 		ldrb	lr, [r6, #1229]	@ zero_extendqisi2
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2806              		.loc 1 914 0
 2807 172c DB14D6E5 		ldrb	r1, [r6, #1243]	@ zero_extendqisi2
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2808              		.loc 1 919 0
 2809 1730 000052E3 		cmp	r2, #0
 912:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2810              		.loc 1 912 0
 2811 1734 1C689FE5 		ldr	r6, .L329+72
 913:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2812              		.loc 1 913 0
 2813 1738 FF000EE2 		and	r0, lr, #255
 2814              	.LVL222:
 914:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2815              		.loc 1 914 0
 2816 173c FF1001E2 		and	r1, r1, #255
 2817              	.LVL223:
 919:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2818              		.loc 1 919 0
 2819 1740 A303000A 		beq	.L192
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2820              		.loc 1 920 0
 2821 1744 D9A4D6E5 		ldrb	sl, [r6, #1241]	@ zero_extendqisi2
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2822              		.loc 1 921 0
 2823 1748 DA34D6E5 		ldrb	r3, [r6, #1242]	@ zero_extendqisi2
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2824              		.loc 1 920 0
 2825 174c FF700AE2 		and	r7, sl, #255
 2826              	.LVL224:
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2827              		.loc 1 921 0
 2828 1750 FFA003E2 		and	sl, r3, #255
 920:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2829              		.loc 1 920 0
 2830 1754 1C71C4E5 		strb	r7, [r4, #284]
 921:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2831              		.loc 1 921 0
 2832 1758 1DA1C4E5 		strb	sl, [r4, #285]
 2833 175c 6BFFFFEA 		b	.L183
 2834              	.LVL225:
 2835              	.L162:
1060:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2836              		.loc 1 1060 0
 2837 1760 F4479FE5 		ldr	r4, .L329+76
 2838 1764 3C71D4E5 		ldrb	r7, [r4, #316]	@ zero_extendqisi2
 2839              	.LVL226:
 2840 1768 000057E3 		cmp	r7, #0
 2841 176c E003000A 		beq	.L210
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2842              		.loc 1 1061 0
 2843 1770 05A5D6E5 		ldrb	sl, [r6, #1285]	@ zero_extendqisi2
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2844              		.loc 1 1062 0
 2845 1774 06C5D6E5 		ldrb	ip, [r6, #1286]	@ zero_extendqisi2
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2846              		.loc 1 1061 0
 2847 1778 FF700AE2 		and	r7, sl, #255
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2848              		.loc 1 1062 0
 2849 177c FFA00CE2 		and	sl, ip, #255
1061:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 2850              		.loc 1 1061 0
 2851 1780 1C71C4E5 		strb	r7, [r4, #284]
1062:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 2852              		.loc 1 1062 0
 2853 1784 1DA1C4E5 		strb	sl, [r4, #285]
 2854 1788 60FFFFEA 		b	.L183
 2855              	.LVL227:
 2856              	.L168:
1107:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2857              		.loc 1 1107 0
 2858 178c C8479FE5 		ldr	r4, .L329+76
 2859 1790 4531D4E5 		ldrb	r3, [r4, #325]	@ zero_extendqisi2
 2860 1794 000053E3 		cmp	r3, #0
 2861 1798 BD03000A 		beq	.L216
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2862              		.loc 1 1109 0
 2863 179c 6522D6E5 		ldrb	r2, [r6, #613]	@ zero_extendqisi2
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2864              		.loc 1 1110 0
 2865 17a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1109:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 2866              		.loc 1 1109 0
 2867 17a4 037002E2 		and	r7, r2, #3
 2868              	.LVL228:
 2869 17a8 1C71C4E5 		strb	r7, [r4, #284]
1110:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 2870              		.loc 1 1110 0
 2871 17ac 1DA1C4E5 		strb	sl, [r4, #285]
 2872 17b0 56FFFFEA 		b	.L183
 2873              	.LVL229:
 2874              	.L170:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2875              		.loc 1 894 0
 2876 17b4 A0479FE5 		ldr	r4, .L329+76
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2877              		.loc 1 887 0
 2878 17b8 B8E4D6E5 		ldrb	lr, [r6, #1208]	@ zero_extendqisi2
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2879              		.loc 1 894 0
 2880 17bc 4C21D4E5 		ldrb	r2, [r4, #332]	@ zero_extendqisi2
 888:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 2881              		.loc 1 888 0
 2882 17c0 B934D6E5 		ldrb	r3, [r6, #1209]	@ zero_extendqisi2
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2883              		.loc 1 889 0
 2884 17c4 C774D6E5 		ldrb	r7, [r6, #1223]	@ zero_extendqisi2
 2885              	.LVL230:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2886              		.loc 1 894 0
 2887 17c8 000052E3 		cmp	r2, #0
 887:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 2888              		.loc 1 887 0
 2889 17cc 84679FE5 		ldr	r6, .L329+72
 2890 17d0 FF000EE2 		and	r0, lr, #255
 2891              	.LVL231:
 889:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 2892              		.loc 1 889 0
 2893 17d4 FF1007E2 		and	r1, r7, #255
 2894              	.LVL232:
 894:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2895              		.loc 1 894 0
 2896 17d8 D803000A 		beq	.L190
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2897              		.loc 1 895 0
 2898 17dc C5A4D6E5 		ldrb	sl, [r6, #1221]	@ zero_extendqisi2
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2899              		.loc 1 896 0
 2900 17e0 C634D6E5 		ldrb	r3, [r6, #1222]	@ zero_extendqisi2
 895:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2901              		.loc 1 895 0
 2902 17e4 FF700AE2 		and	r7, sl, #255
 2903 17e8 1C71C4E5 		strb	r7, [r4, #284]
 896:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2904              		.loc 1 896 0
 2905 17ec 1D31C4E5 		strb	r3, [r4, #285]
 2906              	.LVL233:
 2907              	.L191:
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2908              		.loc 1 909 0
 2909 17f0 34179FE5 		ldr	r1, .L329+28
 2910 17f4 0720A0E1 		mov	r2, r7
 2911 17f8 0730A0E1 		mov	r3, r7
 2912 17fc 0400A0E3 		mov	r0, #4
 2913 1800 00C08DE5 		str	ip, [sp, #0]
 908:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 2914              		.loc 1 908 0
 2915 1804 0CA0A0E1 		mov	sl, ip
 909:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 2916              		.loc 1 909 0
 2917 1808 FEFFFFEB 		bl	CyU3PDebugPrint
 2918              	.LVL234:
 910:../uvc.c      **** 			 		 break;
 2919              		.loc 1 910 0
 2920 180c 3FFFFFEA 		b	.L183
 2921              	.LVL235:
 2922              	.L166:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2923              		.loc 1 1025 0
 2924 1810 44479FE5 		ldr	r4, .L329+76
 2925 1814 41C1D4E5 		ldrb	ip, [r4, #321]	@ zero_extendqisi2
 2926 1818 00005CE3 		cmp	ip, #0
1026:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 2927              		.loc 1 1026 0
 2928 181c 0502D615 		ldrneb	r0, [r6, #517]	@ zero_extendqisi2
 2929              	.LVL236:
1025:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 2930              		.loc 1 1025 0
 2931 1820 B002000A 		beq	.L324
 2932              	.L207:
 2933              	.LVL237:
1033:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 2934              		.loc 1 1033 0
 2935 1824 800040E2 		sub	r0, r0, #128
 2936              	.LVL238:
 2937 1828 FF7000E2 		and	r7, r0, #255
 2938              	.LVL239:
 2939 182c 56FFFFEA 		b	.L314
 2940              	.LVL240:
 2941              	.L252:
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2942              		.loc 1 1416 0 discriminator 1
 2943 1830 000058E3 		cmp	r8, #0
 2944 1834 1800000A 		beq	.L258
1414:../uvc.c      **** 							 break;
 2945              		.loc 1 1414 0
 2946 1838 28E1A0E1 		mov	lr, r8, lsr #2
 2947 183c 00005EE3 		cmp	lr, #0
 2948 1840 03005813 		cmpne	r8, #3
 2949 1844 0020A083 		movhi	r2, #0
 2950 1848 0120A093 		movls	r2, #1
 2951              	.LVL241:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2952              		.loc 1 791 0
 2953 184c 0E31A0E1 		mov	r3, lr, asl #2
1414:../uvc.c      **** 							 break;
 2954              		.loc 1 1414 0
 2955 1850 FA03009A 		bls	.L295
 2956 1854 D4169FE5 		ldr	r1, .L329+32
 2957 1858 500081E2 		add	r0, r1, #80
 2958              	.LVL242:
 2959              	.L268:
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2960              		.loc 1 1417 0 discriminator 2
 2961 185c 047090E4 		ldr	r7, [r0], #4
 2962 1860 012082E2 		add	r2, r2, #1
 2963 1864 FF2002E2 		and	r2, r2, #255
 2964 1868 02005EE1 		cmp	lr, r2
 2965 186c 047081E4 		str	r7, [r1], #4
 2966 1870 F9FFFF8A 		bhi	.L268
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2967              		.loc 1 1417 0 is_stmt 0
 2968 1874 030058E1 		cmp	r8, r3
 2969 1878 0700000A 		beq	.L258
 2970              	.L307:
 2971 187c D8069FE5 		ldr	r0, .L329+76
 2972 1880 03E080E0 		add	lr, r0, r3
 2973 1884 1C11DEE5 		ldrb	r1, [lr, #284]	@ zero_extendqisi2
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2974              		.loc 1 1416 0 is_stmt 1
 2975 1888 013083E2 		add	r3, r3, #1
 2976 188c FF3003E2 		and	r3, r3, #255
 2977              	.LVL243:
 2978 1890 030058E1 		cmp	r8, r3
1417:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2979              		.loc 1 1417 0
 2980 1894 CC10CEE5 		strb	r1, [lr, #204]
1416:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2981              		.loc 1 1416 0
 2982 1898 F7FFFF8A 		bhi	.L307
 2983              	.LVL244:
 2984              	.L258:
1420:../uvc.c      **** 							 break;
 2985              		.loc 1 1420 0
 2986 189c FFA0A0E3 		mov	sl, #255
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2987              		.loc 1 1419 0
 2988 18a0 FEFFFFEB 		bl	I2CCmdHandler
 2989              	.LVL245:
1420:../uvc.c      **** 							 break;
 2990              		.loc 1 1420 0
 2991 18a4 0A70A0E1 		mov	r7, sl
1419:../uvc.c      **** 					 		I2CCmdHandler();
 2992              		.loc 1 1419 0
 2993 18a8 18809DE5 		ldr	r8, [sp, #24]
 2994 18ac 1C409DE5 		ldr	r4, [sp, #28]
1420:../uvc.c      **** 							 break;
 2995              		.loc 1 1420 0
 2996 18b0 ECFDFFEA 		b	.L160
 2997              	.LVL246:
 2998              	.L251:
1410:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2999              		.loc 1 1410 0
 3000 18b4 94769FE5 		ldr	r7, .L329+64
 3001              	.LVL247:
 3002 18b8 0010E0E3 		mvn	r1, #0
 3003 18bc 1C0097E5 		ldr	r0, [r7, #28]
 3004 18c0 FEFFFFEB 		bl	_txe_mutex_get
 3005              	.LVL248:
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3006              		.loc 1 1411 0
 3007 18c4 0A20A0E1 		mov	r2, sl
 3008 18c8 18A09DE5 		ldr	sl, [sp, #24]
 3009 18cc 00C0A0E3 		mov	ip, #0
 3010 18d0 01407AE2 		rsbs	r4, sl, #1
 3011 18d4 0040A033 		movcc	r4, #0
 3012 18d8 1E10A0E3 		mov	r1, #30
 3013 18dc 0930A0E1 		mov	r3, r9
 3014 18e0 0700A0E1 		mov	r0, r7
 3015 18e4 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3016 18e8 FEFFFFEB 		bl	cmdSet
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3017              		.loc 1 1412 0
 3018 18ec 1C0097E5 		ldr	r0, [r7, #28]
 3019 18f0 FEFFFFEB 		bl	_txe_mutex_put
1414:../uvc.c      **** 							 break;
 3020              		.loc 1 1414 0
 3021 18f4 FFA0A0E3 		mov	sl, #255
1413:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3022              		.loc 1 1413 0
 3023 18f8 0100A0E3 		mov	r0, #1
 3024 18fc 6004C6E5 		strb	r0, [r6, #1120]
 3025 1900 18809DE5 		ldr	r8, [sp, #24]
 3026 1904 1C409DE5 		ldr	r4, [sp, #28]
1414:../uvc.c      **** 							 break;
 3027              		.loc 1 1414 0
 3028 1908 0A70A0E1 		mov	r7, sl
 3029 190c D5FDFFEA 		b	.L160
 3030              	.LVL249:
 3031              	.L250:
1388:../uvc.c      **** 							 if(Data0 <= 3){
 3032              		.loc 1 1388 0
 3033 1910 030053E3 		cmp	r3, #3
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3034              		.loc 1 1389 0
 3035 1914 40069F95 		ldrls	r0, .L329+76
 3036 1918 03E0A0E1 		mov	lr, r3
 3037              	.LVL250:
 3038 191c 0030A093 		movls	r3, #0
 3039 1920 7C31C095 		strlsb	r3, [r0, #380]
 3040              	.LVL251:
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3041              		.loc 1 1392 0
 3042 1924 30C69F85 		ldrhi	ip, .L329+76
1389:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 3043              		.loc 1 1389 0
 3044 1928 0E30A091 		movls	r3, lr
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3045              		.loc 1 1398 0
 3046 192c 1C469FE5 		ldr	r4, .L329+64
 3047 1930 18E09D95 		ldrls	lr, [sp, #24]
1393:../uvc.c      **** 								 Data1 = Data0-4;
 3048              		.loc 1 1393 0
 3049 1934 04304382 		subhi	r3, r3, #4
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3050              		.loc 1 1392 0
 3051 1938 0120A083 		movhi	r2, #1
 3052              	.LVL252:
1396:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 3053              		.loc 1 1396 0
 3054 193c 8D31C6E5 		strb	r3, [r6, #397]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3055              		.loc 1 1397 0
 3056 1940 0130A0E3 		mov	r3, #1
1392:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 3057              		.loc 1 1392 0
 3058 1944 7C21CC85 		strhib	r2, [ip, #380]
 3059              	.LVL253:
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3060              		.loc 1 1398 0
 3061 1948 0010E0E3 		mvn	r1, #0
1395:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3062              		.loc 1 1395 0
 3063 194c 2DE4C6E5 		strb	lr, [r6, #1069]
1397:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3064              		.loc 1 1397 0
 3065 1950 3034C6E5 		strb	r3, [r6, #1072]
1398:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3066              		.loc 1 1398 0
 3067 1954 1C0094E5 		ldr	r0, [r4, #28]
 3068 1958 FEFFFFEB 		bl	_txe_mutex_get
1399:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3069              		.loc 1 1399 0
 3070 195c 18809DE5 		ldr	r8, [sp, #24]
 3071 1960 0A20A0E1 		mov	r2, sl
 3072 1964 1C10A0E3 		mov	r1, #28
 3073 1968 0930A0E1 		mov	r3, r9
 3074 196c 0400A0E1 		mov	r0, r4
 3075 1970 00A0A0E3 		mov	sl, #0
 3076 1974 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3077 1978 FEFFFFEB 		bl	cmdSet
1400:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3078              		.loc 1 1400 0
 3079 197c 1C0094E5 		ldr	r0, [r4, #28]
 3080              	.LVL254:
 3081              	.L316:
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3082              		.loc 1 1666 0
 3083 1980 FFA0A0E3 		mov	sl, #255
 3084 1984 FEFFFFEB 		bl	_txe_mutex_put
 3085 1988 0A70A0E1 		mov	r7, sl
 3086 198c 18809DE5 		ldr	r8, [sp, #24]
 3087 1990 1C409DE5 		ldr	r4, [sp, #28]
 3088 1994 B3FDFFEA 		b	.L160
 3089              	.LVL255:
 3090              	.L249:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3091              		.loc 1 1365 0
 3092 1998 B0459FE5 		ldr	r4, .L329+64
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3093              		.loc 1 1361 0
 3094 199c CC34D6E5 		ldrb	r3, [r6, #1228]	@ zero_extendqisi2
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3095              		.loc 1 1362 0
 3096 19a0 CD74D6E5 		ldrb	r7, [r6, #1229]	@ zero_extendqisi2
 3097              	.LVL256:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3098              		.loc 1 1363 0
 3099 19a4 DBE4D6E5 		ldrb	lr, [r6, #1243]	@ zero_extendqisi2
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3100              		.loc 1 1365 0
 3101 19a8 0010E0E3 		mvn	r1, #0
 3102 19ac 1C0094E5 		ldr	r0, [r4, #28]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3103              		.loc 1 1361 0
 3104 19b0 FFA003E2 		and	sl, r3, #255
 3105              	.LVL257:
1362:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3106              		.loc 1 1362 0
 3107 19b4 FF8007E2 		and	r8, r7, #255
 3108              	.LVL258:
1363:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 3109              		.loc 1 1363 0
 3110 19b8 FF700EE2 		and	r7, lr, #255
 3111              	.LVL259:
1365:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3112              		.loc 1 1365 0
 3113 19bc FEFFFFEB 		bl	_txe_mutex_get
 3114              	.LVL260:
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3115              		.loc 1 1373 0
 3116 19c0 D904D6E5 		ldrb	r0, [r6, #1241]	@ zero_extendqisi2
 3117 19c4 18109DE5 		ldr	r1, [sp, #24]
1361:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3118              		.loc 1 1361 0
 3119 19c8 88359FE5 		ldr	r3, .L329+72
1373:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
 3120              		.loc 1 1373 0
 3121 19cc 000051E1 		cmp	r1, r0
 3122 19d0 0600000A 		beq	.L263
1374:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 3123              		.loc 1 1374 0
 3124 19d4 D914C3E5 		strb	r1, [r3, #1241]
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3125              		.loc 1 1375 0
 3126 19d8 ED24D3E5 		ldrb	r2, [r3, #1261]	@ zero_extendqisi2
 3127 19dc 010052E3 		cmp	r2, #1
 3128 19e0 6803000A 		beq	.L264
1375:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 3129              		.loc 1 1375 0 is_stmt 0 discriminator 1
 3130 19e4 ED14D3E5 		ldrb	r1, [r3, #1261]	@ zero_extendqisi2
 3131 19e8 030051E3 		cmp	r1, #3
 3132 19ec 6503000A 		beq	.L264
 3133              	.LVL261:
 3134              	.L263:
1382:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3135              		.loc 1 1382 0 is_stmt 1
 3136 19f0 1C0094E5 		ldr	r0, [r4, #28]
 3137 19f4 FEFFFFEB 		bl	_txe_mutex_put
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3138              		.loc 1 1384 0
 3139 19f8 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3140              		.loc 1 1383 0
 3141 19fc 18809DE5 		ldr	r8, [sp, #24]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3142              		.loc 1 1384 0
 3143 1a00 EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3144              		.loc 1 1383 0
 3145 1a04 1C409DE5 		ldr	r4, [sp, #28]
1384:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 3146              		.loc 1 1384 0
 3147 1a08 D974D6E5 		ldrb	r7, [r6, #1241]	@ zero_extendqisi2
 3148              	.LVL262:
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3149              		.loc 1 1383 0
 3150 1a0c 0400A0E3 		mov	r0, #4
 3151 1a10 1C159FE5 		ldr	r1, .L329+36
1385:../uvc.c      **** 							 break;
 3152              		.loc 1 1385 0
 3153 1a14 FFA0A0E3 		mov	sl, #255
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3154              		.loc 1 1383 0
 3155 1a18 80018DE8 		stmia	sp, {r7, r8}	@ phole stm
 3156 1a1c 08408DE5 		str	r4, [sp, #8]
1385:../uvc.c      **** 							 break;
 3157              		.loc 1 1385 0
 3158 1a20 0A70A0E1 		mov	r7, sl
1383:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3159              		.loc 1 1383 0
 3160 1a24 FEFFFFEB 		bl	CyU3PDebugPrint
1385:../uvc.c      **** 							 break;
 3161              		.loc 1 1385 0
 3162 1a28 8EFDFFEA 		b	.L160
 3163              	.LVL263:
 3164              	.L254:
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3165              		.loc 1 1462 0
 3166 1a2c A4C4D6E5 		ldrb	ip, [r6, #1188]	@ zero_extendqisi2
 3167              	.LVL264:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3168              		.loc 1 1467 0
 3169 1a30 18A59FE5 		ldr	sl, .L329+64
1463:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3170              		.loc 1 1463 0
 3171 1a34 A534D6E5 		ldrb	r3, [r6, #1189]	@ zero_extendqisi2
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3172              		.loc 1 1464 0
 3173 1a38 B3E4D6E5 		ldrb	lr, [r6, #1203]	@ zero_extendqisi2
1462:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3174              		.loc 1 1462 0
 3175 1a3c FF800CE2 		and	r8, ip, #255
 3176              	.LVL265:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3177              		.loc 1 1467 0
 3178 1a40 0010E0E3 		mvn	r1, #0
 3179 1a44 1C009AE5 		ldr	r0, [sl, #28]
1464:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3180              		.loc 1 1464 0
 3181 1a48 FF400EE2 		and	r4, lr, #255
 3182              	.LVL266:
1467:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3183              		.loc 1 1467 0
 3184 1a4c FEFFFFEB 		bl	_txe_mutex_get
 3185              	.LVL267:
1468:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3186              		.loc 1 1468 0
 3187 1a50 0820A0E1 		mov	r2, r8
 3188 1a54 18809DE5 		ldr	r8, [sp, #24]
 3189              	.LVL268:
 3190 1a58 0430A0E1 		mov	r3, r4
 3191 1a5c 2510A0E3 		mov	r1, #37
 3192 1a60 0A00A0E1 		mov	r0, sl
 3193 1a64 0070A0E3 		mov	r7, #0
 3194              	.LVL269:
 3195 1a68 00808DE5 		str	r8, [sp, #0]
 3196 1a6c 04708DE5 		str	r7, [sp, #4]
 3197 1a70 FEFFFFEB 		bl	cmdSet
 3198              	.LVL270:
1469:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3199              		.loc 1 1469 0
 3200 1a74 1C009AE5 		ldr	r0, [sl, #28]
 3201 1a78 FEFFFFEB 		bl	_txe_mutex_put
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3202              		.loc 1 1470 0
 3203 1a7c 18409DE5 		ldr	r4, [sp, #24]
 3204              	.LVL271:
1474:../uvc.c      **** 							 break;
 3205              		.loc 1 1474 0
 3206 1a80 FFA0A0E3 		mov	sl, #255
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3207              		.loc 1 1471 0
 3208 1a84 0100A0E3 		mov	r0, #1
1470:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3209              		.loc 1 1470 0
 3210 1a88 B144C6E5 		strb	r4, [r6, #1201]
1471:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3211              		.loc 1 1471 0
 3212 1a8c 0480A0E1 		mov	r8, r4
 3213 1a90 B504C6E5 		strb	r0, [r6, #1205]
 3214 1a94 1C409DE5 		ldr	r4, [sp, #28]
1474:../uvc.c      **** 							 break;
 3215              		.loc 1 1474 0
 3216 1a98 0A70A0E1 		mov	r7, sl
 3217 1a9c 71FDFFEA 		b	.L160
 3218              	.LVL272:
 3219              	.L253:
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3220              		.loc 1 1422 0
 3221 1aa0 9034D6E5 		ldrb	r3, [r6, #1168]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3222              		.loc 1 1449 0
 3223 1aa4 A4449FE5 		ldr	r4, .L329+64
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3224              		.loc 1 1423 0
 3225 1aa8 9124D6E5 		ldrb	r2, [r6, #1169]	@ zero_extendqisi2
 3226              	.LVL273:
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3227              		.loc 1 1424 0
 3228 1aac 9F14D6E5 		ldrb	r1, [r6, #1183]	@ zero_extendqisi2
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3229              		.loc 1 1449 0
 3230 1ab0 1C0094E5 		ldr	r0, [r4, #28]
1424:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3231              		.loc 1 1424 0
 3232 1ab4 FF7001E2 		and	r7, r1, #255
 3233              	.LVL274:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3234              		.loc 1 1449 0
 3235 1ab8 0010E0E3 		mvn	r1, #0
1422:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3236              		.loc 1 1422 0
 3237 1abc FF9003E2 		and	r9, r3, #255
 3238              	.LVL275:
1423:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3239              		.loc 1 1423 0
 3240 1ac0 FF8002E2 		and	r8, r2, #255
 3241              	.LVL276:
1449:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3242              		.loc 1 1449 0
 3243 1ac4 14C08DE5 		str	ip, [sp, #20]
 3244 1ac8 FEFFFFEB 		bl	_txe_mutex_get
 3245              	.LVL277:
1451:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 3246              		.loc 1 1451 0
 3247 1acc 18C09DE5 		ldr	ip, [sp, #24]
 3248 1ad0 00E0A0E3 		mov	lr, #0
 3249 1ad4 0920A0E1 		mov	r2, r9
 3250 1ad8 0730A0E1 		mov	r3, r7
 3251 1adc 2410A0E3 		mov	r1, #36
 3252 1ae0 0400A0E1 		mov	r0, r4
 3253 1ae4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3254 1ae8 FEFFFFEB 		bl	cmdSet
 3255              	.LVL278:
1453:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 3256              		.loc 1 1453 0
 3257 1aec 14A09DE5 		ldr	sl, [sp, #20]
 3258 1af0 0820A0E1 		mov	r2, r8
 3259 1af4 0730A0E1 		mov	r3, r7
 3260 1af8 0190A0E3 		mov	r9, #1
 3261              	.LVL279:
 3262 1afc 2410A0E3 		mov	r1, #36
 3263 1b00 0400A0E1 		mov	r0, r4
 3264 1b04 00A08DE5 		str	sl, [sp, #0]
 3265 1b08 04908DE5 		str	r9, [sp, #4]
 3266 1b0c FEFFFFEB 		bl	cmdSet
1454:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3267              		.loc 1 1454 0
 3268 1b10 1C0094E5 		ldr	r0, [r4, #28]
 3269 1b14 FEFFFFEB 		bl	_txe_mutex_put
 3270              	.LVL280:
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3271              		.loc 1 1457 0
 3272 1b18 18809DE5 		ldr	r8, [sp, #24]
 3273              	.LVL281:
1460:../uvc.c      **** 							 break;
 3274              		.loc 1 1460 0
 3275 1b1c FFA0A0E3 		mov	sl, #255
1457:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
 3276              		.loc 1 1457 0
 3277 1b20 9D84C6E5 		strb	r8, [r6, #1181]
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3278              		.loc 1 1458 0
 3279 1b24 14C09DE5 		ldr	ip, [sp, #20]
1460:../uvc.c      **** 							 break;
 3280              		.loc 1 1460 0
 3281 1b28 0A70A0E1 		mov	r7, sl
 3282              	.LVL282:
1458:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3283              		.loc 1 1458 0
 3284 1b2c 9EC4C6E5 		strb	ip, [r6, #1182]
1459:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3285              		.loc 1 1459 0
 3286 1b30 0C40A0E1 		mov	r4, ip
 3287 1b34 A194C6E5 		strb	r9, [r6, #1185]
1460:../uvc.c      **** 							 break;
 3288              		.loc 1 1460 0
 3289 1b38 4AFDFFEA 		b	.L160
 3290              	.LVL283:
 3291              	.L255:
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3292              		.loc 1 1477 0
 3293 1b3c 8780A0E1 		mov	r8, r7, asl #1
 3294 1b40 10B49FE5 		ldr	fp, .L329+72
 3295 1b44 07C088E0 		add	ip, r8, r7
 3296              	.LVL284:
 3297 1b48 8CE186E0 		add	lr, r6, ip, asl #3
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3298              		.loc 1 1483 0
 3299 1b4c FC439FE5 		ldr	r4, .L329+64
1477:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 3300              		.loc 1 1477 0
 3301 1b50 0D30CEE5 		strb	r3, [lr, #13]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3302              		.loc 1 1479 0
 3303 1b54 05B5DBE5 		ldrb	fp, [fp, #1285]	@ zero_extendqisi2
1478:../uvc.c      **** 							 if(Data0 == 1){
 3304              		.loc 1 1478 0
 3305 1b58 010053E3 		cmp	r3, #1
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3306              		.loc 1 1483 0
 3307 1b5c 0010E0E3 		mvn	r1, #0
 3308 1b60 1C0094E5 		ldr	r0, [r4, #28]
1479:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3309              		.loc 1 1479 0
 3310 1b64 80B08B03 		orreq	fp, fp, #128
 3311              	.LVL285:
1481:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
 3312              		.loc 1 1481 0
 3313 1b68 7FB00B12 		andne	fp, fp, #127
 3314              	.LVL286:
1483:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3315              		.loc 1 1483 0
 3316 1b6c FEFFFFEB 		bl	_txe_mutex_get
 3317              	.LVL287:
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3318              		.loc 1 1484 0
 3319 1b70 0A20A0E1 		mov	r2, sl
 3320 1b74 2610A0E3 		mov	r1, #38
 3321 1b78 0930A0E1 		mov	r3, r9
 3322 1b7c 0400A0E1 		mov	r0, r4
 3323 1b80 00A0A0E3 		mov	sl, #0
 3324 1b84 04A08DE5 		str	sl, [sp, #4]
 3325 1b88 00B08DE5 		str	fp, [sp, #0]
 3326 1b8c FEFFFFEB 		bl	cmdSet
1485:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3327              		.loc 1 1485 0
 3328 1b90 1C0094E5 		ldr	r0, [r4, #28]
 3329 1b94 FEFFFFEB 		bl	_txe_mutex_put
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3330              		.loc 1 1487 0
 3331 1b98 071088E0 		add	r1, r8, r7
 3332 1b9c 816186E0 		add	r6, r6, r1, asl #3
1488:../uvc.c      **** 							 break;
 3333              		.loc 1 1488 0
 3334 1ba0 FFA0A0E3 		mov	sl, #255
1487:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3335              		.loc 1 1487 0
 3336 1ba4 0120A0E3 		mov	r2, #1
 3337 1ba8 1020C6E5 		strb	r2, [r6, #16]
 3338 1bac 18809DE5 		ldr	r8, [sp, #24]
 3339 1bb0 1C409DE5 		ldr	r4, [sp, #28]
1488:../uvc.c      **** 							 break;
 3340              		.loc 1 1488 0
 3341 1bb4 0A70A0E1 		mov	r7, sl
 3342              	.LVL288:
 3343 1bb8 2AFDFFEA 		b	.L160
 3344              	.LVL289:
 3345              	.L244:
1551:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3346              		.loc 1 1551 0
 3347 1bbc 8C439FE5 		ldr	r4, .L329+64
 3348 1bc0 0010E0E3 		mvn	r1, #0
 3349 1bc4 1C0094E5 		ldr	r0, [r4, #28]
 3350 1bc8 FEFFFFEB 		bl	_txe_mutex_get
 3351              	.LVL290:
1552:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3352              		.loc 1 1552 0
 3353 1bcc 18C09DE5 		ldr	ip, [sp, #24]
 3354 1bd0 00E0A0E3 		mov	lr, #0
 3355 1bd4 0A20A0E1 		mov	r2, sl
 3356 1bd8 0610A0E3 		mov	r1, #6
 3357 1bdc 0930A0E1 		mov	r3, r9
 3358 1be0 0400A0E1 		mov	r0, r4
 3359 1be4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3360 1be8 FEFFFFEB 		bl	cmdSet
 3361              	.LVL291:
1554:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 3362              		.loc 1 1554 0
 3363 1bec 18A09DE5 		ldr	sl, [sp, #24]
 3364 1bf0 0170A0E3 		mov	r7, #1
 3365              	.LVL292:
 3366 1bf4 0610A0E3 		mov	r1, #6
 3367 1bf8 0B20A0E1 		mov	r2, fp
 3368 1bfc 0930A0E1 		mov	r3, r9
 3369 1c00 0400A0E1 		mov	r0, r4
 3370 1c04 00A08DE5 		str	sl, [sp, #0]
 3371 1c08 04708DE5 		str	r7, [sp, #4]
 3372 1c0c FEFFFFEB 		bl	cmdSet
1555:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3373              		.loc 1 1555 0
 3374 1c10 1C0094E5 		ldr	r0, [r4, #28]
 3375 1c14 FEFFFFEB 		bl	_txe_mutex_put
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3376              		.loc 1 1556 0
 3377 1c18 18809DE5 		ldr	r8, [sp, #24]
1558:../uvc.c      **** 							 break;
 3378              		.loc 1 1558 0
 3379 1c1c FFA0A0E3 		mov	sl, #255
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3380              		.loc 1 1557 0
 3381 1c20 2072C6E5 		strb	r7, [r6, #544]
1556:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3382              		.loc 1 1556 0
 3383 1c24 1D82C6E5 		strb	r8, [r6, #541]
1557:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3384              		.loc 1 1557 0
 3385 1c28 1C409DE5 		ldr	r4, [sp, #28]
1558:../uvc.c      **** 							 break;
 3386              		.loc 1 1558 0
 3387 1c2c 0A70A0E1 		mov	r7, sl
 3388 1c30 0CFDFFEA 		b	.L160
 3389              	.LVL293:
 3390              	.L243:
1531:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3391              		.loc 1 1531 0
 3392 1c34 14839FE5 		ldr	r8, .L329+64
 3393 1c38 0010E0E3 		mvn	r1, #0
 3394 1c3c 1C0098E5 		ldr	r0, [r8, #28]
 3395 1c40 FEFFFFEB 		bl	_txe_mutex_get
 3396              	.LVL294:
1532:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3397              		.loc 1 1532 0
 3398 1c44 18209DE5 		ldr	r2, [sp, #24]
 3399 1c48 00C0A0E3 		mov	ip, #0
 3400 1c4c 803042E2 		sub	r3, r2, #128
 3401 1c50 FF4003E2 		and	r4, r3, #255
 3402 1c54 0A20A0E1 		mov	r2, sl
 3403 1c58 0510A0E3 		mov	r1, #5
 3404 1c5c 0930A0E1 		mov	r3, r9
 3405 1c60 0800A0E1 		mov	r0, r8
 3406 1c64 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3407 1c68 FEFFFFEB 		bl	cmdSet
 3408              	.LVL295:
1534:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 3409              		.loc 1 1534 0
 3410 1c6c 18A09DE5 		ldr	sl, [sp, #24]
 3411 1c70 0510A0E3 		mov	r1, #5
 3412 1c74 76704AE2 		sub	r7, sl, #118
 3413              	.LVL296:
 3414 1c78 FFE007E2 		and	lr, r7, #255
 3415 1c7c DC20A0E3 		mov	r2, #220
 3416 1c80 0170A0E3 		mov	r7, #1
 3417 1c84 0930A0E1 		mov	r3, r9
 3418 1c88 0800A0E1 		mov	r0, r8
 3419 1c8c 00E08DE5 		str	lr, [sp, #0]
 3420 1c90 04708DE5 		str	r7, [sp, #4]
 3421 1c94 FEFFFFEB 		bl	cmdSet
 3422              	.LVL297:
1536:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 3423              		.loc 1 1536 0
 3424 1c98 18009DE5 		ldr	r0, [sp, #24]
 3425 1c9c 02C0A0E3 		mov	ip, #2
 3426 1ca0 7E1080E2 		add	r1, r0, #126
 3427 1ca4 FF4001E2 		and	r4, r1, #255
 3428 1ca8 DE20A0E3 		mov	r2, #222
 3429 1cac 0510A0E3 		mov	r1, #5
 3430 1cb0 0930A0E1 		mov	r3, r9
 3431 1cb4 0800A0E1 		mov	r0, r8
 3432 1cb8 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 3433 1cbc FEFFFFEB 		bl	cmdSet
 3434              	.LVL298:
1538:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 3435              		.loc 1 1538 0
 3436 1cc0 18209DE5 		ldr	r2, [sp, #24]
 3437 1cc4 0510A0E3 		mov	r1, #5
 3438 1cc8 723082E2 		add	r3, r2, #114
 3439 1ccc FFA003E2 		and	sl, r3, #255
 3440 1cd0 E020A0E3 		mov	r2, #224
 3441 1cd4 0930A0E1 		mov	r3, r9
 3442 1cd8 0800A0E1 		mov	r0, r8
 3443 1cdc 0340A0E3 		mov	r4, #3
 3444 1ce0 00A08DE5 		str	sl, [sp, #0]
 3445 1ce4 04408DE5 		str	r4, [sp, #4]
 3446 1ce8 FEFFFFEB 		bl	cmdSet
 3447              	.LVL299:
1540:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 3448              		.loc 1 1540 0
 3449 1cec 18009DE5 		ldr	r0, [sp, #24]
 3450 1cf0 DD20A0E3 		mov	r2, #221
 3451 1cf4 6F1040E2 		sub	r1, r0, #111
 3452 1cf8 FFC001E2 		and	ip, r1, #255
 3453 1cfc 0930A0E1 		mov	r3, r9
 3454 1d00 0510A0E3 		mov	r1, #5
 3455 1d04 0800A0E1 		mov	r0, r8
 3456 1d08 04A0A0E3 		mov	sl, #4
 3457 1d0c 00C08DE5 		str	ip, [sp, #0]
 3458 1d10 04A08DE5 		str	sl, [sp, #4]
 3459 1d14 FEFFFFEB 		bl	cmdSet
 3460              	.LVL300:
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3461              		.loc 1 1542 0
 3462 1d18 3C229FE5 		ldr	r2, .L329+76
 3463 1d1c 05E0A0E3 		mov	lr, #5
 3464 1d20 1C41D2E5 		ldrb	r4, [r2, #284]	@ zero_extendqisi2
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3465              		.loc 1 1545 0
 3466 1d24 30A29FE5 		ldr	sl, .L329+76
1542:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 3467              		.loc 1 1542 0
 3468 1d28 7F3084E2 		add	r3, r4, #127
 3469 1d2c FFC003E2 		and	ip, r3, #255
 3470 1d30 0E10A0E1 		mov	r1, lr
 3471 1d34 0B20A0E1 		mov	r2, fp
 3472 1d38 0930A0E1 		mov	r3, r9
 3473 1d3c 0800A0E1 		mov	r0, r8
 3474 1d40 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 3475 1d44 FEFFFFEB 		bl	cmdSet
1543:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3476              		.loc 1 1543 0
 3477 1d48 1C0098E5 		ldr	r0, [r8, #28]
 3478 1d4c FEFFFFEB 		bl	_txe_mutex_put
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3479              		.loc 1 1545 0
 3480 1d50 1C01DAE5 		ldrb	r0, [sl, #284]	@ zero_extendqisi2
1547:../uvc.c      **** 							 break;
 3481              		.loc 1 1547 0
 3482 1d54 FFA0A0E3 		mov	sl, #255
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3483              		.loc 1 1545 0
 3484 1d58 801040E2 		sub	r1, r0, #128
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3485              		.loc 1 1546 0
 3486 1d5c 0872C6E5 		strb	r7, [r6, #520]
1545:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 3487              		.loc 1 1545 0
 3488 1d60 0512C6E5 		strb	r1, [r6, #517]
1546:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3489              		.loc 1 1546 0
 3490 1d64 18809DE5 		ldr	r8, [sp, #24]
 3491 1d68 1C409DE5 		ldr	r4, [sp, #28]
1547:../uvc.c      **** 							 break;
 3492              		.loc 1 1547 0
 3493 1d6c 0A70A0E1 		mov	r7, sl
 3494 1d70 BCFCFFEA 		b	.L160
 3495              	.LVL301:
 3496              	.L242:
1578:../uvc.c      **** 							 Data0 = Data0 - 1;
 3497              		.loc 1 1578 0
 3498 1d74 012043E2 		sub	r2, r3, #1
 3499              	.LVL302:
 3500 1d78 FF2002E2 		and	r2, r2, #255
 3501              	.LVL303:
1579:../uvc.c      **** 							 is60Hz = Data0;
 3502              		.loc 1 1579 0
 3503 1d7c D8119FE5 		ldr	r1, .L329+76
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3504              		.loc 1 1590 0
 3505 1d80 D4E19FE5 		ldr	lr, .L329+76
1585:../uvc.c      **** 							 else if(Data0 >2)
 3506              		.loc 1 1585 0
 3507 1d84 020052E3 		cmp	r2, #2
1577:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3508              		.loc 1 1577 0
 3509 1d88 ED31C6E5 		strb	r3, [r6, #493]
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3510              		.loc 1 1588 0
 3511 1d8c 0130A083 		movhi	r3, #1
1579:../uvc.c      **** 							 is60Hz = Data0;
 3512              		.loc 1 1579 0
 3513 1d90 D82081E5 		str	r2, [r1, #216]
 3514              	.LVL304:
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3515              		.loc 1 1590 0
 3516 1d94 0400A0E3 		mov	r0, #4
1588:../uvc.c      **** 								 is60Hz = CyTrue;
 3517              		.loc 1 1588 0
 3518 1d98 D8308185 		strhi	r3, [r1, #216]
 3519              	.LVL305:
 3520 1d9c 0320A081 		movhi	r2, r3
1590:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
 3521              		.loc 1 1590 0
 3522 1da0 90119FE5 		ldr	r1, .L329+40
 3523 1da4 D8309EE5 		ldr	r3, [lr, #216]
 3524 1da8 FEFFFFEB 		bl	CyU3PDebugPrint
 3525              	.LVL306:
1591:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3526              		.loc 1 1591 0
 3527 1dac A8019FE5 		ldr	r0, .L329+76
 3528 1db0 A83090E5 		ldr	r3, [r0, #168]
 3529 1db4 010053E3 		cmp	r3, #1
 3530 1db8 5101000A 		beq	.L325
 3531              	.LVL307:
 3532              	.L276:
1622:../uvc.c      **** 							 break;
 3533              		.loc 1 1622 0
 3534 1dbc FFA0A0E3 		mov	sl, #255
1621:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3535              		.loc 1 1621 0
 3536 1dc0 0130A0E3 		mov	r3, #1
 3537 1dc4 F031C6E5 		strb	r3, [r6, #496]
 3538 1dc8 18809DE5 		ldr	r8, [sp, #24]
 3539 1dcc 1C409DE5 		ldr	r4, [sp, #28]
1622:../uvc.c      **** 							 break;
 3540              		.loc 1 1622 0
 3541 1dd0 0A70A0E1 		mov	r7, sl
 3542 1dd4 A3FCFFEA 		b	.L160
 3543              	.LVL308:
 3544              	.L241:
1677:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3545              		.loc 1 1677 0
 3546 1dd8 70819FE5 		ldr	r8, .L329+64
 3547 1ddc 0010E0E3 		mvn	r1, #0
 3548 1de0 1C0098E5 		ldr	r0, [r8, #28]
 3549 1de4 FEFFFFEB 		bl	_txe_mutex_get
 3550              	.LVL309:
1678:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3551              		.loc 1 1678 0
 3552 1de8 18C09DE5 		ldr	ip, [sp, #24]
 3553 1dec 0410A0E1 		mov	r1, r4
 3554 1df0 0A20A0E1 		mov	r2, sl
 3555 1df4 0930A0E1 		mov	r3, r9
 3556 1df8 0800A0E1 		mov	r0, r8
 3557 1dfc 00A0A0E3 		mov	sl, #0
 3558 1e00 00C08DE5 		str	ip, [sp, #0]
 3559 1e04 04A08DE5 		str	sl, [sp, #4]
 3560 1e08 FEFFFFEB 		bl	cmdSet
1679:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3561              		.loc 1 1679 0
 3562 1e0c 1C0098E5 		ldr	r0, [r8, #28]
 3563 1e10 FEFFFFEB 		bl	_txe_mutex_put
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3564              		.loc 1 1681 0
 3565 1e14 18709DE5 		ldr	r7, [sp, #24]
 3566              	.LVL310:
1686:../uvc.c      **** 							 break;
 3567              		.loc 1 1686 0
 3568 1e18 FFA0A0E3 		mov	sl, #255
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3569              		.loc 1 1682 0
 3570 1e1c 0130A0E3 		mov	r3, #1
1681:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
 3571              		.loc 1 1681 0
 3572 1e20 BD71C6E5 		strb	r7, [r6, #445]
1682:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3573              		.loc 1 1682 0
 3574 1e24 0780A0E1 		mov	r8, r7
 3575 1e28 C031C6E5 		strb	r3, [r6, #448]
 3576 1e2c 1C409DE5 		ldr	r4, [sp, #28]
1686:../uvc.c      **** 							 break;
 3577              		.loc 1 1686 0
 3578 1e30 0A70A0E1 		mov	r7, sl
 3579 1e34 8BFCFFEA 		b	.L160
 3580              	.LVL311:
 3581              	.L240:
1513:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3582              		.loc 1 1513 0
 3583 1e38 10819FE5 		ldr	r8, .L329+64
 3584 1e3c 0010E0E3 		mvn	r1, #0
 3585 1e40 1C0098E5 		ldr	r0, [r8, #28]
 3586 1e44 FEFFFFEB 		bl	_txe_mutex_get
 3587              	.LVL312:
1515:../uvc.c      **** 							  if(Data0&0x80){
 3588              		.loc 1 1515 0
 3589 1e48 18209DE5 		ldr	r2, [sp, #24]
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3590              		.loc 1 1520 0
 3591 1e4c 0930A0E1 		mov	r3, r9
1515:../uvc.c      **** 							  if(Data0&0x80){
 3592              		.loc 1 1515 0
 3593 1e50 800012E3 		tst	r2, #128
1516:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 3594              		.loc 1 1516 0
 3595 1e54 80704212 		subne	r7, r2, #128
 3596              	.LVL313:
1518:../uvc.c      **** 								  Data0 = ~Data0;
 3597              		.loc 1 1518 0
 3598 1e58 0270E001 		mvneq	r7, r2
 3599 1e5c FF7007E2 		and	r7, r7, #255
 3600              	.LVL314:
1520:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
 3601              		.loc 1 1520 0
 3602 1e60 0110A0E3 		mov	r1, #1
 3603 1e64 0B20A0E1 		mov	r2, fp
 3604 1e68 0040A0E3 		mov	r4, #0
 3605 1e6c DC009FE5 		ldr	r0, .L329+64
 3606 1e70 00708DE5 		str	r7, [sp, #0]
 3607 1e74 04408DE5 		str	r4, [sp, #4]
 3608 1e78 FEFFFFEB 		bl	cmdSet
1521:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3609              		.loc 1 1521 0
 3610 1e7c 1C0098E5 		ldr	r0, [r8, #28]
 3611 1e80 FEFFFFEB 		bl	_txe_mutex_put
1527:../uvc.c      **** 							 break;
 3612              		.loc 1 1527 0
 3613 1e84 FFA0A0E3 		mov	sl, #255
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3614              		.loc 1 1524 0
 3615 1e88 0130A0E3 		mov	r3, #1
1523:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3616              		.loc 1 1523 0
 3617 1e8c A571C6E5 		strb	r7, [r6, #421]
1524:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3618              		.loc 1 1524 0
 3619 1e90 A831C6E5 		strb	r3, [r6, #424]
 3620 1e94 18809DE5 		ldr	r8, [sp, #24]
 3621 1e98 1C409DE5 		ldr	r4, [sp, #28]
1527:../uvc.c      **** 							 break;
 3622              		.loc 1 1527 0
 3623 1e9c 0A70A0E1 		mov	r7, sl
 3624              	.LVL315:
 3625 1ea0 70FCFFEA 		b	.L160
 3626              	.LVL316:
 3627              	.L239:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3628              		.loc 1 1634 0
 3629 1ea4 B0409FE5 		ldr	r4, .L329+76
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3630              		.loc 1 1624 0
 3631 1ea8 F874D6E5 		ldrb	r7, [r6, #1272]	@ zero_extendqisi2
 3632              	.LVL317:
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3633              		.loc 1 1634 0
 3634 1eac 7C21D4E5 		ldrb	r2, [r4, #380]	@ zero_extendqisi2
 3635              	.LVL318:
 3636 1eb0 0310A0E1 		mov	r1, r3
1625:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3637              		.loc 1 1625 0
 3638 1eb4 F934D6E5 		ldrb	r3, [r6, #1273]	@ zero_extendqisi2
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3639              		.loc 1 1626 0
 3640 1eb8 0785D6E5 		ldrb	r8, [r6, #1287]	@ zero_extendqisi2
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3641              		.loc 1 1634 0
 3642 1ebc 010052E3 		cmp	r2, #1
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3643              		.loc 1 1632 0
 3644 1ec0 01E0A0E3 		mov	lr, #1
1631:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3645              		.loc 1 1631 0
 3646 1ec4 0515C6E5 		strb	r1, [r6, #1285]
1624:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3647              		.loc 1 1624 0
 3648 1ec8 FF7007E2 		and	r7, r7, #255
 3649              	.LVL319:
1632:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3650              		.loc 1 1632 0
 3651 1ecc 09E5C6E5 		strb	lr, [r6, #1289]
1626:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3652              		.loc 1 1626 0
 3653 1ed0 FF8008E2 		and	r8, r8, #255
 3654              	.LVL320:
 3655 1ed4 0160A011 		movne	r6, r1
1634:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 3656              		.loc 1 1634 0
 3657 1ed8 6E01000A 		beq	.L326
 3658              	.LVL321:
 3659              	.L290:
1645:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3660              		.loc 1 1645 0
 3661 1edc 6CA09FE5 		ldr	sl, .L329+64
 3662 1ee0 0010E0E3 		mvn	r1, #0
 3663 1ee4 1C009AE5 		ldr	r0, [sl, #28]
 3664 1ee8 FEFFFFEB 		bl	_txe_mutex_get
1646:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3665              		.loc 1 1646 0
 3666 1eec 00C0A0E3 		mov	ip, #0
 3667 1ef0 0C10A0E1 		mov	r1, ip
 3668 1ef4 0720A0E1 		mov	r2, r7
 3669 1ef8 0830A0E1 		mov	r3, r8
 3670 1efc 0A00A0E1 		mov	r0, sl
 3671 1f00 40108DE8 		stmia	sp, {r6, ip}	@ phole stm
 3672 1f04 FEFFFFEB 		bl	cmdSet
1647:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3673              		.loc 1 1647 0
 3674 1f08 1C009AE5 		ldr	r0, [sl, #28]
 3675 1f0c 9BFEFFEA 		b	.L316
 3676              	.L330:
 3677              		.align	2
 3678              	.L329:
 3679 1f10 00000000 		.word	bRequest
 3680 1f14 38050000 		.word	.LC31
 3681 1f18 1C010000 		.word	.LANCHOR0+284
 3682 1f1c 01000100 		.word	65537
 3683 1f20 FF00FF00 		.word	16711935
 3684 1f24 C8030000 		.word	.LC23
 3685 1f28 04040000 		.word	.LC24
 3686 1f2c 68030000 		.word	.LC21
 3687 1f30 CC000000 		.word	.LANCHOR0+204
 3688 1f34 8C040000 		.word	.LC27
 3689 1f38 C4040000 		.word	.LC28
 3690 1f3c 58040000 		.word	.LC26
 3691 1f40 2C040000 		.word	.LC25
 3692 1f44 08050000 		.word	.LC30
 3693 1f48 E4040000 		.word	.LC29
 3694 1f4c 40030000 		.word	.LC20
 3695 1f50 00000000 		.word	cmdQu
 3696 1f54 90030000 		.word	.LC22
 3697 1f58 00000000 		.word	.LANCHOR1
 3698 1f5c 00000000 		.word	.LANCHOR0
 3699              	.LVL322:
 3700              	.L238:
1690:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3701              		.loc 1 1690 0
 3702 1f60 18701FE5 		ldr	r7, .L329+64
 3703              	.LVL323:
 3704 1f64 0010E0E3 		mvn	r1, #0
 3705 1f68 1C0097E5 		ldr	r0, [r7, #28]
 3706 1f6c FEFFFFEB 		bl	_txe_mutex_get
 3707              	.LVL324:
1691:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3708              		.loc 1 1691 0
 3709 1f70 0A20A0E1 		mov	r2, sl
 3710 1f74 18A09DE5 		ldr	sl, [sp, #24]
 3711 1f78 0410A0E1 		mov	r1, r4
 3712 1f7c 0930A0E1 		mov	r3, r9
 3713 1f80 0700A0E1 		mov	r0, r7
 3714 1f84 0080A0E3 		mov	r8, #0
 3715 1f88 00A08DE5 		str	sl, [sp, #0]
 3716 1f8c 04808DE5 		str	r8, [sp, #4]
 3717 1f90 FEFFFFEB 		bl	cmdSet
1692:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3718              		.loc 1 1692 0
 3719 1f94 1C0097E5 		ldr	r0, [r7, #28]
 3720 1f98 FEFFFFEB 		bl	_txe_mutex_put
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3721              		.loc 1 1694 0
 3722 1f9c 18109DE5 		ldr	r1, [sp, #24]
 3723 1fa0 840084E0 		add	r0, r4, r4, asl #1
 3724 1fa4 806186E0 		add	r6, r6, r0, asl #3
1696:../uvc.c      **** 							 break;
 3725              		.loc 1 1696 0
 3726 1fa8 FFA0A0E3 		mov	sl, #255
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3727              		.loc 1 1695 0
 3728 1fac 0120A0E3 		mov	r2, #1
1694:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3729              		.loc 1 1694 0
 3730 1fb0 8D11C6E5 		strb	r1, [r6, #397]
1695:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3731              		.loc 1 1695 0
 3732 1fb4 9021C6E5 		strb	r2, [r6, #400]
 3733 1fb8 0180A0E1 		mov	r8, r1
 3734 1fbc 1C409DE5 		ldr	r4, [sp, #28]
1696:../uvc.c      **** 							 break;
 3735              		.loc 1 1696 0
 3736 1fc0 0A70A0E1 		mov	r7, sl
 3737 1fc4 27FCFFEA 		b	.L160
 3738              	.LVL325:
 3739              	.L248:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3740              		.loc 1 1331 0
 3741 1fc8 80401FE5 		ldr	r4, .L329+64
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3742              		.loc 1 1327 0
 3743 1fcc E0A4D6E5 		ldrb	sl, [r6, #1248]	@ zero_extendqisi2
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3744              		.loc 1 1328 0
 3745 1fd0 E1E4D6E5 		ldrb	lr, [r6, #1249]	@ zero_extendqisi2
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3746              		.loc 1 1329 0
 3747 1fd4 EFC4D6E5 		ldrb	ip, [r6, #1263]	@ zero_extendqisi2
 3748              	.LVL326:
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3749              		.loc 1 1331 0
 3750 1fd8 0010E0E3 		mvn	r1, #0
 3751 1fdc 1C0094E5 		ldr	r0, [r4, #28]
1329:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3752              		.loc 1 1329 0
 3753 1fe0 FF800CE2 		and	r8, ip, #255
1328:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3754              		.loc 1 1328 0
 3755 1fe4 FF900EE2 		and	r9, lr, #255
1331:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3756              		.loc 1 1331 0
 3757 1fe8 FEFFFFEB 		bl	_txe_mutex_get
 3758              	.LVL327:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3759              		.loc 1 1332 0
 3760 1fec 18C09DE5 		ldr	ip, [sp, #24]
 3761 1ff0 ED14D6E5 		ldrb	r1, [r6, #1261]	@ zero_extendqisi2
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3762              		.loc 1 1327 0
 3763 1ff4 FFA00AE2 		and	sl, sl, #255
 3764              	.LVL328:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3765              		.loc 1 1332 0
 3766 1ff8 01005CE1 		cmp	ip, r1
1327:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3767              		.loc 1 1327 0
 3768 1ffc AC301FE5 		ldr	r3, .L329+72
 3769 2000 0C70A001 		moveq	r7, ip
 3770              	.LVL329:
1332:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3771              		.loc 1 1332 0
 3772 2004 0A00000A 		beq	.L261
1334:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
 3773              		.loc 1 1334 0
 3774 2008 EDC4C3E5 		strb	ip, [r3, #1261]
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3775              		.loc 1 1335 0
 3776 200c C534D3E5 		ldrb	r3, [r3, #1221]	@ zero_extendqisi2
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3777              		.loc 1 1336 0
 3778 2010 0400A0E1 		mov	r0, r4
1335:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3779              		.loc 1 1335 0
 3780 2014 03728CE1 		orr	r7, ip, r3, asl #4
 3781 2018 FF7007E2 		and	r7, r7, #255
 3782              	.LVL330:
1336:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3783              		.loc 1 1336 0
 3784 201c 00C0A0E3 		mov	ip, #0
 3785 2020 1910A0E3 		mov	r1, #25
 3786 2024 0A20A0E1 		mov	r2, sl
 3787 2028 0830A0E1 		mov	r3, r8
 3788 202c 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 3789 2030 FEFFFFEB 		bl	cmdSet
 3790              	.LVL331:
 3791              	.L261:
1348:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
 3792              		.loc 1 1348 0
 3793 2034 EE04D6E5 		ldrb	r0, [r6, #1262]	@ zero_extendqisi2
 3794 2038 1CE09DE5 		ldr	lr, [sp, #28]
 3795 203c 0E0050E1 		cmp	r0, lr
 3796 2040 0500000A 		beq	.L262
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3797              		.loc 1 1350 0
 3798 2044 18A09DE5 		ldr	sl, [sp, #24]
 3799              	.LVL332:
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3800              		.loc 1 1349 0
 3801 2048 F8201FE5 		ldr	r2, .L329+72
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3802              		.loc 1 1350 0
 3803 204c 02104AE2 		sub	r1, sl, #2
 3804 2050 010051E3 		cmp	r1, #1
1349:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3805              		.loc 1 1349 0
 3806 2054 EEE4C2E5 		strb	lr, [r2, #1262]
1350:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3807              		.loc 1 1350 0
 3808 2058 E101009A 		bls	.L327
 3809              	.LVL333:
 3810              	.L262:
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3811              		.loc 1 1355 0
 3812 205c 1C0094E5 		ldr	r0, [r4, #28]
 3813 2060 FEFFFFEB 		bl	_txe_mutex_put
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3814              		.loc 1 1357 0
 3815 2064 ED24D6E5 		ldrb	r2, [r6, #1261]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3816              		.loc 1 1356 0
 3817 2068 1C409DE5 		ldr	r4, [sp, #28]
1357:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3818              		.loc 1 1357 0
 3819 206c EE34D6E5 		ldrb	r3, [r6, #1262]	@ zero_extendqisi2
 3820 2070 C5C4D6E5 		ldrb	ip, [r6, #1221]	@ zero_extendqisi2
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3821              		.loc 1 1356 0
 3822 2074 0400A0E3 		mov	r0, #4
 3823 2078 44111FE5 		ldr	r1, .L329+44
1358:../uvc.c      **** 							 break;
 3824              		.loc 1 1358 0
 3825 207c FFA0A0E3 		mov	sl, #255
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3826              		.loc 1 1356 0
 3827 2080 04708DE5 		str	r7, [sp, #4]
 3828 2084 00C08DE5 		str	ip, [sp, #0]
 3829 2088 08408DE5 		str	r4, [sp, #8]
1358:../uvc.c      **** 							 break;
 3830              		.loc 1 1358 0
 3831 208c 0A70A0E1 		mov	r7, sl
 3832              	.LVL334:
1356:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3833              		.loc 1 1356 0
 3834 2090 FEFFFFEB 		bl	CyU3PDebugPrint
 3835              	.LVL335:
 3836 2094 18809DE5 		ldr	r8, [sp, #24]
1358:../uvc.c      **** 							 break;
 3837              		.loc 1 1358 0
 3838 2098 F2FBFFEA 		b	.L160
 3839              	.LVL336:
 3840              	.L247:
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3841              		.loc 1 1267 0
 3842 209c B8A4D6E5 		ldrb	sl, [r6, #1208]	@ zero_extendqisi2
 3843 20a0 0310A0E1 		mov	r1, r3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3844              		.loc 1 1268 0
 3845 20a4 B984D6E5 		ldrb	r8, [r6, #1209]	@ zero_extendqisi2
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3846              		.loc 1 1269 0
 3847 20a8 C744D6E5 		ldrb	r4, [r6, #1223]	@ zero_extendqisi2
1270:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3848              		.loc 1 1270 0
 3849 20ac C534C6E5 		strb	r3, [r6, #1221]
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3850              		.loc 1 1272 0
 3851 20b0 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
1267:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
 3852              		.loc 1 1267 0
 3853 20b4 FF700AE2 		and	r7, sl, #255
 3854              	.LVL337:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3855              		.loc 1 1272 0
 3856 20b8 030013E3 		tst	r3, #3
1268:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3857              		.loc 1 1268 0
 3858 20bc FF8008E2 		and	r8, r8, #255
 3859              	.LVL338:
1269:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3860              		.loc 1 1269 0
 3861 20c0 FF4004E2 		and	r4, r4, #255
 3862              	.LVL339:
1272:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
 3863              		.loc 1 1272 0
 3864 20c4 0130A001 		moveq	r3, r1
 3865 20c8 1D00000A 		beq	.L260
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3866              		.loc 1 1274 0
 3867 20cc 7C911FE5 		ldr	r9, .L329+72
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3868              		.loc 1 1276 0
 3869 20d0 88A11FE5 		ldr	sl, .L329+64
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3870              		.loc 1 1274 0
 3871 20d4 ED04D9E5 		ldrb	r0, [r9, #1261]	@ zero_extendqisi2
 3872 20d8 0120A0E1 		mov	r2, r1
 3873              	.LVL340:
 3874 20dc 023280E1 		orr	r3, r0, r2, asl #4
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3875              		.loc 1 1276 0
 3876 20e0 0010E0E3 		mvn	r1, #0
 3877 20e4 1C009AE5 		ldr	r0, [sl, #28]
1274:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
 3878              		.loc 1 1274 0
 3879 20e8 FF9003E2 		and	r9, r3, #255
 3880              	.LVL341:
1276:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3881              		.loc 1 1276 0
 3882 20ec 14C08DE5 		str	ip, [sp, #20]
 3883 20f0 FEFFFFEB 		bl	_txe_mutex_get
 3884              	.LVL342:
1277:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3885              		.loc 1 1277 0
 3886 20f4 00E0A0E3 		mov	lr, #0
 3887 20f8 1010A0E3 		mov	r1, #16
 3888 20fc 0820A0E1 		mov	r2, r8
 3889 2100 0430A0E1 		mov	r3, r4
 3890 2104 0A00A0E1 		mov	r0, sl
 3891 2108 00E08DE5 		str	lr, [sp, #0]
 3892 210c 04E08DE5 		str	lr, [sp, #4]
 3893 2110 FEFFFFEB 		bl	cmdSet
 3894              	.LVL343:
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3895              		.loc 1 1279 0
 3896 2114 0720A0E1 		mov	r2, r7
 3897 2118 0430A0E1 		mov	r3, r4
 3898 211c 1010A0E3 		mov	r1, #16
 3899 2120 0A00A0E1 		mov	r0, sl
 3900 2124 0170A0E3 		mov	r7, #1
 3901              	.LVL344:
 3902 2128 00908DE5 		str	r9, [sp, #0]
 3903 212c 04708DE5 		str	r7, [sp, #4]
 3904 2130 FEFFFFEB 		bl	cmdSet
 3905              	.LVL345:
1280:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3906              		.loc 1 1280 0
 3907 2134 1C009AE5 		ldr	r0, [sl, #28]
 3908 2138 FEFFFFEB 		bl	_txe_mutex_put
 3909 213c 14C09DE5 		ldr	ip, [sp, #20]
 3910 2140 0930A0E1 		mov	r3, r9
 3911              	.LVL346:
 3912              	.L260:
1283:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 3913              		.loc 1 1283 0
 3914 2144 ED84D6E5 		ldrb	r8, [r6, #1261]	@ zero_extendqisi2
 3915              	.LVL347:
 3916 2148 C544D6E5 		ldrb	r4, [r6, #1221]	@ zero_extendqisi2
 3917              	.LVL348:
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3918              		.loc 1 1282 0
 3919 214c 0400A0E3 		mov	r0, #4
 3920 2150 18121FE5 		ldr	r1, .L329+48
 3921 2154 0C20A0E1 		mov	r2, ip
1284:../uvc.c      **** 						     break;
 3922              		.loc 1 1284 0
 3923 2158 FFA0A0E3 		mov	sl, #255
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3924              		.loc 1 1282 0
 3925 215c 00808DE5 		str	r8, [sp, #0]
 3926 2160 04408DE5 		str	r4, [sp, #4]
1284:../uvc.c      **** 						     break;
 3927              		.loc 1 1284 0
 3928 2164 0A70A0E1 		mov	r7, sl
1282:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
 3929              		.loc 1 1282 0
 3930 2168 FEFFFFEB 		bl	CyU3PDebugPrint
 3931 216c 18809DE5 		ldr	r8, [sp, #24]
 3932 2170 1C409DE5 		ldr	r4, [sp, #28]
1284:../uvc.c      **** 						     break;
 3933              		.loc 1 1284 0
 3934 2174 BBFBFFEA 		b	.L160
 3935              	.LVL349:
 3936              	.L246:
1565:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3937              		.loc 1 1565 0
 3938 2178 30721FE5 		ldr	r7, .L329+64
 3939              	.LVL350:
 3940 217c 0010E0E3 		mvn	r1, #0
 3941 2180 1C0097E5 		ldr	r0, [r7, #28]
 3942 2184 FEFFFFEB 		bl	_txe_mutex_get
 3943              	.LVL351:
1566:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3944              		.loc 1 1566 0
 3945 2188 18C09DE5 		ldr	ip, [sp, #24]
 3946 218c 0A20A0E1 		mov	r2, sl
 3947 2190 0B10A0E3 		mov	r1, #11
 3948 2194 0930A0E1 		mov	r3, r9
 3949 2198 0700A0E1 		mov	r0, r7
 3950 219c 00A0A0E3 		mov	sl, #0
 3951 21a0 00C08DE5 		str	ip, [sp, #0]
 3952 21a4 04A08DE5 		str	sl, [sp, #4]
 3953 21a8 FEFFFFEB 		bl	cmdSet
 3954              	.LVL352:
1568:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 3955              		.loc 1 1568 0
 3956 21ac 1C409DE5 		ldr	r4, [sp, #28]
 3957 21b0 0180A0E3 		mov	r8, #1
 3958 21b4 0B10A0E3 		mov	r1, #11
 3959 21b8 0B20A0E1 		mov	r2, fp
 3960 21bc 0930A0E1 		mov	r3, r9
 3961 21c0 0700A0E1 		mov	r0, r7
 3962 21c4 10018DE8 		stmia	sp, {r4, r8}	@ phole stm
 3963 21c8 FEFFFFEB 		bl	cmdSet
1569:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3964              		.loc 1 1569 0
 3965 21cc 1C0097E5 		ldr	r0, [r7, #28]
 3966 21d0 FEFFFFEB 		bl	_txe_mutex_put
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3967              		.loc 1 1571 0
 3968 21d4 18009DE5 		ldr	r0, [sp, #24]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3969              		.loc 1 1572 0
 3970 21d8 1C109DE5 		ldr	r1, [sp, #28]
1574:../uvc.c      **** 							 break;
 3971              		.loc 1 1574 0
 3972 21dc FFA0A0E3 		mov	sl, #255
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3973              		.loc 1 1573 0
 3974 21e0 9882C6E5 		strb	r8, [r6, #664]
1571:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 3975              		.loc 1 1571 0
 3976 21e4 F404C6E5 		strb	r0, [r6, #1268]
1572:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3977              		.loc 1 1572 0
 3978 21e8 F614C6E5 		strb	r1, [r6, #1270]
1573:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3979              		.loc 1 1573 0
 3980 21ec 0080A0E1 		mov	r8, r0
 3981 21f0 0140A0E1 		mov	r4, r1
1574:../uvc.c      **** 							 break;
 3982              		.loc 1 1574 0
 3983 21f4 0A70A0E1 		mov	r7, sl
 3984 21f8 9AFBFFEA 		b	.L160
 3985              	.LVL353:
 3986              	.L245:
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 3987              		.loc 1 1651 0
 3988 21fc 0C05D6E5 		ldrb	r0, [r6, #1292]	@ zero_extendqisi2
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3989              		.loc 1 1652 0
 3990 2200 0D25D6E5 		ldrb	r2, [r6, #1293]	@ zero_extendqisi2
 3991              	.LVL354:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3992              		.loc 1 1653 0
 3993 2204 1B15D6E5 		ldrb	r1, [r6, #1307]	@ zero_extendqisi2
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3994              		.loc 1 1656 0
 3995 2208 0140A0E3 		mov	r4, #1
1657:../uvc.c      **** 							 if(Data0 != 0){
 3996              		.loc 1 1657 0
 3997 220c 000053E3 		cmp	r3, #0
1655:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
 3998              		.loc 1 1655 0
 3999 2210 1935C6E5 		strb	r3, [r6, #1305]
1651:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 4000              		.loc 1 1651 0
 4001 2214 FF8000E2 		and	r8, r0, #255
 4002              	.LVL355:
1652:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4003              		.loc 1 1652 0
 4004 2218 FFA002E2 		and	sl, r2, #255
 4005              	.LVL356:
1653:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4006              		.loc 1 1653 0
 4007 221c FF7001E2 		and	r7, r1, #255
 4008              	.LVL357:
1656:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4009              		.loc 1 1656 0
 4010 2220 1D45C6E5 		strb	r4, [r6, #1309]
1657:../uvc.c      **** 							 if(Data0 != 0){
 4011              		.loc 1 1657 0
 4012 2224 1C00000A 		beq	.L292
1658:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4013              		.loc 1 1658 0
 4014 2228 E0621FE5 		ldr	r6, .L329+64
 4015 222c 0010E0E3 		mvn	r1, #0
 4016 2230 1C0096E5 		ldr	r0, [r6, #28]
 4017 2234 FEFFFFEB 		bl	_txe_mutex_get
 4018              	.LVL358:
1662:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
 4019              		.loc 1 1662 0
 4020 2238 0820A0E1 		mov	r2, r8
 4021 223c 00C0A0E3 		mov	ip, #0
 4022 2240 0710A0E3 		mov	r1, #7
 4023 2244 0730A0E1 		mov	r3, r7
 4024 2248 0600A0E1 		mov	r0, r6
 4025 224c 10108DE8 		stmia	sp, {r4, ip}	@ phole stm
 4026 2250 FEFFFFEB 		bl	cmdSet
 4027              	.LVL359:
1664:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
 4028              		.loc 1 1664 0
 4029 2254 18809DE5 		ldr	r8, [sp, #24]
 4030              	.LVL360:
 4031 2258 0710A0E3 		mov	r1, #7
 4032 225c 0A20A0E1 		mov	r2, sl
 4033 2260 0730A0E1 		mov	r3, r7
 4034 2264 0600A0E1 		mov	r0, r6
 4035 2268 00808DE5 		str	r8, [sp, #0]
 4036 226c 04408DE5 		str	r4, [sp, #4]
 4037 2270 FEFFFFEB 		bl	cmdSet
1666:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4038              		.loc 1 1666 0
 4039 2274 1C0096E5 		ldr	r0, [r6, #28]
 4040 2278 C0FDFFEA 		b	.L316
 4041              	.LVL361:
 4042              	.L237:
1699:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 4043              		.loc 1 1699 0
 4044 227c FFA0A0E3 		mov	sl, #255
 4045 2280 0400A0E3 		mov	r0, #4
 4046              	.LVL362:
 4047 2284 48131FE5 		ldr	r1, .L329+52
 4048 2288 FEFFFFEB 		bl	CyU3PDebugPrint
 4049              	.LVL363:
 4050 228c 0A70A0E1 		mov	r7, sl
 4051              	.LVL364:
 4052 2290 0A40A0E1 		mov	r4, sl
 4053 2294 0A80A0E1 		mov	r8, sl
 4054 2298 72FBFFEA 		b	.L160
 4055              	.LVL365:
 4056              	.L292:
1668:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4057              		.loc 1 1668 0
 4058 229c 54431FE5 		ldr	r4, .L329+64
 4059 22a0 0010E0E3 		mvn	r1, #0
 4060 22a4 1C0094E5 		ldr	r0, [r4, #28]
 4061 22a8 FEFFFFEB 		bl	_txe_mutex_get
 4062              	.LVL366:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4063              		.loc 1 1669 0
 4064 22ac 18E09DE5 		ldr	lr, [sp, #24]
 4065 22b0 0820A0E1 		mov	r2, r8
 4066 22b4 0730A0E1 		mov	r3, r7
 4067 22b8 0710A0E3 		mov	r1, #7
 4068 22bc 0400A0E1 		mov	r0, r4
 4069 22c0 00E08DE5 		str	lr, [sp, #0]
 4070 22c4 04E08DE5 		str	lr, [sp, #4]
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4071              		.loc 1 1670 0
 4072 22c8 FFA0A0E3 		mov	sl, #255
 4073              	.LVL367:
1669:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4074              		.loc 1 1669 0
 4075 22cc FEFFFFEB 		bl	cmdSet
1670:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4076              		.loc 1 1670 0
 4077 22d0 1C0094E5 		ldr	r0, [r4, #28]
 4078 22d4 FEFFFFEB 		bl	_txe_mutex_put
 4079 22d8 0A70A0E1 		mov	r7, sl
 4080              	.LVL368:
 4081 22dc 1C409DE5 		ldr	r4, [sp, #28]
 4082 22e0 18809DE5 		ldr	r8, [sp, #24]
 4083              	.LVL369:
 4084 22e4 5FFBFFEA 		b	.L160
 4085              	.LVL370:
 4086              	.L324:
1028:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4087              		.loc 1 1028 0
 4088 22e8 0A00A0E1 		mov	r0, sl
 4089 22ec 0910A0E1 		mov	r1, r9
 4090 22f0 FEFFFFEB 		bl	SensorGetControl
 4091              	.LVL371:
1030:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4092              		.loc 1 1030 0
 4093 22f4 01A0A0E3 		mov	sl, #1
 4094 22f8 41A1C4E5 		strb	sl, [r4, #321]
1029:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4095              		.loc 1 1029 0
 4096 22fc 0502C6E5 		strb	r0, [r6, #517]
 4097 2300 47FDFFEA 		b	.L207
 4098              	.LVL372:
 4099              	.L325:
1594:../uvc.c      **** 			                       switch (setRes)
 4100              		.loc 1 1594 0
 4101 2304 7D81D0E5 		ldrb	r8, [r0, #381]	@ zero_extendqisi2
 4102 2308 010048E2 		sub	r0, r8, #1
 4103 230c 030050E3 		cmp	r0, #3
 4104 2310 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 4105 2314 A8FEFFEA 		b	.L276
 4106              	.L281:
 4107 2318 44240000 		.word	.L277
 4108 231c F0230000 		.word	.L278
 4109 2320 8C230000 		.word	.L279
 4110 2324 28230000 		.word	.L280
 4111              	.L280:
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4112              		.loc 1 1612 0
 4113 2328 D4031FE5 		ldr	r0, .L329+76
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4114              		.loc 1 1614 0
 4115 232c D8A31FE5 		ldr	sl, .L329+76
1612:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
 4116              		.loc 1 1612 0
 4117 2330 D8C090E5 		ldr	ip, [r0, #216]
 4118 2334 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4119 2338 00005CE3 		cmp	ip, #0
 4120 233c F4C0A003 		moveq	ip, #244
 4121 2340 74C0A013 		movne	ip, #116
 4122 2344 02208CE1 		orr	r2, ip, r2
 4123 2348 3010A0E3 		mov	r1, #48
 4124 234c 5230A0E3 		mov	r3, #82
 4125 2350 0100A0E3 		mov	r0, #1
 4126 2354 FEFFFFEB 		bl	SensorSetIrisControl
1613:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4127              		.loc 1 1613 0
 4128 2358 7D0FA0E3 		mov	r0, #500
 4129 235c FEFFFFEB 		bl	_tx_thread_sleep
1614:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4130              		.loc 1 1614 0
 4131 2360 D8409AE5 		ldr	r4, [sl, #216]
 4132 2364 8D74D6E5 		ldrb	r7, [r6, #1165]	@ zero_extendqisi2
 4133              	.LVL373:
 4134 2368 000054E3 		cmp	r4, #0
 4135 236c F440A003 		moveq	r4, #244
 4136 2370 7440A013 		movne	r4, #116
 4137 2374 D8309AE5 		ldr	r3, [sl, #216]
 4138 2378 38141FE5 		ldr	r1, .L329+56
 4139 237c 072084E1 		orr	r2, r4, r7
 4140 2380 0400A0E3 		mov	r0, #4
 4141 2384 FEFFFFEB 		bl	CyU3PDebugPrint
 4142 2388 8BFEFFEA 		b	.L276
 4143              	.LVL374:
 4144              	.L279:
1607:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
 4145              		.loc 1 1607 0
 4146 238c 38841FE5 		ldr	r8, .L329+76
 4147 2390 5230A0E3 		mov	r3, #82
 4148 2394 D8E098E5 		ldr	lr, [r8, #216]
 4149 2398 8D14D6E5 		ldrb	r1, [r6, #1165]	@ zero_extendqisi2
 4150 239c 00005EE3 		cmp	lr, #0
 4151 23a0 C4E0A003 		moveq	lr, #196
 4152 23a4 44E0A013 		movne	lr, #68
 4153 23a8 01208EE1 		orr	r2, lr, r1
 4154 23ac 0100A0E3 		mov	r0, #1
 4155 23b0 3010A0E3 		mov	r1, #48
 4156 23b4 FEFFFFEB 		bl	SensorSetIrisControl
1608:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4157              		.loc 1 1608 0
 4158 23b8 7D0FA0E3 		mov	r0, #500
 4159 23bc FEFFFFEB 		bl	_tx_thread_sleep
1609:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4160              		.loc 1 1609 0
 4161 23c0 6C341FE5 		ldr	r3, .L329+76
 4162 23c4 84141FE5 		ldr	r1, .L329+56
 4163 23c8 D80093E5 		ldr	r0, [r3, #216]
 4164 23cc 8D24D6E5 		ldrb	r2, [r6, #1165]	@ zero_extendqisi2
 4165 23d0 000050E3 		cmp	r0, #0
 4166 23d4 C400A003 		moveq	r0, #196
 4167 23d8 4400A013 		movne	r0, #68
 4168 23dc 022080E1 		orr	r2, r0, r2
 4169 23e0 D83093E5 		ldr	r3, [r3, #216]
 4170 23e4 0400A0E3 		mov	r0, #4
 4171 23e8 FEFFFFEB 		bl	CyU3PDebugPrint
1610:../uvc.c      **** 			                         		break;
 4172              		.loc 1 1610 0
 4173 23ec 72FEFFEA 		b	.L276
 4174              	.L278:
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4175              		.loc 1 1602 0
 4176 23f0 9CC41FE5 		ldr	ip, .L329+76
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4177              		.loc 1 1604 0
 4178 23f4 A0A41FE5 		ldr	sl, .L329+76
1602:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
 4179              		.loc 1 1602 0
 4180 23f8 D8209CE5 		ldr	r2, [ip, #216]
 4181 23fc 3010A0E3 		mov	r1, #48
 4182 2400 000052E3 		cmp	r2, #0
 4183 2404 D420A003 		moveq	r2, #212
 4184 2408 5420A013 		movne	r2, #84
 4185 240c 5230A0E3 		mov	r3, #82
 4186 2410 0100A0E3 		mov	r0, #1
 4187 2414 FEFFFFEB 		bl	SensorSetIrisControl
1603:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4188              		.loc 1 1603 0
 4189 2418 7D0FA0E3 		mov	r0, #500
 4190 241c FEFFFFEB 		bl	_tx_thread_sleep
1604:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4191              		.loc 1 1604 0
 4192 2420 D8209AE5 		ldr	r2, [sl, #216]
 4193 2424 E4141FE5 		ldr	r1, .L329+56
 4194 2428 000052E3 		cmp	r2, #0
 4195 242c D8309AE5 		ldr	r3, [sl, #216]
 4196 2430 D420A003 		moveq	r2, #212
 4197 2434 5420A013 		movne	r2, #84
 4198 2438 0400A0E3 		mov	r0, #4
 4199 243c FEFFFFEB 		bl	CyU3PDebugPrint
1605:../uvc.c      **** 			                         		break;
 4200              		.loc 1 1605 0
 4201 2440 5DFEFFEA 		b	.L276
 4202              	.L277:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4203              		.loc 1 1597 0
 4204 2444 F0441FE5 		ldr	r4, .L329+76
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4205              		.loc 1 1599 0
 4206 2448 F4741FE5 		ldr	r7, .L329+76
 4207              	.LVL375:
1597:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
 4208              		.loc 1 1597 0
 4209 244c D82094E5 		ldr	r2, [r4, #216]
 4210 2450 3010A0E3 		mov	r1, #48
 4211 2454 000052E3 		cmp	r2, #0
 4212 2458 E420A003 		moveq	r2, #228
 4213 245c 6420A013 		movne	r2, #100
 4214 2460 5230A0E3 		mov	r3, #82
 4215 2464 0100A0E3 		mov	r0, #1
 4216 2468 FEFFFFEB 		bl	SensorSetIrisControl
1598:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4217              		.loc 1 1598 0
 4218 246c 7D0FA0E3 		mov	r0, #500
 4219 2470 FEFFFFEB 		bl	_tx_thread_sleep
1599:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4220              		.loc 1 1599 0
 4221 2474 D82097E5 		ldr	r2, [r7, #216]
 4222 2478 38151FE5 		ldr	r1, .L329+56
 4223 247c 000052E3 		cmp	r2, #0
 4224 2480 D83097E5 		ldr	r3, [r7, #216]
 4225 2484 E420A003 		moveq	r2, #228
 4226 2488 6420A013 		movne	r2, #100
 4227 248c 0400A0E3 		mov	r0, #4
 4228 2490 FEFFFFEB 		bl	CyU3PDebugPrint
1600:../uvc.c      **** 			                         		break;
 4229              		.loc 1 1600 0
 4230 2494 48FEFFEA 		b	.L276
 4231              	.LVL376:
 4232              	.L326:
1636:../uvc.c      **** 								 if(Data0 < 3){
 4233              		.loc 1 1636 0
 4234 2498 020051E3 		cmp	r1, #2
1637:../uvc.c      **** 					 				 Data0 += 4;
 4235              		.loc 1 1637 0
 4236 249c 04608192 		addls	r6, r1, #4
 4237 24a0 FF600692 		andls	r6, r6, #255
1636:../uvc.c      **** 								 if(Data0 < 3){
 4238              		.loc 1 1636 0
 4239 24a4 8CFEFF9A 		bls	.L290
1639:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 4240              		.loc 1 1639 0
 4241 24a8 0400A0E3 		mov	r0, #4
 4242 24ac 60151FE5 		ldr	r1, .L329+68
 4243 24b0 18309DE5 		ldr	r3, [sp, #24]
 4244 24b4 FEFFFFEB 		bl	CyU3PDebugPrint
 4245              	.LVL377:
1640:../uvc.c      **** 									Data0 = 4; //set to default.
 4246              		.loc 1 1640 0
 4247 24b8 0460A0E3 		mov	r6, #4
 4248 24bc 86FEFFEA 		b	.L290
 4249              	.LVL378:
 4250              	.L208:
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4251              		.loc 1 1046 0
 4252 24c0 0A00A0E1 		mov	r0, sl
 4253              	.LVL379:
 4254 24c4 0910A0E1 		mov	r1, r9
 4255 24c8 FEFFFFEB 		bl	SensorGetControl
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4256              		.loc 1 1047 0
 4257 24cc 0910A0E1 		mov	r1, r9
1046:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4258              		.loc 1 1046 0
 4259 24d0 0070A0E1 		mov	r7, r0
 4260              	.LVL380:
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4261              		.loc 1 1047 0
 4262 24d4 0B00A0E1 		mov	r0, fp
 4263              	.LVL381:
 4264 24d8 FEFFFFEB 		bl	SensorGetControl
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4265              		.loc 1 1052 0
 4266 24dc 0110A0E3 		mov	r1, #1
1048:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4267              		.loc 1 1048 0
 4268 24e0 1C71C4E5 		strb	r7, [r4, #284]
1049:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4269              		.loc 1 1049 0
 4270 24e4 F474C6E5 		strb	r7, [r6, #1268]
1052:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4271              		.loc 1 1052 0
 4272 24e8 4711C4E5 		strb	r1, [r4, #327]
1047:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4273              		.loc 1 1047 0
 4274 24ec 00A0A0E1 		mov	sl, r0
 4275              	.LVL382:
1050:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4276              		.loc 1 1050 0
 4277 24f0 1E01C4E5 		strb	r0, [r4, #286]
1051:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4278              		.loc 1 1051 0
 4279 24f4 F604C6E5 		strb	r0, [r6, #1270]
 4280 24f8 3DFCFFEA 		b	.L209
 4281              	.LVL383:
 4282              	.L181:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4283              		.loc 1 840 0
 4284 24fc 0910A0E1 		mov	r1, r9
 4285 2500 0B00A0E1 		mov	r0, fp
 4286 2504 FEFFFFEB 		bl	SensorGetControl
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4287              		.loc 1 842 0
 4288 2508 0910A0E1 		mov	r1, r9
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4289              		.loc 1 843 0
 4290 250c 0170A0E3 		mov	r7, #1
 4291              	.LVL384:
 840:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4292              		.loc 1 840 0
 4293 2510 0030A0E1 		mov	r3, r0
 4294 2514 1C31C4E5 		strb	r3, [r4, #284]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4295              		.loc 1 842 0
 4296 2518 0A00A0E1 		mov	r0, sl
 841:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4297              		.loc 1 841 0
 4298 251c 9D34C6E5 		strb	r3, [r6, #1181]
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4299              		.loc 1 842 0
 4300 2520 FEFFFFEB 		bl	SensorGetControl
 843:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4301              		.loc 1 843 0
 4302 2524 6071C4E5 		strb	r7, [r4, #352]
 4303 2528 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4304              	.LVL385:
 842:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4305              		.loc 1 842 0
 4306 252c 00A0A0E1 		mov	sl, r0
 4307              	.LVL386:
 4308 2530 1D01C4E5 		strb	r0, [r4, #285]
 847:../uvc.c      **** 						 break;
 4309              		.loc 1 847 0
 4310 2534 F5FBFFEA 		b	.L183
 4311              	.LVL387:
 4312              	.L186:
 873:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4313              		.loc 1 873 0
 4314 2538 0A00A0E1 		mov	r0, sl
 4315              	.LVL388:
 4316 253c 0910A0E1 		mov	r1, r9
 4317 2540 FEFFFFEB 		bl	SensorGetControl
 4318              	.LVL389:
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4319              		.loc 1 879 0
 4320 2544 9EA0D6E5 		ldrb	sl, [r6, #158]	@ zero_extendqisi2
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4321              		.loc 1 880 0
 4322 2548 01C0A0E3 		mov	ip, #1
 879:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4323              		.loc 1 879 0
 4324 254c 1DA1C4E5 		strb	sl, [r4, #285]
 880:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4325              		.loc 1 880 0
 4326 2550 62C1C4E5 		strb	ip, [r4, #354]
 874:../uvc.c      **** 			 	 			if(Data0&0x80)
 4327              		.loc 1 874 0
 4328 2554 800010E3 		tst	r0, #128
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4329              		.loc 1 875 0
 4330 2558 0170A013 		movne	r7, #1
 4331              	.LVL390:
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4332              		.loc 1 877 0
 4333 255c 0B70A001 		moveq	r7, fp
 4334              	.LVL391:
 875:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4335              		.loc 1 875 0
 4336 2560 1C71C415 		strneb	r7, [r4, #284]
 877:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 4337              		.loc 1 877 0
 4338 2564 1CB1C405 		streqb	fp, [r4, #284]
 878:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 4339              		.loc 1 878 0
 4340 2568 9D70C6E5 		strb	r7, [r6, #157]
 884:../uvc.c      **** 			 	 		 break;
 4341              		.loc 1 884 0
 4342 256c E7FBFFEA 		b	.L183
 4343              	.LVL392:
 4344              	.L212:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4345              		.loc 1 1081 0
 4346 2570 0B00A0E1 		mov	r0, fp
 4347              	.LVL393:
 4348 2574 0910A0E1 		mov	r1, r9
 4349 2578 FEFFFFEB 		bl	SensorGetControl
1084:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4350              		.loc 1 1084 0
 4351 257c 01C0A0E3 		mov	ip, #1
 4352 2580 43C1C4E5 		strb	ip, [r4, #323]
1082:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4353              		.loc 1 1082 0
 4354 2584 1905C6E5 		strb	r0, [r6, #1305]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4355              		.loc 1 1083 0
 4356 2588 1AA5D6E5 		ldrb	sl, [r6, #1306]	@ zero_extendqisi2
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4357              		.loc 1 1081 0
 4358 258c 0070A0E1 		mov	r7, r0
 4359              	.LVL394:
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4360              		.loc 1 1083 0
 4361 2590 FFA00AE2 		and	sl, sl, #255
 4362              	.LVL395:
1081:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4363              		.loc 1 1081 0
 4364 2594 1C01C4E5 		strb	r0, [r4, #284]
1083:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4365              		.loc 1 1083 0
 4366 2598 1DA1C4E5 		strb	sl, [r4, #285]
1088:../uvc.c      **** 					 break;
 4367              		.loc 1 1088 0
 4368 259c DBFBFFEA 		b	.L183
 4369              	.LVL396:
 4370              	.L200:
 973:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4371              		.loc 1 973 0
 4372 25a0 0710A0E1 		mov	r1, r7
 4373 25a4 FEFFFFEB 		bl	SensorGetControl
 4374              	.LVL397:
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4375              		.loc 1 977 0
 4376 25a8 0710A0E1 		mov	r1, r7
 974:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4377              		.loc 1 974 0
 4378 25ac 032000E2 		and	r2, r0, #3
 4379 25b0 1C21C4E5 		strb	r2, [r4, #284]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4380              		.loc 1 977 0
 4381 25b4 0A00A0E1 		mov	r0, sl
 975:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4382              		.loc 1 975 0
 4383 25b8 ED24C6E5 		strb	r2, [r6, #1261]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4384              		.loc 1 977 0
 4385 25bc FEFFFFEB 		bl	SensorGetControl
 979:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4386              		.loc 1 979 0
 4387 25c0 0130A0E3 		mov	r3, #1
 4388 25c4 5531C4E5 		strb	r3, [r4, #341]
 977:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 4389              		.loc 1 977 0
 4390 25c8 1E01C4E5 		strb	r0, [r4, #286]
 978:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4391              		.loc 1 978 0
 4392 25cc EE04C6E5 		strb	r0, [r6, #1262]
 4393 25d0 26FCFFEA 		b	.L201
 4394              	.LVL398:
 4395              	.L192:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4396              		.loc 1 923 0
 4397 25d4 FEFFFFEB 		bl	SensorGetControl
 4398              	.LVL399:
 926:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4399              		.loc 1 926 0
 4400 25d8 01C0A0E3 		mov	ip, #1
 4401 25dc 57C1C4E5 		strb	ip, [r4, #343]
 924:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4402              		.loc 1 924 0
 4403 25e0 D904C6E5 		strb	r0, [r6, #1241]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4404              		.loc 1 925 0
 4405 25e4 DA14D6E5 		ldrb	r1, [r6, #1242]	@ zero_extendqisi2
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4406              		.loc 1 923 0
 4407 25e8 0070A0E1 		mov	r7, r0
 4408              	.LVL400:
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4409              		.loc 1 925 0
 4410 25ec FFA001E2 		and	sl, r1, #255
 4411              	.LVL401:
 923:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 4412              		.loc 1 923 0
 4413 25f0 1C01C4E5 		strb	r0, [r4, #284]
 925:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4414              		.loc 1 925 0
 4415 25f4 1DA1C4E5 		strb	sl, [r4, #285]
 930:../uvc.c      **** 			 		 break;
 4416              		.loc 1 930 0
 4417 25f8 C4FBFFEA 		b	.L183
 4418              	.LVL402:
 4419              	.L184:
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4420              		.loc 1 855 0
 4421 25fc 0A00A0E1 		mov	r0, sl
 4422              	.LVL403:
 4423 2600 0910A0E1 		mov	r1, r9
 4424 2604 FEFFFFEB 		bl	SensorGetControl
 857:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4425              		.loc 1 857 0
 4426 2608 B104C6E5 		strb	r0, [r6, #1201]
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4427              		.loc 1 858 0
 4428 260c B214D6E5 		ldrb	r1, [r6, #1202]	@ zero_extendqisi2
 855:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4429              		.loc 1 855 0
 4430 2610 0070A0E1 		mov	r7, r0
 4431              	.LVL404:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4432              		.loc 1 858 0
 4433 2614 FFA001E2 		and	sl, r1, #255
 856:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4434              		.loc 1 856 0
 4435 2618 1C01C4E5 		strb	r0, [r4, #284]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4436              		.loc 1 859 0
 4437 261c 0100A0E3 		mov	r0, #1
 4438              	.LVL405:
 858:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4439              		.loc 1 858 0
 4440 2620 1DA1C4E5 		strb	sl, [r4, #285]
 859:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4441              		.loc 1 859 0
 4442 2624 6101C4E5 		strb	r0, [r4, #353]
 4443              	.LVL406:
 863:../uvc.c      **** 			 	 		 break;
 4444              		.loc 1 863 0
 4445 2628 B8FBFFEA 		b	.L183
 4446              	.LVL407:
 4447              	.L214:
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4448              		.loc 1 1098 0
 4449 262c 0A00A0E1 		mov	r0, sl
 4450              	.LVL408:
 4451 2630 0910A0E1 		mov	r1, r9
 4452 2634 FEFFFFEB 		bl	SensorGetControl
1100:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4453              		.loc 1 1100 0
 4454 2638 BEA1D6E5 		ldrb	sl, [r6, #446]	@ zero_extendqisi2
 4455 263c 1DA1CBE5 		strb	sl, [fp, #285]
1098:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4456              		.loc 1 1098 0
 4457 2640 0070A0E1 		mov	r7, r0
 4458 2644 1C01CBE5 		strb	r0, [fp, #284]
1099:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4459              		.loc 1 1099 0
 4460 2648 BD01C6E5 		strb	r0, [r6, #445]
1101:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4461              		.loc 1 1101 0
 4462 264c 0100A0E3 		mov	r0, #1
 4463 2650 3C01C4E5 		strb	r0, [r4, #316]
 4464              	.LVL409:
1105:../uvc.c      **** 					 break;
 4465              		.loc 1 1105 0
 4466 2654 ADFBFFEA 		b	.L183
 4467              	.LVL410:
 4468              	.L222:
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4469              		.loc 1 1153 0
 4470 2658 0A00A0E1 		mov	r0, sl
 4471              	.LVL411:
 4472 265c 0910A0E1 		mov	r1, r9
 4473 2660 14308DE5 		str	r3, [sp, #20]
 4474 2664 FEFFFFEB 		bl	SensorGetControl
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4475              		.loc 1 1154 0
 4476 2668 84A084E0 		add	sl, r4, r4, asl #1
 4477 266c 8A6186E0 		add	r6, r6, sl, asl #3
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4478              		.loc 1 1155 0
 4479 2670 8EA1D6E5 		ldrb	sl, [r6, #398]	@ zero_extendqisi2
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4480              		.loc 1 1156 0
 4481 2674 0110A0E3 		mov	r1, #1
1155:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4482              		.loc 1 1155 0
 4483 2678 1DA1CBE5 		strb	sl, [fp, #285]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4484              		.loc 1 1153 0
 4485 267c 1C01CBE5 		strb	r0, [fp, #284]
1154:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4486              		.loc 1 1154 0
 4487 2680 8D01C6E5 		strb	r0, [r6, #397]
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4488              		.loc 1 1156 0
 4489 2684 14C09DE5 		ldr	ip, [sp, #20]
1153:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4490              		.loc 1 1153 0
 4491 2688 0070A0E1 		mov	r7, r0
 4492              	.LVL412:
1156:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4493              		.loc 1 1156 0
 4494 268c 3C11CCE5 		strb	r1, [ip, #316]
 4495              	.LVL413:
1162:../uvc.c      **** 					 break;
 4496              		.loc 1 1162 0
 4497 2690 9EFBFFEA 		b	.L183
 4498              	.LVL414:
 4499              	.L216:
1112:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4500              		.loc 1 1112 0
 4501 2694 0A00A0E1 		mov	r0, sl
 4502              	.LVL415:
 4503 2698 0910A0E1 		mov	r1, r9
 4504 269c FEFFFFEB 		bl	SensorGetControl
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4505              		.loc 1 1115 0
 4506 26a0 66A2D6E5 		ldrb	sl, [r6, #614]	@ zero_extendqisi2
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4507              		.loc 1 1117 0
 4508 26a4 0110A0E3 		mov	r1, #1
1115:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4509              		.loc 1 1115 0
 4510 26a8 1DA1C4E5 		strb	sl, [r4, #285]
1117:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4511              		.loc 1 1117 0
 4512 26ac 4511C4E5 		strb	r1, [r4, #325]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4513              		.loc 1 1114 0
 4514 26b0 037000E2 		and	r7, r0, #3
 4515              	.LVL416:
1113:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4516              		.loc 1 1113 0
 4517 26b4 6502C6E5 		strb	r0, [r6, #613]
1114:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4518              		.loc 1 1114 0
 4519 26b8 1C71C4E5 		strb	r7, [r4, #284]
1121:../uvc.c      **** 					 break;
 4520              		.loc 1 1121 0
 4521 26bc 93FBFFEA 		b	.L183
 4522              	.LVL417:
 4523              	.L218:
1134:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
 4524              		.loc 1 1134 0
 4525 26c0 0100A0E3 		mov	r0, #1
 4526              	.LVL418:
 4527 26c4 0910A0E1 		mov	r1, r9
 4528 26c8 FEFFFFEB 		bl	SensorGetControl
 4529              	.LVL419:
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4530              		.loc 1 1139 0
 4531 26cc 0130A0E3 		mov	r3, #1
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4532              		.loc 1 1138 0
 4533 26d0 EEA1D6E5 		ldrb	sl, [r6, #494]	@ zero_extendqisi2
1139:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4534              		.loc 1 1139 0
 4535 26d4 4031C4E5 		strb	r3, [r4, #320]
1138:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4536              		.loc 1 1138 0
 4537 26d8 1DA1C4E5 		strb	sl, [r4, #285]
1135:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4538              		.loc 1 1135 0
 4539 26dc A003A0E1 		mov	r0, r0, lsr #7
 4540              	.LVL420:
1136:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4541              		.loc 1 1136 0
 4542 26e0 037080E0 		add	r7, r0, r3
 4543              	.LVL421:
 4544 26e4 FF7007E2 		and	r7, r7, #255
 4545              	.LVL422:
 4546 26e8 1C71C4E5 		strb	r7, [r4, #284]
1137:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4547              		.loc 1 1137 0
 4548 26ec ED71C6E5 		strb	r7, [r6, #493]
1144:../uvc.c      **** 					 break;
 4549              		.loc 1 1144 0
 4550 26f0 86FBFFEA 		b	.L183
 4551              	.LVL423:
 4552              	.L210:
1064:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 4553              		.loc 1 1064 0
 4554 26f4 0A00A0E1 		mov	r0, sl
 4555              	.LVL424:
 4556 26f8 0910A0E1 		mov	r1, r9
 4557 26fc FEFFFFEB 		bl	SensorGetControl
1068:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4558              		.loc 1 1068 0
 4559 2700 0130A0E3 		mov	r3, #1
 4560 2704 3C31C4E5 		strb	r3, [r4, #316]
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4561              		.loc 1 1065 0
 4562 2708 037000E0 		and	r7, r0, r3
 4563              	.LVL425:
1066:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4564              		.loc 1 1066 0
 4565 270c 0575C6E5 		strb	r7, [r6, #1285]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4566              		.loc 1 1067 0
 4567 2710 0605D6E5 		ldrb	r0, [r6, #1286]	@ zero_extendqisi2
1065:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4568              		.loc 1 1065 0
 4569 2714 1C71C4E5 		strb	r7, [r4, #284]
1067:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4570              		.loc 1 1067 0
 4571 2718 FFA000E2 		and	sl, r0, #255
 4572              	.LVL426:
 4573 271c 1DA1C4E5 		strb	sl, [r4, #285]
1072:../uvc.c      **** 					 break;
 4574              		.loc 1 1072 0
 4575 2720 7AFBFFEA 		b	.L183
 4576              	.LVL427:
 4577              	.L323:
1010:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4578              		.loc 1 1010 0
 4579 2724 0A00A0E1 		mov	r0, sl
 4580 2728 0910A0E1 		mov	r1, r9
 4581 272c FEFFFFEB 		bl	SensorGetControl
 4582              	.LVL428:
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4583              		.loc 1 1012 0
 4584 2730 0170A0E3 		mov	r7, #1
 4585              	.LVL429:
 4586 2734 3D71C4E5 		strb	r7, [r4, #317]
1011:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4587              		.loc 1 1011 0
 4588 2738 A501C6E5 		strb	r0, [r6, #421]
 4589 273c DCFBFFEA 		b	.L203
 4590              	.LVL430:
 4591              	.L190:
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4592              		.loc 1 898 0
 4593 2740 FEFFFFEB 		bl	SensorGetControl
 4594              	.LVL431:
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4595              		.loc 1 904 0
 4596 2744 00181FE5 		ldr	r1, .L329+60
 899:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4597              		.loc 1 899 0
 4598 2748 C504C6E5 		strb	r0, [r6, #1221]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4599              		.loc 1 902 0
 4600 274c C664D6E5 		ldrb	r6, [r6, #1222]	@ zero_extendqisi2
 898:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 4601              		.loc 1 898 0
 4602 2750 0070A0E1 		mov	r7, r0
 4603              	.LVL432:
 900:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4604              		.loc 1 900 0
 4605 2754 700000E2 		and	r0, r0, #112
 4606              	.LVL433:
 4607 2758 20C2A0E1 		mov	ip, r0, lsr #4
 4608              	.LVL434:
 901:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4609              		.loc 1 901 0
 4610 275c 1CC1C4E5 		strb	ip, [r4, #284]
 902:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4611              		.loc 1 902 0
 4612 2760 1D61C4E5 		strb	r6, [r4, #285]
 904:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 4613              		.loc 1 904 0
 4614 2764 0C20A0E1 		mov	r2, ip
 4615 2768 0C30A0E1 		mov	r3, ip
 4616 276c 0400A0E3 		mov	r0, #4
 4617 2770 00708DE5 		str	r7, [sp, #0]
 4618 2774 14C08DE5 		str	ip, [sp, #20]
 4619 2778 FEFFFFEB 		bl	CyU3PDebugPrint
 4620              	.LVL435:
 4621 277c 1C71D4E5 		ldrb	r7, [r4, #284]	@ zero_extendqisi2
 4622              	.LVL436:
 4623 2780 14C09DE5 		ldr	ip, [sp, #20]
 4624 2784 19FCFFEA 		b	.L191
 4625              	.LVL437:
 4626              	.L264:
1376:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4627              		.loc 1 1376 0
 4628 2788 0A20A0E1 		mov	r2, sl
 4629 278c 0730A0E1 		mov	r3, r7
 4630 2790 80E0A0E3 		mov	lr, #128
 4631 2794 00C0A0E3 		mov	ip, #0
 4632 2798 1B10A0E3 		mov	r1, #27
 4633 279c 54081FE5 		ldr	r0, .L329+64
 4634 27a0 00E08DE5 		str	lr, [sp, #0]
 4635 27a4 04C08DE5 		str	ip, [sp, #4]
 4636 27a8 FEFFFFEB 		bl	cmdSet
 4637              	.LVL438:
1378:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
 4638              		.loc 1 1378 0
 4639 27ac 0820A0E1 		mov	r2, r8
 4640 27b0 18809DE5 		ldr	r8, [sp, #24]
 4641              	.LVL439:
 4642 27b4 01A0A0E3 		mov	sl, #1
 4643              	.LVL440:
 4644 27b8 1B10A0E3 		mov	r1, #27
 4645 27bc 0730A0E1 		mov	r3, r7
 4646 27c0 78081FE5 		ldr	r0, .L329+64
 4647 27c4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 4648 27c8 FEFFFFEB 		bl	cmdSet
 4649              	.LVL441:
 4650 27cc 87FCFFEA 		b	.L263
 4651              	.LVL442:
 4652              	.L322:
 935:../uvc.c      **** 						if(sendData >= 3){
 4653              		.loc 1 935 0
 4654 27d0 020057E3 		cmp	r7, #2
 4655 27d4 0D00008A 		bhi	.L328
 4656              	.LVL443:
 4657              	.L195:
 940:../uvc.c      **** 						sendData += 4;
 4658              		.loc 1 940 0
 4659 27d8 047087E2 		add	r7, r7, #4
 4660              	.LVL444:
 4661 27dc FF7007E2 		and	r7, r7, #255
 4662              	.LVL445:
 4663 27e0 69FBFFEA 		b	.L314
 4664              	.LVL446:
 4665              	.L327:
1351:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 4666              		.loc 1 1351 0
 4667 27e4 0830A0E1 		mov	r3, r8
 4668 27e8 1910A0E3 		mov	r1, #25
 4669 27ec 0080A0E3 		mov	r8, #0
 4670              	.LVL447:
 4671 27f0 0920A0E1 		mov	r2, r9
 4672 27f4 AC081FE5 		ldr	r0, .L329+64
 4673 27f8 00E08DE5 		str	lr, [sp, #0]
 4674 27fc 04808DE5 		str	r8, [sp, #4]
 4675 2800 FEFFFFEB 		bl	cmdSet
 4676              	.LVL448:
 4677 2804 14FEFFEA 		b	.L262
 4678              	.LVL449:
 4679              	.L313:
 4680 2808 B4081FE5 		ldr	r0, .L329+76
 4681 280c 29FBFFEA 		b	.L180
 4682              	.LVL450:
 4683              	.L328:
 936:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4684              		.loc 1 936 0
 4685 2810 0730A0E1 		mov	r3, r7
 4686 2814 0400A0E3 		mov	r0, #4
 4687              	.LVL451:
 4688 2818 CC181FE5 		ldr	r1, .L329+68
 4689 281c FEFFFFEB 		bl	CyU3PDebugPrint
 4690              	.LVL452:
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4691              		.loc 1 938 0
 4692 2820 D0081FE5 		ldr	r0, .L329+72
 4693 2824 0020A0E3 		mov	r2, #0
 937:../uvc.c      **** 							sendData = 0; //set back to default
 4694              		.loc 1 937 0
 4695 2828 0270A0E1 		mov	r7, r2
 938:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 4696              		.loc 1 938 0
 4697 282c 2D24C0E5 		strb	r2, [r0, #1069]
 4698 2830 E8FFFFEA 		b	.L195
 4699              	.LVL453:
 4700              	.L293:
 4701 2834 E0081FE5 		ldr	r0, .L329+76
 4702              	.LVL454:
 791:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 4703              		.loc 1 791 0
 4704 2838 0030A0E3 		mov	r3, #0
 4705 283c 16FBFFEA 		b	.L306
 4706              	.LVL455:
 4707              	.L295:
 4708 2840 0030A0E3 		mov	r3, #0
 4709 2844 0CFCFFEA 		b	.L307
 4710              		.cfi_endproc
 4711              	.LFE3:
 4713              		.align	2
 4714              		.global	CTControlHandle
 4716              	CTControlHandle:
 4717              	.LFB4:
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4718              		.loc 1 1715 0
 4719              		.cfi_startproc
 4720              		@ args = 0, pretend = 0, frame = 64
 4721              		@ frame_needed = 0, uses_anonymous_args = 0
 4722              	.LVL456:
 4723 2848 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 4724              	.LCFI18:
 4725              		.cfi_def_cfa_offset 36
1734:../uvc.c      ****     reqData = bRequest;
 4726              		.loc 1 1734 0
 4727 284c 64A99FE5 		ldr	sl, .L416
 4728              		.cfi_offset 14, -4
 4729              		.cfi_offset 11, -8
 4730              		.cfi_offset 10, -12
 4731              		.cfi_offset 9, -16
 4732              		.cfi_offset 8, -20
 4733              		.cfi_offset 7, -24
 4734              		.cfi_offset 6, -28
 4735              		.cfi_offset 5, -32
 4736              		.cfi_offset 4, -36
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4737              		.loc 1 1726 0
 4738 2850 64899FE5 		ldr	r8, .L416+4
1734:../uvc.c      ****     reqData = bRequest;
 4739              		.loc 1 1734 0
 4740 2854 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4741              		.loc 1 1726 0
 4742 2858 8090A0E1 		mov	r9, r0, asl #1
 4743 285c 002089E0 		add	r2, r9, r0
 4744 2860 822188E0 		add	r2, r8, r2, asl #3
1736:../uvc.c      ****     switch (bRequest)
 4745              		.loc 1 1736 0
 4746 2864 830055E3 		cmp	r5, #131
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4747              		.loc 1 1715 0
 4748 2868 5CD04DE2 		sub	sp, sp, #92
 4749              	.LCFI19:
 4750              		.cfi_def_cfa_offset 128
1715:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 4751              		.loc 1 1715 0
 4752 286c 0060A0E1 		mov	r6, r0
1726:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 4753              		.loc 1 1726 0
 4754 2870 2F35D2E5 		ldrb	r3, [r2, #1327]	@ zero_extendqisi2
 4755              	.LVL457:
1727:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 4756              		.loc 1 1727 0
 4757 2874 20B5D2E5 		ldrb	fp, [r2, #1312]	@ zero_extendqisi2
 4758              	.LVL458:
1729:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 4759              		.loc 1 1729 0
 4760 2878 2275D2E5 		ldrb	r7, [r2, #1314]	@ zero_extendqisi2
 4761              	.LVL459:
1736:../uvc.c      ****     switch (bRequest)
 4762              		.loc 1 1736 0
 4763 287c 7600000A 		beq	.L336
 4764 2880 2100009A 		bls	.L411
 4765 2884 850055E3 		cmp	r5, #133
 4766 2888 5900000A 		beq	.L338
 4767 288c 4E00003A 		bcc	.L337
 4768 2890 860055E3 		cmp	r5, #134
 4769 2894 8000000A 		beq	.L339
 4770 2898 870055E3 		cmp	r5, #135
 4771 289c 7600000A 		beq	.L412
 4772              	.L332:
1943:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 4773              		.loc 1 1943 0
 4774 28a0 0000A0E3 		mov	r0, #0
 4775              	.LVL460:
 4776 28a4 0110A0E3 		mov	r1, #1
 4777 28a8 0020A0E1 		mov	r2, r0
 4778 28ac FEFFFFEB 		bl	CyU3PUsbStall
 4779              	.LVL461:
 4780 28b0 08499FE5 		ldr	r4, .L416+8
1944:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 4781              		.loc 1 1944 0
 4782 28b4 0620A0E1 		mov	r2, r6
 4783 28b8 0400A0E3 		mov	r0, #4
 4784 28bc 00199FE5 		ldr	r1, .L416+12
 4785 28c0 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 4786 28c4 FEFFFFEB 		bl	CyU3PDebugPrint
1945:../uvc.c      **** 			  break;
 4787              		.loc 1 1945 0
 4788 28c8 FFC0A0E3 		mov	ip, #255
 4789 28cc 0C60A0E1 		mov	r6, ip
 4790 28d0 0C80A0E1 		mov	r8, ip
 4791              	.LVL462:
 4792              	.L342:
1949:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 4793              		.loc 1 1949 0
 4794 28d4 1EE1D4E5 		ldrb	lr, [r4, #286]	@ zero_extendqisi2
 4795 28d8 08C08DE5 		str	ip, [sp, #8]
 4796 28dc E4189FE5 		ldr	r1, .L416+16
 4797 28e0 FFC0A0E3 		mov	ip, #255
 4798 28e4 0520A0E1 		mov	r2, r5
 4799 28e8 0830A0E1 		mov	r3, r8
 4800 28ec 0400A0E3 		mov	r0, #4
 4801 28f0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 4802 28f4 0CC08DE5 		str	ip, [sp, #12]
 4803 28f8 10E08DE5 		str	lr, [sp, #16]
 4804 28fc 14708DE5 		str	r7, [sp, #20]
 4805 2900 FEFFFFEB 		bl	CyU3PDebugPrint
1950:../uvc.c      **** }
 4806              		.loc 1 1950 0
 4807 2904 5CD08DE2 		add	sp, sp, #92
 4808 2908 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 4809              	.LVL463:
 4810              	.L411:
1736:../uvc.c      ****     switch (bRequest)
 4811              		.loc 1 1736 0
 4812 290c 810055E3 		cmp	r5, #129
 4813 2910 4200000A 		beq	.L334
 4814 2914 1100009A 		bls	.L413
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4815              		.loc 1 1765 0
 4816 2918 A0489FE5 		ldr	r4, .L416+8
 4817 291c 2315D2E5 		ldrb	r1, [r2, #1315]	@ zero_extendqisi2
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4818              		.loc 1 1766 0
 4819 2920 2465D2E5 		ldrb	r6, [r2, #1316]	@ zero_extendqisi2
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4820              		.loc 1 1767 0
 4821 2924 0A0050E3 		cmp	r0, #10
1765:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 4822              		.loc 1 1765 0
 4823 2928 1C11C4E5 		strb	r1, [r4, #284]
1766:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 4824              		.loc 1 1766 0
 4825 292c 1D61C4E5 		strb	r6, [r4, #285]
1767:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 4826              		.loc 1 1767 0
 4827 2930 2C00000A 		beq	.L410
 4828              	.LVL464:
 4829              	.L349:
1801:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 4830              		.loc 1 1801 0
 4831 2934 00E0A0E3 		mov	lr, #0
 4832 2938 1EE1C4E5 		strb	lr, [r4, #286]
 4833              	.L350:
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4834              		.loc 1 1802 0
 4835 293c 0030A0E3 		mov	r3, #0
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4836              		.loc 1 1803 0
 4837 2940 0700A0E1 		mov	r0, r7
 4838              	.LVL465:
 4839 2944 80189FE5 		ldr	r1, .L416+20
1805:../uvc.c      **** 			  break;
 4840              		.loc 1 1805 0
 4841 2948 FF60A0E3 		mov	r6, #255
1802:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 4842              		.loc 1 1802 0
 4843 294c 1F31C4E5 		strb	r3, [r4, #287]
1805:../uvc.c      **** 			  break;
 4844              		.loc 1 1805 0
 4845 2950 0680A0E1 		mov	r8, r6
1803:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4846              		.loc 1 1803 0
 4847 2954 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4848              	.LVL466:
 4849 2958 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1805:../uvc.c      **** 			  break;
 4850              		.loc 1 1805 0
 4851 295c DCFFFFEA 		b	.L342
 4852              	.LVL467:
 4853              	.L413:
1736:../uvc.c      ****     switch (bRequest)
 4854              		.loc 1 1736 0
 4855 2960 010055E3 		cmp	r5, #1
 4856 2964 CDFFFF1A 		bne	.L332
1807:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4857              		.loc 1 1807 0
 4858 2968 50489FE5 		ldr	r4, .L416+8
 4859 296c 56208DE2 		add	r2, sp, #86
 4860 2970 2000A0E3 		mov	r0, #32
 4861              	.LVL468:
 4862 2974 471F84E2 		add	r1, r4, #284
 4863 2978 2C308DE5 		str	r3, [sp, #44]
 4864 297c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4865              	.LVL469:
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4866              		.loc 1 1809 0
 4867 2980 1C01D4E5 		ldrb	r0, [r4, #284]	@ zero_extendqisi2
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4868              		.loc 1 1810 0
 4869 2984 1DC1D4E5 		ldrb	ip, [r4, #285]	@ zero_extendqisi2
1813:../uvc.c      **** 			  switch(CtrlID)
 4870              		.loc 1 1813 0
 4871 2988 012046E2 		sub	r2, r6, #1
1809:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 4872              		.loc 1 1809 0
 4873 298c 30008DE5 		str	r0, [sp, #48]
 4874              	.LVL470:
1810:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 4875              		.loc 1 1810 0
 4876 2990 34C08DE5 		str	ip, [sp, #52]
 4877              	.LVL471:
1813:../uvc.c      **** 			  switch(CtrlID)
 4878              		.loc 1 1813 0
 4879 2994 2C309DE5 		ldr	r3, [sp, #44]
 4880 2998 090052E3 		cmp	r2, #9
 4881 299c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4882 29a0 550100EA 		b	.L351
 4883              	.L356:
 4884 29a4 B82E0000 		.word	.L352
 4885 29a8 FC2E0000 		.word	.L351
 4886 29ac C82B0000 		.word	.L353
 4887 29b0 FC2E0000 		.word	.L351
 4888 29b4 FC2E0000 		.word	.L351
 4889 29b8 FC2E0000 		.word	.L351
 4890 29bc 442B0000 		.word	.L354
 4891 29c0 FC2E0000 		.word	.L351
 4892 29c4 FC2E0000 		.word	.L351
 4893 29c8 C82A0000 		.word	.L355
 4894              	.LVL472:
 4895              	.L337:
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4896              		.loc 1 1783 0
 4897 29cc EC479FE5 		ldr	r4, .L416+8
 4898 29d0 2785D2E5 		ldrb	r8, [r2, #1319]	@ zero_extendqisi2
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4899              		.loc 1 1784 0
 4900 29d4 2825D2E5 		ldrb	r2, [r2, #1320]	@ zero_extendqisi2
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4901              		.loc 1 1785 0
 4902 29d8 0A0050E3 		cmp	r0, #10
1783:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 4903              		.loc 1 1783 0
 4904 29dc 1C81C4E5 		strb	r8, [r4, #284]
1784:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 4905              		.loc 1 1784 0
 4906 29e0 1D21C4E5 		strb	r2, [r4, #285]
1785:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4907              		.loc 1 1785 0
 4908 29e4 D2FFFF1A 		bne	.L349
 4909              	.LVL473:
 4910              	.L410:
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4911              		.loc 1 1800 0 discriminator 1
 4912 29e8 0110A0E3 		mov	r1, #1
 4913 29ec 1E11C4E5 		strb	r1, [r4, #286]
 4914 29f0 D1FFFFEA 		b	.L350
 4915              	.LVL474:
 4916              	.L338:
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4917              		.loc 1 1740 0
 4918 29f4 C4479FE5 		ldr	r4, .L416+8
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4919              		.loc 1 1741 0
 4920 29f8 0030A0E3 		mov	r3, #0
 4921              	.LVL475:
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4922              		.loc 1 1742 0
 4923 29fc 0200A0E3 		mov	r0, #2
 4924              	.LVL476:
 4925 2a00 471F84E2 		add	r1, r4, #284
1744:../uvc.c      **** 			  break;
 4926              		.loc 1 1744 0
 4927 2a04 FF60A0E3 		mov	r6, #255
1740:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 4928              		.loc 1 1740 0
 4929 2a08 1C71C4E5 		strb	r7, [r4, #284]
1741:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 4930              		.loc 1 1741 0
 4931 2a0c 1D31C4E5 		strb	r3, [r4, #285]
1744:../uvc.c      **** 			  break;
 4932              		.loc 1 1744 0
 4933 2a10 0680A0E1 		mov	r8, r6
1742:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4934              		.loc 1 1742 0
 4935 2a14 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4936              	.LVL477:
 4937 2a18 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1744:../uvc.c      **** 			  break;
 4938              		.loc 1 1744 0
 4939 2a1c ACFFFFEA 		b	.L342
 4940              	.LVL478:
 4941              	.L334:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4942              		.loc 1 1750 0
 4943 2a20 98479FE5 		ldr	r4, .L416+8
 4944 2a24 2DA5D2E5 		ldrb	sl, [r2, #1325]	@ zero_extendqisi2
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4945              		.loc 1 1751 0
 4946 2a28 2EC5D2E5 		ldrb	ip, [r2, #1326]	@ zero_extendqisi2
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4947              		.loc 1 1752 0
 4948 2a2c 0080A0E3 		mov	r8, #0
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4949              		.loc 1 1758 0
 4950 2a30 0700A0E1 		mov	r0, r7
 4951              	.LVL479:
 4952 2a34 471F84E2 		add	r1, r4, #284
1763:../uvc.c      **** 			  break;
 4953              		.loc 1 1763 0
 4954 2a38 FF60A0E3 		mov	r6, #255
1751:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 4955              		.loc 1 1751 0
 4956 2a3c 1DC1C4E5 		strb	ip, [r4, #285]
1752:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 4957              		.loc 1 1752 0
 4958 2a40 1E81C4E5 		strb	r8, [r4, #286]
1753:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 4959              		.loc 1 1753 0
 4960 2a44 1F81C4E5 		strb	r8, [r4, #287]
 4961              	.LVL480:
1750:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 4962              		.loc 1 1750 0
 4963 2a48 1CA1C4E5 		strb	sl, [r4, #284]
1763:../uvc.c      **** 			  break;
 4964              		.loc 1 1763 0
 4965 2a4c 0680A0E1 		mov	r8, r6
1758:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 4966              		.loc 1 1758 0
 4967 2a50 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4968              	.LVL481:
 4969 2a54 0AC0A0E1 		mov	ip, sl
1763:../uvc.c      **** 			  break;
 4970              		.loc 1 1763 0
 4971 2a58 9DFFFFEA 		b	.L342
 4972              	.LVL482:
 4973              	.L336:
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4974              		.loc 1 1774 0
 4975 2a5c 5C479FE5 		ldr	r4, .L416+8
 4976 2a60 2535D2E5 		ldrb	r3, [r2, #1317]	@ zero_extendqisi2
 4977              	.LVL483:
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4978              		.loc 1 1775 0
 4979 2a64 26E5D2E5 		ldrb	lr, [r2, #1318]	@ zero_extendqisi2
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4980              		.loc 1 1776 0
 4981 2a68 0A0050E3 		cmp	r0, #10
1774:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 4982              		.loc 1 1774 0
 4983 2a6c 1C31C4E5 		strb	r3, [r4, #284]
1775:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 4984              		.loc 1 1775 0
 4985 2a70 1DE1C4E5 		strb	lr, [r4, #285]
1776:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4986              		.loc 1 1776 0
 4987 2a74 AEFFFF1A 		bne	.L349
 4988 2a78 DAFFFFEA 		b	.L410
 4989              	.LVL484:
 4990              	.L412:
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4991              		.loc 1 1798 0
 4992 2a7c 3C479FE5 		ldr	r4, .L416+8
 4993 2a80 2B65D2E5 		ldrb	r6, [r2, #1323]	@ zero_extendqisi2
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 4994              		.loc 1 1799 0
 4995 2a84 2CC5D2E5 		ldrb	ip, [r2, #1324]	@ zero_extendqisi2
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 4996              		.loc 1 1800 0
 4997 2a88 0A0050E3 		cmp	r0, #10
1798:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 4998              		.loc 1 1798 0
 4999 2a8c 1C61C4E5 		strb	r6, [r4, #284]
1799:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5000              		.loc 1 1799 0
 5001 2a90 1DC1C4E5 		strb	ip, [r4, #285]
1800:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5002              		.loc 1 1800 0
 5003 2a94 A6FFFF1A 		bne	.L349
 5004 2a98 D2FFFFEA 		b	.L410
 5005              	.L339:
1792:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 5006              		.loc 1 1792 0
 5007 2a9c 1C479FE5 		ldr	r4, .L416+8
 5008 2aa0 2905D2E5 		ldrb	r0, [r2, #1321]	@ zero_extendqisi2
 5009              	.LVL485:
 5010 2aa4 0410A0E1 		mov	r1, r4
 5011 2aa8 1C01E1E5 		strb	r0, [r1, #284]!
1796:../uvc.c      **** 			  break;
 5012              		.loc 1 1796 0
 5013 2aac FF60A0E3 		mov	r6, #255
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5014              		.loc 1 1793 0
 5015 2ab0 0100A0E3 		mov	r0, #1
 5016 2ab4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5017              	.LVL486:
1796:../uvc.c      **** 			  break;
 5018              		.loc 1 1796 0
 5019 2ab8 0680A0E1 		mov	r8, r6
1793:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5020              		.loc 1 1793 0
 5021 2abc 1CC1D4E5 		ldrb	ip, [r4, #284]	@ zero_extendqisi2
1796:../uvc.c      **** 			  break;
 5022              		.loc 1 1796 0
 5023 2ac0 0170A0E3 		mov	r7, #1
 5024 2ac4 82FFFFEA 		b	.L342
 5025              	.LVL487:
 5026              	.L355:
1922:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5027              		.loc 1 1922 0
 5028 2ac8 00679FE5 		ldr	r6, .L416+24
 5029 2acc 0010E0E3 		mvn	r1, #0
 5030 2ad0 1C0096E5 		ldr	r0, [r6, #28]
 5031 2ad4 2C308DE5 		str	r3, [sp, #44]
 5032 2ad8 FEFFFFEB 		bl	_txe_mutex_get
1923:../uvc.c      **** 					  if(getData == 1)
 5033              		.loc 1 1923 0
 5034 2adc 30E09DE5 		ldr	lr, [sp, #48]
 5035 2ae0 2C309DE5 		ldr	r3, [sp, #44]
 5036 2ae4 01005EE3 		cmp	lr, #1
 5037 2ae8 AA01000A 		beq	.L414
1925:../uvc.c      **** 					  else if(getData == 0xff)
 5038              		.loc 1 1925 0
 5039 2aec FF005EE3 		cmp	lr, #255
 5040 2af0 9F01000A 		beq	.L415
1928:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
 5041              		.loc 1 1928 0
 5042 2af4 0080A0E3 		mov	r8, #0
 5043 2af8 0600A0E1 		mov	r0, r6
 5044 2afc 2310A0E3 		mov	r1, #35
 5045 2b00 0B20A0E1 		mov	r2, fp
 5046 2b04 00808DE5 		str	r8, [sp, #0]
 5047 2b08 04808DE5 		str	r8, [sp, #4]
 5048 2b0c FEFFFFEB 		bl	cmdSet
 5049              	.L408:
1931:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5050              		.loc 1 1931 0
 5051 2b10 1C0096E5 		ldr	r0, [r6, #28]
 5052 2b14 FEFFFFEB 		bl	_txe_mutex_put
1933:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 5053              		.loc 1 1933 0
 5054 2b18 30809DE5 		ldr	r8, [sp, #48]
 5055 2b1c 34609DE5 		ldr	r6, [sp, #52]
 5056 2b20 1EC1D4E5 		ldrb	ip, [r4, #286]	@ zero_extendqisi2
 5057 2b24 0400A0E3 		mov	r0, #4
 5058 2b28 A4169FE5 		ldr	r1, .L416+28
 5059 2b2c 0820A0E1 		mov	r2, r8
 5060 2b30 0630A0E1 		mov	r3, r6
 5061 2b34 00C08DE5 		str	ip, [sp, #0]
 5062 2b38 FEFFFFEB 		bl	CyU3PDebugPrint
1934:../uvc.c      **** 					  break;
 5063              		.loc 1 1934 0
 5064 2b3c FFC0A0E3 		mov	ip, #255
 5065 2b40 63FFFFEA 		b	.L342
 5066              	.LVL488:
 5067              	.L354:
1899:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 5068              		.loc 1 1899 0
 5069 2b44 4585D8E5 		ldrb	r8, [r8, #1349]	@ zero_extendqisi2
 5070 2b48 010058E3 		cmp	r8, #1
 5071 2b4c 08005813 		cmpne	r8, #8
 5072 2b50 0000A013 		movne	r0, #0
 5073 2b54 0100A003 		moveq	r0, #1
 5074 2b58 8101001A 		bne	.L405
 5075              	.LVL489:
1902:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5076              		.loc 1 1902 0
 5077 2b5c 6C869FE5 		ldr	r8, .L416+24
 5078 2b60 0010E0E3 		mvn	r1, #0
 5079 2b64 1C0098E5 		ldr	r0, [r8, #28]
 5080 2b68 2C308DE5 		str	r3, [sp, #44]
 5081 2b6c FEFFFFEB 		bl	_txe_mutex_get
1903:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5082              		.loc 1 1903 0
 5083 2b70 30A09DE5 		ldr	sl, [sp, #48]
 5084 2b74 2210A0E3 		mov	r1, #34
 5085 2b78 0B20A0E1 		mov	r2, fp
 5086 2b7c 2C309DE5 		ldr	r3, [sp, #44]
 5087 2b80 00C0A0E3 		mov	ip, #0
 5088 2b84 0800A0E1 		mov	r0, r8
 5089 2b88 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 5090 2b8c FEFFFFEB 		bl	cmdSet
1904:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5091              		.loc 1 1904 0
 5092 2b90 1C0098E5 		ldr	r0, [r8, #28]
 5093 2b94 FEFFFFEB 		bl	_txe_mutex_put
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5094              		.loc 1 1907 0
 5095 2b98 1C069FE5 		ldr	r0, .L416+4
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5096              		.loc 1 1908 0
 5097 2b9c 34209DE5 		ldr	r2, [sp, #52]
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5098              		.loc 1 1907 0
 5099 2ba0 061089E0 		add	r1, r9, r6
 5100 2ba4 813180E0 		add	r3, r0, r1, asl #3
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5101              		.loc 1 1909 0
 5102 2ba8 0160A0E3 		mov	r6, #1
1907:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 5103              		.loc 1 1907 0
 5104 2bac 2DA5C3E5 		strb	sl, [r3, #1325]
1908:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5105              		.loc 1 1908 0
 5106 2bb0 2E25C3E5 		strb	r2, [r3, #1326]
1909:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5107              		.loc 1 1909 0
 5108 2bb4 3065C3E5 		strb	r6, [r3, #1328]
 5109              	.LVL490:
 5110              	.L406:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5111              		.loc 1 1911 0
 5112 2bb8 1C81D4E5 		ldrb	r8, [r4, #284]	@ zero_extendqisi2
 5113 2bbc 1D61D4E5 		ldrb	r6, [r4, #285]	@ zero_extendqisi2
1916:../uvc.c      **** 					  break;
 5114              		.loc 1 1916 0
 5115 2bc0 FFC0A0E3 		mov	ip, #255
 5116 2bc4 42FFFFEA 		b	.L342
 5117              	.LVL491:
 5118              	.L353:
1865:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5119              		.loc 1 1865 0
 5120 2bc8 4505D8E5 		ldrb	r0, [r8, #1349]	@ zero_extendqisi2
 5121 2bcc 010050E3 		cmp	r0, #1
 5122 2bd0 04005013 		cmpne	r0, #4
 5123 2bd4 5D01001A 		bne	.L363
1864:../uvc.c      **** 					  value = (value << 8)|Data0;
 5124              		.loc 1 1864 0
 5125 2bd8 30109DE5 		ldr	r1, [sp, #48]
 5126 2bdc 34E09DE5 		ldr	lr, [sp, #52]
 5127 2be0 0E2481E1 		orr	r2, r1, lr, asl #8
1866:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5128              		.loc 1 1866 0
 5129 2be4 F90052E3 		cmp	r2, #249
 5130 2be8 5801008A 		bhi	.L363
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5131              		.loc 1 1871 0
 5132 2bec C8A042E2 		sub	sl, r2, #200
 5133 2bf0 0AC8A0E1 		mov	ip, sl, asl #16
 5134 2bf4 3CC08DE5 		str	ip, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5135              		.loc 1 1873 0
 5136 2bf8 27A062E2 		rsb	sl, r2, #39
 5137 2bfc 38A08DE5 		str	sl, [sp, #56]
 5138 2c00 3CA09DE5 		ldr	sl, [sp, #60]
 5139 2c04 C81062E2 		rsb	r1, r2, #200
 5140 2c08 C80052E3 		cmp	r2, #200
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5141              		.loc 1 1871 0
 5142 2c0c 640042E2 		sub	r0, r2, #100
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5143              		.loc 1 1873 0
 5144 2c10 0118A0E1 		mov	r1, r1, asl #16
 5145 2c14 64E062E2 		rsb	lr, r2, #100
 5146 2c18 2A18A081 		movhi	r1, sl, lsr #16
 5147 2c1c 2118A091 		movls	r1, r1, lsr #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5148              		.loc 1 1871 0
 5149 2c20 00C8A0E1 		mov	ip, r0, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5150              		.loc 1 1873 0
 5151 2c24 640052E3 		cmp	r2, #100
 5152 2c28 0E08A0E1 		mov	r0, lr, asl #16
 5153 2c2c 2C08A081 		movhi	r0, ip, lsr #16
 5154 2c30 38C09DE5 		ldr	ip, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5155              		.loc 1 1871 0
 5156 2c34 14A042E2 		sub	sl, r2, #20
 5157 2c38 38A08DE5 		str	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5158              		.loc 1 1873 0
 5159 2c3c 2008A091 		movls	r0, r0, lsr #16
 5160 2c40 14A062E2 		rsb	sl, r2, #20
 5161 2c44 3CA08DE5 		str	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5162              		.loc 1 1871 0
 5163 2c48 27E042E2 		sub	lr, r2, #39
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5164              		.loc 1 1873 0
 5165 2c4c 000051E1 		cmp	r1, r0
 5166 2c50 01A0A031 		movcc	sl, r1
 5167 2c54 00A0A021 		movcs	sl, r0
 5168 2c58 0CC8A0E1 		mov	ip, ip, asl #16
 5169 2c5c 270052E3 		cmp	r2, #39
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5170              		.loc 1 1871 0
 5171 2c60 0EE8A0E1 		mov	lr, lr, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5172              		.loc 1 1873 0
 5173 2c64 2CE8A091 		movls	lr, ip, lsr #16
 5174 2c68 68C59FE5 		ldr	ip, .L416+32
 5175 2c6c 20A08DE5 		str	sl, [sp, #32]
 5176 2c70 01A06CE0 		rsb	sl, ip, r1
 5177 2c74 2EE8A081 		movhi	lr, lr, lsr #16
 5178 2c78 00C07AE2 		rsbs	ip, sl, #0
 5179 2c7c 0AC0ACE0 		adc	ip, ip, sl
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5180              		.loc 1 1871 0
 5181 2c80 38A09DE5 		ldr	sl, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5182              		.loc 1 1873 0
 5183 2c84 44C08DE5 		str	ip, [sp, #68]
 5184              	.LVL492:
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5185              		.loc 1 1871 0
 5186 2c88 0AC8A0E1 		mov	ip, sl, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5187              		.loc 1 1873 0
 5188 2c8c 3CA09DE5 		ldr	sl, [sp, #60]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5189              		.loc 1 1871 0
 5190 2c90 4CC08DE5 		str	ip, [sp, #76]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5191              		.loc 1 1873 0
 5192 2c94 0AC8A0E1 		mov	ip, sl, asl #16
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5193              		.loc 1 1871 0
 5194 2c98 0AA042E2 		sub	sl, r2, #10
 5195 2c9c 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5196              		.loc 1 1873 0
 5197 2ca0 20A09DE5 		ldr	sl, [sp, #32]
 5198 2ca4 3CC08DE5 		str	ip, [sp, #60]
 5199 2ca8 0A005EE1 		cmp	lr, sl
 5200 2cac 0EA0A031 		movcc	sl, lr
 5201 2cb0 0AC062E2 		rsb	ip, r2, #10
 5202 2cb4 40C08DE5 		str	ip, [sp, #64]
 5203 2cb8 38A08DE5 		str	sl, [sp, #56]
 5204 2cbc 3CC09DE5 		ldr	ip, [sp, #60]
 5205 2cc0 4CA09DE5 		ldr	sl, [sp, #76]
 5206 2cc4 140052E3 		cmp	r2, #20
 5207 2cc8 2CA8A091 		movls	sl, ip, lsr #16
 5208 2ccc 2AA8A081 		movhi	sl, sl, lsr #16
 5209 2cd0 44C09DE5 		ldr	ip, [sp, #68]
 5210 2cd4 010050E1 		cmp	r0, r1
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5211              		.loc 1 1871 0
 5212 2cd8 48109DE5 		ldr	r1, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5213              		.loc 1 1873 0
 5214 2cdc 01C0A033 		movcc	ip, #1
 5215 2ce0 3CA08DE5 		str	sl, [sp, #60]
 5216 2ce4 24C08DE5 		str	ip, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5217              		.loc 1 1871 0
 5218 2ce8 01A8A0E1 		mov	sl, r1, asl #16
 5219 2cec 05C042E2 		sub	ip, r2, #5
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5220              		.loc 1 1873 0
 5221 2cf0 051062E2 		rsb	r1, r2, #5
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5222              		.loc 1 1871 0
 5223 2cf4 48A08DE5 		str	sl, [sp, #72]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5224              		.loc 1 1873 0
 5225 2cf8 40009DE5 		ldr	r0, [sp, #64]
 5226 2cfc 38A09DE5 		ldr	sl, [sp, #56]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5227              		.loc 1 1871 0
 5228 2d00 40C08DE5 		str	ip, [sp, #64]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5229              		.loc 1 1873 0
 5230 2d04 3CC09DE5 		ldr	ip, [sp, #60]
 5231 2d08 4C108DE5 		str	r1, [sp, #76]
 5232 2d0c 48109DE5 		ldr	r1, [sp, #72]
 5233 2d10 0008A0E1 		mov	r0, r0, asl #16
 5234 2d14 0A005CE1 		cmp	ip, sl
 5235 2d18 0AC0A021 		movcs	ip, sl
 5236 2d1c 0A0052E3 		cmp	r2, #10
 5237 2d20 20A09DE5 		ldr	sl, [sp, #32]
 5238 2d24 2108A081 		movhi	r0, r1, lsr #16
 5239 2d28 2008A091 		movls	r0, r0, lsr #16
 5240 2d2c 48008DE5 		str	r0, [sp, #72]
 5241 2d30 24009DE5 		ldr	r0, [sp, #36]
 5242 2d34 0A005EE1 		cmp	lr, sl
 5243 2d38 0200A033 		movcc	r0, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5244              		.loc 1 1871 0
 5245 2d3c 02E042E2 		sub	lr, r2, #2
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5246              		.loc 1 1873 0
 5247 2d40 44C08DE5 		str	ip, [sp, #68]
 5248 2d44 24008DE5 		str	r0, [sp, #36]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5249              		.loc 1 1871 0
 5250 2d48 40C09DE5 		ldr	ip, [sp, #64]
 5251 2d4c 1CE08DE5 		str	lr, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5252              		.loc 1 1873 0
 5253 2d50 44009DE5 		ldr	r0, [sp, #68]
 5254 2d54 48E09DE5 		ldr	lr, [sp, #72]
 5255 2d58 4C109DE5 		ldr	r1, [sp, #76]
 5256 2d5c 02A062E2 		rsb	sl, r2, #2
 5257 2d60 00005EE1 		cmp	lr, r0
 5258 2d64 00E0A021 		movcs	lr, r0
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5259              		.loc 1 1871 0
 5260 2d68 0CC8A0E1 		mov	ip, ip, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5261              		.loc 1 1873 0
 5262 2d6c 050052E3 		cmp	r2, #5
 5263 2d70 40A08DE5 		str	sl, [sp, #64]
 5264 2d74 0118A0E1 		mov	r1, r1, asl #16
 5265 2d78 3CA09DE5 		ldr	sl, [sp, #60]
 5266 2d7c 2C18A081 		movhi	r1, ip, lsr #16
 5267 2d80 38C09DE5 		ldr	ip, [sp, #56]
 5268 2d84 4CE08DE5 		str	lr, [sp, #76]
 5269 2d88 24009DE5 		ldr	r0, [sp, #36]
 5270 2d8c 40E09DE5 		ldr	lr, [sp, #64]
 5271 2d90 2118A091 		movls	r1, r1, lsr #16
 5272 2d94 0C005AE1 		cmp	sl, ip
 5273 2d98 20108DE5 		str	r1, [sp, #32]
 5274 2d9c 0300A033 		movcc	r0, #3
 5275 2da0 38008DE5 		str	r0, [sp, #56]
 5276 2da4 4CA09DE5 		ldr	sl, [sp, #76]
 5277 2da8 0E08A0E1 		mov	r0, lr, asl #16
 5278 2dac 20E09DE5 		ldr	lr, [sp, #32]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5279              		.loc 1 1871 0
 5280 2db0 1C109DE5 		ldr	r1, [sp, #28]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5281              		.loc 1 1873 0
 5282 2db4 0A005EE1 		cmp	lr, sl
 5283 2db8 0AE0A021 		movcs	lr, sl
 5284 2dbc 44C09DE5 		ldr	ip, [sp, #68]
 5285 2dc0 48A09DE5 		ldr	sl, [sp, #72]
 5286 2dc4 020052E3 		cmp	r2, #2
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5287              		.loc 1 1871 0
 5288 2dc8 0118A0E1 		mov	r1, r1, asl #16
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5289              		.loc 1 1873 0
 5290 2dcc 2018A091 		movls	r1, r0, lsr #16
 5291 2dd0 38009DE5 		ldr	r0, [sp, #56]
 5292 2dd4 2118A081 		movhi	r1, r1, lsr #16
 5293 2dd8 0C005AE1 		cmp	sl, ip
 5294 2ddc 0400A033 		movcc	r0, #4
 5295 2de0 40008DE5 		str	r0, [sp, #64]
1871:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 5296              		.loc 1 1871 0
 5297 2de4 010042E2 		sub	r0, r2, #1
 5298 2de8 38008DE5 		str	r0, [sp, #56]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5299              		.loc 1 1873 0
 5300 2dec 4CA09DE5 		ldr	sl, [sp, #76]
 5301 2df0 20009DE5 		ldr	r0, [sp, #32]
 5302 2df4 01C062E2 		rsb	ip, r2, #1
 5303 2df8 3CC08DE5 		str	ip, [sp, #60]
 5304 2dfc 0A0050E1 		cmp	r0, sl
1880:../uvc.c      **** 						  shutter = shutter+index;
 5305              		.loc 1 1880 0
 5306 2e00 38A09DE5 		ldr	sl, [sp, #56]
 5307 2e04 3C009DE5 		ldr	r0, [sp, #60]
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5308              		.loc 1 1873 0
 5309 2e08 40C09DE5 		ldr	ip, [sp, #64]
 5310 2e0c 05C0A033 		movcc	ip, #5
1880:../uvc.c      **** 						  shutter = shutter+index;
 5311              		.loc 1 1880 0
 5312 2e10 010052E3 		cmp	r2, #1
 5313 2e14 0028A091 		movls	r2, r0, asl #16
 5314 2e18 0A28A081 		movhi	r2, sl, asl #16
 5315 2e1c 0E0051E1 		cmp	r1, lr
 5316 2e20 01A0A031 		movcc	sl, r1
 5317 2e24 0EA0A021 		movcs	sl, lr
1873:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 5318              		.loc 1 1873 0
 5319 2e28 0E0051E1 		cmp	r1, lr
 5320 2e2c 0C10A021 		movcs	r1, ip
 5321 2e30 0610A033 		movcc	r1, #6
1880:../uvc.c      **** 						  shutter = shutter+index;
 5322              		.loc 1 1880 0
 5323 2e34 22085AE1 		cmp	sl, r2, lsr #16
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5324              		.loc 1 1883 0
 5325 2e38 90A39FE5 		ldr	sl, .L416+24
1880:../uvc.c      **** 						  shutter = shutter+index;
 5326              		.loc 1 1880 0
 5327 2e3c 0120A091 		movls	r2, r1
 5328 2e40 0720A083 		movhi	r2, #7
 5329 2e44 012082E2 		add	r2, r2, #1
 5330 2e48 FFE002E2 		and	lr, r2, #255
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5331              		.loc 1 1883 0
 5332 2e4c 0010E0E3 		mvn	r1, #0
 5333 2e50 1C009AE5 		ldr	r0, [sl, #28]
1880:../uvc.c      **** 						  shutter = shutter+index;
 5334              		.loc 1 1880 0
 5335 2e54 38E08DE5 		str	lr, [sp, #56]
 5336              	.LVL493:
1883:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5337              		.loc 1 1883 0
 5338 2e58 2C308DE5 		str	r3, [sp, #44]
 5339 2e5c FEFFFFEB 		bl	_txe_mutex_get
1884:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5340              		.loc 1 1884 0
 5341 2e60 38C09DE5 		ldr	ip, [sp, #56]
 5342 2e64 0310A0E3 		mov	r1, #3
 5343 2e68 0B20A0E1 		mov	r2, fp
 5344 2e6c 2C309DE5 		ldr	r3, [sp, #44]
 5345 2e70 00C08DE5 		str	ip, [sp, #0]
 5346 2e74 0A00A0E1 		mov	r0, sl
 5347 2e78 00C0A0E3 		mov	ip, #0
 5348 2e7c 04C08DE5 		str	ip, [sp, #4]
 5349 2e80 FEFFFFEB 		bl	cmdSet
1885:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5350              		.loc 1 1885 0
 5351 2e84 1C009AE5 		ldr	r0, [sl, #28]
 5352 2e88 FEFFFFEB 		bl	_txe_mutex_put
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5353              		.loc 1 1888 0
 5354 2e8c 30009DE5 		ldr	r0, [sp, #48]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5355              		.loc 1 1889 0
 5356 2e90 34C09DE5 		ldr	ip, [sp, #52]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5357              		.loc 1 1891 0
 5358 2e94 38309DE5 		ldr	r3, [sp, #56]
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5359              		.loc 1 1888 0
 5360 2e98 061089E0 		add	r1, r9, r6
 5361 2e9c 816188E0 		add	r6, r8, r1, asl #3
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5362              		.loc 1 1890 0
 5363 2ea0 0120A0E3 		mov	r2, #1
1888:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 5364              		.loc 1 1888 0
 5365 2ea4 2D05C6E5 		strb	r0, [r6, #1325]
1889:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5366              		.loc 1 1889 0
 5367 2ea8 2EC5C6E5 		strb	ip, [r6, #1326]
1890:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5368              		.loc 1 1890 0
 5369 2eac 3025C6E5 		strb	r2, [r6, #1328]
1891:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5370              		.loc 1 1891 0
 5371 2eb0 0D33C8E5 		strb	r3, [r8, #781]
 5372 2eb4 3FFFFFEA 		b	.L406
 5373              	.LVL494:
 5374              	.L352:
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5375              		.loc 1 1818 0
 5376 2eb8 062089E0 		add	r2, r9, r6
 5377 2ebc 826188E0 		add	r6, r8, r2, asl #3
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5378              		.loc 1 1819 0
 5379 2ec0 0110A0E3 		mov	r1, #1
1822:../uvc.c      **** 		  		    switch (getData){
 5380              		.loc 1 1822 0
 5381 2ec4 01E040E2 		sub	lr, r0, #1
1818:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 5382              		.loc 1 1818 0
 5383 2ec8 2D05C6E5 		strb	r0, [r6, #1325]
1819:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5384              		.loc 1 1819 0
 5385 2ecc 3015C6E5 		strb	r1, [r6, #1328]
 5386              	.LVL495:
1822:../uvc.c      **** 		  		    switch (getData){
 5387              		.loc 1 1822 0
 5388 2ed0 07005EE3 		cmp	lr, #7
 5389 2ed4 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 5390 2ed8 980000EA 		b	.L357
 5391              	.L362:
 5392 2edc D4300000 		.word	.L358
 5393 2ee0 38300000 		.word	.L359
 5394 2ee4 40310000 		.word	.L357
 5395 2ee8 D02F0000 		.word	.L360
 5396 2eec 40310000 		.word	.L357
 5397 2ef0 40310000 		.word	.L357
 5398 2ef4 40310000 		.word	.L357
 5399 2ef8 302F0000 		.word	.L361
 5400              	.LVL496:
 5401              	.L351:
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5402              		.loc 1 1938 0
 5403 2efc 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5404              		.loc 1 1937 0
 5405 2f00 30A09DE5 		ldr	sl, [sp, #48]
 5406 2f04 069089E0 		add	r9, r9, r6
 5407 2f08 89E188E0 		add	lr, r8, r9, asl #3
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5408              		.loc 1 1938 0
 5409 2f0c 0620A0E1 		mov	r2, r6
 5410 2f10 0400A0E3 		mov	r0, #4
 5411 2f14 C0129FE5 		ldr	r1, .L416+36
1937:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 5412              		.loc 1 1937 0
 5413 2f18 2DA5CEE5 		strb	sl, [lr, #1325]
1938:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5414              		.loc 1 1938 0
 5415 2f1c FEFFFFEB 		bl	CyU3PDebugPrint
1939:../uvc.c      **** 			  		 break;
 5416              		.loc 1 1939 0
 5417 2f20 FFC0A0E3 		mov	ip, #255
 5418 2f24 0C60A0E1 		mov	r6, ip
 5419 2f28 0C80A0E1 		mov	r8, ip
 5420 2f2c 68FEFFEA 		b	.L342
 5421              	.LVL497:
 5422              	.L361:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5423              		.loc 1 1841 0
 5424 2f30 98629FE5 		ldr	r6, .L416+24
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5425              		.loc 1 1839 0
 5426 2f34 00A0A0E3 		mov	sl, #0
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5427              		.loc 1 1841 0
 5428 2f38 1C0096E5 		ldr	r0, [r6, #28]
1839:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5429              		.loc 1 1839 0
 5430 2f3c 0DA3C8E5 		strb	sl, [r8, #781]
 5431              	.LVL498:
1841:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5432              		.loc 1 1841 0
 5433 2f40 0010E0E3 		mvn	r1, #0
 5434 2f44 2C308DE5 		str	r3, [sp, #44]
 5435 2f48 FEFFFFEB 		bl	_txe_mutex_get
1842:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5436              		.loc 1 1842 0
 5437 2f4c 0B20A0E1 		mov	r2, fp
 5438 2f50 2C309DE5 		ldr	r3, [sp, #44]
 5439 2f54 1010A0E3 		mov	r1, #16
 5440 2f58 0600A0E1 		mov	r0, r6
 5441 2f5c 00A08DE5 		str	sl, [sp, #0]
 5442 2f60 04A08DE5 		str	sl, [sp, #4]
 5443 2f64 FEFFFFEB 		bl	cmdSet
1843:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5444              		.loc 1 1843 0
 5445 2f68 1C0096E5 		ldr	r0, [r6, #28]
 5446 2f6c FEFFFFEB 		bl	_txe_mutex_put
 5447              	.LVL499:
 5448              	.LBB71:
 5449              	.LBB72:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5450              		.loc 1 736 0
 5451 2f70 0010E0E3 		mvn	r1, #0
 5452 2f74 1C0096E5 		ldr	r0, [r6, #28]
 5453 2f78 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5454              		.loc 1 737 0
 5455 2f7c 01C0A0E3 		mov	ip, #1
 5456 2f80 2010A0E3 		mov	r1, #32
 5457 2f84 2720A0E3 		mov	r2, #39
 5458 2f88 3030A0E3 		mov	r3, #48
 5459 2f8c 0600A0E1 		mov	r0, r6
 5460 2f90 00C08DE5 		str	ip, [sp, #0]
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5461              		.loc 1 738 0
 5462 2f94 0280A0E3 		mov	r8, #2
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5463              		.loc 1 737 0
 5464 2f98 04A08DE5 		str	sl, [sp, #4]
 5465 2f9c FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5466              		.loc 1 738 0
 5467 2fa0 2110A0E3 		mov	r1, #33
 5468 2fa4 2520A0E3 		mov	r2, #37
 5469 2fa8 3030A0E3 		mov	r3, #48
 5470 2fac 0600A0E1 		mov	r0, r6
 5471 2fb0 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5472 2fb4 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5473              		.loc 1 739 0
 5474 2fb8 1C0096E5 		ldr	r0, [r6, #28]
 5475 2fbc FEFFFFEB 		bl	_txe_mutex_put
 5476              	.LBE72:
 5477              	.LBE71:
1845:../uvc.c      **** 							break;
 5478              		.loc 1 1845 0
 5479 2fc0 FFC0A0E3 		mov	ip, #255
 5480 2fc4 0C60A0E1 		mov	r6, ip
 5481 2fc8 0880A0E3 		mov	r8, #8
 5482 2fcc 40FEFFEA 		b	.L342
 5483              	.LVL500:
 5484              	.L360:
 5485              	.LBB73:
 5486              	.LBB74:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5487              		.loc 1 736 0
 5488 2fd0 F8619FE5 		ldr	r6, .L416+24
 5489 2fd4 0010E0E3 		mvn	r1, #0
 5490 2fd8 1C0096E5 		ldr	r0, [r6, #28]
 5491 2fdc FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5492              		.loc 1 737 0
 5493 2fe0 0080A0E3 		mov	r8, #0
 5494 2fe4 2010A0E3 		mov	r1, #32
 5495 2fe8 2720A0E3 		mov	r2, #39
 5496 2fec 3030A0E3 		mov	r3, #48
 5497 2ff0 0600A0E1 		mov	r0, r6
 5498 2ff4 00808DE5 		str	r8, [sp, #0]
 5499 2ff8 04808DE5 		str	r8, [sp, #4]
 5500 2ffc FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5501              		.loc 1 738 0
 5502 3000 01C0A0E3 		mov	ip, #1
 5503 3004 2110A0E3 		mov	r1, #33
 5504 3008 2520A0E3 		mov	r2, #37
 5505 300c 3030A0E3 		mov	r3, #48
 5506 3010 0600A0E1 		mov	r0, r6
 5507 3014 00C08DE5 		str	ip, [sp, #0]
 5508 3018 04808DE5 		str	r8, [sp, #4]
 5509 301c FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5510              		.loc 1 739 0
 5511 3020 1C0096E5 		ldr	r0, [r6, #28]
 5512 3024 FEFFFFEB 		bl	_txe_mutex_put
 5513 3028 FFC0A0E3 		mov	ip, #255
 5514 302c 0C60A0E1 		mov	r6, ip
 5515 3030 0480A0E3 		mov	r8, #4
 5516 3034 26FEFFEA 		b	.L342
 5517              	.LVL501:
 5518              	.L359:
 5519              	.LBE74:
 5520              	.LBE73:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5521              		.loc 1 1829 0
 5522 3038 90619FE5 		ldr	r6, .L416+24
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5523              		.loc 1 1827 0
 5524 303c 00A0A0E3 		mov	sl, #0
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5525              		.loc 1 1829 0
 5526 3040 1C0096E5 		ldr	r0, [r6, #28]
1827:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 5527              		.loc 1 1827 0
 5528 3044 0DA3C8E5 		strb	sl, [r8, #781]
 5529              	.LVL502:
1829:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5530              		.loc 1 1829 0
 5531 3048 0010E0E3 		mvn	r1, #0
 5532 304c 2C308DE5 		str	r3, [sp, #44]
 5533 3050 FEFFFFEB 		bl	_txe_mutex_get
1830:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5534              		.loc 1 1830 0
 5535 3054 0B20A0E1 		mov	r2, fp
 5536 3058 2C309DE5 		ldr	r3, [sp, #44]
 5537 305c 1010A0E3 		mov	r1, #16
 5538 3060 0600A0E1 		mov	r0, r6
 5539 3064 00A08DE5 		str	sl, [sp, #0]
 5540 3068 04A08DE5 		str	sl, [sp, #4]
 5541 306c FEFFFFEB 		bl	cmdSet
1831:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5542              		.loc 1 1831 0
 5543 3070 1C0096E5 		ldr	r0, [r6, #28]
 5544 3074 FEFFFFEB 		bl	_txe_mutex_put
 5545              	.LVL503:
 5546              	.LBB75:
 5547              	.LBB76:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5548              		.loc 1 736 0
 5549 3078 0010E0E3 		mvn	r1, #0
 5550 307c 1C0096E5 		ldr	r0, [r6, #28]
 5551 3080 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5552              		.loc 1 737 0
 5553 3084 2010A0E3 		mov	r1, #32
 5554 3088 2720A0E3 		mov	r2, #39
 5555 308c 3030A0E3 		mov	r3, #48
 5556 3090 0600A0E1 		mov	r0, r6
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5557              		.loc 1 738 0
 5558 3094 0180A0E3 		mov	r8, #1
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5559              		.loc 1 737 0
 5560 3098 00A08DE5 		str	sl, [sp, #0]
 5561 309c 04A08DE5 		str	sl, [sp, #4]
 5562 30a0 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5563              		.loc 1 738 0
 5564 30a4 2110A0E3 		mov	r1, #33
 5565 30a8 2520A0E3 		mov	r2, #37
 5566 30ac 3030A0E3 		mov	r3, #48
 5567 30b0 0600A0E1 		mov	r0, r6
 5568 30b4 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 5569 30b8 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5570              		.loc 1 739 0
 5571 30bc 1C0096E5 		ldr	r0, [r6, #28]
 5572 30c0 FEFFFFEB 		bl	_txe_mutex_put
 5573 30c4 FFC0A0E3 		mov	ip, #255
 5574 30c8 0C60A0E1 		mov	r6, ip
 5575 30cc 0280A0E3 		mov	r8, #2
 5576 30d0 FFFDFFEA 		b	.L342
 5577              	.LVL504:
 5578              	.L358:
 5579              	.LBE76:
 5580              	.LBE75:
 5581              	.LBB77:
 5582              	.LBB78:
 736:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5583              		.loc 1 736 0
 5584 30d4 F4609FE5 		ldr	r6, .L416+24
 5585 30d8 0010E0E3 		mvn	r1, #0
 5586 30dc 1C0096E5 		ldr	r0, [r6, #28]
 5587 30e0 FEFFFFEB 		bl	_txe_mutex_get
 737:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5588              		.loc 1 737 0
 5589 30e4 0080A0E3 		mov	r8, #0
 5590 30e8 01A0A0E3 		mov	sl, #1
 5591 30ec 2010A0E3 		mov	r1, #32
 5592 30f0 2720A0E3 		mov	r2, #39
 5593 30f4 3030A0E3 		mov	r3, #48
 5594 30f8 0600A0E1 		mov	r0, r6
 5595 30fc 04808DE5 		str	r8, [sp, #4]
 5596 3100 00A08DE5 		str	sl, [sp, #0]
 5597 3104 FEFFFFEB 		bl	cmdSet
 738:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5598              		.loc 1 738 0
 5599 3108 02C0A0E3 		mov	ip, #2
 5600 310c 2110A0E3 		mov	r1, #33
 5601 3110 2520A0E3 		mov	r2, #37
 5602 3114 3030A0E3 		mov	r3, #48
 5603 3118 0600A0E1 		mov	r0, r6
 5604 311c 00C08DE5 		str	ip, [sp, #0]
 5605 3120 04808DE5 		str	r8, [sp, #4]
 5606 3124 FEFFFFEB 		bl	cmdSet
 739:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5607              		.loc 1 739 0
 5608 3128 1C0096E5 		ldr	r0, [r6, #28]
 5609 312c FEFFFFEB 		bl	_txe_mutex_put
 5610              	.LBE78:
 5611              	.LBE77:
1825:../uvc.c      **** 							break;
 5612              		.loc 1 1825 0
 5613 3130 FFC0A0E3 		mov	ip, #255
 5614 3134 0C60A0E1 		mov	r6, ip
 5615 3138 0A80A0E1 		mov	r8, sl
 5616 313c E4FDFFEA 		b	.L342
 5617              	.LVL505:
 5618              	.L357:
1822:../uvc.c      **** 		  		    switch (getData){
 5619              		.loc 1 1822 0
 5620 3140 FFC0A0E3 		mov	ip, #255
 5621 3144 0080A0E1 		mov	r8, r0
 5622 3148 0C60A0E1 		mov	r6, ip
 5623 314c E0FDFFEA 		b	.L342
 5624              	.LVL506:
 5625              	.L363:
1893:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5626              		.loc 1 1893 0
 5627 3150 0000A0E3 		mov	r0, #0
 5628 3154 0110A0E3 		mov	r1, #1
 5629 3158 0020A0E1 		mov	r2, r0
 5630 315c FEFFFFEB 		bl	CyU3PUsbStall
 5631              	.LVL507:
 5632 3160 94FEFFEA 		b	.L406
 5633              	.LVL508:
 5634              	.L405:
1911:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 5635              		.loc 1 1911 0
 5636 3164 0110A0E3 		mov	r1, #1
 5637 3168 0020A0E1 		mov	r2, r0
 5638 316c FEFFFFEB 		bl	CyU3PUsbStall
 5639 3170 90FEFFEA 		b	.L406
 5640              	.LVL509:
 5641              	.L415:
1926:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5642              		.loc 1 1926 0
 5643 3174 08E0A0E3 		mov	lr, #8
 5644 3178 00C0A0E3 		mov	ip, #0
 5645 317c 0600A0E1 		mov	r0, r6
 5646 3180 2310A0E3 		mov	r1, #35
 5647 3184 0B20A0E1 		mov	r2, fp
 5648 3188 00E08DE5 		str	lr, [sp, #0]
 5649 318c 04C08DE5 		str	ip, [sp, #4]
 5650 3190 FEFFFFEB 		bl	cmdSet
 5651 3194 5DFEFFEA 		b	.L408
 5652              	.L414:
1924:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5653              		.loc 1 1924 0
 5654 3198 0480A0E3 		mov	r8, #4
 5655 319c 00E0A0E3 		mov	lr, #0
 5656 31a0 0600A0E1 		mov	r0, r6
 5657 31a4 2310A0E3 		mov	r1, #35
 5658 31a8 0B20A0E1 		mov	r2, fp
 5659 31ac 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 5660 31b0 FEFFFFEB 		bl	cmdSet
 5661 31b4 55FEFFEA 		b	.L408
 5662              	.L417:
 5663              		.align	2
 5664              	.L416:
 5665 31b8 00000000 		.word	bRequest
 5666 31bc 00000000 		.word	.LANCHOR1
 5667 31c0 00000000 		.word	.LANCHOR0
 5668 31c4 D4050000 		.word	.LC34
 5669 31c8 F8050000 		.word	.LC35
 5670 31cc 1C010000 		.word	.LANCHOR0+284
 5671 31d0 00000000 		.word	cmdQu
 5672 31d4 88050000 		.word	.LC32
 5673 31d8 FFFF0000 		.word	65535
 5674 31dc B0050000 		.word	.LC33
 5675              		.cfi_endproc
 5676              	.LFE4:
 5678              		.align	2
 5679              		.global	UVCAppEP0Thread_Entry
 5681              	UVCAppEP0Thread_Entry:
 5682              	.LFB26:
4180:../uvc.c      **** {
 5683              		.loc 1 4180 0
 5684              		.cfi_startproc
 5685              		@ args = 0, pretend = 0, frame = 40
 5686              		@ frame_needed = 0, uses_anonymous_args = 0
 5687              	.LVL510:
 5688 31e0 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 5689              	.LCFI20:
 5690              		.cfi_def_cfa_offset 24
 5691 31e4 444F9FE5 		ldr	r4, .L639
 5692              		.cfi_offset 14, -4
 5693              		.cfi_offset 8, -8
 5694              		.cfi_offset 7, -12
 5695              		.cfi_offset 6, -16
 5696              		.cfi_offset 5, -20
 5697              		.cfi_offset 4, -24
 5698 31e8 446F9FE5 		ldr	r6, .L639+4
 5699 31ec 30D04DE2 		sub	sp, sp, #48
 5700              	.LCFI21:
 5701              		.cfi_def_cfa_offset 72
 5702              	.LVL511:
4201:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 5703              		.loc 1 4201 0
 5704 31f0 0450A0E1 		mov	r5, r4
 5705              	.LVL512:
 5706              	.L580:
 5707 31f4 00C0E0E3 		mvn	ip, #0
 5708 31f8 300F9FE5 		ldr	r0, .L639
 5709 31fc 5C10A0E3 		mov	r1, #92
 5710 3200 0120A0E3 		mov	r2, #1
 5711 3204 28308DE2 		add	r3, sp, #40
 5712 3208 00C08DE5 		str	ip, [sp, #0]
 5713 320c FEFFFFEB 		bl	_txe_event_flags_get
 5714 3210 000050E3 		cmp	r0, #0
 5715 3214 6600001A 		bne	.L419
4205:../uvc.c      ****             if (!isUsbConnected)
 5716              		.loc 1 4205 0
 5717 3218 B03095E5 		ldr	r3, [r5, #176]
 5718 321c 000053E3 		cmp	r3, #0
 5719 3220 9D00000A 		beq	.L625
 5720              	.L420:
4221:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 5721              		.loc 1 4221 0
 5722 3224 28309DE5 		ldr	r3, [sp, #40]
 5723 3228 040013E3 		tst	r3, #4
 5724 322c 1C00000A 		beq	.L421
4223:../uvc.c      ****             	switch ((wIndex >> 8))
 5725              		.loc 1 4223 0
 5726 3230 00EF9FE5 		ldr	lr, .L639+8
 5727 3234 B070DEE1 		ldrh	r7, [lr, #0]
 5728 3238 2724A0E1 		mov	r2, r7, lsr #8
 5729 323c 030052E3 		cmp	r2, #3
 5730 3240 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5731 3244 110000EA 		b	.L422
 5732              	.L427:
 5733 3248 68340000 		.word	.L423
 5734 324c E0330000 		.word	.L424
 5735 3250 28340000 		.word	.L425
 5736 3254 58320000 		.word	.L426
 5737              	.L426:
 5738              	.LBB99:
 5739              	.LBB103:
3728:../uvc.c      ****     switch (wValue)
 5740              		.loc 1 3728 0
 5741 3258 DC1E9FE5 		ldr	r1, .L639+12
 5742 325c B030D1E1 		ldrh	r3, [r1, #0]
 5743 3260 090C53E3 		cmp	r3, #2304
 5744 3264 AD01000A 		beq	.L470
 5745 3268 C500008A 		bhi	.L480
 5746 326c 010B53E3 		cmp	r3, #1024
 5747 3270 F303000A 		beq	.L465
 5748 3274 B900008A 		bhi	.L481
 5749 3278 020C53E3 		cmp	r3, #512
 5750 327c EC03000A 		beq	.L463
 5751 3280 030C53E3 		cmp	r3, #768
 5752 3284 E603000A 		beq	.L464
 5753 3288 010C53E3 		cmp	r3, #256
 5754 328c E003000A 		beq	.L626
 5755              	.L422:
 5756              	.LBE103:
 5757              	.LBE99:
4244:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 5758              		.loc 1 4244 0
 5759 3290 0000A0E3 		mov	r0, #0
 5760 3294 0110A0E3 		mov	r1, #1
 5761 3298 0020A0E1 		mov	r2, r0
 5762 329c FEFFFFEB 		bl	CyU3PUsbStall
 5763 32a0 28309DE5 		ldr	r3, [sp, #40]
 5764              	.L421:
4249:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 5765              		.loc 1 4249 0
 5766 32a4 080013E3 		tst	r3, #8
 5767 32a8 0800000A 		beq	.L486
4253:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 5768              		.loc 1 4253 0
 5769 32ac 84CE9FE5 		ldr	ip, .L639+8
 5770 32b0 B030DCE1 		ldrh	r3, [ip, #0]
 5771 32b4 010053E3 		cmp	r3, #1
 5772 32b8 4C01000A 		beq	.L487
 5773              	.L488:
 5774              	.LBB107:
 5775              	.LBB110:
4169:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 5776              		.loc 1 4169 0
 5777 32bc 0000A0E3 		mov	r0, #0
 5778 32c0 0110A0E3 		mov	r1, #1
 5779 32c4 0020A0E1 		mov	r2, r0
 5780 32c8 FEFFFFEB 		bl	CyU3PUsbStall
 5781              	.L615:
 5782 32cc 28309DE5 		ldr	r3, [sp, #40]
 5783              	.L486:
 5784              	.LBE110:
 5785              	.LBE107:
4264:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 5786              		.loc 1 4264 0
 5787 32d0 400013E3 		tst	r3, #64
 5788 32d4 7600001A 		bne	.L627
 5789              	.L562:
4387:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
 5790              		.loc 1 4387 0
 5791 32d8 100013E3 		tst	r3, #16
 5792 32dc 3400000A 		beq	.L419
4390:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
 5793              		.loc 1 4390 0
 5794 32e0 580E9FE5 		ldr	r0, .L639+16
 5795 32e4 18108DE2 		add	r1, sp, #24
 5796 32e8 0020E0E3 		mvn	r2, #0
 5797 32ec FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 5798              	.LVL513:
4391:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5799              		.loc 1 4391 0
 5800 32f0 007050E2 		subs	r7, r0, #0
 5801 32f4 1801001A 		bne	.L628
4404:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
 5802              		.loc 1 4404 0
 5803 32f8 18E09DE5 		ldr	lr, [sp, #24]
 5804 32fc BC21DDE1 		ldrh	r2, [sp, #28]
 5805 3300 0100DEE5 		ldrb	r0, [lr, #1]	@ zero_extendqisi2
 5806              	.LVL514:
 5807 3304 0030DEE5 		ldrb	r3, [lr, #0]	@ zero_extendqisi2
 5808 3308 00008DE5 		str	r0, [sp, #0]
 5809 330c 02C0DEE5 		ldrb	ip, [lr, #2]	@ zero_extendqisi2
 5810 3310 0400A0E3 		mov	r0, #4
 5811 3314 281E9FE5 		ldr	r1, .L639+20
 5812 3318 04C08DE5 		str	ip, [sp, #4]
 5813 331c FEFFFFEB 		bl	CyU3PDebugPrint
4405:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
 5814              		.loc 1 4405 0
 5815 3320 18C09DE5 		ldr	ip, [sp, #24]
 5816 3324 0030DCE5 		ldrb	r3, [ip, #0]	@ zero_extendqisi2
 5817 3328 000053E3 		cmp	r3, #0
 5818 332c F900001A 		bne	.L570
4407:../uvc.c      ****                     if (dmaInfo.count == 3)
 5819              		.loc 1 4407 0
 5820 3330 BC21DDE1 		ldrh	r2, [sp, #28]
 5821 3334 030052E3 		cmp	r2, #3
4411:../uvc.c      ****                         dmaInfo.count = 3;
 5822              		.loc 1 4411 0
 5823 3338 BC21CD01 		streqh	r2, [sp, #28]	@ movhi
4407:../uvc.c      ****                     if (dmaInfo.count == 3)
 5824              		.loc 1 4407 0
 5825 333c 0100000A 		beq	.L572
4413:../uvc.c      ****                     else if (dmaInfo.count == 4)
 5826              		.loc 1 4413 0
 5827 3340 040052E3 		cmp	r2, #4
 5828 3344 9E03000A 		beq	.L629
 5829              	.LVL515:
 5830              	.L572:
4422:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
 5831              		.loc 1 4422 0
 5832 3348 000096E5 		ldr	r0, [r6, #0]
 5833 334c F41D9FE5 		ldr	r1, .L639+24
 5834 3350 01C0D0E5 		ldrb	ip, [r0, #1]	@ zero_extendqisi2
 5835 3354 0030D0E5 		ldrb	r3, [r0, #0]	@ zero_extendqisi2
 5836 3358 00C08DE5 		str	ip, [sp, #0]
 5837 335c 0270D0E5 		ldrb	r7, [r0, #2]	@ zero_extendqisi2
 5838 3360 0400A0E3 		mov	r0, #4
 5839 3364 04708DE5 		str	r7, [sp, #4]
 5840 3368 FEFFFFEB 		bl	CyU3PDebugPrint
 5841              	.L574:
4452:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
 5842              		.loc 1 4452 0
 5843 336c 002096E5 		ldr	r2, [r6, #0]
4453:../uvc.c      ****                 dmaInfo.size   = 1024;
 5844              		.loc 1 4453 0
 5845 3370 01EBA0E3 		mov	lr, #1024	@ movhi
4454:../uvc.c      ****                 dmaInfo.status = 0;
 5846              		.loc 1 4454 0
 5847 3374 0030A0E3 		mov	r3, #0	@ movhi
4457:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
 5848              		.loc 1 4457 0
 5849 3378 C00D9FE5 		ldr	r0, .L639+16
4452:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
 5850              		.loc 1 4452 0
 5851 337c 18208DE5 		str	r2, [sp, #24]
4453:../uvc.c      ****                 dmaInfo.size   = 1024;
 5852              		.loc 1 4453 0
 5853 3380 BEE1CDE1 		strh	lr, [sp, #30]	@ movhi
4454:../uvc.c      ****                 dmaInfo.status = 0;
 5854              		.loc 1 4454 0
 5855 3384 B032CDE1 		strh	r3, [sp, #32]	@ movhi
4457:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
 5856              		.loc 1 4457 0
 5857 3388 FEFFFFEB 		bl	CyU3PDmaChannelDiscardBuffer
 5858              	.LVL516:
4458:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5859              		.loc 1 4458 0
 5860 338c 002050E2 		subs	r2, r0, #0
 5861 3390 A000001A 		bne	.L630
4465:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
 5862              		.loc 1 4465 0
 5863 3394 0010E0E3 		mvn	r1, #0
 5864 3398 AC0D9FE5 		ldr	r0, .L639+28
 5865              	.LVL517:
 5866 339c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 5867              	.LVL518:
4467:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
 5868              		.loc 1 4467 0
 5869 33a0 A40D9FE5 		ldr	r0, .L639+28
 5870 33a4 18108DE2 		add	r1, sp, #24
 5871 33a8 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 5872              	.LVL519:
4468:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 5873              		.loc 1 4468 0
 5874 33ac 002050E2 		subs	r2, r0, #0
 5875 33b0 0100001A 		bne	.L631
 5876              	.LVL520:
 5877              	.L419:
4477:../uvc.c      ****         CyU3PThreadRelinquish ();
 5878              		.loc 1 4477 0
 5879 33b4 FEFFFFEB 		bl	_txe_thread_relinquish
4478:../uvc.c      ****     }
 5880              		.loc 1 4478 0
 5881 33b8 8DFFFFEA 		b	.L580
 5882              	.LVL521:
 5883              	.L631:
4470:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
 5884              		.loc 1 4470 0
 5885 33bc 0400A0E3 		mov	r0, #4
 5886              	.LVL522:
 5887 33c0 881D9FE5 		ldr	r1, .L639+32
 5888 33c4 FEFFFFEB 		bl	CyU3PDebugPrint
 5889              	.LVL523:
 5890              	.L579:
 5891              	.LBB113:
 5892              	.LBB114:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5893              		.loc 1 2061 0
 5894 33c8 841D9FE5 		ldr	r1, .L639+36
 5895 33cc 0400A0E3 		mov	r0, #4
 5896 33d0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 5897              		.loc 1 2062 0
 5898 33d4 FA0FA0E3 		mov	r0, #1000
 5899 33d8 FEFFFFEB 		bl	_tx_thread_sleep
 5900 33dc F9FFFFEA 		b	.L579
 5901              	.L424:
 5902              	.LBE114:
 5903              	.LBE113:
 5904              	.LBB115:
 5905              	.LBB118:
3498:../uvc.c      ****     switch (wValue)
 5906              		.loc 1 3498 0
 5907 33e0 540D9FE5 		ldr	r0, .L639+12
 5908 33e4 B020D0E1 		ldrh	r2, [r0, #0]
 5909 33e8 060C52E3 		cmp	r2, #1536
 5910 33ec 4B03000A 		beq	.L448
 5911 33f0 AC00008A 		bhi	.L454
 5912 33f4 030C52E3 		cmp	r2, #768
 5913 33f8 4403000A 		beq	.L445
 5914 33fc A100008A 		bhi	.L455
 5915 3400 010C52E3 		cmp	r2, #256
 5916 3404 3D03000A 		beq	.L443
 5917 3408 020C52E3 		cmp	r2, #512
 5918 340c 3703000A 		beq	.L632
 5919              	.L442:
3555:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 5920              		.loc 1 3555 0
 5921 3410 403D9FE5 		ldr	r3, .L639+40
 5922 3414 401D9FE5 		ldr	r1, .L639+44
 5923 3418 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 5924 341c 0400A0E3 		mov	r0, #4
 5925 3420 FEFFFFEB 		bl	CyU3PDebugPrint
 5926 3424 99FFFFEA 		b	.L422
 5927              	.L425:
 5928              	.LBE118:
 5929              	.LBE115:
 5930              	.LBB122:
 5931              	.LBB125:
3423:../uvc.c      ****     switch (wValue)
 5932              		.loc 1 3423 0
 5933 3428 0CCD9FE5 		ldr	ip, .L639+12
 5934 342c B020DCE1 		ldrh	r2, [ip, #0]
 5935 3430 060C52E3 		cmp	r2, #1536
 5936 3434 2903000A 		beq	.L433
 5937 3438 8700008A 		bhi	.L439
 5938 343c 030C52E3 		cmp	r2, #768
 5939 3440 2203000A 		beq	.L431
 5940 3444 7C00008A 		bhi	.L440
 5941 3448 010C52E3 		cmp	r2, #256
 5942 344c 1B03000A 		beq	.L429
 5943 3450 020C52E3 		cmp	r2, #512
 5944 3454 EDFFFF1A 		bne	.L442
 5945              	.LVL524:
3431:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 5946              		.loc 1 3431 0
 5947 3458 0100A0E3 		mov	r0, #1
 5948 345c FEFFFFEB 		bl	ControlHandle
 5949              	.LVL525:
 5950 3460 28309DE5 		ldr	r3, [sp, #40]
 5951 3464 8EFFFFEA 		b	.L421
 5952              	.L423:
 5953              	.LBE125:
 5954              	.LBE122:
 5955              	.LBB129:
 5956              	.LBB130:
3693:../uvc.c      **** 	if(valIdx < 32){
 5957              		.loc 1 3693 0
 5958 3468 F07C9FE5 		ldr	r7, .L639+48
 5959 346c 8E24D7E5 		ldrb	r2, [r7, #1166]	@ zero_extendqisi2
 5960 3470 1F0052E3 		cmp	r2, #31
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5961              		.loc 1 3694 0
 5962 3474 C03C9F95 		ldrls	r3, .L639+12
3696:../uvc.c      **** 		valIdx++;
 5963              		.loc 1 3696 0
 5964 3478 01108292 		addls	r1, r2, #1
3694:../uvc.c      **** 		value[valIdx][0] = wValue>>8;
 5965              		.loc 1 3694 0
 5966 347c B0C0D391 		ldrlsh	ip, [r3, #0]
 5967 3480 82208490 		addls	r2, r4, r2, asl #1
 5968 3484 2CE4A091 		movls	lr, ip, lsr #8
 5969 3488 DCE0C295 		strlsb	lr, [r2, #220]
3695:../uvc.c      **** 		value[valIdx][1] = (uint8_t)wValue;
 5970              		.loc 1 3695 0
 5971 348c DDC0C295 		strlsb	ip, [r2, #221]
3696:../uvc.c      **** 		valIdx++;
 5972              		.loc 1 3696 0
 5973 3490 8E14C795 		strlsb	r1, [r7, #1166]
3697:../uvc.c      **** 		value[0][1] = valIdx;
 5974              		.loc 1 3697 0
 5975 3494 DD10C495 		strlsb	r1, [r4, #221]
 5976 3498 7CFFFFEA 		b	.L422
 5977              	.L625:
 5978              	.LBE130:
 5979              	.LBE129:
4207:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5980              		.loc 1 4207 0
 5981 349c FEFFFFEB 		bl	CyU3PUsbGetSpeed
4208:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 5982              		.loc 1 4208 0
 5983 34a0 000050E3 		cmp	r0, #0
4207:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 5984              		.loc 1 4207 0
 5985 34a4 C800C5E5 		strb	r0, [r5, #200]
4210:../uvc.c      ****                     isUsbConnected = CyTrue;
 5986              		.loc 1 4210 0
 5987 34a8 0100A013 		movne	r0, #1
 5988 34ac B0008515 		strne	r0, [r5, #176]
 5989 34b0 5BFFFFEA 		b	.L420
 5990              	.L627:
4326:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5991              		.loc 1 4326 0
 5992 34b4 A48C9FE5 		ldr	r8, .L639+48
4269:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 5993              		.loc 1 4269 0
 5994 34b8 1800A0E3 		mov	r0, #24
 5995 34bc 24108DE2 		add	r1, sp, #36
 5996 34c0 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
4326:../uvc.c      **** 				if(snapButFlag == 0x0f){
 5997              		.loc 1 4326 0
 5998 34c4 0B27D8E5 		ldrb	r2, [r8, #1803]	@ zero_extendqisi2
 5999 34c8 0F0052E3 		cmp	r2, #15
 6000 34cc D102000A 		beq	.L633
4353:../uvc.c      **** 				}else if(!snapButFlag){
 6001              		.loc 1 4353 0
 6002 34d0 000052E3 		cmp	r2, #0
 6003 34d4 28309D15 		ldrne	r3, [sp, #40]
 6004 34d8 7EFFFF1A 		bne	.L562
4355:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 6005              		.loc 1 4355 0
 6006 34dc 803C9FE5 		ldr	r3, .L639+52
 6007 34e0 02E0A0E3 		mov	lr, #2
 6008 34e4 001093E5 		ldr	r1, [r3, #0]
4356:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6009              		.loc 1 4356 0
 6010 34e8 0170A0E3 		mov	r7, #1
4355:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 6011              		.loc 1 4355 0
 6012 34ec 00E0C1E5 		strb	lr, [r1, #0]
4356:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6013              		.loc 1 4356 0
 6014 34f0 000093E5 		ldr	r0, [r3, #0]
4367:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6015              		.loc 1 4367 0
 6016 34f4 0010E0E3 		mvn	r1, #0
4356:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 6017              		.loc 1 4356 0
 6018 34f8 0170C0E5 		strb	r7, [r0, #1]
4357:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 6019              		.loc 1 4357 0
 6020 34fc 00C093E5 		ldr	ip, [r3, #0]
4367:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6021              		.loc 1 4367 0
 6022 3500 600C9FE5 		ldr	r0, .L639+56
4357:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 6023              		.loc 1 4357 0
 6024 3504 0220CCE5 		strb	r2, [ip, #2]
4358:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 6025              		.loc 1 4358 0
 6026 3508 00E093E5 		ldr	lr, [r3, #0]
4361:../uvc.c      **** 					interStabuf.size   = 1024;
 6027              		.loc 1 4361 0
 6028 350c 01CBA0E3 		mov	ip, #1024	@ movhi
4358:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 6029              		.loc 1 4358 0
 6030 3510 0370CEE5 		strb	r7, [lr, #3]
4360:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6031              		.loc 1 4360 0
 6032 3514 00E093E5 		ldr	lr, [r3, #0]
4364:../uvc.c      **** 					interStabuf.count = 4;
 6033              		.loc 1 4364 0
 6034 3518 0430A0E3 		mov	r3, #4	@ movhi
4362:../uvc.c      **** 					interStabuf.status = 0;
 6035              		.loc 1 4362 0
 6036 351c B421CDE1 		strh	r2, [sp, #20]	@ movhi
4361:../uvc.c      **** 					interStabuf.size   = 1024;
 6037              		.loc 1 4361 0
 6038 3520 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
4360:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 6039              		.loc 1 4360 0
 6040 3524 0CE08DE5 		str	lr, [sp, #12]
4364:../uvc.c      **** 					interStabuf.count = 4;
 6041              		.loc 1 4364 0
 6042 3528 B031CDE1 		strh	r3, [sp, #16]	@ movhi
4367:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 6043              		.loc 1 4367 0
 6044 352c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4370:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 6045              		.loc 1 4370 0
 6046 3530 300C9FE5 		ldr	r0, .L639+56
 6047 3534 0C108DE2 		add	r1, sp, #12
 6048 3538 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 6049              	.LVL526:
4372:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 6050              		.loc 1 4372 0
 6051 353c 002050E2 		subs	r2, r0, #0
 6052 3540 AB02001A 		bne	.L634
4378:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
 6053              		.loc 1 4378 0
 6054 3544 0500A0E3 		mov	r0, #5
 6055              	.LVL527:
 6056 3548 3010A0E3 		mov	r1, #48
 6057 354c 0720A0E1 		mov	r2, r7
 6058              	.LVL528:
 6059 3550 FEFFFFEB 		bl	SensorSetControl
 6060 3554 28309DE5 		ldr	r3, [sp, #40]
4379:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 6061              		.loc 1 4379 0
 6062 3558 0B77C8E5 		strb	r7, [r8, #1803]
 6063 355c 5DFFFFEA 		b	.L562
 6064              	.L481:
 6065              	.LBB131:
 6066              	.LBB102:
3728:../uvc.c      ****     switch (wValue)
 6067              		.loc 1 3728 0
 6068 3560 060C53E3 		cmp	r3, #1536
 6069 3564 9E02000A 		beq	.L467
 6070 3568 1100008A 		bhi	.L482
 6071 356c 050C53E3 		cmp	r3, #1280
 6072 3570 46FFFF1A 		bne	.L422
 6073              	.LVL529:
3748:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 6074              		.loc 1 3748 0
 6075 3574 1400A0E3 		mov	r0, #20
 6076 3578 FEFFFFEB 		bl	ControlHandle
 6077              	.LVL530:
 6078 357c 28309DE5 		ldr	r3, [sp, #40]
 6079 3580 47FFFFEA 		b	.L421
 6080              	.L480:
3728:../uvc.c      ****     switch (wValue)
 6081              		.loc 1 3728 0
 6082 3584 0F0C53E3 		cmp	r3, #3840
 6083 3588 9102000A 		beq	.L475
 6084 358c 1800008A 		bhi	.L483
 6085 3590 0B0C53E3 		cmp	r3, #2816
 6086 3594 8A02000A 		beq	.L472
 6087 3598 0D00008A 		bhi	.L484
 6088 359c 0A0C53E3 		cmp	r3, #2560
 6089 35a0 3AFFFF1A 		bne	.L422
 6090              	.LVL531:
3769:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 6091              		.loc 1 3769 0
 6092 35a4 1900A0E3 		mov	r0, #25
 6093 35a8 FEFFFFEB 		bl	ControlHandle
 6094              	.LVL532:
 6095 35ac 28309DE5 		ldr	r3, [sp, #40]
 6096 35b0 3BFFFFEA 		b	.L421
 6097              	.L482:
3728:../uvc.c      ****     switch (wValue)
 6098              		.loc 1 3728 0
 6099 35b4 070C53E3 		cmp	r3, #1792
 6100 35b8 7D02000A 		beq	.L468
 6101 35bc 020B53E3 		cmp	r3, #2048
 6102 35c0 32FFFF1A 		bne	.L422
 6103              	.LVL533:
3760:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 6104              		.loc 1 3760 0
 6105 35c4 1700A0E3 		mov	r0, #23
 6106 35c8 FEFFFFEB 		bl	ControlHandle
 6107              	.LVL534:
 6108 35cc 28309DE5 		ldr	r3, [sp, #40]
 6109 35d0 33FFFFEA 		b	.L421
 6110              	.L484:
3728:../uvc.c      ****     switch (wValue)
 6111              		.loc 1 3728 0
 6112 35d4 030B53E3 		cmp	r3, #3072
 6113 35d8 7102000A 		beq	.L473
 6114 35dc 0D0C53E3 		cmp	r3, #3328
 6115 35e0 2AFFFF1A 		bne	.L422
 6116              	.LVL535:
3785:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 6117              		.loc 1 3785 0
 6118 35e4 1C00A0E3 		mov	r0, #28
 6119 35e8 FEFFFFEB 		bl	ControlHandle
 6120              	.LVL536:
 6121 35ec 28309DE5 		ldr	r3, [sp, #40]
 6122 35f0 2BFFFFEA 		b	.L421
 6123              	.L483:
3728:../uvc.c      ****     switch (wValue)
 6124              		.loc 1 3728 0
 6125 35f4 110C53E3 		cmp	r3, #4352
 6126 35f8 6502000A 		beq	.L477
 6127 35fc 9A00008A 		bhi	.L485
 6128 3600 010A53E3 		cmp	r3, #4096
 6129 3604 21FFFF1A 		bne	.L422
 6130              	.LVL537:
3797:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 6131              		.loc 1 3797 0
 6132 3608 1F00A0E3 		mov	r0, #31
 6133 360c FEFFFFEB 		bl	ControlHandle
 6134              	.LVL538:
 6135 3610 28309DE5 		ldr	r3, [sp, #40]
 6136 3614 22FFFFEA 		b	.L421
 6137              	.LVL539:
 6138              	.L630:
 6139              	.LBE102:
 6140              	.LBE131:
4460:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
 6141              		.loc 1 4460 0
 6142 3618 0400A0E3 		mov	r0, #4
 6143              	.LVL540:
 6144 361c 481B9FE5 		ldr	r1, .L639+60
 6145 3620 FEFFFFEB 		bl	CyU3PDebugPrint
 6146              	.LVL541:
 6147              	.L578:
 6148              	.LBB132:
 6149              	.LBB133:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6150              		.loc 1 2061 0
 6151 3624 281B9FE5 		ldr	r1, .L639+36
 6152 3628 0400A0E3 		mov	r0, #4
 6153 362c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6154              		.loc 1 2062 0
 6155 3630 FA0FA0E3 		mov	r0, #1000
 6156 3634 FEFFFFEB 		bl	_tx_thread_sleep
 6157 3638 F9FFFFEA 		b	.L578
 6158              	.L440:
 6159              	.LBE133:
 6160              	.LBE132:
 6161              	.LBB134:
 6162              	.LBB126:
3423:../uvc.c      ****     switch (wValue)
 6163              		.loc 1 3423 0
 6164 363c 010B52E3 		cmp	r2, #1024
 6165 3640 17FFFF0A 		beq	.L421
 6166 3644 050C52E3 		cmp	r2, #1280
 6167 3648 70FFFF1A 		bne	.L442
 6168              	.LVL542:
3442:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 6169              		.loc 1 3442 0
 6170 364c 0400A0E3 		mov	r0, #4
 6171 3650 FEFFFFEB 		bl	ControlHandle
 6172              	.LVL543:
 6173 3654 28309DE5 		ldr	r3, [sp, #40]
 6174 3658 11FFFFEA 		b	.L421
 6175              	.L439:
3423:../uvc.c      ****     switch (wValue)
 6176              		.loc 1 3423 0
 6177 365c 0A0C52E3 		cmp	r2, #2560
 6178 3660 4702000A 		beq	.L436
 6179 3664 1700008A 		bhi	.L441
 6180 3668 070C52E3 		cmp	r2, #1792
 6181 366c 4002000A 		beq	.L434
 6182 3670 020B52E3 		cmp	r2, #2048
 6183 3674 65FFFF1A 		bne	.L442
 6184              	.LVL544:
3454:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 6185              		.loc 1 3454 0
 6186 3678 0700A0E3 		mov	r0, #7
 6187 367c FEFFFFEB 		bl	ControlHandle
 6188              	.LVL545:
 6189 3680 28309DE5 		ldr	r3, [sp, #40]
 6190 3684 06FFFFEA 		b	.L421
 6191              	.L455:
 6192              	.LBE126:
 6193              	.LBE134:
 6194              	.LBB135:
 6195              	.LBB119:
3498:../uvc.c      ****     switch (wValue)
 6196              		.loc 1 3498 0
 6197 3688 010B52E3 		cmp	r2, #1024
 6198 368c 3402000A 		beq	.L446
 6199 3690 050C52E3 		cmp	r2, #1280
 6200 3694 5DFFFF1A 		bne	.L442
 6201              	.LVL546:
3520:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 6202              		.loc 1 3520 0
 6203 3698 0400A0E3 		mov	r0, #4
 6204 369c FEFFFFEB 		bl	CTControlHandle
 6205              	.LVL547:
 6206 36a0 28309DE5 		ldr	r3, [sp, #40]
 6207 36a4 FEFEFFEA 		b	.L421
 6208              	.L454:
3498:../uvc.c      ****     switch (wValue)
 6209              		.loc 1 3498 0
 6210 36a8 090C52E3 		cmp	r2, #2304
 6211 36ac 2802000A 		beq	.L450
 6212 36b0 0E00008A 		bhi	.L456
 6213 36b4 070C52E3 		cmp	r2, #1792
 6214 36b8 2102000A 		beq	.L449
 6215 36bc 020B52E3 		cmp	r2, #2048
 6216 36c0 52FFFF1A 		bne	.L442
 6217 36c4 F6FEFFEA 		b	.L421
 6218              	.L441:
 6219              	.LBE119:
 6220              	.LBE135:
 6221              	.LBB136:
 6222              	.LBB124:
3423:../uvc.c      ****     switch (wValue)
 6223              		.loc 1 3423 0
 6224 36c8 0D0C52E3 		cmp	r2, #3328
 6225 36cc 2C02000A 		beq	.L436
 6226 36d0 0E0C52E3 		cmp	r2, #3584
 6227 36d4 1602000A 		beq	.L438
 6228 36d8 030B52E3 		cmp	r2, #3072
 6229 36dc 4BFFFF1A 		bne	.L442
 6230              	.LVL548:
3464:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 6231              		.loc 1 3464 0
 6232 36e0 0B00A0E3 		mov	r0, #11
 6233 36e4 FEFFFFEB 		bl	ControlHandle
 6234              	.LVL549:
 6235 36e8 28309DE5 		ldr	r3, [sp, #40]
 6236 36ec ECFEFFEA 		b	.L421
 6237              	.L456:
 6238              	.LBE124:
 6239              	.LBE136:
 6240              	.LBB137:
 6241              	.LBB117:
3498:../uvc.c      ****     switch (wValue)
 6242              		.loc 1 3498 0
 6243 36f0 0B0C52E3 		cmp	r2, #2816
 6244 36f4 0A02000A 		beq	.L452
 6245 36f8 030B52E3 		cmp	r2, #3072
 6246 36fc 0402000A 		beq	.L453
 6247 3700 0A0C52E3 		cmp	r2, #2560
 6248 3704 41FFFF1A 		bne	.L442
 6249              	.LVL550:
3539:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 6250              		.loc 1 3539 0
 6251 3708 0800A0E3 		mov	r0, #8
 6252 370c FEFFFFEB 		bl	CTControlHandle
 6253              	.LVL551:
 6254 3710 28309DE5 		ldr	r3, [sp, #40]
 6255 3714 E2FEFFEA 		b	.L421
 6256              	.LVL552:
 6257              	.L570:
 6258              	.LBE117:
 6259              	.LBE137:
4428:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
 6260              		.loc 1 4428 0
 6261 3718 010053E3 		cmp	r3, #1
 6262 371c 1800000A 		beq	.L635
4448:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
 6263              		.loc 1 4448 0
 6264 3720 000096E5 		ldr	r0, [r6, #0]
 6265 3724 0C10A0E1 		mov	r1, ip
 6266 3728 BC21DDE1 		ldrh	r2, [sp, #28]
 6267 372c FEFFFFEB 		bl	CyU3PMemCopy
4449:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
 6268              		.loc 1 4449 0
 6269 3730 001096E5 		ldr	r1, [r6, #0]
 6270 3734 BC21DDE1 		ldrh	r2, [sp, #28]
 6271 3738 0100D1E5 		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 6272 373c 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6273 3740 00008DE5 		str	r0, [sp, #0]
 6274 3744 02C0D1E5 		ldrb	ip, [r1, #2]	@ zero_extendqisi2
 6275 3748 0400A0E3 		mov	r0, #4
 6276 374c 1C1A9FE5 		ldr	r1, .L639+64
 6277 3750 04C08DE5 		str	ip, [sp, #4]
 6278 3754 FEFFFFEB 		bl	CyU3PDebugPrint
 6279 3758 03FFFFEA 		b	.L574
 6280              	.L628:
4393:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
 6281              		.loc 1 4393 0
 6282 375c 0400A0E3 		mov	r0, #4
 6283 3760 0C1A9FE5 		ldr	r1, .L639+68
 6284 3764 0720A0E1 		mov	r2, r7
 6285 3768 FEFFFFEB 		bl	CyU3PDebugPrint
 6286              	.L569:
 6287              	.LBB138:
 6288              	.LBB139:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6289              		.loc 1 2061 0
 6290 376c E0199FE5 		ldr	r1, .L639+36
 6291 3770 0400A0E3 		mov	r0, #4
 6292 3774 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 6293              		.loc 1 2062 0
 6294 3778 FA0FA0E3 		mov	r0, #1000
 6295 377c FEFFFFEB 		bl	_tx_thread_sleep
 6296 3780 F9FFFFEA 		b	.L569
 6297              	.L635:
 6298              	.LBE139:
 6299              	.LBE138:
4432:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
 6300              		.loc 1 4432 0
 6301 3784 0110DCE5 		ldrb	r1, [ip, #1]	@ zero_extendqisi2
 6302 3788 0220DCE5 		ldrb	r2, [ip, #2]	@ zero_extendqisi2
 6303 378c 03C0DCE5 		ldrb	ip, [ip, #3]	@ zero_extendqisi2
 6304 3790 0730A0E1 		mov	r3, r7
 6305 3794 7000A0E3 		mov	r0, #112
 6306 3798 007096E5 		ldr	r7, [r6, #0]
 6307              	.LVL553:
 6308 379c 00C08DE5 		str	ip, [sp, #0]
 6309 37a0 FEFFFFEB 		bl	SensorWrite2B
 6310              	.LVL554:
4434:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
 6311              		.loc 1 4434 0
 6312 37a4 CC199FE5 		ldr	r1, .L639+72
4432:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
 6313              		.loc 1 4432 0
 6314 37a8 0000C7E5 		strb	r0, [r7, #0]
4434:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
 6315              		.loc 1 4434 0
 6316 37ac 18009DE5 		ldr	r0, [sp, #24]
 6317 37b0 BC21DDE1 		ldrh	r2, [sp, #28]
 6318 37b4 03E0D0E5 		ldrb	lr, [r0, #3]	@ zero_extendqisi2
 6319 37b8 0230D0E5 		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 6320 37bc 03C080E2 		add	ip, r0, #3
 6321 37c0 0400A0E3 		mov	r0, #4
 6322 37c4 00E08DE5 		str	lr, [sp, #0]
 6323 37c8 04C08DE5 		str	ip, [sp, #4]
 6324 37cc FEFFFFEB 		bl	CyU3PDebugPrint
4435:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
 6325              		.loc 1 4435 0
 6326 37d0 001096E5 		ldr	r1, [r6, #0]
 6327 37d4 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 6328 37d8 000053E3 		cmp	r3, #0
 6329 37dc CA01001A 		bne	.L418
4441:../uvc.c      ****                     dmaInfo.count -= 2;
 6330              		.loc 1 4441 0
 6331 37e0 BC71DDE1 		ldrh	r7, [sp, #28]
 6332 37e4 022047E2 		sub	r2, r7, #2
 6333 37e8 BC21CDE1 		strh	r2, [sp, #28]	@ movhi
 6334 37ec DEFEFFEA 		b	.L574
 6335              	.L487:
 6336              	.LVL555:
 6337              	.LBB140:
 6338              	.LBB109:
3829:../uvc.c      ****     switch (wValue)
 6339              		.loc 1 3829 0
 6340 37f0 44099FE5 		ldr	r0, .L639+12
 6341 37f4 B020D0E1 		ldrh	r2, [r0, #0]
 6342 37f8 030C52E3 		cmp	r2, #768
 6343 37fc 2001000A 		beq	.L491
 6344 3800 2100008A 		bhi	.L494
 6345 3804 010C52E3 		cmp	r2, #256
 6346 3808 FD00000A 		beq	.L489
 6347 380c 020C52E3 		cmp	r2, #512
 6348 3810 A9FEFF1A 		bne	.L488
3894:../uvc.c      ****             switch (bRequest)
 6349              		.loc 1 3894 0
 6350 3814 3C299FE5 		ldr	r2, .L639+40
 6351 3818 0030D2E5 		ldrb	r3, [r2, #0]	@ zero_extendqisi2
 6352 381c 810053E3 		cmp	r3, #129
 6353 3820 5300000A 		beq	.L554
 6354 3824 B301008A 		bhi	.L507
 6355 3828 010053E3 		cmp	r3, #1
 6356 382c 6C00001A 		bne	.L531
3919:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6357              		.loc 1 3919 0
 6358 3830 2000A0E3 		mov	r0, #32
 6359 3834 40199FE5 		ldr	r1, .L639+76
 6360 3838 2E208DE2 		add	r2, sp, #46
 6361 383c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6362              	.LVL556:
3921:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6363              		.loc 1 3921 0
 6364 3840 000050E3 		cmp	r0, #0
 6365 3844 A0FEFF1A 		bne	.L615
3923:../uvc.c      ****                         switch (glCommitCtrl[3])
 6366              		.loc 1 3923 0
 6367 3848 8301D4E5 		ldrb	r0, [r4, #387]	@ zero_extendqisi2
 6368              	.LVL557:
 6369 384c 011040E2 		sub	r1, r0, #1
 6370 3850 030051E3 		cmp	r1, #3
 6371 3854 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6372 3858 570100EA 		b	.L509
 6373              	.L514:
 6374 385c 4C3E0000 		.word	.L510
 6375 3860 003E0000 		.word	.L511
 6376 3864 983E0000 		.word	.L512
 6377 3868 603D0000 		.word	.L513
 6378              	.L485:
 6379              	.LBE109:
 6380              	.LBE140:
 6381              	.LBB141:
 6382              	.LBB104:
3728:../uvc.c      ****     switch (wValue)
 6383              		.loc 1 3728 0
 6384 386c 120C53E3 		cmp	r3, #4608
 6385 3870 DF00000A 		beq	.L478
 6386 3874 130C53E3 		cmp	r3, #4864
 6387 3878 84FEFF1A 		bne	.L422
 6388              	.LVL558:
3809:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
 6389              		.loc 1 3809 0
 6390 387c 2600A0E3 		mov	r0, #38
 6391 3880 FEFFFFEB 		bl	ControlHandle
 6392              	.LVL559:
 6393 3884 28309DE5 		ldr	r3, [sp, #40]
 6394 3888 85FEFFEA 		b	.L421
 6395              	.LVL560:
 6396              	.L494:
 6397              	.LBE104:
 6398              	.LBE141:
 6399              	.LBB142:
 6400              	.LBB111:
3829:../uvc.c      ****     switch (wValue)
 6401              		.loc 1 3829 0
 6402 388c 010B52E3 		cmp	r2, #1024
 6403 3890 4C00000A 		beq	.L492
 6404 3894 050C52E3 		cmp	r2, #1280
 6405 3898 87FEFF1A 		bne	.L488
4114:../uvc.c      ****             	switch (bRequest)
 6406              		.loc 1 4114 0
 6407 389c B4189FE5 		ldr	r1, .L639+40
 6408 38a0 0020D1E5 		ldrb	r2, [r1, #0]	@ zero_extendqisi2
 6409 38a4 810052E3 		cmp	r2, #129
 6410 38a8 3100000A 		beq	.L554
 6411 38ac 2500008A 		bhi	.L557
 6412 38b0 010052E3 		cmp	r2, #1
 6413 38b4 80FEFF1A 		bne	.L488
4139:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6414              		.loc 1 4139 0
 6415 38b8 2000A0E3 		mov	r0, #32
 6416 38bc B8189FE5 		ldr	r1, .L639+76
 6417 38c0 2E208DE2 		add	r2, sp, #46
 6418 38c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6419              	.LVL561:
4141:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6420              		.loc 1 4141 0
 6421 38c8 000050E3 		cmp	r0, #0
 6422 38cc 1700001A 		bne	.L559
4145:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 6423              		.loc 1 4145 0
 6424 38d0 0020A0E3 		mov	r2, #0
 6425 38d4 54089FE5 		ldr	r0, .L639
 6426              	.LVL562:
 6427 38d8 8010A0E3 		mov	r1, #128
 6428 38dc FEFFFFEB 		bl	_txe_event_flags_set
 6429              	.LVL563:
4146:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 6430              		.loc 1 4146 0
 6431 38e0 002050E2 		subs	r2, r0, #0
4152:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
 6432              		.loc 1 4152 0
 6433 38e4 0F70E003 		mvneq	r7, #15
 6434 38e8 BA70C505 		streqb	r7, [r5, #186]
4146:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 6435              		.loc 1 4146 0
 6436 38ec 0200000A 		beq	.L561
4148:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
 6437              		.loc 1 4148 0
 6438 38f0 88189FE5 		ldr	r1, .L639+80
 6439 38f4 0400A0E3 		mov	r0, #4
 6440              	.LVL564:
 6441 38f8 FEFFFFEB 		bl	CyU3PDebugPrint
 6442              	.LVL565:
 6443              	.L561:
4155:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
 6444              		.loc 1 4155 0
 6445 38fc 81E1D4E5 		ldrb	lr, [r4, #385]	@ zero_extendqisi2
 6446 3900 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6447 3904 BE22DDE1 		ldrh	r2, [sp, #46]
 6448              	.LVL566:
 6449 3908 0400A0E3 		mov	r0, #4
 6450 390c 70189FE5 		ldr	r1, .L639+84
 6451 3910 00E08DE5 		str	lr, [sp, #0]
 6452 3914 FEFFFFEB 		bl	CyU3PDebugPrint
 6453 3918 28309DE5 		ldr	r3, [sp, #40]
 6454 391c 6BFEFFEA 		b	.L486
 6455              	.LVL567:
 6456              	.L470:
 6457              	.LBE111:
 6458              	.LBE142:
 6459              	.LBB143:
 6460              	.LBB101:
3764:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 6461              		.loc 1 3764 0
 6462 3920 1800A0E3 		mov	r0, #24
 6463 3924 FEFFFFEB 		bl	ControlHandle
 6464              	.LVL568:
 6465 3928 28309DE5 		ldr	r3, [sp, #40]
 6466 392c 5CFEFFEA 		b	.L421
 6467              	.LVL569:
 6468              	.L559:
 6469              	.LBE101:
 6470              	.LBE143:
 6471              	.LBB144:
 6472              	.LBB108:
4157:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 6473              		.loc 1 4157 0
 6474 3930 50189FE5 		ldr	r1, .L639+88
 6475 3934 BE22DDE1 		ldrh	r2, [sp, #46]
 6476 3938 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6477 393c 0400A0E3 		mov	r0, #4
 6478              	.LVL570:
 6479 3940 FEFFFFEB 		bl	CyU3PDebugPrint
 6480 3944 5CFEFFEA 		b	.L488
 6481              	.LVL571:
 6482              	.L557:
4114:../uvc.c      ****             	switch (bRequest)
 6483              		.loc 1 4114 0
 6484 3948 850052E3 		cmp	r2, #133
 6485 394c 1000000A 		beq	.L555
 6486 3950 860052E3 		cmp	r2, #134
 6487 3954 58FEFF1A 		bne	.L488
 6488              	.L620:
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6489              		.loc 1 3898 0
 6490 3958 0100A0E3 		mov	r0, #1
 6491              	.L614:
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6492              		.loc 1 3897 0
 6493 395c 0330A0E3 		mov	r3, #3
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6494              		.loc 1 3898 0
 6495 3960 24189FE5 		ldr	r1, .L639+92
3897:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 6496              		.loc 1 3897 0
 6497 3964 1C31C4E5 		strb	r3, [r4, #284]
3898:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6498              		.loc 1 3898 0
 6499 3968 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6500 396c 28309DE5 		ldr	r3, [sp, #40]
 6501 3970 56FEFFEA 		b	.L486
 6502              	.L554:
4126:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6503              		.loc 1 4126 0
 6504 3974 C8C0D4E5 		ldrb	ip, [r4, #200]	@ zero_extendqisi2
 6505 3978 03005CE3 		cmp	ip, #3
 6506 397c 0C00000A 		beq	.L636
 6507              	.L558:
4132:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6508              		.loc 1 4132 0
 6509 3980 1A00A0E3 		mov	r0, #26
 6510 3984 04189FE5 		ldr	r1, .L639+96
 6511 3988 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6512 398c 28309DE5 		ldr	r3, [sp, #40]
 6513 3990 4EFEFFEA 		b	.L486
 6514              	.L555:
4123:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6515              		.loc 1 4123 0
 6516 3994 F0179FE5 		ldr	r1, .L639+92
 6517 3998 0200A0E3 		mov	r0, #2
 6518              	.L616:
4122:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6519              		.loc 1 4122 0
 6520 399c 0020A0E3 		mov	r2, #0
4121:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 6521              		.loc 1 4121 0
 6522 39a0 1C31C4E5 		strb	r3, [r4, #284]
4122:../uvc.c      ****                         glEp0Buffer[1] = 0;
 6523              		.loc 1 4122 0
 6524 39a4 1D21C4E5 		strb	r2, [r4, #285]
4123:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6525              		.loc 1 4123 0
 6526 39a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6527 39ac 28309DE5 		ldr	r3, [sp, #40]
 6528 39b0 46FEFFEA 		b	.L486
 6529              	.L636:
4128:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 6530              		.loc 1 4128 0
 6531 39b4 1A00A0E3 		mov	r0, #26
 6532 39b8 D4179FE5 		ldr	r1, .L639+100
 6533 39bc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6534 39c0 28309DE5 		ldr	r3, [sp, #40]
 6535 39c4 41FEFFEA 		b	.L486
 6536              	.L492:
4028:../uvc.c      ****                 switch (bRequest)
 6537              		.loc 1 4028 0
 6538 39c8 88279FE5 		ldr	r2, .L639+40
 6539 39cc 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 6540 39d0 810052E3 		cmp	r2, #129
 6541 39d4 1D00000A 		beq	.L533
 6542 39d8 1600008A 		bhi	.L536
 6543 39dc 010052E3 		cmp	r2, #1
 6544 39e0 0500000A 		beq	.L637
 6545              	.L531:
4107:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 6546              		.loc 1 4107 0
 6547 39e4 0000A0E3 		mov	r0, #0
 6548 39e8 0110A0E3 		mov	r1, #1
 6549 39ec 0020A0E1 		mov	r2, r0
 6550 39f0 FEFFFFEB 		bl	CyU3PUsbStall
 6551 39f4 28309DE5 		ldr	r3, [sp, #40]
 6552 39f8 34FEFFEA 		b	.L486
 6553              	.L637:
4053:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6554              		.loc 1 4053 0
 6555 39fc 2000A0E3 		mov	r0, #32
 6556 3a00 74179FE5 		ldr	r1, .L639+76
 6557 3a04 2E208DE2 		add	r2, sp, #46
 6558 3a08 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6559              	.LVL572:
4055:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6560              		.loc 1 4055 0
 6561 3a0c 000050E3 		cmp	r0, #0
 6562 3a10 2DFEFF1A 		bne	.L615
4074:../uvc.c      ****                            switch (glCommitCtrl[1])
 6563              		.loc 1 4074 0
 6564 3a14 8101D5E5 		ldrb	r0, [r5, #385]	@ zero_extendqisi2
 6565              	.LVL573:
 6566 3a18 011040E2 		sub	r1, r0, #1
 6567 3a1c 030051E3 		cmp	r1, #3
 6568 3a20 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 6569 3a24 210000EA 		b	.L538
 6570              	.L543:
 6571 3a28 443B0000 		.word	.L539
 6572 3a2c 9C3B0000 		.word	.L540
 6573 3a30 003B0000 		.word	.L541
 6574 3a34 703A0000 		.word	.L542
 6575              	.LVL574:
 6576              	.L536:
4028:../uvc.c      ****                 switch (bRequest)
 6577              		.loc 1 4028 0
 6578 3a38 850052E3 		cmp	r2, #133
 6579 3a3c 2B00000A 		beq	.L534
 6580 3a40 860052E3 		cmp	r2, #134
 6581 3a44 E6FFFF1A 		bne	.L531
 6582              	.L619:
4032:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 6583              		.loc 1 4032 0
 6584 3a48 0300A0E1 		mov	r0, r3
 6585 3a4c C2FFFFEA 		b	.L614
 6586              	.L533:
4040:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6587              		.loc 1 4040 0
 6588 3a50 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
4042:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6589              		.loc 1 4042 0
 6590 3a54 0B00A0E3 		mov	r0, #11
4040:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6591              		.loc 1 4040 0
 6592 3a58 030053E3 		cmp	r3, #3
4042:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6593              		.loc 1 4042 0
 6594 3a5c 34179F05 		ldreq	r1, .L639+104
4046:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 6595              		.loc 1 4046 0
 6596 3a60 34179F15 		ldrne	r1, .L639+108
 6597 3a64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 6598 3a68 28309DE5 		ldr	r3, [sp, #40]
 6599 3a6c 17FEFFEA 		b	.L486
 6600              	.LVL575:
 6601              	.L542:
4077:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
 6602              		.loc 1 4077 0
 6603 3a70 D82094E5 		ldr	r2, [r4, #216]
 6604 3a74 3010A0E3 		mov	r1, #48
 6605 3a78 000052E3 		cmp	r2, #0
 6606 3a7c E420A003 		moveq	r2, #228
 6607 3a80 6420A013 		movne	r2, #100
 6608 3a84 5230A0E3 		mov	r3, #82
 6609 3a88 0100A0E3 		mov	r0, #1
 6610 3a8c FEFFFFEB 		bl	SensorSetIrisControl
4079:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6611              		.loc 1 4079 0
 6612 3a90 D82094E5 		ldr	r2, [r4, #216]
 6613 3a94 04179FE5 		ldr	r1, .L639+112
 6614 3a98 000052E3 		cmp	r2, #0
 6615 3a9c D83094E5 		ldr	r3, [r4, #216]
 6616 3aa0 E420A003 		moveq	r2, #228
 6617 3aa4 6420A013 		movne	r2, #100
 6618 3aa8 0400A0E3 		mov	r0, #4
 6619 3aac FEFFFFEB 		bl	CyU3PDebugPrint
 6620              	.L538:
4099:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6621              		.loc 1 4099 0
 6622 3ab0 81E1D4E5 		ldrb	lr, [r4, #385]	@ zero_extendqisi2
4101:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6623              		.loc 1 4101 0
 6624 3ab4 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6625 3ab8 BE22DDE1 		ldrh	r2, [sp, #46]
 6626              	.LVL576:
 6627 3abc 0400A0E3 		mov	r0, #4
 6628 3ac0 DC169FE5 		ldr	r1, .L639+116
4099:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
 6629              		.loc 1 4099 0
 6630 3ac4 A0E1C4E5 		strb	lr, [r4, #416]
4101:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
 6631              		.loc 1 4101 0
 6632 3ac8 00E08DE5 		str	lr, [sp, #0]
 6633 3acc FEFFFFEB 		bl	CyU3PDebugPrint
 6634 3ad0 28309DE5 		ldr	r3, [sp, #40]
 6635 3ad4 FDFDFFEA 		b	.L486
 6636              	.LVL577:
 6637              	.L528:
3978:../uvc.c      ****                 switch (bRequest)
 6638              		.loc 1 3978 0
 6639 3ad8 860052E3 		cmp	r2, #134
 6640 3adc D9FFFF0A 		beq	.L619
 6641 3ae0 870052E3 		cmp	r2, #135
 6642 3ae4 D9FFFF0A 		beq	.L533
 6643              	.L624:
 6644 3ae8 850052E3 		cmp	r2, #133
 6645 3aec BCFFFF1A 		bne	.L531
 6646              	.L534:
4037:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 6647              		.loc 1 4037 0
 6648 3af0 0200A0E3 		mov	r0, #2
 6649 3af4 90169FE5 		ldr	r1, .L639+92
4035:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 6650              		.loc 1 4035 0
 6651 3af8 1A30A0E3 		mov	r3, #26
 6652 3afc A6FFFFEA 		b	.L616
 6653              	.LVL578:
 6654              	.L541:
4082:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
 6655              		.loc 1 4082 0
 6656 3b00 D82094E5 		ldr	r2, [r4, #216]
 6657 3b04 3010A0E3 		mov	r1, #48
 6658 3b08 000052E3 		cmp	r2, #0
 6659 3b0c D420A003 		moveq	r2, #212
 6660 3b10 5420A013 		movne	r2, #84
 6661 3b14 5230A0E3 		mov	r3, #82
 6662 3b18 0100A0E3 		mov	r0, #1
 6663 3b1c FEFFFFEB 		bl	SensorSetIrisControl
4084:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
 6664              		.loc 1 4084 0
 6665 3b20 D82094E5 		ldr	r2, [r4, #216]
 6666 3b24 74169FE5 		ldr	r1, .L639+112
 6667 3b28 000052E3 		cmp	r2, #0
 6668 3b2c D83094E5 		ldr	r3, [r4, #216]
 6669 3b30 D420A003 		moveq	r2, #212
 6670 3b34 5420A013 		movne	r2, #84
 6671 3b38 0400A0E3 		mov	r0, #4
 6672 3b3c FEFFFFEB 		bl	CyU3PDebugPrint
 6673 3b40 DAFFFFEA 		b	.L538
 6674              	.L539:
4092:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
 6675              		.loc 1 4092 0
 6676 3b44 14769FE5 		ldr	r7, .L639+48
 6677 3b48 D80094E5 		ldr	r0, [r4, #216]
 6678 3b4c 8D34D7E5 		ldrb	r3, [r7, #1165]	@ zero_extendqisi2
 6679 3b50 000050E3 		cmp	r0, #0
 6680 3b54 F400A003 		moveq	r0, #244
 6681 3b58 7400A013 		movne	r0, #116
 6682 3b5c 032080E1 		orr	r2, r0, r3
 6683 3b60 3010A0E3 		mov	r1, #48
 6684 3b64 5230A0E3 		mov	r3, #82
 6685 3b68 0100A0E3 		mov	r0, #1
 6686 3b6c FEFFFFEB 		bl	SensorSetIrisControl
4094:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6687              		.loc 1 4094 0
 6688 3b70 D8C094E5 		ldr	ip, [r4, #216]
 6689 3b74 8D74D7E5 		ldrb	r7, [r7, #1165]	@ zero_extendqisi2
 6690 3b78 00005CE3 		cmp	ip, #0
 6691 3b7c F4C0A003 		moveq	ip, #244
 6692 3b80 74C0A013 		movne	ip, #116
 6693 3b84 D83094E5 		ldr	r3, [r4, #216]
 6694 3b88 10169FE5 		ldr	r1, .L639+112
 6695 3b8c 07208CE1 		orr	r2, ip, r7
 6696 3b90 0400A0E3 		mov	r0, #4
 6697 3b94 FEFFFFEB 		bl	CyU3PDebugPrint
 6698 3b98 C4FFFFEA 		b	.L538
 6699              	.L540:
4087:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
 6700              		.loc 1 4087 0
 6701 3b9c BC759FE5 		ldr	r7, .L639+48
 6702 3ba0 D8E094E5 		ldr	lr, [r4, #216]
 6703 3ba4 8D24D7E5 		ldrb	r2, [r7, #1165]	@ zero_extendqisi2
 6704 3ba8 00005EE3 		cmp	lr, #0
 6705 3bac C4E0A003 		moveq	lr, #196
 6706 3bb0 44E0A013 		movne	lr, #68
 6707 3bb4 02208EE1 		orr	r2, lr, r2
 6708 3bb8 3010A0E3 		mov	r1, #48
 6709 3bbc 5230A0E3 		mov	r3, #82
 6710 3bc0 0100A0E3 		mov	r0, #1
 6711 3bc4 FEFFFFEB 		bl	SensorSetIrisControl
4089:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
 6712              		.loc 1 4089 0
 6713 3bc8 D8C094E5 		ldr	ip, [r4, #216]
 6714 3bcc 8D74D7E5 		ldrb	r7, [r7, #1165]	@ zero_extendqisi2
 6715 3bd0 00005CE3 		cmp	ip, #0
 6716 3bd4 C4C0A003 		moveq	ip, #196
 6717 3bd8 44C0A013 		movne	ip, #68
 6718 3bdc D83094E5 		ldr	r3, [r4, #216]
 6719 3be0 B8159FE5 		ldr	r1, .L639+112
 6720 3be4 07208CE1 		orr	r2, ip, r7
 6721 3be8 0400A0E3 		mov	r0, #4
 6722 3bec FEFFFFEB 		bl	CyU3PDebugPrint
 6723 3bf0 AEFFFFEA 		b	.L538
 6724              	.L478:
 6725              	.LVL579:
 6726              	.LBE108:
 6727              	.LBE144:
 6728              	.LBB145:
 6729              	.LBB105:
3805:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
 6730              		.loc 1 3805 0
 6731 3bf4 2500A0E3 		mov	r0, #37
 6732 3bf8 FEFFFFEB 		bl	ControlHandle
 6733              	.LVL580:
 6734 3bfc 28309DE5 		ldr	r3, [sp, #40]
 6735 3c00 A7FDFFEA 		b	.L421
 6736              	.LVL581:
 6737              	.L489:
 6738              	.LBE105:
 6739              	.LBE145:
 6740              	.LBB146:
 6741              	.LBB112:
3832:../uvc.c      ****             switch (bRequest)
 6742              		.loc 1 3832 0
 6743 3c04 4C759FE5 		ldr	r7, .L639+40
 6744 3c08 0020D7E5 		ldrb	r2, [r7, #0]	@ zero_extendqisi2
 6745 3c0c 830052E3 		cmp	r2, #131
 6746 3c10 4200008A 		bhi	.L500
 6747 3c14 810052E3 		cmp	r2, #129
 6748 3c18 4400002A 		bcs	.L497
 6749 3c1c 010052E3 		cmp	r2, #1
 6750 3c20 6FFFFF1A 		bne	.L531
3859:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6751              		.loc 1 3859 0
 6752 3c24 2000A0E3 		mov	r0, #32
 6753 3c28 4C159FE5 		ldr	r1, .L639+76
 6754 3c2c 2E208DE2 		add	r2, sp, #46
 6755 3c30 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6756              	.LVL582:
3861:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 6757              		.loc 1 3861 0
 6758 3c34 000050E3 		cmp	r0, #0
 6759 3c38 A3FDFF1A 		bne	.L615
3863:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 6760              		.loc 1 3863 0
 6761 3c3c C870D5E5 		ldrb	r7, [r5, #200]	@ zero_extendqisi2
 6762 3c40 030057E3 		cmp	r7, #3
 6763 3c44 A0FDFF1A 		bne	.L615
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6764              		.loc 1 3867 0
 6765 3c48 10359FE5 		ldr	r3, .L639+48
 6766 3c4c 8271D4E5 		ldrb	r7, [r4, #386]	@ zero_extendqisi2
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6767              		.loc 1 3868 0
 6768 3c50 83E1D4E5 		ldrb	lr, [r4, #387]	@ zero_extendqisi2
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6769              		.loc 1 3869 0
 6770 3c54 84C1D4E5 		ldrb	ip, [r4, #388]	@ zero_extendqisi2
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6771              		.loc 1 3870 0
 6772 3c58 8501D4E5 		ldrb	r0, [r4, #389]	@ zero_extendqisi2
 6773              	.LVL583:
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6774              		.loc 1 3871 0
 6775 3c5c 8611D4E5 		ldrb	r1, [r4, #390]	@ zero_extendqisi2
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6776              		.loc 1 3872 0
 6777 3c60 8721D4E5 		ldrb	r2, [r4, #391]	@ zero_extendqisi2
3867:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
 6778              		.loc 1 3867 0
 6779 3c64 A276C3E5 		strb	r7, [r3, #1698]
3868:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 6780              		.loc 1 3868 0
 6781 3c68 A3E6C3E5 		strb	lr, [r3, #1699]
3869:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 6782              		.loc 1 3869 0
 6783 3c6c A4C6C3E5 		strb	ip, [r3, #1700]
3870:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 6784              		.loc 1 3870 0
 6785 3c70 A506C3E5 		strb	r0, [r3, #1701]
3871:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 6786              		.loc 1 3871 0
 6787 3c74 A616C3E5 		strb	r1, [r3, #1702]
3872:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 6788              		.loc 1 3872 0
 6789 3c78 A726C3E5 		strb	r2, [r3, #1703]
 6790 3c7c 28309DE5 		ldr	r3, [sp, #40]
 6791 3c80 92FDFFEA 		b	.L486
 6792              	.LVL584:
 6793              	.L491:
3978:../uvc.c      ****                 switch (bRequest)
 6794              		.loc 1 3978 0
 6795 3c84 CC249FE5 		ldr	r2, .L639+40
 6796 3c88 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
 6797 3c8c 830052E3 		cmp	r2, #131
 6798 3c90 90FFFF8A 		bhi	.L528
 6799 3c94 810052E3 		cmp	r2, #129
 6800 3c98 6CFFFF2A 		bcs	.L533
 6801 3c9c 010052E3 		cmp	r2, #1
 6802 3ca0 4FFFFF1A 		bne	.L531
4003:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 6803              		.loc 1 4003 0
 6804 3ca4 2000A0E3 		mov	r0, #32
 6805 3ca8 CC149FE5 		ldr	r1, .L639+76
 6806 3cac 2E208DE2 		add	r2, sp, #46
 6807 3cb0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 6808              	.LVL585:
4005:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 6809              		.loc 1 4005 0
 6810 3cb4 000050E3 		cmp	r0, #0
 6811 3cb8 83FDFF1A 		bne	.L615
4007:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 6812              		.loc 1 4007 0
 6813 3cbc C810D5E5 		ldrb	r1, [r5, #200]	@ zero_extendqisi2
 6814 3cc0 030051E3 		cmp	r1, #3
 6815 3cc4 0C00001A 		bne	.L530
4011:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6816              		.loc 1 4011 0
 6817 3cc8 90349FE5 		ldr	r3, .L639+48
 6818 3ccc 8171D5E5 		ldrb	r7, [r5, #385]	@ zero_extendqisi2
4012:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6819              		.loc 1 4012 0
 6820 3cd0 82E1D5E5 		ldrb	lr, [r5, #386]	@ zero_extendqisi2
4013:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6821              		.loc 1 4013 0
 6822 3cd4 83C1D5E5 		ldrb	ip, [r5, #387]	@ zero_extendqisi2
4014:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6823              		.loc 1 4014 0
 6824 3cd8 8401D5E5 		ldrb	r0, [r5, #388]	@ zero_extendqisi2
 6825              	.LVL586:
4015:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6826              		.loc 1 4015 0
 6827 3cdc 8511D5E5 		ldrb	r1, [r5, #389]	@ zero_extendqisi2
4016:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6828              		.loc 1 4016 0
 6829 3ce0 8621D5E5 		ldrb	r2, [r5, #390]	@ zero_extendqisi2
4011:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 6830              		.loc 1 4011 0
 6831 3ce4 F576C3E5 		strb	r7, [r3, #1781]
4012:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 6832              		.loc 1 4012 0
 6833 3ce8 F6E6C3E5 		strb	lr, [r3, #1782]
4013:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 6834              		.loc 1 4013 0
 6835 3cec F7C6C3E5 		strb	ip, [r3, #1783]
4014:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 6836              		.loc 1 4014 0
 6837 3cf0 F806C3E5 		strb	r0, [r3, #1784]
4015:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 6838              		.loc 1 4015 0
 6839 3cf4 F916C3E5 		strb	r1, [r3, #1785]
4016:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 6840              		.loc 1 4016 0
 6841 3cf8 FA26C3E5 		strb	r2, [r3, #1786]
 6842              	.L530:
4018:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
 6843              		.loc 1 4018 0
 6844 3cfc 81C1D4E5 		ldrb	ip, [r4, #385]	@ zero_extendqisi2
 6845 3d00 8031D4E5 		ldrb	r3, [r4, #384]	@ zero_extendqisi2
 6846 3d04 BE22DDE1 		ldrh	r2, [sp, #46]
 6847              	.LVL587:
 6848 3d08 0400A0E3 		mov	r0, #4
 6849 3d0c 94149FE5 		ldr	r1, .L639+120
 6850 3d10 00C08DE5 		str	ip, [sp, #0]
 6851 3d14 FEFFFFEB 		bl	CyU3PDebugPrint
 6852 3d18 28309DE5 		ldr	r3, [sp, #40]
 6853 3d1c 6BFDFFEA 		b	.L486
 6854              	.LVL588:
 6855              	.L500:
3832:../uvc.c      ****             switch (bRequest)
 6856              		.loc 1 3832 0
 6857 3d20 860052E3 		cmp	r2, #134
 6858 3d24 47FFFF0A 		beq	.L619
 6859 3d28 870052E3 		cmp	r2, #135
 6860 3d2c 6DFFFF1A 		bne	.L624
 6861              	.L497:
3847:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
 6862              		.loc 1 3847 0
 6863 3d30 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
 6864 3d34 030053E3 		cmp	r3, #3
 6865 3d38 10FFFF1A 		bne	.L558
3849:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
 6866              		.loc 1 3849 0
 6867 3d3c 68149FE5 		ldr	r1, .L639+124
 6868 3d40 1A00A0E3 		mov	r0, #26
 6869 3d44 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
3850:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 6870              		.loc 1 3850 0
 6871 3d48 0400A0E3 		mov	r0, #4
 6872 3d4c 5C149FE5 		ldr	r1, .L639+128
 6873 3d50 0020D7E5 		ldrb	r2, [r7, #0]	@ zero_extendqisi2
 6874 3d54 FEFFFFEB 		bl	CyU3PDebugPrint
 6875 3d58 28309DE5 		ldr	r3, [sp, #40]
 6876 3d5c 5BFDFFEA 		b	.L486
 6877              	.LVL589:
 6878              	.L513:
3941:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
 6879              		.loc 1 3941 0
 6880 3d60 F8739FE5 		ldr	r7, .L639+48
 6881 3d64 D80094E5 		ldr	r0, [r4, #216]
 6882 3d68 8DE4D7E5 		ldrb	lr, [r7, #1165]	@ zero_extendqisi2
 6883 3d6c 000050E3 		cmp	r0, #0
 6884 3d70 F400A003 		moveq	r0, #244
 6885 3d74 7400A013 		movne	r0, #116
 6886 3d78 0E2080E1 		orr	r2, r0, lr
 6887 3d7c 3010A0E3 		mov	r1, #48
 6888 3d80 5230A0E3 		mov	r3, #82
 6889 3d84 0100A0E3 		mov	r0, #1
 6890 3d88 FEFFFFEB 		bl	SensorSetIrisControl
3942:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6891              		.loc 1 3942 0
 6892 3d8c 7D0FA0E3 		mov	r0, #500
 6893 3d90 FEFFFFEB 		bl	_tx_thread_sleep
3943:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6894              		.loc 1 3943 0
 6895 3d94 D8C094E5 		ldr	ip, [r4, #216]
 6896 3d98 8D24D7E5 		ldrb	r2, [r7, #1165]	@ zero_extendqisi2
 6897 3d9c 00005CE3 		cmp	ip, #0
 6898 3da0 F4C0A003 		moveq	ip, #244
 6899 3da4 74C0A013 		movne	ip, #116
 6900 3da8 D83094E5 		ldr	r3, [r4, #216]
 6901 3dac 0400A0E3 		mov	r0, #4
 6902 3db0 FC139FE5 		ldr	r1, .L639+132
 6903 3db4 02208CE1 		orr	r2, ip, r2
 6904 3db8 FEFFFFEB 		bl	CyU3PDebugPrint
 6905              	.L509:
3948:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6906              		.loc 1 3948 0
 6907 3dbc 8331D4E5 		ldrb	r3, [r4, #387]	@ zero_extendqisi2
3949:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6908              		.loc 1 3949 0
 6909 3dc0 F0139FE5 		ldr	r1, .L639+136
 6910 3dc4 0320A0E1 		mov	r2, r3
 6911 3dc8 0400A0E3 		mov	r0, #4
3948:../uvc.c      ****                         setRes = glCommitCtrl[3];
 6912              		.loc 1 3948 0
 6913 3dcc 7D31C4E5 		strb	r3, [r4, #381]
3949:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 6914              		.loc 1 3949 0
 6915 3dd0 FEFFFFEB 		bl	CyU3PDebugPrint
3962:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 6916              		.loc 1 3962 0
 6917 3dd4 0020A0E3 		mov	r2, #0
 6918 3dd8 50039FE5 		ldr	r0, .L639
 6919 3ddc 0110A0E3 		mov	r1, #1
 6920 3de0 FEFFFFEB 		bl	_txe_event_flags_set
 6921              	.LVL590:
3963:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 6922              		.loc 1 3963 0
 6923 3de4 002050E2 		subs	r2, r0, #0
 6924 3de8 37FDFF0A 		beq	.L615
3965:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
 6925              		.loc 1 3965 0
 6926 3dec 0400A0E3 		mov	r0, #4
 6927              	.LVL591:
 6928 3df0 C4139FE5 		ldr	r1, .L639+140
 6929 3df4 FEFFFFEB 		bl	CyU3PDebugPrint
 6930              	.LVL592:
 6931 3df8 28309DE5 		ldr	r3, [sp, #40]
 6932 3dfc 33FDFFEA 		b	.L486
 6933              	.L511:
3931:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
 6934              		.loc 1 3931 0
 6935 3e00 D82094E5 		ldr	r2, [r4, #216]
 6936 3e04 3010A0E3 		mov	r1, #48
 6937 3e08 000052E3 		cmp	r2, #0
 6938 3e0c D420A003 		moveq	r2, #212
 6939 3e10 5420A013 		movne	r2, #84
 6940 3e14 5230A0E3 		mov	r3, #82
 6941 3e18 0100A0E3 		mov	r0, #1
 6942 3e1c FEFFFFEB 		bl	SensorSetIrisControl
3932:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6943              		.loc 1 3932 0
 6944 3e20 7D0FA0E3 		mov	r0, #500
 6945 3e24 FEFFFFEB 		bl	_tx_thread_sleep
3933:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6946              		.loc 1 3933 0
 6947 3e28 D82094E5 		ldr	r2, [r4, #216]
 6948 3e2c 80139FE5 		ldr	r1, .L639+132
 6949 3e30 000052E3 		cmp	r2, #0
 6950 3e34 D83094E5 		ldr	r3, [r4, #216]
 6951 3e38 D420A003 		moveq	r2, #212
 6952 3e3c 5420A013 		movne	r2, #84
 6953 3e40 0400A0E3 		mov	r0, #4
 6954 3e44 FEFFFFEB 		bl	CyU3PDebugPrint
 6955 3e48 DBFFFFEA 		b	.L509
 6956              	.L510:
3926:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
 6957              		.loc 1 3926 0
 6958 3e4c D82094E5 		ldr	r2, [r4, #216]
 6959 3e50 3010A0E3 		mov	r1, #48
 6960 3e54 000052E3 		cmp	r2, #0
 6961 3e58 E420A003 		moveq	r2, #228
 6962 3e5c 6420A013 		movne	r2, #100
 6963 3e60 5230A0E3 		mov	r3, #82
 6964 3e64 0100A0E3 		mov	r0, #1
 6965 3e68 FEFFFFEB 		bl	SensorSetIrisControl
3927:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6966              		.loc 1 3927 0
 6967 3e6c 7D0FA0E3 		mov	r0, #500
 6968 3e70 FEFFFFEB 		bl	_tx_thread_sleep
3928:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 6969              		.loc 1 3928 0
 6970 3e74 D82094E5 		ldr	r2, [r4, #216]
 6971 3e78 34139FE5 		ldr	r1, .L639+132
 6972 3e7c 000052E3 		cmp	r2, #0
 6973 3e80 D83094E5 		ldr	r3, [r4, #216]
 6974 3e84 E420A003 		moveq	r2, #228
 6975 3e88 6420A013 		movne	r2, #100
 6976 3e8c 0400A0E3 		mov	r0, #4
 6977 3e90 FEFFFFEB 		bl	CyU3PDebugPrint
 6978 3e94 C8FFFFEA 		b	.L509
 6979              	.L512:
3936:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
 6980              		.loc 1 3936 0
 6981 3e98 C0729FE5 		ldr	r7, .L639+48
 6982 3e9c D8E094E5 		ldr	lr, [r4, #216]
 6983 3ea0 8D34D7E5 		ldrb	r3, [r7, #1165]	@ zero_extendqisi2
 6984 3ea4 00005EE3 		cmp	lr, #0
 6985 3ea8 C4E0A003 		moveq	lr, #196
 6986 3eac 44E0A013 		movne	lr, #68
 6987 3eb0 03208EE1 		orr	r2, lr, r3
 6988 3eb4 3010A0E3 		mov	r1, #48
 6989 3eb8 5230A0E3 		mov	r3, #82
 6990 3ebc 0100A0E3 		mov	r0, #1
 6991 3ec0 FEFFFFEB 		bl	SensorSetIrisControl
3937:../uvc.c      ****                          		CyU3PThreadSleep(500);
 6992              		.loc 1 3937 0
 6993 3ec4 7D0FA0E3 		mov	r0, #500
 6994 3ec8 FEFFFFEB 		bl	_tx_thread_sleep
3938:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 6995              		.loc 1 3938 0
 6996 3ecc D82094E5 		ldr	r2, [r4, #216]
 6997 3ed0 8DC4D7E5 		ldrb	ip, [r7, #1165]	@ zero_extendqisi2
 6998 3ed4 000052E3 		cmp	r2, #0
 6999 3ed8 C420A003 		moveq	r2, #196
 7000 3edc 4420A013 		movne	r2, #68
 7001 3ee0 D83094E5 		ldr	r3, [r4, #216]
 7002 3ee4 C8129FE5 		ldr	r1, .L639+132
 7003 3ee8 0C2082E1 		orr	r2, r2, ip
 7004 3eec 0400A0E3 		mov	r0, #4
 7005 3ef0 FEFFFFEB 		bl	CyU3PDebugPrint
 7006 3ef4 B0FFFFEA 		b	.L509
 7007              	.LVL593:
 7008              	.L507:
3894:../uvc.c      ****             switch (bRequest)
 7009              		.loc 1 3894 0
 7010 3ef8 850053E3 		cmp	r3, #133
 7011 3efc FBFEFF0A 		beq	.L534
 7012 3f00 860053E3 		cmp	r3, #134
 7013 3f04 B6FEFF1A 		bne	.L531
 7014 3f08 92FEFFEA 		b	.L620
 7015              	.LVL594:
 7016              	.L418:
 7017              	.LBE112:
 7018              	.LBE146:
4479:../uvc.c      **** }
 7019              		.loc 1 4479 0
 7020 3f0c 30D08DE2 		add	sp, sp, #48
 7021 3f10 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 7022              	.L453:
 7023              	.LVL595:
 7024              	.LBB147:
 7025              	.LBB120:
3547:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 7026              		.loc 1 3547 0
 7027 3f14 0A00A0E3 		mov	r0, #10
 7028 3f18 FEFFFFEB 		bl	CTControlHandle
 7029              	.LVL596:
 7030 3f1c 28309DE5 		ldr	r3, [sp, #40]
 7031 3f20 DFFCFFEA 		b	.L421
 7032              	.L452:
 7033              	.LVL597:
3543:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 7034              		.loc 1 3543 0
 7035 3f24 0900A0E3 		mov	r0, #9
 7036 3f28 FEFFFFEB 		bl	CTControlHandle
 7037              	.LVL598:
 7038 3f2c 28309DE5 		ldr	r3, [sp, #40]
 7039 3f30 DBFCFFEA 		b	.L421
 7040              	.L438:
 7041              	.LVL599:
 7042              	.LBE120:
 7043              	.LBE147:
 7044              	.LBB148:
 7045              	.LBB127:
3468:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 7046              		.loc 1 3468 0
 7047 3f34 0E00A0E3 		mov	r0, #14
 7048 3f38 FEFFFFEB 		bl	ControlHandle
 7049              	.LVL600:
 7050 3f3c 28309DE5 		ldr	r3, [sp, #40]
 7051 3f40 D7FCFFEA 		b	.L421
 7052              	.L449:
 7053              	.LVL601:
 7054              	.LBE127:
 7055              	.LBE148:
 7056              	.LBB149:
 7057              	.LBB116:
3528:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 7058              		.loc 1 3528 0
 7059 3f44 0600A0E3 		mov	r0, #6
 7060 3f48 FEFFFFEB 		bl	CTControlHandle
 7061              	.LVL602:
 7062 3f4c 28309DE5 		ldr	r3, [sp, #40]
 7063 3f50 D3FCFFEA 		b	.L421
 7064              	.L450:
 7065              	.LVL603:
3534:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 7066              		.loc 1 3534 0
 7067 3f54 0700A0E3 		mov	r0, #7
 7068 3f58 FEFFFFEB 		bl	CTControlHandle
 7069              	.LVL604:
 7070 3f5c 28309DE5 		ldr	r3, [sp, #40]
 7071 3f60 CFFCFFEA 		b	.L421
 7072              	.L446:
 7073              	.LVL605:
3515:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 7074              		.loc 1 3515 0
 7075 3f64 0300A0E3 		mov	r0, #3
 7076 3f68 FEFFFFEB 		bl	CTControlHandle
 7077              	.LVL606:
 7078 3f6c 28309DE5 		ldr	r3, [sp, #40]
 7079 3f70 CBFCFFEA 		b	.L421
 7080              	.L434:
 7081              	.LVL607:
 7082              	.LBE116:
 7083              	.LBE149:
 7084              	.LBB150:
 7085              	.LBB123:
3450:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 7086              		.loc 1 3450 0
 7087 3f74 0600A0E3 		mov	r0, #6
 7088 3f78 FEFFFFEB 		bl	ControlHandle
 7089              	.LVL608:
 7090 3f7c 28309DE5 		ldr	r3, [sp, #40]
 7091 3f80 C7FCFFEA 		b	.L421
 7092              	.L436:
 7093              	.LVL609:
3460:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 7094              		.loc 1 3460 0
 7095 3f84 0900A0E3 		mov	r0, #9
 7096 3f88 FEFFFFEB 		bl	ControlHandle
 7097              	.LVL610:
 7098 3f8c 28309DE5 		ldr	r3, [sp, #40]
 7099 3f90 C3FCFFEA 		b	.L421
 7100              	.L477:
 7101              	.LVL611:
 7102              	.LBE123:
 7103              	.LBE150:
 7104              	.LBB151:
 7105              	.LBB100:
3801:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
 7106              		.loc 1 3801 0
 7107 3f94 2400A0E3 		mov	r0, #36
 7108 3f98 FEFFFFEB 		bl	ControlHandle
 7109              	.LVL612:
 7110 3f9c 28309DE5 		ldr	r3, [sp, #40]
 7111 3fa0 BFFCFFEA 		b	.L421
 7112              	.L473:
 7113              	.LVL613:
3779:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
 7114              		.loc 1 3779 0
 7115 3fa4 1B00A0E3 		mov	r0, #27
 7116 3fa8 FEFFFFEB 		bl	ControlHandle
 7117              	.LVL614:
 7118 3fac 28309DE5 		ldr	r3, [sp, #40]
 7119 3fb0 BBFCFFEA 		b	.L421
 7120              	.L468:
 7121              	.LVL615:
3756:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 7122              		.loc 1 3756 0
 7123 3fb4 1600A0E3 		mov	r0, #22
 7124 3fb8 FEFFFFEB 		bl	ControlHandle
 7125              	.LVL616:
 7126 3fbc 28309DE5 		ldr	r3, [sp, #40]
 7127 3fc0 B7FCFFEA 		b	.L421
 7128              	.L472:
 7129              	.LVL617:
3775:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 7130              		.loc 1 3775 0
 7131 3fc4 1A00A0E3 		mov	r0, #26
 7132 3fc8 FEFFFFEB 		bl	ControlHandle
 7133              	.LVL618:
 7134 3fcc 28309DE5 		ldr	r3, [sp, #40]
 7135 3fd0 B3FCFFEA 		b	.L421
 7136              	.L475:
 7137              	.LVL619:
3793:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 7138              		.loc 1 3793 0
 7139 3fd4 1E00A0E3 		mov	r0, #30
 7140 3fd8 FEFFFFEB 		bl	ControlHandle
 7141              	.LVL620:
 7142 3fdc 28309DE5 		ldr	r3, [sp, #40]
 7143 3fe0 AFFCFFEA 		b	.L421
 7144              	.L467:
 7145              	.LVL621:
3752:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 7146              		.loc 1 3752 0
 7147 3fe4 1500A0E3 		mov	r0, #21
 7148 3fe8 FEFFFFEB 		bl	ControlHandle
 7149              	.LVL622:
 7150 3fec 28309DE5 		ldr	r3, [sp, #40]
 7151 3ff0 ABFCFFEA 		b	.L421
 7152              	.LVL623:
 7153              	.L634:
 7154              	.LBE100:
 7155              	.LBE151:
4374:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 7156              		.loc 1 4374 0
 7157 3ff4 0400A0E3 		mov	r0, #4
 7158              	.LVL624:
 7159 3ff8 C0119FE5 		ldr	r1, .L639+144
 7160 3ffc FEFFFFEB 		bl	CyU3PDebugPrint
 7161              	.LVL625:
 7162              	.L567:
 7163              	.LBB152:
 7164              	.LBB153:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7165              		.loc 1 2061 0
 7166 4000 4C119FE5 		ldr	r1, .L639+36
 7167 4004 0400A0E3 		mov	r0, #4
 7168 4008 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7169              		.loc 1 2062 0
 7170 400c FA0FA0E3 		mov	r0, #1000
 7171 4010 FEFFFFEB 		bl	_tx_thread_sleep
 7172 4014 F9FFFFEA 		b	.L567
 7173              	.L633:
 7174              	.LBE153:
 7175              	.LBE152:
4328:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 7176              		.loc 1 4328 0
 7177 4018 44319FE5 		ldr	r3, .L639+52
 7178 401c 02C0A0E3 		mov	ip, #2
 7179 4020 002093E5 		ldr	r2, [r3, #0]
4329:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7180              		.loc 1 4329 0
 7181 4024 0170A0E3 		mov	r7, #1
4328:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 7182              		.loc 1 4328 0
 7183 4028 00C0C2E5 		strb	ip, [r2, #0]
4329:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7184              		.loc 1 4329 0
 7185 402c 001093E5 		ldr	r1, [r3, #0]
4330:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7186              		.loc 1 4330 0
 7187 4030 0020A0E3 		mov	r2, #0
4329:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7188              		.loc 1 4329 0
 7189 4034 0170C1E5 		strb	r7, [r1, #1]
4330:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7190              		.loc 1 4330 0
 7191 4038 000093E5 		ldr	r0, [r3, #0]
4334:../uvc.c      **** 					interStabuf.size   = 1024;
 7192              		.loc 1 4334 0
 7193 403c 01CBA0E3 		mov	ip, #1024	@ movhi
4330:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7194              		.loc 1 4330 0
 7195 4040 0220C0E5 		strb	r2, [r0, #2]
4331:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7196              		.loc 1 4331 0
 7197 4044 00E093E5 		ldr	lr, [r3, #0]
4340:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7198              		.loc 1 4340 0
 7199 4048 0010E0E3 		mvn	r1, #0
4331:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 7200              		.loc 1 4331 0
 7201 404c 0320CEE5 		strb	r2, [lr, #3]
4333:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 7202              		.loc 1 4333 0
 7203 4050 00E093E5 		ldr	lr, [r3, #0]
4340:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7204              		.loc 1 4340 0
 7205 4054 0C019FE5 		ldr	r0, .L639+56
4337:../uvc.c      **** 					interStabuf.count = 4;
 7206              		.loc 1 4337 0
 7207 4058 0430A0E3 		mov	r3, #4	@ movhi
4335:../uvc.c      **** 					interStabuf.status = 0;
 7208              		.loc 1 4335 0
 7209 405c B421CDE1 		strh	r2, [sp, #20]	@ movhi
4334:../uvc.c      **** 					interStabuf.size   = 1024;
 7210              		.loc 1 4334 0
 7211 4060 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
4333:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 7212              		.loc 1 4333 0
 7213 4064 0CE08DE5 		str	lr, [sp, #12]
4337:../uvc.c      **** 					interStabuf.count = 4;
 7214              		.loc 1 4337 0
 7215 4068 B031CDE1 		strh	r3, [sp, #16]	@ movhi
4340:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 7216              		.loc 1 4340 0
 7217 406c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
4343:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 7218              		.loc 1 4343 0
 7219 4070 F0009FE5 		ldr	r0, .L639+56
 7220 4074 0C108DE2 		add	r1, sp, #12
 7221 4078 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 7222              	.LVL626:
4345:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 7223              		.loc 1 4345 0
 7224 407c 002050E2 		subs	r2, r0, #0
 7225 4080 0500001A 		bne	.L638
4350:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
 7226              		.loc 1 4350 0
 7227 4084 0500A0E3 		mov	r0, #5
 7228              	.LVL627:
 7229 4088 3010A0E3 		mov	r1, #48
 7230 408c FEFFFFEB 		bl	SensorSetControl
 7231              	.LVL628:
4352:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
 7232              		.loc 1 4352 0
 7233 4090 0B77C8E5 		strb	r7, [r8, #1803]
 7234 4094 28309DE5 		ldr	r3, [sp, #40]
 7235 4098 8EFCFFEA 		b	.L562
 7236              	.LVL629:
 7237              	.L638:
4347:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 7238              		.loc 1 4347 0
 7239 409c 0400A0E3 		mov	r0, #4
 7240              	.LVL630:
 7241 40a0 18119FE5 		ldr	r1, .L639+144
 7242 40a4 FEFFFFEB 		bl	CyU3PDebugPrint
 7243              	.LVL631:
 7244              	.L565:
 7245              	.LBB154:
 7246              	.LBB155:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7247              		.loc 1 2061 0
 7248 40a8 A4109FE5 		ldr	r1, .L639+36
 7249 40ac 0400A0E3 		mov	r0, #4
 7250 40b0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7251              		.loc 1 2062 0
 7252 40b4 FA0FA0E3 		mov	r0, #1000
 7253 40b8 FEFFFFEB 		bl	_tx_thread_sleep
 7254 40bc F9FFFFEA 		b	.L565
 7255              	.L429:
 7256              	.LVL632:
 7257              	.LBE155:
 7258              	.LBE154:
 7259              	.LBB156:
 7260              	.LBB128:
3427:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 7261              		.loc 1 3427 0
 7262 40c0 0000A0E3 		mov	r0, #0
 7263 40c4 FEFFFFEB 		bl	ControlHandle
 7264              	.LVL633:
 7265 40c8 28309DE5 		ldr	r3, [sp, #40]
 7266 40cc 74FCFFEA 		b	.L421
 7267              	.L431:
 7268              	.LVL634:
3435:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 7269              		.loc 1 3435 0
 7270 40d0 0200A0E3 		mov	r0, #2
 7271 40d4 FEFFFFEB 		bl	ControlHandle
 7272              	.LVL635:
 7273 40d8 28309DE5 		ldr	r3, [sp, #40]
 7274 40dc 70FCFFEA 		b	.L421
 7275              	.L433:
 7276              	.LVL636:
3446:../uvc.c      ****      		ControlHandle(HueCtlID5);
 7277              		.loc 1 3446 0
 7278 40e0 0500A0E3 		mov	r0, #5
 7279 40e4 FEFFFFEB 		bl	ControlHandle
 7280              	.LVL637:
 7281 40e8 28309DE5 		ldr	r3, [sp, #40]
 7282 40ec 6CFCFFEA 		b	.L421
 7283              	.L632:
 7284              	.LVL638:
 7285              	.LBE128:
 7286              	.LBE156:
 7287              	.LBB157:
 7288              	.LBB121:
3506:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 7289              		.loc 1 3506 0
 7290 40f0 0100A0E3 		mov	r0, #1
 7291 40f4 FEFFFFEB 		bl	CTControlHandle
 7292              	.LVL639:
 7293 40f8 28309DE5 		ldr	r3, [sp, #40]
 7294 40fc 68FCFFEA 		b	.L421
 7295              	.L443:
 7296              	.LVL640:
3502:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 7297              		.loc 1 3502 0
 7298 4100 0000A0E3 		mov	r0, #0
 7299 4104 FEFFFFEB 		bl	CTControlHandle
 7300              	.LVL641:
 7301 4108 28309DE5 		ldr	r3, [sp, #40]
 7302 410c 64FCFFEA 		b	.L421
 7303              	.L445:
 7304              	.LVL642:
3510:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 7305              		.loc 1 3510 0
 7306 4110 0200A0E3 		mov	r0, #2
 7307 4114 FEFFFFEB 		bl	CTControlHandle
 7308              	.LVL643:
 7309 4118 28309DE5 		ldr	r3, [sp, #40]
 7310 411c 60FCFFEA 		b	.L421
 7311              	.L448:
 7312              	.LVL644:
3524:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 7313              		.loc 1 3524 0
 7314 4120 0500A0E3 		mov	r0, #5
 7315 4124 FEFFFFEB 		bl	CTControlHandle
 7316              	.LVL645:
 7317 4128 28309DE5 		ldr	r3, [sp, #40]
 7318 412c 5CFCFFEA 		b	.L421
 7319              	.L640:
 7320              		.align	2
 7321              	.L639:
 7322 4130 00000000 		.word	.LANCHOR0
 7323 4134 00000000 		.word	glDebugRspBuffer
 7324 4138 00000000 		.word	wIndex
 7325 413c 00000000 		.word	wValue
 7326 4140 00000000 		.word	glDebugCmdChannel
 7327 4144 54080000 		.word	.LC48
 7328 4148 80080000 		.word	.LC49
 7329 414c 00000000 		.word	glDebugRspChannel
 7330 4150 2C090000 		.word	.LC53
 7331 4154 4C020000 		.word	.LC14
 7332 4158 00000000 		.word	bRequest
 7333 415c 5C060000 		.word	.LC36
 7334 4160 00000000 		.word	.LANCHOR1
 7335 4164 00000000 		.word	glInterStaBuffer
 7336 4168 00000000 		.word	glChHandleInterStat
 7337 416c F0080000 		.word	.LC52
 7338 4170 C8080000 		.word	.LC51
 7339 4174 20080000 		.word	.LC47
 7340 4178 A8080000 		.word	.LC50
 7341 417c 80010000 		.word	.LANCHOR0+384
 7342 4180 74070000 		.word	.LC43
 7343 4184 98070000 		.word	.LC44
 7344 4188 C4070000 		.word	.LC45
 7345 418c 1C010000 		.word	.LANCHOR0+284
 7346 4190 BC060000 		.word	.LANCHOR1+1724
 7347 4194 D8060000 		.word	.LANCHOR1+1752
 7348 4198 F4060000 		.word	.LANCHOR1+1780
 7349 419c 00070000 		.word	.LANCHOR1+1792
 7350 41a0 28070000 		.word	.LC41
 7351 41a4 4C070000 		.word	.LC42
 7352 41a8 FC060000 		.word	.LC40
 7353 41ac A0060000 		.word	.LANCHOR1+1696
 7354 41b0 88060000 		.word	.LC37
 7355 41b4 B0060000 		.word	.LC38
 7356 41b8 D4060000 		.word	.LC39
 7357 41bc EC020000 		.word	.LC18
 7358 41c0 EC070000 		.word	.LC46
 7359              	.LVL646:
 7360              	.L629:
 7361              	.LBE121:
 7362              	.LBE157:
4415:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
 7363              		.loc 1 4415 0
 7364 41c4 0330DCE5 		ldrb	r3, [ip, #3]	@ zero_extendqisi2
 7365 41c8 000053E3 		cmp	r3, #0
 7366 41cc 0A00000A 		beq	.L573
4417:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
 7367              		.loc 1 4417 0
 7368 41d0 007096E5 		ldr	r7, [r6, #0]
 7369              	.LVL647:
 7370 41d4 8330A0E1 		mov	r3, r3, asl #1
 7371 41d8 0110DCE5 		ldrb	r1, [ip, #1]	@ zero_extendqisi2
 7372 41dc 0220DCE5 		ldrb	r2, [ip, #2]	@ zero_extendqisi2
 7373 41e0 7100A0E3 		mov	r0, #113
 7374 41e4 01C087E2 		add	ip, r7, #1
 7375 41e8 FE3003E2 		and	r3, r3, #254
 7376 41ec 00C08DE5 		str	ip, [sp, #0]
 7377 41f0 FEFFFFEB 		bl	SensorRead
 7378 41f4 0000C7E5 		strb	r0, [r7, #0]
 7379 41f8 18C09DE5 		ldr	ip, [sp, #24]
 7380              	.L573:
4420:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
 7381              		.loc 1 4420 0
 7382 41fc 03E0DCE5 		ldrb	lr, [ip, #3]	@ zero_extendqisi2
 7383 4200 8E20A0E1 		mov	r2, lr, asl #1
 7384 4204 011082E2 		add	r1, r2, #1
 7385 4208 0120A0E1 		mov	r2, r1
 7386 420c BC11CDE1 		strh	r1, [sp, #28]	@ movhi
 7387 4210 4CFCFFEA 		b	.L572
 7388              	.L626:
 7389              	.LVL648:
 7390              	.LBB158:
 7391              	.LBB106:
3732:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 7392              		.loc 1 3732 0
 7393 4214 1000A0E3 		mov	r0, #16
 7394 4218 FEFFFFEB 		bl	ControlHandle
 7395              	.LVL649:
 7396 421c 28309DE5 		ldr	r3, [sp, #40]
 7397 4220 1FFCFFEA 		b	.L421
 7398              	.L464:
 7399              	.LVL650:
3740:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 7400              		.loc 1 3740 0
 7401 4224 1200A0E3 		mov	r0, #18
 7402 4228 FEFFFFEB 		bl	ControlHandle
 7403              	.LVL651:
 7404 422c 28309DE5 		ldr	r3, [sp, #40]
 7405 4230 1BFCFFEA 		b	.L421
 7406              	.L463:
 7407              	.LVL652:
3736:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 7408              		.loc 1 3736 0
 7409 4234 1100A0E3 		mov	r0, #17
 7410 4238 FEFFFFEB 		bl	ControlHandle
 7411              	.LVL653:
 7412 423c 28309DE5 		ldr	r3, [sp, #40]
 7413 4240 17FCFFEA 		b	.L421
 7414              	.L465:
 7415              	.LVL654:
3744:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 7416              		.loc 1 3744 0
 7417 4244 1300A0E3 		mov	r0, #19
 7418 4248 FEFFFFEB 		bl	ControlHandle
 7419              	.LVL655:
 7420 424c 28309DE5 		ldr	r3, [sp, #40]
 7421 4250 13FCFFEA 		b	.L421
 7422              	.LBE106:
 7423              	.LBE158:
 7424              		.cfi_endproc
 7425              	.LFE26:
 7427              		.align	2
 7428              		.global	CamDefSet
 7430              	CamDefSet:
 7431              	.LFB5:
1954:../uvc.c      **** {
 7432              		.loc 1 1954 0
 7433              		.cfi_startproc
 7434              		@ args = 0, pretend = 0, frame = 24
 7435              		@ frame_needed = 0, uses_anonymous_args = 0
 7436              	.LVL656:
 7437 4254 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7438              	.LCFI22:
 7439              		.cfi_def_cfa_offset 36
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7440              		.loc 1 1961 0
 7441 4258 B0429FE5 		ldr	r4, .L644
 7442              		.cfi_offset 14, -4
 7443              		.cfi_offset 11, -8
 7444              		.cfi_offset 10, -12
 7445              		.cfi_offset 9, -16
 7446              		.cfi_offset 8, -20
 7447              		.cfi_offset 7, -24
 7448              		.cfi_offset 6, -28
 7449              		.cfi_offset 5, -32
 7450              		.cfi_offset 4, -36
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7451              		.loc 1 1966 0
 7452 425c B0229FE5 		ldr	r2, .L644+4
1963:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 7453              		.loc 1 1963 0
 7454 4260 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1954:../uvc.c      **** {
 7455              		.loc 1 1954 0
 7456 4264 2CD04DE2 		sub	sp, sp, #44
 7457              	.LCFI23:
 7458              		.cfi_def_cfa_offset 80
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7459              		.loc 1 1966 0
 7460 4268 1C0092E5 		ldr	r0, [r2, #28]
 7461 426c 0010E0E3 		mvn	r1, #0
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7462              		.loc 1 1968 0
 7463 4270 2963A0E1 		mov	r6, r9, lsr #6
1962:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7464              		.loc 1 1962 0
 7465 4274 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1961:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 7466              		.loc 1 1961 0
 7467 4278 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 7468              	.LVL657:
1966:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 7469              		.loc 1 1966 0
 7470 427c FEFFFFEB 		bl	_txe_mutex_get
1967:../uvc.c      ****     if(Data1&0x80){
 7471              		.loc 1 1967 0
 7472 4280 800019E3 		tst	r9, #128
1968:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 7473              		.loc 1 1968 0
 7474 4284 01600612 		andne	r6, r6, #1
 7475 4288 0660E011 		mvnne	r6, r6
 7476 428c 3B600612 		andne	r6, r6, #59
 7477 4290 0660E011 		mvnne	r6, r6
 7478 4294 FF600612 		andne	r6, r6, #255
 7479              	.LVL658:
1970:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 7480              		.loc 1 1970 0
 7481 4298 C6608603 		orreq	r6, r6, #198
 7482              	.LVL659:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7483              		.loc 1 1974 0
 7484 429c 0080A0E3 		mov	r8, #0
 7485 42a0 0A20A0E1 		mov	r2, sl
 7486 42a4 0730A0E1 		mov	r3, r7
 7487 42a8 0110A0E3 		mov	r1, #1
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7488              		.loc 1 1972 0
 7489 42ac 0951A0E1 		mov	r5, r9, asl #2
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7490              		.loc 1 1974 0
 7491 42b0 5C029FE5 		ldr	r0, .L644+4
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7492              		.loc 1 1977 0
 7493 42b4 0190A0E3 		mov	r9, #1
 7494              	.LVL660:
1972:../uvc.c      ****     Data0 = (Data0 << 2);
 7495              		.loc 1 1972 0
 7496 42b8 FF5005E2 		and	r5, r5, #255
 7497              	.LVL661:
1974:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 7498              		.loc 1 1974 0
 7499 42bc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7500 42c0 FEFFFFEB 		bl	cmdSet
 7501              	.LVL662:
1977:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 7502              		.loc 1 1977 0
 7503 42c4 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 7504 42c8 0910A0E1 		mov	r1, r9
 7505 42cc 0730A0E1 		mov	r3, r7
 7506 42d0 3C029FE5 		ldr	r0, .L644+4
 7507 42d4 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 7508 42d8 FEFFFFEB 		bl	cmdSet
 7509              	.LVL663:
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7510              		.loc 1 1980 0
 7511 42dc 0620A0E1 		mov	r2, r6
 7512 42e0 0530A0E1 		mov	r3, r5
 7513 42e4 2C129FE5 		ldr	r1, .L644+8
 7514 42e8 0400A0E3 		mov	r0, #4
1979:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 7515              		.loc 1 1979 0
 7516 42ec A661C4E5 		strb	r6, [r4, #422]
1978:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7517              		.loc 1 1978 0
 7518 42f0 A551C4E5 		strb	r5, [r4, #421]
1980:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 7519              		.loc 1 1980 0
 7520 42f4 FEFFFFEB 		bl	CyU3PDebugPrint
 7521              	.LVL664:
1985:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7522              		.loc 1 1985 0
 7523 42f8 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 7524              	.LVL665:
1986:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 7525              		.loc 1 1986 0
 7526 42fc B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 7527 4300 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 7528 4304 0210A0E3 		mov	r1, #2
 7529 4308 04029FE5 		ldr	r0, .L644+4
 7530 430c 00B08DE5 		str	fp, [sp, #0]
 7531 4310 04808DE5 		str	r8, [sp, #4]
 7532 4314 FEFFFFEB 		bl	cmdSet
 7533              	.LVL666:
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7534              		.loc 1 1989 0
 7535 4318 0B20A0E1 		mov	r2, fp
 7536 431c 0530A0E1 		mov	r3, r5
 7537 4320 F0119FE5 		ldr	r1, .L644+8
 7538 4324 0400A0E3 		mov	r0, #4
1987:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7539              		.loc 1 1987 0
 7540 4328 BD51C4E5 		strb	r5, [r4, #445]
1988:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 7541              		.loc 1 1988 0
 7542 432c FD53C4E5 		strb	r5, [r4, #1021]
1989:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7543              		.loc 1 1989 0
 7544 4330 FEFFFFEB 		bl	CyU3PDebugPrint
 7545              	.LVL667:
1994:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7546              		.loc 1 1994 0
 7547 4334 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1993:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7548              		.loc 1 1993 0
 7549 4338 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 7550              	.LVL668:
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7551              		.loc 1 1995 0
 7552 433c 80B047E2 		sub	fp, r7, #128
 7553 4340 FF100BE2 		and	r1, fp, #255
 7554 4344 14108DE5 		str	r1, [sp, #20]
 7555 4348 14C09DE5 		ldr	ip, [sp, #20]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7556              		.loc 1 1996 0
 7557 434c 760047E2 		sub	r0, r7, #118
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7558              		.loc 1 1997 0
 7559 4350 7EE087E2 		add	lr, r7, #126
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7560              		.loc 1 1995 0
 7561 4354 0630A0E1 		mov	r3, r6
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7562              		.loc 1 1996 0
 7563 4358 18008DE5 		str	r0, [sp, #24]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7564              		.loc 1 1995 0
 7565 435c 0510A0E3 		mov	r1, #5
 7566 4360 DF20A0E3 		mov	r2, #223
 7567 4364 A8019FE5 		ldr	r0, .L644+4
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7568              		.loc 1 1997 0
 7569 4368 1CE08DE5 		str	lr, [sp, #28]
1995:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 7570              		.loc 1 1995 0
 7571 436c 00C08DE5 		str	ip, [sp, #0]
 7572 4370 04808DE5 		str	r8, [sp, #4]
 7573 4374 FEFFFFEB 		bl	cmdSet
 7574              	.LVL669:
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7575              		.loc 1 1996 0
 7576 4378 18A09DE5 		ldr	sl, [sp, #24]
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7577              		.loc 1 1998 0
 7578 437c 72E087E2 		add	lr, r7, #114
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7579              		.loc 1 1996 0
 7580 4380 FFC00AE2 		and	ip, sl, #255
 7581 4384 0630A0E1 		mov	r3, r6
 7582 4388 0510A0E3 		mov	r1, #5
 7583 438c DC20A0E3 		mov	r2, #220
 7584 4390 7C019FE5 		ldr	r0, .L644+4
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7585              		.loc 1 1998 0
 7586 4394 20E08DE5 		str	lr, [sp, #32]
1996:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 7587              		.loc 1 1996 0
 7588 4398 00C08DE5 		str	ip, [sp, #0]
 7589 439c 04908DE5 		str	r9, [sp, #4]
 7590 43a0 FEFFFFEB 		bl	cmdSet
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7591              		.loc 1 1997 0
 7592 43a4 1C009DE5 		ldr	r0, [sp, #28]
 7593 43a8 02E0A0E3 		mov	lr, #2
 7594 43ac FFC000E2 		and	ip, r0, #255
 7595 43b0 0630A0E1 		mov	r3, r6
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7596              		.loc 1 1999 0
 7597 43b4 6FA047E2 		sub	sl, r7, #111
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7598              		.loc 1 1997 0
 7599 43b8 0510A0E3 		mov	r1, #5
 7600 43bc DE20A0E3 		mov	r2, #222
 7601 43c0 4C019FE5 		ldr	r0, .L644+4
 7602 43c4 04E08DE5 		str	lr, [sp, #4]
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7603              		.loc 1 1999 0
 7604 43c8 24A08DE5 		str	sl, [sp, #36]
1997:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 7605              		.loc 1 1997 0
 7606 43cc 00C08DE5 		str	ip, [sp, #0]
 7607 43d0 FEFFFFEB 		bl	cmdSet
1998:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 7608              		.loc 1 1998 0
 7609 43d4 20A09DE5 		ldr	sl, [sp, #32]
 7610 43d8 0630A0E1 		mov	r3, r6
 7611 43dc FFC00AE2 		and	ip, sl, #255
 7612 43e0 00C08DE5 		str	ip, [sp, #0]
 7613 43e4 0510A0E3 		mov	r1, #5
 7614 43e8 03C0A0E3 		mov	ip, #3
 7615 43ec E020A0E3 		mov	r2, #224
 7616 43f0 1C019FE5 		ldr	r0, .L644+4
 7617 43f4 04C08DE5 		str	ip, [sp, #4]
 7618 43f8 FEFFFFEB 		bl	cmdSet
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7619              		.loc 1 1999 0
 7620 43fc 24009DE5 		ldr	r0, [sp, #36]
 7621 4400 04A0A0E3 		mov	sl, #4
 7622 4404 FFC000E2 		and	ip, r0, #255
 7623 4408 0630A0E1 		mov	r3, r6
 7624 440c 0510A0E3 		mov	r1, #5
 7625 4410 DD20A0E3 		mov	r2, #221
 7626 4414 F8009FE5 		ldr	r0, .L644+4
 7627 4418 00C08DE5 		str	ip, [sp, #0]
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7628              		.loc 1 2000 0
 7629 441c 7F7087E2 		add	r7, r7, #127
 7630              	.LVL670:
1999:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 7631              		.loc 1 1999 0
 7632 4420 04A08DE5 		str	sl, [sp, #4]
 7633 4424 FEFFFFEB 		bl	cmdSet
2000:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 7634              		.loc 1 2000 0
 7635 4428 05E0A0E3 		mov	lr, #5
 7636 442c 0E10A0E1 		mov	r1, lr
 7637 4430 0630A0E1 		mov	r3, r6
 7638 4434 E120A0E3 		mov	r2, #225
 7639 4438 FF6007E2 		and	r6, r7, #255
 7640              	.LVL671:
 7641 443c D0009FE5 		ldr	r0, .L644+4
 7642 4440 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 7643 4444 FEFFFFEB 		bl	cmdSet
 7644              	.LVL672:
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7645              		.loc 1 2001 0
 7646 4448 14C09DE5 		ldr	ip, [sp, #20]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7647              		.loc 1 2002 0
 7648 444c 24E09DE5 		ldr	lr, [sp, #36]
 7649 4450 1C609DE5 		ldr	r6, [sp, #28]
2001:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 7650              		.loc 1 2001 0
 7651 4454 05C2C4E5 		strb	ip, [r4, #517]
2002:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 7652              		.loc 1 2002 0
 7653 4458 20C09DE5 		ldr	ip, [sp, #32]
 7654 445c 0B20A0E1 		mov	r2, fp
 7655 4460 18309DE5 		ldr	r3, [sp, #24]
 7656 4464 B0109FE5 		ldr	r1, .L644+12
 7657 4468 0A00A0E1 		mov	r0, sl
 7658 446c 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 7659 4470 0C708DE5 		str	r7, [sp, #12]
 7660 4474 FEFFFFEB 		bl	CyU3PDebugPrint
 7661              	.LVL673:
2006:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 7662              		.loc 1 2006 0
 7663 4478 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 7664              	.LVL674:
2007:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7665              		.loc 1 2007 0
 7666 447c 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 7667              	.LVL675:
2008:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 7668              		.loc 1 2008 0
 7669 4480 0730A0E1 		mov	r3, r7
 7670 4484 0610A0E3 		mov	r1, #6
 7671 4488 8520A0E3 		mov	r2, #133
 7672 448c 80009FE5 		ldr	r0, .L644+4
 7673 4490 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7674 4494 FEFFFFEB 		bl	cmdSet
2009:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 7675              		.loc 1 2009 0
 7676 4498 0730A0E1 		mov	r3, r7
 7677 449c 0610A0E3 		mov	r1, #6
 7678 44a0 8620A0E3 		mov	r2, #134
 7679 44a4 68009FE5 		ldr	r0, .L644+4
 7680 44a8 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 7681 44ac FEFFFFEB 		bl	cmdSet
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7682              		.loc 1 2011 0
 7683 44b0 0620A0E1 		mov	r2, r6
 7684 44b4 0530A0E1 		mov	r3, r5
 7685 44b8 58109FE5 		ldr	r1, .L644+8
 7686 44bc 0A00A0E1 		mov	r0, sl
2010:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 7687              		.loc 1 2010 0
 7688 44c0 1D62C4E5 		strb	r6, [r4, #541]
2011:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7689              		.loc 1 2011 0
 7690 44c4 FEFFFFEB 		bl	CyU3PDebugPrint
 7691              	.LVL676:
2016:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 7692              		.loc 1 2016 0
 7693 44c8 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 7694              	.LVL677:
2017:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 7695              		.loc 1 2017 0
 7696 44cc 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 7697 44d0 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 7698 44d4 0710A0E3 		mov	r1, #7
 7699 44d8 34009FE5 		ldr	r0, .L644+4
 7700 44dc 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 7701 44e0 FEFFFFEB 		bl	cmdSet
 7702              	.LVL678:
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7703              		.loc 1 2019 0
 7704 44e4 0530A0E1 		mov	r3, r5
 7705 44e8 0A00A0E1 		mov	r0, sl
 7706 44ec 24109FE5 		ldr	r1, .L644+8
 7707 44f0 0620A0E1 		mov	r2, r6
2018:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 7708              		.loc 1 2018 0
 7709 44f4 3552C4E5 		strb	r5, [r4, #565]
2019:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 7710              		.loc 1 2019 0
 7711 44f8 FEFFFFEB 		bl	CyU3PDebugPrint
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7712              		.loc 1 2021 0
 7713 44fc 10309FE5 		ldr	r3, .L644+4
 7714 4500 1C0093E5 		ldr	r0, [r3, #28]
2024:../uvc.c      **** }
 7715              		.loc 1 2024 0
 7716 4504 2CD08DE2 		add	sp, sp, #44
 7717 4508 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
2021:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 7718              		.loc 1 2021 0
 7719 450c FEFFFFEA 		b	_txe_mutex_put
 7720              	.L645:
 7721              		.align	2
 7722              	.L644:
 7723 4510 00000000 		.word	.LANCHOR1
 7724 4514 00000000 		.word	statQu
 7725 4518 60090000 		.word	.LC54
 7726 451c 80090000 		.word	.LC55
 7727              		.cfi_endproc
 7728              	.LFE5:
 7730              		.align	2
 7731              		.global	CyFxUVCAddHeader
 7733              	CyFxUVCAddHeader:
 7734              	.LFB6:
2032:../uvc.c      **** {
 7735              		.loc 1 2032 0
 7736              		.cfi_startproc
 7737              		@ args = 0, pretend = 0, frame = 0
 7738              		@ frame_needed = 0, uses_anonymous_args = 0
 7739              	.LVL679:
 7740 4520 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 7741              	.LCFI24:
 7742              		.cfi_def_cfa_offset 16
2032:../uvc.c      **** {
 7743              		.loc 1 2032 0
 7744 4524 0040A0E1 		mov	r4, r0
 7745              		.cfi_offset 14, -4
 7746              		.cfi_offset 5, -8
 7747              		.cfi_offset 4, -12
 7748              		.cfi_offset 3, -16
 7749 4528 0150A0E1 		mov	r5, r1
2034:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 7750              		.loc 1 2034 0
 7751 452c 30009FE5 		ldr	r0, .L648
 7752              	.LVL680:
 7753 4530 0010E0E3 		mvn	r1, #0
 7754              	.LVL681:
 7755 4534 FEFFFFEB 		bl	_txe_mutex_get
2035:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 7756              		.loc 1 2035 0
 7757 4538 0400A0E1 		mov	r0, r4
 7758 453c 24109FE5 		ldr	r1, .L648+4
 7759 4540 0C20A0E3 		mov	r2, #12
 7760 4544 FEFFFFEB 		bl	CyU3PMemCopy
2036:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 7761              		.loc 1 2036 0
 7762 4548 14009FE5 		ldr	r0, .L648
 7763 454c FEFFFFEB 		bl	_txe_mutex_put
2039:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 7764              		.loc 1 2039 0
 7765 4550 020015E3 		tst	r5, #2
2041:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 7766              		.loc 1 2041 0
 7767 4554 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 7768 4558 02308313 		orrne	r3, r3, #2
 7769 455c 0130C415 		strneb	r3, [r4, #1]
 7770 4560 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 7771              	.L649:
 7772              		.align	2
 7773              	.L648:
 7774 4564 00000000 		.word	imgHdMux
 7775 4568 80040000 		.word	.LANCHOR1+1152
 7776              		.cfi_endproc
 7777              	.LFE6:
 7779              		.align	2
 7780              		.global	CyFxAppErrorHandler
 7782              	CyFxAppErrorHandler:
 7783              	.LFB7:
2051:../uvc.c      **** {
 7784              		.loc 1 2051 0
 7785              		.cfi_startproc
 7786              		@ args = 0, pretend = 0, frame = 0
 7787              		@ frame_needed = 0, uses_anonymous_args = 0
 7788              	.LVL682:
 7789 456c 08402DE9 		stmfd	sp!, {r3, lr}
 7790              	.LCFI25:
 7791              		.cfi_def_cfa_offset 8
 7792              	.LVL683:
 7793              	.L651:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 7794              		.loc 1 2061 0 discriminator 1
 7795 4570 10109FE5 		ldr	r1, .L652
 7796 4574 0400A0E3 		mov	r0, #4
 7797              		.cfi_offset 14, -4
 7798              		.cfi_offset 3, -8
 7799 4578 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 7800              		.loc 1 2062 0 discriminator 1
 7801 457c FA0FA0E3 		mov	r0, #1000
 7802 4580 FEFFFFEB 		bl	_tx_thread_sleep
 7803 4584 F9FFFFEA 		b	.L651
 7804              	.L653:
 7805              		.align	2
 7806              	.L652:
 7807 4588 4C020000 		.word	.LC14
 7808              		.cfi_endproc
 7809              	.LFE7:
 7811              		.align	2
 7812              		.global	UVCAppThread_Entry
 7814              	UVCAppThread_Entry:
 7815              	.LFB20:
3052:../uvc.c      **** {
 7816              		.loc 1 3052 0
 7817              		.cfi_startproc
 7818              		@ args = 0, pretend = 0, frame = 200
 7819              		@ frame_needed = 0, uses_anonymous_args = 0
 7820              	.LVL684:
 7821 458c F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 7822              	.LCFI26:
 7823              		.cfi_def_cfa_offset 32
 7824 4590 D0D04DE2 		sub	sp, sp, #208
 7825              	.LCFI27:
 7826              		.cfi_def_cfa_offset 240
 7827              	.LBB223:
 7828              	.LBB224:
2508:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 7829              		.loc 1 2508 0
 7830              		.cfi_offset 14, -4
 7831              		.cfi_offset 10, -8
 7832              		.cfi_offset 9, -12
 7833              		.cfi_offset 8, -16
 7834              		.cfi_offset 7, -20
 7835              		.cfi_offset 6, -24
 7836              		.cfi_offset 5, -28
 7837              		.cfi_offset 4, -32
 7838 4594 FEFFFFEB 		bl	CyU3PUartInit
 7839              	.LVL685:
2509:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7840              		.loc 1 2509 0
 7841 4598 004050E2 		subs	r4, r0, #0
 7842 459c 0400000A 		beq	.L655
2511:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 7843              		.loc 1 2511 0
 7844 45a0 0400A0E3 		mov	r0, #4
 7845              	.LVL686:
 7846 45a4 781E9FE5 		ldr	r1, .L790
 7847 45a8 FEFFFFEB 		bl	CyU3PDebugPrint
2512:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7848              		.loc 1 2512 0
 7849 45ac 0400A0E1 		mov	r0, r4
 7850 45b0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7851              	.L655:
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7852              		.loc 1 2516 0
 7853 45b4 6CCE9FE5 		ldr	ip, .L790+4
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7854              		.loc 1 2518 0
 7855 45b8 0030A0E3 		mov	r3, #0
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7856              		.loc 1 2517 0
 7857 45bc 0120A0E3 		mov	r2, #1
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7858              		.loc 1 2525 0
 7859 45c0 68008DE2 		add	r0, sp, #104
 7860 45c4 0310A0E1 		mov	r1, r3
2516:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 7861              		.loc 1 2516 0
 7862 45c8 78C08DE5 		str	ip, [sp, #120]
2517:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 7863              		.loc 1 2517 0
 7864 45cc 7C20CDE5 		strb	r2, [sp, #124]
2518:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 7865              		.loc 1 2518 0
 7866 45d0 7D30CDE5 		strb	r3, [sp, #125]
2519:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 7867              		.loc 1 2519 0
 7868 45d4 68208DE5 		str	r2, [sp, #104]
2520:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 7869              		.loc 1 2520 0
 7870 45d8 6C308DE5 		str	r3, [sp, #108]
2521:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 7871              		.loc 1 2521 0
 7872 45dc 70308DE5 		str	r3, [sp, #112]
2522:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 7873              		.loc 1 2522 0
 7874 45e0 74208DE5 		str	r2, [sp, #116]
2525:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 7875              		.loc 1 2525 0
 7876 45e4 FEFFFFEB 		bl	CyU3PUartSetConfig
 7877              	.LVL687:
2526:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7878              		.loc 1 2526 0
 7879 45e8 000050E3 		cmp	r0, #0
 7880 45ec 0000000A 		beq	.L656
2528:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7881              		.loc 1 2528 0
 7882 45f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7883              	.LVL688:
 7884              	.L656:
2532:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 7885              		.loc 1 2532 0
 7886 45f4 0000E0E3 		mvn	r0, #0
 7887 45f8 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 7888              	.LVL689:
2533:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7889              		.loc 1 2533 0
 7890 45fc 000050E3 		cmp	r0, #0
 7891 4600 0000000A 		beq	.L657
2535:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7892              		.loc 1 2535 0
 7893 4604 FEFFFFEB 		bl	CyFxAppErrorHandler
 7894              	.LVL690:
 7895              	.L657:
2539:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 7896              		.loc 1 2539 0
 7897 4608 0300A0E3 		mov	r0, #3
 7898 460c 0410A0E3 		mov	r1, #4
 7899 4610 FEFFFFEB 		bl	CyU3PDebugInit
 7900              	.LVL691:
2540:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7901              		.loc 1 2540 0
 7902 4614 000050E3 		cmp	r0, #0
 7903 4618 0000000A 		beq	.L658
2542:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7904              		.loc 1 2542 0
 7905 461c FEFFFFEB 		bl	CyFxAppErrorHandler
 7906              	.LVL692:
 7907              	.L658:
2546:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 7908              		.loc 1 2546 0
 7909 4620 0000A0E3 		mov	r0, #0
 7910 4624 FEFFFFEB 		bl	CyU3PDebugPreamble
 7911              	.LVL693:
 7912              	.LBE224:
 7913              	.LBE223:
3068:../uvc.c      **** 		CyU3PThreadSleep(500);
 7914              		.loc 1 3068 0
 7915 4628 7D0FA0E3 		mov	r0, #500
 7916 462c FEFFFFEB 		bl	_tx_thread_sleep
 7917              	.LVL694:
 7918 4630 7D0FA0E3 		mov	r0, #500
 7919 4634 FEFFFFEB 		bl	_tx_thread_sleep
 7920 4638 7D0FA0E3 		mov	r0, #500
 7921 463c FEFFFFEB 		bl	_tx_thread_sleep
 7922 4640 7D0FA0E3 		mov	r0, #500
 7923 4644 FEFFFFEB 		bl	_tx_thread_sleep
 7924 4648 7D0FA0E3 		mov	r0, #500
 7925 464c FEFFFFEB 		bl	_tx_thread_sleep
 7926 4650 7D0FA0E3 		mov	r0, #500
 7927 4654 FEFFFFEB 		bl	_tx_thread_sleep
 7928              	.LBB225:
 7929              	.LBB226:
2556:../uvc.c      ****     status = CyU3PI2cInit ();
 7930              		.loc 1 2556 0
 7931 4658 FEFFFFEB 		bl	CyU3PI2cInit
 7932              	.LVL695:
2557:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 7933              		.loc 1 2557 0
 7934 465c 004050E2 		subs	r4, r0, #0
 7935 4660 0400000A 		beq	.L659
2559:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 7936              		.loc 1 2559 0
 7937 4664 0400A0E3 		mov	r0, #4
 7938              	.LVL696:
 7939 4668 BC1D9FE5 		ldr	r1, .L790+8
 7940 466c FEFFFFEB 		bl	CyU3PDebugPrint
2560:../uvc.c      ****         CyFxAppErrorHandler (status);
 7941              		.loc 1 2560 0
 7942 4670 0400A0E1 		mov	r0, r4
 7943 4674 FEFFFFEB 		bl	CyFxAppErrorHandler
 7944              	.L659:
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7945              		.loc 1 2564 0
 7946 4678 B06D9FE5 		ldr	r6, .L790+12
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7947              		.loc 1 2565 0
 7948 467c 0050A0E3 		mov	r5, #0
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7949              		.loc 1 2566 0
 7950 4680 0040E0E3 		mvn	r4, #0
 7951              	.LVL697:
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7952              		.loc 1 2569 0
 7953 4684 A4008DE2 		add	r0, sp, #164
 7954 4688 0510A0E1 		mov	r1, r5
2566:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 7955              		.loc 1 2566 0
 7956 468c AC408DE5 		str	r4, [sp, #172]
2567:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 7957              		.loc 1 2567 0
 7958 4690 B04BCDE1 		strh	r4, [sp, #176]	@ movhi
2564:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 7959              		.loc 1 2564 0
 7960 4694 A4608DE5 		str	r6, [sp, #164]
2565:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 7961              		.loc 1 2565 0
 7962 4698 A8508DE5 		str	r5, [sp, #168]
2569:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 7963              		.loc 1 2569 0
 7964 469c FEFFFFEB 		bl	CyU3PI2cSetConfig
 7965              	.LVL698:
2570:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 7966              		.loc 1 2570 0
 7967 46a0 004050E2 		subs	r4, r0, #0
 7968 46a4 0400000A 		beq	.L660
2572:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 7969              		.loc 1 2572 0
 7970 46a8 0400A0E3 		mov	r0, #4
 7971              	.LVL699:
 7972 46ac 801D9FE5 		ldr	r1, .L790+16
 7973 46b0 FEFFFFEB 		bl	CyU3PDebugPrint
2573:../uvc.c      ****         CyFxAppErrorHandler (status);
 7974              		.loc 1 2573 0
 7975 46b4 0400A0E1 		mov	r0, r4
 7976 46b8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7977              	.L660:
 7978              	.LBE226:
 7979              	.LBE225:
 7980              	.LBB227:
 7981              	.LBB230:
2643:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 7982              		.loc 1 2643 0
 7983 46bc 744D9FE5 		ldr	r4, .L790+20
 7984              	.LVL700:
 7985 46c0 2820A0E3 		mov	r2, #40
 7986 46c4 0010A0E3 		mov	r1, #0
 7987 46c8 0400A0E1 		mov	r0, r4
 7988 46cc FEFFFFEB 		bl	_txe_event_flags_create
 7989              	.LVL701:
2644:../uvc.c      ****     if (apiRetStatus != 0)
 7990              		.loc 1 2644 0
 7991 46d0 002050E2 		subs	r2, r0, #0
 7992 46d4 4501001A 		bne	.L759
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 7993              		.loc 1 2658 0
 7994 46d8 0260A0E3 		mov	r6, #2
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 7995              		.loc 1 2665 0
 7996 46dc 0210A0E1 		mov	r1, r2
2654:../uvc.c      ****     isUsbConnected = CyFalse;
 7997              		.loc 1 2654 0
 7998 46e0 B02084E5 		str	r2, [r4, #176]
2655:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 7999              		.loc 1 2655 0
 8000 46e4 C42084E5 		str	r2, [r4, #196]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 8001              		.loc 1 2661 0
 8002 46e8 0370A0E3 		mov	r7, #3
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 8003              		.loc 1 2665 0
 8004 46ec B4008DE2 		add	r0, sp, #180
 8005              	.LVL702:
2660:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 8006              		.loc 1 2660 0
 8007 46f0 BC20CDE5 		strb	r2, [sp, #188]
2662:../uvc.c      ****     gpioClock.halfDiv    = 0;
 8008              		.loc 1 2662 0
 8009 46f4 B8208DE5 		str	r2, [sp, #184]
2658:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 8010              		.loc 1 2658 0
 8011 46f8 B460CDE5 		strb	r6, [sp, #180]
2659:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 8012              		.loc 1 2659 0
 8013 46fc B560CDE5 		strb	r6, [sp, #181]
2661:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 8014              		.loc 1 2661 0
 8015 4700 BD70CDE5 		strb	r7, [sp, #189]
2665:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 8016              		.loc 1 2665 0
 8017 4704 FEFFFFEB 		bl	CyU3PGpioInit
 8018              	.LVL703:
2666:../uvc.c      ****     if (apiRetStatus != 0)
 8019              		.loc 1 2666 0
 8020 4708 002050E2 		subs	r2, r0, #0
 8021 470c 4901001A 		bne	.L760
2674:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 8022              		.loc 1 2674 0
 8023 4710 1600A0E3 		mov	r0, #22
 8024              	.LVL704:
 8025 4714 0110A0E3 		mov	r1, #1
 8026 4718 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8027              	.LVL705:
2675:../uvc.c      ****     if (apiRetStatus != 0)
 8028              		.loc 1 2675 0
 8029 471c 002050E2 		subs	r2, r0, #0
 8030 4720 3B01001A 		bne	.L761
2680:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 8031              		.loc 1 2680 0
 8032 4724 1400A0E3 		mov	r0, #20
 8033              	.LVL706:
 8034 4728 0110A0E3 		mov	r1, #1
 8035 472c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8036              	.LVL707:
2681:../uvc.c      ****     if (apiRetStatus != 0)
 8037              		.loc 1 2681 0
 8038 4730 002050E2 		subs	r2, r0, #0
 8039 4734 4801001A 		bne	.L762
2686:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 8040              		.loc 1 2686 0
 8041 4738 1800A0E3 		mov	r0, #24
 8042              	.LVL708:
 8043 473c 0110A0E3 		mov	r1, #1
 8044 4740 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 8045              	.LVL709:
2687:../uvc.c      ****     if (apiRetStatus != 0)
 8046              		.loc 1 2687 0
 8047 4744 002050E2 		subs	r2, r0, #0
 8048 4748 7702001A 		bne	.L763
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8049              		.loc 1 2694 0
 8050 474c 0150A0E3 		mov	r5, #1
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 8051              		.loc 1 2699 0
 8052 4750 1600A0E3 		mov	r0, #22
 8053              	.LVL710:
 8054 4754 80108DE2 		add	r1, sp, #128
2697:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 8055              		.loc 1 2697 0
 8056 4758 8C208DE5 		str	r2, [sp, #140]
2698:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8057              		.loc 1 2698 0
 8058 475c 9020CDE5 		strb	r2, [sp, #144]
2694:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8059              		.loc 1 2694 0
 8060 4760 80508DE5 		str	r5, [sp, #128]
2695:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 8061              		.loc 1 2695 0
 8062 4764 84508DE5 		str	r5, [sp, #132]
2696:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 8063              		.loc 1 2696 0
 8064 4768 88508DE5 		str	r5, [sp, #136]
2699:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 8065              		.loc 1 2699 0
 8066 476c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8067              	.LVL711:
2700:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8068              		.loc 1 2700 0
 8069 4770 002050E2 		subs	r2, r0, #0
 8070 4774 6302001A 		bne	.L764
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 8071              		.loc 1 2713 0
 8072 4778 1400A0E3 		mov	r0, #20
 8073              	.LVL712:
 8074 477c 80108DE2 		add	r1, sp, #128
2711:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 8075              		.loc 1 2711 0
 8076 4780 8C208DE5 		str	r2, [sp, #140]
2712:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8077              		.loc 1 2712 0
 8078 4784 9020CDE5 		strb	r2, [sp, #144]
2708:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 8079              		.loc 1 2708 0
 8080 4788 80508DE5 		str	r5, [sp, #128]
2709:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 8081              		.loc 1 2709 0
 8082 478c 84508DE5 		str	r5, [sp, #132]
2710:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 8083              		.loc 1 2710 0
 8084 4790 88508DE5 		str	r5, [sp, #136]
2713:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 8085              		.loc 1 2713 0
 8086 4794 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8087              	.LVL713:
2714:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8088              		.loc 1 2714 0
 8089 4798 002050E2 		subs	r2, r0, #0
 8090 479c 6B02001A 		bne	.L765
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 8091              		.loc 1 2727 0
 8092 47a0 1800A0E3 		mov	r0, #24
 8093              	.LVL714:
 8094 47a4 80108DE2 		add	r1, sp, #128
2722:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 8095              		.loc 1 2722 0
 8096 47a8 80208DE5 		str	r2, [sp, #128]
2723:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 8097              		.loc 1 2723 0
 8098 47ac 84208DE5 		str	r2, [sp, #132]
2724:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 8099              		.loc 1 2724 0
 8100 47b0 88208DE5 		str	r2, [sp, #136]
2726:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 8101              		.loc 1 2726 0
 8102 47b4 9020CDE5 		strb	r2, [sp, #144]
2725:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 8103              		.loc 1 2725 0
 8104 47b8 8C508DE5 		str	r5, [sp, #140]
2727:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 8105              		.loc 1 2727 0
 8106 47bc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 8107              	.LVL715:
2728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8108              		.loc 1 2728 0
 8109 47c0 002050E2 		subs	r2, r0, #0
 8110 47c4 4602001A 		bne	.L766
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 8111              		.loc 1 2740 0
 8112 47c8 0500A0E1 		mov	r0, r5
 8113              	.LVL716:
 8114 47cc 94108DE2 		add	r1, sp, #148
2737:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 8115              		.loc 1 2737 0
 8116 47d0 9C208DE5 		str	r2, [sp, #156]
2738:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 8117              		.loc 1 2738 0
 8118 47d4 98208DE5 		str	r2, [sp, #152]
2735:../uvc.c      ****     pibclock.clkDiv      = 2;
 8119              		.loc 1 2735 0
 8120 47d8 B469CDE1 		strh	r6, [sp, #148]	@ movhi
2736:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 8121              		.loc 1 2736 0
 8122 47dc A070CDE5 		strb	r7, [sp, #160]
2740:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 8123              		.loc 1 2740 0
 8124 47e0 FEFFFFEB 		bl	CyU3PPibInit
 8125              	.LVL717:
2741:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8126              		.loc 1 2741 0
 8127 47e4 002050E2 		subs	r2, r0, #0
 8128 47e8 3402001A 		bne	.L767
2748:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 8129              		.loc 1 2748 0
 8130 47ec 480C9FE5 		ldr	r0, .L790+24
 8131              	.LVL718:
 8132 47f0 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 8133              	.LVL719:
2756:../uvc.c      ****     SensorReset ();
 8134              		.loc 1 2756 0
 8135 47f4 FEFFFFEB 		bl	SensorReset
2757:../uvc.c      ****     CyU3PThreadSleep(5000);
 8136              		.loc 1 2757 0
 8137 47f8 400C9FE5 		ldr	r0, .L790+28
 8138 47fc FEFFFFEB 		bl	_tx_thread_sleep
2761:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 8139              		.loc 1 2761 0
 8140 4800 FEFFFFEB 		bl	CyU3PUsbStart
 8141              	.LVL720:
2762:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8142              		.loc 1 2762 0
 8143 4804 002050E2 		subs	r2, r0, #0
 8144 4808 2302001A 		bne	.L768
2768:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 8145              		.loc 1 2768 0
 8146 480c 0010A0E3 		mov	r1, #0
 8147 4810 2C0C9FE5 		ldr	r0, .L790+32
 8148              	.LVL721:
 8149 4814 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 8150              	.LVL722:
2771:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 8151              		.loc 1 2771 0
 8152 4818 280C9FE5 		ldr	r0, .L790+36
 8153 481c FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
2777:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 8154              		.loc 1 2777 0
 8155 4820 0010A0E3 		mov	r1, #0
 8156 4824 202C9FE5 		ldr	r2, .L790+40
 8157 4828 0100A0E3 		mov	r0, #1
 8158 482c FEFFFFEB 		bl	CyU3PUsbSetDesc
2778:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 8159              		.loc 1 2778 0
 8160 4830 0000A0E3 		mov	r0, #0
 8161 4834 0010A0E1 		mov	r1, r0
 8162 4838 102C9FE5 		ldr	r2, .L790+44
 8163 483c FEFFFFEB 		bl	CyU3PUsbSetDesc
2781:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 8164              		.loc 1 2781 0
 8165 4840 0010A0E3 		mov	r1, #0
 8166 4844 082C9FE5 		ldr	r2, .L790+48
 8167 4848 0200A0E3 		mov	r0, #2
 8168 484c FEFFFFEB 		bl	CyU3PUsbSetDesc
2782:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 8169              		.loc 1 2782 0
 8170 4850 0010A0E3 		mov	r1, #0
 8171 4854 FC2B9FE5 		ldr	r2, .L790+52
 8172 4858 0700A0E3 		mov	r0, #7
 8173 485c FEFFFFEB 		bl	CyU3PUsbSetDesc
2785:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 8174              		.loc 1 2785 0
 8175 4860 0010A0E3 		mov	r1, #0
 8176 4864 F02B9FE5 		ldr	r2, .L790+56
 8177 4868 0400A0E3 		mov	r0, #4
 8178 486c FEFFFFEB 		bl	CyU3PUsbSetDesc
2786:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 8179              		.loc 1 2786 0
 8180 4870 0010A0E3 		mov	r1, #0
 8181 4874 E42B9FE5 		ldr	r2, .L790+60
 8182 4878 0300A0E3 		mov	r0, #3
 8183 487c FEFFFFEB 		bl	CyU3PUsbSetDesc
2787:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 8184              		.loc 1 2787 0
 8185 4880 0010A0E3 		mov	r1, #0
 8186 4884 D82B9FE5 		ldr	r2, .L790+64
 8187 4888 0600A0E3 		mov	r0, #6
 8188 488c FEFFFFEB 		bl	CyU3PUsbSetDesc
2790:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 8189              		.loc 1 2790 0
 8190 4890 0010A0E3 		mov	r1, #0
 8191 4894 CC2B9FE5 		ldr	r2, .L790+68
 8192 4898 0500A0E3 		mov	r0, #5
 8193 489c FEFFFFEB 		bl	CyU3PUsbSetDesc
2791:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 8194              		.loc 1 2791 0
 8195 48a0 0110A0E3 		mov	r1, #1
 8196 48a4 C02B9FE5 		ldr	r2, .L790+72
 8197 48a8 0500A0E3 		mov	r0, #5
 8198 48ac FEFFFFEB 		bl	CyU3PUsbSetDesc
2792:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 8199              		.loc 1 2792 0
 8200 48b0 0210A0E3 		mov	r1, #2
 8201 48b4 B42B9FE5 		ldr	r2, .L790+76
 8202 48b8 0500A0E3 		mov	r0, #5
 8203 48bc FEFFFFEB 		bl	CyU3PUsbSetDesc
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8204              		.loc 1 2802 0
 8205 48c0 0070A0E3 		mov	r7, #0
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 8206              		.loc 1 2799 0
 8207 48c4 0150A0E3 		mov	r5, #1
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 8208              		.loc 1 2800 0
 8209 48c8 0380A0E3 		mov	r8, #3
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 8210              		.loc 1 2805 0
 8211 48cc 8200A0E3 		mov	r0, #130
 8212 48d0 C0108DE2 		add	r1, sp, #192
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 8213              		.loc 1 2801 0
 8214 48d4 4090A0E3 		mov	r9, #64	@ movhi
2799:../uvc.c      ****     endPointConfig.enable   = 1;
 8215              		.loc 1 2799 0
 8216 48d8 C0508DE5 		str	r5, [sp, #192]
2800:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 8217              		.loc 1 2800 0
 8218 48dc C480CDE5 		strb	r8, [sp, #196]
2801:../uvc.c      ****     endPointConfig.pcktSize = 64;
 8219              		.loc 1 2801 0
 8220 48e0 B89CCDE1 		strh	r9, [sp, #200]	@ movhi
2802:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8221              		.loc 1 2802 0
 8222 48e4 CB70CDE5 		strb	r7, [sp, #203]
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 8223              		.loc 1 2803 0
 8224 48e8 B67CCDE1 		strh	r7, [sp, #198]	@ movhi
2804:../uvc.c      ****     endPointConfig.burstLen = 1;
 8225              		.loc 1 2804 0
 8226 48ec CA50CDE5 		strb	r5, [sp, #202]
2805:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 8227              		.loc 1 2805 0
 8228 48f0 FEFFFFEB 		bl	CyU3PSetEpConfig
 8229              	.LVL723:
2803:../uvc.c      ****     endPointConfig.streams  = 0;
 8230              		.loc 1 2803 0
 8231 48f4 0760A0E1 		mov	r6, r7	@ movhi
2806:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8232              		.loc 1 2806 0
 8233 48f8 003050E2 		subs	r3, r0, #0
 8234 48fc DC01001A 		bne	.L769
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 8235              		.loc 1 2817 0
 8236 4900 6CEB9FE5 		ldr	lr, .L790+80
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8237              		.loc 1 2816 0
 8238 4904 6C9B9FE5 		ldr	r9, .L790+84
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 8239              		.loc 1 2814 0
 8240 4908 01CBA0E3 		mov	ip, #1024	@ movhi
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 8241              		.loc 1 2825 0
 8242 490c 680B9FE5 		ldr	r0, .L790+88
 8243              	.LVL724:
 8244 4910 0410A0E3 		mov	r1, #4
 8245 4914 4C208DE2 		add	r2, sp, #76
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 8246              		.loc 1 2823 0
 8247 4918 10A0A0E3 		mov	sl, #16
2822:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8248              		.loc 1 2822 0
 8249 491c 5C70CDE5 		strb	r7, [sp, #92]
2814:../uvc.c      ****     dmaInterConfig.size           = 1024;
 8250              		.loc 1 2814 0
 8251 4920 BCC4CDE1 		strh	ip, [sp, #76]	@ movhi
2815:../uvc.c      ****     dmaInterConfig.count          = 1;
 8252              		.loc 1 2815 0
 8253 4924 BE54CDE1 		strh	r5, [sp, #78]	@ movhi
2816:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8254              		.loc 1 2816 0
 8255 4928 B095CDE1 		strh	r9, [sp, #80]	@ movhi
2817:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 8256              		.loc 1 2817 0
 8257 492c B2E5CDE1 		strh	lr, [sp, #82]	@ movhi
2818:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 8258              		.loc 1 2818 0
 8259 4930 B435CDE1 		strh	r3, [sp, #84]	@ movhi
2819:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 8260              		.loc 1 2819 0
 8261 4934 B635CDE1 		strh	r3, [sp, #86]	@ movhi
2820:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 8262              		.loc 1 2820 0
 8263 4938 B835CDE1 		strh	r3, [sp, #88]	@ movhi
2821:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 8264              		.loc 1 2821 0
 8265 493c BA35CDE1 		strh	r3, [sp, #90]	@ movhi
2823:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 8266              		.loc 1 2823 0
 8267 4940 60A08DE5 		str	sl, [sp, #96]
2824:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 8268              		.loc 1 2824 0
 8269 4944 64308DE5 		str	r3, [sp, #100]
2825:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 8270              		.loc 1 2825 0
 8271 4948 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8272              	.LVL725:
2827:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8273              		.loc 1 2827 0
 8274 494c 007050E2 		subs	r7, r0, #0
 8275 4950 BD01001A 		bne	.L770
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8276              		.loc 1 2834 0
 8277 4954 010BA0E3 		mov	r0, #1024
 8278              	.LVL726:
 8279 4958 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 8280 495c 1C1B9FE5 		ldr	r1, .L790+92
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8281              		.loc 1 2835 0
 8282 4960 000050E3 		cmp	r0, #0
2834:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8283              		.loc 1 2834 0
 8284 4964 000081E5 		str	r0, [r1, #0]
2835:../uvc.c      ****     if (glInterStaBuffer == 0)
 8285              		.loc 1 2835 0
 8286 4968 AE01000A 		beq	.L771
2842:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
 8287              		.loc 1 2842 0
 8288 496c 0710A0E1 		mov	r1, r7
 8289 4970 0720A0E1 		mov	r2, r7
 8290 4974 3830A0E3 		mov	r3, #56
 8291 4978 040B9FE5 		ldr	r0, .L790+96
 8292 497c FEFFFFEB 		bl	_txe_mutex_create
2844:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 8293              		.loc 1 2844 0
 8294 4980 0430A0E3 		mov	r3, #4	@ movhi
 8295 4984 BA30CDE1 		strh	r3, [sp, #10]	@ movhi
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8296              		.loc 1 2847 0
 8297 4988 F83A9FE5 		ldr	r3, .L790+100
2843:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 8298              		.loc 1 2843 0
 8299 498c 01C9A0E3 		mov	ip, #16384	@ movhi
 8300 4990 B8C0CDE1 		strh	ip, [sp, #8]	@ movhi
2846:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 8301              		.loc 1 2846 0
 8302 4994 01CCA0E3 		mov	ip, #256	@ movhi
 8303 4998 BEC0CDE1 		strh	ip, [sp, #14]	@ movhi
2847:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 8304              		.loc 1 2847 0
 8305 499c B031CDE1 		strh	r3, [sp, #16]	@ movhi
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8306              		.loc 1 2848 0
 8307 49a0 E4CA9FE5 		ldr	ip, .L790+104
2850:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 8308              		.loc 1 2850 0
 8309 49a4 0C30A0E3 		mov	r3, #12	@ movhi
 8310 49a8 B032CDE1 		strh	r3, [sp, #32]	@ movhi
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8311              		.loc 1 2855 0
 8312 49ac DC3A9FE5 		ldr	r3, .L790+108
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8313              		.loc 1 2856 0
 8314 49b0 08208DE2 		add	r2, sp, #8
2848:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 8315              		.loc 1 2848 0
 8316 49b4 B6C1CDE1 		strh	ip, [sp, #22]	@ movhi
2849:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 8317              		.loc 1 2849 0
 8318 49b8 BE71CDE1 		strh	r7, [sp, #30]	@ movhi
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8319              		.loc 1 2851 0
 8320 49bc 04C0A0E3 		mov	ip, #4	@ movhi
2852:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 8321              		.loc 1 2852 0
 8322 49c0 B472CDE1 		strh	r7, [sp, #36]	@ movhi
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8323              		.loc 1 2845 0
 8324 49c4 02A0A0E3 		mov	sl, #2	@ movhi
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8325              		.loc 1 2856 0
 8326 49c8 C40A9FE5 		ldr	r0, .L790+112
 8327 49cc 0710A0E3 		mov	r1, #7
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8328              		.loc 1 2854 0
 8329 49d0 1870A0E3 		mov	r7, #24
 8330              	.LVL727:
2845:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 8331              		.loc 1 2845 0
 8332 49d4 BCA0CDE1 		strh	sl, [sp, #12]	@ movhi
2851:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 8333              		.loc 1 2851 0
 8334 49d8 B2C2CDE1 		strh	ip, [sp, #34]	@ movhi
2853:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8335              		.loc 1 2853 0
 8336 49dc 2660CDE5 		strb	r6, [sp, #38]
2854:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 8337              		.loc 1 2854 0
 8338 49e0 28708DE5 		str	r7, [sp, #40]
2855:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 8339              		.loc 1 2855 0
 8340 49e4 2C308DE5 		str	r3, [sp, #44]
2856:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 8341              		.loc 1 2856 0
 8342 49e8 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 8343              	.LVL728:
2858:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8344              		.loc 1 2858 0
 8345 49ec 002050E2 		subs	r2, r0, #0
 8346 49f0 8301001A 		bne	.L772
2873:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8347              		.loc 1 2873 0
 8348 49f4 C4A0CDE5 		strb	sl, [sp, #196]
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
 8349              		.loc 1 2879 0
 8350 49f8 0400A0E3 		mov	r0, #4
 8351              	.LVL729:
 8352 49fc C0108DE2 		add	r1, sp, #192
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
 8353              		.loc 1 2874 0
 8354 4a00 01ABA0E3 		mov	sl, #1024	@ movhi
2876:../uvc.c      ****     endPointConfig.streams  = 0;
 8355              		.loc 1 2876 0
 8356 4a04 B62CCDE1 		strh	r2, [sp, #198]	@ movhi
2872:../uvc.c      ****     endPointConfig.enable   = 1;
 8357              		.loc 1 2872 0
 8358 4a08 C0508DE5 		str	r5, [sp, #192]
2874:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
 8359              		.loc 1 2874 0
 8360 4a0c B8ACCDE1 		strh	sl, [sp, #200]	@ movhi
2875:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 8361              		.loc 1 2875 0
 8362 4a10 CB60CDE5 		strb	r6, [sp, #203]
2877:../uvc.c      ****     endPointConfig.burstLen = 1;
 8363              		.loc 1 2877 0
 8364 4a14 CA50CDE5 		strb	r5, [sp, #202]
2879:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
 8365              		.loc 1 2879 0
 8366 4a18 FEFFFFEB 		bl	CyU3PSetEpConfig
 8367              	.LVL730:
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8368              		.loc 1 2880 0
 8369 4a1c 002050E2 		subs	r2, r0, #0
 8370 4a20 6E01001A 		bne	.L773
2886:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
 8371              		.loc 1 2886 0
 8372 4a24 0510A0E1 		mov	r1, r5
 8373 4a28 0400A0E3 		mov	r0, #4
 8374              	.LVL731:
 8375 4a2c FEFFFFEB 		bl	CyU3PUsbSetEpPktMode
 8376              	.LVL732:
2888:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
 8377              		.loc 1 2888 0
 8378 4a30 8400A0E3 		mov	r0, #132
 8379 4a34 C0108DE2 		add	r1, sp, #192
 8380 4a38 FEFFFFEB 		bl	CyU3PSetEpConfig
 8381              	.LVL733:
2889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8382              		.loc 1 2889 0
 8383 4a3c 003050E2 		subs	r3, r0, #0
 8384 4a40 5C01001A 		bne	.L774
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8385              		.loc 1 2907 0
 8386 4a44 0810A0E1 		mov	r1, r8
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
 8387              		.loc 1 2897 0
 8388 4a48 487A9FE5 		ldr	r7, .L790+116
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 8389              		.loc 1 2905 0
 8390 4a4c 488A9FE5 		ldr	r8, .L790+120
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8391              		.loc 1 2907 0
 8392 4a50 30208DE2 		add	r2, sp, #48
2895:../uvc.c      ****     channelConfig.size           = 1024;
 8393              		.loc 1 2895 0
 8394 4a54 01CBA0E3 		mov	ip, #1024	@ movhi
2896:../uvc.c      ****     channelConfig.count          = 1;
 8395              		.loc 1 2896 0
 8396 4a58 B253CDE1 		strh	r5, [sp, #50]	@ movhi
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
 8397              		.loc 1 2898 0
 8398 4a5c 3FECA0E3 		mov	lr, #16128	@ movhi
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8399              		.loc 1 2907 0
 8400 4a60 380A9FE5 		ldr	r0, .L790+124
 8401              	.LVL734:
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
 8402              		.loc 1 2904 0
 8403 4a64 0850A0E3 		mov	r5, #8
2895:../uvc.c      ****     channelConfig.size           = 1024;
 8404              		.loc 1 2895 0
 8405 4a68 B0C3CDE1 		strh	ip, [sp, #48]	@ movhi
2897:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
 8406              		.loc 1 2897 0
 8407 4a6c B473CDE1 		strh	r7, [sp, #52]	@ movhi
2898:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
 8408              		.loc 1 2898 0
 8409 4a70 B6E3CDE1 		strh	lr, [sp, #54]	@ movhi
2899:../uvc.c      ****     channelConfig.prodAvailCount = 0;
 8410              		.loc 1 2899 0
 8411 4a74 B833CDE1 		strh	r3, [sp, #56]	@ movhi
2900:../uvc.c      ****     channelConfig.prodHeader     = 0;
 8412              		.loc 1 2900 0
 8413 4a78 BA33CDE1 		strh	r3, [sp, #58]	@ movhi
2901:../uvc.c      ****     channelConfig.prodFooter     = 0;
 8414              		.loc 1 2901 0
 8415 4a7c BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2902:../uvc.c      ****     channelConfig.consHeader     = 0;
 8416              		.loc 1 2902 0
 8417 4a80 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2903:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8418              		.loc 1 2903 0
 8419 4a84 4060CDE5 		strb	r6, [sp, #64]
2904:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
 8420              		.loc 1 2904 0
 8421 4a88 44508DE5 		str	r5, [sp, #68]
2905:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
 8422              		.loc 1 2905 0
 8423 4a8c 48808DE5 		str	r8, [sp, #72]
2907:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
 8424              		.loc 1 2907 0
 8425 4a90 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8426              	.LVL735:
2908:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8427              		.loc 1 2908 0
 8428 4a94 002050E2 		subs	r2, r0, #0
 8429 4a98 3D01001A 		bne	.L775
2914:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
 8430              		.loc 1 2914 0
 8431 4a9c FC099FE5 		ldr	r0, .L790+124
 8432              	.LVL736:
 8433 4aa0 0210A0E1 		mov	r1, r2
 8434 4aa4 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 8435              	.LVL737:
2915:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8436              		.loc 1 2915 0
 8437 4aa8 003050E2 		subs	r3, r0, #0
 8438 4aac 2E01001A 		bne	.L776
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8439              		.loc 1 2933 0
 8440 4ab0 30208DE2 		add	r2, sp, #48
2923:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 8441              		.loc 1 2923 0
 8442 4ab4 B493CDE1 		strh	r9, [sp, #52]	@ movhi
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8443              		.loc 1 2933 0
 8444 4ab8 E4099FE5 		ldr	r0, .L790+128
 8445              	.LVL738:
 8446 4abc 0410A0E3 		mov	r1, #4
2921:../uvc.c      ****     channelConfig.size           = 1024;
 8447              		.loc 1 2921 0
 8448 4ac0 01ABA0E3 		mov	sl, #1024	@ movhi
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
 8449              		.loc 1 2924 0
 8450 4ac4 C19FA0E3 		mov	r9, #772	@ movhi
2921:../uvc.c      ****     channelConfig.size           = 1024;
 8451              		.loc 1 2921 0
 8452 4ac8 B0A3CDE1 		strh	sl, [sp, #48]	@ movhi
2922:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
 8453              		.loc 1 2922 0
 8454 4acc B233CDE1 		strh	r3, [sp, #50]	@ movhi
2924:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
 8455              		.loc 1 2924 0
 8456 4ad0 B693CDE1 		strh	r9, [sp, #54]	@ movhi
2925:../uvc.c      ****     channelConfig.prodAvailCount = 0;
 8457              		.loc 1 2925 0
 8458 4ad4 B833CDE1 		strh	r3, [sp, #56]	@ movhi
2926:../uvc.c      ****     channelConfig.prodHeader     = 0;
 8459              		.loc 1 2926 0
 8460 4ad8 BA33CDE1 		strh	r3, [sp, #58]	@ movhi
2927:../uvc.c      ****     channelConfig.prodFooter     = 0;
 8461              		.loc 1 2927 0
 8462 4adc BC33CDE1 		strh	r3, [sp, #60]	@ movhi
2928:../uvc.c      ****     channelConfig.consHeader     = 0;
 8463              		.loc 1 2928 0
 8464 4ae0 BE33CDE1 		strh	r3, [sp, #62]	@ movhi
2929:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 8465              		.loc 1 2929 0
 8466 4ae4 4060CDE5 		strb	r6, [sp, #64]
2930:../uvc.c      ****     channelConfig.notification   = 0;
 8467              		.loc 1 2930 0
 8468 4ae8 44308DE5 		str	r3, [sp, #68]
2931:../uvc.c      ****     channelConfig.cb             = 0;
 8469              		.loc 1 2931 0
 8470 4aec 48308DE5 		str	r3, [sp, #72]
2933:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
 8471              		.loc 1 2933 0
 8472 4af0 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 8473              	.LVL739:
2934:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8474              		.loc 1 2934 0
 8475 4af4 002050E2 		subs	r2, r0, #0
 8476 4af8 1201001A 		bne	.L777
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8477              		.loc 1 2940 0
 8478 4afc 010BA0E3 		mov	r0, #1024
 8479              	.LVL740:
 8480 4b00 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 8481              	.LVL741:
 8482 4b04 9C299FE5 		ldr	r2, .L790+132
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
 8483              		.loc 1 2941 0
 8484 4b08 000050E3 		cmp	r0, #0
2940:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 8485              		.loc 1 2940 0
 8486 4b0c 000082E5 		str	r0, [r2, #0]
2941:../uvc.c      ****     if (glDebugRspBuffer == 0)
 8487              		.loc 1 2941 0
 8488 4b10 BF00000A 		beq	.L778
2949:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 8489              		.loc 1 2949 0
 8490 4b14 0100A0E3 		mov	r0, #1
 8491 4b18 0010A0E1 		mov	r1, r0
 8492 4b1c FEFFFFEB 		bl	CyU3PConnectState
 8493              	.LVL742:
2950:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8494              		.loc 1 2950 0
 8495 4b20 002050E2 		subs	r2, r0, #0
 8496 4b24 B100001A 		bne	.L779
2956:../uvc.c      ****     CyU3PBusyWait(100);
 8497              		.loc 1 2956 0
 8498 4b28 6400A0E3 		mov	r0, #100
 8499              	.LVL743:
 8500 4b2c FEFFFFEB 		bl	CyU3PBusyWait
 8501              	.LVL744:
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8502              		.loc 1 2958 0
 8503 4b30 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2960:../uvc.c      ****     endPointConfig.enable   = 1;
 8504              		.loc 1 2960 0
 8505 4b34 0110A0E3 		mov	r1, #1
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8506              		.loc 1 2961 0
 8507 4b38 0230A0E3 		mov	r3, #2
2960:../uvc.c      ****     endPointConfig.enable   = 1;
 8508              		.loc 1 2960 0
 8509 4b3c C0108DE5 		str	r1, [sp, #192]
2961:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 8510              		.loc 1 2961 0
 8511 4b40 C430CDE5 		strb	r3, [sp, #196]
2972:../uvc.c      ****     endPointConfig.streams  = 0;
 8512              		.loc 1 2972 0
 8513 4b44 0060A0E3 		mov	r6, #0	@ movhi
 8514 4b48 B66CCDE1 		strh	r6, [sp, #198]	@ movhi
2962:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 8515              		.loc 1 2962 0
 8516 4b4c 030050E3 		cmp	r0, #3
2965:../uvc.c      ****     	endPointConfig.burstLen = 16;
 8517              		.loc 1 2965 0
 8518 4b50 0F108102 		addeq	r1, r1, #15
2958:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 8519              		.loc 1 2958 0
 8520 4b54 C800C4E5 		strb	r0, [r4, #200]
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8521              		.loc 1 2969 0
 8522 4b58 020CA013 		movne	r0, #512	@ movhi
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8523              		.loc 1 2964 0
 8524 4b5c 013BA003 		moveq	r3, #1024	@ movhi
2969:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 8525              		.loc 1 2969 0
 8526 4b60 B80CCD11 		strneh	r0, [sp, #200]	@ movhi
2970:../uvc.c      ****     	endPointConfig.burstLen = 1;
 8527              		.loc 1 2970 0
 8528 4b64 CA10CDE5 		strb	r1, [sp, #202]
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8529              		.loc 1 2973 0
 8530 4b68 8300A0E3 		mov	r0, #131
 8531 4b6c C0108DE2 		add	r1, sp, #192
2964:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 8532              		.loc 1 2964 0
 8533 4b70 B83CCD01 		streqh	r3, [sp, #200]	@ movhi
2973:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 8534              		.loc 1 2973 0
 8535 4b74 FEFFFFEB 		bl	CyU3PSetEpConfig
 8536              	.LVL745:
2974:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8537              		.loc 1 2974 0
 8538 4b78 002050E2 		subs	r2, r0, #0
 8539 4b7c 5600001A 		bne	.L756
 8540 4b80 24799FE5 		ldr	r7, .L790+136
 8541              	.LBE230:
 8542              	.LBE227:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8543              		.loc 1 3097 0
 8544 4b84 AC589FE5 		ldr	r5, .L790+20
 8545 4b88 0260A0E1 		mov	r6, r2
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
 8546              		.loc 1 3328 0
 8547 4b8c 0080E0E3 		mvn	r8, #0
 8548              	.LVL746:
 8549              	.L705:
3097:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 8550              		.loc 1 3097 0
 8551 4b90 A0089FE5 		ldr	r0, .L790+20
 8552 4b94 0110A0E3 		mov	r1, #1
 8553 4b98 0220A0E3 		mov	r2, #2
 8554 4b9c CC308DE2 		add	r3, sp, #204
 8555 4ba0 00608DE5 		str	r6, [sp, #0]
 8556 4ba4 FEFFFFEB 		bl	_txe_event_flags_get
 8557 4ba8 000050E3 		cmp	r0, #0
 8558 4bac 3300001A 		bne	.L707
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8559              		.loc 1 3101 0
 8560 4bb0 29C0D5E5 		ldrb	ip, [r5, #41]	@ zero_extendqisi2
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8561              		.loc 1 3146 0
 8562 4bb4 BCE095E5 		ldr	lr, [r5, #188]
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8563              		.loc 1 3101 0
 8564 4bb8 01308CE3 		orr	r3, ip, #1
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8565              		.loc 1 3146 0
 8566 4bbc 00005EE3 		cmp	lr, #0
3101:../uvc.c      ****         	debugData[0][1] = debugData[0][1]|0x01;
 8567              		.loc 1 3101 0
 8568 4bc0 2930C5E5 		strb	r3, [r5, #41]
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8569              		.loc 1 3146 0
 8570 4bc4 0300000A 		beq	.L708
3146:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 8571              		.loc 1 3146 0 is_stmt 0 discriminator 1
 8572 4bc8 B09CD5E1 		ldrh	r9, [r5, #192]
 8573 4bcc B2ACD5E1 		ldrh	sl, [r5, #194]
 8574 4bd0 0A0059E1 		cmp	r9, sl
 8575 4bd4 6601000A 		beq	.L780
 8576              	.LVL747:
 8577              	.L708:
3404:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 8578              		.loc 1 3404 0 is_stmt 1
 8579 4bd8 4010A0E3 		mov	r1, #64
 8580 4bdc 0020A0E3 		mov	r2, #0
 8581 4be0 50089FE5 		ldr	r0, .L790+20
 8582 4be4 FEFFFFEB 		bl	_txe_event_flags_set
3407:../uvc.c      ****         CyU3PThreadRelinquish ();
 8583              		.loc 1 3407 0
 8584 4be8 FEFFFFEB 		bl	_txe_thread_relinquish
3408:../uvc.c      ****     }
 8585              		.loc 1 3408 0
 8586 4bec E7FFFFEA 		b	.L705
 8587              	.LVL748:
 8588              	.L759:
 8589              	.LBB277:
 8590              	.LBB229:
2646:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 8591              		.loc 1 2646 0
 8592 4bf0 0400A0E3 		mov	r0, #4
 8593              	.LVL749:
 8594 4bf4 B4189FE5 		ldr	r1, .L790+140
 8595 4bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 8596              	.LVL750:
 8597              	.L662:
 8598              	.LBB241:
 8599              	.LBB242:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8600              		.loc 1 2061 0
 8601 4bfc B0189FE5 		ldr	r1, .L790+144
 8602 4c00 0400A0E3 		mov	r0, #4
 8603 4c04 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8604              		.loc 1 2062 0
 8605 4c08 FA0FA0E3 		mov	r0, #1000
 8606 4c0c FEFFFFEB 		bl	_tx_thread_sleep
 8607 4c10 F9FFFFEA 		b	.L662
 8608              	.LVL751:
 8609              	.L761:
 8610              	.LBE242:
 8611              	.LBE241:
2677:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 8612              		.loc 1 2677 0
 8613 4c14 0400A0E3 		mov	r0, #4
 8614              	.LVL752:
 8615 4c18 98189FE5 		ldr	r1, .L790+148
 8616 4c1c FEFFFFEB 		bl	CyU3PDebugPrint
 8617              	.LVL753:
 8618              	.L666:
 8619              	.LBB239:
 8620              	.LBB240:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8621              		.loc 1 2061 0
 8622 4c20 8C189FE5 		ldr	r1, .L790+144
 8623 4c24 0400A0E3 		mov	r0, #4
 8624 4c28 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8625              		.loc 1 2062 0
 8626 4c2c FA0FA0E3 		mov	r0, #1000
 8627 4c30 FEFFFFEB 		bl	_tx_thread_sleep
 8628 4c34 F9FFFFEA 		b	.L666
 8629              	.LVL754:
 8630              	.L760:
 8631              	.LBE240:
 8632              	.LBE239:
2668:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 8633              		.loc 1 2668 0
 8634 4c38 0400A0E3 		mov	r0, #4
 8635              	.LVL755:
 8636 4c3c 78189FE5 		ldr	r1, .L790+152
 8637 4c40 FEFFFFEB 		bl	CyU3PDebugPrint
 8638              	.LVL756:
 8639              	.L664:
 8640              	.LBB237:
 8641              	.LBB238:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8642              		.loc 1 2061 0
 8643 4c44 68189FE5 		ldr	r1, .L790+144
 8644 4c48 0400A0E3 		mov	r0, #4
 8645 4c4c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8646              		.loc 1 2062 0
 8647 4c50 FA0FA0E3 		mov	r0, #1000
 8648 4c54 FEFFFFEB 		bl	_tx_thread_sleep
 8649 4c58 F9FFFFEA 		b	.L664
 8650              	.LVL757:
 8651              	.L762:
 8652              	.LBE238:
 8653              	.LBE237:
2683:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 8654              		.loc 1 2683 0
 8655 4c5c 0400A0E3 		mov	r0, #4
 8656              	.LVL758:
 8657 4c60 58189FE5 		ldr	r1, .L790+156
 8658 4c64 FEFFFFEB 		bl	CyU3PDebugPrint
 8659              	.LVL759:
 8660              	.L668:
 8661              	.LBB235:
 8662              	.LBB236:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8663              		.loc 1 2061 0
 8664 4c68 44189FE5 		ldr	r1, .L790+144
 8665 4c6c 0400A0E3 		mov	r0, #4
 8666 4c70 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8667              		.loc 1 2062 0
 8668 4c74 FA0FA0E3 		mov	r0, #1000
 8669 4c78 FEFFFFEB 		bl	_tx_thread_sleep
 8670 4c7c F9FFFFEA 		b	.L668
 8671              	.LVL760:
 8672              	.L707:
 8673              	.LBE236:
 8674              	.LBE235:
 8675              	.LBE229:
 8676              	.LBE277:
3259:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 8677              		.loc 1 3259 0
 8678 4c80 B0079FE5 		ldr	r0, .L790+20
 8679 4c84 0210A0E3 		mov	r1, #2
 8680 4c88 0320A0E3 		mov	r2, #3
 8681 4c8c CC308DE2 		add	r3, sp, #204
 8682 4c90 00608DE5 		str	r6, [sp, #0]
 8683 4c94 FEFFFFEB 		bl	_txe_event_flags_get
 8684 4c98 000050E3 		cmp	r0, #0
 8685 4c9c 2400001A 		bne	.L730
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8686              		.loc 1 3262 0
 8687 4ca0 2930D5E5 		ldrb	r3, [r5, #41]	@ zero_extendqisi2
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8688              		.loc 1 3276 0
 8689 4ca4 C49095E5 		ldr	r9, [r5, #196]
3262:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8690              		.loc 1 3262 0
 8691 4ca8 7FE003E2 		and	lr, r3, #127
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8692              		.loc 1 3263 0
 8693 4cac 04108EE3 		orr	r1, lr, #4
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8694              		.loc 1 3276 0
 8695 4cb0 000059E3 		cmp	r9, #0
3264:../uvc.c      ****             	hitFV     = CyFalse;
 8696              		.loc 1 3264 0
 8697 4cb4 BC6085E5 		str	r6, [r5, #188]
3263:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x04;
 8698              		.loc 1 3263 0
 8699 4cb8 2910C5E5 		strb	r1, [r5, #41]
3265:../uvc.c      ****                 prodCount = 0;
 8700              		.loc 1 3265 0
 8701 4cbc B06CC5E1 		strh	r6, [r5, #192]	@ movhi
3272:../uvc.c      ****                 fb=0;
 8702              		.loc 1 3272 0
 8703 4cc0 B46BC5E1 		strh	r6, [r5, #180]	@ movhi
3266:../uvc.c      ****                 consCount = 0;
 8704              		.loc 1 3266 0
 8705 4cc4 B26CC5E1 		strh	r6, [r5, #194]	@ movhi
3273:../uvc.c      ****                 pb=0;
 8706              		.loc 1 3273 0
 8707 4cc8 B66BC5E1 		strh	r6, [r5, #182]	@ movhi
3274:../uvc.c      ****                 pbc=0;
 8708              		.loc 1 3274 0
 8709 4ccc B86BC5E1 		strh	r6, [r5, #184]	@ movhi
3276:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 8710              		.loc 1 3276 0
 8711 4cd0 0A00000A 		beq	.L781
 8712              	.LVL761:
 8713              	.L731:
3297:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 8714              		.loc 1 3297 0
 8715 4cd4 C46084E5 		str	r6, [r4, #196]
 8716 4cd8 BEFFFFEA 		b	.L708
 8717              	.LVL762:
 8718              	.L756:
 8719              	.LBB278:
 8720              	.LBB275:
2977:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 8721              		.loc 1 2977 0
 8722 4cdc 0400A0E3 		mov	r0, #4
 8723              	.LVL763:
 8724 4ce0 DC179FE5 		ldr	r1, .L790+160
 8725 4ce4 FEFFFFEB 		bl	CyU3PDebugPrint
 8726              	.LVL764:
 8727              	.L706:
 8728              	.LBB243:
 8729              	.LBB244:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8730              		.loc 1 2061 0
 8731 4ce8 C4179FE5 		ldr	r1, .L790+144
 8732 4cec 0400A0E3 		mov	r0, #4
 8733 4cf0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8734              		.loc 1 2062 0
 8735 4cf4 FA0FA0E3 		mov	r0, #1000
 8736 4cf8 FEFFFFEB 		bl	_tx_thread_sleep
 8737 4cfc F9FFFFEA 		b	.L706
 8738              	.LVL765:
 8739              	.L781:
 8740              	.LBE244:
 8741              	.LBE243:
 8742              	.LBE275:
 8743              	.LBE278:
3278:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 8744              		.loc 1 3278 0
 8745 4d00 8C079FE5 		ldr	r0, .L790+112
 8746 4d04 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 8747              	.LVL766:
3279:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 8748              		.loc 1 3279 0
 8749 4d08 000050E3 		cmp	r0, #0
 8750 4d0c 0200001A 		bne	.L757
3285:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 8751              		.loc 1 3285 0
 8752 4d10 8300A0E3 		mov	r0, #131
 8753              	.LVL767:
 8754 4d14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 8755 4d18 EDFFFFEA 		b	.L731
 8756              	.L757:
 8757              	.LBB279:
 8758              	.LBB280:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8759              		.loc 1 2061 0
 8760 4d1c 90179FE5 		ldr	r1, .L790+144
 8761 4d20 0400A0E3 		mov	r0, #4
 8762 4d24 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8763              		.loc 1 2062 0
 8764 4d28 FA0FA0E3 		mov	r0, #1000
 8765 4d2c FEFFFFEB 		bl	_tx_thread_sleep
 8766 4d30 F9FFFFEA 		b	.L757
 8767              	.LVL768:
 8768              	.L730:
 8769              	.LBE280:
 8770              	.LBE279:
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8771              		.loc 1 3320 0
 8772 4d34 2900D5E5 		ldrb	r0, [r5, #41]	@ zero_extendqisi2
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8773              		.loc 1 3322 0
 8774 4d38 88179FE5 		ldr	r1, .L790+164
3320:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8775              		.loc 1 3320 0
 8776 4d3c 7F2000E2 		and	r2, r0, #127
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
 8777              		.loc 1 3321 0
 8778 4d40 20A082E3 		orr	sl, r2, #32
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8779              		.loc 1 3322 0
 8780 4d44 0400A0E3 		mov	r0, #4
 8781 4d48 0620A0E1 		mov	r2, r6
3321:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x20;
 8782              		.loc 1 3321 0
 8783 4d4c 29A0C5E5 		strb	sl, [r5, #41]
3322:../uvc.c      ****             	CyU3PDebugPrint (4, "pre wait stream set %x\n", apiRetStatus);
 8784              		.loc 1 3322 0
 8785 4d50 FEFFFFEB 		bl	CyU3PDebugPrint
3323:../uvc.c      ****             	if(CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_CLEAR_EVENT, CYU3P_EVENT_AND, &flag,
 8786              		.loc 1 3323 0
 8787 4d54 DC069FE5 		ldr	r0, .L790+20
 8788 4d58 011CA0E3 		mov	r1, #256
 8789 4d5c 0220A0E3 		mov	r2, #2
 8790 4d60 CC308DE2 		add	r3, sp, #204
 8791 4d64 00608DE5 		str	r6, [sp, #0]
 8792 4d68 FEFFFFEB 		bl	_txe_event_flags_get
 8793 4d6c 000050E3 		cmp	r0, #0
 8794 4d70 6400001A 		bne	.L734
3325:../uvc.c      ****                     		CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_OR);
 8795              		.loc 1 3325 0
 8796 4d74 0110A0E3 		mov	r1, #1
 8797 4d78 0620A0E1 		mov	r2, r6
 8798 4d7c B4069FE5 		ldr	r0, .L790+20
 8799 4d80 FEFFFFEB 		bl	_txe_event_flags_set
 8800              	.L735:
3332:../uvc.c      ****             	CyU3PDebugPrint (4, "post wait stream set %x\n", apiRetStatus);
 8801              		.loc 1 3332 0
 8802 4d84 40179FE5 		ldr	r1, .L790+168
 8803 4d88 0020A0E3 		mov	r2, #0
 8804 4d8c 0400A0E3 		mov	r0, #4
 8805 4d90 FEFFFFEB 		bl	CyU3PDebugPrint
3333:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 8806              		.loc 1 3333 0
 8807 4d94 0010A0E3 		mov	r1, #0
 8808 4d98 0120A0E1 		mov	r2, r1
 8809 4d9c F0069FE5 		ldr	r0, .L790+112
 8810 4da0 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 8811              	.LVL769:
3334:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 8812              		.loc 1 3334 0
 8813 4da4 002050E2 		subs	r2, r0, #0
 8814 4da8 4D00001A 		bne	.L782
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8815              		.loc 1 3340 0
 8816 4dac 29E0D4E5 		ldrb	lr, [r4, #41]	@ zero_extendqisi2
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8817              		.loc 1 3343 0
 8818 4db0 A81094E5 		ldr	r1, [r4, #168]
3340:../uvc.c      ****             	debugData[0][1] = debugData[0][1]&0x7F;
 8819              		.loc 1 3340 0
 8820 4db4 7F900EE2 		and	r9, lr, #127
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8821              		.loc 1 3341 0
 8822 4db8 08C089E3 		orr	ip, r9, #8
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8823              		.loc 1 3343 0
 8824 4dbc 000051E3 		cmp	r1, #0
3341:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x08;
 8825              		.loc 1 3341 0
 8826 4dc0 29C0C4E5 		strb	ip, [r4, #41]
3343:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 8827              		.loc 1 3343 0
 8828 4dc4 3E00001A 		bne	.L738
 8829              	.LVL770:
 8830              	.LBB281:
 8831              	.LBB283:
3002:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8832              		.loc 1 3002 0
 8833 4dc8 C830D5E5 		ldrb	r3, [r5, #200]	@ zero_extendqisi2
 8834 4dcc 030053E3 		cmp	r3, #3
 8835 4dd0 3400000A 		beq	.L783
3007:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 8836              		.loc 1 3007 0
 8837 4dd4 020053E3 		cmp	r3, #2
 8838 4dd8 1600000A 		beq	.L784
 8839              	.LVL771:
 8840              	.L741:
 8841              	.LBE283:
 8842              	.LBE281:
3391:../uvc.c      ****                     gpif_initialized = CyTrue;
 8843              		.loc 1 3391 0
 8844 4ddc 0130A0E3 		mov	r3, #1
 8845 4de0 A83084E5 		str	r3, [r4, #168]
3393:../uvc.c      ****                     CyU3PThreadSleep(200);
 8846              		.loc 1 3393 0
 8847 4de4 C800A0E3 		mov	r0, #200
 8848 4de8 FEFFFFEB 		bl	_tx_thread_sleep
 8849 4dec 79FFFFEA 		b	.L708
 8850              	.LVL772:
 8851              	.L779:
 8852              	.LBB289:
 8853              	.LBB228:
2952:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 8854              		.loc 1 2952 0
 8855 4df0 0400A0E3 		mov	r0, #4
 8856              	.LVL773:
 8857 4df4 D4169FE5 		ldr	r1, .L790+172
 8858 4df8 FEFFFFEB 		bl	CyU3PDebugPrint
 8859              	.LVL774:
 8860              	.L702:
 8861              	.LBB233:
 8862              	.LBB234:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8863              		.loc 1 2061 0
 8864 4dfc B0169FE5 		ldr	r1, .L790+144
 8865 4e00 0400A0E3 		mov	r0, #4
 8866 4e04 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8867              		.loc 1 2062 0
 8868 4e08 FA0FA0E3 		mov	r0, #1000
 8869 4e0c FEFFFFEB 		bl	_tx_thread_sleep
 8870 4e10 F9FFFFEA 		b	.L702
 8871              	.L778:
 8872              	.LBE234:
 8873              	.LBE233:
2943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
 8874              		.loc 1 2943 0
 8875 4e14 040080E2 		add	r0, r0, #4
 8876 4e18 B4169FE5 		ldr	r1, .L790+176
 8877 4e1c FEFFFFEB 		bl	CyU3PDebugPrint
 8878              	.LVL775:
 8879              	.L700:
 8880              	.LBB231:
 8881              	.LBB232:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8882              		.loc 1 2061 0
 8883 4e20 8C169FE5 		ldr	r1, .L790+144
 8884 4e24 0400A0E3 		mov	r0, #4
 8885 4e28 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8886              		.loc 1 2062 0
 8887 4e2c FA0FA0E3 		mov	r0, #1000
 8888 4e30 FEFFFFEB 		bl	_tx_thread_sleep
 8889 4e34 F9FFFFEA 		b	.L700
 8890              	.LVL776:
 8891              	.L784:
 8892              	.LBE232:
 8893              	.LBE231:
 8894              	.LBE228:
 8895              	.LBE289:
 8896              	.LBB290:
 8897              	.LBB282:
3009:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 8898              		.loc 1 3009 0
 8899 4e38 98169FE5 		ldr	r1, .L790+180
 8900 4e3c 0100A0E3 		mov	r0, #1
 8901              	.LVL777:
 8902 4e40 FEFFFFEB 		bl	CyU3PDebugPrint
 8903              	.LVL778:
3010:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 8904              		.loc 1 3010 0
 8905 4e44 90069FE5 		ldr	r0, .L790+184
 8906 4e48 FEFFFFEB 		bl	CyU3PGpifLoad
 8907 4e4c 0020A0E1 		mov	r2, r0
 8908              	.LVL779:
 8909              	.L740:
3012:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8910              		.loc 1 3012 0
 8911 4e50 000052E3 		cmp	r2, #0
 8912 4e54 3200001A 		bne	.L785
3020:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 8913              		.loc 1 3020 0
 8914 4e58 C830D4E5 		ldrb	r3, [r4, #200]	@ zero_extendqisi2
 8915 4e5c 030053E3 		cmp	r3, #3
 8916 4e60 0100000A 		beq	.L758
3024:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 8917              		.loc 1 3024 0
 8918 4e64 020053E3 		cmp	r3, #2
 8919 4e68 DBFFFF1A 		bne	.L741
 8920              	.L758:
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8921              		.loc 1 3026 0
 8922 4e6c 0200A0E1 		mov	r0, r2
 8923              	.LVL780:
 8924 4e70 0210A0E1 		mov	r1, r2
 8925 4e74 FEFFFFEB 		bl	CyU3PGpifSMStart
 8926              	.LVL781:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8927              		.loc 1 3028 0
 8928 4e78 000050E3 		cmp	r0, #0
3026:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 8929              		.loc 1 3026 0
 8930 4e7c 0020A0E1 		mov	r2, r0
 8931              	.LVL782:
3028:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 8932              		.loc 1 3028 0
 8933 4e80 D5FFFF0A 		beq	.L741
3031:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 8934              		.loc 1 3031 0
 8935 4e84 0400A0E3 		mov	r0, #4
 8936              	.LVL783:
 8937 4e88 50169FE5 		ldr	r1, .L790+188
 8938 4e8c FEFFFFEB 		bl	CyU3PDebugPrint
 8939              	.LVL784:
 8940              	.L746:
 8941              	.LBB284:
 8942              	.LBB285:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8943              		.loc 1 2061 0
 8944 4e90 1C169FE5 		ldr	r1, .L790+144
 8945 4e94 0400A0E3 		mov	r0, #4
 8946 4e98 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8947              		.loc 1 2062 0
 8948 4e9c FA0FA0E3 		mov	r0, #1000
 8949 4ea0 FEFFFFEB 		bl	_tx_thread_sleep
 8950 4ea4 F9FFFFEA 		b	.L746
 8951              	.LVL785:
 8952              	.L783:
 8953              	.LBE285:
 8954              	.LBE284:
3004:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 8955              		.loc 1 3004 0
 8956 4ea8 34169FE5 		ldr	r1, .L790+192
 8957 4eac 0100A0E3 		mov	r0, #1
 8958              	.LVL786:
 8959 4eb0 FEFFFFEB 		bl	CyU3PDebugPrint
 8960              	.LVL787:
3005:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 8961              		.loc 1 3005 0
 8962 4eb4 2C069FE5 		ldr	r0, .L790+196
 8963 4eb8 FEFFFFEB 		bl	CyU3PGpifLoad
 8964 4ebc 0020A0E1 		mov	r2, r0
 8965              	.LVL788:
 8966 4ec0 E2FFFFEA 		b	.L740
 8967              	.LVL789:
 8968              	.L738:
 8969              	.LBE282:
 8970              	.LBE290:
3400:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 8971              		.loc 1 3400 0
 8972 4ec4 BC059FE5 		ldr	r0, .L790+100
 8973              	.LVL790:
 8974 4ec8 0210A0E1 		mov	r1, r2
 8975 4ecc 02A0A0E3 		mov	sl, #2
 8976 4ed0 0020A0E1 		mov	r2, r0
 8977              	.LVL791:
 8978 4ed4 0130A0E1 		mov	r3, r1
 8979 4ed8 00A08DE5 		str	sl, [sp, #0]
 8980 4edc FEFFFFEB 		bl	CyU3PGpifSMSwitch
 8981              	.LVL792:
 8982 4ee0 3CFFFFEA 		b	.L708
 8983              	.LVL793:
 8984              	.L782:
3337:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 8985              		.loc 1 3337 0
 8986 4ee4 0400A0E3 		mov	r0, #4
 8987              	.LVL794:
 8988 4ee8 FC159FE5 		ldr	r1, .L790+200
 8989 4eec FEFFFFEB 		bl	CyU3PDebugPrint
 8990              	.LVL795:
 8991              	.L737:
 8992              	.LBB291:
 8993              	.LBB292:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 8994              		.loc 1 2061 0
 8995 4ef0 BC159FE5 		ldr	r1, .L790+144
 8996 4ef4 0400A0E3 		mov	r0, #4
 8997 4ef8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 8998              		.loc 1 2062 0
 8999 4efc FA0FA0E3 		mov	r0, #1000
 9000 4f00 FEFFFFEB 		bl	_tx_thread_sleep
 9001 4f04 F9FFFFEA 		b	.L737
 9002              	.LVL796:
 9003              	.L734:
 9004              	.LBE292:
 9005              	.LBE291:
3328:../uvc.c      ****             		CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P_W
 9006              		.loc 1 3328 0
 9007 4f08 0110A0E3 		mov	r1, #1
 9008 4f0c 0220A0E3 		mov	r2, #2
 9009 4f10 CC308DE2 		add	r3, sp, #204
 9010 4f14 1C059FE5 		ldr	r0, .L790+20
 9011 4f18 00808DE5 		str	r8, [sp, #0]
 9012 4f1c FEFFFFEB 		bl	_txe_event_flags_get
 9013 4f20 97FFFFEA 		b	.L735
 9014              	.LVL797:
 9015              	.L785:
 9016              	.LBB293:
 9017              	.LBB288:
3015:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 9018              		.loc 1 3015 0
 9019 4f24 0400A0E3 		mov	r0, #4
 9020              	.LVL798:
 9021 4f28 C0159FE5 		ldr	r1, .L790+204
 9022 4f2c FEFFFFEB 		bl	CyU3PDebugPrint
 9023              	.LVL799:
 9024              	.L743:
 9025              	.LBB286:
 9026              	.LBB287:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9027              		.loc 1 2061 0
 9028 4f30 7C159FE5 		ldr	r1, .L790+144
 9029 4f34 0400A0E3 		mov	r0, #4
 9030 4f38 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9031              		.loc 1 2062 0
 9032 4f3c FA0FA0E3 		mov	r0, #1000
 9033 4f40 FEFFFFEB 		bl	_tx_thread_sleep
 9034 4f44 F9FFFFEA 		b	.L743
 9035              	.LVL800:
 9036              	.L777:
 9037              	.LBE287:
 9038              	.LBE286:
 9039              	.LBE288:
 9040              	.LBE293:
 9041              	.LBB294:
 9042              	.LBB276:
2936:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
 9043              		.loc 1 2936 0
 9044 4f48 0400A0E3 		mov	r0, #4
 9045              	.LVL801:
 9046 4f4c A0159FE5 		ldr	r1, .L790+208
 9047 4f50 FEFFFFEB 		bl	CyU3PDebugPrint
 9048              	.LVL802:
 9049              	.L698:
 9050              	.LBB245:
 9051              	.LBB246:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9052              		.loc 1 2061 0
 9053 4f54 58159FE5 		ldr	r1, .L790+144
 9054 4f58 0400A0E3 		mov	r0, #4
 9055 4f5c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9056              		.loc 1 2062 0
 9057 4f60 FA0FA0E3 		mov	r0, #1000
 9058 4f64 FEFFFFEB 		bl	_tx_thread_sleep
 9059 4f68 F9FFFFEA 		b	.L698
 9060              	.LVL803:
 9061              	.L776:
 9062              	.LBE246:
 9063              	.LBE245:
2917:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
 9064              		.loc 1 2917 0
 9065 4f6c 0400A0E3 		mov	r0, #4
 9066              	.LVL804:
 9067 4f70 80159FE5 		ldr	r1, .L790+212
 9068 4f74 0320A0E1 		mov	r2, r3
 9069 4f78 FEFFFFEB 		bl	CyU3PDebugPrint
 9070              	.LVL805:
 9071              	.L696:
 9072              	.LBB247:
 9073              	.LBB248:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9074              		.loc 1 2061 0
 9075 4f7c 30159FE5 		ldr	r1, .L790+144
 9076 4f80 0400A0E3 		mov	r0, #4
 9077 4f84 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9078              		.loc 1 2062 0
 9079 4f88 FA0FA0E3 		mov	r0, #1000
 9080 4f8c FEFFFFEB 		bl	_tx_thread_sleep
 9081 4f90 F9FFFFEA 		b	.L696
 9082              	.LVL806:
 9083              	.L775:
 9084              	.LBE248:
 9085              	.LBE247:
2910:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
 9086              		.loc 1 2910 0
 9087 4f94 0400A0E3 		mov	r0, #4
 9088              	.LVL807:
 9089 4f98 5C159FE5 		ldr	r1, .L790+216
 9090 4f9c FEFFFFEB 		bl	CyU3PDebugPrint
 9091              	.LVL808:
 9092              	.L694:
 9093              	.LBB249:
 9094              	.LBB250:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9095              		.loc 1 2061 0
 9096 4fa0 0C159FE5 		ldr	r1, .L790+144
 9097 4fa4 0400A0E3 		mov	r0, #4
 9098 4fa8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9099              		.loc 1 2062 0
 9100 4fac FA0FA0E3 		mov	r0, #1000
 9101 4fb0 FEFFFFEB 		bl	_tx_thread_sleep
 9102 4fb4 F9FFFFEA 		b	.L694
 9103              	.LVL809:
 9104              	.L774:
 9105              	.LBE250:
 9106              	.LBE249:
2891:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
 9107              		.loc 1 2891 0
 9108 4fb8 0400A0E3 		mov	r0, #4
 9109              	.LVL810:
 9110 4fbc 3C159FE5 		ldr	r1, .L790+220
 9111 4fc0 0320A0E1 		mov	r2, r3
 9112 4fc4 FEFFFFEB 		bl	CyU3PDebugPrint
 9113              	.LVL811:
 9114              	.L692:
 9115              	.LBB251:
 9116              	.LBB252:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9117              		.loc 1 2061 0
 9118 4fc8 E4149FE5 		ldr	r1, .L790+144
 9119 4fcc 0400A0E3 		mov	r0, #4
 9120 4fd0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9121              		.loc 1 2062 0
 9122 4fd4 FA0FA0E3 		mov	r0, #1000
 9123 4fd8 FEFFFFEB 		bl	_tx_thread_sleep
 9124 4fdc F9FFFFEA 		b	.L692
 9125              	.LVL812:
 9126              	.L773:
 9127              	.LBE252:
 9128              	.LBE251:
2882:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
 9129              		.loc 1 2882 0
 9130 4fe0 0400A0E3 		mov	r0, #4
 9131              	.LVL813:
 9132 4fe4 18159FE5 		ldr	r1, .L790+224
 9133 4fe8 FEFFFFEB 		bl	CyU3PDebugPrint
 9134              	.LVL814:
 9135              	.L690:
 9136              	.LBB253:
 9137              	.LBB254:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9138              		.loc 1 2061 0
 9139 4fec C0149FE5 		ldr	r1, .L790+144
 9140 4ff0 0400A0E3 		mov	r0, #4
 9141 4ff4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9142              		.loc 1 2062 0
 9143 4ff8 FA0FA0E3 		mov	r0, #1000
 9144 4ffc FEFFFFEB 		bl	_tx_thread_sleep
 9145 5000 F9FFFFEA 		b	.L690
 9146              	.LVL815:
 9147              	.L772:
 9148              	.LBE254:
 9149              	.LBE253:
2861:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 9150              		.loc 1 2861 0
 9151 5004 0400A0E3 		mov	r0, #4
 9152              	.LVL816:
 9153 5008 F8149FE5 		ldr	r1, .L790+228
 9154 500c FEFFFFEB 		bl	CyU3PDebugPrint
 9155              	.LVL817:
 9156              	.L688:
 9157              	.LBB255:
 9158              	.LBB256:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9159              		.loc 1 2061 0
 9160 5010 9C149FE5 		ldr	r1, .L790+144
 9161 5014 0400A0E3 		mov	r0, #4
 9162 5018 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9163              		.loc 1 2062 0
 9164 501c FA0FA0E3 		mov	r0, #1000
 9165 5020 FEFFFFEB 		bl	_tx_thread_sleep
 9166 5024 F9FFFFEA 		b	.L688
 9167              	.LVL818:
 9168              	.L771:
 9169              	.LBE256:
 9170              	.LBE255:
2837:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 9171              		.loc 1 2837 0
 9172 5028 040080E2 		add	r0, r0, #4
 9173 502c D8149FE5 		ldr	r1, .L790+232
 9174 5030 FEFFFFEB 		bl	CyU3PDebugPrint
 9175              	.LVL819:
 9176              	.L686:
 9177              	.LBB257:
 9178              	.LBB258:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9179              		.loc 1 2061 0
 9180 5034 78149FE5 		ldr	r1, .L790+144
 9181 5038 0400A0E3 		mov	r0, #4
 9182 503c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9183              		.loc 1 2062 0
 9184 5040 FA0FA0E3 		mov	r0, #1000
 9185 5044 FEFFFFEB 		bl	_tx_thread_sleep
 9186 5048 F9FFFFEA 		b	.L686
 9187              	.LVL820:
 9188              	.L770:
 9189              	.LBE258:
 9190              	.LBE257:
2830:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 9191              		.loc 1 2830 0
 9192 504c 0400A0E3 		mov	r0, #4
 9193 5050 B8149FE5 		ldr	r1, .L790+236
 9194 5054 0720A0E1 		mov	r2, r7
 9195 5058 FEFFFFEB 		bl	CyU3PDebugPrint
 9196              	.L684:
 9197              	.LBB259:
 9198              	.LBB260:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9199              		.loc 1 2061 0
 9200 505c 50149FE5 		ldr	r1, .L790+144
 9201 5060 0400A0E3 		mov	r0, #4
 9202 5064 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9203              		.loc 1 2062 0
 9204 5068 FA0FA0E3 		mov	r0, #1000
 9205 506c FEFFFFEB 		bl	_tx_thread_sleep
 9206 5070 F9FFFFEA 		b	.L684
 9207              	.LVL821:
 9208              	.L769:
 9209              	.LBE260:
 9210              	.LBE259:
2809:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 9211              		.loc 1 2809 0
 9212 5074 0400A0E3 		mov	r0, #4
 9213              	.LVL822:
 9214 5078 44149FE5 		ldr	r1, .L790+160
 9215 507c 0320A0E1 		mov	r2, r3
 9216 5080 FEFFFFEB 		bl	CyU3PDebugPrint
 9217              	.LVL823:
 9218              	.L682:
 9219              	.LBB261:
 9220              	.LBB262:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9221              		.loc 1 2061 0
 9222 5084 28149FE5 		ldr	r1, .L790+144
 9223 5088 0400A0E3 		mov	r0, #4
 9224 508c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9225              		.loc 1 2062 0
 9226 5090 FA0FA0E3 		mov	r0, #1000
 9227 5094 FEFFFFEB 		bl	_tx_thread_sleep
 9228 5098 F9FFFFEA 		b	.L682
 9229              	.LVL824:
 9230              	.L768:
 9231              	.LBE262:
 9232              	.LBE261:
2764:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 9233              		.loc 1 2764 0
 9234 509c 0400A0E3 		mov	r0, #4
 9235              	.LVL825:
 9236 50a0 6C149FE5 		ldr	r1, .L790+240
 9237 50a4 FEFFFFEB 		bl	CyU3PDebugPrint
 9238              	.LVL826:
 9239              	.L680:
 9240              	.LBB263:
 9241              	.LBB264:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9242              		.loc 1 2061 0
 9243 50a8 04149FE5 		ldr	r1, .L790+144
 9244 50ac 0400A0E3 		mov	r0, #4
 9245 50b0 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9246              		.loc 1 2062 0
 9247 50b4 FA0FA0E3 		mov	r0, #1000
 9248 50b8 FEFFFFEB 		bl	_tx_thread_sleep
 9249 50bc F9FFFFEA 		b	.L680
 9250              	.LVL827:
 9251              	.L767:
 9252              	.LBE264:
 9253              	.LBE263:
2743:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 9254              		.loc 1 2743 0
 9255 50c0 0400A0E3 		mov	r0, #4
 9256              	.LVL828:
 9257 50c4 4C149FE5 		ldr	r1, .L790+244
 9258 50c8 FEFFFFEB 		bl	CyU3PDebugPrint
 9259              	.LVL829:
 9260              	.L678:
 9261              	.LBB265:
 9262              	.LBB266:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9263              		.loc 1 2061 0
 9264 50cc E0139FE5 		ldr	r1, .L790+144
 9265 50d0 0400A0E3 		mov	r0, #4
 9266 50d4 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9267              		.loc 1 2062 0
 9268 50d8 FA0FA0E3 		mov	r0, #1000
 9269 50dc FEFFFFEB 		bl	_tx_thread_sleep
 9270 50e0 F9FFFFEA 		b	.L678
 9271              	.LVL830:
 9272              	.L766:
 9273              	.LBE266:
 9274              	.LBE265:
2730:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 9275              		.loc 1 2730 0
 9276 50e4 0400A0E3 		mov	r0, #4
 9277              	.LVL831:
 9278 50e8 2C149FE5 		ldr	r1, .L790+248
 9279 50ec FEFFFFEB 		bl	CyU3PDebugPrint
 9280              	.LVL832:
 9281              	.L676:
 9282              	.LBB267:
 9283              	.LBB268:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9284              		.loc 1 2061 0
 9285 50f0 BC139FE5 		ldr	r1, .L790+144
 9286 50f4 0400A0E3 		mov	r0, #4
 9287 50f8 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9288              		.loc 1 2062 0
 9289 50fc FA0FA0E3 		mov	r0, #1000
 9290 5100 FEFFFFEB 		bl	_tx_thread_sleep
 9291 5104 F9FFFFEA 		b	.L676
 9292              	.LVL833:
 9293              	.L764:
 9294              	.LBE268:
 9295              	.LBE267:
2702:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 9296              		.loc 1 2702 0
 9297 5108 0400A0E3 		mov	r0, #4
 9298              	.LVL834:
 9299 510c 0C149FE5 		ldr	r1, .L790+252
 9300 5110 FEFFFFEB 		bl	CyU3PDebugPrint
 9301              	.LVL835:
 9302              	.L672:
 9303              	.LBB269:
 9304              	.LBB270:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9305              		.loc 1 2061 0
 9306 5114 98139FE5 		ldr	r1, .L790+144
 9307 5118 0400A0E3 		mov	r0, #4
 9308 511c FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9309              		.loc 1 2062 0
 9310 5120 FA0FA0E3 		mov	r0, #1000
 9311 5124 FEFFFFEB 		bl	_tx_thread_sleep
 9312 5128 F9FFFFEA 		b	.L672
 9313              	.LVL836:
 9314              	.L763:
 9315              	.LBE270:
 9316              	.LBE269:
2689:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 9317              		.loc 1 2689 0
 9318 512c 0400A0E3 		mov	r0, #4
 9319              	.LVL837:
 9320 5130 EC139FE5 		ldr	r1, .L790+256
 9321 5134 FEFFFFEB 		bl	CyU3PDebugPrint
 9322              	.LVL838:
 9323              	.L670:
 9324              	.LBB271:
 9325              	.LBB272:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9326              		.loc 1 2061 0
 9327 5138 74139FE5 		ldr	r1, .L790+144
 9328 513c 0400A0E3 		mov	r0, #4
 9329 5140 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9330              		.loc 1 2062 0
 9331 5144 FA0FA0E3 		mov	r0, #1000
 9332 5148 FEFFFFEB 		bl	_tx_thread_sleep
 9333 514c F9FFFFEA 		b	.L670
 9334              	.LVL839:
 9335              	.L765:
 9336              	.LBE272:
 9337              	.LBE271:
2716:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 9338              		.loc 1 2716 0
 9339 5150 0400A0E3 		mov	r0, #4
 9340              	.LVL840:
 9341 5154 CC139FE5 		ldr	r1, .L790+260
 9342 5158 FEFFFFEB 		bl	CyU3PDebugPrint
 9343              	.LVL841:
 9344              	.L674:
 9345              	.LBB273:
 9346              	.LBB274:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9347              		.loc 1 2061 0
 9348 515c 50139FE5 		ldr	r1, .L790+144
 9349 5160 0400A0E3 		mov	r0, #4
 9350 5164 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9351              		.loc 1 2062 0
 9352 5168 FA0FA0E3 		mov	r0, #1000
 9353 516c FEFFFFEB 		bl	_tx_thread_sleep
 9354 5170 F9FFFFEA 		b	.L674
 9355              	.LVL842:
 9356              	.L780:
 9357              	.LBE274:
 9358              	.LBE273:
 9359              	.LBE276:
 9360              	.LBE294:
3153:../uvc.c      ****             	debugData[0][0]++;
 9361              		.loc 1 3153 0
 9362 5174 2890D5E5 		ldrb	r9, [r5, #40]	@ zero_extendqisi2
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 9363              		.loc 1 3154 0
 9364 5178 03A0E0E1 		mvn	sl, r3
 9365 517c 7DC00AE2 		and	ip, sl, #125
3153:../uvc.c      ****             	debugData[0][0]++;
 9366              		.loc 1 3153 0
 9367 5180 01E089E2 		add	lr, r9, #1
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 9368              		.loc 1 3154 0
 9369 5184 0C30E0E1 		mvn	r3, ip
3158:../uvc.c      ****                 prodCount = 0;
 9370              		.loc 1 3158 0
 9371 5188 B06CC5E1 		strh	r6, [r5, #192]	@ movhi
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9372              		.loc 1 3173 0
 9373 518c 0010E0E3 		mvn	r1, #0
3159:../uvc.c      ****                 consCount = 0;
 9374              		.loc 1 3159 0
 9375 5190 B26CC5E1 		strh	r6, [r5, #194]	@ movhi
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9376              		.loc 1 3173 0
 9377 5194 E8029FE5 		ldr	r0, .L790+96
3153:../uvc.c      ****             	debugData[0][0]++;
 9378              		.loc 1 3153 0
 9379 5198 28E0C5E5 		strb	lr, [r5, #40]
3154:../uvc.c      ****             	debugData[0][1] = debugData[0][1]|0x82;
 9380              		.loc 1 3154 0
 9381 519c 2930C5E5 		strb	r3, [r5, #41]
3155:../uvc.c      ****             	fb=0;
 9382              		.loc 1 3155 0
 9383 51a0 B46BC5E1 		strh	r6, [r5, #180]	@ movhi
3156:../uvc.c      ****             	pb=0;
 9384              		.loc 1 3156 0
 9385 51a4 B66BC5E1 		strh	r6, [r5, #182]	@ movhi
3157:../uvc.c      ****             	pbc=0;
 9386              		.loc 1 3157 0
 9387 51a8 B86BC5E1 		strh	r6, [r5, #184]	@ movhi
3160:../uvc.c      ****                 hitFV     = CyFalse;
 9388              		.loc 1 3160 0
 9389 51ac BC6085E5 		str	r6, [r5, #188]
3173:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 9390              		.loc 1 3173 0
 9391 51b0 FEFFFFEB 		bl	_txe_mutex_get
3174:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 9392              		.loc 1 3174 0
 9393 51b4 8104D7E5 		ldrb	r0, [r7, #1153]	@ zero_extendqisi2
 9394 51b8 011020E2 		eor	r1, r0, #1
 9395 51bc 8114C7E5 		strb	r1, [r7, #1153]
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9396              		.loc 1 3176 0
 9397 51c0 BA20D5E5 		ldrb	r2, [r5, #186]	@ zero_extendqisi2
 9398 51c4 F00052E3 		cmp	r2, #240
 9399 51c8 1900000A 		beq	.L786
 9400              	.L709:
3184:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
 9401              		.loc 1 3184 0
 9402 51cc BA20D4E5 		ldrb	r2, [r4, #186]	@ zero_extendqisi2
 9403 51d0 FF0052E3 		cmp	r2, #255
 9404 51d4 3800000A 		beq	.L787
3196:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
 9405              		.loc 1 3196 0
 9406 51d8 BA90D5E5 		ldrb	r9, [r5, #186]	@ zero_extendqisi2
 9407 51dc AA0059E3 		cmp	r9, #170
 9408 51e0 2700000A 		beq	.L788
 9409              	.L710:
3234:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
 9410              		.loc 1 3234 0
 9411 51e4 98029FE5 		ldr	r0, .L790+96
 9412 51e8 FEFFFFEB 		bl	_txe_mutex_put
3236:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 9413              		.loc 1 3236 0
 9414 51ec A0029FE5 		ldr	r0, .L790+112
 9415 51f0 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 9416              	.LVL843:
3237:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9417              		.loc 1 3237 0
 9418 51f4 002050E2 		subs	r2, r0, #0
 9419 51f8 1800001A 		bne	.L789
3244:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 9420              		.loc 1 3244 0
 9421 51fc 0210A0E1 		mov	r1, r2
 9422 5200 8C029FE5 		ldr	r0, .L790+112
 9423              	.LVL844:
 9424 5204 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 9425              	.LVL845:
3245:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 9426              		.loc 1 3245 0
 9427 5208 002050E2 		subs	r2, r0, #0
 9428 520c 2CFFFF0A 		beq	.L738
3247:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 9429              		.loc 1 3247 0
 9430 5210 0400A0E3 		mov	r0, #4
 9431              	.LVL846:
 9432 5214 10139FE5 		ldr	r1, .L790+264
 9433 5218 FEFFFFEB 		bl	CyU3PDebugPrint
 9434              	.LVL847:
 9435              	.L729:
 9436              	.LBB295:
 9437              	.LBB296:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9438              		.loc 1 2061 0
 9439 521c 90129FE5 		ldr	r1, .L790+144
 9440 5220 0400A0E3 		mov	r0, #4
 9441 5224 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9442              		.loc 1 2062 0
 9443 5228 FA0FA0E3 		mov	r0, #1000
 9444 522c FEFFFFEB 		bl	_tx_thread_sleep
 9445 5230 F9FFFFEA 		b	.L729
 9446              	.LVL848:
 9447              	.L786:
 9448              	.LBE296:
 9449              	.LBE295:
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9450              		.loc 1 3176 0 discriminator 1
 9451 5234 FC019FE5 		ldr	r0, .L790+20
 9452 5238 8010A0E3 		mov	r1, #128
 9453 523c 0320A0E3 		mov	r2, #3
 9454 5240 CC308DE2 		add	r3, sp, #204
 9455 5244 00608DE5 		str	r6, [sp, #0]
 9456 5248 FEFFFFEB 		bl	_txe_event_flags_get
 9457 524c 000050E3 		cmp	r0, #0
3181:../uvc.c      ****                 		stiflag = 0xFF;
 9458              		.loc 1 3181 0 discriminator 1
 9459 5250 BA80C505 		streqb	r8, [r5, #186]
3182:../uvc.c      ****                 		IMcount = 0;
 9460              		.loc 1 3182 0 discriminator 1
 9461 5254 A161C505 		streqb	r6, [r5, #417]
3176:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
 9462              		.loc 1 3176 0 discriminator 1
 9463 5258 E1FFFF0A 		beq	.L710
 9464 525c DAFFFFEA 		b	.L709
 9465              	.LVL849:
 9466              	.L789:
3239:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 9467              		.loc 1 3239 0
 9468 5260 0400A0E3 		mov	r0, #4
 9469              	.LVL850:
 9470 5264 C4129FE5 		ldr	r1, .L790+268
 9471 5268 FEFFFFEB 		bl	CyU3PDebugPrint
 9472              	.LVL851:
 9473              	.L727:
 9474              	.LBB297:
 9475              	.LBB298:
2061:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 9476              		.loc 1 2061 0
 9477 526c 40129FE5 		ldr	r1, .L790+144
 9478 5270 0400A0E3 		mov	r0, #4
 9479 5274 FEFFFFEB 		bl	CyU3PDebugPrint
2062:../uvc.c      ****         CyU3PThreadSleep (1000);
 9480              		.loc 1 2062 0
 9481 5278 FA0FA0E3 		mov	r0, #1000
 9482 527c FEFFFFEB 		bl	_tx_thread_sleep
 9483 5280 F9FFFFEA 		b	.L727
 9484              	.LVL852:
 9485              	.L788:
 9486              	.LBE298:
 9487              	.LBE297:
3202:../uvc.c      ****                 	if(IMcount++ >= 0x3)
 9488              		.loc 1 3202 0
 9489 5284 A121D5E5 		ldrb	r2, [r5, #417]	@ zero_extendqisi2
 9490 5288 01A082E2 		add	sl, r2, #1
 9491 528c 020052E3 		cmp	r2, #2
 9492 5290 A1A1C5E5 		strb	sl, [r5, #417]
 9493 5294 D2FFFF9A 		bls	.L710
3204:../uvc.c      ****                     switch (setRes)
 9494              		.loc 1 3204 0
 9495 5298 7D01D5E5 		ldrb	r0, [r5, #381]	@ zero_extendqisi2
 9496 529c 011040E2 		sub	r1, r0, #1
 9497 52a0 030051E3 		cmp	r1, #3
 9498 52a4 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 9499 52a8 230000EA 		b	.L712
 9500              	.L717:
 9501 52ac 9C530000 		.word	.L713
 9502 52b0 E0530000 		.word	.L714
 9503 52b4 48530000 		.word	.L715
 9504 52b8 EC520000 		.word	.L716
 9505              	.L787:
3186:../uvc.c      ****                  		if(IMcount++ >= 0x3){
 9506              		.loc 1 3186 0
 9507 52bc A101D5E5 		ldrb	r0, [r5, #417]	@ zero_extendqisi2
 9508 52c0 011080E2 		add	r1, r0, #1
 9509 52c4 020050E3 		cmp	r0, #2
 9510 52c8 A111C5E5 		strb	r1, [r5, #417]
 9511 52cc C4FFFF9A 		bls	.L710
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9512              		.loc 1 3187 0
 9513 52d0 81C4D7E5 		ldrb	ip, [r7, #1153]	@ zero_extendqisi2
3188:../uvc.c      ****                 		stiflag = 0x0F;
 9514              		.loc 1 3188 0
 9515 52d4 0F30A0E3 		mov	r3, #15
3187:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 9516              		.loc 1 3187 0
 9517 52d8 20E08CE3 		orr	lr, ip, #32
 9518 52dc 81E4C7E5 		strb	lr, [r7, #1153]
3189:../uvc.c      ****                 		IMcount = 0;
 9519              		.loc 1 3189 0
 9520 52e0 A161C5E5 		strb	r6, [r5, #417]
3188:../uvc.c      ****                 		stiflag = 0x0F;
 9521              		.loc 1 3188 0
 9522 52e4 BA30C5E5 		strb	r3, [r5, #186]
 9523 52e8 BDFFFFEA 		b	.L710
 9524              	.L716:
3222:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
 9525              		.loc 1 3222 0
 9526 52ec D80094E5 		ldr	r0, [r4, #216]
 9527 52f0 8DC4D7E5 		ldrb	ip, [r7, #1165]	@ zero_extendqisi2
 9528 52f4 000050E3 		cmp	r0, #0
 9529 52f8 F400A003 		moveq	r0, #244
 9530 52fc 7400A013 		movne	r0, #116
 9531 5300 0C2080E1 		orr	r2, r0, ip
 9532 5304 3010A0E3 		mov	r1, #48
 9533 5308 5230A0E3 		mov	r3, #82
 9534 530c 0100A0E3 		mov	r0, #1
 9535 5310 FEFFFFEB 		bl	SensorSetIrisControl
3224:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
 9536              		.loc 1 3224 0
 9537 5314 D82094E5 		ldr	r2, [r4, #216]
 9538 5318 8DA4D7E5 		ldrb	sl, [r7, #1165]	@ zero_extendqisi2
 9539 531c 000052E3 		cmp	r2, #0
 9540 5320 F420A003 		moveq	r2, #244
 9541 5324 7420A013 		movne	r2, #116
 9542 5328 D83094E5 		ldr	r3, [r4, #216]
 9543 532c 0400A0E3 		mov	r0, #4
 9544 5330 FC119FE5 		ldr	r1, .L790+272
 9545 5334 0A2082E1 		orr	r2, r2, sl
 9546 5338 FEFFFFEB 		bl	CyU3PDebugPrint
 9547              	.L712:
3229:../uvc.c      ****                     IMcount = 0;
 9548              		.loc 1 3229 0
 9549 533c A161C4E5 		strb	r6, [r4, #417]
3231:../uvc.c      ****                 	stiflag = 0x0;
 9550              		.loc 1 3231 0
 9551 5340 BA60C4E5 		strb	r6, [r4, #186]
 9552 5344 A6FFFFEA 		b	.L710
 9553              	.L715:
3217:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
 9554              		.loc 1 3217 0
 9555 5348 D8E094E5 		ldr	lr, [r4, #216]
 9556 534c 8D34D7E5 		ldrb	r3, [r7, #1165]	@ zero_extendqisi2
 9557 5350 00005EE3 		cmp	lr, #0
 9558 5354 C4E0A003 		moveq	lr, #196
 9559 5358 44E0A013 		movne	lr, #68
 9560 535c 03208EE1 		orr	r2, lr, r3
 9561 5360 3010A0E3 		mov	r1, #48
 9562 5364 5230A0E3 		mov	r3, #82
 9563 5368 0100A0E3 		mov	r0, #1
 9564 536c FEFFFFEB 		bl	SensorSetIrisControl
3219:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
 9565              		.loc 1 3219 0
 9566 5370 D89094E5 		ldr	r9, [r4, #216]
 9567 5374 8DC4D7E5 		ldrb	ip, [r7, #1165]	@ zero_extendqisi2
 9568 5378 000059E3 		cmp	r9, #0
 9569 537c C490A003 		moveq	r9, #196
 9570 5380 4490A013 		movne	r9, #68
 9571 5384 D83094E5 		ldr	r3, [r4, #216]
 9572 5388 A4119FE5 		ldr	r1, .L790+272
 9573 538c 0C2089E1 		orr	r2, r9, ip
 9574 5390 0400A0E3 		mov	r0, #4
 9575 5394 FEFFFFEB 		bl	CyU3PDebugPrint
3220:../uvc.c      ****                  		break;
 9576              		.loc 1 3220 0
 9577 5398 E7FFFFEA 		b	.L712
 9578              	.L713:
3207:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
 9579              		.loc 1 3207 0
 9580 539c D82094E5 		ldr	r2, [r4, #216]
 9581 53a0 3010A0E3 		mov	r1, #48
 9582 53a4 000052E3 		cmp	r2, #0
 9583 53a8 E420A003 		moveq	r2, #228
 9584 53ac 6420A013 		movne	r2, #100
 9585 53b0 5230A0E3 		mov	r3, #82
 9586 53b4 0100A0E3 		mov	r0, #1
 9587 53b8 FEFFFFEB 		bl	SensorSetIrisControl
3209:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
 9588              		.loc 1 3209 0
 9589 53bc D82094E5 		ldr	r2, [r4, #216]
 9590 53c0 6C119FE5 		ldr	r1, .L790+272
 9591 53c4 000052E3 		cmp	r2, #0
 9592 53c8 D83094E5 		ldr	r3, [r4, #216]
 9593 53cc E420A003 		moveq	r2, #228
 9594 53d0 6420A013 		movne	r2, #100
 9595 53d4 0400A0E3 		mov	r0, #4
 9596 53d8 FEFFFFEB 		bl	CyU3PDebugPrint
3210:../uvc.c      ****                  		break;
 9597              		.loc 1 3210 0
 9598 53dc D6FFFFEA 		b	.L712
 9599              	.L714:
3212:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
 9600              		.loc 1 3212 0
 9601 53e0 D82094E5 		ldr	r2, [r4, #216]
 9602 53e4 3010A0E3 		mov	r1, #48
 9603 53e8 000052E3 		cmp	r2, #0
 9604 53ec D420A003 		moveq	r2, #212
 9605 53f0 5420A013 		movne	r2, #84
 9606 53f4 5230A0E3 		mov	r3, #82
 9607 53f8 0100A0E3 		mov	r0, #1
 9608 53fc FEFFFFEB 		bl	SensorSetIrisControl
3214:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
 9609              		.loc 1 3214 0
 9610 5400 D82094E5 		ldr	r2, [r4, #216]
 9611 5404 28119FE5 		ldr	r1, .L790+272
 9612 5408 000052E3 		cmp	r2, #0
 9613 540c D83094E5 		ldr	r3, [r4, #216]
 9614 5410 D420A003 		moveq	r2, #212
 9615 5414 5420A013 		movne	r2, #84
 9616 5418 0400A0E3 		mov	r0, #4
 9617 541c FEFFFFEB 		bl	CyU3PDebugPrint
3215:../uvc.c      ****                  		break;
 9618              		.loc 1 3215 0
 9619 5420 C5FFFFEA 		b	.L712
 9620              	.L791:
 9621              		.align	2
 9622              	.L790:
 9623 5424 B8090000 		.word	.LC56
 9624 5428 00C20100 		.word	115200
 9625 542c D8090000 		.word	.LC57
 9626 5430 A0860100 		.word	100000
 9627 5434 F4090000 		.word	.LC58
 9628 5438 00000000 		.word	.LANCHOR0
 9629 543c 00000000 		.word	CyFxGpifCB
 9630 5440 88130000 		.word	5000
 9631 5444 00000000 		.word	CyFxUVCApplnUSBSetupCB
 9632 5448 00000000 		.word	CyFxUVCApplnUSBEventCB
 9633 544c 00000000 		.word	CyFxUSBDeviceDscr
 9634 5450 00000000 		.word	CyFxUSBDeviceDscrSS
 9635 5454 00000000 		.word	CyFxUSBDeviceQualDscr
 9636 5458 00000000 		.word	CyFxUSBBOSDscr
 9637 545c 00000000 		.word	CyFxUSBHSConfigDscr
 9638 5460 00000000 		.word	CyFxUSBFSConfigDscr
 9639 5464 00000000 		.word	CyFxUSBSSConfigDscr
 9640 5468 00000000 		.word	CyFxUSBStringLangIDDscr
 9641 546c 00000000 		.word	CyFxUSBManufactureDscr
 9642 5470 00000000 		.word	CyFxUSBProductDscr
 9643 5474 02030000 		.word	770
 9644 5478 013F0000 		.word	16129
 9645 547c 00000000 		.word	glChHandleInterStat
 9646 5480 00000000 		.word	glInterStaBuffer
 9647 5484 00000000 		.word	imgHdMux
 9648 5488 01010000 		.word	257
 9649 548c 03030000 		.word	771
 9650 5490 00000000 		.word	CyFxUvcApplnDmaCallback
 9651 5494 00000000 		.word	glChHandleUVCStream
 9652 5498 04040000 		.word	1028
 9653 549c 00000000 		.word	CyFxUvcAppDebugCallback
 9654 54a0 00000000 		.word	glDebugCmdChannel
 9655 54a4 00000000 		.word	glDebugRspChannel
 9656 54a8 00000000 		.word	glDebugRspBuffer
 9657 54ac 00000000 		.word	.LANCHOR1
 9658 54b0 100A0000 		.word	.LC59
 9659 54b4 4C020000 		.word	.LC14
 9660 54b8 600A0000 		.word	.LC61
 9661 54bc 3C0A0000 		.word	.LC60
 9662 54c0 880A0000 		.word	.LC62
 9663 54c4 E00B0000 		.word	.LC69
 9664 54c8 A80E0000 		.word	.LC83
 9665 54cc C00E0000 		.word	.LC84
 9666 54d0 FC0D0000 		.word	.LC79
 9667 54d4 CC0D0000 		.word	.LC78
 9668 54d8 200F0000 		.word	.LC87
 9669 54dc 3C000000 		.word	.LANCHOR2+60
 9670 54e0 680F0000 		.word	.LC89
 9671 54e4 100F0000 		.word	.LC86
 9672 54e8 20000000 		.word	.LANCHOR2+32
 9673 54ec DC0E0000 		.word	.LC85
 9674 54f0 300F0000 		.word	.LC88
 9675 54f4 940D0000 		.word	.LC77
 9676 54f8 640D0000 		.word	.LC76
 9677 54fc 2C0D0000 		.word	.LC75
 9678 5500 F40C0000 		.word	.LC74
 9679 5504 BC0C0000 		.word	.LC73
 9680 5508 8C0C0000 		.word	.LC72
 9681 550c 540C0000 		.word	.LC71
 9682 5510 140C0000 		.word	.LC70
 9683 5514 B00B0000 		.word	.LC68
 9684 5518 800B0000 		.word	.LC67
 9685 551c 480B0000 		.word	.LC66
 9686 5520 E00A0000 		.word	.LC64
 9687 5524 B40A0000 		.word	.LC63
 9688 5528 140B0000 		.word	.LC65
 9689 552c 740E0000 		.word	.LC82
 9690 5530 480E0000 		.word	.LC81
 9691 5534 240E0000 		.word	.LC80
 9692              		.cfi_endproc
 9693              	.LFE20:
 9695              		.align	2
 9696              		.global	CyFxApplicationDefine
 9698              	CyFxApplicationDefine:
 9699              	.LFB28:
4753:../uvc.c      **** }
4754:../uvc.c      **** 
4755:../uvc.c      **** 
4756:../uvc.c      **** /*
4757:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4758:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4759:../uvc.c      ****  */
4760:../uvc.c      **** void
4761:../uvc.c      **** CyFxApplicationDefine (
4762:../uvc.c      ****         void)
4763:../uvc.c      **** {
 9700              		.loc 1 4763 0
 9701              		.cfi_startproc
 9702              		@ args = 0, pretend = 0, frame = 32
 9703              		@ frame_needed = 0, uses_anonymous_args = 0
 9704              	.LVL853:
 9705 5538 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 9706              	.LCFI28:
 9707              		.cfi_def_cfa_offset 32
4764:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4765:../uvc.c      ****     uint32_t retThrdCreate;
4766:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4767:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4768:../uvc.c      **** 
4769:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4770:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9708              		.loc 1 4770 0
 9709 553c 010AA0E3 		mov	r0, #4096
4763:../uvc.c      **** {
 9710              		.loc 1 4763 0
 9711 5540 40D04DE2 		sub	sp, sp, #64
 9712              	.LCFI29:
 9713              		.cfi_def_cfa_offset 96
 9714              		.loc 1 4770 0
 9715              		.cfi_offset 14, -4
 9716              		.cfi_offset 10, -8
 9717              		.cfi_offset 9, -12
 9718              		.cfi_offset 8, -16
 9719              		.cfi_offset 7, -20
 9720              		.cfi_offset 6, -24
 9721              		.cfi_offset 5, -28
 9722              		.cfi_offset 4, -32
 9723 5544 FEFFFFEB 		bl	CyU3PMemAlloc
 9724 5548 0080A0E1 		mov	r8, r0
 9725              	.LVL854:
4771:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9726              		.loc 1 4771 0
 9727 554c 010AA0E3 		mov	r0, #4096
 9728              	.LVL855:
 9729 5550 FEFFFFEB 		bl	CyU3PMemAlloc
 9730 5554 00A0A0E1 		mov	sl, r0
 9731              	.LVL856:
4772:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9732              		.loc 1 4772 0
 9733 5558 010AA0E3 		mov	r0, #4096
 9734              	.LVL857:
 9735 555c FEFFFFEB 		bl	CyU3PMemAlloc
4773:../uvc.c      **** 
4774:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 9736              		.loc 1 4774 0
 9737 5560 000058E3 		cmp	r8, #0
 9738 5564 00005A13 		cmpne	sl, #0
 9739 5568 0070A013 		movne	r7, #0
 9740 556c 0170A003 		moveq	r7, #1
4772:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 9741              		.loc 1 4772 0
 9742 5570 0090A0E1 		mov	r9, r0
 9743              	.LVL858:
 9744              		.loc 1 4774 0
 9745 5574 0000001A 		bne	.L796
 9746              	.LVL859:
 9747              	.L793:
 9748              	.L795:
 9749 5578 FEFFFFEA 		b	.L795
 9750              	.L796:
 9751              		.loc 1 4774 0 is_stmt 0 discriminator 1
 9752 557c 000050E3 		cmp	r0, #0
 9753 5580 FCFFFF0A 		beq	.L793
 9754              	.LVL860:
4775:../uvc.c      ****         goto fatalErrorHandler;
4776:../uvc.c      **** 
4777:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4778:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4779:../uvc.c      ****     char *staName = "I2CstaQue";
4780:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9755              		.loc 1 4780 0 is_stmt 1
 9756 5584 04619FE5 		ldr	r6, .L797
 9757 5588 20408DE2 		add	r4, sp, #32
 9758 558c 0400A0E1 		mov	r0, r4
 9759 5590 4010A0E3 		mov	r1, #64
 9760 5594 F8209FE5 		ldr	r2, .L797+4
 9761 5598 0730A0E1 		mov	r3, r7
 9762 559c 00608DE5 		str	r6, [sp, #0]
 9763 55a0 FEFFFFEB 		bl	cmdbufCreate
 9764 55a4 04E0A0E1 		mov	lr, r4
 9765 55a8 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 9766 55ac E4C09FE5 		ldr	ip, .L797+8
4781:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4782:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4783:../uvc.c      **** 
4784:../uvc.c      **** 	/****** initialize command descriptor ***********/
4785:../uvc.c      **** 	cmdquInit(cmdQuptr);
4786:../uvc.c      **** 	cmdquInit(statQuptr);
4787:../uvc.c      **** 
4788:../uvc.c      ****     /* Create the UVC application thread. */
4789:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 9767              		.loc 1 4789 0
 9768 55b0 0840A0E3 		mov	r4, #8
4780:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9769              		.loc 1 4780 0
 9770 55b4 0C50A0E1 		mov	r5, ip
 9771 55b8 0F00A5E8 		stmia	r5!, {r0, r1, r2, r3}
 9772 55bc 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 9773              		.loc 1 4789 0
 9774 55c0 0160A0E3 		mov	r6, #1
4780:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 9775              		.loc 1 4780 0
 9776 55c4 0F0085E8 		stmia	r5, {r0, r1, r2, r3}
4785:../uvc.c      **** 	cmdquInit(cmdQuptr);
 9777              		.loc 1 4785 0
 9778 55c8 0C00A0E1 		mov	r0, ip
 9779 55cc FEFFFFEB 		bl	cmdquInit
4786:../uvc.c      **** 	cmdquInit(statQuptr);
 9780              		.loc 1 4786 0
 9781 55d0 C4009FE5 		ldr	r0, .L797+12
 9782 55d4 FEFFFFEB 		bl	cmdquInit
 9783              		.loc 1 4789 0
 9784 55d8 A850A0E3 		mov	r5, #168
 9785 55dc 01CAA0E3 		mov	ip, #4096
 9786 55e0 B8009FE5 		ldr	r0, .L797+16
 9787 55e4 B8109FE5 		ldr	r1, .L797+20
 9788 55e8 B8209FE5 		ldr	r2, .L797+24
 9789 55ec 0730A0E1 		mov	r3, r7
 9790 55f0 00118DE8 		stmia	sp, {r8, ip}	@ phole stm
 9791 55f4 08408DE5 		str	r4, [sp, #8]
 9792 55f8 0C408DE5 		str	r4, [sp, #12]
 9793 55fc 10708DE5 		str	r7, [sp, #16]
 9794 5600 14608DE5 		str	r6, [sp, #20]
 9795 5604 18508DE5 		str	r5, [sp, #24]
 9796 5608 FEFFFFEB 		bl	_txe_thread_create
 9797              	.LVL861:
4790:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4791:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4792:../uvc.c      ****             0,                                          /* No input parameter to thread */
4793:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4794:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4795:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4796:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4797:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4798:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4799:../uvc.c      ****             );
4800:../uvc.c      ****     if (retThrdCreate != 0)
 9798              		.loc 1 4800 0
 9799 560c 00C050E2 		subs	ip, r0, #0
 9800 5610 D8FFFF1A 		bne	.L793
4801:../uvc.c      ****     {
4802:../uvc.c      ****         goto fatalErrorHandler;
4803:../uvc.c      ****     }
4804:../uvc.c      **** 
4805:../uvc.c      ****     /* Create the control request handling thread. */
4806:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 9801              		.loc 1 4806 0
 9802 5614 0C30A0E1 		mov	r3, ip
 9803 5618 027BA0E3 		mov	r7, #2048
 9804 561c 88009FE5 		ldr	r0, .L797+28
 9805              	.LVL862:
 9806 5620 88109FE5 		ldr	r1, .L797+32
 9807 5624 88209FE5 		ldr	r2, .L797+36
 9808 5628 10C08DE5 		str	ip, [sp, #16]
 9809 562c 00A08DE5 		str	sl, [sp, #0]
 9810 5630 04708DE5 		str	r7, [sp, #4]
 9811 5634 08408DE5 		str	r4, [sp, #8]
 9812 5638 0C408DE5 		str	r4, [sp, #12]
 9813 563c 14608DE5 		str	r6, [sp, #20]
 9814 5640 18508DE5 		str	r5, [sp, #24]
 9815 5644 FEFFFFEB 		bl	_txe_thread_create
 9816              	.LVL863:
4807:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4808:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4809:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4810:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4811:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4812:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4813:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4814:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4815:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4816:../uvc.c      ****             );
4817:../uvc.c      ****     if (retThrdCreate != 0)
 9817              		.loc 1 4817 0
 9818 5648 00C050E2 		subs	ip, r0, #0
 9819 564c C9FFFF1A 		bne	.L793
4818:../uvc.c      ****     {
4819:../uvc.c      ****         goto fatalErrorHandler;
4820:../uvc.c      ****     }
4821:../uvc.c      **** #if 1
4822:../uvc.c      ****     /* Create the I2C control command handling thread. */
4823:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 9820              		.loc 1 4823 0
 9821 5650 60009FE5 		ldr	r0, .L797+40
 9822              	.LVL864:
 9823 5654 60109FE5 		ldr	r1, .L797+44
 9824 5658 60209FE5 		ldr	r2, .L797+48
 9825 565c 0C30A0E1 		mov	r3, ip
 9826 5660 00908DE5 		str	r9, [sp, #0]
 9827 5664 04708DE5 		str	r7, [sp, #4]
 9828 5668 08408DE5 		str	r4, [sp, #8]
 9829 566c 0C408DE5 		str	r4, [sp, #12]
 9830 5670 10C08DE5 		str	ip, [sp, #16]
 9831 5674 14608DE5 		str	r6, [sp, #20]
 9832 5678 18508DE5 		str	r5, [sp, #24]
 9833 567c FEFFFFEB 		bl	_txe_thread_create
 9834              	.LVL865:
4824:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4825:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4826:../uvc.c      ****             0,                                          /* No input parameter to thread */
4827:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4828:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4829:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4830:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4831:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4832:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4833:../uvc.c      ****             );
4834:../uvc.c      ****     if (retThrdCreate != 0)
 9835              		.loc 1 4834 0
 9836 5680 000050E3 		cmp	r0, #0
 9837 5684 BBFFFF1A 		bne	.L793
4835:../uvc.c      ****     {
4836:../uvc.c      ****         goto fatalErrorHandler;
4837:../uvc.c      ****     }
4838:../uvc.c      **** #endif
4839:../uvc.c      **** 
4840:../uvc.c      ****     return;
4841:../uvc.c      **** 
4842:../uvc.c      **** fatalErrorHandler:
4843:../uvc.c      ****     /* Add custom recovery or debug actions here */
4844:../uvc.c      ****     /* Loop indefinitely */
4845:../uvc.c      ****     while (1);
4846:../uvc.c      **** }
 9838              		.loc 1 4846 0
 9839 5688 40D08DE2 		add	sp, sp, #64
 9840 568c F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 9841              	.L798:
 9842              		.align	2
 9843              	.L797:
 9844 5690 00000000 		.word	cmdQuMux
 9845 5694 A00F0000 		.word	.LC90
 9846 5698 00000000 		.word	cmdQu
 9847 569c 00000000 		.word	statQu
 9848 56a0 A4010000 		.word	.LANCHOR0+420
 9849 56a4 AC0F0000 		.word	.LC91
 9850 56a8 00000000 		.word	UVCAppThread_Entry
 9851 56ac 4C020000 		.word	.LANCHOR0+588
 9852 56b0 C00F0000 		.word	.LC92
 9853 56b4 00000000 		.word	UVCAppEP0Thread_Entry
 9854 56b8 F4020000 		.word	.LANCHOR0+756
 9855 56bc D80F0000 		.word	.LC93
 9856 56c0 00000000 		.word	I2cAppThread_Entry
 9857              		.cfi_endproc
 9858              	.LFE28:
 9860              		.align	2
 9861              		.global	main
 9863              	main:
 9864              	.LFB29:
4847:../uvc.c      **** 
4848:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4849:../uvc.c      ****  * the ThreadX RTOS here.
4850:../uvc.c      ****  */
4851:../uvc.c      **** int
4852:../uvc.c      **** main (
4853:../uvc.c      ****         void)
4854:../uvc.c      **** {
 9865              		.loc 1 4854 0
 9866              		.cfi_startproc
 9867              		@ args = 0, pretend = 0, frame = 56
 9868              		@ frame_needed = 0, uses_anonymous_args = 0
 9869 56c4 30402DE9 		stmfd	sp!, {r4, r5, lr}
 9870              	.LCFI30:
 9871              		.cfi_def_cfa_offset 12
4855:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4856:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4857:../uvc.c      **** 
4858:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4859:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4860:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
4861:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4862:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4863:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9872              		.loc 1 4863 0
 9873 56c8 0010A0E3 		mov	r1, #0
4854:../uvc.c      **** {
 9874              		.loc 1 4854 0
 9875 56cc 3CD04DE2 		sub	sp, sp, #60
 9876              	.LCFI31:
 9877              		.cfi_def_cfa_offset 72
4860:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9878              		.loc 1 4860 0
 9879 56d0 0220A0E3 		mov	r2, #2
4864:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9880              		.loc 1 4864 0
 9881 56d4 033081E2 		add	r3, r1, #3
4859:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9882              		.loc 1 4859 0
 9883 56d8 0150A0E3 		mov	r5, #1
 9884              		.cfi_offset 14, -4
 9885              		.cfi_offset 5, -8
 9886              		.cfi_offset 4, -12
4865:../uvc.c      **** 
4866:../uvc.c      ****     /* Initialize the device */
4867:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 9887              		.loc 1 4867 0
 9888 56dc 28008DE2 		add	r0, sp, #40
4859:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 9889              		.loc 1 4859 0
 9890 56e0 28508DE5 		str	r5, [sp, #40]
4860:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 9891              		.loc 1 4860 0
 9892 56e4 2C20CDE5 		strb	r2, [sp, #44]
4861:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 9893              		.loc 1 4861 0
 9894 56e8 2D20CDE5 		strb	r2, [sp, #45]
4862:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 9895              		.loc 1 4862 0
 9896 56ec 2E20CDE5 		strb	r2, [sp, #46]
4863:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 9897              		.loc 1 4863 0
 9898 56f0 30108DE5 		str	r1, [sp, #48]
4864:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 9899              		.loc 1 4864 0
 9900 56f4 3430CDE5 		strb	r3, [sp, #52]
 9901              		.loc 1 4867 0
 9902 56f8 FEFFFFEB 		bl	CyU3PDeviceInit
 9903              	.LVL866:
4868:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9904              		.loc 1 4868 0
 9905 56fc 004050E2 		subs	r4, r0, #0
 9906 5700 0000000A 		beq	.L802
 9907              	.L800:
 9908              	.L801:
 9909 5704 FEFFFFEA 		b	.L801
 9910              	.L802:
4869:../uvc.c      ****     {
4870:../uvc.c      ****         goto handle_fatal_error;
4871:../uvc.c      ****     }
4872:../uvc.c      **** 
4873:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4874:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 9911              		.loc 1 4874 0
 9912 5708 0410A0E1 		mov	r1, r4
 9913 570c 0420A0E1 		mov	r2, r4
 9914 5710 0500A0E1 		mov	r0, r5
 9915              	.LVL867:
 9916 5714 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 9917              	.LVL868:
4875:../uvc.c      **** 
4876:../uvc.c      ****     /* Configure the IO matrix for the device. */
4877:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4878:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4879:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4880:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4881:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4882:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4883:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4884:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4885:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4886:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4887:../uvc.c      **** 
4888:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 9918              		.loc 1 4888 0
 9919 5718 0D00A0E1 		mov	r0, sp
4878:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 9920              		.loc 1 4878 0
 9921 571c 1640CDE5 		strb	r4, [sp, #22]
4879:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 9922              		.loc 1 4879 0
 9923 5720 18408DE5 		str	r4, [sp, #24]
4880:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 9924              		.loc 1 4880 0
 9925 5724 1C408DE5 		str	r4, [sp, #28]
4881:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 9926              		.loc 1 4881 0
 9927 5728 20408DE5 		str	r4, [sp, #32]
4882:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 9928              		.loc 1 4882 0
 9929 572c 24408DE5 		str	r4, [sp, #36]
4885:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 9930              		.loc 1 4885 0
 9931 5730 0C408DE5 		str	r4, [sp, #12]
4886:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 9932              		.loc 1 4886 0
 9933 5734 10408DE5 		str	r4, [sp, #16]
4877:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 9934              		.loc 1 4877 0
 9935 5738 00508DE5 		str	r5, [sp, #0]
4883:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 9936              		.loc 1 4883 0
 9937 573c 04508DE5 		str	r5, [sp, #4]
4884:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 9938              		.loc 1 4884 0
 9939 5740 08508DE5 		str	r5, [sp, #8]
 9940              		.loc 1 4888 0
 9941 5744 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 9942              	.LVL869:
4889:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 9943              		.loc 1 4889 0
 9944 5748 004050E2 		subs	r4, r0, #0
 9945 574c ECFFFF1A 		bne	.L800
4890:../uvc.c      ****     {
4891:../uvc.c      ****         goto handle_fatal_error;
4892:../uvc.c      ****     }
4893:../uvc.c      **** 
4894:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4895:../uvc.c      ****     CyU3PKernelEntry ();
 9946              		.loc 1 4895 0
 9947 5750 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 9948              	.LVL870:
4896:../uvc.c      **** 
4897:../uvc.c      ****     /* Dummy return to make the compiler happy */
4898:../uvc.c      ****     return 0;
4899:../uvc.c      **** 
4900:../uvc.c      **** handle_fatal_error:
4901:../uvc.c      ****     /* Cannot recover from this error. */
4902:../uvc.c      ****     while (1);
4903:../uvc.c      **** }
 9949              		.loc 1 4903 0
 9950 5754 0400A0E1 		mov	r0, r4
 9951 5758 3CD08DE2 		add	sp, sp, #60
 9952 575c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 9953              		.cfi_endproc
 9954              	.LFE29:
 9956              		.global	CyFxGpifTransition
 9957              		.global	CyFxGpifWavedata
 9958              		.global	CyFxGpifWavedataPosition
 9959              		.global	CyFxGpifRegValue
 9960              		.global	CyFxGpifConfig
 9961              		.global	CyFxGpifTransition_usb2
 9962              		.global	CyFxGpifWavedata_usb2
 9963              		.global	CyFxGpifWavedataPosition_usb2
 9964              		.global	CyFxGpifRegValue_usb2
 9965              		.global	CyFxGpifConfig_usb2
 9966              		.global	snapButFlag
 9967              		.global	testSnap
 9968              		.global	fb
 9969              		.global	pb
 9970              		.global	pbc
 9971              		.global	fbbak
 9972              		.global	pbbak
 9973              		.global	pbcbak
 9974              		.global	pbcpbak
 9975              		.global	isUsbConnected
 9976              		.global	usbSpeed
 9977              		.global	clearFeatureRqtReceived
 9978              		.global	streamingRecove
 9979              		.global	streamingStarted
 9980              		.global	glProbeCtrl
 9981              		.global	glProbeCtrlFull
 9982              		.global	glProbeStilCtrl
 9983              		.global	glProbeCtrl20
 9984              		.global	glProbeStilCtrl20
 9985              		.global	glUVCHeader
 9986              		.comm	glChHandleUVCStream,220,4
 9987              		.comm	glChHandleStillStream,220,4
 9988              		.comm	glChHandleInterStat,160,4
 9989              		.comm	glInterStaBuffer,4,4
 9990              		.comm	cmdQu,32,4
 9991              		.comm	statQu,32,4
 9992              		.comm	cmdQuMux,56,4
 9993              		.comm	staQuMux,56,4
 9994              		.comm	timMux,56,4
 9995              		.comm	imgHdMux,56,4
 9996              		.comm	bmReqType,1,1
 9997              		.comm	bRequest,1,1
 9998              		.comm	wValue,2,2
 9999              		.comm	wIndex,2,2
 10000              		.comm	wLength,2,2
 10001              		.comm	glDebugCmdChannel,160,4
 10002              		.comm	glDebugRspChannel,160,4
 10003              		.comm	glDebugRspBuffer,4,4
 10004              		.comm	posTick,4,4
 10005              		.comm	I2CCmdTimer,44,4
 10006              		.section	.rodata
 10007              		.align	2
 10008              		.set	.LANCHOR2,. + 0
 10011              	ShutSp:
 10012 0000 3582     		.short	-32203
 10013 0002 1B41     		.short	16667
 10014 0004 8D20     		.short	8333
 10015 0006 A00F     		.short	4000
 10016 0008 D007     		.short	2000
 10017 000a E803     		.short	1000
 10018 000c F401     		.short	500
 10019 000e C800     		.short	200
 10020 0010 6400     		.short	100
 10021 0012 0A00     		.short	10
 10022 0014 0000     		.short	0
 10023 0016 00000000 		.space	10
 10023      00000000 
 10023      0000
 10026              	CyFxGpifConfig:
 10027 0020 0F00     		.short	15
 10028 0022 0000     		.space	2
 10029 0024 00000000 		.word	CyFxGpifWavedata
 10030 0028 00000000 		.word	CyFxGpifWavedataPosition
 10031 002c 0500     		.short	5
 10032 002e 0000     		.space	2
 10033 0030 00000000 		.word	CyFxGpifTransition
 10034 0034 4C00     		.short	76
 10035 0036 0000     		.space	2
 10036 0038 00000000 		.word	CyFxGpifRegValue
 10039              	CyFxGpifConfig_usb2:
 10040 003c 9300     		.short	147
 10041 003e 0000     		.space	2
 10042 0040 00000000 		.word	CyFxGpifWavedata_usb2
 10043 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 10044 0048 0800     		.short	8
 10045 004a 0000     		.space	2
 10046 004c 00000000 		.word	CyFxGpifTransition_usb2
 10047 0050 4C00     		.short	76
 10048 0052 0000     		.space	2
 10049 0054 00000000 		.word	CyFxGpifRegValue_usb2
 10050              		.data
 10051              		.align	2
 10052              		.set	.LANCHOR1,. + 0
 10055              	ExUCtrlParArry:
 10056 0000 00       		.byte	0
 10057 0001 00       		.byte	0
 10058 0002 04       		.byte	4
 10059 0003 01       		.byte	1
 10060 0004 00       		.byte	0
 10061 0005 38       		.byte	56
 10062 0006 01       		.byte	1
 10063 0007 01       		.byte	1
 10064 0008 00       		.byte	0
 10065 0009 03       		.byte	3
 10066 000a 00       		.byte	0
 10067 000b 4E       		.byte	78
 10068 000c 00       		.byte	0
 10069 000d 4E       		.byte	78
 10070 000e 00       		.byte	0
 10071 000f 30       		.byte	48
 10072 0010 01       		.byte	1
 10073 0011 00       		.byte	0
 10074 0012 00       		.byte	0
 10075 0013 00000000 		.space	5
 10075      00
 10076 0018 00       		.byte	0
 10077 0019 00       		.byte	0
 10078 001a 01       		.byte	1
 10079 001b 00       		.byte	0
 10080 001c 00       		.byte	0
 10081 001d 00       		.byte	0
 10082 001e 00       		.byte	0
 10083 001f 01       		.byte	1
 10084 0020 00       		.byte	0
 10085 0021 03       		.byte	3
 10086 0022 00       		.byte	0
 10087 0023 00       		.byte	0
 10088 0024 00       		.byte	0
 10089 0025 00       		.byte	0
 10090 0026 00       		.byte	0
 10091 0027 30       		.byte	48
 10092 0028 01       		.byte	1
 10093 0029 00       		.byte	0
 10094 002a 00       		.byte	0
 10095 002b 00000000 		.space	5
 10095      00
 10096 0030 00       		.byte	0
 10097 0031 00       		.byte	0
 10098 0032 02       		.byte	2
 10099 0033 00       		.byte	0
 10100 0034 00       		.byte	0
 10101 0035 FF       		.byte	-1
 10102 0036 00       		.byte	0
 10103 0037 01       		.byte	1
 10104 0038 00       		.byte	0
 10105 0039 03       		.byte	3
 10106 003a 00       		.byte	0
 10107 003b 01       		.byte	1
 10108 003c 00       		.byte	0
 10109 003d 00       		.byte	0
 10110 003e 00       		.byte	0
 10111 003f 30       		.byte	48
 10112 0040 01       		.byte	1
 10113 0041 01       		.byte	1
 10114 0042 00       		.byte	0
 10115 0043 00000000 		.space	5
 10115      00
 10116 0048 00       		.byte	0
 10117 0049 00       		.byte	0
 10118 004a 02       		.byte	2
 10119 004b 00       		.byte	0
 10120 004c 00       		.byte	0
 10121 004d 00       		.byte	0
 10122 004e 00       		.byte	0
 10123 004f 00       		.byte	0
 10124 0050 00       		.byte	0
 10125 0051 03       		.byte	3
 10126 0052 00       		.byte	0
 10127 0053 00       		.byte	0
 10128 0054 00       		.byte	0
 10129 0055 00       		.byte	0
 10130 0056 00       		.byte	0
 10131 0057 30       		.byte	48
 10132 0058 01       		.byte	1
 10133 0059 01       		.byte	1
 10134 005a 00       		.byte	0
 10135 005b 00000000 		.space	5
 10135      00
 10136 0060 13       		.byte	19
 10137 0061 14       		.byte	20
 10138 0062 02       		.byte	2
 10139 0063 00       		.byte	0
 10140 0064 00       		.byte	0
 10141 0065 FF       		.byte	-1
 10142 0066 FF       		.byte	-1
 10143 0067 01       		.byte	1
 10144 0068 00       		.byte	0
 10145 0069 03       		.byte	3
 10146 006a 00       		.byte	0
 10147 006b 66       		.byte	102
 10148 006c 66       		.byte	102
 10149 006d 66       		.byte	102
 10150 006e 66       		.byte	102
 10151 006f 30       		.byte	48
 10152 0070 01       		.byte	1
 10153 0071 00       		.byte	0
 10154 0072 00       		.byte	0
 10155 0073 00000000 		.space	5
 10155      00
 10156 0078 11       		.byte	17
 10157 0079 00       		.byte	0
 10158 007a 02       		.byte	2
 10159 007b 01       		.byte	1
 10160 007c 00       		.byte	0
 10161 007d 03       		.byte	3
 10162 007e 00       		.byte	0
 10163 007f 01       		.byte	1
 10164 0080 00       		.byte	0
 10165 0081 03       		.byte	3
 10166 0082 00       		.byte	0
 10167 0083 80       		.byte	-128
 10168 0084 00       		.byte	0
 10169 0085 80       		.byte	-128
 10170 0086 00       		.byte	0
 10171 0087 30       		.byte	48
 10172 0088 01       		.byte	1
 10173 0089 01       		.byte	1
 10174 008a 00       		.byte	0
 10175 008b 00000000 		.space	5
 10175      00
 10176 0090 10       		.byte	16
 10177 0091 00       		.byte	0
 10178 0092 01       		.byte	1
 10179 0093 01       		.byte	1
 10180 0094 00       		.byte	0
 10181 0095 02       		.byte	2
 10182 0096 00       		.byte	0
 10183 0097 01       		.byte	1
 10184 0098 00       		.byte	0
 10185 0099 03       		.byte	3
 10186 009a 00       		.byte	0
 10187 009b 00       		.byte	0
 10188 009c 00       		.byte	0
 10189 009d 00       		.byte	0
 10190 009e 00       		.byte	0
 10191 009f 30       		.byte	48
 10192 00a0 01       		.byte	1
 10193 00a1 01       		.byte	1
 10194 00a2 00       		.byte	0
 10195 00a3 00000000 		.space	5
 10195      00
 10196 00a8 00       		.byte	0
 10197 00a9 00       		.byte	0
 10198 00aa 04       		.byte	4
 10199 00ab 01       		.byte	1
 10200 00ac 00       		.byte	0
 10201 00ad 38       		.byte	56
 10202 00ae 01       		.byte	1
 10203 00af 01       		.byte	1
 10204 00b0 00       		.byte	0
 10205 00b1 03       		.byte	3
 10206 00b2 00       		.byte	0
 10207 00b3 4E       		.byte	78
 10208 00b4 00       		.byte	0
 10209 00b5 4E       		.byte	78
 10210 00b6 00       		.byte	0
 10211 00b7 30       		.byte	48
 10212 00b8 01       		.byte	1
 10213 00b9 00       		.byte	0
 10214 00ba 00       		.byte	0
 10215 00bb 00000000 		.space	5
 10215      00
 10216 00c0 00       		.byte	0
 10217 00c1 00       		.byte	0
 10218 00c2 01       		.byte	1
 10219 00c3 00       		.byte	0
 10220 00c4 00       		.byte	0
 10221 00c5 00       		.byte	0
 10222 00c6 00       		.byte	0
 10223 00c7 01       		.byte	1
 10224 00c8 00       		.byte	0
 10225 00c9 03       		.byte	3
 10226 00ca 00       		.byte	0
 10227 00cb 00       		.byte	0
 10228 00cc 00       		.byte	0
 10229 00cd 00       		.byte	0
 10230 00ce 00       		.byte	0
 10231 00cf 30       		.byte	48
 10232 00d0 01       		.byte	1
 10233 00d1 00       		.byte	0
 10234 00d2 00       		.byte	0
 10235 00d3 00000000 		.space	5
 10235      00
 10236 00d8 00       		.byte	0
 10237 00d9 00       		.byte	0
 10238 00da 02       		.byte	2
 10239 00db 00       		.byte	0
 10240 00dc 00       		.byte	0
 10241 00dd 05       		.byte	5
 10242 00de 00       		.byte	0
 10243 00df 01       		.byte	1
 10244 00e0 00       		.byte	0
 10245 00e1 03       		.byte	3
 10246 00e2 00       		.byte	0
 10247 00e3 00       		.byte	0
 10248 00e4 00       		.byte	0
 10249 00e5 00       		.byte	0
 10250 00e6 00       		.byte	0
 10251 00e7 30       		.byte	48
 10252 00e8 01       		.byte	1
 10253 00e9 00       		.byte	0
 10254 00ea 00       		.byte	0
 10255 00eb 00000000 		.space	5
 10255      00
 10256 00f0 00       		.byte	0
 10257 00f1 00       		.byte	0
 10258 00f2 03       		.byte	3
 10259 00f3 00       		.byte	0
 10260 00f4 00       		.byte	0
 10261 00f5 0A       		.byte	10
 10262 00f6 00       		.byte	0
 10263 00f7 01       		.byte	1
 10264 00f8 00       		.byte	0
 10265 00f9 03       		.byte	3
 10266 00fa 00       		.byte	0
 10267 00fb 00       		.byte	0
 10268 00fc 00       		.byte	0
 10269 00fd 00       		.byte	0
 10270 00fe 00       		.byte	0
 10271 00ff 30       		.byte	48
 10272 0100 01       		.byte	1
 10273 0101 00       		.byte	0
 10274 0102 00       		.byte	0
 10275 0103 00000000 		.space	5
 10275      00
 10276 0108 00       		.byte	0
 10277 0109 00       		.byte	0
 10278 010a 02       		.byte	2
 10279 010b 00       		.byte	0
 10280 010c 00       		.byte	0
 10281 010d 40       		.byte	64
 10282 010e 00       		.byte	0
 10283 010f 01       		.byte	1
 10284 0110 00       		.byte	0
 10285 0111 03       		.byte	3
 10286 0112 00       		.byte	0
 10287 0113 0F       		.byte	15
 10288 0114 11       		.byte	17
 10289 0115 00       		.byte	0
 10290 0116 00       		.byte	0
 10291 0117 30       		.byte	48
 10292 0118 01       		.byte	1
 10293 0119 00       		.byte	0
 10294 011a 00       		.byte	0
 10295 011b 00000000 		.space	5
 10295      00
 10296 0120 00       		.byte	0
 10297 0121 00       		.byte	0
 10298 0122 02       		.byte	2
 10299 0123 00       		.byte	0
 10300 0124 00       		.byte	0
 10301 0125 64       		.byte	100
 10302 0126 00       		.byte	0
 10303 0127 01       		.byte	1
 10304 0128 00       		.byte	0
 10305 0129 03       		.byte	3
 10306 012a 00       		.byte	0
 10307 012b 00       		.byte	0
 10308 012c 00       		.byte	0
 10309 012d 00       		.byte	0
 10310 012e 00       		.byte	0
 10311 012f 30       		.byte	48
 10312 0130 01       		.byte	1
 10313 0131 00       		.byte	0
 10314 0132 00       		.byte	0
 10315 0133 00000000 		.space	5
 10315      00
 10316 0138 00       		.byte	0
 10317 0139 00       		.byte	0
 10318 013a 02       		.byte	2
 10319 013b 00       		.byte	0
 10320 013c 00       		.byte	0
 10321 013d 64       		.byte	100
 10322 013e 00       		.byte	0
 10323 013f 01       		.byte	1
 10324 0140 00       		.byte	0
 10325 0141 03       		.byte	3
 10326 0142 00       		.byte	0
 10327 0143 00       		.byte	0
 10328 0144 00       		.byte	0
 10329 0145 00       		.byte	0
 10330 0146 00       		.byte	0
 10331 0147 30       		.byte	48
 10332 0148 01       		.byte	1
 10333 0149 00       		.byte	0
 10334 014a 00       		.byte	0
 10335 014b 00000000 		.space	5
 10335      00
 10336 0150 00       		.byte	0
 10337 0151 00       		.byte	0
 10338 0152 02       		.byte	2
 10339 0153 00       		.byte	0
 10340 0154 00       		.byte	0
 10341 0155 64       		.byte	100
 10342 0156 00       		.byte	0
 10343 0157 01       		.byte	1
 10344 0158 00       		.byte	0
 10345 0159 03       		.byte	3
 10346 015a 00       		.byte	0
 10347 015b 00       		.byte	0
 10348 015c 00       		.byte	0
 10349 015d 00       		.byte	0
 10350 015e 00       		.byte	0
 10351 015f 30       		.byte	48
 10352 0160 01       		.byte	1
 10353 0161 00       		.byte	0
 10354 0162 00       		.byte	0
 10355 0163 00000000 		.space	5
 10355      00
 10356 0168 00       		.byte	0
 10357 0169 00       		.byte	0
 10358 016a 02       		.byte	2
 10359 016b 00       		.byte	0
 10360 016c 00       		.byte	0
 10361 016d 64       		.byte	100
 10362 016e 00       		.byte	0
 10363 016f 01       		.byte	1
 10364 0170 00       		.byte	0
 10365 0171 03       		.byte	3
 10366 0172 00       		.byte	0
 10367 0173 00       		.byte	0
 10368 0174 00       		.byte	0
 10369 0175 00       		.byte	0
 10370 0176 00       		.byte	0
 10371 0177 30       		.byte	48
 10372 0178 01       		.byte	1
 10373 0179 00       		.byte	0
 10374 017a 00       		.byte	0
 10375 017b 00000000 		.space	5
 10375      00
 10378              	CtrlParArry:
 10379 0180 10       		.byte	16
 10380 0181 10       		.byte	16
 10381 0182 02       		.byte	2
 10382 0183 00       		.byte	0
 10383 0184 00       		.byte	0
 10384 0185 03       		.byte	3
 10385 0186 00       		.byte	0
 10386 0187 01       		.byte	1
 10387 0188 00       		.byte	0
 10388 0189 03       		.byte	3
 10389 018a 00       		.byte	0
 10390 018b 03       		.byte	3
 10391 018c 00       		.byte	0
 10392 018d 03       		.byte	3
 10393 018e 00       		.byte	0
 10394 018f 30       		.byte	48
 10395 0190 01       		.byte	1
 10396 0191 00       		.byte	0
 10397 0192 00       		.byte	0
 10398 0193 00000000 		.space	5
 10398      00
 10399 0198 15       		.byte	21
 10400 0199 15       		.byte	21
 10401 019a 02       		.byte	2
 10402 019b 00       		.byte	0
 10403 019c 00       		.byte	0
 10404 019d FF       		.byte	-1
 10405 019e 00       		.byte	0
 10406 019f 01       		.byte	1
 10407 01a0 00       		.byte	0
 10408 01a1 03       		.byte	3
 10409 01a2 00       		.byte	0
 10410 01a3 76       		.byte	118
 10411 01a4 00       		.byte	0
 10412 01a5 76       		.byte	118
 10413 01a6 C7       		.byte	-57
 10414 01a7 30       		.byte	48
 10415 01a8 01       		.byte	1
 10416 01a9 01       		.byte	1
 10417 01aa 00       		.byte	0
 10418 01ab 00000000 		.space	5
 10418      00
 10419 01b0 04       		.byte	4
 10420 01b1 04       		.byte	4
 10421 01b2 02       		.byte	2
 10422 01b3 00       		.byte	0
 10423 01b4 00       		.byte	0
 10424 01b5 FF       		.byte	-1
 10425 01b6 00       		.byte	0
 10426 01b7 01       		.byte	1
 10427 01b8 00       		.byte	0
 10428 01b9 03       		.byte	3
 10429 01ba 00       		.byte	0
 10430 01bb 70       		.byte	112
 10431 01bc 00       		.byte	0
 10432 01bd 70       		.byte	112
 10433 01be 00       		.byte	0
 10434 01bf 30       		.byte	48
 10435 01c0 01       		.byte	1
 10436 01c1 01       		.byte	1
 10437 01c2 00       		.byte	0
 10438 01c3 00000000 		.space	5
 10438      00
 10439 01c8 00       		.byte	0
 10440 01c9 00       		.byte	0
 10441 01ca 02       		.byte	2
 10442 01cb 00       		.byte	0
 10443 01cc 00       		.byte	0
 10444 01cd 64       		.byte	100
 10445 01ce 00       		.byte	0
 10446 01cf 01       		.byte	1
 10447 01d0 00       		.byte	0
 10448 01d1 03       		.byte	3
 10449 01d2 00       		.byte	0
 10450 01d3 00       		.byte	0
 10451 01d4 00       		.byte	0
 10452 01d5 00       		.byte	0
 10453 01d6 00       		.byte	0
 10454 01d7 30       		.byte	48
 10455 01d8 01       		.byte	1
 10456 01d9 00       		.byte	0
 10457 01da 00       		.byte	0
 10458 01db 00000000 		.space	5
 10458      00
 10459 01e0 07       		.byte	7
 10460 01e1 07       		.byte	7
 10461 01e2 02       		.byte	2
 10462 01e3 00       		.byte	0
 10463 01e4 00       		.byte	0
 10464 01e5 01       		.byte	1
 10465 01e6 00       		.byte	0
 10466 01e7 01       		.byte	1
 10467 01e8 00       		.byte	0
 10468 01e9 03       		.byte	3
 10469 01ea 00       		.byte	0
 10470 01eb 01       		.byte	1
 10471 01ec 00       		.byte	0
 10472 01ed 01       		.byte	1
 10473 01ee 00       		.byte	0
 10474 01ef 30       		.byte	48
 10475 01f0 01       		.byte	1
 10476 01f1 00       		.byte	0
 10477 01f2 00       		.byte	0
 10478 01f3 00000000 		.space	5
 10478      00
 10479 01f8 DF       		.byte	-33
 10480 01f9 E1       		.byte	-31
 10481 01fa 02       		.byte	2
 10482 01fb 00       		.byte	0
 10483 01fc 00       		.byte	0
 10484 01fd FF       		.byte	-1
 10485 01fe 00       		.byte	0
 10486 01ff 01       		.byte	1
 10487 0200 00       		.byte	0
 10488 0201 03       		.byte	3
 10489 0202 00       		.byte	0
 10490 0203 80       		.byte	-128
 10491 0204 00       		.byte	0
 10492 0205 00       		.byte	0
 10493 0206 00       		.byte	0
 10494 0207 C6       		.byte	-58
 10495 0208 01       		.byte	1
 10496 0209 01       		.byte	1
 10497 020a 00       		.byte	0
 10498 020b 00000000 		.space	5
 10498      00
 10499 0210 85       		.byte	-123
 10500 0211 86       		.byte	-122
 10501 0212 02       		.byte	2
 10502 0213 00       		.byte	0
 10503 0214 00       		.byte	0
 10504 0215 64       		.byte	100
 10505 0216 00       		.byte	0
 10506 0217 01       		.byte	1
 10507 0218 00       		.byte	0
 10508 0219 03       		.byte	3
 10509 021a 00       		.byte	0
 10510 021b 32       		.byte	50
 10511 021c 00       		.byte	0
 10512 021d 32       		.byte	50
 10513 021e 00       		.byte	0
 10514 021f F2       		.byte	-14
 10515 0220 01       		.byte	1
 10516 0221 01       		.byte	1
 10517 0222 00       		.byte	0
 10518 0223 00000000 		.space	5
 10518      00
 10519 0228 06       		.byte	6
 10520 0229 06       		.byte	6
 10521 022a 02       		.byte	2
 10522 022b 00       		.byte	0
 10523 022c 00       		.byte	0
 10524 022d FF       		.byte	-1
 10525 022e 00       		.byte	0
 10526 022f 01       		.byte	1
 10527 0230 00       		.byte	0
 10528 0231 03       		.byte	3
 10529 0232 00       		.byte	0
 10530 0233 20       		.byte	32
 10531 0234 00       		.byte	0
 10532 0235 20       		.byte	32
 10533 0236 00       		.byte	0
 10534 0237 30       		.byte	48
 10535 0238 01       		.byte	1
 10536 0239 01       		.byte	1
 10537 023a 00       		.byte	0
 10538 023b 00000000 		.space	5
 10538      00
 10539 0240 00       		.byte	0
 10540 0241 00       		.byte	0
 10541 0242 02       		.byte	2
 10542 0243 00       		.byte	0
 10543 0244 00       		.byte	0
 10544 0245 64       		.byte	100
 10545 0246 00       		.byte	0
 10546 0247 01       		.byte	1
 10547 0248 00       		.byte	0
 10548 0249 03       		.byte	3
 10549 024a 00       		.byte	0
 10550 024b 00       		.byte	0
 10551 024c 00       		.byte	0
 10552 024d 00       		.byte	0
 10553 024e 00       		.byte	0
 10554 024f 30       		.byte	48
 10555 0250 01       		.byte	1
 10556 0251 00       		.byte	0
 10557 0252 00       		.byte	0
 10558 0253 00000000 		.space	5
 10558      00
 10559 0258 08       		.byte	8
 10560 0259 08       		.byte	8
 10561 025a 02       		.byte	2
 10562 025b 00       		.byte	0
 10563 025c 00       		.byte	0
 10564 025d 05       		.byte	5
 10565 025e 00       		.byte	0
 10566 025f 01       		.byte	1
 10567 0260 00       		.byte	0
 10568 0261 03       		.byte	3
 10569 0262 00       		.byte	0
 10570 0263 00       		.byte	0
 10571 0264 00       		.byte	0
 10572 0265 00       		.byte	0
 10573 0266 00       		.byte	0
 10574 0267 30       		.byte	48
 10575 0268 01       		.byte	1
 10576 0269 00       		.byte	0
 10577 026a 00       		.byte	0
 10578 026b 00000000 		.space	5
 10578      00
 10579 0270 00       		.byte	0
 10580 0271 00       		.byte	0
 10581 0272 02       		.byte	2
 10582 0273 00       		.byte	0
 10583 0274 00       		.byte	0
 10584 0275 40       		.byte	64
 10585 0276 00       		.byte	0
 10586 0277 01       		.byte	1
 10587 0278 00       		.byte	0
 10588 0279 03       		.byte	3
 10589 027a 00       		.byte	0
 10590 027b 00       		.byte	0
 10591 027c 00       		.byte	0
 10592 027d 00       		.byte	0
 10593 027e 00       		.byte	0
 10594 027f 30       		.byte	48
 10595 0280 01       		.byte	1
 10596 0281 00       		.byte	0
 10597 0282 00       		.byte	0
 10598 0283 00000000 		.space	5
 10598      00
 10599 0288 09       		.byte	9
 10600 0289 0A       		.byte	10
 10601 028a 04       		.byte	4
 10602 028b 00       		.byte	0
 10603 028c 00       		.byte	0
 10604 028d 40       		.byte	64
 10605 028e 00       		.byte	0
 10606 028f 01       		.byte	1
 10607 0290 00       		.byte	0
 10608 0291 03       		.byte	3
 10609 0292 00       		.byte	0
 10610 0293 20       		.byte	32
 10611 0294 38       		.byte	56
 10612 0295 20       		.byte	32
 10613 0296 38       		.byte	56
 10614 0297 30       		.byte	48
 10615 0298 01       		.byte	1
 10616 0299 00       		.byte	0
 10617 029a 00       		.byte	0
 10618 029b 00000000 		.space	5
 10618      00
 10619 02a0 00       		.byte	0
 10620 02a1 00       		.byte	0
 10621 02a2 02       		.byte	2
 10622 02a3 00       		.byte	0
 10623 02a4 00       		.byte	0
 10624 02a5 64       		.byte	100
 10625 02a6 00       		.byte	0
 10626 02a7 01       		.byte	1
 10627 02a8 00       		.byte	0
 10628 02a9 03       		.byte	3
 10629 02aa 00       		.byte	0
 10630 02ab 00       		.byte	0
 10631 02ac 00       		.byte	0
 10632 02ad 00       		.byte	0
 10633 02ae 00       		.byte	0
 10634 02af 30       		.byte	48
 10635 02b0 01       		.byte	1
 10636 02b1 00       		.byte	0
 10637 02b2 00       		.byte	0
 10638 02b3 00000000 		.space	5
 10638      00
 10639 02b8 00       		.byte	0
 10640 02b9 00       		.byte	0
 10641 02ba 02       		.byte	2
 10642 02bb 00       		.byte	0
 10643 02bc 00       		.byte	0
 10644 02bd 64       		.byte	100
 10645 02be 00       		.byte	0
 10646 02bf 01       		.byte	1
 10647 02c0 00       		.byte	0
 10648 02c1 03       		.byte	3
 10649 02c2 00       		.byte	0
 10650 02c3 00       		.byte	0
 10651 02c4 00       		.byte	0
 10652 02c5 00       		.byte	0
 10653 02c6 00       		.byte	0
 10654 02c7 30       		.byte	48
 10655 02c8 01       		.byte	1
 10656 02c9 00       		.byte	0
 10657 02ca 00       		.byte	0
 10658 02cb 00000000 		.space	5
 10658      00
 10659 02d0 2A       		.byte	42
 10660 02d1 2A       		.byte	42
 10661 02d2 02       		.byte	2
 10662 02d3 00       		.byte	0
 10663 02d4 00       		.byte	0
 10664 02d5 1B       		.byte	27
 10665 02d6 00       		.byte	0
 10666 02d7 01       		.byte	1
 10667 02d8 00       		.byte	0
 10668 02d9 03       		.byte	3
 10669 02da 00       		.byte	0
 10670 02db 00       		.byte	0
 10671 02dc 00       		.byte	0
 10672 02dd 00       		.byte	0
 10673 02de 00       		.byte	0
 10674 02df 30       		.byte	48
 10675 02e0 01       		.byte	1
 10676 02e1 00       		.byte	0
 10677 02e2 00       		.byte	0
 10678 02e3 00000000 		.space	5
 10678      00
 10679 02e8 00       		.byte	0
 10680 02e9 00       		.byte	0
 10681 02ea 02       		.byte	2
 10682 02eb 00       		.byte	0
 10683 02ec 00       		.byte	0
 10684 02ed 64       		.byte	100
 10685 02ee 00       		.byte	0
 10686 02ef 01       		.byte	1
 10687 02f0 00       		.byte	0
 10688 02f1 03       		.byte	3
 10689 02f2 00       		.byte	0
 10690 02f3 00       		.byte	0
 10691 02f4 00       		.byte	0
 10692 02f5 00       		.byte	0
 10693 02f6 00       		.byte	0
 10694 02f7 30       		.byte	48
 10695 02f8 01       		.byte	1
 10696 02f9 00       		.byte	0
 10697 02fa 00       		.byte	0
 10698 02fb 00000000 		.space	5
 10698      00
 10699 0300 00       		.byte	0
 10700 0301 00       		.byte	0
 10701 0302 02       		.byte	2
 10702 0303 00       		.byte	0
 10703 0304 00       		.byte	0
 10704 0305 12       		.byte	18
 10705 0306 00       		.byte	0
 10706 0307 01       		.byte	1
 10707 0308 00       		.byte	0
 10708 0309 03       		.byte	3
 10709 030a 00       		.byte	0
 10710 030b 00       		.byte	0
 10711 030c 00       		.byte	0
 10712 030d 00       		.byte	0
 10713 030e 00       		.byte	0
 10714 030f 30       		.byte	48
 10715 0310 01       		.byte	1
 10716 0311 00       		.byte	0
 10717 0312 00       		.byte	0
 10718 0313 00000000 		.space	5
 10718      00
 10719 0318 01       		.byte	1
 10720 0319 01       		.byte	1
 10721 031a 02       		.byte	2
 10722 031b 00       		.byte	0
 10723 031c 00       		.byte	0
 10724 031d 09       		.byte	9
 10725 031e 00       		.byte	0
 10726 031f 01       		.byte	1
 10727 0320 00       		.byte	0
 10728 0321 03       		.byte	3
 10729 0322 00       		.byte	0
 10730 0323 00       		.byte	0
 10731 0324 00       		.byte	0
 10732 0325 01       		.byte	1
 10733 0326 00       		.byte	0
 10734 0327 30       		.byte	48
 10735 0328 01       		.byte	1
 10736 0329 00       		.byte	0
 10737 032a 00       		.byte	0
 10738 032b 00000000 		.space	5
 10738      00
 10739 0330 05       		.byte	5
 10740 0331 05       		.byte	5
 10741 0332 02       		.byte	2
 10742 0333 00       		.byte	0
 10743 0334 00       		.byte	0
 10744 0335 03       		.byte	3
 10745 0336 00       		.byte	0
 10746 0337 01       		.byte	1
 10747 0338 00       		.byte	0
 10748 0339 03       		.byte	3
 10749 033a 00       		.byte	0
 10750 033b 00       		.byte	0
 10751 033c 00       		.byte	0
 10752 033d 00       		.byte	0
 10753 033e 00       		.byte	0
 10754 033f 30       		.byte	48
 10755 0340 01       		.byte	1
 10756 0341 00       		.byte	0
 10757 0342 00       		.byte	0
 10758 0343 00000000 		.space	5
 10758      00
 10759 0348 18       		.byte	24
 10760 0349 18       		.byte	24
 10761 034a 02       		.byte	2
 10762 034b 00       		.byte	0
 10763 034c 00       		.byte	0
 10764 034d 01       		.byte	1
 10765 034e 00       		.byte	0
 10766 034f 01       		.byte	1
 10767 0350 00       		.byte	0
 10768 0351 03       		.byte	3
 10769 0352 00       		.byte	0
 10770 0353 00       		.byte	0
 10771 0354 00       		.byte	0
 10772 0355 00       		.byte	0
 10773 0356 00       		.byte	0
 10774 0357 30       		.byte	48
 10775 0358 01       		.byte	1
 10776 0359 00       		.byte	0
 10777 035a 00       		.byte	0
 10778 035b 00000000 		.space	5
 10778      00
 10779 0360 19       		.byte	25
 10780 0361 19       		.byte	25
 10781 0362 01       		.byte	1
 10782 0363 00       		.byte	0
 10783 0364 00       		.byte	0
 10784 0365 40       		.byte	64
 10785 0366 00       		.byte	0
 10786 0367 01       		.byte	1
 10787 0368 00       		.byte	0
 10788 0369 03       		.byte	3
 10789 036a 00       		.byte	0
 10790 036b 20       		.byte	32
 10791 036c 00       		.byte	0
 10792 036d 20       		.byte	32
 10793 036e 00       		.byte	0
 10794 036f 30       		.byte	48
 10795 0370 01       		.byte	1
 10796 0371 00       		.byte	0
 10797 0372 00       		.byte	0
 10798 0373 00000000 		.space	5
 10798      00
 10799 0378 20       		.byte	32
 10800 0379 20       		.byte	32
 10801 037a 02       		.byte	2
 10802 037b 00       		.byte	0
 10803 037c 00       		.byte	0
 10804 037d 02       		.byte	2
 10805 037e 00       		.byte	0
 10806 037f 01       		.byte	1
 10807 0380 00       		.byte	0
 10808 0381 03       		.byte	3
 10809 0382 00       		.byte	0
 10810 0383 00       		.byte	0
 10811 0384 00       		.byte	0
 10812 0385 00       		.byte	0
 10813 0386 00       		.byte	0
 10814 0387 30       		.byte	48
 10815 0388 01       		.byte	1
 10816 0389 00       		.byte	0
 10817 038a 00       		.byte	0
 10818 038b 00000000 		.space	5
 10818      00
 10819 0390 22       		.byte	34
 10820 0391 22       		.byte	34
 10821 0392 02       		.byte	2
 10822 0393 00       		.byte	0
 10823 0394 00       		.byte	0
 10824 0395 3F       		.byte	63
 10825 0396 00       		.byte	0
 10826 0397 01       		.byte	1
 10827 0398 00       		.byte	0
 10828 0399 03       		.byte	3
 10829 039a 00       		.byte	0
 10830 039b 00       		.byte	0
 10831 039c 00       		.byte	0
 10832 039d 00       		.byte	0
 10833 039e 00       		.byte	0
 10834 039f 30       		.byte	48
 10835 03a0 01       		.byte	1
 10836 03a1 00       		.byte	0
 10837 03a2 00       		.byte	0
 10838 03a3 00000000 		.space	5
 10838      00
 10839 03a8 23       		.byte	35
 10840 03a9 23       		.byte	35
 10841 03aa 02       		.byte	2
 10842 03ab 00       		.byte	0
 10843 03ac 00       		.byte	0
 10844 03ad 64       		.byte	100
 10845 03ae 00       		.byte	0
 10846 03af 01       		.byte	1
 10847 03b0 00       		.byte	0
 10848 03b1 03       		.byte	3
 10849 03b2 00       		.byte	0
 10850 03b3 10       		.byte	16
 10851 03b4 00       		.byte	0
 10852 03b5 10       		.byte	16
 10853 03b6 00       		.byte	0
 10854 03b7 30       		.byte	48
 10855 03b8 01       		.byte	1
 10856 03b9 00       		.byte	0
 10857 03ba 00       		.byte	0
 10858 03bb 00000000 		.space	5
 10858      00
 10859 03c0 24       		.byte	36
 10860 03c1 24       		.byte	36
 10861 03c2 02       		.byte	2
 10862 03c3 00       		.byte	0
 10863 03c4 00       		.byte	0
 10864 03c5 64       		.byte	100
 10865 03c6 00       		.byte	0
 10866 03c7 01       		.byte	1
 10867 03c8 00       		.byte	0
 10868 03c9 03       		.byte	3
 10869 03ca 00       		.byte	0
 10870 03cb 10       		.byte	16
 10871 03cc 00       		.byte	0
 10872 03cd 10       		.byte	16
 10873 03ce 00       		.byte	0
 10874 03cf 30       		.byte	48
 10875 03d0 01       		.byte	1
 10876 03d1 00       		.byte	0
 10877 03d2 00       		.byte	0
 10878 03d3 00000000 		.space	5
 10878      00
 10879 03d8 02       		.byte	2
 10880 03d9 03       		.byte	3
 10881 03da 04       		.byte	4
 10882 03db 00       		.byte	0
 10883 03dc 00       		.byte	0
 10884 03dd 7F       		.byte	127
 10885 03de 00       		.byte	0
 10886 03df 01       		.byte	1
 10887 03e0 00       		.byte	0
 10888 03e1 03       		.byte	3
 10889 03e2 00       		.byte	0
 10890 03e3 00       		.byte	0
 10891 03e4 20       		.byte	32
 10892 03e5 00       		.byte	0
 10893 03e6 20       		.byte	32
 10894 03e7 30       		.byte	48
 10895 03e8 01       		.byte	1
 10896 03e9 00       		.byte	0
 10897 03ea 00       		.byte	0
 10898 03eb 00000000 		.space	5
 10898      00
 10899 03f0 04       		.byte	4
 10900 03f1 04       		.byte	4
 10901 03f2 02       		.byte	2
 10902 03f3 00       		.byte	0
 10903 03f4 00       		.byte	0
 10904 03f5 FF       		.byte	-1
 10905 03f6 00       		.byte	0
 10906 03f7 01       		.byte	1
 10907 03f8 00       		.byte	0
 10908 03f9 03       		.byte	3
 10909 03fa 00       		.byte	0
 10910 03fb 60       		.byte	96
 10911 03fc 00       		.byte	0
 10912 03fd 60       		.byte	96
 10913 03fe 00       		.byte	0
 10914 03ff 30       		.byte	48
 10915 0400 01       		.byte	1
 10916 0401 00       		.byte	0
 10917 0402 00       		.byte	0
 10918 0403 00000000 		.space	5
 10918      00
 10919 0408 00       		.byte	0
 10920 0409 00       		.byte	0
 10921 040a 02       		.byte	2
 10922 040b 00       		.byte	0
 10923 040c 00       		.byte	0
 10924 040d 19       		.byte	25
 10925 040e 00       		.byte	0
 10926 040f 01       		.byte	1
 10927 0410 00       		.byte	0
 10928 0411 03       		.byte	3
 10929 0412 00       		.byte	0
 10930 0413 00       		.byte	0
 10931 0414 00       		.byte	0
 10932 0415 00       		.byte	0
 10933 0416 00       		.byte	0
 10934 0417 30       		.byte	48
 10935 0418 01       		.byte	1
 10936 0419 00       		.byte	0
 10937 041a 00       		.byte	0
 10938 041b 00000000 		.space	5
 10938      00
 10939 0420 10       		.byte	16
 10940 0421 10       		.byte	16
 10941 0422 02       		.byte	2
 10942 0423 00       		.byte	0
 10943 0424 00       		.byte	0
 10944 0425 06       		.byte	6
 10945 0426 00       		.byte	0
 10946 0427 01       		.byte	1
 10947 0428 00       		.byte	0
 10948 0429 03       		.byte	3
 10949 042a 00       		.byte	0
 10950 042b 03       		.byte	3
 10951 042c 00       		.byte	0
 10952 042d 03       		.byte	3
 10953 042e 00       		.byte	0
 10954 042f 30       		.byte	48
 10955 0430 01       		.byte	1
 10956 0431 00       		.byte	0
 10957 0432 00       		.byte	0
 10958 0433 00000000 		.space	5
 10958      00
 10959 0438 00       		.byte	0
 10960 0439 00       		.byte	0
 10961 043a 02       		.byte	2
 10962 043b 00       		.byte	0
 10963 043c 00       		.byte	0
 10964 043d 03       		.byte	3
 10965 043e 00       		.byte	0
 10966 043f 01       		.byte	1
 10967 0440 00       		.byte	0
 10968 0441 03       		.byte	3
 10969 0442 00       		.byte	0
 10970 0443 00       		.byte	0
 10971 0444 00       		.byte	0
 10972 0445 00       		.byte	0
 10973 0446 00       		.byte	0
 10974 0447 30       		.byte	48
 10975 0448 01       		.byte	1
 10976 0449 00       		.byte	0
 10977 044a 00       		.byte	0
 10978 044b 00000000 		.space	5
 10978      00
 10979 0450 50       		.byte	80
 10980 0451 50       		.byte	80
 10981 0452 01       		.byte	1
 10982 0453 00       		.byte	0
 10983 0454 00       		.byte	0
 10984 0455 03       		.byte	3
 10985 0456 00       		.byte	0
 10986 0457 01       		.byte	1
 10987 0458 00       		.byte	0
 10988 0459 03       		.byte	3
 10989 045a 00       		.byte	0
 10990 045b 00       		.byte	0
 10991 045c 00       		.byte	0
 10992 045d 00       		.byte	0
 10993 045e 00       		.byte	0
 10994 045f 30       		.byte	48
 10995 0460 01       		.byte	1
 10996 0461 00       		.byte	0
 10997 0462 00       		.byte	0
 10998 0463 00000000 		.space	5
 10998      00
 10999 0468 00       		.byte	0
 11000 0469 00       		.byte	0
 11001 046a 0B       		.byte	11
 11002 046b 00       		.byte	0
 11003 046c 00       		.byte	0
 11004 046d FF       		.byte	-1
 11005 046e FF       		.byte	-1
 11006 046f 01       		.byte	1
 11007 0470 00       		.byte	0
 11008 0471 03       		.byte	3
 11009 0472 00       		.byte	0
 11010 0473 00       		.byte	0
 11011 0474 00       		.byte	0
 11012 0475 00       		.byte	0
 11013 0476 00       		.byte	0
 11014 0477 00       		.byte	0
 11015 0478 01       		.byte	1
 11016 0479 00       		.byte	0
 11017 047a 00       		.byte	0
 11018 047b 00000000 		.space	5
 11018      00
 11021              	glUVCHeader:
 11022 0480 0C       		.byte	12
 11023 0481 8C       		.byte	-116
 11024 0482 00       		.byte	0
 11025 0483 00       		.byte	0
 11026 0484 00       		.byte	0
 11027 0485 00       		.byte	0
 11028 0486 00       		.byte	0
 11029 0487 00       		.byte	0
 11030 0488 00       		.byte	0
 11031 0489 00       		.byte	0
 11032 048a 00       		.byte	0
 11033 048b 00       		.byte	0
 11036              	dbgIdx:
 11037 048c 02       		.byte	2
 11040              	ROIMode:
 11041 048d 01       		.byte	1
 11044              	valIdx:
 11045 048e 01       		.byte	1
 11046 048f 00       		.space	1
 11049              	EXTBLCWinPos:
 11050 0490 14       		.byte	20
 11051 0491 13       		.byte	19
 11052 0492 02       		.byte	2
 11053 0493 00       		.byte	0
 11054 0494 00       		.byte	0
 11055 0495 FF       		.byte	-1
 11056 0496 FF       		.byte	-1
 11057 0497 01       		.byte	1
 11058 0498 00       		.byte	0
 11059 0499 03       		.byte	3
 11060 049a 00       		.byte	0
 11061 049b 66       		.byte	102
 11062 049c 66       		.byte	102
 11063 049d 66       		.byte	102
 11064 049e 66       		.byte	102
 11065 049f 30       		.byte	48
 11066 04a0 01       		.byte	1
 11067 04a1 00       		.byte	0
 11068 04a2 0000     		.space	2
 11071              	EXTBLCWeight:
 11072 04a4 11       		.byte	17
 11073 04a5 11       		.byte	17
 11074 04a6 02       		.byte	2
 11075 04a7 00       		.byte	0
 11076 04a8 00       		.byte	0
 11077 04a9 FF       		.byte	-1
 11078 04aa 00       		.byte	0
 11079 04ab 01       		.byte	1
 11080 04ac 00       		.byte	0
 11081 04ad 03       		.byte	3
 11082 04ae 00       		.byte	0
 11083 04af 80       		.byte	-128
 11084 04b0 00       		.byte	0
 11085 04b1 80       		.byte	-128
 11086 04b2 00       		.byte	0
 11087 04b3 30       		.byte	48
 11088 04b4 01       		.byte	1
 11089 04b5 00       		.byte	0
 11090 04b6 0000     		.space	2
 11093              	EXTShutter:
 11094 04b8 00       		.byte	0
 11095 04b9 02       		.byte	2
 11096 04ba 02       		.byte	2
 11097 04bb 00       		.byte	0
 11098 04bc 00       		.byte	0
 11099 04bd 08       		.byte	8
 11100 04be 00       		.byte	0
 11101 04bf 01       		.byte	1
 11102 04c0 00       		.byte	0
 11103 04c1 03       		.byte	3
 11104 04c2 00       		.byte	0
 11105 04c3 00       		.byte	0
 11106 04c4 00       		.byte	0
 11107 04c5 00       		.byte	0
 11108 04c6 00       		.byte	0
 11109 04c7 30       		.byte	48
 11110 04c8 01       		.byte	1
 11111 04c9 00       		.byte	0
 11112 04ca 0000     		.space	2
 11115              	EXTShutlev:
 11116 04cc 02       		.byte	2
 11117 04cd 12       		.byte	18
 11118 04ce 02       		.byte	2
 11119 04cf 00       		.byte	0
 11120 04d0 00       		.byte	0
 11121 04d1 FF       		.byte	-1
 11122 04d2 7F       		.byte	127
 11123 04d3 01       		.byte	1
 11124 04d4 00       		.byte	0
 11125 04d5 03       		.byte	3
 11126 04d6 00       		.byte	0
 11127 04d7 3F       		.byte	63
 11128 04d8 00       		.byte	0
 11129 04d9 3F       		.byte	63
 11130 04da 00       		.byte	0
 11131 04db 30       		.byte	48
 11132 04dc 01       		.byte	1
 11133 04dd 00       		.byte	0
 11134 04de 0000     		.space	2
 11137              	EXTAexModGainlev:
 11138 04e0 00       		.byte	0
 11139 04e1 03       		.byte	3
 11140 04e2 04       		.byte	4
 11141 04e3 00       		.byte	0
 11142 04e4 00       		.byte	0
 11143 04e5 03       		.byte	3
 11144 04e6 7F       		.byte	127
 11145 04e7 01       		.byte	1
 11146 04e8 00       		.byte	0
 11147 04e9 03       		.byte	3
 11148 04ea 00       		.byte	0
 11149 04eb 00       		.byte	0
 11150 04ec 3F       		.byte	63
 11151 04ed 00       		.byte	0
 11152 04ee 3F       		.byte	63
 11153 04ef 30       		.byte	48
 11154 04f0 01       		.byte	1
 11155 04f1 00       		.byte	0
 11156 04f2 0000     		.space	2
 11159              	WBMenuCmpArry:
 11160 04f4 20       		.byte	32
 11161 04f5 0F       		.byte	15
 11162 04f6 38       		.byte	56
 11163 04f7 F0       		.byte	-16
 11166              	PUCBLC:
 11167 04f8 10       		.byte	16
 11168 04f9 11       		.byte	17
 11169 04fa 02       		.byte	2
 11170 04fb 00       		.byte	0
 11171 04fc 00       		.byte	0
 11172 04fd 03       		.byte	3
 11173 04fe 00       		.byte	0
 11174 04ff 01       		.byte	1
 11175 0500 00       		.byte	0
 11176 0501 03       		.byte	3
 11177 0502 00       		.byte	0
 11178 0503 03       		.byte	3
 11179 0504 00       		.byte	0
 11180 0505 03       		.byte	3
 11181 0506 00       		.byte	0
 11182 0507 30       		.byte	48
 11183 0508 01       		.byte	1
 11184 0509 00       		.byte	0
 11185 050a 0000     		.space	2
 11188              	PUCSharp:
 11189 050c 06       		.byte	6
 11190 050d 07       		.byte	7
 11191 050e 02       		.byte	2
 11192 050f 00       		.byte	0
 11193 0510 00       		.byte	0
 11194 0511 08       		.byte	8
 11195 0512 00       		.byte	0
 11196 0513 01       		.byte	1
 11197 0514 00       		.byte	0
 11198 0515 03       		.byte	3
 11199 0516 00       		.byte	0
 11200 0517 00       		.byte	0
 11201 0518 00       		.byte	0
 11202 0519 00       		.byte	0
 11203 051a 00       		.byte	0
 11204 051b 30       		.byte	48
 11205 051c 01       		.byte	1
 11206 051d 00       		.byte	0
 11207 051e 0000     		.space	2
 11210              	CTCtrlParArry:
 11211 0520 00       		.byte	0
 11212 0521 00       		.byte	0
 11213 0522 01       		.byte	1
 11214 0523 00       		.byte	0
 11215 0524 00       		.byte	0
 11216 0525 03       		.byte	3
 11217 0526 00       		.byte	0
 11218 0527 01       		.byte	1
 11219 0528 00       		.byte	0
 11220 0529 03       		.byte	3
 11221 052a 00       		.byte	0
 11222 052b 03       		.byte	3
 11223 052c 00       		.byte	0
 11224 052d 03       		.byte	3
 11225 052e 00       		.byte	0
 11226 052f 30       		.byte	48
 11227 0530 01       		.byte	1
 11228 0531 00       		.byte	0
 11229 0532 00       		.byte	0
 11230 0533 00000000 		.space	5
 11230      00
 11231 0538 00       		.byte	0
 11232 0539 00       		.byte	0
 11233 053a 01       		.byte	1
 11234 053b 01       		.byte	1
 11235 053c 00       		.byte	0
 11236 053d 0F       		.byte	15
 11237 053e 00       		.byte	0
 11238 053f 0F       		.byte	15
 11239 0540 00       		.byte	0
 11240 0541 03       		.byte	3
 11241 0542 00       		.byte	0
 11242 0543 02       		.byte	2
 11243 0544 00       		.byte	0
 11244 0545 02       		.byte	2
 11245 0546 00       		.byte	0
 11246 0547 30       		.byte	48
 11247 0548 01       		.byte	1
 11248 0549 01       		.byte	1
 11249 054a 00       		.byte	0
 11250 054b 00000000 		.space	5
 11250      00
 11251 0550 02       		.byte	2
 11252 0551 00       		.byte	0
 11253 0552 01       		.byte	1
 11254 0553 00       		.byte	0
 11255 0554 00       		.byte	0
 11256 0555 01       		.byte	1
 11257 0556 00       		.byte	0
 11258 0557 01       		.byte	1
 11259 0558 00       		.byte	0
 11260 0559 03       		.byte	3
 11261 055a 00       		.byte	0
 11262 055b 00       		.byte	0
 11263 055c 00       		.byte	0
 11264 055d 00       		.byte	0
 11265 055e 00       		.byte	0
 11266 055f 30       		.byte	48
 11267 0560 01       		.byte	1
 11268 0561 01       		.byte	1
 11269 0562 00       		.byte	0
 11270 0563 00000000 		.space	5
 11270      00
 11271 0568 00       		.byte	0
 11272 0569 00       		.byte	0
 11273 056a 04       		.byte	4
 11274 056b 01       		.byte	1
 11275 056c 00       		.byte	0
 11276 056d 38       		.byte	56
 11277 056e 01       		.byte	1
 11278 056f 01       		.byte	1
 11279 0570 00       		.byte	0
 11280 0571 03       		.byte	3
 11281 0572 00       		.byte	0
 11282 0573 4E       		.byte	78
 11283 0574 00       		.byte	0
 11284 0575 4E       		.byte	78
 11285 0576 00       		.byte	0
 11286 0577 30       		.byte	48
 11287 0578 01       		.byte	1
 11288 0579 00       		.byte	0
 11289 057a 00       		.byte	0
 11290 057b 00000000 		.space	5
 11290      00
 11291 0580 04       		.byte	4
 11292 0581 00       		.byte	0
 11293 0582 01       		.byte	1
 11294 0583 00       		.byte	0
 11295 0584 00       		.byte	0
 11296 0585 00       		.byte	0
 11297 0586 00       		.byte	0
 11298 0587 01       		.byte	1
 11299 0588 00       		.byte	0
 11300 0589 03       		.byte	3
 11301 058a 00       		.byte	0
 11302 058b 00       		.byte	0
 11303 058c 00       		.byte	0
 11304 058d 00       		.byte	0
 11305 058e 00       		.byte	0
 11306 058f 30       		.byte	48
 11307 0590 01       		.byte	1
 11308 0591 00       		.byte	0
 11309 0592 00       		.byte	0
 11310 0593 00000000 		.space	5
 11310      00
 11311 0598 05       		.byte	5
 11312 0599 00       		.byte	0
 11313 059a 02       		.byte	2
 11314 059b 00       		.byte	0
 11315 059c 00       		.byte	0
 11316 059d FF       		.byte	-1
 11317 059e 00       		.byte	0
 11318 059f 01       		.byte	1
 11319 05a0 00       		.byte	0
 11320 05a1 03       		.byte	3
 11321 05a2 00       		.byte	0
 11322 05a3 01       		.byte	1
 11323 05a4 00       		.byte	0
 11324 05a5 00       		.byte	0
 11325 05a6 00       		.byte	0
 11326 05a7 30       		.byte	48
 11327 05a8 01       		.byte	1
 11328 05a9 01       		.byte	1
 11329 05aa 00       		.byte	0
 11330 05ab 00000000 		.space	5
 11330      00
 11331 05b0 06       		.byte	6
 11332 05b1 00       		.byte	0
 11333 05b2 02       		.byte	2
 11334 05b3 00       		.byte	0
 11335 05b4 00       		.byte	0
 11336 05b5 00       		.byte	0
 11337 05b6 00       		.byte	0
 11338 05b7 00       		.byte	0
 11339 05b8 00       		.byte	0
 11340 05b9 03       		.byte	3
 11341 05ba 00       		.byte	0
 11342 05bb 00       		.byte	0
 11343 05bc 00       		.byte	0
 11344 05bd 00       		.byte	0
 11345 05be 00       		.byte	0
 11346 05bf 30       		.byte	48
 11347 05c0 01       		.byte	1
 11348 05c1 01       		.byte	1
 11349 05c2 00       		.byte	0
 11350 05c3 00000000 		.space	5
 11350      00
 11351 05c8 23       		.byte	35
 11352 05c9 00       		.byte	0
 11353 05ca 02       		.byte	2
 11354 05cb 00       		.byte	0
 11355 05cc 00       		.byte	0
 11356 05cd 30       		.byte	48
 11357 05ce 00       		.byte	0
 11358 05cf 01       		.byte	1
 11359 05d0 00       		.byte	0
 11360 05d1 03       		.byte	3
 11361 05d2 0A       		.byte	10
 11362 05d3 00       		.byte	0
 11363 05d4 00       		.byte	0
 11364 05d5 0A       		.byte	10
 11365 05d6 00       		.byte	0
 11366 05d7 30       		.byte	48
 11367 05d8 01       		.byte	1
 11368 05d9 01       		.byte	1
 11369 05da 00       		.byte	0
 11370 05db 00000000 		.space	5
 11370      00
 11371 05e0 08       		.byte	8
 11372 05e1 00       		.byte	0
 11373 05e2 01       		.byte	1
 11374 05e3 00       		.byte	0
 11375 05e4 00       		.byte	0
 11376 05e5 7F       		.byte	127
 11377 05e6 00       		.byte	0
 11378 05e7 01       		.byte	1
 11379 05e8 00       		.byte	0
 11380 05e9 03       		.byte	3
 11381 05ea 00       		.byte	0
 11382 05eb 00       		.byte	0
 11383 05ec 00       		.byte	0
 11384 05ed 00       		.byte	0
 11385 05ee 00       		.byte	0
 11386 05ef 30       		.byte	48
 11387 05f0 01       		.byte	1
 11388 05f1 00       		.byte	0
 11389 05f2 00       		.byte	0
 11390 05f3 00000000 		.space	5
 11390      00
 11391 05f8 09       		.byte	9
 11392 05f9 00       		.byte	0
 11393 05fa 02       		.byte	2
 11394 05fb 00       		.byte	0
 11395 05fc 00       		.byte	0
 11396 05fd 05       		.byte	5
 11397 05fe 00       		.byte	0
 11398 05ff 01       		.byte	1
 11399 0600 00       		.byte	0
 11400 0601 03       		.byte	3
 11401 0602 00       		.byte	0
 11402 0603 00       		.byte	0
 11403 0604 00       		.byte	0
 11404 0605 00       		.byte	0
 11405 0606 00       		.byte	0
 11406 0607 30       		.byte	48
 11407 0608 01       		.byte	1
 11408 0609 00       		.byte	0
 11409 060a 00       		.byte	0
 11410 060b 00000000 		.space	5
 11410      00
 11411 0610 10       		.byte	16
 11412 0611 00       		.byte	0
 11413 0612 03       		.byte	3
 11414 0613 00       		.byte	0
 11415 0614 00       		.byte	0
 11416 0615 00       		.byte	0
 11417 0616 00       		.byte	0
 11418 0617 00       		.byte	0
 11419 0618 00       		.byte	0
 11420 0619 03       		.byte	3
 11421 061a 00       		.byte	0
 11422 061b 00       		.byte	0
 11423 061c 00       		.byte	0
 11424 061d 00       		.byte	0
 11425 061e 00       		.byte	0
 11426 061f 30       		.byte	48
 11427 0620 01       		.byte	1
 11428 0621 00       		.byte	0
 11429 0622 00       		.byte	0
 11430 0623 00000000 		.space	5
 11430      00
 11431 0628 00       		.byte	0
 11432 0629 00       		.byte	0
 11433 062a 02       		.byte	2
 11434 062b 00       		.byte	0
 11435 062c 00       		.byte	0
 11436 062d 40       		.byte	64
 11437 062e 00       		.byte	0
 11438 062f 01       		.byte	1
 11439 0630 00       		.byte	0
 11440 0631 03       		.byte	3
 11441 0632 00       		.byte	0
 11442 0633 0F       		.byte	15
 11443 0634 11       		.byte	17
 11444 0635 00       		.byte	0
 11445 0636 00       		.byte	0
 11446 0637 30       		.byte	48
 11447 0638 01       		.byte	1
 11448 0639 00       		.byte	0
 11449 063a 00       		.byte	0
 11450 063b 00000000 		.space	5
 11450      00
 11451 0640 00       		.byte	0
 11452 0641 00       		.byte	0
 11453 0642 02       		.byte	2
 11454 0643 00       		.byte	0
 11455 0644 00       		.byte	0
 11456 0645 64       		.byte	100
 11457 0646 00       		.byte	0
 11458 0647 01       		.byte	1
 11459 0648 00       		.byte	0
 11460 0649 03       		.byte	3
 11461 064a 00       		.byte	0
 11462 064b 00       		.byte	0
 11463 064c 00       		.byte	0
 11464 064d 00       		.byte	0
 11465 064e 00       		.byte	0
 11466 064f 30       		.byte	48
 11467 0650 01       		.byte	1
 11468 0651 00       		.byte	0
 11469 0652 00       		.byte	0
 11470 0653 00000000 		.space	5
 11470      00
 11471 0658 00       		.byte	0
 11472 0659 00       		.byte	0
 11473 065a 02       		.byte	2
 11474 065b 00       		.byte	0
 11475 065c 00       		.byte	0
 11476 065d 64       		.byte	100
 11477 065e 00       		.byte	0
 11478 065f 01       		.byte	1
 11479 0660 00       		.byte	0
 11480 0661 03       		.byte	3
 11481 0662 00       		.byte	0
 11482 0663 00       		.byte	0
 11483 0664 00       		.byte	0
 11484 0665 00       		.byte	0
 11485 0666 00       		.byte	0
 11486 0667 30       		.byte	48
 11487 0668 01       		.byte	1
 11488 0669 00       		.byte	0
 11489 066a 00       		.byte	0
 11490 066b 00000000 		.space	5
 11490      00
 11491 0670 00       		.byte	0
 11492 0671 00       		.byte	0
 11493 0672 02       		.byte	2
 11494 0673 00       		.byte	0
 11495 0674 00       		.byte	0
 11496 0675 64       		.byte	100
 11497 0676 00       		.byte	0
 11498 0677 01       		.byte	1
 11499 0678 00       		.byte	0
 11500 0679 03       		.byte	3
 11501 067a 00       		.byte	0
 11502 067b 00       		.byte	0
 11503 067c 00       		.byte	0
 11504 067d 00       		.byte	0
 11505 067e 00       		.byte	0
 11506 067f 30       		.byte	48
 11507 0680 01       		.byte	1
 11508 0681 00       		.byte	0
 11509 0682 00       		.byte	0
 11510 0683 00000000 		.space	5
 11510      00
 11511 0688 00       		.byte	0
 11512 0689 00       		.byte	0
 11513 068a 02       		.byte	2
 11514 068b 00       		.byte	0
 11515 068c 00       		.byte	0
 11516 068d 64       		.byte	100
 11517 068e 00       		.byte	0
 11518 068f 01       		.byte	1
 11519 0690 00       		.byte	0
 11520 0691 03       		.byte	3
 11521 0692 00       		.byte	0
 11522 0693 00       		.byte	0
 11523 0694 00       		.byte	0
 11524 0695 00       		.byte	0
 11525 0696 00       		.byte	0
 11526 0697 30       		.byte	48
 11527 0698 01       		.byte	1
 11528 0699 00       		.byte	0
 11529 069a 00       		.byte	0
 11530 069b 00000000 		.space	5
 11530      00
 11533              	glProbeCtrlFull:
 11534 06a0 00       		.byte	0
 11535 06a1 00       		.byte	0
 11536 06a2 01       		.byte	1
 11537 06a3 01       		.byte	1
 11538 06a4 15       		.byte	21
 11539 06a5 16       		.byte	22
 11540 06a6 05       		.byte	5
 11541 06a7 00       		.byte	0
 11542 06a8 00       		.byte	0
 11543 06a9 00       		.byte	0
 11544 06aa 00       		.byte	0
 11545 06ab 00       		.byte	0
 11546 06ac 00       		.byte	0
 11547 06ad 00       		.byte	0
 11548 06ae 00       		.byte	0
 11549 06af 00       		.byte	0
 11550 06b0 00       		.byte	0
 11551 06b1 00       		.byte	0
 11552 06b2 00       		.byte	0
 11553 06b3 C6       		.byte	-58
 11554 06b4 99       		.byte	-103
 11555 06b5 00       		.byte	0
 11556 06b6 00       		.byte	0
 11557 06b7 40       		.byte	64
 11558 06b8 00       		.byte	0
 11559 06b9 00       		.byte	0
 11560 06ba 0000     		.space	2
 11563              	glProbeCtrl20:
 11564 06bc 00       		.byte	0
 11565 06bd 00       		.byte	0
 11566 06be 01       		.byte	1
 11567 06bf 01       		.byte	1
 11568 06c0 80       		.byte	-128
 11569 06c1 1A       		.byte	26
 11570 06c2 06       		.byte	6
 11571 06c3 00       		.byte	0
 11572 06c4 00       		.byte	0
 11573 06c5 00       		.byte	0
 11574 06c6 00       		.byte	0
 11575 06c7 00       		.byte	0
 11576 06c8 00       		.byte	0
 11577 06c9 00       		.byte	0
 11578 06ca 00       		.byte	0
 11579 06cb 00       		.byte	0
 11580 06cc 00       		.byte	0
 11581 06cd 00       		.byte	0
 11582 06ce 00       		.byte	0
 11583 06cf D2       		.byte	-46
 11584 06d0 0F       		.byte	15
 11585 06d1 00       		.byte	0
 11586 06d2 00       		.byte	0
 11587 06d3 40       		.byte	64
 11588 06d4 00       		.byte	0
 11589 06d5 00       		.byte	0
 11590 06d6 0000     		.space	2
 11593              	glProbeCtrl:
 11594 06d8 00       		.byte	0
 11595 06d9 00       		.byte	0
 11596 06da 01       		.byte	1
 11597 06db 01       		.byte	1
 11598 06dc 15       		.byte	21
 11599 06dd 16       		.byte	22
 11600 06de 05       		.byte	5
 11601 06df 00       		.byte	0
 11602 06e0 00       		.byte	0
 11603 06e1 00       		.byte	0
 11604 06e2 00       		.byte	0
 11605 06e3 00       		.byte	0
 11606 06e4 00       		.byte	0
 11607 06e5 00       		.byte	0
 11608 06e6 00       		.byte	0
 11609 06e7 00       		.byte	0
 11610 06e8 00       		.byte	0
 11611 06e9 00       		.byte	0
 11612 06ea 00       		.byte	0
 11613 06eb 48       		.byte	72
 11614 06ec 3F       		.byte	63
 11615 06ed 00       		.byte	0
 11616 06ee 00       		.byte	0
 11617 06ef 40       		.byte	64
 11618 06f0 00       		.byte	0
 11619 06f1 00       		.byte	0
 11620 06f2 0000     		.space	2
 11623              	glProbeStilCtrl:
 11624 06f4 01       		.byte	1
 11625 06f5 02       		.byte	2
 11626 06f6 00       		.byte	0
 11627 06f7 00       		.byte	0
 11628 06f8 C6       		.byte	-58
 11629 06f9 99       		.byte	-103
 11630 06fa 00       		.byte	0
 11631 06fb 00       		.byte	0
 11632 06fc 40       		.byte	64
 11633 06fd 00       		.byte	0
 11634 06fe 00       		.byte	0
 11635 06ff 00       		.space	1
 11638              	glProbeStilCtrl20:
 11639 0700 01       		.byte	1
 11640 0701 01       		.byte	1
 11641 0702 00       		.byte	0
 11642 0703 00       		.byte	0
 11643 0704 D2       		.byte	-46
 11644 0705 0F       		.byte	15
 11645 0706 00       		.byte	0
 11646 0707 00       		.byte	0
 11647 0708 40       		.byte	64
 11648 0709 00       		.byte	0
 11649 070a 00       		.byte	0
 11652              	snapButFlag:
 11653 070b 01       		.byte	1
 11656              	CyFxGpifTransition:
 11657 070c 0000     		.short	0
 11658 070e 5555     		.short	21845
 11659 0710 8888     		.short	-30584
 11660 0712 AAAA     		.short	-21846
 11661 0714 3333     		.short	13107
 11662 0716 0000     		.space	2
 11665              	CyFxGpifWavedata:
 11666 0718 0181731E 		.word	510886145
 11667 071c 00000000 		.word	0
 11668 0720 00000080 		.word	-2147483648
 11669 0724 00000000 		.word	0
 11670 0728 00000000 		.word	0
 11671 072c 00000000 		.word	0
 11672 0730 0201702E 		.word	779092226
 11673 0734 00010000 		.word	256
 11674 0738 A0000080 		.word	-2147483488
 11675 073c 00000000 		.word	0
 11676 0740 00000000 		.word	0
 11677 0744 00000000 		.word	0
 11678 0748 0380722E 		.word	779255811
 11679 074c 02010020 		.word	536871170
 11680 0750 60000080 		.word	-2147483552
 11681 0754 00000000 		.word	0
 11682 0758 00000000 		.word	0
 11683 075c 00000000 		.word	0
 11684 0760 0460722E 		.word	779247620
 11685 0764 02010024 		.word	603980034
 11686 0768 90000080 		.word	-2147483504
 11687 076c 0594731E 		.word	510891013
 11688 0770 06000000 		.word	6
 11689 0774 00000080 		.word	-2147483648
 11690 0778 0380722E 		.word	779255811
 11691 077c 02010020 		.word	536871170
 11692 0780 60000080 		.word	-2147483552
 11693 0784 0693731E 		.word	510890758
 11694 0788 06000000 		.word	6
 11695 078c 00000080 		.word	-2147483648
 11696 0790 0720703E 		.word	1047535623
 11697 0794 08010000 		.word	264
 11698 0798 00000080 		.word	-2147483648
 11699 079c 0820703E 		.word	1047535624
 11700 07a0 08010000 		.word	264
 11701 07a4 00000080 		.word	-2147483648
 11702 07a8 0920703E 		.word	1047535625
 11703 07ac 08010000 		.word	264
 11704 07b0 00000080 		.word	-2147483648
 11705 07b4 0A20703E 		.word	1047535626
 11706 07b8 08010000 		.word	264
 11707 07bc 00000080 		.word	-2147483648
 11708 07c0 0380722E 		.word	779255811
 11709 07c4 02010020 		.word	536871170
 11710 07c8 60000080 		.word	-2147483552
 11711 07cc 0B000000 		.word	11
 11712 07d0 00000000 		.word	0
 11713 07d4 00010080 		.word	-2147483392
 11714 07d8 0460722E 		.word	779247620
 11715 07dc 02010024 		.word	603980034
 11716 07e0 90000080 		.word	-2147483504
 11717 07e4 0D000000 		.word	13
 11718 07e8 00000000 		.word	0
 11719 07ec 00010080 		.word	-2147483392
 11720 07f0 0460722E 		.word	779247620
 11721 07f4 02010024 		.word	603980034
 11722 07f8 90000080 		.word	-2147483504
 11723 07fc 0C000000 		.word	12
 11724 0800 00000000 		.word	0
 11725 0804 00010080 		.word	-2147483392
 11726 0808 0380722E 		.word	779255811
 11727 080c 02010020 		.word	536871170
 11728 0810 60000080 		.word	-2147483552
 11729 0814 0E000000 		.word	14
 11730 0818 00000000 		.word	0
 11731 081c 00010080 		.word	-2147483392
 11732 0820 00000000 		.word	0
 11733 0824 00000000 		.word	0
 11734 0828 00000000 		.word	0
 11735 082c 00000000 		.word	0
 11736 0830 00000000 		.word	0
 11737 0834 00000000 		.word	0
 11740              	CyFxGpifWavedataPosition:
 11741 0838 00       		.byte	0
 11742 0839 01       		.byte	1
 11743 083a 02       		.byte	2
 11744 083b 03       		.byte	3
 11745 083c 04       		.byte	4
 11746 083d 05       		.byte	5
 11747 083e 06       		.byte	6
 11748 083f 07       		.byte	7
 11749 0840 08       		.byte	8
 11750 0841 09       		.byte	9
 11751 0842 0A       		.byte	10
 11752 0843 0B       		.byte	11
 11753 0844 0B       		.byte	11
 11754 0845 0B       		.byte	11
 11755 0846 0B       		.byte	11
 11756 0847 00       		.space	1
 11759              	CyFxGpifRegValue:
 11760 0848 08830080 		.word	-2147450104
 11761 084c 67000000 		.word	103
 11762 0850 00000000 		.word	0
 11763 0854 46000000 		.word	70
 11764 0858 00000000 		.word	0
 11765 085c 00000000 		.word	0
 11766 0860 02000000 		.word	2
 11767 0864 82000000 		.word	130
 11768 0868 82070000 		.word	1922
 11769 086c 40040000 		.word	1088
 11770 0870 FCFF0000 		.word	65532
 11771 0874 28000000 		.word	40
 11772 0878 00000000 		.word	0
 11773 087c 00000000 		.word	0
 11774 0880 00000000 		.word	0
 11775 0884 00000000 		.word	0
 11776 0888 01000000 		.word	1
 11777 088c 00000000 		.word	0
 11778 0890 00000000 		.word	0
 11779 0894 00000000 		.word	0
 11780 0898 00000000 		.word	0
 11781 089c 00000000 		.word	0
 11782 08a0 00000000 		.word	0
 11783 08a4 00000000 		.word	0
 11784 08a8 00000000 		.word	0
 11785 08ac 00000000 		.word	0
 11786 08b0 00000000 		.word	0
 11787 08b4 00000000 		.word	0
 11788 08b8 00000000 		.word	0
 11789 08bc 06000000 		.word	6
 11790 08c0 00000000 		.word	0
 11791 08c4 FFFF0000 		.word	65535
 11792 08c8 09010000 		.word	265
 11793 08cc 00000000 		.word	0
 11794 08d0 F71F0000 		.word	8183
 11795 08d4 00000000 		.word	0
 11796 08d8 FFFF0000 		.word	65535
 11797 08dc 09010000 		.word	265
 11798 08e0 00000000 		.word	0
 11799 08e4 F71F0000 		.word	8183
 11800 08e8 00000000 		.word	0
 11801 08ec 00000000 		.word	0
 11802 08f0 00000000 		.word	0
 11803 08f4 00000000 		.word	0
 11804 08f8 00000000 		.word	0
 11805 08fc 00000000 		.word	0
 11806 0900 00000000 		.word	0
 11807 0904 00000000 		.word	0
 11808 0908 00000000 		.word	0
 11809 090c 00000000 		.word	0
 11810 0910 00000000 		.word	0
 11811 0914 00000000 		.word	0
 11812 0918 00000000 		.word	0
 11813 091c 00000000 		.word	0
 11814 0920 00000000 		.word	0
 11815 0924 00000000 		.word	0
 11816 0928 00000000 		.word	0
 11817 092c 00000000 		.word	0
 11818 0930 00000000 		.word	0
 11819 0934 00000000 		.word	0
 11820 0938 00000000 		.word	0
 11821 093c 00000000 		.word	0
 11822 0940 00000000 		.word	0
 11823 0944 00040180 		.word	-2147417088
 11824 0948 01040180 		.word	-2147417087
 11825 094c 02040180 		.word	-2147417086
 11826 0950 03040180 		.word	-2147417085
 11827 0954 00000000 		.word	0
 11828 0958 00000000 		.word	0
 11829 095c 00000000 		.word	0
 11830 0960 00000000 		.word	0
 11831 0964 00000000 		.word	0
 11832 0968 00000000 		.word	0
 11833 096c 00000000 		.word	0
 11834 0970 00000000 		.word	0
 11835 0974 C1FFFFFF 		.word	-63
 11838              	CyFxGpifTransition_usb2:
 11839 0978 0000     		.short	0
 11840 097a 5555     		.short	21845
 11841 097c AAAA     		.short	-21846
 11842 097e 8888     		.short	-30584
 11843 0980 1111     		.short	4369
 11844 0982 4444     		.short	17476
 11845 0984 3333     		.short	13107
 11846 0986 CCCC     		.short	-13108
 11849              	CyFxGpifWavedata_usb2:
 11850 0988 0181731E 		.word	510886145
 11851 098c 00000000 		.word	0
 11852 0990 00000080 		.word	-2147483648
 11853 0994 00000000 		.word	0
 11854 0998 00000000 		.word	0
 11855 099c 00000000 		.word	0
 11856 09a0 0201703E 		.word	1047527682
 11857 09a4 00010000 		.word	256
 11858 09a8 A00000C0 		.word	-1073741664
 11859 09ac 00000000 		.word	0
 11860 09b0 00000000 		.word	0
 11861 09b4 00000000 		.word	0
 11862 09b8 0394731E 		.word	510891011
 11863 09bc 04000020 		.word	536870916
 11864 09c0 60004080 		.word	-2143289248
 11865 09c4 00000000 		.word	0
 11866 09c8 00000000 		.word	0
 11867 09cc 00000000 		.word	0
 11868 09d0 0620702E 		.word	779100166
 11869 09d4 0C000000 		.word	12
 11870 09d8 00000080 		.word	-2147483648
 11871 09dc 0620702E 		.word	779100166
 11872 09e0 0C000000 		.word	12
 11873 09e4 00000080 		.word	-2147483648
 11874 09e8 0394731E 		.word	510891011
 11875 09ec 04000020 		.word	536870916
 11876 09f0 60004080 		.word	-2143289248
 11877 09f4 0620702E 		.word	779100166
 11878 09f8 0C000000 		.word	12
 11879 09fc 00000080 		.word	-2147483648
 11880 0a00 0C93731E 		.word	510890764
 11881 0a04 04000024 		.word	603979780
 11882 0a08 90004080 		.word	-2143289200
 11883 0a0c 0D20702E 		.word	779100173
 11884 0a10 0C000000 		.word	12
 11885 0a14 00000080 		.word	-2147483648
 11886 0a18 0780724E 		.word	1316126727
 11887 0a1c 0A000000 		.word	10
 11888 0a20 00000080 		.word	-2147483648
 11889 0a24 08000000 		.word	8
 11890 0a28 00000000 		.word	0
 11891 0a2c 00010080 		.word	-2147483392
 11892 0a30 0920702E 		.word	779100169
 11893 0a34 0C010000 		.word	268
 11894 0a38 00000080 		.word	-2147483648
 11895 0a3c 0A01701E 		.word	510656778
 11896 0a40 0E000100 		.word	65550
 11897 0a44 00000080 		.word	-2147483648
 11898 0a48 00000000 		.word	0
 11899 0a4c 00000000 		.word	0
 11900 0a50 00000000 		.word	0
 11901 0a54 00000000 		.word	0
 11902 0a58 00000000 		.word	0
 11903 0a5c 00000000 		.word	0
 11904 0a60 0394731E 		.word	510891011
 11905 0a64 04000020 		.word	536870916
 11906 0a68 60004080 		.word	-2143289248
 11907 0a6c 08000000 		.word	8
 11908 0a70 00000000 		.word	0
 11909 0a74 00010080 		.word	-2147483392
 11910 0a78 0B000000 		.word	11
 11911 0a7c 00000000 		.word	0
 11912 0a80 00010080 		.word	-2147483392
 11913 0a84 0C93731E 		.word	510890764
 11914 0a88 04000024 		.word	603979780
 11915 0a8c 90004080 		.word	-2143289200
 11916 0a90 0D20702E 		.word	779100173
 11917 0a94 0C000000 		.word	12
 11918 0a98 00000080 		.word	-2147483648
 11919 0a9c 0D20702E 		.word	779100173
 11920 0aa0 0C000000 		.word	12
 11921 0aa4 00000080 		.word	-2147483648
 11922 0aa8 0E60724E 		.word	1316118542
 11923 0aac 0A000000 		.word	10
 11924 0ab0 00000080 		.word	-2147483648
 11925 0ab4 0F000000 		.word	15
 11926 0ab8 00000000 		.word	0
 11927 0abc 00010080 		.word	-2147483392
 11928 0ac0 1020702E 		.word	779100176
 11929 0ac4 0C010000 		.word	268
 11930 0ac8 00000080 		.word	-2147483648
 11931 0acc 1101701E 		.word	510656785
 11932 0ad0 0E000100 		.word	65550
 11933 0ad4 00000080 		.word	-2147483648
 11934 0ad8 0C93731E 		.word	510890764
 11935 0adc 04000024 		.word	603979780
 11936 0ae0 90004080 		.word	-2143289200
 11937 0ae4 0F000000 		.word	15
 11938 0ae8 00000000 		.word	0
 11939 0aec 00010080 		.word	-2147483392
 11940 0af0 12000000 		.word	18
 11941 0af4 00000000 		.word	0
 11942 0af8 00010080 		.word	-2147483392
 11943 0afc 0394731E 		.word	510891011
 11944 0b00 04000020 		.word	536870916
 11945 0b04 60004080 		.word	-2143289248
 11946 0b08 0480732E 		.word	779321348
 11947 0b0c 02010000 		.word	258
 11948 0b10 0000C0C0 		.word	-1061158912
 11949 0b14 0580732E 		.word	779321349
 11950 0b18 02010000 		.word	258
 11951 0b1c 0000C0C0 		.word	-1061158912
 11952 0b20 0580732E 		.word	779321349
 11953 0b24 02010000 		.word	258
 11954 0b28 0000C0C0 		.word	-1061158912
 11955 0b2c 0480732E 		.word	779321348
 11956 0b30 02010000 		.word	258
 11957 0b34 0000C0C0 		.word	-1061158912
 11960              	CyFxGpifWavedataPosition_usb2:
 11961 0b38 00       		.byte	0
 11962 0b39 01       		.byte	1
 11963 0b3a 02       		.byte	2
 11964 0b3b 03       		.byte	3
 11965 0b3c 04       		.byte	4
 11966 0b3d 05       		.byte	5
 11967 0b3e 06       		.byte	6
 11968 0b3f 07       		.byte	7
 11969 0b40 08       		.byte	8
 11970 0b41 09       		.byte	9
 11971 0b42 0A       		.byte	10
 11972 0b43 08       		.byte	8
 11973 0b44 0B       		.byte	11
 11974 0b45 0C       		.byte	12
 11975 0b46 0D       		.byte	13
 11976 0b47 08       		.byte	8
 11977 0b48 0E       		.byte	14
 11978 0b49 0F       		.byte	15
 11979 0b4a 08       		.byte	8
 11980 0b4b 08       		.byte	8
 11981 0b4c 08       		.byte	8
 11982 0b4d 08       		.byte	8
 11983 0b4e 08       		.byte	8
 11984 0b4f 08       		.byte	8
 11985 0b50 08       		.byte	8
 11986 0b51 08       		.byte	8
 11987 0b52 08       		.byte	8
 11988 0b53 08       		.byte	8
 11989 0b54 08       		.byte	8
 11990 0b55 08       		.byte	8
 11991 0b56 08       		.byte	8
 11992 0b57 08       		.byte	8
 11993 0b58 08       		.byte	8
 11994 0b59 08       		.byte	8
 11995 0b5a 08       		.byte	8
 11996 0b5b 08       		.byte	8
 11997 0b5c 08       		.byte	8
 11998 0b5d 08       		.byte	8
 11999 0b5e 08       		.byte	8
 12000 0b5f 08       		.byte	8
 12001 0b60 08       		.byte	8
 12002 0b61 08       		.byte	8
 12003 0b62 08       		.byte	8
 12004 0b63 08       		.byte	8
 12005 0b64 08       		.byte	8
 12006 0b65 08       		.byte	8
 12007 0b66 08       		.byte	8
 12008 0b67 08       		.byte	8
 12009 0b68 08       		.byte	8
 12010 0b69 08       		.byte	8
 12011 0b6a 08       		.byte	8
 12012 0b6b 08       		.byte	8
 12013 0b6c 08       		.byte	8
 12014 0b6d 08       		.byte	8
 12015 0b6e 08       		.byte	8
 12016 0b6f 08       		.byte	8
 12017 0b70 08       		.byte	8
 12018 0b71 08       		.byte	8
 12019 0b72 08       		.byte	8
 12020 0b73 08       		.byte	8
 12021 0b74 08       		.byte	8
 12022 0b75 08       		.byte	8
 12023 0b76 08       		.byte	8
 12024 0b77 08       		.byte	8
 12025 0b78 08       		.byte	8
 12026 0b79 08       		.byte	8
 12027 0b7a 08       		.byte	8
 12028 0b7b 08       		.byte	8
 12029 0b7c 08       		.byte	8
 12030 0b7d 08       		.byte	8
 12031 0b7e 08       		.byte	8
 12032 0b7f 08       		.byte	8
 12033 0b80 08       		.byte	8
 12034 0b81 08       		.byte	8
 12035 0b82 08       		.byte	8
 12036 0b83 08       		.byte	8
 12037 0b84 08       		.byte	8
 12038 0b85 08       		.byte	8
 12039 0b86 08       		.byte	8
 12040 0b87 08       		.byte	8
 12041 0b88 08       		.byte	8
 12042 0b89 08       		.byte	8
 12043 0b8a 08       		.byte	8
 12044 0b8b 08       		.byte	8
 12045 0b8c 08       		.byte	8
 12046 0b8d 08       		.byte	8
 12047 0b8e 08       		.byte	8
 12048 0b8f 08       		.byte	8
 12049 0b90 08       		.byte	8
 12050 0b91 08       		.byte	8
 12051 0b92 08       		.byte	8
 12052 0b93 08       		.byte	8
 12053 0b94 08       		.byte	8
 12054 0b95 08       		.byte	8
 12055 0b96 08       		.byte	8
 12056 0b97 08       		.byte	8
 12057 0b98 08       		.byte	8
 12058 0b99 08       		.byte	8
 12059 0b9a 08       		.byte	8
 12060 0b9b 08       		.byte	8
 12061 0b9c 08       		.byte	8
 12062 0b9d 08       		.byte	8
 12063 0b9e 08       		.byte	8
 12064 0b9f 08       		.byte	8
 12065 0ba0 08       		.byte	8
 12066 0ba1 08       		.byte	8
 12067 0ba2 08       		.byte	8
 12068 0ba3 08       		.byte	8
 12069 0ba4 08       		.byte	8
 12070 0ba5 08       		.byte	8
 12071 0ba6 08       		.byte	8
 12072 0ba7 08       		.byte	8
 12073 0ba8 08       		.byte	8
 12074 0ba9 08       		.byte	8
 12075 0baa 08       		.byte	8
 12076 0bab 08       		.byte	8
 12077 0bac 08       		.byte	8
 12078 0bad 08       		.byte	8
 12079 0bae 08       		.byte	8
 12080 0baf 08       		.byte	8
 12081 0bb0 08       		.byte	8
 12082 0bb1 08       		.byte	8
 12083 0bb2 08       		.byte	8
 12084 0bb3 08       		.byte	8
 12085 0bb4 08       		.byte	8
 12086 0bb5 08       		.byte	8
 12087 0bb6 08       		.byte	8
 12088 0bb7 08       		.byte	8
 12089 0bb8 00       		.byte	0
 12090 0bb9 01       		.byte	1
 12091 0bba 02       		.byte	2
 12092 0bbb 10       		.byte	16
 12093 0bbc 04       		.byte	4
 12094 0bbd 05       		.byte	5
 12095 0bbe 06       		.byte	6
 12096 0bbf 07       		.byte	7
 12097 0bc0 08       		.byte	8
 12098 0bc1 09       		.byte	9
 12099 0bc2 0A       		.byte	10
 12100 0bc3 08       		.byte	8
 12101 0bc4 11       		.byte	17
 12102 0bc5 0C       		.byte	12
 12103 0bc6 0D       		.byte	13
 12104 0bc7 08       		.byte	8
 12105 0bc8 0E       		.byte	14
 12106 0bc9 0F       		.byte	15
 12107 0bca 08       		.byte	8
 12108 0bcb 00       		.space	1
 12111              	CyFxGpifRegValue_usb2:
 12112 0bcc 08830080 		.word	-2147450104
 12113 0bd0 67000000 		.word	103
 12114 0bd4 01000000 		.word	1
 12115 0bd8 46000000 		.word	70
 12116 0bdc 00000000 		.word	0
 12117 0be0 00000000 		.word	0
 12118 0be4 02000000 		.word	2
 12119 0be8 82000000 		.word	130
 12120 0bec 82070000 		.word	1922
 12121 0bf0 40040000 		.word	1088
 12122 0bf4 FCFF0000 		.word	65532
 12123 0bf8 28000000 		.word	40
 12124 0bfc 00000000 		.word	0
 12125 0c00 00000000 		.word	0
 12126 0c04 00000000 		.word	0
 12127 0c08 00000000 		.word	0
 12128 0c0c 01000000 		.word	1
 12129 0c10 00000000 		.word	0
 12130 0c14 00000000 		.word	0
 12131 0c18 00000000 		.word	0
 12132 0c1c 00000000 		.word	0
 12133 0c20 00000000 		.word	0
 12134 0c24 00000000 		.word	0
 12135 0c28 00000000 		.word	0
 12136 0c2c 00000000 		.word	0
 12137 0c30 00000000 		.word	0
 12138 0c34 00000000 		.word	0
 12139 0c38 00000000 		.word	0
 12140 0c3c 00000000 		.word	0
 12141 0c40 06000000 		.word	6
 12142 0c44 00000000 		.word	0
 12143 0c48 FFFF0000 		.word	65535
 12144 0c4c 09010000 		.word	265
 12145 0c50 00000000 		.word	0
 12146 0c54 F71F0000 		.word	8183
 12147 0c58 00000000 		.word	0
 12148 0c5c FFFF0000 		.word	65535
 12149 0c60 09010000 		.word	265
 12150 0c64 00000000 		.word	0
 12151 0c68 F71F0000 		.word	8183
 12152 0c6c 00000000 		.word	0
 12153 0c70 00000000 		.word	0
 12154 0c74 00000000 		.word	0
 12155 0c78 00000000 		.word	0
 12156 0c7c 00000000 		.word	0
 12157 0c80 00000000 		.word	0
 12158 0c84 00000000 		.word	0
 12159 0c88 00000000 		.word	0
 12160 0c8c 00000000 		.word	0
 12161 0c90 00000000 		.word	0
 12162 0c94 00000000 		.word	0
 12163 0c98 00000000 		.word	0
 12164 0c9c 00000000 		.word	0
 12165 0ca0 00000000 		.word	0
 12166 0ca4 00000000 		.word	0
 12167 0ca8 00000000 		.word	0
 12168 0cac 00000000 		.word	0
 12169 0cb0 00000000 		.word	0
 12170 0cb4 00000000 		.word	0
 12171 0cb8 00000000 		.word	0
 12172 0cbc 00000000 		.word	0
 12173 0cc0 00000000 		.word	0
 12174 0cc4 00000000 		.word	0
 12175 0cc8 00040180 		.word	-2147417088
 12176 0ccc 01040180 		.word	-2147417087
 12177 0cd0 02040180 		.word	-2147417086
 12178 0cd4 03040180 		.word	-2147417085
 12179 0cd8 00000000 		.word	0
 12180 0cdc 00000000 		.word	0
 12181 0ce0 00000000 		.word	0
 12182 0ce4 00000000 		.word	0
 12183 0ce8 00000000 		.word	0
 12184 0cec 00000000 		.word	0
 12185 0cf0 00000000 		.word	0
 12186 0cf4 00000000 		.word	0
 12187 0cf8 C1FFFFFF 		.word	-63
 12188              		.section	.rodata.str1.4,"aMS",%progbits,1
 12189              		.align	2
 12190              	.LC0:
 12191 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 12191      7065722D 
 12191      74696D65 
 12191      72202564 
 12191      0D0A00
 12192 0013 00       		.space	1
 12193              	.LC1:
 12194 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 12194      636F6D6D 
 12194      616E6420 
 12194      71756575 
 12194      65206973 
 12195 0037 00       		.space	1
 12196              	.LC2:
 12197 0038 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 12197      706F732D 
 12197      74696D65 
 12197      72202564 
 12197      2025640D 
 12198 004e 0000     		.space	2
 12199              	.LC3:
 12200 0050 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 12200      5420656E 
 12200      636F756E 
 12200      74657265 
 12200      642E2E2E 
 12201              	.LC4:
 12202 0070 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 12202      454E4420 
 12202      656E636F 
 12202      756E7465 
 12202      7265642E 
 12203 0092 0000     		.space	2
 12204              	.LC5:
 12205 0094 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 12205      64697363 
 12205      6F6E6E65 
 12205      63746564 
 12205      2E2E2E30 
 12206 00b3 00       		.space	1
 12207              	.LC6:
 12208 00b4 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 12208      7220696E 
 12208      206D756C 
 12208      74696368 
 12208      616E6E65 
 12209 00e7 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 12209      2025782C 
 12209      20646D61 
 12209      446F6E65 
 12209      20256420 
 12210              	.LC7:
 12211 0100 626D5265 		.ascii	"bmReqType = 0x%x bRequest = 0x%x wValue = 0x%x wInd"
 12211      71547970 
 12211      65203D20 
 12211      30782578 
 12211      20625265 
 12212 0133 6578203D 		.ascii	"ex = 0x%x wLength = 0x%x isflag 0x%x\015\012\000"
 12212      20307825 
 12212      7820774C 
 12212      656E6774 
 12212      68203D20 
 12213 015a 0000     		.space	2
 12214              	.LC8:
 12215 015c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 12215      43595F46 
 12215      585F5556 
 12215      435F5649 
 12215      44454F5F 
 12216 018f 0A00     		.ascii	"\012\000"
 12217 0191 000000   		.space	3
 12218              	.LC9:
 12219 0194 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 12219      43595F46 
 12219      585F5556 
 12219      435F5649 
 12219      44454F5F 
 12220 01c7 00       		.ascii	"\000"
 12221              	.LC10:
 12222 01c8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 12222      726E6174 
 12222      65207365 
 12222      7474696E 
 12222      6720302E 
 12223              	.LC11:
 12224 01e0 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 12224      72206665 
 12224      61747572 
 12224      65207265 
 12224      71756573 
 12225 0203 00       		.space	1
 12226              	.LC12:
 12227 0204 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 12227      6F6D6D69 
 12227      74656F66 
 12227      20737461 
 12227      7465203D 
 12228              	.LC13:
 12229 021c 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 12229      6E656C20 
 12229      53657420 
 12229      57726170 
 12229      55702066 
 12230 0249 000000   		.space	3
 12231              	.LC14:
 12232 024c 4572726F 		.ascii	"Error handler...\015\012\000"
 12232      72206861 
 12232      6E646C65 
 12232      722E2E2E 
 12232      0D0A00
 12233 025f 00       		.space	1
 12234              	.LC15:
 12235 0260 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 12235      69742045 
 12235      4F462066 
 12235      61696C65 
 12235      64210D0A 
 12236 0275 000000   		.space	3
 12237              	.LC16:
 12238 0278 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 12238      49324320 
 12238      636F6D6D 
 12238      616E6420 
 12238      69732030 
 12239 02ab 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12239      78257820 
 12239      30782578 
 12239      20307825 
 12239      78203078 
 12240              	.LC17:
 12241 02c4 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 12241      49324320 
 12241      636F6D6D 
 12241      616E6420 
 12241      73657474 
 12242 02ea 0000     		.space	2
 12243              	.LC18:
 12244 02ec 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 12244      43595F46 
 12244      585F5556 
 12244      435F5354 
 12244      5245414D 
 12245 0312 0000     		.space	2
 12246              	.LC19:
 12247 0314 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 12247      73687574 
 12247      74657220 
 12247      73657420 
 12247      76616C75 
 12248 033e 0000     		.space	2
 12249              	.LC20:
 12250 0340 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 12250      20736875 
 12250      74746572 
 12250      20737065 
 12250      65642E20 
 12251 0365 000000   		.space	3
 12252              	.LC21:
 12253 0368 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 12253      20736875 
 12253      74746572 
 12253      20737065 
 12253      6564322E 
 12254 038e 0000     		.space	2
 12255              	.LC22:
 12256 0390 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 12256      206C6967 
 12256      68742063 
 12256      6F6D7065 
 12256      6E736174 
 12257 03c3 25640D0A 		.ascii	"%d\015\012\000"
 12257      00
 12258              	.LC23:
 12259 03c8 54686520 		.ascii	"The I2C current data is not available. try again. %"
 12259      49324320 
 12259      63757272 
 12259      656E7420 
 12259      64617461 
 12260 03fb 64202564 		.ascii	"d %d\015\012\000"
 12260      0D0A00
 12261 0402 0000     		.space	2
 12262              	.LC24:
 12263 0404 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 12263      26414743 
 12263      2073656E 
 12263      7420746F 
 12263      20686F73 
 12264 042a 0000     		.space	2
 12265              	.LC25:
 12266 042c 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 12266      73687574 
 12266      74657226 
 12266      6578706F 
 12266      73757265 
 12267 0457 00       		.space	1
 12268              	.LC26:
 12269 0458 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 12269      26414743 
 12269      20676F74 
 12269      74656E20 
 12269      66726F6D 
 12270 0489 0A00     		.ascii	"\012\000"
 12271 048b 00       		.space	1
 12272              	.LC27:
 12273 048c 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 12273      74657220 
 12273      6C657665 
 12273      6C20676F 
 12273      7474656E 
 12274 04bf 25640D0A 		.ascii	"%d\015\012\000"
 12274      00
 12275              	.LC28:
 12276 04c4 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 12276      75656E63 
 12276      79207365 
 12276      7474696E 
 12276      67206973 
 12277 04e2 0000     		.space	2
 12278              	.LC29:
 12279 04e4 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 12279      20746865 
 12279      20766964 
 12279      656F206D 
 12279      6F646520 
 12280 0506 0000     		.space	2
 12281              	.LC30:
 12282 0508 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 12282      67657420 
 12282      64617461 
 12282      2066726F 
 12282      6D20686F 
 12283 0535 000000   		.space	3
 12284              	.LC31:
 12285 0538 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 12285      52657175 
 12285      65737420 
 12285      30782578 
 12285      20706172 
 12286 056b 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 12286      6E642074 
 12286      6F20686F 
 12286      73742030 
 12286      78257820 
 12287 0586 0000     		.space	2
 12288              	.LC32:
 12289 0588 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 12289      204F7020 
 12289      72656365 
 12289      69766573 
 12289      20284354 
 12290 05af 00       		.space	1
 12291              	.LC33:
 12292 05b0 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 12292      756C7420 
 12292      73656C65 
 12292      63746F72 
 12292      20284354 
 12293 05d2 0000     		.space	2
 12294              	.LC34:
 12295 05d4 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 12295      756C7420 
 12295      72657175 
 12295      65737420 
 12295      28435429 
 12296 05f5 000000   		.space	3
 12297              	.LC35:
 12298 05f8 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 12298      52657175 
 12298      65737420 
 12298      30782578 
 12298      20706172 
 12299 062b 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 12299      20307825 
 12299      78202F20 
 12299      73656E64 
 12299      20746F20 
 12300 0658 00       		.ascii	"\000"
 12301 0659 000000   		.space	3
 12302              	.LC36:
 12303 065c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 12303      64656661 
 12303      756C7420 
 12303      73657475 
 12303      70207265 
 12304              	.LC37:
 12305 0688 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 12305      6F207374 
 12305      7265616D 
 12305      20474554 
 12305      20726571 
 12306 06ad 000000   		.space	3
 12307              	.LC38:
 12308 06b0 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 12308      74686520 
 12308      76696465 
 12308      6F206D6F 
 12308      64652066 
 12309 06d1 000000   		.space	3
 12310              	.LC39:
 12311 06d4 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 12311      74686520 
 12311      76696465 
 12311      6F206D6F 
 12311      64652066 
 12312 06f9 000000   		.space	3
 12313              	.LC40:
 12314 06fc 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 12314      55564320 
 12314      7374696C 
 12314      6C205072 
 12314      6F622873 
 12315 0727 00       		.space	1
 12316              	.LC41:
 12317 0728 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 12317      74686520 
 12317      7374696C 
 12317      6C206D6F 
 12317      64652066 
 12318 0749 000000   		.space	3
 12319              	.LC42:
 12320 074c 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 12320      7374696C 
 12320      6C20636F 
 12320      6D6D6974 
 12320      20636F6E 
 12321              	.LC43:
 12322 0774 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 12322      43595F46 
 12322      585F5556 
 12322      435F5354 
 12322      494C5F45 
 12323              	.LC44:
 12324 0798 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 12324      55564320 
 12324      7374696C 
 12324      6C207472 
 12324      69676765 
 12325 07c1 000000   		.space	3
 12326              	.LC45:
 12327 07c4 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 12327      7374696C 
 12327      6C207472 
 12327      69676765 
 12327      7220636F 
 12328 07eb 00       		.space	1
 12329              	.LC46:
 12330 07ec 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 12330      65642074 
 12330      6F207365 
 12330      6E642069 
 12330      6E746572 
 12331 081d 0A00     		.ascii	"\012\000"
 12332 081f 00       		.space	1
 12333              	.LC47:
 12334 0820 4661696C 		.ascii	"Failed to receive debug command, Error code = %d\015"
 12334      65642074 
 12334      6F207265 
 12334      63656976 
 12334      65206465 
 12335 0851 0A00     		.ascii	"\012\000"
 12336 0853 00       		.space	1
 12337              	.LC48:
 12338 0854 44656275 		.ascii	"Debug interface conut %d data %d %d %d\015\012\000"
 12338      6720696E 
 12338      74657266 
 12338      61636520 
 12338      636F6E75 
 12339 087d 000000   		.space	3
 12340              	.LC49:
 12341 0880 44656275 		.ascii	"Debug responsR conut %d data %d %d %d\015\012\000"
 12341      67207265 
 12341      73706F6E 
 12341      73522063 
 12341      6F6E7574 
 12342              	.LC50:
 12343 08a8 44656275 		.ascii	"Debug write %d data %d %d %d\015\012\000"
 12343      67207772 
 12343      69746520 
 12343      25642064 
 12343      61746120 
 12344 08c7 00       		.space	1
 12345              	.LC51:
 12346 08c8 44656275 		.ascii	"Debug respons conut %d data %d %d %d\015\012\000"
 12346      67207265 
 12346      73706F6E 
 12346      7320636F 
 12346      6E757420 
 12347 08ef 00       		.space	1
 12348              	.LC52:
 12349 08f0 4661696C 		.ascii	"Failed to free up command OUT EP buffer, Error code"
 12349      65642074 
 12349      6F206672 
 12349      65652075 
 12349      7020636F 
 12350 0923 203D2025 		.ascii	" = %d\015\012\000"
 12350      640D0A00 
 12351 092b 00       		.space	1
 12352              	.LC53:
 12353 092c 4661696C 		.ascii	"Failed to send debug response, Error code = %d\015\012"
 12353      65642074 
 12353      6F207365 
 12353      6E642064 
 12353      65627567 
 12354 095c 00       		.ascii	"\000"
 12355 095d 000000   		.space	3
 12356              	.LC54:
 12357 0960 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 12357      73657420 
 12357      64656620 
 12357      64617461 
 12357      20307825 
 12358 097f 00       		.space	1
 12359              	.LC55:
 12360 0980 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 12360      73657420 
 12360      64656620 
 12360      64617461 
 12360      20307825 
 12361 09b3 2E0D0A00 		.ascii	".\015\012\000"
 12362 09b7 00       		.space	1
 12363              	.LC56:
 12364 09b8 55415254 		.ascii	"UART initialization failed!\012\000"
 12364      20696E69 
 12364      7469616C 
 12364      697A6174 
 12364      696F6E20 
 12365 09d5 000000   		.space	3
 12366              	.LC57:
 12367 09d8 49324320 		.ascii	"I2C initialization failed!\012\000"
 12367      696E6974 
 12367      69616C69 
 12367      7A617469 
 12367      6F6E2066 
 12368              	.LC58:
 12369 09f4 49324320 		.ascii	"I2C configuration failed!\012\000"
 12369      636F6E66 
 12369      69677572 
 12369      6174696F 
 12369      6E206661 
 12370 0a0f 00       		.space	1
 12371              	.LC59:
 12372 0a10 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 12372      43726561 
 12372      74652045 
 12372      76656E74 
 12372      20666169 
 12373 0a3a 0000     		.space	2
 12374              	.LC60:
 12375 0a3c 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 12375      20496E69 
 12375      74206661 
 12375      696C6564 
 12375      2C204572 
 12376 0a5f 00       		.space	1
 12377              	.LC61:
 12378 0a60 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 12378      204F7665 
 12378      72726964 
 12378      65206661 
 12378      696C6564 
 12379 0a87 00       		.space	1
 12380              	.LC62:
 12381 0a88 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 12381      28323029 
 12381      204F7665 
 12381      72726964 
 12381      65206661 
 12382 0ab3 00       		.space	1
 12383              	.LC63:
 12384 0ab4 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 12384      28323429 
 12384      204F7665 
 12384      72726964 
 12384      65206661 
 12385 0adf 00       		.space	1
 12386              	.LC64:
 12387 0ae0 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 12387      20536574 
 12387      20287265 
 12387      73657420 
 12387      32322920 
 12388 0b12 00       		.ascii	"\000"
 12389 0b13 00       		.space	1
 12390              	.LC65:
 12391 0b14 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 12391      20536574 
 12391      2028706F 
 12391      77657220 
 12391      32302920 
 12392 0b46 00       		.ascii	"\000"
 12393 0b47 00       		.space	1
 12394              	.LC66:
 12395 0b48 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 12395      20536574 
 12395      2028736E 
 12395      61702073 
 12395      686F7420 
 12396 0b7b 25640A00 		.ascii	"%d\012\000"
 12397 0b7f 00       		.space	1
 12398              	.LC67:
 12399 0b80 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 12399      46756E63 
 12399      74696F6E 
 12399      20466169 
 12399      6C656420 
 12400 0baf 00       		.space	1
 12401              	.LC68:
 12402 0bb0 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 12402      46756E63 
 12402      74696F6E 
 12402      20466169 
 12402      6C656420 
 12403 0bdf 00       		.space	1
 12404              	.LC69:
 12405 0be0 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 12405      53657420 
 12405      456E6470 
 12405      6F696E74 
 12405      20636F6E 
 12406 0c10 00       		.ascii	"\000"
 12407 0c11 000000   		.space	3
 12408              	.LC70:
 12409 0c14 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 12409      496E7465 
 12409      72727570 
 12409      74205374 
 12409      61747573 
 12410 0c47 20436F64 		.ascii	" Code = %d\012\000"
 12410      65203D20 
 12410      25640A00 
 12411 0c53 00       		.space	1
 12412              	.LC71:
 12413 0c54 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 12413      65642074 
 12413      6F20616C 
 12413      6C6F6361 
 12413      7465206D 
 12414 0c87 65720D0A 		.ascii	"er\015\012\000"
 12414      00
 12415              	.LC72:
 12416 0c8c 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 12416      4368616E 
 12416      6E656C20 
 12416      43726561 
 12416      74696F6E 
 12417 0cba 0000     		.space	2
 12418              	.LC73:
 12419 0cbc 44656275 		.ascii	"Debug Command endpoint config failed, Error code = "
 12419      6720436F 
 12419      6D6D616E 
 12419      6420656E 
 12419      64706F69 
 12420 0cef 25640A00 		.ascii	"%d\012\000"
 12421 0cf3 00       		.space	1
 12422              	.LC74:
 12423 0cf4 44656275 		.ascii	"Debug Response endpoint config failed, Error code ="
 12423      67205265 
 12423      73706F6E 
 12423      73652065 
 12423      6E64706F 
 12424 0d27 2025640A 		.ascii	" %d\012\000"
 12424      00
 12425              	.LC75:
 12426 0d2c 44656275 		.ascii	"Debug Command channel create failed, Error code = %"
 12426      6720436F 
 12426      6D6D616E 
 12426      64206368 
 12426      616E6E65 
 12427 0d5f 640A00   		.ascii	"d\012\000"
 12428 0d62 0000     		.space	2
 12429              	.LC76:
 12430 0d64 44656275 		.ascii	"Debug channel SetXfer failed, Error code = %d\012\000"
 12430      67206368 
 12430      616E6E65 
 12430      6C205365 
 12430      74586665 
 12431 0d93 00       		.space	1
 12432              	.LC77:
 12433 0d94 44656275 		.ascii	"Debug Response channel create failed, Error code = "
 12433      67205265 
 12433      73706F6E 
 12433      73652063 
 12433      68616E6E 
 12434 0dc7 25640A00 		.ascii	"%d\012\000"
 12435 0dcb 00       		.space	1
 12436              	.LC78:
 12437 0dcc 4661696C 		.ascii	"Failed to allocate memory for debug buffer\015\012\000"
 12437      65642074 
 12437      6F20616C 
 12437      6C6F6361 
 12437      7465206D 
 12438 0df9 000000   		.space	3
 12439              	.LC79:
 12440 0dfc 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 12440      436F6E6E 
 12440      65637420 
 12440      6661696C 
 12440      65642C20 
 12441 0e21 000000   		.space	3
 12442              	.LC80:
 12443 0e24 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 12443      74686520 
 12443      76696465 
 12443      6F206D6F 
 12443      64652066 
 12444 0e46 0000     		.space	2
 12445              	.LC81:
 12446 0e48 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 12446      4368616E 
 12446      6E656C20 
 12446      52657365 
 12446      74204661 
 12447 0e73 00       		.space	1
 12448              	.LC82:
 12449 0e74 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 12449      4368616E 
 12449      6E656C20 
 12449      53657420 
 12449      5472616E 
 12450 0ea5 00       		.ascii	"\000"
 12451 0ea6 0000     		.space	2
 12452              	.LC83:
 12453 0ea8 70726520 		.ascii	"pre wait stream set %x\012\000"
 12453      77616974 
 12453      20737472 
 12453      65616D20 
 12453      73657420 
 12454              	.LC84:
 12455 0ec0 706F7374 		.ascii	"post wait stream set %x\012\000"
 12455      20776169 
 12455      74207374 
 12455      7265616D 
 12455      20736574 
 12456 0ed9 000000   		.space	3
 12457              	.LC85:
 12458 0edc 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 12458      4368616E 
 12458      6E656C20 
 12458      53657420 
 12458      5472616E 
 12459 0f0d 0A00     		.ascii	"\012\000"
 12460 0f0f 00       		.space	1
 12461              	.LC86:
 12462 0f10 0D0A2073 		.ascii	"\015\012 super gpif\000"
 12462      75706572 
 12462      20677069 
 12462      6600
 12463 0f1e 0000     		.space	2
 12464              	.LC87:
 12465 0f20 0D0A2068 		.ascii	"\015\012 high gpif\000"
 12465      69676820 
 12465      67706966 
 12465      00
 12466 0f2d 000000   		.space	3
 12467              	.LC88:
 12468 0f30 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 12468      696E6720 
 12468      47504946 
 12468      20436F6E 
 12468      66696775 
 12469 0f63 0A00     		.ascii	"\012\000"
 12470 0f65 000000   		.space	3
 12471              	.LC89:
 12472 0f68 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 12472      74696E67 
 12472      20475049 
 12472      46207374 
 12472      61746520 
 12473 0f9b 0D0A00   		.ascii	"\015\012\000"
 12474 0f9e 0000     		.space	2
 12475              	.LC90:
 12476 0fa0 49324363 		.ascii	"I2CcmdQue\000"
 12476      6D645175 
 12476      6500
 12477 0faa 0000     		.space	2
 12478              	.LC91:
 12479 0fac 33303A55 		.ascii	"30:UVC App Thread\000"
 12479      56432041 
 12479      70702054 
 12479      68726561 
 12479      6400
 12480 0fbe 0000     		.space	2
 12481              	.LC92:
 12482 0fc0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 12482      56432041 
 12482      70702045 
 12482      50302054 
 12482      68726561 
 12483 0fd6 0000     		.space	2
 12484              	.LC93:
 12485 0fd8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 12485      32432041 
 12485      70702043 
 12485      54524C20 
 12485      54687265 
 12486 0fef 00       		.bss
 12487              		.align	2
 12488              		.set	.LANCHOR0,. + 0
 12491              	glFxUVCEvent:
 12492 0000 00000000 		.space	40
 12492      00000000 
 12492      00000000 
 12492      00000000 
 12492      00000000 
 12495              	debugData:
 12496 0028 00000000 		.space	128
 12496      00000000 
 12496      00000000 
 12496      00000000 
 12496      00000000 
 12499              	gpif_initialized:
 12500 00a8 00000000 		.space	4
 12503              	streamingStarted:
 12504 00ac 00000000 		.space	4
 12507              	isUsbConnected:
 12508 00b0 00000000 		.space	4
 12511              	fb:
 12512 00b4 0000     		.space	2
 12515              	pb:
 12516 00b6 0000     		.space	2
 12519              	pbc:
 12520 00b8 0000     		.space	2
 12523              	stiflag:
 12524 00ba 00       		.space	1
 12525 00bb 00       		.space	1
 12528              	hitFV:
 12529 00bc 00000000 		.space	4
 12532              	prodCount:
 12533 00c0 0000     		.space	2
 12536              	consCount:
 12537 00c2 0000     		.space	2
 12540              	clearFeatureRqtReceived:
 12541 00c4 00000000 		.space	4
 12544              	usbSpeed:
 12545 00c8 00       		.space	1
 12546 00c9 000000   		.space	3
 12549              	I2CCMDArry:
 12550 00cc 00000000 		.space	12
 12550      00000000 
 12550      00000000 
 12553              	is60Hz:
 12554 00d8 00000000 		.space	4
 12557              	value:
 12558 00dc 00000000 		.space	64
 12558      00000000 
 12558      00000000 
 12558      00000000 
 12558      00000000 
 12561              	glEp0Buffer:
 12562 011c 00000000 		.space	32
 12562      00000000 
 12562      00000000 
 12562      00000000 
 12562      00000000 
 12565              	curFlag:
 12566 013c 00000000 		.space	64
 12566      00000000 
 12566      00000000 
 12566      00000000 
 12566      00000000 
 12569              	CamMode:
 12570 017c 00       		.space	1
 12573              	setRes:
 12574 017d 00       		.space	1
 12575 017e 0000     		.space	2
 12578              	glCommitCtrl:
 12579 0180 00000000 		.space	32
 12579      00000000 
 12579      00000000 
 12579      00000000 
 12579      00000000 
 12582              	setstilRes:
 12583 01a0 00       		.space	1
 12586              	IMcount.7874:
 12587 01a1 00       		.space	1
 12588 01a2 0000     		.space	2
 12591              	uvcAppThread:
 12592 01a4 00000000 		.space	168
 12592      00000000 
 12592      00000000 
 12592      00000000 
 12592      00000000 
 12595              	uvcAppEP0Thread:
 12596 024c 00000000 		.space	168
 12596      00000000 
 12596      00000000 
 12596      00000000 
 12596      00000000 
 12599              	i2cAppThread:
 12600 02f4 00000000 		.space	168
 12600      00000000 
 12600      00000000 
 12600      00000000 
 12600      00000000 
 12603              	testSnap:
 12604 039c 00       		.space	1
 12605 039d 00       		.space	1
 12608              	fbbak:
 12609 039e 0000     		.space	2
 12612              	pbbak:
 12613 03a0 0000     		.space	2
 12616              	pbcbak:
 12617 03a2 0000     		.space	2
 12620              	pbcpbak:
 12621 03a4 0000     		.space	2
 12622 03a6 0000     		.space	2
 12625              	streamingRecove:
 12626 03a8 00000000 		.space	4
 12627              		.text
 12628              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:199    .text:00000168 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:206    .text:00000178 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:307    .text:0000023c $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:351    .text:00000278 I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:318    .text:0000025c $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:320    .text:0000025c CyFxUvcAppDebugCallback
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:344    .text:00000274 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:348    .text:00000278 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:385    .text:000002a8 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:391    .text:000002b4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:393    .text:000002b4 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:595    .text:00000438 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:604    .text:00000448 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:607    .text:00000448 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:829    .text:000005e8 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:839    .text:00000604 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:841    .text:00000604 CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1231   .text:0000097c $d
                            *COM*:00000001 bRequest
                            *COM*:00000001 bmReqType
                            *COM*:00000002 wLength
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1249   .text:000009b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1252   .text:000009b0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1289   .text:000009e8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1302   .text:00000a14 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1349   .text:00000a68 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1356   .text:00000a78 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1374   .text:00000a94 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1383   .text:00000aac $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1386   .text:00000aac I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1731   .text:00000dfc $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1740   .text:00000e14 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1743   .text:00000e14 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1806   .text:00000e94 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1829   .text:00000eac $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1842   .text:00000ed4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1948   .text:00000fc8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1956   .text:00000fdc $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:1959   .text:00000fdc ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:2171   .text:00001178 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:2213   .text:00001214 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:2279   .text:00001294 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:2320   .text:00001330 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:3679   .text:00001f10 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:3702   .text:00001f60 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:4107   .text:00002318 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:4113   .text:00002328 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:4716   .text:00002848 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:4884   .text:000029a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:4897   .text:000029cc $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5392   .text:00002edc $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5403   .text:00002efc $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5665   .text:000031b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5678   .text:000031e0 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5681   .text:000031e0 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5733   .text:00003248 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:5741   .text:00003258 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:6374   .text:0000385c $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:6384   .text:0000386c $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:6571   .text:00003a28 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:6578   .text:00003a38 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7322   .text:00004130 $d
                            *COM*:00000004 glDebugRspBuffer
                            *COM*:000000a0 glDebugCmdChannel
                            *COM*:000000a0 glDebugRspChannel
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7364   .text:000041c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7430   .text:00004254 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7723   .text:00004510 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7730   .text:00004520 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7733   .text:00004520 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7774   .text:00004564 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7779   .text:0000456c $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7782   .text:0000456c CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7807   .text:00004588 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7811   .text:0000458c $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:7814   .text:0000458c UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9501   .text:000052ac $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9507   .text:000052bc $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9623   .text:00005424 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9695   .text:00005538 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9698   .text:00005538 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9844   .text:00005690 $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9860   .text:000056c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:9863   .text:000056c4 main
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11656  .data:0000070c CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11665  .data:00000718 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11740  .data:00000838 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11759  .data:00000848 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10026  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11838  .data:00000978 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11849  .data:00000988 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11960  .data:00000b38 CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12111  .data:00000bcc CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10039  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11652  .data:0000070b snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12603  .bss:0000039c testSnap
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12511  .bss:000000b4 fb
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12515  .bss:000000b6 pb
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12519  .bss:000000b8 pbc
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12608  .bss:0000039e fbbak
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12612  .bss:000003a0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12616  .bss:000003a2 pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12620  .bss:000003a4 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12507  .bss:000000b0 isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12544  .bss:000000c8 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12540  .bss:000000c4 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12625  .bss:000003a8 streamingRecove
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12503  .bss:000000ac streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11593  .data:000006d8 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11533  .data:000006a0 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11623  .data:000006f4 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11563  .data:000006bc glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11638  .data:00000700 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11021  .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 staQuMux
                            *COM*:00000038 timMux
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10007  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10011  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10051  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10055  .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:10378  .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11036  .data:0000048c dbgIdx
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11040  .data:0000048d ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11044  .data:0000048e valIdx
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11049  .data:00000490 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11071  .data:000004a4 EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11093  .data:000004b8 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11115  .data:000004cc EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11137  .data:000004e0 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11159  .data:000004f4 WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11166  .data:000004f8 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11188  .data:0000050c PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:11210  .data:00000520 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12189  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12487  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12491  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12495  .bss:00000028 debugData
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12499  .bss:000000a8 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12523  .bss:000000ba stiflag
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12528  .bss:000000bc hitFV
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12532  .bss:000000c0 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12536  .bss:000000c2 consCount
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12549  .bss:000000cc I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12553  .bss:000000d8 is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12557  .bss:000000dc value
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12561  .bss:0000011c glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12565  .bss:0000013c curFlag
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12569  .bss:0000017c CamMode
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12573  .bss:0000017d setRes
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12578  .bss:00000180 glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12582  .bss:000001a0 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12586  .bss:000001a1 IMcount.7874
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12591  .bss:000001a4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12595  .bss:0000024c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccZX3INM.s:12599  .bss:000002f4 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PGpifDisable
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PUsbAckSetup
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PDmaMultiChannelSetWrapUp
SensorRead2B
SensorWrite2B
cmdSet
SensorWrite2B2
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
SensorGetControl
CyU3PDmaChannelGetBuffer
CyU3PDmaChannelDiscardBuffer
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PGpioSimpleGetValue
SensorRead
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PUsbSetEpPktMode
CyU3PDmaChannelSetXfer
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
