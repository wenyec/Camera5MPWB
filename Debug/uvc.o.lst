   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uvc.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	I2CCmdCb
  19              	I2CCmdCb:
  20              	.LFB18:
  21              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h" //"cyfxgpif2config_lineTest.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** CyU3PMutex       imgHdMux;
  98:../uvc.c      **** 
  99:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
 100:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 101:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 102:../uvc.c      **** 
 103:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 104:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 105:../uvc.c      **** //uint16_t lineCount = 0; //res test
 106:../uvc.c      **** 
 107:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 108:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 109:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 110:../uvc.c      ****                                                            received. */
 111:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 112:../uvc.c      **** #ifdef BACKFLOW_DETECT
 113:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 114:../uvc.c      **** #endif
 115:../uvc.c      **** 
 116:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 117:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 118:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 119:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 120:../uvc.c      **** #endif
 121:../uvc.c      **** 
 122:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 123:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 124:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 125:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 126:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 127:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 128:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 129:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 131:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 133:../uvc.c      ****                                    with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 135:../uvc.c      ****                                    streaming with adjustable compression parameters */
 136:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 137:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 138:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 139:../uvc.c      **** };
 140:../uvc.c      **** 
 141:../uvc.c      **** uint8_t glProbeCtrlFull[CY_FX_UVC_MAX_PROBE_SETTING] = {
 142:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 143:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 144:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 145:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 146:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 147:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 148:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 149:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 150:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 151:../uvc.c      ****                                    with adjustable compression parameters */
 152:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 153:../uvc.c      ****                                    streaming with adjustable compression parameters */
 154:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 155:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes 10077696 */
 156:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 157:../uvc.c      **** };
 158:../uvc.c      **** 
 159:../uvc.c      **** 
 160:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 161:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 162:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 163:../uvc.c      ****     0x02,                       /* Use 1st Video frame index */
 164:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 165:../uvc.c      ****     0x00, 0xc6, 0x99, 0x00,     /* Max video frame size in bytes */
 166:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 167:../uvc.c      **** };
 168:../uvc.c      **** 
 169:../uvc.c      **** 
 170:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 171:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 172:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 173:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 174:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 175:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 176:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 177:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 178:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 179:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 180:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 181:../uvc.c      ****                                    with adjustable compression parameters */
 182:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 183:../uvc.c      ****                                    streaming with adjustable compression parameters */
 184:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 185:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 186:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 187:../uvc.c      **** };
 188:../uvc.c      **** 
 189:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 190:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 191:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 192:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 193:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 194:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 195:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 196:../uvc.c      **** };
 197:../uvc.c      **** 
 198:../uvc.c      **** 
 199:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 200:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 201:../uvc.c      **** 
 202:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 203:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 204:../uvc.c      **** {
 205:../uvc.c      ****     0x0C,                               /* Header Length */
 206:../uvc.c      ****     0x8C,                               /* Bit field header field */
 207:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 208:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 209:../uvc.c      **** };
 210:../uvc.c      **** 
 211:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 212:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 213:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 214:../uvc.c      ****                                                            the current video frame. */
 215:../uvc.c      **** //volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 216:../uvc.c      **** volatile static uint8_t stiflag = 0;             /* Whether the image is still image */
 217:../uvc.c      **** //volatile static uint16_t stillcont = 0;
 218:../uvc.c      **** volatile static CyBool_t is60Hz = CyFalse;				/* Flag for frequency */
 219:../uvc.c      **** volatile static uint8_t ROIMode = 0x01;				/* for 720p has 0x04 (ROI) 0x05 and 0x06; the other Res.
 220:../uvc.c      **** //#define isWBMamu   0  // Is white balance control manual mode.
 221:../uvc.c      **** 
 222:../uvc.c      **** /************ control parameters array ***********
 223:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 224:../uvc.c      ****  *    e.g.
 225:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 226:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 227:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 228:../uvc.c      ****  **************************************************/
 229:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 230:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 231:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 232:../uvc.c      **** 		{/*0*/BLCModeRegAct       , BLCModeRegAct        , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,
 233:../uvc.c      **** 		{/*1*/0x15/*BrightnessReg1*/      , 0x15/*BrightnessReg0*/       , 2,    0,    0,  255,    0, 1, 
 234:../uvc.c      **** 		{/*2*/0x04/*ContrastReg*/         , 0x04/*ContrastReg*/          , 2,    0,    0,  255,    0, 1, 
 235:../uvc.c      **** 		{/*3*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 236:../uvc.c      **** 		{/*4*/MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,
 237:../uvc.c      **** 		{/*5*/HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,
 238:../uvc.c      **** 		{/*6*/SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,
 239:../uvc.c      **** 		{/*7*/SharpnessReg1       , SharpnessReg1        , 2,    0,    0,  255,    0, 1, 0, 3, 0,  32, 0,
 240:../uvc.c      **** 		{/*8*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 241:../uvc.c      **** 		{/*9*/WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,
 242:../uvc.c      **** 		{/*A*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,
 243:../uvc.c      **** 		{/*B*/ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,
 244:../uvc.c      **** 		{/*C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 245:../uvc.c      **** 		{/*D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 246:../uvc.c      **** 		{/*E*/DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,
 247:../uvc.c      **** 		{/*F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,
 248:../uvc.c      **** 		{/*10*/ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0
 249:../uvc.c      **** 		{/*11*/SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0
 250:../uvc.c      **** 		{/*12*/MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 251:../uvc.c      **** 		{/*13*/NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0
 252:../uvc.c      **** 		{/*14*/NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0
 253:../uvc.c      **** 		{/*15*/DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0
 254:../uvc.c      **** 		{/*16*/DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0
 255:../uvc.c      **** 		{/*17*/DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 256:../uvc.c      **** 		{/*18*/NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0
 257:../uvc.c      **** 		{/*19*/AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32
 258:../uvc.c      **** 		{/*1A*/AExReferleveReg     , AExReferleveReg      , 2,    0,    0,  255,    0, 1, 0, 3, 0,  0x60,
 259:../uvc.c      **** 		{/*1B*/0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0
 260:../uvc.c      **** 		{/*1C*/SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0
 261:../uvc.c      **** 		{/*1D*/0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 262:../uvc.c      **** 		{/*1E*/SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0
 263:../uvc.c      **** 		/**********************************
 264:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 265:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 266:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 267:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 268:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 269:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 270:../uvc.c      **** 		 *
 271:../uvc.c      **** 		 *********************************/
 272:../uvc.c      **** 		{/*1F*/0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 
 273:../uvc.c      **** };
 274:../uvc.c      **** #if 1 // the new control structure
 275:../uvc.c      **** /* the processing unit control request */
 276:../uvc.c      **** //		{ 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,   0, I2C_EAGLESDP_ADDR,  CyTrue, CyFalse,
 277:../uvc.c      **** 
 278:../uvc.c      **** volatile static SensorCtrl PUCBLC =
 279:../uvc.c      **** 		{BLCModeRegAct,		//Reg1: the command register address1
 280:../uvc.c      **** 		 BLCModeRegGain,	//Reg2: the command register address2
 281:../uvc.c      **** 		 2,					//UVCLn: the command length
 282:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 283:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 284:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 285:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 286:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 287:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 288:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 289:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 290:../uvc.c      **** 		 3,					//UVCDefVLo: the command default data value low byte
 291:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 292:../uvc.c      **** 		 3,					//UVCCurVLo: the command current data value low byte
 293:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 294:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 295:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 296:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 297:../uvc.c      **** 		}; //
 298:../uvc.c      **** //volatile static SensorCtrl PUCBright;
 299:../uvc.c      **** //volatile static SensorCtrl PUCContrast;
 300:../uvc.c      **** //volatile static SensorCtrl PUCGain;
 301:../uvc.c      **** //volatile static SensorCtrl PUCPLFreq;
 302:../uvc.c      **** //volatile static SensorCtrl PUCHueC;
 303:../uvc.c      **** //volatile static SensorCtrl PUCSaturation;
 304:../uvc.c      **** volatile static SensorCtrl PUCSharp =
 305:../uvc.c      **** 		{SharpnessReg1,		//Reg1: the command register address1
 306:../uvc.c      **** 		 SharpnessReg2,		//Reg2: the command register address2
 307:../uvc.c      **** 		 2,					//UVCLn: the command length
 308:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 309:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 310:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 311:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 312:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 313:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 314:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 315:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 316:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 317:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 318:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 319:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 320:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 321:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 322:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 323:../uvc.c      **** 		}; //sharpness, Reg1: 0-disable & 1-enable; Reg2: 0x00~0xFF.
 324:../uvc.c      **** //volatile static SensorCtrl PUCWBLC; //?
 325:../uvc.c      **** //volatile static SensorCtrl PUCDZoom;
 326:../uvc.c      **** 
 327:../uvc.c      **** volatile static SensorCtrl *pPUCSenCtrl[0x10] = {
 328:../uvc.c      **** 	&PUCBLC,
 329:../uvc.c      **** 	0, //&PUCBright,
 330:../uvc.c      **** 	0, //&PUCContrast,
 331:../uvc.c      **** 	0, //&PUCGain (AGC?)
 332:../uvc.c      **** 	0, //&PUCPLFreq,
 333:../uvc.c      **** 	0, //&PUCHueC,
 334:../uvc.c      **** 	0, //&PUCSaturation,
 335:../uvc.c      **** 	&PUCSharp,
 336:../uvc.c      **** 	0, //&PUCGamGain,
 337:../uvc.c      **** 	0, //&PUCWBMd,
 338:../uvc.c      **** 	0, //UVCCtlID10,
 339:../uvc.c      **** 	0, //&PUCWBLC,
 340:../uvc.c      **** 	0, //UVCCtlID12,
 341:../uvc.c      **** 	0, //UVCCtlID13,
 342:../uvc.c      **** 	0, //&PUCDZoom,
 343:../uvc.c      **** 	0 //UVCCtlID15
 344:../uvc.c      **** };
 345:../uvc.c      **** 
 346:../uvc.c      **** /* the Camera terminal control request */
 347:../uvc.c      **** //volatile static SensorCtrl CTCAutoExMode;
 348:../uvc.c      **** //volatile static SensorCtrl CTCExposureTAbs;
 349:../uvc.c      **** //volatile static SensorCtrl CTCFocusRel;
 350:../uvc.c      **** //volatile static SensorCtrl CTCIrisAbs;
 351:../uvc.c      **** //volatile static SensorCtrl CTCOPZoomAbs;
 352:../uvc.c      **** 
 353:../uvc.c      **** /* the Extentsion control request */
 354:../uvc.c      **** volatile static SensorCtrl EXTShutter =
 355:../uvc.c      **** 		{ShutterReg,		//Reg1: the command register address1
 356:../uvc.c      **** 		 0x02/*ShutterReg*/,		//Reg2: the command register address2
 357:../uvc.c      **** 		 2,					//UVCLn: the command length
 358:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 359:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 360:../uvc.c      **** 		 8,					//UVCMaxLo: the command maximum value low byte
 361:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 362:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 363:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 364:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 365:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 366:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 367:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 368:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 369:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 370:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 371:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 372:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 373:../uvc.c      **** 		}; //shutter control 0 ~ 0x12
 374:../uvc.c      **** /*volatile static SensorCtrl EXTSensUp =
 375:../uvc.c      **** 		{SenseUpReg,		//Reg1: the command register address1
 376:../uvc.c      **** 		 SenseUpReg,		//Reg2: the command register address2
 377:../uvc.c      **** 		 2,					//UVCLn: the command length
 378:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 379:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 380:../uvc.c      **** 		 9,					//UVCMaxLo: the command maximum value low byte
 381:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 382:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 383:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 384:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 385:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 386:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 387:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 388:../uvc.c      **** 		 1,					//UVCCurVLo: the command current data value low byte
 389:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 390:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 391:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 392:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 393:../uvc.c      **** 		};	// sense up control 0 ~ 0x09
 394:../uvc.c      **** */
 395:../uvc.c      **** /*volatile static SensorCtrl EXTMirror =
 396:../uvc.c      **** 		{MirrModeReg,		//Reg1: the command register address1
 397:../uvc.c      **** 		 MirrModeReg,		//Reg2: the command register address2
 398:../uvc.c      **** 		 2,					//UVCLn: the command length
 399:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 400:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 401:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 402:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 403:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 404:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 405:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 406:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 407:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 408:../uvc.c      **** 		 0,					//UVCDefVHi: the command default data value high byte
 409:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 410:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 411:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 412:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 413:../uvc.c      **** 		 CyFalse,		 	//AvailableF: the command available flag
 414:../uvc.c      **** 		};	// mirror mode control 0 ~ 0x03
 415:../uvc.c      **** */
 416:../uvc.c      **** //volatile static SensorCtrl EXT3DnoiseReduceMode;
 417:../uvc.c      **** //volatile static SensorCtrl EXT3DNoiseLev;
 418:../uvc.c      **** //volatile static SensorCtrl EXTDayNightMode;
 419:../uvc.c      **** //volatile static SensorCtrl EXTDayNightdely;
 420:../uvc.c      **** //volatile static SensorCtrl EXTDayNightlev;
 421:../uvc.c      **** //volatile static SensorCtrl EXTNightDaylev;
 422:../uvc.c      **** volatile static SensorCtrl EXTAexModGainlev =
 423:../uvc.c      **** 		{ShutterReg/*AExModeReg*/,		//Reg1: the command register address1
 424:../uvc.c      **** 		 0x03/*AExAGCReg*/,			//Reg2: the command register address2
 425:../uvc.c      **** 		 4,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 426:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 427:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 428:../uvc.c      **** 		 3,					//UVCMaxLo: the command maximum value low byte
 429:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 430:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 431:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 432:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 433:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 434:../uvc.c      **** 		 0,					//UVCDefVLo: the command default data value low byte
 435:../uvc.c      **** 		 63, 				//UVCDefVHi: the command default data value high byte
 436:../uvc.c      **** 		 0,					//UVCCurVLo: the command current data value low byte
 437:../uvc.c      **** 		 63,				//UVCCurVHi: the command current data value high byte
 438:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 439:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 440:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 441:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 442:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 443:../uvc.c      **** //volatile static SensorCtrl EXTExpReflev;
 444:../uvc.c      **** //volatile static SensorCtrl EXTCamMode;
 445:../uvc.c      **** //volatile static SensorCtrl EXTSnapshot;
 446:../uvc.c      **** //volatile static SensorCtrl EXTSensorPare;
 447:../uvc.c      **** //volatile static SensorCtrl EXTI2Ccmd;
 448:../uvc.c      **** volatile static SensorCtrl EXTBLCWinPos =
 449:../uvc.c      **** 		{BLCPosReg,			//Reg1: the command register address1
 450:../uvc.c      **** 		 BLCSizeReg,		//Reg2: the command register address2
 451:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 452:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 453:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 454:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 455:../uvc.c      **** 		 0xff,				//UVCMaxHi: the command maximum value high byte
 456:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 457:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 458:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 459:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 460:../uvc.c      **** 		 0x66,				//UVCDefVLo: the command default data value low byte
 461:../uvc.c      **** 		 0x66, 				//UVCDefVHi: the command default data value high byte
 462:../uvc.c      **** 		 0x66,				//UVCCurVLo: the command current data value low byte
 463:../uvc.c      **** 		 0x66,				//UVCCurVHi: the command current data value high byte
 464:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 465:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 466:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 467:../uvc.c      **** 		}; //BLC position: [7:4]:Top/bottom [3:0]:left/right; BLC size: [7:4]:height [3:0]:width.
 468:../uvc.c      **** //{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,
 469:../uvc.c      **** volatile static SensorCtrl EXTBLCWeight =
 470:../uvc.c      **** 		{BLCModeRegGain,			//Reg1: the command register address1
 471:../uvc.c      **** 		 BLCModeRegGain,			//Reg2: the command register address2
 472:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 473:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 474:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 475:../uvc.c      **** 		 0xff,				//UVCMaxLo: the command maximum value low byte
 476:../uvc.c      **** 		 0,					//UVCMaxHi: the command maximum value high byte
 477:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 478:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 479:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 480:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 481:../uvc.c      **** 		 0x80,				//UVCDefVLo: the command default data value low byte
 482:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 483:../uvc.c      **** 		 0x80,				//UVCCurVLo: the command current data value low byte
 484:../uvc.c      **** 		 0,					//UVCCurVHi: the command current data value high byte
 485:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 486:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 487:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 488:../uvc.c      **** 		}; //
 489:../uvc.c      **** //volatile static SensorCtrl EXTBLCGrid;
 490:../uvc.c      **** //{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 491:../uvc.c      **** 
 492:../uvc.c      **** volatile static SensorCtrl EXTShutlev =
 493:../uvc.c      **** 		{0x02/*AExModeReg2*/,		//Reg1: the command register address1
 494:../uvc.c      **** 		 0x12/*ShutterFineReg*/,			//Reg2: the command register address2
 495:../uvc.c      **** 		 2,					//UVCLn: the command length: 1th for mode and 2nd for gain level
 496:../uvc.c      **** 		 0,					//UVCMinLo: the command minimum value low byte
 497:../uvc.c      **** 		 0,					//UVCMinHi: the command minimum value high byte
 498:../uvc.c      **** 		 255,				//UVCMaxLo: the command maximum value low byte
 499:../uvc.c      **** 		 127,				//UVCMaxHi: the command maximum value high byte
 500:../uvc.c      **** 		 1,					//UVCResLo: the command Res. value low byte
 501:../uvc.c      **** 		 0,					//UVCResHi: the command Res. value high byte
 502:../uvc.c      **** 		 3,					//UVCInfoLo: the command information value low byte
 503:../uvc.c      **** 		 0,					//UVCInfoHi: the command information value high byte
 504:../uvc.c      **** 		 63,				//UVCDefVLo: the command default data value low byte
 505:../uvc.c      **** 		 0, 				//UVCDefVHi: the command default data value high byte
 506:../uvc.c      **** 		 63,					//UVCCurVLo: the command current data value low byte
 507:../uvc.c      **** 		 0,				//UVCCurVHi: the command current data value high byte
 508:../uvc.c      **** 		 I2C_EAGLESDP_ADDR,	//DeviceAdd: the device address
 509:../uvc.c      **** 		 CyTrue,			//CheckF: the command checked flag
 510:../uvc.c      **** 		 CyFalse			//AvailableF: the command available flag
 511:../uvc.c      **** 		}; //AE mode setting & AGC level: 0:auto 1:AGC only 2:auto Shutter only 3:menual
 512:../uvc.c      **** 		   //Gain level: 0 ~ 0xff
 513:../uvc.c      **** 
 514:../uvc.c      **** volatile static SensorCtrl *pEXTSenCtrl[0x20] = {//Extension control
 515:../uvc.c      **** 		&EXTShutter,
 516:../uvc.c      **** 		0, //&EXTSensUp,
 517:../uvc.c      **** 		0, //&EXTMirror,
 518:../uvc.c      **** 		0, //&EXT3DnoiseReduceMode,
 519:../uvc.c      **** 		0, //&EXT3DNoiseLev,
 520:../uvc.c      **** 		0, //&EXTDayNightMode,
 521:../uvc.c      **** 		0, //&EXTDayNightdely,
 522:../uvc.c      **** 		0, //&EXTDayNightlev,
 523:../uvc.c      **** 		0, //&EXTNightDaylev,
 524:../uvc.c      **** 		&EXTAexModGainlev,
 525:../uvc.c      **** 		0, //&EXTExpReflev,
 526:../uvc.c      **** 		&EXTShutlev,
 527:../uvc.c      **** 		0, //&EXTCamMode,
 528:../uvc.c      **** 		0, //&EXTSnapshot,
 529:../uvc.c      **** 		0, //&EXTSensorPare,
 530:../uvc.c      **** 		0, //&EXTI2Ccmd,
 531:../uvc.c      **** 		0, //&Ext1CtlID0 = 0x20,
 532:../uvc.c      **** 		0, //&Ext1CtlID1,
 533:../uvc.c      **** 		0, //&Ext1CtlID2,
 534:../uvc.c      **** 		0, //&Ext1CtlID3,
 535:../uvc.c      **** 		&EXTBLCWinPos,   		// back light compensation range
 536:../uvc.c      **** 		&EXTBLCWeight,  	    // back light compensation weight (gain) factor
 537:../uvc.c      **** 		0, //&EXTBLCGrid,    	// back light compensation grid state
 538:../uvc.c      **** 		0
 539:../uvc.c      **** };
 540:../uvc.c      **** 
 541:../uvc.c      **** #endif //end of the new control structure
 542:../uvc.c      **** 
 543:../uvc.c      **** #ifndef CAM720
 544:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 545:../uvc.c      **** #else
 546:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 547:../uvc.c      **** #endif
 548:../uvc.c      **** 	static uint8_t setRes = 0;  // 1:2592x1944; 2:1920x1080; 3:1280x720; 0:n/a
 549:../uvc.c      **** 	static uint8_t setstilRes = 0;  // 1:1920x1080; 2:2592x1944; 3:1280x720; 0:n/a
 550:../uvc.c      **** 
 551:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 552:../uvc.c      **** 		{/*20 set Iris auto (AF Lens)*/0,               0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4
 553:../uvc.c      **** 		{/*21 set Iris auto (non AF Lens)*/0,           0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0,
 554:../uvc.c      **** 		{/*22 set Iris value (DC manual)*/0,            0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1,
 555:../uvc.c      **** 		{/*23 opt zoom*/0,                              0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0,
 556:../uvc.c      **** 		{/*24*/0x13/*Ext1BLCRangeCtlID4 position*/ , 0x14/*size*/ , 2,    0,    0,    0xff, 0xff, 1, 0, 3
 557:../uvc.c      **** 		{/*25*/0x11/*Ext1BLCWeightCtlID5*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   0x80,
 558:../uvc.c      **** 		{/*26*/BLCModeRegAct/*Ext1BLCGridCtlID6*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0
 559:../uvc.c      **** 		{/*27*/0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e,
 560:../uvc.c      **** 		{/*28*/0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0
 561:../uvc.c      **** 		{/*29*/0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0
 562:../uvc.c      **** 		{/*2A*/0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0
 563:../uvc.c      **** 		{/*2B*/0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 1
 564:../uvc.c      **** 		{/*2C*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 565:../uvc.c      **** 		{/*2D*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 566:../uvc.c      **** 		{/*2E*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 567:../uvc.c      **** 		{/*2F*/0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0
 568:../uvc.c      **** };
 569:../uvc.c      **** 
 570:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 571:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 572:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 573:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 574:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 575:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 576:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 577:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 578:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 579:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 580:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 581:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 582:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 583:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 584:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 585:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 586:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 587:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 588:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 589:../uvc.c      **** };
 590:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 591:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 592:../uvc.c      **** static uint16_t ShutSp[16]={33333, 16667, 8333, 4000, 2000, 1000, 500, 200, 100, 10, 0}; // in micr
 593:../uvc.c      **** static uint8_t curFlag[64]={0}; //the curFlag for each controls current records available. 0: unabl
 594:../uvc.c      **** /*
 595:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 596:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 597:../uvc.c      ****  */
 598:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 599:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 600:../uvc.c      **** };
 601:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 602:../uvc.c      **** 		0
 603:../uvc.c      **** };
 604:../uvc.c      **** 
 605:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 606:../uvc.c      **** 
 607:../uvc.c      **** void I2CCmdHandler(){
 608:../uvc.c      **** 	uint8_t buf[2];
 609:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 610:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 611:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 612:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 613:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 614:../uvc.c      **** 	uint8_t i;
 615:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 616:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 617:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 618:../uvc.c      **** 	if((I2CCMDArry[3]==0x52) && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x01))
 619:../uvc.c      **** 	{
 620:../uvc.c      **** 		ROIMode = I2CCMDArry[9]&0x03; //set ROI mode based on the I2C data.
 621:../uvc.c      **** 		if(is60Hz==CyFalse)
 622:../uvc.c      **** 			{
 623:../uvc.c      **** 				I2CCMDArry[9]=0x80|I2CCMDArry[9];
 624:../uvc.c      **** 			}
 625:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command setting value %x %x\r\n", I2CCMDArry[9], ROIMode);
 626:../uvc.c      **** 
 627:../uvc.c      **** 	}
 628:../uvc.c      **** 	if(CmdType == 0)//I2C read
 629:../uvc.c      **** 	{
 630:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 631:../uvc.c      **** #if 0 //for debugging
 632:../uvc.c      **** 		/* test still image operation */
 633:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 634:../uvc.c      **** 			snapButFlag = 0; //press
 635:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 636:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 637:../uvc.c      **** 			snapButFlag = 0xf; //release
 638:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 639:../uvc.c      **** 		}
 640:../uvc.c      **** 
 641:../uvc.c      **** 		/* end of the test */
 642:../uvc.c      **** #endif
 643:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 644:../uvc.c      **** 				SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5]
 645:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 646:../uvc.c      **** 				if(CmdDataLen == 2){
 647:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 648:../uvc.c      **** 				}
 649:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 650:../uvc.c      **** 		}else{//not support currently
 651:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 652:../uvc.c      **** 		}
 653:../uvc.c      **** 	}else if(CmdType == 1){
 654:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 655:../uvc.c      **** 			if(CmdRegLen == 2){
 656:../uvc.c      **** 				for(i = 0; i<4; i++)
 657:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 658:../uvc.c      **** 			}
 659:../uvc.c      **** 			else{
 660:../uvc.c      **** 				if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 661:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 662:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 663:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 664:../uvc.c      **** 				}
 665:../uvc.c      **** 				else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDA
 666:../uvc.c      **** 			}
 667:../uvc.c      **** 		}else{//not support currently
 668:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 669:../uvc.c      **** 		}
 670:../uvc.c      **** 
 671:../uvc.c      **** 	}
 672:../uvc.c      **** }
 673:../uvc.c      **** 
 674:../uvc.c      **** /************************************
 675:../uvc.c      ****  * set Iris mode
 676:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 677:../uvc.c      ****  */
 678:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 679:../uvc.c      **** 	uint8_t dataIdx = 0;
 680:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 682:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 683:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 684:../uvc.c      **** }
 685:../uvc.c      **** 
 686:../uvc.c      **** 
 687:../uvc.c      **** 
 688:../uvc.c      **** inline uint8_t getShutCtrl(uint8_t Data, uint8_t* pAxMode){
 689:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 690:../uvc.c      **** 	uint16_t NumLn;
 691:../uvc.c      **** 	uint16_t fRate, shutTm;
 692:../uvc.c      **** 	uint8_t LnVal;
 693:../uvc.c      **** 	switch (Data){
 694:../uvc.c      **** 	case 1:
 695:../uvc.c      **** 	case 2:
 696:../uvc.c      **** 	case 3:
 697:../uvc.c      **** 	case 4:
 698:../uvc.c      **** 	case 5:
 699:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 700:../uvc.c      **** 		fRate = 30;
 701:../uvc.c      **** 		NumLn = (shutTm/LnTm)*fRate;
 702:../uvc.c      **** 		if(NumLn > 1944)
 703:../uvc.c      **** 			NumLn =1944;
 704:../uvc.c      **** 		else if(NumLn < 8)
 705:../uvc.c      **** 			NumLn = 8;
 706:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 707:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 708:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 709:../uvc.c      **** 		break;
 710:../uvc.c      **** 	case 6:
 711:../uvc.c      **** 	case 7:
 712:../uvc.c      **** 	case 8:
 713:../uvc.c      **** 	case 9:
 714:../uvc.c      **** 	case 10:
 715:../uvc.c      **** 		shutTm = ShutSp[Data-1];
 716:../uvc.c      **** 		fRate = 30;
 717:../uvc.c      **** 		NumLn = (shutTm*fRate)/LnTm;
 718:../uvc.c      **** 		if(NumLn > 1944)
 719:../uvc.c      **** 			NumLn =1944;
 720:../uvc.c      **** 		else if(NumLn < 8)
 721:../uvc.c      **** 			NumLn = 8;
 722:../uvc.c      **** 		LnVal = (uint8_t)(NumLn/8);
 723:../uvc.c      **** 		*pAxMode = 0x01;	// shutter menual
 724:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 725:../uvc.c      **** 		break;
 726:../uvc.c      **** 	case 0: //auto
 727:../uvc.c      **** 	default:
 728:../uvc.c      **** 		*pAxMode = 0x00;	// auto
 729:../uvc.c      **** 		LnVal = 1;
 730:../uvc.c      **** 		break;
 731:../uvc.c      **** 	}
 732:../uvc.c      **** 	return LnVal;
 733:../uvc.c      **** }
 734:../uvc.c      **** 
 735:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 736:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 737:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 738:../uvc.c      ****     uint16_t readCount;
 739:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID, AxMode;
 740:../uvc.c      ****     uint8_t devAdd;
 741:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET+4;
 742:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 743:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 744:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 745:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 746:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 747:../uvc.c      ****     }else{
 748:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 749:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 750:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 751:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 752:../uvc.c      ****     }
 753:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 754:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 755:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 756:../uvc.c      **** #endif
 757:../uvc.c      ****     reqData = bRequest;
 758:../uvc.c      ****     /*
 759:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 760:../uvc.c      ****      */
 761:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 762:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 763:../uvc.c      ****     	goto EndofSet;
 764:../uvc.c      ****     }
 765:../uvc.c      ****     switch (bRequest)
 766:../uvc.c      **** 		 {
 767:../uvc.c      **** 
 768:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 769:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 770:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 771:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 772:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 773:../uvc.c      **** 			  break;
 774:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 775:../uvc.c      **** 
 776:../uvc.c      **** 			 switch(CtrlID)
 777:../uvc.c      **** 			 {
 778:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 779:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID4:
 780:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 781:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 782:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 783:../uvc.c      **** 			 	 		 }else{
 784:../uvc.c      **** 			 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 785:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 786:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 787:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 788:../uvc.c      **** 			 	 		 }
 789:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 790:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 791:../uvc.c      **** 						 break;
 792:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 793:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 794:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 795:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 796:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 797:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 798:../uvc.c      **** 			 	 		 }else{
 799:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 800:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 801:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 802:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 803:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 804:../uvc.c      **** 			 	 		 }
 805:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 806:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 807:../uvc.c      **** 			 	 		 break;
 808:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 809:../uvc.c      **** 						 //glEp0Buffer[0] = ExUCtrlParArry[CtrlID][13];
 810:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 811:../uvc.c      **** 						 //glEp0Buffer[1] = ExUCtrlParArry[CtrlID][14];
 812:../uvc.c      **** 								 //pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 813:../uvc.c      **** 			 	 		 if(curFlag[CtrlID]){
 814:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 815:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 816:../uvc.c      **** 			 	 		 }else{
 817:../uvc.c      **** 			 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 818:../uvc.c      **** 			 	 			if(Data0&0x80)
 819:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 820:../uvc.c      **** 			 	 			else
 821:../uvc.c      **** 			 	 				glEp0Buffer[0] = 0;
 822:../uvc.c      **** 			 	 			ExUCtrlParArry[CtrlID-0x20][13] = glEp0Buffer[0];
 823:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 824:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 825:../uvc.c      **** 			 	 		 }
 826:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 827:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 828:../uvc.c      **** 			 	 		 break;
 829:../uvc.c      **** 			 	 }
 830:../uvc.c      **** 			 	 case ExtShutCtlID0:
 831:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 832:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 833:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 834:../uvc.c      **** 
 835:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 836:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 837:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 838:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 839:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 840:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 841:../uvc.c      **** 		 	 		 }else{
 842:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 843:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 844:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 845:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 846:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 847:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 848:../uvc.c      **** 						CyU3PDebugPrint (4, "test shutter speed. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], Data1, Data0);
 849:../uvc.c      **** 
 850:../uvc.c      **** 		 	 		 }
 851:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 852:../uvc.c      **** 					 sendData1 = Data1;//glEp0Buffer[1];
 853:../uvc.c      **** 					 CyU3PDebugPrint (4, "test shutter speed2. 0x%x 0x%x 0x%x\r\n", glEp0Buffer[0], sendData, send
 854:../uvc.c      **** 			 		 break;
 855:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 856:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 857:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 858:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 859:../uvc.c      **** 
 860:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 861:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 862:../uvc.c      **** 					 //glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 863:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 864:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 865:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 866:../uvc.c      **** 		 	 		 }else{
 867:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
 868:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 869:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 870:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 871:../uvc.c      **** 		 	 		 }
 872:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 873:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 874:../uvc.c      **** 			 		 break;
 875:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 876:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 877:../uvc.c      **** 
 878:../uvc.c      **** 					 if(CamMode == 1){//720p
 879:../uvc.c      **** 						if(sendData >= 3){
 880:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 881:../uvc.c      **** 							sendData = 0; //set back to default
 882:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 883:../uvc.c      **** 						}
 884:../uvc.c      **** 						sendData += 4;
 885:../uvc.c      **** 					 }
 886:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 887:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 888:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 889:../uvc.c      **** 					 break;
 890:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 891:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 892:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 893:../uvc.c      **** 			 		 }
 894:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 895:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 896:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 897:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 898:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 899:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 900:../uvc.c      **** #endif
 901:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 902:../uvc.c      **** 			 		 {
 903:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 904:../uvc.c      **** 			 		 }
 905:../uvc.c      **** 			 		 break;
 906:../uvc.c      **** 				 case ExtAexModCtlID9:
 907:../uvc.c      **** 				     RegAdd0 = pEXTSenCtrl[CtrlID - 0x10]->Reg1; //ExUCtrlParArry[locCtrlID][0];
 908:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 909:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 910:../uvc.c      **** 
 911:../uvc.c      **** 					 //glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;
 912:../uvc.c      **** 					 //glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 913:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 914:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 915:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 916:../uvc.c      **** 		 	 		 }else{
 917:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
 918:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 919:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 920:../uvc.c      **** 
 921:../uvc.c      **** 		 	 			glEp0Buffer[2] = SensorGetControl(RegAdd1, devAdd);
 922:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 923:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 924:../uvc.c      **** 		 	 		 }
 925:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
 926:../uvc.c      **** 					 //sendData1 = glEp0Buffer[1];
 927:../uvc.c      **** 
 928:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 929:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 930:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 931:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 932:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 933:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 934:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 935:../uvc.c      **** 					 break;
 936:../uvc.c      **** 
 937:../uvc.c      **** 			 	 case BrgtCtlID1:
 938:../uvc.c      **** 			 		 /* cancel for 5MP w/b camera
 939:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 940:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 941:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 942:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 943:../uvc.c      **** 					 }else{
 944:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 945:../uvc.c      **** 					 }
 946:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 947:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 948:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 949:../uvc.c      **** 					 */
 950:../uvc.c      **** 
 951:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 952:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 953:../uvc.c      **** 		 	 		 }else{
 954:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 955:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 956:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 957:../uvc.c      **** 		 	 		 }
 958:../uvc.c      **** 					 //Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode()
 959:../uvc.c      **** 					  if(Data0&0x80){
 960:../uvc.c      **** 						  Data0 = ~Data0;
 961:../uvc.c      **** 					  }else{
 962:../uvc.c      **** 						  Data0 = Data0 + 0x80;
 963:../uvc.c      **** 					  }
 964:../uvc.c      **** 					 glEp0Buffer[0] = Data0;
 965:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 966:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 967:../uvc.c      **** 			 		 break;
 968:../uvc.c      **** 				 case HueCtlID5:
 969:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 970:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 971:../uvc.c      **** 		 	 		 }else{
 972:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 973:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 974:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 975:../uvc.c      **** 		 	 		 }
 976:../uvc.c      **** 
 977:../uvc.c      **** 					 glEp0Buffer[0] = Data0 + GREEN_BASE;
 978:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 979:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 980:../uvc.c      **** 					 break;
 981:../uvc.c      **** 				 case WBTLevCtlID11:
 982:../uvc.c      **** 					 //glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 983:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
 984:../uvc.c      **** 					 //glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 985:../uvc.c      **** 					 //glEp0Buffer[3] = 0;
 986:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
 987:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 988:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 989:../uvc.c      **** 		 	 		 }else{
 990:../uvc.c      **** 		 	 			Data0 = SensorGetControl(RegAdd0, devAdd);
 991:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 992:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 993:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 994:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 995:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 996:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 997:../uvc.c      **** 		 	 		 }
 998:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 999:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1000:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1001:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
1002:../uvc.c      **** 					 break;
1003:../uvc.c      **** 				 case BLCCtlID0:
1004:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1005:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1006:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1007:../uvc.c      **** 		 	 		 }else{
1008:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1009:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
1010:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1011:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1012:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1013:../uvc.c      **** 		 	 		 }
1014:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1015:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1016:../uvc.c      **** 					 break;
1017:../uvc.c      **** 				 case ShapCtlID7:
1018:../uvc.c      **** 					 //glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;
1019:../uvc.c      **** 							 //CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1020:../uvc.c      **** 					 //glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1021:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1022:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
1023:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1024:../uvc.c      **** 		 	 		 }else{
1025:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd1, devAdd);
1026:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
1027:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
1028:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1029:../uvc.c      **** 		 	 		 }
1030:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1031:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1032:../uvc.c      **** 					 break;
1033:../uvc.c      **** 				 case ExtExRefCtlID10:
1034:../uvc.c      **** 				 case ConsCtlID2:
1035:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ExtExRefCtlID10][13];//SensorGetControl(RegAdd0, devAdd);
1036:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//SensorGetControl(RegAdd0, devAdd);
1037:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1038:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1039:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
1040:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1041:../uvc.c      **** 		 	 		 }else{
1042:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1043:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
1044:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
1045:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1046:../uvc.c      **** 		 	 		 }
1047:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1048:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1049:../uvc.c      **** 					 break;
1050:../uvc.c      **** 				 case WBTMdCtlID9:
1051:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1052:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1053:../uvc.c      **** 						 glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1054:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1055:../uvc.c      **** 		 	 		 }else{
1056:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1057:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1058:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
1059:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1060:../uvc.c      **** 
1061:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1062:../uvc.c      **** 		 	 		 }
1063:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1064:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1065:../uvc.c      **** 					 break;
1066:../uvc.c      **** 				 case MFreqCtlID4:
1067:../uvc.c      **** 
1068:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1069:../uvc.c      **** 
1070:../uvc.c      **** 		 	 			 if(is60Hz)
1071:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
1072:../uvc.c      **** 		 	 			 else
1073:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 1;
1074:../uvc.c      **** 
1075:../uvc.c      **** 						 //glEp0Buffer[0] = glEp0Buffer[0] & 0x80;    // get two least Bits
1076:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1077:../uvc.c      **** 		 	 		 }else{
1078:../uvc.c      **** 		 	 			Data0 = SensorGetControl(0x1, devAdd); //get resolution bit7 for main frequency information
1079:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
1080:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
1081:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1082:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1083:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1084:../uvc.c      **** 		 	 		 }
1085:../uvc.c      **** 
1086:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1087:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1088:../uvc.c      **** 					 break;
1089:../uvc.c      **** 				 case SaturCtlID6:
1090:../uvc.c      **** 				 default:
1091:../uvc.c      **** 					 //glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
1092:../uvc.c      **** 					 //glEp0Buffer[1] = 0;
1093:../uvc.c      **** 		 	 		 if(curFlag[CtrlID]){
1094:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
1095:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1096:../uvc.c      **** 		 	 		 }else{
1097:../uvc.c      **** 		 	 			glEp0Buffer[0] = SensorGetControl(RegAdd0, devAdd);
1098:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
1099:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
1100:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
1101:../uvc.c      **** 		 	 		 }
1102:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1103:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
1104:../uvc.c      **** 
1105:../uvc.c      **** 					 //sendData = glEp0Buffer[0];
1106:../uvc.c      **** 					 break;
1107:../uvc.c      **** 			 }
1108:../uvc.c      **** 
1109:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1110:../uvc.c      **** 
1111:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1112:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
1113:../uvc.c      **** #endif
1114:../uvc.c      **** 			  break;
1115:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
1116:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1117:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
1118:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
1119:../uvc.c      **** 		 	 }
1120:../uvc.c      **** 
1121:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1122:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
1123:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1124:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
1125:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1126:../uvc.c      **** 			 }else
1127:../uvc.c      **** 			 {
1128:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
1129:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
1130:../uvc.c      **** 			 }
1131:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1132:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1133:../uvc.c      **** 			  break;
1134:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1135:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1136:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
1137:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
1138:../uvc.c      **** 		 	 }
1139:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1140:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
1141:../uvc.c      **** 				 glEp0Buffer[1] = 0;
1142:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
1143:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1144:../uvc.c      **** 			 }else
1145:../uvc.c      **** 			 {
1146:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
1147:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
1148:../uvc.c      **** 			 }
1149:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1150:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1151:../uvc.c      **** 			  break;
1152:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1153:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1154:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
1155:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
1156:../uvc.c      **** 				 glEp0Buffer[2] = 0;
1157:../uvc.c      **** 				 glEp0Buffer[3] = 0;
1158:../uvc.c      **** 		 	 }
1159:../uvc.c      **** 		 	 else{
1160:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
1161:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
1162:../uvc.c      **** 			  glEp0Buffer[2] = 0;
1163:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1164:../uvc.c      **** 		 	 }
1165:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1166:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1167:../uvc.c      **** 			  break;
1168:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1169:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1170:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
1171:../uvc.c      **** 		 	 }
1172:../uvc.c      **** 		 	 else{
1173:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
1174:../uvc.c      **** 		 	 }
1175:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1176:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1177:../uvc.c      **** 			  Len = 1;
1178:../uvc.c      **** 			  break;
1179:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1180:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
1181:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
1182:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
1183:../uvc.c      **** 		 	 }
1184:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
1185:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1186:../uvc.c      **** 				  glEp0Buffer[1] = 0;
1187:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
1188:../uvc.c      **** 				  glEp0Buffer[3] = 0;
1189:../uvc.c      **** 			 }else{
1190:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
1191:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
1192:../uvc.c      **** 			 }
1193:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1194:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1195:../uvc.c      **** 			  break;
1196:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1197:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1198:../uvc.c      **** 				  glEp0Buffer, &readCount);
1199:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
1200:../uvc.c      **** 			   {
1201:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
1202:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
1203:../uvc.c      **** 				  getData = glEp0Buffer[0];
1204:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
1205:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1206:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
1207:../uvc.c      **** #endif
1208:../uvc.c      **** 				  switch(CtrlID)
1209:../uvc.c      **** 					 {
1210:../uvc.c      **** 						 case ExtShutCtlID0:
1211:../uvc.c      **** 						     RegAdd0 = EXTShutter.Reg1; //ExUCtrlParArry[locCtrlID][0];
1212:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
1213:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
1214:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
1215:../uvc.c      **** #if 1	// register setting directly
1216:../uvc.c      **** 						     if((EXTAexModGainlev.UVCCurVLo&0x3) != 0)
1217:../uvc.c      **** 						     {
1218:../uvc.c      **** 						    	 Data0 = (Data0 << 4) | (EXTAexModGainlev.UVCCurVLo);
1219:../uvc.c      **** 						    	 dataIdx = 0;
1220:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1221:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
1222:../uvc.c      **** 								 dataIdx++;
1223:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1224:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1225:../uvc.c      **** 						     }
1226:../uvc.c      **** 						     CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x 0x%x\r\n",
1227:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
1228:../uvc.c      **** 						     break;
1229:../uvc.c      **** #else	// old fashion
1230:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
1231:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
1232:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
1233:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
1234:../uvc.c      **** 									 }else{
1235:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
1236:../uvc.c      **** 									 }
1237:../uvc.c      **** 								 }
1238:../uvc.c      **** 							 }else{
1239:../uvc.c      **** 								 Data1 = Data0 - 1;
1240:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
1241:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
1242:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
1243:../uvc.c      **** 									 }else{
1244:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
1245:../uvc.c      **** 									 }
1246:../uvc.c      **** 								 }
1247:../uvc.c      **** 								 if(Data1 < 8){
1248:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
1249:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
1250:../uvc.c      **** 								 }else{
1251:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
1252:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
1253:../uvc.c      **** 								 }
1254:../uvc.c      **** 							 }
1255:../uvc.c      **** 							 EXTShutter.AvailableF = CyTrue; //CtrlParArry[CtrlID][16] = CyTrue;
1256:../uvc.c      **** 							 dataIdx = 0;
1257:../uvc.c      **** 							 Data1 = getShutCtrl(Data0, &AxMode); //call setting shutter control Reg. routine.
1258:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1259:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, AxMode, dataIdx);  //First for Axmode 0
1260:../uvc.c      **** 							 if(AxMode){
1261:../uvc.c      **** 								 dataIdx++;
1262:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x80, dataIdx);  //Second for Axmode 2
1263:../uvc.c      **** 								 dataIdx++;
1264:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x12, devAdd, Data1, dataIdx);  //Third for fine shutter adjustme
1265:../uvc.c      **** 							 }
1266:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1267:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
1268:../uvc.c      **** 							 break;
1269:../uvc.c      **** #endif
1270:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
1271:../uvc.c      **** 						     RegAdd0 = EXTAexModGainlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1272:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1273:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
1274:../uvc.c      **** 						     dataIdx = 0;
1275:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1276:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
1277:../uvc.c      **** 							 {
1278:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). Ctrl
1279:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1280:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1281:../uvc.c      **** 								 /*
1282:../uvc.c      **** 								 dataIdx++;
1283:../uvc.c      **** 								 if(getData == 1 || getData == 3){
1284:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x80, dataIdx);  //set AEX mode2 to 0x80 (fixed shu
1285:../uvc.c      **** 									 dataIdx++;
1286:../uvc.c      **** 								 }else{
1287:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, 0x2, devAdd, 0x00, dataIdx);  //set AEX mode2 to 0x00
1288:../uvc.c      **** 									 dataIdx++;
1289:../uvc.c      **** 								 }
1290:../uvc.c      **** 								 */
1291:../uvc.c      **** 							 }
1292:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVHi != getData1){
1293:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
1294:../uvc.c      **** 								 if(getData == 2 || getData == 3){
1295:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
1296:../uvc.c      **** 								 }
1297:../uvc.c      **** 							 }
1298:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1299:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1300:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1301:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
1302:../uvc.c      **** 							 break;
1303:../uvc.c      **** 
1304:../uvc.c      **** 						 case ExtCtlShutlevCtlID11://shutter level
1305:../uvc.c      **** 						     RegAdd0 = EXTShutlev.Reg1; //ExUCtrlParArry[locCtrlID][0];
1306:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
1307:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
1308:../uvc.c      **** 						     dataIdx = 0;
1309:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1310:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
1311:../uvc.c      **** 							 {
1312:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//exposure mode (assume b3:2=00, no BLC window). CtrlParArr
1313:../uvc.c      **** 								 //Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
1314:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
1315:../uvc.c      **** 								 dataIdx++;
1316:../uvc.c      **** 							 }
1317:../uvc.c      **** 							 if(EXTShutlev.UVCCurVLo != getData){
1318:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
1319:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
1320:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
1321:../uvc.c      **** 									 dataIdx++;
1322:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //shutter level
1323:../uvc.c      **** 								 }
1324:../uvc.c      **** 							 }
1325:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1326:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1327:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
1328:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
1329:../uvc.c      **** 							 break;
1330:../uvc.c      **** 						 case ExtCamMCtlID12:
1331:../uvc.c      **** 							 dataIdx = 0;
1332:../uvc.c      **** 							 if(Data0 <= 3){
1333:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
1334:../uvc.c      **** 								 Data1 = Data0;
1335:../uvc.c      **** 							 }else{
1336:../uvc.c      **** 								 CamMode = 1; //set 720p flag
1337:../uvc.c      **** 								 Data1 = Data0-4;
1338:../uvc.c      **** 							 }
1339:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1340:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
1341:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1342:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1343:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1344:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1345:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
1346:../uvc.c      **** 							 break;
1347:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
1348:../uvc.c      **** 							 dataIdx = 0;
1349:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
1350:../uvc.c      **** 								 Data0 = 1;
1351:../uvc.c      **** 							 }else{ //save current sensor parameters.
1352:../uvc.c      **** 								 Data0 = 0;
1353:../uvc.c      **** 							 }
1354:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1355:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1356:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1357:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1358:../uvc.c      **** 							 break;
1359:../uvc.c      **** 						 case ExtI2CCtlID15:
1360:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
1361:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
1362:../uvc.c      **** 					 		 }
1363:../uvc.c      **** 					 		I2CCmdHandler();
1364:../uvc.c      **** 							 break;
1365:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
1366:../uvc.c      **** 						     RegAdd0 = EXTBLCWinPos.Reg1; //ExUCtrlParArry[locCtrlID][0];
1367:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
1368:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
1369:../uvc.c      **** 
1370:../uvc.c      **** 							 dataIdx = 0;
1371:../uvc.c      **** #if 0 //seperate version
1372:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
1373:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
1374:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1375:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
1376:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
1377:../uvc.c      **** 							 }else{ //disable BLD window
1378:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
1379:../uvc.c      **** 							 }
1380:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
1381:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
1382:../uvc.c      **** 							 dataIdx++;
1383:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
1384:../uvc.c      **** 							 dataIdx++;
1385:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
1386:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
1387:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
1388:../uvc.c      **** 							 dataIdx++;
1389:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
1390:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1391:../uvc.c      **** #else //combination version
1392:../uvc.c      **** 							 //Data0 = Data0&0x7F; //mask window show flag bit.
1393:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1394:../uvc.c      **** 						     /* end test */
1395:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
1396:../uvc.c      **** 							 dataIdx++;
1397:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
1398:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1399:../uvc.c      **** 							 getData1 = Data1;
1400:../uvc.c      **** #endif
1401:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVLo = Data0; //ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array
1402:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
1403:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1404:../uvc.c      **** 							 break;
1405:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
1406:../uvc.c      **** 						     RegAdd0 = EXTBLCWeight.Reg1; //ExUCtrlParArry[locCtrlID][0];
1407:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
1408:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
1409:../uvc.c      **** 
1410:../uvc.c      **** 							 dataIdx = 0;
1411:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1412:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
1413:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1414:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
1415:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
1416:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1417:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][16] = CyTrue;
1418:../uvc.c      **** 							 break;
1419:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
1420:../uvc.c      **** 							 dataIdx = 0;
1421:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
1422:../uvc.c      **** 							 if(Data0 == 1){
1423:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
1424:../uvc.c      **** 							 }else{
1425:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo&0x7f;
1426:../uvc.c      **** 							 }
1427:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1428:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
1429:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1430:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
1431:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
1432:../uvc.c      **** 							 break;
1433:../uvc.c      **** 				  	  	 case BrgtCtlID1:
1434:../uvc.c      **** #if 0 //cancel for 5MP w/b camera
1435:../uvc.c      **** 							 dataIdx = 0;
1436:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1437:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1438:../uvc.c      **** 							  if(Data0&0x80){
1439:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
1440:../uvc.c      **** 							  }else{
1441:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
1442:../uvc.c      **** 							  }
1443:../uvc.c      **** 							 Data1 |= ~0x03;
1444:../uvc.c      **** 							 Data1 &= 0xC7;
1445:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
1446:../uvc.c      **** 						  	 dataIdx++;
1447:../uvc.c      **** 
1448:../uvc.c      **** 							 Data0 = (Data0 << 2);
1449:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
1450:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1451:../uvc.c      **** 
1452:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1453:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
1454:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1455:../uvc.c      **** #endif
1456:../uvc.c      **** 							 dataIdx = 0;
1457:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1458:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
1459:../uvc.c      **** 							  if(Data0&0x80){
1460:../uvc.c      **** 								  Data0 = Data0 - 0x80;
1461:../uvc.c      **** 							  }else{
1462:../uvc.c      **** 								  Data0 = ~Data0;
1463:../uvc.c      **** 							  }
1464:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //First
1465:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1466:../uvc.c      **** 
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1468:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1469:../uvc.c      **** 
1470:../uvc.c      **** 
1471:../uvc.c      **** 							 break;
1472:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
1473:../uvc.c      **** 							 dataIdx = 0;
1474:../uvc.c      **** 
1475:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1476:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
1477:../uvc.c      **** 							 dataIdx++;
1478:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
1479:../uvc.c      **** 							 dataIdx++;
1480:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
1481:../uvc.c      **** 							 dataIdx++;
1482:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
1483:../uvc.c      **** 							 dataIdx++;
1484:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
1485:../uvc.c      **** 							 dataIdx++;
1486:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
1487:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1488:../uvc.c      **** 
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
1490:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1491:../uvc.c      **** 							 break;
1492:../uvc.c      **** 						 case SaturCtlID6:
1493:../uvc.c      **** 							 dataIdx = 0;
1494:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
1495:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1496:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1497:../uvc.c      **** 							 dataIdx++;
1498:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
1499:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1501:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1502:../uvc.c      **** 							 break;
1503:../uvc.c      **** 
1504:../uvc.c      **** 						 case WBTLevCtlID11:
1505:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
1506:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
1507:../uvc.c      **** 							 dataIdx = 0;
1508:../uvc.c      **** 
1509:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1510:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1511:../uvc.c      **** 							 dataIdx++;
1512:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
1513:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1514:../uvc.c      **** 
1515:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
1516:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
1517:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1518:../uvc.c      **** 							 break;
1519:../uvc.c      **** 						 case MFreqCtlID4:
1520:../uvc.c      **** 							 dataIdx = 0;
1521:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1522:../uvc.c      **** 							 Data0 = Data0 - 1;
1523:../uvc.c      **** 							 is60Hz = Data0;
1524:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
1525:../uvc.c      **** 							 {
1526:../uvc.c      **** 								 Data0 = 0;  // 50Hz (PAL)
1527:../uvc.c      **** 								 is60Hz = CyFalse;
1528:../uvc.c      **** 							 }
1529:../uvc.c      **** 							 else if(Data0 >2)
1530:../uvc.c      **** 							 {
1531:../uvc.c      **** 								 Data0 = 1;  // 60Hz (NTSC)
1532:../uvc.c      **** 								 is60Hz = CyTrue;
1533:../uvc.c      **** 							 }
1534:../uvc.c      **** 							 CyU3PDebugPrint (4, "Frequency setting is  %d %d\r\n", Data0, is60Hz);
1535:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
1536:../uvc.c      **** 							 {
1537:../uvc.c      **** 								 //CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1538:../uvc.c      **** 			                       switch (setRes)
1539:../uvc.c      **** 			                         {
1540:../uvc.c      **** 			                         	case 1: //1944
1541:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_
1542:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1543:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1544:../uvc.c      **** 			                         		break;
1545:../uvc.c      **** 			                         	case 2: //1080
1546:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_
1547:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1548:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
1549:../uvc.c      **** 			                         		break;
1550:../uvc.c      **** 			                         	case 3: //720
1551:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I
1552:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1553:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1554:../uvc.c      **** 			                         		break;
1555:../uvc.c      **** 			                         	case 4: //VGA
1556:../uvc.c      **** 			                         		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I
1557:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
1558:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
1559:../uvc.c      **** 			                         	default:
1560:../uvc.c      **** 			                         		break;
1561:../uvc.c      **** 			                         }
1562:../uvc.c      **** 								 //CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1563:../uvc.c      **** 							 }
1564:../uvc.c      **** 
1565:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1566:../uvc.c      **** 							 break;
1567:../uvc.c      **** 					 	 case BLCCtlID0:
1568:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1569:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1570:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1571:../uvc.c      **** 						     dataIdx = 0;
1572:../uvc.c      **** 
1573:../uvc.c      **** 							 //CtrlParArry[CtrlID][13] = Data0;
1574:../uvc.c      **** 							 //CtrlParArry[CtrlID][16] = CyTrue;
1575:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1576:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1577:../uvc.c      **** 
1578:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
1579:../uvc.c      **** 							 {
1580:../uvc.c      **** 								 if(Data0 < 3){
1581:../uvc.c      **** 					 				 Data0 += 4;
1582:../uvc.c      **** 					 			 }else{
1583:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
1584:../uvc.c      **** 									Data0 = 4; //set to default.
1585:../uvc.c      **** 					 			 }
1586:../uvc.c      **** 					 		 }
1587:../uvc.c      **** 							 //CtrlParArry[CamModeIndex][13] = Data0;
1588:../uvc.c      **** 							 dataIdx = 0;
1589:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1590:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1591:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1592:../uvc.c      **** 
1593:../uvc.c      **** 					 		 break;
1594:../uvc.c      **** 					 	 case ShapCtlID7:
1595:../uvc.c      **** 						     RegAdd0 = pPUCSenCtrl[CtrlID]->Reg1; //ExUCtrlParArry[locCtrlID][0];
1596:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
1597:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
1598:../uvc.c      **** 						     dataIdx = 0;
1599:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->UVCCurVLo = Data0;
1600:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
1601:../uvc.c      **** 							 if(Data0 != 0){
1602:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1603:../uvc.c      **** #ifdef COLOR
1604:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1605:../uvc.c      **** #else
1606:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x1, dataIdx);  //First: enable sharpness.
1607:../uvc.c      **** 								 dataIdx++;
1608:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second: set enhancement valu
1609:../uvc.c      **** #endif
1610:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1611:../uvc.c      **** 							 }else{
1612:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1613:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
1614:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1615:../uvc.c      **** 
1616:../uvc.c      **** 							 }
1617:../uvc.c      **** 							 break;
1618:../uvc.c      **** 						 case ExtExRefCtlID10:
1619:../uvc.c      **** 						 case ConsCtlID2:
1620:../uvc.c      **** 							 dataIdx = 0;
1621:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1622:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1623:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1624:../uvc.c      **** 
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][13] = Data0;
1626:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
1627:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
1628:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][16] = CyTrue;
1629:../uvc.c      **** 
1630:../uvc.c      **** 							 break;
1631:../uvc.c      **** 						 default:
1632:../uvc.c      **** 							 dataIdx = 0;
1633:../uvc.c      **** 
1634:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1635:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
1636:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1637:../uvc.c      **** 
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
1639:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
1640:../uvc.c      **** 							 break;
1641:../uvc.c      **** 					 }
1642:../uvc.c      **** 			   }else{
1643:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
1644:../uvc.c      **** 			   }
1645:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1646:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
1647:../uvc.c      **** #endif
1648:../uvc.c      **** 
1649:../uvc.c      **** 			  break;
1650:../uvc.c      **** 		  default:
1651:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1652:../uvc.c      **** 			  break;
1653:../uvc.c      **** 		 }
1654:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
1655:../uvc.c      **** }
1656:../uvc.c      **** /************** CT control requests handler *************************/
1657:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
1658:../uvc.c      **** 
1659:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
1660:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
1661:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1662:../uvc.c      ****     uint16_t readCount;
1663:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
1664:../uvc.c      ****     uint16_t diff, value, diffRd;
1665:../uvc.c      ****     uint8_t i, shutter, index;
1666:../uvc.c      ****     diff = 0xffff;
1667:../uvc.c      ****     shutter = 1;
1668:../uvc.c      ****     index = 1;
1669:../uvc.c      **** 
1670:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
1671:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
1672:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
1673:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
1674:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
1675:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1676:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
1677:../uvc.c      **** #endif
1678:../uvc.c      ****     reqData = bRequest;
1679:../uvc.c      **** 
1680:../uvc.c      ****     switch (bRequest)
1681:../uvc.c      **** 		 {
1682:../uvc.c      **** 
1683:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
1684:../uvc.c      **** 			  glEp0Buffer[0] = Len;
1685:../uvc.c      **** 			  glEp0Buffer[1] = 0;
1686:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
1687:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1688:../uvc.c      **** 			  break;
1689:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
1690:../uvc.c      **** 
1691:../uvc.c      **** 			 switch(CtrlID)
1692:../uvc.c      **** 			 {
1693:../uvc.c      **** 				 default:
1694:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
1695:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
1696:../uvc.c      **** 					 glEp0Buffer[2] = 0;
1697:../uvc.c      **** 					 glEp0Buffer[3] = 0;
1698:../uvc.c      **** 					 sendData = glEp0Buffer[0];
1699:../uvc.c      **** 					 break;
1700:../uvc.c      **** 			 }
1701:../uvc.c      **** 
1702:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1703:../uvc.c      **** 
1704:../uvc.c      **** #ifdef USB_DEBUG_PRINT
1705:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
1706:../uvc.c      **** #endif
1707:../uvc.c      **** 			  break;
1708:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
1709:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
1710:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
1711:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
1712:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1713:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1714:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1715:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1716:../uvc.c      **** 			  break;
1717:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
1718:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
1719:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
1720:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1721:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1722:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1723:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1724:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1725:../uvc.c      **** 			  break;
1726:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
1727:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
1728:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
1729:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1730:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1731:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1732:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1733:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1734:../uvc.c      **** 			  break;
1735:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
1736:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
1737:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
1738:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1739:../uvc.c      **** 			  Len = 1;
1740:../uvc.c      **** 			  break;
1741:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
1742:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
1743:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
1744:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
1745:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
1746:../uvc.c      **** 			  glEp0Buffer[3] = 0;
1747:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
1748:../uvc.c      **** 			  sendData = glEp0Buffer[0];
1749:../uvc.c      **** 			  break;
1750:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
1751:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
1752:../uvc.c      **** 			  glEp0Buffer, &readCount);
1753:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
1754:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
1755:../uvc.c      **** 			  value = Data1;
1756:../uvc.c      **** 
1757:../uvc.c      **** 			  switch(CtrlID)
1758:../uvc.c      **** 			  {
1759:../uvc.c      **** 		  	      case AutoExMCtlID1:
1760:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
1761:../uvc.c      **** 
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
1763:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
1764:../uvc.c      **** 				    getData = glEp0Buffer[0];
1765:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
1766:../uvc.c      **** 		  		    switch (getData){
1767:../uvc.c      **** 						case 1:
1768:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
1769:../uvc.c      **** 							break;
1770:../uvc.c      **** 						case 2:
1771:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1772:../uvc.c      **** 							dataIdx = 0;
1773:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1774:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1775:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1776:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
1777:../uvc.c      **** 
1778:../uvc.c      **** 							break;
1779:../uvc.c      **** 						case 4:
1780:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1781:../uvc.c      **** 							break;
1782:../uvc.c      **** 						case 8:
1783:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1784:../uvc.c      **** 			  		    	dataIdx = 0;
1785:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1786:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1787:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1788:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1789:../uvc.c      **** 							break;
1790:../uvc.c      **** 		  		    }
1791:../uvc.c      **** #if 0
1792:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1793:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1794:../uvc.c      **** 						  dataIdx = 0;
1795:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1796:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1797:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1798:../uvc.c      **** 		  		    }
1799:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1800:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1801:../uvc.c      **** 		  		    }
1802:../uvc.c      **** #endif
1803:../uvc.c      **** 				    break;
1804:../uvc.c      **** 
1805:../uvc.c      **** 			  	  case ExTmACtlID3:
1806:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1807:../uvc.c      **** 
1808:../uvc.c      **** 					  value = (value << 8)|Data0;
1809:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1810:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1811:../uvc.c      **** 					  {
1812:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1813:../uvc.c      **** 						  {
1814:../uvc.c      **** 							if(value > ShutValueArry[i]){
1815:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1816:../uvc.c      **** 							}else{
1817:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1818:../uvc.c      **** 							}
1819:../uvc.c      **** 							  if(diff > diffRd){
1820:../uvc.c      **** 								  diff = diffRd;
1821:../uvc.c      **** 								  index = i;
1822:../uvc.c      **** 							  }
1823:../uvc.c      **** 						  }
1824:../uvc.c      **** 						  shutter = shutter+index;
1825:../uvc.c      **** 
1826:../uvc.c      **** 						  dataIdx = 0;
1827:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1828:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1829:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1830:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1831:../uvc.c      **** 
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1834:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1835:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1836:../uvc.c      **** 					  }else{
1837:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1838:../uvc.c      **** 					  }
1839:../uvc.c      **** 					  getData = glEp0Buffer[0];
1840:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1841:../uvc.c      **** 					  break;
1842:../uvc.c      **** 			  	  case IriACtlID7:
1843:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1844:../uvc.c      **** 					  {
1845:../uvc.c      **** 							 dataIdx = 0;
1846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1847:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
1848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1849:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1850:../uvc.c      **** 
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1853:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1854:../uvc.c      **** 					  }else{
1855:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1856:../uvc.c      **** 					  }
1857:../uvc.c      **** 					  getData = glEp0Buffer[0];
1858:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1859:../uvc.c      **** 
1860:../uvc.c      **** 					  break;
1861:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1862:../uvc.c      **** 					  getData = glEp0Buffer[0];
1863:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1864:../uvc.c      **** #if 1
1865:../uvc.c      **** 					  dataIdx = 0;
1866:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1867:../uvc.c      **** 					  if(getData == 1)
1868:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1869:../uvc.c      **** 					  else if(getData == 0xff)
1870:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1871:../uvc.c      **** 					  else
1872:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, STOP, dataIdx);
1873:../uvc.c      **** 					  //dataIdx++;
1874:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1875:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1876:../uvc.c      **** #endif
1877:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1878:../uvc.c      **** 					  break;
1879:../uvc.c      **** 
1880:../uvc.c      **** 			  	  default:
1881:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1882:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1883:../uvc.c      **** 			  		 break;
1884:../uvc.c      **** 			  }
1885:../uvc.c      **** 			  break;
1886:../uvc.c      **** 		  default:
1887:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1888:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1889:../uvc.c      **** 			  break;
1890:../uvc.c      **** 		 }
1891:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1892:../uvc.c      **** 
1893:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1894:../uvc.c      **** }
1895:../uvc.c      **** 
1896:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1897:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1898:../uvc.c      **** {
1899:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
1900:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
1901:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1902:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1903:../uvc.c      **** 
1904:../uvc.c      ****     CtrlID = BrgtCtlID1;
1905:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1906:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1907:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1908:../uvc.c      ****     Data1 = Data0;
1909:../uvc.c      **** 
1910:../uvc.c      ****     CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1911:../uvc.c      ****     if(Data1&0x80){
1912:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1913:../uvc.c      ****     }else{
1914:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1915:../uvc.c      ****     }
1916:../uvc.c      ****     Data0 = (Data0 << 2);
1917:../uvc.c      **** 
1918:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1919:../uvc.c      **** 
1920:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1921:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1922:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1923:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1924:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1925:../uvc.c      **** 
1926:../uvc.c      ****     CtrlID = ConsCtlID2;
1927:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1928:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1929:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1930:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1931:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1932:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
1933:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1934:../uvc.c      **** 
1935:../uvc.c      ****     CtrlID = HueCtlID5;
1936:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1937:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1938:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1944:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1945:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1946:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1947:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1948:../uvc.c      **** 
1949:../uvc.c      ****     CtrlID = SaturCtlID6;
1950:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1951:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1952:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1953:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1954:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1955:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1956:../uvc.c      **** 
1957:../uvc.c      ****     CtrlID = ShapCtlID7;
1958:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1959:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1960:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1961:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1962:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1963:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1964:../uvc.c      **** 
1965:../uvc.c      **** 	CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
1966:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1967:../uvc.c      **** 	return;
1968:../uvc.c      **** }
1969:../uvc.c      **** 
1970:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1971:../uvc.c      **** void
1972:../uvc.c      **** CyFxUVCAddHeader (
1973:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1974:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1975:../uvc.c      ****         )
1976:../uvc.c      **** {
1977:../uvc.c      ****     /* Copy header to buffer */
1978:../uvc.c      **** 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
1979:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1980:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
1981:../uvc.c      **** 
1982:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1983:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1984:../uvc.c      ****     {
1985:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1986:../uvc.c      ****     }
1987:../uvc.c      **** }
1988:../uvc.c      **** 
1989:../uvc.c      **** 
1990:../uvc.c      **** /* Application Error Handler */
1991:../uvc.c      **** void
1992:../uvc.c      **** CyFxAppErrorHandler (
1993:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1994:../uvc.c      ****         )
1995:../uvc.c      **** {
1996:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1997:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1998:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1999:../uvc.c      **** 
2000:../uvc.c      ****        This function can be modified to take additional error handling actions such
2001:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
2002:../uvc.c      ****      */
2003:../uvc.c      ****     for (;;)
2004:../uvc.c      ****     {
2005:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
2006:../uvc.c      ****         CyU3PThreadSleep (1000);
2007:../uvc.c      ****     }
2008:../uvc.c      **** }
2009:../uvc.c      **** 
2010:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
2011:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
2012:../uvc.c      ****  */
2013:../uvc.c      **** static void
2014:../uvc.c      **** CyFxUVCApplnAbortHandler (
2015:../uvc.c      ****         void)
2016:../uvc.c      **** {
2017:../uvc.c      **** 	uint32_t flag;
2018:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
2019:../uvc.c      **** 	{
2020:../uvc.c      ****         /* Clear the Video Stream Request Event */
2021:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
2022:../uvc.c      **** 
2023:../uvc.c      ****         /* Set Video Stream Abort Event */
2024:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
2025:../uvc.c      **** 	}
2026:../uvc.c      **** }
2027:../uvc.c      **** 
2028:../uvc.c      **** /* This is the Callback function to handle the USB Events */
2029:../uvc.c      **** static void
2030:../uvc.c      **** CyFxUVCApplnUSBEventCB (
2031:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
2032:../uvc.c      ****         uint16_t             evdata  /* Event data */
2033:../uvc.c      ****         )
2034:../uvc.c      **** {
2035:../uvc.c      ****     switch (evtype)
2036:../uvc.c      ****     {
2037:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
2038:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
2039:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2040:../uvc.c      ****             gpif_initialized = 0;
2041:../uvc.c      ****             streamingStarted = CyFalse;
2042:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2043:../uvc.c      ****             break;
2044:../uvc.c      **** 
2045:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
2046:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
2047:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2048:../uvc.c      ****             gpif_initialized = 0;
2049:../uvc.c      ****             streamingStarted = CyFalse;
2050:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2051:../uvc.c      ****             break;
2052:../uvc.c      **** 
2053:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
2054:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
2055:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
2056:../uvc.c      ****             gpif_initialized = 0;
2057:../uvc.c      ****             isUsbConnected = CyFalse;
2058:../uvc.c      ****             streamingStarted = CyFalse;
2059:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
2060:../uvc.c      ****             break;
2061:../uvc.c      **** 
2062:../uvc.c      **** #ifdef BACKFLOW_DETECT
2063:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
2064:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
2065:../uvc.c      ****             break;
2066:../uvc.c      **** #endif
2067:../uvc.c      **** 
2068:../uvc.c      ****         default:
2069:../uvc.c      ****             break;
2070:../uvc.c      ****     }
2071:../uvc.c      **** }
2072:../uvc.c      **** 
2073:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
2074:../uvc.c      **** static CyBool_t
2075:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
2076:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
2077:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
2078:../uvc.c      ****         )
2079:../uvc.c      **** {
2080:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
2081:../uvc.c      ****     uint32_t status;
2082:../uvc.c      **** 
2083:../uvc.c      ****     /* Obtain Request Type and Request */
2084:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
2085:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
2086:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
2087:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
2088:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
2089:../uvc.c      **** 
2090:../uvc.c      ****     /* Check for UVC Class Requests */
2091:../uvc.c      ****     switch (bmReqType)
2092:../uvc.c      ****     {
2093:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
2094:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
2095:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
2096:../uvc.c      ****             switch (wIndex & 0xFF)
2097:../uvc.c      ****             {
2098:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
2099:../uvc.c      ****                     {
2100:../uvc.c      ****                         uvcHandleReq = CyTrue;
2101:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
2102:../uvc.c      ****                                 CYU3P_EVENT_OR);
2103:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2104:../uvc.c      ****                         {
2105:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
2106:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2107:../uvc.c      ****                         }
2108:../uvc.c      ****                     }
2109:../uvc.c      ****                     break;
2110:../uvc.c      **** 
2111:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
2112:../uvc.c      ****                     {
2113:../uvc.c      ****                         uvcHandleReq = CyTrue;
2114:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
2115:../uvc.c      ****                                 CYU3P_EVENT_OR);
2116:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
2117:../uvc.c      ****                         {
2118:../uvc.c      ****                             /* Error handling */
2119:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
2120:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
2121:../uvc.c      ****                         }
2122:../uvc.c      ****                     }
2123:../uvc.c      ****                     break;
2124:../uvc.c      **** 
2125:../uvc.c      ****                 default:
2126:../uvc.c      ****                     break;
2127:../uvc.c      ****             }
2128:../uvc.c      ****             break;
2129:../uvc.c      **** 
2130:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
2131:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
2132:../uvc.c      ****             {
2133:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
2134:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
2135:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
2136:../uvc.c      ****                 {
2137:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
2138:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
2139:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
2140:../uvc.c      ****                     gpif_initialized = 0;
2141:../uvc.c      ****                     streamingStarted = CyFalse;
2142:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
2143:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2144:../uvc.c      ****                     CyU3PBusyWait (100);
2145:../uvc.c      **** 
2146:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
2147:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2148:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2149:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2150:../uvc.c      ****                     CyU3PBusyWait (100);
2151:../uvc.c      **** 
2152:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
2153:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2154:../uvc.c      ****                     uvcHandleReq = CyTrue;
2155:../uvc.c      ****                     /* Complete Control request handshake */
2156:../uvc.c      ****                     CyU3PUsbAckSetup ();
2157:../uvc.c      ****                     /* Indicate stop streaming to main thread */
2158:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
2159:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
2160:../uvc.c      **** 
2161:../uvc.c      ****                 }
2162:../uvc.c      ****             }
2163:../uvc.c      ****             break;
2164:../uvc.c      **** 
2165:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
2166:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
2167:../uvc.c      ****             {
2168:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
2169:../uvc.c      ****                 {
2170:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
2171:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
2172:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
2173:../uvc.c      ****                 	 * has started. */
2174:../uvc.c      ****                     if (streamingStarted == CyTrue)
2175:../uvc.c      ****                     {
2176:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
2177:../uvc.c      **** 
2178:../uvc.c      ****                         /* Disable the GPIF state machine. */
2179:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
2180:../uvc.c      ****                         gpif_initialized = 0;
2181:../uvc.c      ****                         streamingStarted = CyFalse;
2182:../uvc.c      **** 
2183:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
2184:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
2185:../uvc.c      ****                         CyU3PBusyWait (100);
2186:../uvc.c      **** 
2187:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
2188:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2189:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2190:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
2191:../uvc.c      ****                         CyU3PBusyWait (100);
2192:../uvc.c      **** 
2193:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
2194:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
2195:../uvc.c      **** 
2196:../uvc.c      ****                         uvcHandleReq = CyTrue;
2197:../uvc.c      ****                         /* Complete Control request handshake */
2198:../uvc.c      ****                         CyU3PUsbAckSetup ();
2199:../uvc.c      ****                         /* Indicate stop streaming to main thread */
2200:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
2201:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
2202:../uvc.c      ****                     }
2203:../uvc.c      ****                     else
2204:../uvc.c      ****                     {
2205:../uvc.c      ****                         uvcHandleReq = CyTrue;
2206:../uvc.c      ****                         CyU3PUsbAckSetup ();
2207:../uvc.c      ****                     }
2208:../uvc.c      ****                 }
2209:../uvc.c      ****             }
2210:../uvc.c      ****             break;
2211:../uvc.c      **** 
2212:../uvc.c      ****         default:
2213:../uvc.c      ****             break;
2214:../uvc.c      ****     }
2215:../uvc.c      **** 
2216:../uvc.c      ****     /* Return status of request handling to the USB driver */
2217:../uvc.c      ****     return uvcHandleReq;
2218:../uvc.c      **** }
2219:../uvc.c      **** 
2220:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
2221:../uvc.c      **** 
2222:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
2223:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
2224:../uvc.c      ****  */
2225:../uvc.c      **** void
2226:../uvc.c      **** CyFxUvcApplnDmaCallback (
2227:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
2228:../uvc.c      ****         CyU3PDmaCbType_t      type,
2229:../uvc.c      ****         CyU3PDmaCBInput_t    *input
2230:../uvc.c      ****         )
2231:../uvc.c      **** {
2232:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
2233:../uvc.c      **** #if 1
2234:../uvc.c      ****     CyU3PReturnStatus_t status;
2235:../uvc.c      ****     //CyU3PDebugPrint (4, "DMA Callback: event = %d, size = %x, dmaDone %x\r\n",
2236:../uvc.c      ****       //                                          type, input->buffer_p.count, prodCount - consCoun
2237:../uvc.c      **** 
2238:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2239:../uvc.c      ****     {
2240:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
2241:../uvc.c      ****             {
2242:../uvc.c      **** #if 0  //remove the still flag stting here, move into the App thread
2243:../uvc.c      ****                 if((fb == 0)&&(stiflag == 0x0F)){
2244:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2245:../uvc.c      ****                 	//glUVCHeader[1] |= (1<<5);    //set still image flag
2246:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
2247:../uvc.c      ****                 	stiflag = 0x03;
2248:../uvc.c      ****                 }else if(0&&(fb!=0)&&(stiflag == 0x0F)){
2249:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2250:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2251:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2252:../uvc.c      ****                 }
2253:../uvc.c      **** #endif
2254:../uvc.c      ****             	CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_FRAM
2255:../uvc.c      ****                 fb++;
2256:../uvc.c      ****             }
2257:../uvc.c      ****             else
2258:../uvc.c      ****             {
2259:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
2260:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
2261:../uvc.c      ****                 pb++;
2262:../uvc.c      ****                 pbc = input->buffer_p.count;
2263:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
2264:../uvc.c      ****                 //                        status, input->buffer_p.count, prodCount, consCount, line
2265:../uvc.c      ****                 //lineCount = 0; //res test
2266:../uvc.c      **** #if 1   //remove the still flag clearing here
2267:../uvc.c      ****                 if(stiflag == 0x0F){
2268:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
2269:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2270:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
2271:../uvc.c      ****                 	stiflag = 0xAA;
2272:../uvc.c      ****                 }
2273:../uvc.c      **** #endif
2274:../uvc.c      ****                 hitFV = CyTrue;  //set the hitFV flag to indicate the the partial buffer has been c
2275:../uvc.c      ****             }
2276:../uvc.c      **** 
2277:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
2278:../uvc.c      ****             prodCount++;
2279:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2280:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
2281:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
2282:../uvc.c      ****             if ((status != CY_U3P_SUCCESS))
2283:../uvc.c      ****             {
2284:../uvc.c      ****                 prodCount--;
2285:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
2286:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
2287:../uvc.c      ****             }
2288:../uvc.c      ****     }
2289:../uvc.c      **** #endif
2290:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
2291:../uvc.c      ****     {
2292:../uvc.c      ****         consCount++;
2293:../uvc.c      ****         streamingStarted = CyTrue;
2294:../uvc.c      ****     }
2295:../uvc.c      **** }
2296:../uvc.c      **** 
2297:../uvc.c      **** /*
2298:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
2299:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
2300:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
2301:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
2302:../uvc.c      ****  * to commit the buffer.
2303:../uvc.c      ****  */
2304:../uvc.c      **** static uint8_t
2305:../uvc.c      **** CyFxUvcAppCommitEOF (
2306:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
2307:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
2308:../uvc.c      ****         )
2309:../uvc.c      **** {
2310:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2311:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
2312:../uvc.c      **** 
2313:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
2314:../uvc.c      **** 
2315:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2316:../uvc.c      ****     {
2317:../uvc.c      ****         switch (stateId)
2318:../uvc.c      ****         {
2319:../uvc.c      **** 
2320:../uvc.c      ****         	case FULL_BUF_IN_SCK0:
2321:../uvc.c      ****             case FULL_BUF_IN_SCK1:
2322:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2323:../uvc.c      ****                 break;
2324:../uvc.c      **** 
2325:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
2326:../uvc.c      ****                 socket = 0;
2327:../uvc.c      ****                 break;
2328:../uvc.c      **** 
2329:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
2330:../uvc.c      ****                 socket = 1;
2331:../uvc.c      ****                 break;
2332:../uvc.c      **** 
2333:../uvc.c      ****             default:
2334:../uvc.c      ****             	//CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2335:../uvc.c      ****                 /* Unexpected current state. Return error. */
2336:../uvc.c      ****             	//lineCount++;
2337:../uvc.c      ****             	return 1;
2338:../uvc.c      ****         }
2339:../uvc.c      ****     }
2340:../uvc.c      **** 
2341:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2342:../uvc.c      ****     {
2343:../uvc.c      ****         switch (stateId)
2344:../uvc.c      ****         {
2345:../uvc.c      **** #ifndef CAM720
2346:../uvc.c      **** #ifdef GPIFIIM
2347:../uvc.c      ****             case 13:
2348:../uvc.c      ****             case 24:
2349:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2350:../uvc.c      ****                 break;
2351:../uvc.c      **** 
2352:../uvc.c      ****             case 8:
2353:../uvc.c      ****                 socket = 0;
2354:../uvc.c      ****                 break;
2355:../uvc.c      **** 
2356:../uvc.c      ****             case 20:
2357:../uvc.c      ****                 socket = 1;
2358:../uvc.c      ****                 break;
2359:../uvc.c      **** #else
2360:../uvc.c      ****             case 11:
2361:../uvc.c      ****             case 18:
2362:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2363:../uvc.c      ****                 break;
2364:../uvc.c      **** 
2365:../uvc.c      ****             case 8:
2366:../uvc.c      ****                 socket = 0;
2367:../uvc.c      ****                 break;
2368:../uvc.c      **** 
2369:../uvc.c      ****             case 15:
2370:../uvc.c      ****                 socket = 1;
2371:../uvc.c      ****                 break;
2372:../uvc.c      **** #endif
2373:../uvc.c      **** #else
2374:../uvc.c      ****             case 11:
2375:../uvc.c      ****             case 18:
2376:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
2377:../uvc.c      ****                 break;
2378:../uvc.c      **** 
2379:../uvc.c      ****             case 8:
2380:../uvc.c      ****                 socket = 0;
2381:../uvc.c      ****                 break;
2382:../uvc.c      **** 
2383:../uvc.c      ****             case 15:
2384:../uvc.c      ****                 socket = 1;
2385:../uvc.c      ****                 break;
2386:../uvc.c      **** 
2387:../uvc.c      **** #endif
2388:../uvc.c      ****              default:
2389:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
2390:../uvc.c      ****                 /* Unexpected current state. Return error. */
2391:../uvc.c      ****                return 1;
2392:../uvc.c      ****         }
2393:../uvc.c      ****     }
2394:../uvc.c      **** 
2395:../uvc.c      ****     if (socket != 0xFF)
2396:../uvc.c      ****     {
2397:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
2398:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
2399:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
2400:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
2401:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
2402:../uvc.c      ****         {
2403:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
2404:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
2405:../uvc.c      ****         }
2406:../uvc.c      ****     }
2407:../uvc.c      **** 
2408:../uvc.c      ****     return 0;
2409:../uvc.c      **** }
2410:../uvc.c      **** 
2411:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
2412:../uvc.c      **** void
2413:../uvc.c      **** CyFxGpifCB (
2414:../uvc.c      ****         CyU3PGpifEventType event,
2415:../uvc.c      ****         uint8_t currentState
2416:../uvc.c      ****         )
2417:../uvc.c      **** {
2418:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
2419:../uvc.c      ****     {
2420:../uvc.c      ****     	/* KYS: Moving hitFV to where we commit the partial buffer. This fixes a potential race condit
2421:../uvc.c      ****     	           in the UVC implementation. */
2422:../uvc.c      ****     	//hitFV = CyTrue;
2423:../uvc.c      ****         if (CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS)
2424:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\r\n");
2425:../uvc.c      ****     }
2426:../uvc.c      ****    // CyU3PDebugPrint(4,"\r\n commiteof state = %d",currentState);
2427:../uvc.c      **** }
2428:../uvc.c      **** 
2429:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
2430:../uvc.c      **** static void
2431:../uvc.c      **** CyFxUVCApplnDebugInit (
2432:../uvc.c      ****         void)
2433:../uvc.c      **** {
2434:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
2435:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
2436:../uvc.c      **** 
2437:../uvc.c      ****     /* Initialize the UART for printing debug messages */
2438:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
2439:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2440:../uvc.c      ****     {
2441:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
2442:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2443:../uvc.c      ****     }
2444:../uvc.c      **** 
2445:../uvc.c      ****     /* Set UART Configuration */
2446:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
2447:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
2448:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
2449:../uvc.c      ****     uartConfig.txEnable = CyTrue;
2450:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
2451:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
2452:../uvc.c      ****     uartConfig.isDma    = CyTrue;
2453:../uvc.c      **** 
2454:../uvc.c      ****     /* Set the UART configuration */
2455:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
2456:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2457:../uvc.c      ****     {
2458:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2459:../uvc.c      ****     }
2460:../uvc.c      **** 
2461:../uvc.c      ****     /* Set the UART transfer */
2462:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
2463:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2464:../uvc.c      ****     {
2465:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2466:../uvc.c      ****     }
2467:../uvc.c      **** 
2468:../uvc.c      ****     /* Initialize the Debug logger module. */
2469:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
2470:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2471:../uvc.c      ****     {
2472:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2473:../uvc.c      ****     }
2474:../uvc.c      **** 
2475:../uvc.c      ****     /* Disable log message headers. */
2476:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
2477:../uvc.c      **** }
2478:../uvc.c      **** 
2479:../uvc.c      **** /* I2C initialization. */
2480:../uvc.c      **** static void
2481:../uvc.c      **** CyFxUVCApplnI2CInit (void)
2482:../uvc.c      **** {
2483:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
2484:../uvc.c      ****     CyU3PReturnStatus_t status;
2485:../uvc.c      **** 
2486:../uvc.c      ****     status = CyU3PI2cInit ();
2487:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
2488:../uvc.c      ****     {
2489:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
2490:../uvc.c      ****         CyFxAppErrorHandler (status);
2491:../uvc.c      ****     }
2492:../uvc.c      **** 
2493:../uvc.c      ****     /*  Set I2C Configuration */
2494:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
2495:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
2496:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
2497:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
2498:../uvc.c      **** 
2499:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
2500:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
2501:../uvc.c      ****     {
2502:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
2503:../uvc.c      ****         CyFxAppErrorHandler (status);
2504:../uvc.c      ****     }
2505:../uvc.c      **** }
2506:../uvc.c      **** 
2507:../uvc.c      **** #ifdef BACKFLOW_DETECT
2508:../uvc.c      **** static void CyFxUvcAppPibCallback (
2509:../uvc.c      ****         CyU3PPibIntrType cbType,
2510:../uvc.c      ****         uint16_t cbArg)
2511:../uvc.c      **** {
2512:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
2513:../uvc.c      ****     {
2514:../uvc.c      ****         if (!back_flow_detected)
2515:../uvc.c      ****         {
2516:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
2517:../uvc.c      ****             back_flow_detected = 1;
2518:../uvc.c      ****         }
2519:../uvc.c      ****     }
2520:../uvc.c      **** }
2521:../uvc.c      **** #endif
2522:../uvc.c      **** 
2523:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2524:../uvc.c      **** static void
2525:../uvc.c      **** CyFxUvcAppDebugCallback (
2526:../uvc.c      ****         CyU3PDmaChannel   *handle,
2527:../uvc.c      ****         CyU3PDmaCbType_t   type,
2528:../uvc.c      ****         CyU3PDmaCBInput_t *input)
2529:../uvc.c      **** {
2530:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
2531:../uvc.c      ****     {
2532:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
2533:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
2534:../uvc.c      ****     }
2535:../uvc.c      **** }
2536:../uvc.c      **** #endif
2537:../uvc.c      **** 
2538:../uvc.c      **** #if 0
2539:../uvc.c      **** static void CyFxAppIntEpCb(
2540:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
2541:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
2542:../uvc.c      **** 		uint8_t  ebNum)
2543:../uvc.c      **** 		{
2544:../uvc.c      **** 			//CyBool_t value;
2545:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
2546:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
2547:../uvc.c      **** 
2548:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
2549:../uvc.c      **** 		}
2550:../uvc.c      **** #endif
2551:../uvc.c      **** 
2552:../uvc.c      **** /* This function initializes the USB Module, creates event group,
2553:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
2554:../uvc.c      ****    configures the DMA module for the UVC Application */
2555:../uvc.c      **** static void
2556:../uvc.c      **** CyFxUVCApplnInit (void)
2557:../uvc.c      **** {
2558:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
2559:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
2560:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
2561:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
2562:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
2563:../uvc.c      ****     CyU3PPibClock_t              pibclock;
2564:../uvc.c      **** 
2565:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
2566:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
2567:../uvc.c      **** 
2568:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2569:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
2570:../uvc.c      **** #endif
2571:../uvc.c      **** 
2572:../uvc.c      ****     /* Create UVC event group */
2573:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
2574:../uvc.c      ****     if (apiRetStatus != 0)
2575:../uvc.c      ****     {
2576:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
2577:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2578:../uvc.c      ****     }
2579:../uvc.c      **** 
2580:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2581:../uvc.c      ****     CyFxUvcAppPTZInit ();
2582:../uvc.c      **** #endif
2583:../uvc.c      **** 
2584:../uvc.c      ****     isUsbConnected = CyFalse;
2585:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
2586:../uvc.c      **** 
2587:../uvc.c      ****     /* Init the GPIO module */
2588:../uvc.c      ****     gpioClock.fastClkDiv = 2;
2589:../uvc.c      ****     gpioClock.slowClkDiv = 2;
2590:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
2591:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
2592:../uvc.c      ****     gpioClock.halfDiv    = 0;
2593:../uvc.c      **** 
2594:../uvc.c      ****     /* Initialize Gpio interface */
2595:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
2596:../uvc.c      ****     if (apiRetStatus != 0)
2597:../uvc.c      ****     {
2598:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
2599:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2600:../uvc.c      ****     }
2601:../uvc.c      **** 
2602:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
2603:../uvc.c      ****      * must use GpioOverride to configure it */
2604:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
2605:../uvc.c      ****     if (apiRetStatus != 0)
2606:../uvc.c      ****     {
2607:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
2608:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2609:../uvc.c      ****     }
2610:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
2611:../uvc.c      ****     if (apiRetStatus != 0)
2612:../uvc.c      ****     {
2613:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
2614:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2615:../uvc.c      ****     }
2616:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
2617:../uvc.c      ****     if (apiRetStatus != 0)
2618:../uvc.c      ****     {
2619:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
2620:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2621:../uvc.c      ****     }
2622:../uvc.c      **** 
2623:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
2624:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2625:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2626:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2627:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2628:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2629:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
2630:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2631:../uvc.c      ****     {
2632:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
2633:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2634:../uvc.c      ****     }
2635:../uvc.c      **** 
2636:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
2637:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2638:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
2639:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
2640:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
2641:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
2642:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2643:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
2644:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2645:../uvc.c      ****     {
2646:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
2647:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2648:../uvc.c      ****     }
2649:../uvc.c      **** 
2650:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
2651:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
2652:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
2653:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
2654:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
2655:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
2656:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
2657:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
2658:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2659:../uvc.c      ****     {
2660:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
2661:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2662:../uvc.c      ****     }
2663:../uvc.c      **** 
2664:../uvc.c      ****     /* Initialize the P-port. */
2665:../uvc.c      ****     pibclock.clkDiv      = 2;
2666:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
2667:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
2668:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
2669:../uvc.c      **** 
2670:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
2671:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2672:../uvc.c      ****     {
2673:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2674:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2675:../uvc.c      ****     }
2676:../uvc.c      **** 
2677:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
2678:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
2679:../uvc.c      **** 
2680:../uvc.c      **** #ifdef BACKFLOW_DETECT
2681:../uvc.c      ****     back_flow_detected = 0;
2682:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
2683:../uvc.c      **** #endif
2684:../uvc.c      **** 
2685:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
2686:../uvc.c      ****     SensorReset ();
2687:../uvc.c      ****     CyU3PThreadSleep(5000);
2688:../uvc.c      ****     //SensorInit ();
2689:../uvc.c      **** 
2690:../uvc.c      ****     /* USB initialization. */
2691:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
2692:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2693:../uvc.c      ****     {
2694:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
2695:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2696:../uvc.c      ****     }
2697:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
2698:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
2699:../uvc.c      **** 
2700:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
2701:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
2702:../uvc.c      **** 
2703:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
2704:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
2705:../uvc.c      **** 
2706:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
2707:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
2708:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
2709:../uvc.c      **** 
2710:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
2711:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
2712:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
2713:../uvc.c      **** 
2714:../uvc.c      ****     /* Configuration descriptors. */
2715:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
2716:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
2717:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
2718:../uvc.c      **** 
2719:../uvc.c      ****     /* String Descriptors */
2720:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
2721:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
2722:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
2723:../uvc.c      **** 
2724:../uvc.c      ****     /* Configure the status interrupt endpoint.
2725:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
2726:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
2727:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
2728:../uvc.c      ****      */
2729:../uvc.c      ****     endPointConfig.enable   = 1;
2730:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
2731:../uvc.c      ****     endPointConfig.pcktSize = 64;
2732:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2733:../uvc.c      ****     endPointConfig.streams  = 0;
2734:../uvc.c      ****     endPointConfig.burstLen = 1;
2735:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
2736:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2737:../uvc.c      ****     {
2738:../uvc.c      ****         /* Error Handling */
2739:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2740:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2741:../uvc.c      ****     }
2742:../uvc.c      **** 
2743:../uvc.c      ****     /* create a DMA for interrupt endpoint */
2744:../uvc.c      ****     dmaInterConfig.size           = 1024;
2745:../uvc.c      ****     dmaInterConfig.count          = 1;
2746:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2747:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
2748:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
2749:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
2750:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
2751:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
2752:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2753:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
2754:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
2755:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
2756:../uvc.c      ****             &dmaInterConfig);
2757:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2758:../uvc.c      ****     {
2759:../uvc.c      ****         /* Error handling */
2760:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
2761:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2762:../uvc.c      ****     }
2763:../uvc.c      **** 
2764:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2765:../uvc.c      ****     if (glInterStaBuffer == 0)
2766:../uvc.c      ****     {
2767:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
2768:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2769:../uvc.c      ****     }
2770:../uvc.c      **** 
2771:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
2772:../uvc.c      ****     CyU3PMutexCreate(&imgHdMux, CYU3P_NO_INHERIT);// create a mutex for the image header operation.
2773:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
2774:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
2775:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
2776:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
2777:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
2778:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
2779:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
2780:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
2781:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
2782:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
2783:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2784:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
2785:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
2786:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
2787:../uvc.c      ****             &dmaMultiConfig);
2788:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2789:../uvc.c      ****     {
2790:../uvc.c      ****         /* Error handling */
2791:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
2792:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2793:../uvc.c      ****     }
2794:../uvc.c      **** 
2795:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
2796:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
2797:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
2798:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
2799:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
2800:../uvc.c      ****      */
2801:../uvc.c      **** 
2802:../uvc.c      ****     endPointConfig.enable   = 1;
2803:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2804:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
2805:../uvc.c      ****     endPointConfig.isoPkts  = 0;
2806:../uvc.c      ****     endPointConfig.streams  = 0;
2807:../uvc.c      ****     endPointConfig.burstLen = 1;
2808:../uvc.c      **** 
2809:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
2810:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2811:../uvc.c      ****     {
2812:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
2813:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2814:../uvc.c      ****     }
2815:../uvc.c      **** 
2816:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
2817:../uvc.c      **** 
2818:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
2819:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2820:../uvc.c      ****     {
2821:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
2822:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2823:../uvc.c      ****     }
2824:../uvc.c      **** 
2825:../uvc.c      ****     channelConfig.size           = 1024;
2826:../uvc.c      ****     channelConfig.count          = 1;
2827:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2828:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2829:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2830:../uvc.c      ****     channelConfig.prodHeader     = 0;
2831:../uvc.c      ****     channelConfig.prodFooter     = 0;
2832:../uvc.c      ****     channelConfig.consHeader     = 0;
2833:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2834:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2835:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2836:../uvc.c      **** 
2837:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2838:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2839:../uvc.c      ****     {
2840:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2841:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2842:../uvc.c      ****     }
2843:../uvc.c      **** 
2844:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2845:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2846:../uvc.c      ****     {
2847:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2848:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2849:../uvc.c      ****     }
2850:../uvc.c      **** 
2851:../uvc.c      ****     channelConfig.size           = 1024;
2852:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2853:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2854:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2855:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2856:../uvc.c      ****     channelConfig.prodHeader     = 0;
2857:../uvc.c      ****     channelConfig.prodFooter     = 0;
2858:../uvc.c      ****     channelConfig.consHeader     = 0;
2859:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2860:../uvc.c      ****     channelConfig.notification   = 0;
2861:../uvc.c      ****     channelConfig.cb             = 0;
2862:../uvc.c      **** 
2863:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2864:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2865:../uvc.c      ****     {
2866:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2867:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2868:../uvc.c      ****     }
2869:../uvc.c      **** 
2870:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2871:../uvc.c      ****     if (glDebugRspBuffer == 0)
2872:../uvc.c      ****     {
2873:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2874:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2875:../uvc.c      ****     }
2876:../uvc.c      **** #endif
2877:../uvc.c      **** 
2878:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2879:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2880:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2881:../uvc.c      ****     {
2882:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2883:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2884:../uvc.c      ****     }
2885:../uvc.c      **** 
2886:../uvc.c      ****     CyU3PBusyWait(100);
2887:../uvc.c      **** 
2888:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2889:../uvc.c      **** 
2890:../uvc.c      ****     endPointConfig.enable   = 1;
2891:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2892:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2893:../uvc.c      ****     {
2894:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2895:../uvc.c      ****     	endPointConfig.burstLen = 16;
2896:../uvc.c      ****     }
2897:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2898:../uvc.c      ****     {
2899:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2900:../uvc.c      ****     	endPointConfig.burstLen = 1;
2901:../uvc.c      ****     }
2902:../uvc.c      ****     endPointConfig.streams  = 0;
2903:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2904:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2905:../uvc.c      ****     {
2906:../uvc.c      ****         /* Error Handling */
2907:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2908:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2909:../uvc.c      ****     }
2910:../uvc.c      **** #if 0    //for still image method 3 using
2911:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2912:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2913:../uvc.c      ****     {
2914:../uvc.c      ****         /* Error Handling */
2915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2917:../uvc.c      ****     }
2918:../uvc.c      **** #endif
2919:../uvc.c      **** 
2920:../uvc.c      **** }
2921:../uvc.c      **** 
2922:../uvc.c      **** /*
2923:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2924:../uvc.c      ****  * streaming session is started.
2925:../uvc.c      ****  */
2926:../uvc.c      **** static void
2927:../uvc.c      **** CyFxUvcAppGpifInit (
2928:../uvc.c      ****         void)
2929:../uvc.c      **** {
2930:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2931:../uvc.c      **** 
2932:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2933:../uvc.c      ****     {
2934:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2935:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2936:../uvc.c      ****     }
2937:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2938:../uvc.c      ****     {
2939:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2940:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2941:../uvc.c      ****     }
2942:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2943:../uvc.c      ****     {
2944:../uvc.c      ****         /* Error Handling */
2945:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2946:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2947:../uvc.c      ****     }
2948:../uvc.c      **** 
2949:../uvc.c      ****     /* Start the state machine from the designated start state. */
2950:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2951:../uvc.c      ****     {
2952:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2953:../uvc.c      ****     }
2954:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2955:../uvc.c      ****     {
2956:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2957:../uvc.c      ****     }
2958:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2959:../uvc.c      ****     {
2960:../uvc.c      ****         /* Error Handling */
2961:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2962:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2963:../uvc.c      ****     }
2964:../uvc.c      **** }
2965:../uvc.c      **** 
2966:../uvc.c      **** /*
2967:../uvc.c      ****  * Entry function for the UVC Application Thread
2968:../uvc.c      ****  */
2969:../uvc.c      **** 
2970:../uvc.c      **** uint32_t posTick;
2971:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2972:../uvc.c      **** 
2973:../uvc.c      **** void  I2CCmdCb(uint32_t input){
  22              		.loc 1 2973 0
  23              		.cfi_startproc
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
2974:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  27              		.loc 1 2974 0
  28 0000 28209FE5 		ldr	r2, .L2
2973:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  29              		.loc 1 2973 0
  30 0004 08402DE9 		stmfd	sp!, {r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  35              		.loc 1 2974 0
  36 0008 002092E5 		ldr	r2, [r2]
2973:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
  37              		.loc 1 2973 0
  38 000c 0030A0E1 		mov	r3, r0
  39              		.loc 1 2974 0
  40 0010 1C109FE5 		ldr	r1, .L2+4
  41 0014 0400A0E3 		mov	r0, #4
  42              	.LVL1:
  43 0018 FEFFFFEB 		bl	CyU3PDebugPrint
  44              	.LVL2:
2975:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  45              		.loc 1 2975 0
  46 001c 14009FE5 		ldr	r0, .L2+8
  47 0020 2010A0E3 		mov	r1, #32
  48 0024 0020A0E3 		mov	r2, #0
2976:../uvc.c      **** }
  49              		.loc 1 2976 0
  50 0028 0840BDE8 		ldmfd	sp!, {r3, lr}
2975:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
  51              		.loc 1 2975 0
  52 002c FEFFFFEA 		b	_txe_event_flags_set
  53              	.LVL3:
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0030 00000000 		.word	posTick
  58 0034 00000000 		.word	.LC0
  59 0038 00000000 		.word	.LANCHOR0
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.align	2
  65              	UVCHandleVideoStreamingRqts:
  66              	.LFB24:
2977:../uvc.c      **** 
2978:../uvc.c      **** 
2979:../uvc.c      **** void
2980:../uvc.c      **** UVCAppThread_Entry (
2981:../uvc.c      ****         uint32_t input)
2982:../uvc.c      **** {
2983:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2984:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2985:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2986:../uvc.c      ****     uint8_t i = 0;
2987:../uvc.c      ****     uint32_t flag;
2988:../uvc.c      ****     uint32_t prinflag = 0;
2989:../uvc.c      **** static uint8_t IMcount = 0;
2990:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2991:../uvc.c      ****     uint32_t frameCnt = 0;
2992:../uvc.c      **** #endif
2993:../uvc.c      ****     /* Initialize the Uart Debug Module */
2994:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2995:../uvc.c      **** 
2996:../uvc.c      ****     /* Initialize the I2C interface */
2997:../uvc.c      **** 	while (i++ < 6){
2998:../uvc.c      **** 		CyU3PThreadSleep(500);
2999:../uvc.c      **** 	}
3000:../uvc.c      **** 
3001:../uvc.c      ****     CyFxUVCApplnI2CInit ();
3002:../uvc.c      **** 
3003:../uvc.c      ****     /* Initialize the UVC Application */
3004:../uvc.c      ****     CyFxUVCApplnInit ();
3005:../uvc.c      ****     /*
3006:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
3007:../uvc.c      **** 
3008:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
3009:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
3010:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
3011:../uvc.c      **** 
3012:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
3013:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
3014:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
3015:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
3016:../uvc.c      **** 
3017:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
3018:../uvc.c      ****        of handling the abort request.
3019:../uvc.c      ****      */
3020:../uvc.c      **** 
3021:../uvc.c      ****     //SensorSetIrisControl(0x4, 0x30, 0x40, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set reference level 
3022:../uvc.c      ****     //CyU3PThreadSleep(1000);
3023:../uvc.c      **** 
3024:../uvc.c      ****     for (;;)
3025:../uvc.c      ****     {
3026:../uvc.c      ****         /* Waiting for the Video Stream Event */
3027:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
3028:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3029:../uvc.c      ****         {
3030:../uvc.c      **** #if 0 //test for new firmware no video bring up
3031:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
3032:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
3033:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
3034:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
3035:../uvc.c      ****             {
3036:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
3037:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
3038:../uvc.c      ****                 {
3039:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3040:../uvc.c      **** #ifdef  USB_LOWRES_IMG
3041:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
3042:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
3043:../uvc.c      **** #endif
3044:../uvc.c      **** #endif
3045:../uvc.c      ****                     }
3046:../uvc.c      ****                 else
3047:../uvc.c      ****                 {
3048:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
3049:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
3050:../uvc.c      **** #ifdef USB_LOWRES_IMG
3051:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
3052:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3053:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
3054:../uvc.c      **** #endif
3055:../uvc.c      **** #endif
3056:../uvc.c      ****                 }
3057:../uvc.c      **** 
3058:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
3059:../uvc.c      ****                 prodCount++;
3060:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
3061:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
3062:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
3063:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3064:../uvc.c      ****                 {
3065:../uvc.c      ****                     prodCount--;
3066:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
3067:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
3068:../uvc.c      ****                 }
3069:../uvc.c      ****             }
3070:../uvc.c      **** #endif
3071:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
3072:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
3073:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
3074:../uvc.c      ****             {
3075:../uvc.c      ****             	if(0&&(prinflag == 0)){
3076:../uvc.c      ****             		CyU3PDebugPrint (4, "(1) fb %d pb % pbc %\n", fb, pb, pbc);
3077:../uvc.c      ****             		prinflag = 1;
3078:../uvc.c      ****             	}
3079:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
3080:../uvc.c      ****             	fb=0;
3081:../uvc.c      ****             	pb=0;
3082:../uvc.c      ****             	pbc=0;
3083:../uvc.c      ****                 prodCount = 0;
3084:../uvc.c      ****                 consCount = 0;
3085:../uvc.c      ****                 hitFV     = CyFalse;
3086:../uvc.c      **** 
3087:../uvc.c      **** #ifdef BACKFLOW_DETECT
3088:../uvc.c      ****                 back_flow_detected = 0;
3089:../uvc.c      **** #endif
3090:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
3091:../uvc.c      ****                 frameCnt++;
3092:../uvc.c      **** #endif
3093:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
3094:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
3095:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
3096:../uvc.c      ****                 //}
3097:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
3098:../uvc.c      ****             	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3099:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
3100:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
3101:../uvc.c      ****                  	if ((stiflag == 0xF0) && CyU3PEventGet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
3102:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
3103:../uvc.c      ****                 		//glUVCHeader[1] |= (1<<5);    //set still image flag
3104:../uvc.c      ****                        	//SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*
3105:../uvc.c      ****                      	//CyU3PThreadSleep(100);
3106:../uvc.c      ****                 		stiflag = 0xFF;
3107:../uvc.c      ****                 		IMcount = 0;
3108:../uvc.c      ****                 	}
3109:../uvc.c      ****                  	else if(stiflag==0xFF){//setting still marker in the stream head after one frame 
3110:../uvc.c      **** 
3111:../uvc.c      ****                  		if(IMcount++ >= 0x3){
3112:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
3113:../uvc.c      ****                 		stiflag = 0x0F;
3114:../uvc.c      ****                 		IMcount = 0;
3115:../uvc.c      ****                 		}
3116:../uvc.c      ****                  		/*if(IMcount > 0x4){
3117:../uvc.c      ****                 			stiflag = 0x0F;
3118:../uvc.c      ****                 			IMcount = 0;
3119:../uvc.c      ****                 		}*/
3120:../uvc.c      **** 
3121:../uvc.c      ****                 }else if(stiflag==0xAA){//recovery video stream res. after one still frame set.
3122:../uvc.c      ****                     //CyU3PThreadSleep(400);
3123:../uvc.c      ****                 	//CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
3124:../uvc.c      ****                    	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3125:../uvc.c      ****                 	//CyU3PMutexPut(&imgHdMux);
3126:../uvc.c      **** 
3127:../uvc.c      ****                 	if(IMcount++ >= 0x3)
3128:../uvc.c      ****                 	{
3129:../uvc.c      ****                     switch (setRes)
3130:../uvc.c      ****                      {
3131:../uvc.c      ****                  	case 1: //1944
3132:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/*boardID
3133:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3134:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x64:0xE4
3135:../uvc.c      ****                  		break;
3136:../uvc.c      ****                  	case 2: //1080
3137:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/*boardID
3138:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3139:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", is60Hz? 0x54:0xD4
3140:../uvc.c      ****                  		break;
3141:../uvc.c      ****                  	case 3: //720
3142:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_DSPBOARD
3143:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3144:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x45:0x
3145:../uvc.c      ****                  		break;
3146:../uvc.c      ****                  	case 4: //VGA
3147:../uvc.c      ****                  		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_DSPBOARD
3148:../uvc.c      ****                  		//CyU3PThreadSleep(100);
3149:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format1 %x %d\n", ((is60Hz? 0x75:0x
3150:../uvc.c      ****                  		break;
3151:../uvc.c      ****                  	default:
3152:../uvc.c      ****                  		break;
3153:../uvc.c      ****                      }
3154:../uvc.c      ****                     IMcount = 0;
3155:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
3156:../uvc.c      ****                 	stiflag = 0x0;
3157:../uvc.c      ****                 	}
3158:../uvc.c      ****                 }
3159:../uvc.c      ****                 CyU3PMutexPut(&imgHdMux);
3160:../uvc.c      ****                 /* Reset the DMA channel. */
3161:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3162:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3163:../uvc.c      ****                 {
3164:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
3165:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3166:../uvc.c      ****                 }
3167:../uvc.c      **** 
3168:../uvc.c      ****                 /* Start Channel Immediately */
3169:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3170:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3171:../uvc.c      ****                 {
3172:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
3173:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3174:../uvc.c      ****                 }
3175:../uvc.c      **** 
3176:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
3177:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
3178:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3179:../uvc.c      ****                 }
3180:../uvc.c      ****         }
3181:../uvc.c      ****         else
3182:../uvc.c      ****         {
3183:../uvc.c      ****             /* If we have a stream abort request pending. */
3184:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
3185:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
3186:../uvc.c      ****             {
3187:../uvc.c      ****                 hitFV     = CyFalse;
3188:../uvc.c      ****                 prodCount = 0;
3189:../uvc.c      ****                 consCount = 0;
3190:../uvc.c      ****                 if(0&&(prinflag == 0)){
3191:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb % pbc %\n", fb, pb, pbc);
3192:../uvc.c      ****                 	prinflag = 1;
3193:../uvc.c      ****                 }
3194:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
3195:../uvc.c      ****                 fb=0;
3196:../uvc.c      ****                 pb=0;
3197:../uvc.c      ****                 pbc=0;
3198:../uvc.c      **** 
3199:../uvc.c      ****                 if (!clearFeatureRqtReceived)
3200:../uvc.c      ****                 {
3201:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
3202:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
3203:../uvc.c      ****                     {
3204:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
3205:../uvc.c      ****                     }
3206:../uvc.c      **** 
3207:../uvc.c      ****                     /* Flush the Endpoint memory */
3208:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
3209:../uvc.c      ****                 }
3210:../uvc.c      **** 
3211:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
3212:../uvc.c      ****             }
3213:../uvc.c      ****             else
3214:../uvc.c      ****             {
3215:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
3216:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
3217:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
3218:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
3219:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
3220:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
3221:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3222:../uvc.c      ****                 {
3223:../uvc.c      ****                     /* Error handling */
3224:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
3225:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3226:../uvc.c      ****                 }
3227:../uvc.c      **** 
3228:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
3229:../uvc.c      ****                 if (gpif_initialized == CyFalse)
3230:../uvc.c      ****                 {
3231:../uvc.c      **** #if 0
3232:../uvc.c      ****                 	//for start up of the AF Lens
3233:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3234:../uvc.c      ****                     CyU3PThreadSleep(500);
3235:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3236:../uvc.c      ****                     CyU3PThreadSleep(500);
3237:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
3238:../uvc.c      ****                    	CyU3PThreadSleep(300);
3239:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
3240:../uvc.c      ****                     CyU3PThreadSleep(500);
3241:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
3242:../uvc.c      ****                     CyU3PThreadSleep(500);
3243:../uvc.c      **** #endif
3244:../uvc.c      **** #if 0
3245:../uvc.c      ****                     switch (setRes)
3246:../uvc.c      ****                     {
3247:../uvc.c      ****                     	case 1: //1944
3248:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x64, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3249:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3250:../uvc.c      ****                     		break;
3251:../uvc.c      ****                     	case 2: //1080
3252:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x54, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3253:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3254:../uvc.c      ****                     		break;
3255:../uvc.c      ****                     	case 3: //720
3256:../uvc.c      ****                     		SensorSetIrisControl(0x1, 0x30, 0x45, I2C_DSPBOARD_ADDR_WR/*boardID*/);//star
3257:../uvc.c      ****                     		CyU3PThreadSleep(1000);
3258:../uvc.c      ****                     		break;
3259:../uvc.c      ****                     	default:
3260:../uvc.c      ****                     		break;
3261:../uvc.c      ****                     }
3262:../uvc.c      **** #endif
3263:../uvc.c      ****                     CyFxUvcAppGpifInit ();
3264:../uvc.c      **** 
3265:../uvc.c      ****                     gpif_initialized = CyTrue;
3266:../uvc.c      ****                     CyU3PThreadSleep(200);
3267:../uvc.c      ****                     
3268:../uvc.c      ****                 }
3269:../uvc.c      ****                 else
3270:../uvc.c      ****                 {
3271:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
3272:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
3273:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
3274:../uvc.c      ****                 }
3275:../uvc.c      ****             }
3276:../uvc.c      ****         }
3277:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
3278:../uvc.c      **** 
3279:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
3280:../uvc.c      ****         CyU3PThreadRelinquish ();
3281:../uvc.c      ****     }
3282:../uvc.c      **** }
3283:../uvc.c      **** 
3284:../uvc.c      **** /*
3285:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
3286:../uvc.c      ****  */
3287:../uvc.c      **** 
3288:../uvc.c      **** static void
3289:../uvc.c      **** UVCHandleProcessingUnitRqts (
3290:../uvc.c      ****         void)
3291:../uvc.c      **** {
3292:../uvc.c      ****     uint8_t CtrlAdd;
3293:../uvc.c      **** #ifdef DbgInfo
3294:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3295:../uvc.c      **** #endif
3296:../uvc.c      ****     switch (wValue)
3297:../uvc.c      ****     {
3298:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
3299:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
3300:../uvc.c      ****     		ControlHandle(BLCCtlID0);
3301:../uvc.c      ****     		break;
3302:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
3303:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
3304:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
3305:../uvc.c      ****     		break;
3306:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
3307:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
3308:../uvc.c      **** 			ControlHandle(ConsCtlID2);
3309:../uvc.c      **** 			break;
3310:../uvc.c      **** 
3311:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
3312:../uvc.c      **** 
3313:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
3314:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
3315:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
3316:../uvc.c      ****       		break;
3317:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
3318:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
3319:../uvc.c      ****      		ControlHandle(HueCtlID5);
3320:../uvc.c      ****      		break;
3321:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
3322:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
3323:../uvc.c      ****           		ControlHandle(SaturCtlID6);
3324:../uvc.c      ****           		break;
3325:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
3326:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
3327:../uvc.c      ****           		ControlHandle(ShapCtlID7);
3328:../uvc.c      ****           		break;
3329:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
3330:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
3331:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
3332:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
3333:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
3334:../uvc.c      ****     		break;
3335:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
3336:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
3337:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
3338:../uvc.c      ****     		break;
3339:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
3340:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
3341:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
3342:../uvc.c      ****     		break;
3343:../uvc.c      **** 
3344:../uvc.c      ****         default:
3345:../uvc.c      ****             /*
3346:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3347:../uvc.c      ****              * other controls.
3348:../uvc.c      ****              */
3349:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3350:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3351:../uvc.c      ****             break;
3352:../uvc.c      ****     }
3353:../uvc.c      **** }
3354:../uvc.c      **** 
3355:../uvc.c      **** /*
3356:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
3357:../uvc.c      ****  */
3358:../uvc.c      **** static void
3359:../uvc.c      **** UVCHandleCameraTerminalRqts (
3360:../uvc.c      ****         void)
3361:../uvc.c      **** {
3362:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3363:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3364:../uvc.c      ****     uint16_t readCount;
3365:../uvc.c      ****     uint16_t zoomVal;
3366:../uvc.c      ****     int32_t  panVal, tiltVal;
3367:../uvc.c      ****     CyBool_t sendData = CyFalse;
3368:../uvc.c      **** #endif
3369:../uvc.c      ****     uint8_t CtrlAdd;
3370:../uvc.c      **** 
3371:../uvc.c      ****     switch (wValue)
3372:../uvc.c      ****     {
3373:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
3374:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
3375:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
3376:../uvc.c      ****     		break;
3377:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
3378:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
3379:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
3380:../uvc.c      ****     		break;
3381:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
3382:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
3383:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
3384:../uvc.c      **** 			break;
3385:../uvc.c      **** 
3386:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
3387:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
3388:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
3389:../uvc.c      **** 			break;
3390:../uvc.c      **** 
3391:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
3392:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
3393:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
3394:../uvc.c      ****       		break;
3395:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
3396:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
3397:../uvc.c      ****      		CTControlHandle(FocACtlID5);
3398:../uvc.c      ****      		break;
3399:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
3400:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
3401:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
3402:../uvc.c      ****           		break;
3403:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
3404:../uvc.c      ****           		break;
3405:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
3406:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
3407:../uvc.c      ****      		CTControlHandle(IriACtlID7);
3408:../uvc.c      ****      		break;
3409:../uvc.c      **** 
3410:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
3411:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
3412:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
3413:../uvc.c      ****     		break;
3414:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3415:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
3416:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
3417:../uvc.c      ****     		break;
3418:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
3419:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
3420:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
3421:../uvc.c      ****     		break;
3422:../uvc.c      **** 
3423:../uvc.c      ****         default:
3424:../uvc.c      ****             /*
3425:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
3426:../uvc.c      ****              * other controls.
3427:../uvc.c      ****              */
3428:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
3429:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3430:../uvc.c      ****             break;
3431:../uvc.c      ****     }
3432:../uvc.c      **** 
3433:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
3434:../uvc.c      ****     switch (wValue)
3435:../uvc.c      ****     {
3436:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
3437:../uvc.c      ****             switch (bRequest)
3438:../uvc.c      ****             {
3439:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3440:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
3441:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3442:../uvc.c      ****                     break;
3443:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
3444:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
3445:../uvc.c      ****                     sendData = CyTrue;
3446:../uvc.c      ****                     break;
3447:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
3448:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
3449:../uvc.c      ****                     sendData = CyTrue;
3450:../uvc.c      ****                     break;
3451:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
3452:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
3453:../uvc.c      ****                     sendData = CyTrue;
3454:../uvc.c      ****                     break;
3455:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
3456:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
3457:../uvc.c      ****                     sendData = CyTrue;
3458:../uvc.c      ****                     break;
3459:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
3460:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
3461:../uvc.c      ****                     sendData = CyTrue;
3462:../uvc.c      ****                     break;
3463:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3464:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3465:../uvc.c      ****                             glEp0Buffer, &readCount);
3466:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3467:../uvc.c      ****                     {
3468:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
3469:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
3470:../uvc.c      ****                     }
3471:../uvc.c      ****                     break;
3472:../uvc.c      ****                 default:
3473:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3474:../uvc.c      ****                     break;
3475:../uvc.c      ****             }
3476:../uvc.c      **** 
3477:../uvc.c      ****             if (sendData)
3478:../uvc.c      ****             {
3479:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
3480:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
3481:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
3482:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3483:../uvc.c      ****             }
3484:../uvc.c      ****             break;
3485:../uvc.c      **** 
3486:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
3487:../uvc.c      ****             switch (bRequest)
3488:../uvc.c      ****             {
3489:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3490:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
3491:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3492:../uvc.c      ****                     break;
3493:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3494:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
3495:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
3496:../uvc.c      ****                     sendData = CyTrue;
3497:../uvc.c      ****                     break;
3498:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3499:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
3500:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
3501:../uvc.c      ****                     sendData = CyTrue;
3502:../uvc.c      ****                     break;
3503:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3504:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
3505:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
3506:../uvc.c      ****                     sendData = CyTrue;
3507:../uvc.c      ****                     break;
3508:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
3509:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
3510:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
3511:../uvc.c      ****                     sendData = CyTrue;
3512:../uvc.c      ****                     break;
3513:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
3514:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
3515:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
3516:../uvc.c      ****                     sendData = CyTrue;
3517:../uvc.c      ****                     break;
3518:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3519:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3520:../uvc.c      ****                             glEp0Buffer, &readCount);
3521:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3522:../uvc.c      ****                     {
3523:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
3524:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
3525:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
3526:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
3527:../uvc.c      **** 
3528:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
3529:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
3530:../uvc.c      ****                     }
3531:../uvc.c      ****                     break;
3532:../uvc.c      ****                 default:
3533:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3534:../uvc.c      ****                     break;
3535:../uvc.c      ****             }
3536:../uvc.c      **** 
3537:../uvc.c      ****             if (sendData)
3538:../uvc.c      ****             {
3539:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
3540:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
3541:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
3542:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
3543:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
3544:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
3545:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
3546:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
3547:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
3548:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
3549:../uvc.c      ****             }
3550:../uvc.c      ****             break;
3551:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
3552:../uvc.c      ****         default:
3553:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
3554:../uvc.c      ****             break;
3555:../uvc.c      ****     }
3556:../uvc.c      **** #endif
3557:../uvc.c      **** }
3558:../uvc.c      **** 
3559:../uvc.c      **** /*
3560:../uvc.c      ****  * Handler for UVC Interface control requests.
3561:../uvc.c      ****  */
3562:../uvc.c      **** static void
3563:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
3564:../uvc.c      ****         void)
3565:../uvc.c      **** {
3566:../uvc.c      **** 
3567:../uvc.c      ****     switch (wValue)
3568:../uvc.c      ****     {
3569:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
3570:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3571:../uvc.c      ****     		break;
3572:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
3573:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
3574:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
3575:../uvc.c      ****     		break;
3576:../uvc.c      ****     	default:
3577:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
3578:../uvc.c      ****      		break;
3579:../uvc.c      ****     }
3580:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
3581:../uvc.c      **** 
3582:../uvc.c      **** }
3583:../uvc.c      **** 
3584:../uvc.c      **** /*
3585:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
3586:../uvc.c      ****  */
3587:../uvc.c      **** static void
3588:../uvc.c      **** UVCHandleExtensionUnitRqts (
3589:../uvc.c      ****         void)
3590:../uvc.c      **** {
3591:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
3592:../uvc.c      **** 
3593:../uvc.c      **** #ifdef DbgInfo
3594:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
3595:../uvc.c      **** #endif
3596:../uvc.c      ****     switch (wValue)
3597:../uvc.c      ****     {
3598:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
3599:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
3600:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
3601:../uvc.c      ****     		break;
3602:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
3603:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
3604:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
3605:../uvc.c      ****     		break;
3606:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
3607:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
3608:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
3609:../uvc.c      ****      		break;
3610:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
3611:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
3612:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
3613:../uvc.c      ****     		break;
3614:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
3615:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
3616:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
3617:../uvc.c      ****     		break;
3618:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
3619:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
3620:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
3621:../uvc.c      ****      		break;
3622:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
3623:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
3624:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
3625:../uvc.c      ****     		break;
3626:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
3627:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
3628:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
3629:../uvc.c      ****     		break;
3630:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
3631:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
3632:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
3633:../uvc.c      ****      		break;
3634:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
3635:../uvc.c      ****     		if(1||CamMode == 1){//only 720p support
3636:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
3637:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
3638:../uvc.c      ****     		}else/* no support for 1080p camera */
3639:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
3640:../uvc.c      ****     		break;
3641:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
3642:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
3643:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
3644:../uvc.c      ****     		break;
3645:../uvc.c      **** 		case CY_FX_EXT_CONTROL_12: //AEx shutter level CONTROL12
3646:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCtlShutlevCtlID11][0];
3647:../uvc.c      ****       		ControlHandle(ExtCtlShutlevCtlID11);
3648:../uvc.c      ****     		break;
3649:../uvc.c      **** 
3650:../uvc.c      ****     		//ExtCtlShutlevCtlID11
3651:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
3652:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
3653:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
3654:../uvc.c      ****     		break;
3655:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
3656:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
3657:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
3658:../uvc.c      ****     		//break;
3659:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
3660:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
3661:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
3662:../uvc.c      ****     		break;
3663:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
3664:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
3665:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
3666:../uvc.c      ****     		break;
3667:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
3668:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID4-EXUAOFFSET][0];
3669:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID4);
3670:../uvc.c      ****     		break;
3671:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
3672:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID5-EXUAOFFSET][0];
3673:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID5);
3674:../uvc.c      ****     		break;
3675:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
3676:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID6-EXUAOFFSET][0];
3677:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID6);
3678:../uvc.c      ****     		break;
3679:../uvc.c      ****    	default:
3680:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
3681:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
3682:../uvc.c      ****     		break;
3683:../uvc.c      ****     }
3684:../uvc.c      **** 
3685:../uvc.c      **** }
3686:../uvc.c      **** 
3687:../uvc.c      **** /*
3688:../uvc.c      ****  * Handler for the video streaming control requests.
3689:../uvc.c      ****  */
3690:../uvc.c      **** static void
3691:../uvc.c      **** UVCHandleVideoStreamingRqts (
3692:../uvc.c      ****         void)
3693:../uvc.c      **** {
  67              		.loc 1 3693 0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 8
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              	.LVL4:
3694:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
3695:../uvc.c      ****     uint16_t readCount;
3696:../uvc.c      **** 
3697:../uvc.c      ****     switch (wValue)
  72              		.loc 1 3697 0
  73 003c A8369FE5 		ldr	r3, .L133
3693:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  74              		.loc 1 3693 0
  75 0040 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  76              	.LCFI1:
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 4, -16
  79              		.cfi_offset 5, -12
  80              		.cfi_offset 6, -8
  81              		.cfi_offset 14, -4
  82              		.loc 1 3697 0
  83 0044 B030D3E1 		ldrh	r3, [r3]
3693:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
  84              		.loc 1 3693 0
  85 0048 10D04DE2 		sub	sp, sp, #16
  86              	.LCFI2:
  87              		.cfi_def_cfa_offset 32
  88              		.loc 1 3697 0
  89 004c 030C53E3 		cmp	r3, #768
  90 0050 5200000A 		beq	.L6
  91 0054 1300008A 		bhi	.L7
  92 0058 010C53E3 		cmp	r3, #256
  93 005c 2400000A 		beq	.L8
  94 0060 020C53E3 		cmp	r3, #512
  95 0064 1C00001A 		bne	.L5
3698:../uvc.c      ****     {
3699:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
3700:../uvc.c      ****             switch (bRequest)
3701:../uvc.c      ****             {
3702:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3703:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3704:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3705:../uvc.c      ****                     break;
3706:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3707:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3708:../uvc.c      ****                     glEp0Buffer[1] = 0;
3709:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3710:../uvc.c      ****                     break;
3711:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3712:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
3713:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
3714:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3715:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3716:../uvc.c      ****                     {
3717:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrlFul
3718:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
3719:../uvc.c      **** 
3720:../uvc.c      ****                     }
3721:../uvc.c      ****                     else
3722:../uvc.c      ****                     {
3723:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3724:../uvc.c      ****                     }
3725:../uvc.c      ****                     break;
3726:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3727:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3728:../uvc.c      ****                             glCommitCtrl, &readCount);
3729:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3730:../uvc.c      ****                     {
3731:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3732:../uvc.c      ****                         {
3733:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
3734:../uvc.c      ****                                active data structure. */
3735:../uvc.c      ****                             glProbeCtrlFull[2] = glCommitCtrl[2];
3736:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
3737:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
3738:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
3739:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
3740:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
3741:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
3742:../uvc.c      ****                             //glProbeCtrl[19] = glCommitCtrl[19];
3743:../uvc.c      ****                             //glProbeCtrl[20] = glCommitCtrl[20];
3744:../uvc.c      ****                             //glProbeCtrl[21] = glCommitCtrl[21];
3745:../uvc.c      **** #if 0
3746:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream SET request Code: %d\n", bRequest);
3747:../uvc.c      ****                             CyU3PDebugPrint (4, "video stream GET Ctrl Code: %d, %d, %d, %d, %d, %d
3748:../uvc.c      ****                             		glCommitCtrl[2], glCommitCtrl[3], glCommitCtrl[4],
3749:../uvc.c      ****                             		glCommitCtrl[5], glCommitCtrl[6], glCommitCtrl[7]);
3750:../uvc.c      **** #endif
3751:../uvc.c      ****                             //setRes = glProbeCtrlFull[3]; //set resolution flag
3752:../uvc.c      ****                        }
3753:../uvc.c      ****                     }
3754:../uvc.c      ****                     break;
3755:../uvc.c      ****                 default:
3756:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3757:../uvc.c      ****                     break;
3758:../uvc.c      ****             }
3759:../uvc.c      ****             break;
3760:../uvc.c      **** 
3761:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
3762:../uvc.c      ****             switch (bRequest)
  96              		.loc 1 3762 0
  97 0068 80369FE5 		ldr	r3, .L133+4
  98 006c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
  99 0070 810053E3 		cmp	r3, #129
 100 0074 9000000A 		beq	.L23
 101 0078 AF00009A 		bls	.L127
 102              	.L53:
3763:../uvc.c      ****             {
3764:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
3765:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
3766:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3767:../uvc.c      ****                     break;
3768:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
3769:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3770:../uvc.c      ****                     glEp0Buffer[1] = 0;
3771:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3772:../uvc.c      ****                     break;
3773:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
3774:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
3775:../uvc.c      ****                     {
3776:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
3777:../uvc.c      ****                     }
3778:../uvc.c      ****                     else
3779:../uvc.c      ****                     {
3780:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
3781:../uvc.c      ****                     }
3782:../uvc.c      ****                     break;
3783:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
3784:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
3785:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
3786:../uvc.c      ****                        */
3787:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3788:../uvc.c      ****                             glCommitCtrl, &readCount);
3789:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
3790:../uvc.c      ****                     {
3791:../uvc.c      ****                         switch (glCommitCtrl[3])
3792:../uvc.c      ****                          {
3793:../uvc.c      ****                          	case 1: //1944
3794:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR_WR/
3795:../uvc.c      ****                          		CyU3PThreadSleep(500);
3796:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3797:../uvc.c      ****                          		break;
3798:../uvc.c      ****                          	case 2: //1080
3799:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR_WR/
3800:../uvc.c      ****                          		CyU3PThreadSleep(500);
3801:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
3802:../uvc.c      ****                          		break;
3803:../uvc.c      ****                          	case 3: //720
3804:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, I2C_
3805:../uvc.c      ****                          		CyU3PThreadSleep(500);
3806:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3807:../uvc.c      ****                          		break;
3808:../uvc.c      ****                          	case 4: //VGA
3809:../uvc.c      ****                          		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, I2C_
3810:../uvc.c      ****                          		CyU3PThreadSleep(500);
3811:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
3812:../uvc.c      ****                          		break;
3813:../uvc.c      ****                          	default:
3814:../uvc.c      ****                          		break;
3815:../uvc.c      ****                          }
3816:../uvc.c      ****                         setRes = glCommitCtrl[3];
3817:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
3818:../uvc.c      **** 
3819:../uvc.c      **** #if 0
3820:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
3821:../uvc.c      ****                         {
3822:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
3823:../uvc.c      ****                         }
3824:../uvc.c      ****                         else
3825:../uvc.c      ****                         {
3826:../uvc.c      ****                             SensorScaling_VGA ();
3827:../uvc.c      ****                         }
3828:../uvc.c      **** #endif
3829:../uvc.c      ****                         /* We can start streaming video now. */
3830:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
3831:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
3832:../uvc.c      ****                         {
3833:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
3834:../uvc.c      ****                         }
3835:../uvc.c      ****                     }
3836:../uvc.c      ****                     break;
3837:../uvc.c      **** 
3838:../uvc.c      ****                 default:
3839:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3840:../uvc.c      ****                     break;
3841:../uvc.c      ****             }
3842:../uvc.c      ****             break;
3843:../uvc.c      **** 
3844:../uvc.c      **** /* still image streaming handler */
3845:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
3846:../uvc.c      ****                 switch (bRequest)
3847:../uvc.c      ****                 {
3848:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3849:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
3850:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3851:../uvc.c      ****                         break;
3852:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3853:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3854:../uvc.c      ****                         glEp0Buffer[1] = 0;
3855:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3856:../uvc.c      ****                         break;
3857:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3858:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
3859:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
3860:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
3861:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3862:../uvc.c      ****                         {
3863:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3864:../uvc.c      ****                         }
3865:../uvc.c      ****                         else
3866:../uvc.c      ****                         {
3867:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3868:../uvc.c      ****                         }
3869:../uvc.c      ****                         break;
3870:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3871:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3872:../uvc.c      ****                                 glCommitCtrl, &readCount);
3873:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3874:../uvc.c      ****                         {
3875:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
3876:../uvc.c      ****                             {
3877:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
3878:../uvc.c      ****                                    active data structure. */
3879:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
3880:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
3881:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
3882:../uvc.c      ****                             	//glProbeStilCtrl[4] = glCommitCtrl[4];
3883:../uvc.c      ****                             	//glProbeStilCtrl[5] = glCommitCtrl[5];
3884:../uvc.c      ****                             	//glProbeStilCtrl[6] = glCommitCtrl[6];
3885:../uvc.c      ****                             }
3886:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still Prob(set) control %d %d %d\r\n", rea
3887:../uvc.c      ****                         }
3888:../uvc.c      ****                         break;
3889:../uvc.c      ****                     default:
3890:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3891:../uvc.c      ****                         break;
3892:../uvc.c      ****                 }
3893:../uvc.c      ****                 break;
3894:../uvc.c      **** 
3895:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
3896:../uvc.c      ****                 switch (bRequest)
 103              		.loc 1 3896 0
 104 007c 850053E3 		cmp	r3, #133
 105 0080 2500000A 		beq	.L55
 106 0084 860053E3 		cmp	r3, #134
 107 0088 1300001A 		bne	.L5
 108              	.L120:
3897:../uvc.c      ****                 {
3898:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3899:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3900:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3901:../uvc.c      ****                         break;
3902:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3903:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
3904:../uvc.c      ****                         glEp0Buffer[1] = 0;
3905:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3906:../uvc.c      ****                         break;
3907:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
3908:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3909:../uvc.c      ****                         {
3910:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3911:../uvc.c      ****                         }
3912:../uvc.c      ****                         else
3913:../uvc.c      ****                         {
3914:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
3915:../uvc.c      ****                         }
3916:../uvc.c      ****                         break;
3917:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3918:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3919:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3920:../uvc.c      ****                            */
3921:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3922:../uvc.c      ****                                 glCommitCtrl, &readCount);
3923:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3924:../uvc.c      ****                         {
3925:../uvc.c      ****     #if 0
3926:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
3927:../uvc.c      ****                             {
3928:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
3929:../uvc.c      ****                             }
3930:../uvc.c      ****                             else
3931:../uvc.c      ****                             {
3932:../uvc.c      ****                                 SensorScaling_VGA ();
3933:../uvc.c      ****                             }
3934:../uvc.c      ****                             /* We can start streaming video now. */
3935:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3936:../uvc.c      **** 
3937:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3938:../uvc.c      ****                             {
3939:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3940:../uvc.c      ****                             }
3941:../uvc.c      **** 	#endif
3942:../uvc.c      ****                            switch (glCommitCtrl[1])
3943:../uvc.c      ****                              {
3944:../uvc.c      ****                              	case 4: //1944
3945:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x64:0xE4, I2C_DSPBOARD_ADDR
3946:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3947:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3948:../uvc.c      ****                              		break;
3949:../uvc.c      ****                              	case 3: //1080
3950:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, is60Hz? 0x54:0xD4, I2C_DSPBOARD_ADDR
3951:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3952:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", is60Hz
3953:../uvc.c      ****                              		break;
3954:../uvc.c      ****                              	case 2: //720
3955:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x45:0xC5)&0xFC)|ROIMode, 
3956:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3957:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3958:../uvc.c      ****                              		break;
3959:../uvc.c      ****                             	case 1: //VGA
3960:../uvc.c      ****                              		SensorSetIrisControl(0x1, 0x30, ((is60Hz? 0x75:0xF5)&0xFC)|ROIMode, 
3961:../uvc.c      ****                              		//CyU3PThreadSleep(500);
3962:../uvc.c      ****                                     CyU3PDebugPrint (4, "Set the still mode format %x %d\n", ((is60
3963:../uvc.c      ****                              		break;
3964:../uvc.c      ****                               	default:
3965:../uvc.c      ****                              		break;
3966:../uvc.c      ****                              }
3967:../uvc.c      ****                             setstilRes = glCommitCtrl[1];
3968:../uvc.c      **** 
3969:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still commit control set %d %d %d\r\n", readCount
3970:../uvc.c      **** 
3971:../uvc.c      ****                         }
3972:../uvc.c      ****                         break;
3973:../uvc.c      **** 
3974:../uvc.c      ****                     default:
3975:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3976:../uvc.c      ****                         break;
3977:../uvc.c      ****                 }
3978:../uvc.c      ****                 break;
3979:../uvc.c      **** 
3980:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
3981:../uvc.c      ****                 //CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", bRequest, 0);
3982:../uvc.c      ****             	switch (bRequest)
3983:../uvc.c      ****                 {
3984:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3985:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
 109              		.loc 1 3985 0
 110 008c 60169FE5 		ldr	r1, .L133+8
 111 0090 0330A0E3 		mov	r3, #3
 112 0094 2830E1E5 		strb	r3, [r1, #40]!
3986:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 113              		.loc 1 3986 0
 114 0098 0100A0E3 		mov	r0, #1
 115 009c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 116              	.LVL5:
3987:../uvc.c      ****                         break;
3988:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3989:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3990:../uvc.c      ****                         glEp0Buffer[1] = 0;
3991:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3992:../uvc.c      ****                         break;
3993:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3994:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3995:../uvc.c      ****                         {
3996:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3997:../uvc.c      ****                         }
3998:../uvc.c      ****                         else
3999:../uvc.c      ****                         {
4000:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
4001:../uvc.c      ****                         }
4002:../uvc.c      ****                         break;
4003:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
4004:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
4005:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
4006:../uvc.c      ****                            */
4007:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
4008:../uvc.c      ****                                 glCommitCtrl, &readCount);
4009:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
4010:../uvc.c      ****                         {
4011:../uvc.c      ****     #if 1
4012:../uvc.c      ****                             /* We can start still streaming video now. */
4013:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, VD_FX_UVC_STIL_EVENT, CYU3
4014:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
4015:../uvc.c      ****                             {
4016:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STIL_EVENT failed %x\n", apiRetS
4017:../uvc.c      ****                             }
4018:../uvc.c      ****     #endif
4019:../uvc.c      ****                             else{
4020:../uvc.c      ****                             stiflag = 0xF0;//set still trigger flag
4021:../uvc.c      ****                             //stillcont = 0;
4022:../uvc.c      ****                             }
4023:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d %d\r\n", readC
4024:../uvc.c      ****                         }else{
4025:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
4026:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
4027:../uvc.c      ****                         }
4028:../uvc.c      ****                         break;
4029:../uvc.c      **** 
4030:../uvc.c      ****                     default:
4031:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4032:../uvc.c      ****                         break;
4033:../uvc.c      ****                 }
4034:../uvc.c      ****                 break;
4035:../uvc.c      **** 
4036:../uvc.c      ****         default:
4037:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
4038:../uvc.c      ****             break;
4039:../uvc.c      ****     }
4040:../uvc.c      **** }
 117              		.loc 1 4040 0
 118 00a0 10D08DE2 		add	sp, sp, #16
 119              		@ sp needed
 120 00a4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 121              	.L7:
3697:../uvc.c      ****     {
 122              		.loc 1 3697 0
 123 00a8 010B53E3 		cmp	r3, #1024
 124 00ac 2400000A 		beq	.L10
 125 00b0 050C53E3 		cmp	r3, #1280
 126 00b4 0800001A 		bne	.L5
3982:../uvc.c      ****                 {
 127              		.loc 1 3982 0
 128 00b8 30369FE5 		ldr	r3, .L133+4
 129 00bc 0050D3E5 		ldrb	r5, [r3]	@ zero_extendqisi2
 130 00c0 810055E3 		cmp	r5, #129
 131 00c4 7C00000A 		beq	.L23
 132 00c8 8300009A 		bls	.L128
 133 00cc 850055E3 		cmp	r5, #133
 134 00d0 6601000A 		beq	.L76
 135 00d4 860055E3 		cmp	r5, #134
 136 00d8 EBFFFF0A 		beq	.L120
 137              	.L5:
4037:../uvc.c      ****             break;
 138              		.loc 1 4037 0
 139 00dc 0000A0E3 		mov	r0, #0
 140 00e0 0020A0E1 		mov	r2, r0
 141 00e4 0110A0E3 		mov	r1, #1
 142 00e8 FEFFFFEB 		bl	CyU3PUsbStall
 143              	.LVL6:
 144              	.L4:
 145              		.loc 1 4040 0
 146 00ec 10D08DE2 		add	sp, sp, #16
 147              		@ sp needed
 148 00f0 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 149              	.LVL7:
 150              	.L8:
3700:../uvc.c      ****             {
 151              		.loc 1 3700 0
 152 00f4 F4459FE5 		ldr	r4, .L133+4
 153 00f8 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 154 00fc 830053E3 		cmp	r3, #131
 155 0100 5100009A 		bls	.L129
 156 0104 860053E3 		cmp	r3, #134
 157 0108 DFFFFF0A 		beq	.L120
 158 010c 870053E3 		cmp	r3, #135
 159 0110 5901000A 		beq	.L14
 160              	.L125:
3846:../uvc.c      ****                 {
 161              		.loc 1 3846 0
 162 0114 850053E3 		cmp	r3, #133
 163 0118 EFFFFF1A 		bne	.L5
 164              	.L55:
3903:../uvc.c      ****                         glEp0Buffer[1] = 0;
 165              		.loc 1 3903 0
 166 011c D0359FE5 		ldr	r3, .L133+8
 167 0120 1AC0A0E3 		mov	ip, #26
 168              	.L121:
3990:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 169              		.loc 1 3990 0
 170 0124 0020A0E3 		mov	r2, #0
3991:../uvc.c      ****                         break;
 171              		.loc 1 3991 0
 172 0128 281083E2 		add	r1, r3, #40
 173 012c 0200A0E3 		mov	r0, #2
3989:../uvc.c      ****                         glEp0Buffer[1] = 0;
 174              		.loc 1 3989 0
 175 0130 28C0C3E5 		strb	ip, [r3, #40]
3990:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 176              		.loc 1 3990 0
 177 0134 2920C3E5 		strb	r2, [r3, #41]
3991:../uvc.c      ****                         break;
 178              		.loc 1 3991 0
 179 0138 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 180              	.LVL8:
 181              		.loc 1 4040 0
 182 013c 10D08DE2 		add	sp, sp, #16
 183              		@ sp needed
 184 0140 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 185              	.L10:
3896:../uvc.c      ****                 {
 186              		.loc 1 3896 0
 187 0144 A4359FE5 		ldr	r3, .L133+4
 188 0148 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 189 014c 810053E3 		cmp	r3, #129
 190 0150 1A00000A 		beq	.L44
 191 0154 C8FFFF8A 		bhi	.L53
 192 0158 010053E3 		cmp	r3, #1
 193 015c DEFFFF1A 		bne	.L5
3921:../uvc.c      ****                                 glCommitCtrl, &readCount);
 194              		.loc 1 3921 0
 195 0160 8C459FE5 		ldr	r4, .L133+8
 196 0164 2000A0E3 		mov	r0, #32
 197 0168 4C1084E2 		add	r1, r4, #76
 198 016c 08208DE2 		add	r2, sp, #8
 199 0170 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 200              	.LVL9:
3923:../uvc.c      ****                         {
 201              		.loc 1 3923 0
 202 0174 000050E3 		cmp	r0, #0
 203 0178 DBFFFF1A 		bne	.L4
3942:../uvc.c      ****                              {
 204              		.loc 1 3942 0
 205 017c 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 206 0180 01304CE2 		sub	r3, ip, #1
 207 0184 030053E3 		cmp	r3, #3
 208 0188 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 209 018c B80000EA 		b	.L58
 210              	.L60:
 211 0190 F0040000 		.word	.L59
 212 0194 94040000 		.word	.L61
 213 0198 30040000 		.word	.L62
 214 019c 28060000 		.word	.L63
 215              	.LVL10:
 216              	.L6:
3846:../uvc.c      ****                 {
 217              		.loc 1 3846 0
 218 01a0 48359FE5 		ldr	r3, .L133+4
 219 01a4 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 220 01a8 830053E3 		cmp	r3, #131
 221 01ac 0B00009A 		bls	.L130
 222 01b0 860053E3 		cmp	r3, #134
 223 01b4 B4FFFF0A 		beq	.L120
 224 01b8 870053E3 		cmp	r3, #135
 225 01bc D4FFFF1A 		bne	.L125
 226              	.L44:
3861:../uvc.c      ****                         {
 227              		.loc 1 3861 0
 228 01c0 2C359FE5 		ldr	r3, .L133+8
3863:../uvc.c      ****                         }
 229              		.loc 1 3863 0
 230 01c4 0B00A0E3 		mov	r0, #11
3861:../uvc.c      ****                         {
 231              		.loc 1 3861 0
 232 01c8 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 233 01cc 030053E3 		cmp	r3, #3
3863:../uvc.c      ****                         }
 234              		.loc 1 3863 0
 235 01d0 20159F05 		ldreq	r1, .L133+12
3867:../uvc.c      ****                         }
 236              		.loc 1 3867 0
 237 01d4 20159F15 		ldrne	r1, .L133+16
 238 01d8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 239              	.LVL11:
 240 01dc C2FFFFEA 		b	.L4
 241              	.L130:
3846:../uvc.c      ****                 {
 242              		.loc 1 3846 0
 243 01e0 810053E3 		cmp	r3, #129
 244 01e4 F5FFFF2A 		bcs	.L44
 245 01e8 010053E3 		cmp	r3, #1
 246 01ec BAFFFF1A 		bne	.L5
3871:../uvc.c      ****                                 glCommitCtrl, &readCount);
 247              		.loc 1 3871 0
 248 01f0 FC449FE5 		ldr	r4, .L133+8
 249 01f4 2000A0E3 		mov	r0, #32
 250 01f8 4C1084E2 		add	r1, r4, #76
 251 01fc 08208DE2 		add	r2, sp, #8
 252 0200 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 253              	.LVL12:
3873:../uvc.c      ****                         {
 254              		.loc 1 3873 0
 255 0204 000050E3 		cmp	r0, #0
 256 0208 B7FFFF1A 		bne	.L4
3875:../uvc.c      ****                             {
 257              		.loc 1 3875 0
 258 020c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 259 0210 030053E3 		cmp	r3, #3
3879:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 260              		.loc 1 3879 0
 261 0214 4D20D405 		ldreqb	r2, [r4, #77]	@ zero_extendqisi2
 262 0218 E0349F05 		ldreq	r3, .L133+20
3880:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 263              		.loc 1 3880 0
 264 021c 4E00D405 		ldreqb	r0, [r4, #78]	@ zero_extendqisi2
 265              	.LVL13:
 266 0220 4D10D415 		ldrneb	r1, [r4, #77]	@ zero_extendqisi2
 267 0224 0210A001 		moveq	r1, r2
3879:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 268              		.loc 1 3879 0
 269 0228 5520C305 		streqb	r2, [r3, #85]
3880:../uvc.c      ****                             	//glProbeStilCtrl[3] = glCommitCtrl[3];
 270              		.loc 1 3880 0
 271 022c 5600C305 		streqb	r0, [r3, #86]
3886:../uvc.c      ****                         }
 272              		.loc 1 3886 0
 273 0230 B820DDE1 		ldrh	r2, [sp, #8]
 274 0234 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 275 0238 0400A0E3 		mov	r0, #4
 276 023c 00108DE5 		str	r1, [sp]
 277 0240 BC149FE5 		ldr	r1, .L133+24
 278 0244 FEFFFFEB 		bl	CyU3PDebugPrint
 279              	.LVL14:
 280 0248 A7FFFFEA 		b	.L4
 281              	.LVL15:
 282              	.L129:
3700:../uvc.c      ****             {
 283              		.loc 1 3700 0
 284 024c 810053E3 		cmp	r3, #129
 285 0250 0901002A 		bcs	.L14
 286 0254 010053E3 		cmp	r3, #1
 287 0258 9FFFFF1A 		bne	.L5
3727:../uvc.c      ****                             glCommitCtrl, &readCount);
 288              		.loc 1 3727 0
 289 025c 90449FE5 		ldr	r4, .L133+8
 290 0260 2000A0E3 		mov	r0, #32
 291 0264 4C1084E2 		add	r1, r4, #76
 292 0268 08208DE2 		add	r2, sp, #8
 293 026c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 294              	.LVL16:
3729:../uvc.c      ****                     {
 295              		.loc 1 3729 0
 296 0270 000050E3 		cmp	r0, #0
 297 0274 9CFFFF1A 		bne	.L4
3731:../uvc.c      ****                         {
 298              		.loc 1 3731 0
 299 0278 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 300 027c 030053E3 		cmp	r3, #3
 301 0280 99FFFF1A 		bne	.L4
3735:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 302              		.loc 1 3735 0
 303 0284 74349FE5 		ldr	r3, .L133+20
 304 0288 4E60D4E5 		ldrb	r6, [r4, #78]	@ zero_extendqisi2
3736:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 305              		.loc 1 3736 0
 306 028c 4F50D4E5 		ldrb	r5, [r4, #79]	@ zero_extendqisi2
3737:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 307              		.loc 1 3737 0
 308 0290 50C0D4E5 		ldrb	ip, [r4, #80]	@ zero_extendqisi2
3738:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 309              		.loc 1 3738 0
 310 0294 5100D4E5 		ldrb	r0, [r4, #81]	@ zero_extendqisi2
 311              	.LVL17:
3739:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 312              		.loc 1 3739 0
 313 0298 5210D4E5 		ldrb	r1, [r4, #82]	@ zero_extendqisi2
3740:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 314              		.loc 1 3740 0
 315 029c 5320D4E5 		ldrb	r2, [r4, #83]	@ zero_extendqisi2
3735:../uvc.c      ****                             glProbeCtrlFull[3] = glCommitCtrl[3];
 316              		.loc 1 3735 0
 317 02a0 0260C3E5 		strb	r6, [r3, #2]
3736:../uvc.c      ****                             glProbeCtrlFull[4] = glCommitCtrl[4];
 318              		.loc 1 3736 0
 319 02a4 0350C3E5 		strb	r5, [r3, #3]
3737:../uvc.c      ****                             glProbeCtrlFull[5] = glCommitCtrl[5];
 320              		.loc 1 3737 0
 321 02a8 04C0C3E5 		strb	ip, [r3, #4]
3738:../uvc.c      ****                             glProbeCtrlFull[6] = glCommitCtrl[6];
 322              		.loc 1 3738 0
 323 02ac 0500C3E5 		strb	r0, [r3, #5]
3739:../uvc.c      ****                             glProbeCtrlFull[7] = glCommitCtrl[7];
 324              		.loc 1 3739 0
 325 02b0 0610C3E5 		strb	r1, [r3, #6]
3740:../uvc.c      ****                             //glProbeCtrl[18] = glCommitCtrl[18];
 326              		.loc 1 3740 0
 327 02b4 0720C3E5 		strb	r2, [r3, #7]
 328 02b8 8BFFFFEA 		b	.L4
 329              	.LVL18:
 330              	.L23:
3774:../uvc.c      ****                     {
 331              		.loc 1 3774 0
 332 02bc 30349FE5 		ldr	r3, .L133+8
 333 02c0 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 334 02c4 030053E3 		cmp	r3, #3
 335 02c8 2D00000A 		beq	.L131
 336              	.L19:
3723:../uvc.c      ****                     }
 337              		.loc 1 3723 0
 338 02cc 34149FE5 		ldr	r1, .L133+28
 339 02d0 1A00A0E3 		mov	r0, #26
 340 02d4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 341              	.LVL19:
 342 02d8 83FFFFEA 		b	.L4
 343              	.L128:
3982:../uvc.c      ****                 {
 344              		.loc 1 3982 0
 345 02dc 010055E3 		cmp	r5, #1
 346 02e0 7DFFFF1A 		bne	.L5
4007:../uvc.c      ****                                 glCommitCtrl, &readCount);
 347              		.loc 1 4007 0
 348 02e4 08449FE5 		ldr	r4, .L133+8
 349 02e8 08208DE2 		add	r2, sp, #8
 350 02ec 2000A0E3 		mov	r0, #32
 351 02f0 4C1084E2 		add	r1, r4, #76
 352 02f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 353              	.LVL20:
4009:../uvc.c      ****                         {
 354              		.loc 1 4009 0
 355 02f8 002050E2 		subs	r2, r0, #0
 356 02fc EA00001A 		bne	.L79
4013:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 357              		.loc 1 4013 0
 358 0300 0400A0E1 		mov	r0, r4
 359              	.LVL21:
 360 0304 8010A0E3 		mov	r1, #128
 361 0308 FEFFFFEB 		bl	_txe_event_flags_set
 362              	.LVL22:
4014:../uvc.c      ****                             {
 363              		.loc 1 4014 0
 364 030c 002050E2 		subs	r2, r0, #0
4020:../uvc.c      ****                             //stillcont = 0;
 365              		.loc 1 4020 0
 366 0310 0F30E003 		mvneq	r3, #15
 367 0314 7230C405 		streqb	r3, [r4, #114]
4014:../uvc.c      ****                             {
 368              		.loc 1 4014 0
 369 0318 ED00001A 		bne	.L132
 370              	.LVL23:
 371              	.L81:
4023:../uvc.c      ****                         }else{
 372              		.loc 1 4023 0 discriminator 1
 373 031c 4D10D4E5 		ldrb	r1, [r4, #77]	@ zero_extendqisi2
 374 0320 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 375 0324 B820DDE1 		ldrh	r2, [sp, #8]
 376 0328 00108DE5 		str	r1, [sp]
 377 032c 0400A0E3 		mov	r0, #4
 378 0330 D4139FE5 		ldr	r1, .L133+32
 379 0334 FEFFFFEB 		bl	CyU3PDebugPrint
 380              	.LVL24:
 381 0338 6BFFFFEA 		b	.L4
 382              	.LVL25:
 383              	.L127:
3762:../uvc.c      ****             {
 384              		.loc 1 3762 0
 385 033c 010053E3 		cmp	r3, #1
 386 0340 65FFFF1A 		bne	.L5
3787:../uvc.c      ****                             glCommitCtrl, &readCount);
 387              		.loc 1 3787 0
 388 0344 A8439FE5 		ldr	r4, .L133+8
 389 0348 2000A0E3 		mov	r0, #32
 390 034c 4C1084E2 		add	r1, r4, #76
 391 0350 08208DE2 		add	r2, sp, #8
 392 0354 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 393              	.LVL26:
3789:../uvc.c      ****                     {
 394              		.loc 1 3789 0
 395 0358 000050E3 		cmp	r0, #0
 396 035c 62FFFF1A 		bne	.L4
3791:../uvc.c      ****                          {
 397              		.loc 1 3791 0
 398 0360 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 399 0364 013042E2 		sub	r3, r2, #1
 400 0368 030053E3 		cmp	r3, #3
 401 036c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 402 0370 DB0000EA 		b	.L82
 403              	.L30:
 404 0374 D8050000 		.word	.L29
 405 0378 88050000 		.word	.L31
 406 037c 38050000 		.word	.L32
 407 0380 94030000 		.word	.L33
 408              	.LVL27:
 409              	.L131:
3776:../uvc.c      ****                     }
 410              		.loc 1 3776 0
 411 0384 84139FE5 		ldr	r1, .L133+36
 412 0388 1A00A0E3 		mov	r0, #26
 413 038c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 414              	.LVL28:
 415 0390 55FFFFEA 		b	.L4
 416              	.LVL29:
 417              	.L33:
3809:../uvc.c      ****                          		CyU3PThreadSleep(500);
 418              		.loc 1 3809 0
 419 0394 64539FE5 		ldr	r5, .L133+20
 420 0398 6C2094E5 		ldr	r2, [r4, #108]
 421 039c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 422 03a0 000052E3 		cmp	r2, #0
 423 03a4 F420A003 		moveq	r2, #244
 424 03a8 7420A013 		movne	r2, #116
 425 03ac 032082E1 		orr	r2, r2, r3
 426 03b0 3010A0E3 		mov	r1, #48
 427 03b4 5230A0E3 		mov	r3, #82
 428 03b8 0100A0E3 		mov	r0, #1
 429              	.LVL30:
 430 03bc FEFFFFEB 		bl	SensorSetIrisControl
 431              	.LVL31:
3810:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 432              		.loc 1 3810 0
 433 03c0 7D0FA0E3 		mov	r0, #500
 434 03c4 FEFFFFEB 		bl	_tx_thread_sleep
 435              	.LVL32:
3811:../uvc.c      ****                          		break;
 436              		.loc 1 3811 0
 437 03c8 6C1094E5 		ldr	r1, [r4, #108]
 438 03cc 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 439 03d0 6C3094E5 		ldr	r3, [r4, #108]
 440 03d4 000051E3 		cmp	r1, #0
 441 03d8 F410A003 		moveq	r1, #244
 442 03dc 7410A013 		movne	r1, #116
 443              	.L116:
 444 03e0 022081E1 		orr	r2, r1, r2
 445 03e4 0400A0E3 		mov	r0, #4
 446 03e8 24139FE5 		ldr	r1, .L133+40
 447 03ec FEFFFFEB 		bl	CyU3PDebugPrint
 448              	.LVL33:
 449 03f0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
 450              	.L28:
3817:../uvc.c      **** 
 451              		.loc 1 3817 0
 452 03f4 0320A0E1 		mov	r2, r3
 453 03f8 18139FE5 		ldr	r1, .L133+44
 454 03fc 0400A0E3 		mov	r0, #4
3816:../uvc.c      ****                         CyU3PDebugPrint (4, "Set the video mode format setRes %d\n", setRes);
 455              		.loc 1 3816 0
 456 0400 7030C4E5 		strb	r3, [r4, #112]
3817:../uvc.c      **** 
 457              		.loc 1 3817 0
 458 0404 FEFFFFEB 		bl	CyU3PDebugPrint
 459              	.LVL34:
3830:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 460              		.loc 1 3830 0
 461 0408 0020A0E3 		mov	r2, #0
 462 040c E0029FE5 		ldr	r0, .L133+8
 463 0410 0110A0E3 		mov	r1, #1
 464 0414 FEFFFFEB 		bl	_txe_event_flags_set
 465              	.LVL35:
3831:../uvc.c      ****                         {
 466              		.loc 1 3831 0
 467 0418 002050E2 		subs	r2, r0, #0
 468 041c 32FFFF0A 		beq	.L4
3833:../uvc.c      ****                         }
 469              		.loc 1 3833 0
 470 0420 F4129FE5 		ldr	r1, .L133+48
 471 0424 0400A0E3 		mov	r0, #4
 472              	.LVL36:
 473 0428 FEFFFFEB 		bl	CyU3PDebugPrint
 474              	.LVL37:
 475 042c 2EFFFFEA 		b	.L4
 476              	.LVL38:
 477              	.L62:
3950:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 478              		.loc 1 3950 0
 479 0430 6C2094E5 		ldr	r2, [r4, #108]
 480 0434 3010A0E3 		mov	r1, #48
 481 0438 000052E3 		cmp	r2, #0
 482 043c D420A003 		moveq	r2, #212
 483 0440 5420A013 		movne	r2, #84
 484 0444 5230A0E3 		mov	r3, #82
 485 0448 0100A0E3 		mov	r0, #1
 486              	.LVL39:
 487 044c FEFFFFEB 		bl	SensorSetIrisControl
 488              	.LVL40:
3952:../uvc.c      ****                              		break;
 489              		.loc 1 3952 0
 490 0450 6C2094E5 		ldr	r2, [r4, #108]
 491 0454 0400A0E3 		mov	r0, #4
 492 0458 000052E3 		cmp	r2, #0
 493 045c 6C3094E5 		ldr	r3, [r4, #108]
 494 0460 D420A003 		moveq	r2, #212
 495 0464 5420A013 		movne	r2, #84
 496 0468 B0129FE5 		ldr	r1, .L133+52
 497 046c FEFFFFEB 		bl	CyU3PDebugPrint
 498              	.LVL41:
 499 0470 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
 500              	.L58:
3969:../uvc.c      **** 
 501              		.loc 1 3969 0
 502 0474 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 503 0478 B820DDE1 		ldrh	r2, [sp, #8]
 504 047c 00C08DE5 		str	ip, [sp]
 505 0480 9C129FE5 		ldr	r1, .L133+56
3967:../uvc.c      **** 
 506              		.loc 1 3967 0
 507 0484 71C0C4E5 		strb	ip, [r4, #113]
3969:../uvc.c      **** 
 508              		.loc 1 3969 0
 509 0488 0400A0E3 		mov	r0, #4
 510 048c FEFFFFEB 		bl	CyU3PDebugPrint
 511              	.LVL42:
 512 0490 15FFFFEA 		b	.L4
 513              	.LVL43:
 514              	.L61:
3955:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 515              		.loc 1 3955 0
 516 0494 64529FE5 		ldr	r5, .L133+20
 517 0498 6C2094E5 		ldr	r2, [r4, #108]
 518 049c 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 519 04a0 000052E3 		cmp	r2, #0
 520 04a4 C420A003 		moveq	r2, #196
 521 04a8 4420A013 		movne	r2, #68
 522 04ac 032082E1 		orr	r2, r2, r3
 523 04b0 3010A0E3 		mov	r1, #48
 524 04b4 5230A0E3 		mov	r3, #82
 525 04b8 0100A0E3 		mov	r0, #1
 526              	.LVL44:
 527 04bc FEFFFFEB 		bl	SensorSetIrisControl
 528              	.LVL45:
3957:../uvc.c      ****                              		break;
 529              		.loc 1 3957 0
 530 04c0 6C1094E5 		ldr	r1, [r4, #108]
 531 04c4 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 532 04c8 6C3094E5 		ldr	r3, [r4, #108]
 533 04cc 000051E3 		cmp	r1, #0
 534 04d0 C410A003 		moveq	r1, #196
 535 04d4 4410A013 		movne	r1, #68
 536              	.L118:
3962:../uvc.c      ****                              		break;
 537              		.loc 1 3962 0
 538 04d8 022081E1 		orr	r2, r1, r2
 539 04dc 0400A0E3 		mov	r0, #4
 540 04e0 38129FE5 		ldr	r1, .L133+52
 541 04e4 FEFFFFEB 		bl	CyU3PDebugPrint
 542              	.LVL46:
 543 04e8 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
3963:../uvc.c      ****                               	default:
 544              		.loc 1 3963 0
 545 04ec E0FFFFEA 		b	.L58
 546              	.LVL47:
 547              	.L59:
3960:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 548              		.loc 1 3960 0
 549 04f0 08529FE5 		ldr	r5, .L133+20
 550 04f4 6C2094E5 		ldr	r2, [r4, #108]
 551 04f8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 552 04fc 000052E3 		cmp	r2, #0
 553 0500 F420A003 		moveq	r2, #244
 554 0504 7420A013 		movne	r2, #116
 555 0508 032082E1 		orr	r2, r2, r3
 556 050c 3010A0E3 		mov	r1, #48
 557 0510 5230A0E3 		mov	r3, #82
 558 0514 0100A0E3 		mov	r0, #1
 559              	.LVL48:
 560 0518 FEFFFFEB 		bl	SensorSetIrisControl
 561              	.LVL49:
3962:../uvc.c      ****                              		break;
 562              		.loc 1 3962 0
 563 051c 6C1094E5 		ldr	r1, [r4, #108]
 564 0520 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 565 0524 000051E3 		cmp	r1, #0
 566 0528 6C3094E5 		ldr	r3, [r4, #108]
 567 052c F410A003 		moveq	r1, #244
 568 0530 7410A013 		movne	r1, #116
 569 0534 E7FFFFEA 		b	.L118
 570              	.LVL50:
 571              	.L32:
3804:../uvc.c      ****                          		CyU3PThreadSleep(500);
 572              		.loc 1 3804 0
 573 0538 C0519FE5 		ldr	r5, .L133+20
 574 053c 6C2094E5 		ldr	r2, [r4, #108]
 575 0540 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 576 0544 000052E3 		cmp	r2, #0
 577 0548 C420A003 		moveq	r2, #196
 578 054c 4420A013 		movne	r2, #68
 579 0550 032082E1 		orr	r2, r2, r3
 580 0554 3010A0E3 		mov	r1, #48
 581 0558 5230A0E3 		mov	r3, #82
 582 055c 0100A0E3 		mov	r0, #1
 583              	.LVL51:
 584 0560 FEFFFFEB 		bl	SensorSetIrisControl
 585              	.LVL52:
3805:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", ((is60Hz? 
 586              		.loc 1 3805 0
 587 0564 7D0FA0E3 		mov	r0, #500
 588 0568 FEFFFFEB 		bl	_tx_thread_sleep
 589              	.LVL53:
3806:../uvc.c      ****                          		break;
 590              		.loc 1 3806 0
 591 056c 6C1094E5 		ldr	r1, [r4, #108]
 592 0570 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 593 0574 000051E3 		cmp	r1, #0
 594 0578 6C3094E5 		ldr	r3, [r4, #108]
 595 057c C410A003 		moveq	r1, #196
 596 0580 4410A013 		movne	r1, #68
 597 0584 95FFFFEA 		b	.L116
 598              	.LVL54:
 599              	.L31:
3799:../uvc.c      ****                          		CyU3PThreadSleep(500);
 600              		.loc 1 3799 0
 601 0588 6C2094E5 		ldr	r2, [r4, #108]
 602 058c 3010A0E3 		mov	r1, #48
 603 0590 000052E3 		cmp	r2, #0
 604 0594 D420A003 		moveq	r2, #212
 605 0598 5420A013 		movne	r2, #84
 606 059c 5230A0E3 		mov	r3, #82
 607 05a0 0100A0E3 		mov	r0, #1
 608              	.LVL55:
 609 05a4 FEFFFFEB 		bl	SensorSetIrisControl
 610              	.LVL56:
3800:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 611              		.loc 1 3800 0
 612 05a8 7D0FA0E3 		mov	r0, #500
 613 05ac FEFFFFEB 		bl	_tx_thread_sleep
 614              	.LVL57:
3801:../uvc.c      ****                          		break;
 615              		.loc 1 3801 0
 616 05b0 6C2094E5 		ldr	r2, [r4, #108]
 617 05b4 0400A0E3 		mov	r0, #4
 618 05b8 000052E3 		cmp	r2, #0
 619 05bc 6C3094E5 		ldr	r3, [r4, #108]
 620 05c0 D420A003 		moveq	r2, #212
 621 05c4 5420A013 		movne	r2, #84
 622 05c8 44119FE5 		ldr	r1, .L133+40
 623 05cc FEFFFFEB 		bl	CyU3PDebugPrint
 624              	.LVL58:
 625 05d0 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
3802:../uvc.c      ****                          	case 3: //720
 626              		.loc 1 3802 0
 627 05d4 86FFFFEA 		b	.L28
 628              	.LVL59:
 629              	.L29:
3794:../uvc.c      ****                          		CyU3PThreadSleep(500);
 630              		.loc 1 3794 0
 631 05d8 6C2094E5 		ldr	r2, [r4, #108]
 632 05dc 3010A0E3 		mov	r1, #48
 633 05e0 000052E3 		cmp	r2, #0
 634 05e4 E420A003 		moveq	r2, #228
 635 05e8 6420A013 		movne	r2, #100
 636 05ec 5230A0E3 		mov	r3, #82
 637 05f0 0100A0E3 		mov	r0, #1
 638              	.LVL60:
 639 05f4 FEFFFFEB 		bl	SensorSetIrisControl
 640              	.LVL61:
3795:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set the video mode format %x %d\n", is60Hz? 0x
 641              		.loc 1 3795 0
 642 05f8 7D0FA0E3 		mov	r0, #500
 643 05fc FEFFFFEB 		bl	_tx_thread_sleep
 644              	.LVL62:
3796:../uvc.c      ****                          		break;
 645              		.loc 1 3796 0
 646 0600 6C2094E5 		ldr	r2, [r4, #108]
 647 0604 0400A0E3 		mov	r0, #4
 648 0608 000052E3 		cmp	r2, #0
 649 060c 6C3094E5 		ldr	r3, [r4, #108]
 650 0610 E420A003 		moveq	r2, #228
 651 0614 6420A013 		movne	r2, #100
 652 0618 F4109FE5 		ldr	r1, .L133+40
 653 061c FEFFFFEB 		bl	CyU3PDebugPrint
 654              	.LVL63:
 655 0620 4F30D4E5 		ldrb	r3, [r4, #79]	@ zero_extendqisi2
3797:../uvc.c      ****                          	case 2: //1080
 656              		.loc 1 3797 0
 657 0624 72FFFFEA 		b	.L28
 658              	.LVL64:
 659              	.L63:
3945:../uvc.c      ****                              		//CyU3PThreadSleep(500);
 660              		.loc 1 3945 0
 661 0628 6C2094E5 		ldr	r2, [r4, #108]
 662 062c 3010A0E3 		mov	r1, #48
 663 0630 000052E3 		cmp	r2, #0
 664 0634 E420A003 		moveq	r2, #228
 665 0638 6420A013 		movne	r2, #100
 666 063c 5230A0E3 		mov	r3, #82
 667 0640 0100A0E3 		mov	r0, #1
 668              	.LVL65:
 669 0644 FEFFFFEB 		bl	SensorSetIrisControl
 670              	.LVL66:
3947:../uvc.c      ****                              		break;
 671              		.loc 1 3947 0
 672 0648 6C2094E5 		ldr	r2, [r4, #108]
 673 064c 0400A0E3 		mov	r0, #4
 674 0650 000052E3 		cmp	r2, #0
 675 0654 6C3094E5 		ldr	r3, [r4, #108]
 676 0658 E420A003 		moveq	r2, #228
 677 065c 6420A013 		movne	r2, #100
 678 0660 B8109FE5 		ldr	r1, .L133+52
 679 0664 FEFFFFEB 		bl	CyU3PDebugPrint
 680              	.LVL67:
 681 0668 4DC0D4E5 		ldrb	ip, [r4, #77]	@ zero_extendqisi2
3948:../uvc.c      ****                              	case 3: //1080
 682              		.loc 1 3948 0
 683 066c 80FFFFEA 		b	.L58
 684              	.LVL68:
 685              	.L76:
3989:../uvc.c      ****                         glEp0Buffer[1] = 0;
 686              		.loc 1 3989 0
 687 0670 7C309FE5 		ldr	r3, .L133+8
 688 0674 01C0A0E3 		mov	ip, #1
 689 0678 A9FEFFEA 		b	.L121
 690              	.L14:
3715:../uvc.c      ****                     {
 691              		.loc 1 3715 0
 692 067c 70309FE5 		ldr	r3, .L133+8
 693 0680 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 694 0684 030053E3 		cmp	r3, #3
 695 0688 0FFFFF1A 		bne	.L19
3717:../uvc.c      ****                         CyU3PDebugPrint (4, "video stream GET request Code: %d, \n", bRequest);
 696              		.loc 1 3717 0
 697 068c 6C109FE5 		ldr	r1, .L133+20
 698 0690 1A00A0E3 		mov	r0, #26
 699 0694 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 700              	.LVL69:
3718:../uvc.c      **** 
 701              		.loc 1 3718 0
 702 0698 0020D4E5 		ldrb	r2, [r4]	@ zero_extendqisi2
 703 069c 84109FE5 		ldr	r1, .L133+60
 704 06a0 0400A0E3 		mov	r0, #4
 705 06a4 FEFFFFEB 		bl	CyU3PDebugPrint
 706              	.LVL70:
 707 06a8 8FFEFFEA 		b	.L4
 708              	.LVL71:
 709              	.L79:
4025:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
 710              		.loc 1 4025 0
 711 06ac B820DDE1 		ldrh	r2, [sp, #8]
 712 06b0 4C30D4E5 		ldrb	r3, [r4, #76]	@ zero_extendqisi2
 713 06b4 70109FE5 		ldr	r1, .L133+64
 714 06b8 0400A0E3 		mov	r0, #4
 715              	.LVL72:
 716 06bc FEFFFFEB 		bl	CyU3PDebugPrint
 717              	.LVL73:
4026:../uvc.c      ****                         }
 718              		.loc 1 4026 0
 719 06c0 0000A0E3 		mov	r0, #0
 720 06c4 0510A0E1 		mov	r1, r5
 721 06c8 0020A0E1 		mov	r2, r0
 722 06cc FEFFFFEB 		bl	CyU3PUsbStall
 723              	.LVL74:
 724 06d0 85FEFFEA 		b	.L4
 725              	.LVL75:
 726              	.L132:
4016:../uvc.c      ****                             }
 727              		.loc 1 4016 0
 728 06d4 54109FE5 		ldr	r1, .L133+68
 729 06d8 0400A0E3 		mov	r0, #4
 730              	.LVL76:
 731 06dc FEFFFFEB 		bl	CyU3PDebugPrint
 732              	.LVL77:
 733 06e0 0DFFFFEA 		b	.L81
 734              	.LVL78:
 735              	.L82:
3791:../uvc.c      ****                          {
 736              		.loc 1 3791 0
 737 06e4 0230A0E1 		mov	r3, r2
 738 06e8 41FFFFEA 		b	.L28
 739              	.L134:
 740              		.align	2
 741              	.L133:
 742 06ec 00000000 		.word	wValue
 743 06f0 00000000 		.word	bRequest
 744 06f4 00000000 		.word	.LANCHOR0
 745 06f8 54000000 		.word	.LANCHOR1+84
 746 06fc 60000000 		.word	.LANCHOR1+96
 747 0700 00000000 		.word	.LANCHOR1
 748 0704 B4000000 		.word	.LC5
 749 0708 1C000000 		.word	.LANCHOR1+28
 750 070c 50010000 		.word	.LC9
 751 0710 38000000 		.word	.LANCHOR1+56
 752 0714 40000000 		.word	.LC2
 753 0718 64000000 		.word	.LC3
 754 071c 8C000000 		.word	.LC4
 755 0720 E0000000 		.word	.LC6
 756 0724 04010000 		.word	.LC7
 757 0728 18000000 		.word	.LC1
 758 072c 7C010000 		.word	.LC10
 759 0730 2C010000 		.word	.LC8
 760              		.cfi_endproc
 761              	.LFE24:
 763              		.align	2
 764              		.global	I2cAppThread_Entry
 766              	I2cAppThread_Entry:
 767              	.LFB26:
4041:../uvc.c      **** 
4042:../uvc.c      **** /*
4043:../uvc.c      ****  * Entry function for the UVC control request processing thread.
4044:../uvc.c      ****  */
4045:../uvc.c      **** void
4046:../uvc.c      **** UVCAppEP0Thread_Entry (
4047:../uvc.c      ****         uint32_t input)
4048:../uvc.c      **** {
4049:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
4050:../uvc.c      ****     uint32_t eventFlag;
4051:../uvc.c      **** 	CyBool_t value;
4052:../uvc.c      **** 	CyBool_t *valueptr = &value;
4053:../uvc.c      **** 
4054:../uvc.c      **** 
4055:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4056:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4057:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
4058:../uvc.c      **** 
4059:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
4060:../uvc.c      **** #endif
4061:../uvc.c      **** 
4062:../uvc.c      ****     /* for interrupt status test */
4063:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4064:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
4065:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
4066:../uvc.c      **** 
4067:../uvc.c      ****     for (;;)
4068:../uvc.c      ****     {
4069:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
4070:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
4071:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
4072:../uvc.c      ****         {
4073:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
4074:../uvc.c      ****             if (!isUsbConnected)
4075:../uvc.c      ****             {
4076:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
4077:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
4078:../uvc.c      ****                 {
4079:../uvc.c      ****                     isUsbConnected = CyTrue;
4080:../uvc.c      ****                 }
4081:../uvc.c      ****             }
4082:../uvc.c      **** //#ifdef DbgInfo
4083:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
4084:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
4085:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
4086:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
4087:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
4088:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
4089:../uvc.c      **** //#endif
4090:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
4091:../uvc.c      ****             {
4092:../uvc.c      ****             	switch ((wIndex >> 8))
4093:../uvc.c      ****                 {
4094:../uvc.c      **** 
4095:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
4096:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
4097:../uvc.c      ****                         break;
4098:../uvc.c      **** 
4099:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
4100:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
4101:../uvc.c      ****                         break;
4102:../uvc.c      **** 
4103:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
4104:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
4105:../uvc.c      ****                         break;
4106:../uvc.c      **** 
4107:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
4108:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
4109:../uvc.c      ****                         break;
4110:../uvc.c      **** 
4111:../uvc.c      ****                     default:
4112:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
4113:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
4114:../uvc.c      ****                         break;
4115:../uvc.c      ****                 }
4116:../uvc.c      ****             }
4117:../uvc.c      **** 
4118:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
4119:../uvc.c      ****             {
4120:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
4121:../uvc.c      **** 
4122:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
4123:../uvc.c      ****                 {
4124:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
4125:../uvc.c      ****                 }
4126:../uvc.c      ****                 else
4127:../uvc.c      ****                 {
4128:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
4129:../uvc.c      ****                 }
4130:../uvc.c      ****             }
4131:../uvc.c      **** 
4132:../uvc.c      ****             /* handle interrupt status event */
4133:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
4134:../uvc.c      ****             {
4135:../uvc.c      **** 
4136:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
4137:../uvc.c      ****             	/** preparing interrupt status data **/
4138:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
4139:../uvc.c      **** 
4140:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4141:../uvc.c      **** 
4142:../uvc.c      **** #if 0 //for real button
4143:../uvc.c      **** 				if(value&&(!snapButFlag)){
4144:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4145:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4146:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4147:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4148:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4149:../uvc.c      **** 
4150:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4151:../uvc.c      **** 					interStabuf.size   = 1024;
4152:../uvc.c      **** 					interStabuf.status = 0;
4153:../uvc.c      **** 
4154:../uvc.c      **** 					interStabuf.count = 4;
4155:../uvc.c      **** 
4156:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4157:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4158:../uvc.c      **** 
4159:../uvc.c      **** 					/** send a interrupt status data **/
4160:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4161:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4162:../uvc.c      **** 					{
4163:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4164:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4165:../uvc.c      **** 					}
4166:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
4167:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
4168:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4169:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4170:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4171:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4172:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4173:../uvc.c      **** 
4174:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4175:../uvc.c      **** 					interStabuf.size   = 1024;
4176:../uvc.c      **** 					interStabuf.status = 0;
4177:../uvc.c      **** 
4178:../uvc.c      **** 					interStabuf.count = 4;
4179:../uvc.c      **** 
4180:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4181:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4182:../uvc.c      **** 
4183:../uvc.c      **** 					/** send a interrupt status data **/
4184:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4185:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4186:../uvc.c      **** 					{
4187:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4188:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4189:../uvc.c      **** 					}
4190:../uvc.c      **** 
4191:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
4192:../uvc.c      **** 					stiflag = 0xFF;
4193:../uvc.c      **** 				}
4194:../uvc.c      **** #else			//for botton simulation
4195:../uvc.c      **** 				if(snapButFlag == 0x0f){
4196:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4197:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4198:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4199:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4200:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
4201:../uvc.c      **** 
4202:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4203:../uvc.c      **** 					interStabuf.size   = 1024;
4204:../uvc.c      **** 					interStabuf.status = 0;
4205:../uvc.c      **** 
4206:../uvc.c      **** 					interStabuf.count = 4;
4207:../uvc.c      **** 
4208:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4209:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4210:../uvc.c      **** 
4211:../uvc.c      **** 					/** send a interrupt status data **/
4212:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4213:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4214:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4215:../uvc.c      **** 					{
4216:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4217:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4218:../uvc.c      **** 					}
4219:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
4220:../uvc.c      **** 
4221:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
4222:../uvc.c      **** 				}else if(!snapButFlag){
4223:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
4224:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
4225:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
4226:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
4227:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
4228:../uvc.c      **** 
4229:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
4230:../uvc.c      **** 					interStabuf.size   = 1024;
4231:../uvc.c      **** 					interStabuf.status = 0;
4232:../uvc.c      **** 
4233:../uvc.c      **** 					interStabuf.count = 4;
4234:../uvc.c      **** 
4235:../uvc.c      **** 					/** wait unitll the responses has gone out **/
4236:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
4237:../uvc.c      **** 
4238:../uvc.c      **** 					/** send a interrupt status data **/
4239:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
4240:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
4241:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
4242:../uvc.c      **** 					{
4243:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
4244:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
4245:../uvc.c      **** 					}
4246:../uvc.c      **** 
4247:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
4248:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
4249:../uvc.c      **** 				}
4250:../uvc.c      **** #endif
4251:../uvc.c      **** 
4252:../uvc.c      ****             }
4253:../uvc.c      **** 
4254:../uvc.c      **** 
4255:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
4256:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
4257:../uvc.c      ****             {
4258:../uvc.c      ****                 /* Get the command buffer */
4259:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
4260:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4261:../uvc.c      ****                 {
4262:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
4263:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4264:../uvc.c      ****                 }
4265:../uvc.c      **** 
4266:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
4267:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
4268:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
4269:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
4270:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
4271:../uvc.c      ****                  * register value high byte and register value low byte.
4272:../uvc.c      ****                  */
4273:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
4274:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
4275:../uvc.c      ****                 {
4276:../uvc.c      ****                     if (dmaInfo.count == 3)
4277:../uvc.c      ****                     {
4278:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
4279:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
4280:../uvc.c      ****                         dmaInfo.count = 3;
4281:../uvc.c      ****                     }
4282:../uvc.c      ****                     else if (dmaInfo.count == 4)
4283:../uvc.c      ****                     {
4284:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
4285:../uvc.c      ****                         {
4286:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
4287:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
4288:../uvc.c      ****                         }
4289:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
4290:../uvc.c      ****                     }
4291:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
4292:../uvc.c      ****                 }
4293:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
4294:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
4295:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
4296:../uvc.c      ****                  */
4297:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
4298:../uvc.c      ****                 {
4299:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4300:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
4301:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
4302:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
4303:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
4304:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4305:../uvc.c      ****                         	break;
4306:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
4307:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
4308:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
4309:../uvc.c      ****                         	break;*/
4310:../uvc.c      ****                     dmaInfo.count -= 2;
4311:../uvc.c      ****                 }
4312:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
4313:../uvc.c      ****                 else
4314:../uvc.c      ****                 {
4315:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
4316:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
4317:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
4318:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
4319:../uvc.c      ****                 }
4320:../uvc.c      **** 
4321:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
4322:../uvc.c      ****                 dmaInfo.size   = 1024;
4323:../uvc.c      ****                 dmaInfo.status = 0;
4324:../uvc.c      **** 
4325:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
4326:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
4327:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4328:../uvc.c      ****                 {
4329:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
4330:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4331:../uvc.c      ****                 }
4332:../uvc.c      **** 
4333:../uvc.c      ****                 /* Wait until the response has gone out. */
4334:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
4335:../uvc.c      **** 
4336:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
4337:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
4338:../uvc.c      ****                 {
4339:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
4340:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
4341:../uvc.c      ****                 }
4342:../uvc.c      ****             }
4343:../uvc.c      **** #endif
4344:../uvc.c      ****         }
4345:../uvc.c      ****         /* Allow other ready threads to run. */
4346:../uvc.c      ****         CyU3PThreadRelinquish ();
4347:../uvc.c      ****     }
4348:../uvc.c      **** }
4349:../uvc.c      **** 
4350:../uvc.c      **** /*
4351:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
4352:../uvc.c      ****  * added 10/2013
4353:../uvc.c      ****  */
4354:../uvc.c      **** /*
4355:../uvc.c      **** static uint8_t timeDelay[64] = {
4356:../uvc.c      **** 
4357:../uvc.c      **** };
4358:../uvc.c      **** */
4359:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
 768              		.loc 1 4359 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 8
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL79:
 773 0734 F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 774              	.LCFI3:
 775              		.cfi_def_cfa_offset 28
 776              		.cfi_offset 4, -28
 777              		.cfi_offset 5, -24
 778              		.cfi_offset 6, -20
 779              		.cfi_offset 7, -16
 780              		.cfi_offset 8, -12
 781              		.cfi_offset 9, -8
 782              		.cfi_offset 14, -4
4360:../uvc.c      **** 
4361:../uvc.c      **** 	uint16_t count = 0, cmdCopyIdx = 0, count1 = 0, cmdQuIdx = 0; //
4362:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4363:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4364:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
4365:../uvc.c      **** 	VdcmdDes  *lcStaDes;
4366:../uvc.c      **** 	uint32_t flag = 0;
4367:../uvc.c      **** 	uint8_t  cmdFlag = 0;
4368:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
4369:../uvc.c      **** 	uint8_t i;
4370:../uvc.c      **** 	uint16_t delaytime;
4371:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
4372:../uvc.c      **** 
4373:../uvc.c      **** #if 0 //for test the command queue
4374:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
4375:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4376:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
4377:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4378:../uvc.c      **** 		lcCmdDes += 1;
4379:../uvc.c      **** 	}
4380:../uvc.c      **** 	lcCmdDes = statQuptr->startAdd;
4381:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
4382:../uvc.c      **** 		CyU3PDebugPrint (4, "State Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n",
4383:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
4384:../uvc.c      **** 		lcCmdDes += 1;
4385:../uvc.c      **** 	}
4386:../uvc.c      **** 
4387:../uvc.c      **** #endif
4388:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
4389:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
 783              		.loc 1 4389 0
 784 0738 34029FE5 		ldr	r0, .L161
 785              	.LVL80:
4359:../uvc.c      **** 
 786              		.loc 1 4359 0
 787 073c 1CD04DE2 		sub	sp, sp, #28
 788              	.LCFI4:
 789              		.cfi_def_cfa_offset 56
4366:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 790              		.loc 1 4366 0
 791 0740 00C0A0E3 		mov	ip, #0
 792              		.loc 1 4389 0
 793 0744 FA2FA0E3 		mov	r2, #1000
 794 0748 2C30A0E3 		mov	r3, #44
 795 074c 0C10A0E1 		mov	r1, ip
 796 0750 04C08DE5 		str	ip, [sp, #4]
 797 0754 08C08DE5 		str	ip, [sp, #8]
 798 0758 00208DE5 		str	r2, [sp]
 799 075c 0C308DE5 		str	r3, [sp, #12]
 800 0760 10229FE5 		ldr	r2, .L161+4
 801 0764 0B30A0E3 		mov	r3, #11
4366:../uvc.c      **** 	uint8_t  cmdFlag = 0;
 802              		.loc 1 4366 0
 803 0768 14C08DE5 		str	ip, [sp, #20]
 804              	.LVL81:
 805              		.loc 1 4389 0
 806 076c FEFFFFEB 		bl	_txe_timer_create
 807              	.LVL82:
4390:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 808              		.loc 1 4390 0
 809 0770 FEFFFFEB 		bl	_tx_time_get
 810              	.LVL83:
4391:../uvc.c      **** 	CyU3PThreadSleep(50);
4392:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
4393:../uvc.c      **** 
4394:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
 811              		.loc 1 4394 0
 812 0774 00529FE5 		ldr	r5, .L161+8
4390:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
 813              		.loc 1 4390 0
 814 0778 00129FE5 		ldr	r1, .L161+12
 815 077c 0020A0E1 		mov	r2, r0
 816 0780 0400A0E3 		mov	r0, #4
 817 0784 FEFFFFEB 		bl	CyU3PDebugPrint
 818              	.LVL84:
4391:../uvc.c      **** 	CyU3PThreadSleep(50);
 819              		.loc 1 4391 0
 820 0788 3200A0E3 		mov	r0, #50
 821 078c FEFFFFEB 		bl	_tx_thread_sleep
 822              	.LVL85:
4392:../uvc.c      **** 
 823              		.loc 1 4392 0
 824 0790 DC019FE5 		ldr	r0, .L161
 825 0794 FEFFFFEB 		bl	_txe_timer_activate
 826              	.LVL86:
 827              		.loc 1 4394 0
 828 0798 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 829 079c 000052E3 		cmp	r2, #0
 830 07a0 0300001A 		bne	.L136
 831              	.L137:
4395:../uvc.c      ****         /* Allow other ready threads to run. */
4396:../uvc.c      **** 
4397:../uvc.c      ****         CyU3PThreadRelinquish ();
 832              		.loc 1 4397 0
 833 07a4 FEFFFFEB 		bl	_txe_thread_relinquish
 834              	.LVL87:
4394:../uvc.c      ****         /* Allow other ready threads to run. */
 835              		.loc 1 4394 0
 836 07a8 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
 837 07ac 000052E3 		cmp	r2, #0
 838 07b0 FBFFFF0A 		beq	.L137
 839              	.L136:
4398:../uvc.c      **** 	}
4399:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
 840              		.loc 1 4399 0
 841 07b4 103095E5 		ldr	r3, [r5, #16]
 842 07b8 0400A0E3 		mov	r0, #4
 843 07bc 3C3093E5 		ldr	r3, [r3, #60]
 844 07c0 BC119FE5 		ldr	r1, .L161+16
 845 07c4 FEFFFFEB 		bl	CyU3PDebugPrint
 846              	.LVL88:
 847 07c8 B8619FE5 		ldr	r6, .L161+20
 848 07cc B8819FE5 		ldr	r8, .L161+24
4400:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
4401:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
4402:../uvc.c      **** 	//CyU3PThreadSleep(100);
4403:../uvc.c      **** 	//SetCurCmd();
4404:../uvc.c      **** 	/*********** the loop of the thread ***********/
4405:../uvc.c      **** 	for(;;){
4406:../uvc.c      **** 
4407:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 849              		.loc 1 4407 0
 850 07d0 0070E0E3 		mvn	r7, #0
 851              	.L154:
 852 07d4 14308DE2 		add	r3, sp, #20
 853 07d8 2010A0E3 		mov	r1, #32
 854 07dc 0320A0E3 		mov	r2, #3
 855 07e0 00708DE5 		str	r7, [sp]
 856 07e4 A4019FE5 		ldr	r0, .L161+28
 857 07e8 FEFFFFEB 		bl	_txe_event_flags_get
 858              	.LVL89:
4408:../uvc.c      **** /*  // for test GPIO output
4409:../uvc.c      **** 		if(trigger)
4410:../uvc.c      **** 		{
4411:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
4412:../uvc.c      **** 			{
4413:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
4414:../uvc.c      **** 			}
4415:../uvc.c      **** 
4416:../uvc.c      **** 		}else{
4417:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
4418:../uvc.c      **** 			{
4419:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
4420:../uvc.c      **** 			}
4421:../uvc.c      **** 
4422:../uvc.c      **** 		}
4423:../uvc.c      **** */
4424:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 859              		.loc 1 4424 0
 860 07ec 1C0096E5 		ldr	r0, [r6, #28]
 861 07f0 0010E0E3 		mvn	r1, #0
 862 07f4 FEFFFFEB 		bl	_txe_mutex_get
 863              	.LVL90:
4425:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4426:../uvc.c      **** 			/* find an available reading I2C command in the state queue */
4427:../uvc.c      **** 			lcStaDes = (VdcmdDes*)statQuptr->readPtr;
4428:../uvc.c      **** 			//if(0 && (lcStaDes->cmdFlag == CyTrue)){ /* for state queue it's not used right now. */
4429:../uvc.c      **** 				i = 0;
4430:../uvc.c      **** 				while((lcStaDes->cmdFlag == deswait) && (i < MAXCMD)){
 864              		.loc 1 4430 0
 865 07f8 103096E5 		ldr	r3, [r6, #16]
 866 07fc 3C3093E5 		ldr	r3, [r3, #60]
 867 0800 000053E3 		cmp	r3, #0
 868 0804 0300001A 		bne	.L138
 869 0808 4030A0E3 		mov	r3, #64
 870              	.LVL91:
 871              	.L139:
 872 080c 013043E2 		sub	r3, r3, #1
 873 0810 FF3013E2 		ands	r3, r3, #255
 874 0814 FCFFFF1A 		bne	.L139
 875              	.LVL92:
 876              	.L138:
4431:../uvc.c      **** 					i++;
4432:../uvc.c      **** 					lcCmdDes = lcStaDes->cmdDesNext;
4433:../uvc.c      **** 					statQuptr->readPtr = lcStaDes;
4434:../uvc.c      **** 				}
4435:../uvc.c      **** #if 0
4436:../uvc.c      **** 				if(lcStaDes->cmdFlag != deswait){
4437:../uvc.c      **** 				i = lcStaDes->curNum;
4438:../uvc.c      **** 				regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4439:../uvc.c      **** 				devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4440:../uvc.c      **** 				data = ((lcStaDes->CmdPar)+i)->Data;
4441:../uvc.c      **** 				//delaytime = ((lcStaDes->CmdPar)+i)->DelayT;
4442:../uvc.c      **** 
4443:../uvc.c      **** 				//for(i = 0; i < lcStaDes->NumPara; i++){
4444:../uvc.c      **** 					//regAdd = ((lcStaDes->CmdPar)+i)->RegAdd;
4445:../uvc.c      **** 					//devAdd = ((lcStaDes->CmdPar)+i)->DevAdd;
4446:../uvc.c      **** 					((lcStaDes->CmdPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
4447:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4448:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
4449:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
4450:../uvc.c      **** #endif
4451:../uvc.c      **** 				//}
4452:../uvc.c      **** 				lcStaDes->cmdFlag = CyFalse;
4453:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->cmdDesNext; //update command queue read pointer
4454:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
4455:../uvc.c      **** 				/* setting delay */
4456:../uvc.c      **** 				delaytime = 300;
4457:../uvc.c      **** 				CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
4458:../uvc.c      **** 				CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
4459:../uvc.c      **** 			} //end of the if condition statment
4460:../uvc.c      **** #endif
4461:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 877              		.loc 1 4461 0
 878 0818 1C0096E5 		ldr	r0, [r6, #28]
 879 081c FEFFFFEB 		bl	_txe_mutex_put
 880              	.LVL93:
4462:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
4463:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 881              		.loc 1 4463 0
 882 0820 1C0095E5 		ldr	r0, [r5, #28]
 883 0824 0010E0E3 		mvn	r1, #0
 884 0828 FEFFFFEB 		bl	_txe_mutex_get
 885              	.LVL94:
4464:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 886              		.loc 1 4464 0
 887 082c 104095E5 		ldr	r4, [r5, #16]
 888              	.LVL95:
4465:../uvc.c      **** 
4466:../uvc.c      **** 				/*
4467:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4468:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4469:../uvc.c      **** 				*/
4470:../uvc.c      **** 
4471:../uvc.c      **** 				/* find a available command */
4472:../uvc.c      **** 				i = 0;
4473:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 889              		.loc 1 4473 0
 890 0830 3C3094E5 		ldr	r3, [r4, #60]
 891 0834 000053E3 		cmp	r3, #0
 892 0838 0900001A 		bne	.L140
 893 083c 4020A0E3 		mov	r2, #64
 894 0840 010000EA 		b	.L143
 895              	.LVL96:
 896              	.L141:
 897              		.loc 1 4473 0 is_stmt 0 discriminator 2
 898 0844 FF2012E2 		ands	r2, r2, #255
 899 0848 3100000A 		beq	.L159
 900              	.L143:
4474:../uvc.c      **** 					i++;
4475:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 901              		.loc 1 4475 0 is_stmt 1
 902 084c 344094E5 		ldr	r4, [r4, #52]
 903              	.LVL97:
 904 0850 012042E2 		sub	r2, r2, #1
4473:../uvc.c      **** 					i++;
 905              		.loc 1 4473 0
 906 0854 3C3094E5 		ldr	r3, [r4, #60]
 907 0858 000053E3 		cmp	r3, #0
 908 085c F8FFFF0A 		beq	.L141
 909 0860 104085E5 		str	r4, [r5, #16]
 910              	.L140:
 911              	.LVL98:
 912 0864 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
4476:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
4477:../uvc.c      **** 				}
4478:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
4479:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){//remove sensor set for WB camera
4480:../uvc.c      **** 					i = lcCmdDes->curNum;
4481:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
4482:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
4483:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
4484:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
4485:../uvc.c      **** #if 1
4486:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 913              		.loc 1 4486 0
 914 0868 00C0D4E5 		ldrb	ip, [r4]	@ zero_extendqisi2
 915 086c 833083E0 		add	r3, r3, r3, asl #1
 916 0870 833084E0 		add	r3, r4, r3, asl #1
 917 0874 20C04CE2 		sub	ip, ip, #32
4481:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 918              		.loc 1 4481 0
 919 0878 0400D3E5 		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 920              	.LVL99:
4482:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 921              		.loc 1 4482 0
 922 087c 0510D3E5 		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 923              	.LVL100:
4483:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 924              		.loc 1 4483 0
 925 0880 0620D3E5 		ldrb	r2, [r3, #6]	@ zero_extendqisi2
 926              	.LVL101:
4484:../uvc.c      **** #if 1
 927              		.loc 1 4484 0
 928 0884 B890D3E1 		ldrh	r9, [r3, #8]
 929              	.LVL102:
 930              		.loc 1 4486 0
 931 0888 03005CE3 		cmp	ip, #3
 932 088c 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 933 0890 340000EA 		b	.L149
 934              	.L155:
 935 0894 04090000 		.word	.L144
 936 0898 F4080000 		.word	.L146
 937 089c A4080000 		.word	.L148
 938 08a0 A4080000 		.word	.L148
 939              	.L148:
4487:../uvc.c      **** 						case 0x20:
4488:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
4489:../uvc.c      **** 							delaytime = 500;
4490:../uvc.c      **** 							break;
4491:../uvc.c      **** 						case 0x21:
4492:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
4493:../uvc.c      **** 							delaytime = 500;
4494:../uvc.c      **** 							break;
4495:../uvc.c      **** 						case 0x22:
4496:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
4497:../uvc.c      **** 							delaytime = 300;
4498:../uvc.c      **** 							break;
4499:../uvc.c      **** 						case 0x23:
4500:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 940              		.loc 1 4500 0
 941 08a4 8230A0E3 		mov	r3, #130
 942              	.LVL103:
 943 08a8 FEFFFFEB 		bl	SensorSetIrisControl
 944              	.LVL104:
4501:../uvc.c      **** 							delaytime = 300;
4502:../uvc.c      **** 							break;
 945              		.loc 1 4502 0
 946 08ac 4B1FA0E3 		mov	r1, #300
 947              	.LVL105:
 948              	.L145:
4503:../uvc.c      **** 						default:
4504:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
4505:../uvc.c      **** 							break;
4506:../uvc.c      **** 					}
4507:../uvc.c      **** #endif
4508:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
4509:../uvc.c      **** 					/** timer's ticket modify **/
4510:../uvc.c      **** 					//delaytime =100; //temp add -6/17/2015
4511:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 949              		.loc 1 4511 0
 950 08b0 0020A0E3 		mov	r2, #0
 951 08b4 B8009FE5 		ldr	r0, .L161
 952 08b8 FEFFFFEB 		bl	_txe_timer_change
 953              	.LVL106:
4512:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 954              		.loc 1 4512 0
 955 08bc B0009FE5 		ldr	r0, .L161
 956 08c0 FEFFFFEB 		bl	_txe_timer_activate
 957              	.LVL107:
4513:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
4514:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
4515:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4516:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
4517:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
4518:../uvc.c      **** #endif
4519:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 958              		.loc 1 4519 0
 959 08c4 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 960 08c8 0220D4E5 		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 961 08cc 030052E1 		cmp	r2, r3
 962 08d0 1600000A 		beq	.L160
4520:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
4521:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
4522:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
4523:../uvc.c      **** 						}else{
4524:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
4525:../uvc.c      **** 						}
4526:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
4527:../uvc.c      **** 					}else{
4528:../uvc.c      **** 						lcCmdDes->curNum ++;
 963              		.loc 1 4528 0
 964 08d4 013083E2 		add	r3, r3, #1
4529:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 965              		.loc 1 4529 0
 966 08d8 0F20A0E3 		mov	r2, #15
4528:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 967              		.loc 1 4528 0
 968 08dc 0130C4E5 		strb	r3, [r4, #1]
 969              		.loc 1 4529 0
 970 08e0 3C2084E5 		str	r2, [r4, #60]
 971              	.LVL108:
 972              	.L153:
4530:../uvc.c      **** 					}
4531:../uvc.c      **** 				}else{
4532:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
4533:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
4534:../uvc.c      **** 				}
4535:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 973              		.loc 1 4535 0
 974 08e4 1C0095E5 		ldr	r0, [r5, #28]
 975 08e8 FEFFFFEB 		bl	_txe_mutex_put
 976              	.LVL109:
4536:../uvc.c      **** 			}
4537:../uvc.c      **** /*
4538:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
4539:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
4540:../uvc.c      **** */
4541:../uvc.c      **** #ifdef USB_DEBUG_PRINT
4542:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
4543:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
4544:../uvc.c      **** #endif
4545:../uvc.c      **** 
4546:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
4547:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
4548:../uvc.c      **** #if 0
4549:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
4550:../uvc.c      **** 
4551:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
4552:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
4553:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
4554:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
4555:../uvc.c      **** 			    i = 0;
4556:../uvc.c      **** 				 switch(cmdCopyIdx)
4557:../uvc.c      **** 				 {
4558:../uvc.c      **** 					 case BrgtCtlID1:
4559:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
4560:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4561:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
4562:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4563:../uvc.c      **** 							 i++;
4564:../uvc.c      **** 						 }
4565:../uvc.c      **** 						 else{
4566:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4567:../uvc.c      **** 						 }
4568:../uvc.c      **** 
4569:../uvc.c      **** 						 CyU3PBusyWait(500);
4570:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
4571:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4572:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4573:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4574:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4575:../uvc.c      **** 						 }
4576:../uvc.c      **** 						 else{
4577:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4578:../uvc.c      **** 						 }
4579:../uvc.c      **** 						 break;
4580:../uvc.c      **** 					 case HueCtlID5:
4581:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
4582:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4583:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4584:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4585:../uvc.c      **** 						 }
4586:../uvc.c      **** 						 else{
4587:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4588:../uvc.c      **** 						 }
4589:../uvc.c      **** 						 break;
4590:../uvc.c      **** 					 case SaturCtlID6:
4591:../uvc.c      **** 					 case WBTLevCtlID10:
4592:../uvc.c      **** 					 default:
4593:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
4594:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
4595:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
4596:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
4597:../uvc.c      **** 						 }
4598:../uvc.c      **** 						 else{
4599:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
4600:../uvc.c      **** 						 }
4601:../uvc.c      **** 						 break;
4602:../uvc.c      **** 				 }
4603:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
4604:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
4605:../uvc.c      **** 			}
4606:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
4607:../uvc.c      **** #endif
4608:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
4609:../uvc.c      **** 		/* Allow other ready threads to run. */
4610:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
4611:../uvc.c      **** 			CyU3PThreadRelinquish ();
 977              		.loc 1 4611 0
 978 08ec FEFFFFEB 		bl	_txe_thread_relinquish
 979              	.LVL110:
4612:../uvc.c      **** 		}
 980              		.loc 1 4612 0
 981 08f0 B7FFFFEA 		b	.L154
 982              	.LVL111:
 983              	.L146:
4492:../uvc.c      **** 							delaytime = 500;
 984              		.loc 1 4492 0
 985 08f4 5230A0E3 		mov	r3, #82
 986              	.LVL112:
 987 08f8 FEFFFFEB 		bl	SensorSetIrisControl
 988              	.LVL113:
4494:../uvc.c      **** 						case 0x22:
 989              		.loc 1 4494 0
 990 08fc 7D1FA0E3 		mov	r1, #500
 991 0900 EAFFFFEA 		b	.L145
 992              	.LVL114:
 993              	.L144:
4488:../uvc.c      **** 							delaytime = 500;
 994              		.loc 1 4488 0
 995 0904 8230A0E3 		mov	r3, #130
 996              	.LVL115:
 997 0908 FEFFFFEB 		bl	SensorSetIrisControl
 998              	.LVL116:
4490:../uvc.c      **** 						case 0x21:
 999              		.loc 1 4490 0
 1000 090c 7D1FA0E3 		mov	r1, #500
 1001 0910 E6FFFFEA 		b	.L145
 1002              	.LVL117:
 1003              	.L159:
4532:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 1004              		.loc 1 4532 0
 1005 0914 FA1FA0E3 		mov	r1, #1000
 1006 0918 54009FE5 		ldr	r0, .L161
 1007 091c 104085E5 		str	r4, [r5, #16]
 1008 0920 FEFFFFEB 		bl	_txe_timer_change
 1009              	.LVL118:
4533:../uvc.c      **** 				}
 1010              		.loc 1 4533 0
 1011 0924 48009FE5 		ldr	r0, .L161
 1012 0928 FEFFFFEB 		bl	_txe_timer_activate
 1013              	.LVL119:
 1014 092c ECFFFFEA 		b	.L153
 1015              	.LVL120:
 1016              	.L160:
4521:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1017              		.loc 1 4521 0
 1018 0930 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
4520:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1019              		.loc 1 4520 0
 1020 0934 0020A0E3 		mov	r2, #0
4521:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 1021              		.loc 1 4521 0
 1022 0938 230053E3 		cmp	r3, #35
4522:../uvc.c      **** 						}else{
 1023              		.loc 1 4522 0
 1024 093c 24304382 		subhi	r3, r3, #36
 1025 0940 83308380 		addhi	r3, r3, r3, asl #1
4524:../uvc.c      **** 						}
 1026              		.loc 1 4524 0
 1027 0944 83308390 		addls	r3, r3, r3, asl #1
4522:../uvc.c      **** 						}else{
 1028              		.loc 1 4522 0
 1029 0948 83318880 		addhi	r3, r8, r3, asl #3
4524:../uvc.c      **** 						}
 1030              		.loc 1 4524 0
 1031 094c 83318890 		addls	r3, r8, r3, asl #3
4522:../uvc.c      **** 						}else{
 1032              		.loc 1 4522 0
 1033 0950 7C20C385 		strhib	r2, [r3, #124]
4524:../uvc.c      **** 						}
 1034              		.loc 1 4524 0
 1035 0954 FC21C395 		strlsb	r2, [r3, #508]
4526:../uvc.c      **** 					}else{
 1036              		.loc 1 4526 0
 1037 0958 343094E5 		ldr	r3, [r4, #52]
4520:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 1038              		.loc 1 4520 0
 1039 095c 3C2084E5 		str	r2, [r4, #60]
4526:../uvc.c      **** 					}else{
 1040              		.loc 1 4526 0
 1041 0960 103085E5 		str	r3, [r5, #16]
 1042 0964 DEFFFFEA 		b	.L153
 1043              	.LVL121:
 1044              	.L149:
4504:../uvc.c      **** 							break;
 1045              		.loc 1 4504 0
 1046 0968 FEFFFFEB 		bl	SensorSetControl
 1047              	.LVL122:
 1048 096c 0910A0E1 		mov	r1, r9
4505:../uvc.c      **** 					}
 1049              		.loc 1 4505 0
 1050 0970 CEFFFFEA 		b	.L145
 1051              	.L162:
 1052              		.align	2
 1053              	.L161:
 1054 0974 00000000 		.word	I2CCmdTimer
 1055 0978 00000000 		.word	I2CCmdCb
 1056 097c 00000000 		.word	cmdQu
 1057 0980 A4010000 		.word	.LC11
 1058 0984 B8010000 		.word	.LC12
 1059 0988 00000000 		.word	statQu
 1060 098c 00000000 		.word	.LANCHOR1
 1061 0990 00000000 		.word	.LANCHOR0
 1062              		.cfi_endproc
 1063              	.LFE26:
 1065              		.align	2
 1066              		.global	CyFxUvcApplnDmaCallback
 1068              	CyFxUvcApplnDmaCallback:
 1069              	.LFB11:
2231:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1070              		.loc 1 2231 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              	.LVL123:
2238:../uvc.c      ****     {
 1075              		.loc 1 2238 0
 1076 0994 080051E3 		cmp	r1, #8
2231:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
 1077              		.loc 1 2231 0
 1078 0998 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1079              	.LCFI5:
 1080              		.cfi_def_cfa_offset 16
 1081              		.cfi_offset 4, -16
 1082              		.cfi_offset 5, -12
 1083              		.cfi_offset 6, -8
 1084              		.cfi_offset 14, -4
 1085 099c 0250A0E1 		mov	r5, r2
 1086 09a0 08D04DE2 		sub	sp, sp, #8
 1087              	.LCFI6:
 1088              		.cfi_def_cfa_offset 24
2238:../uvc.c      ****     {
 1089              		.loc 1 2238 0
 1090 09a4 0B00000A 		beq	.L174
2290:../uvc.c      ****     {
 1091              		.loc 1 2290 0
 1092 09a8 100051E3 		cmp	r1, #16
 1093 09ac 0700001A 		bne	.L163
2292:../uvc.c      ****         streamingStarted = CyTrue;
 1094              		.loc 1 2292 0
 1095 09b0 6C319FE5 		ldr	r3, .L177
2293:../uvc.c      ****     }
 1096              		.loc 1 2293 0
 1097 09b4 0110A0E3 		mov	r1, #1
 1098              	.LVL124:
2292:../uvc.c      ****         streamingStarted = CyTrue;
 1099              		.loc 1 2292 0
 1100 09b8 B228D3E1 		ldrh	r2, [r3, #130]
 1101              	.LVL125:
2293:../uvc.c      ****     }
 1102              		.loc 1 2293 0
 1103 09bc 841083E5 		str	r1, [r3, #132]
2292:../uvc.c      ****         streamingStarted = CyTrue;
 1104              		.loc 1 2292 0
 1105 09c0 012082E0 		add	r2, r2, r1
 1106 09c4 0228A0E1 		mov	r2, r2, asl #16
 1107 09c8 2228A0E1 		mov	r2, r2, lsr #16
 1108 09cc B228C3E1 		strh	r2, [r3, #130]	@ movhi
 1109              	.LVL126:
 1110              	.L163:
2295:../uvc.c      **** 
 1111              		.loc 1 2295 0
 1112 09d0 08D08DE2 		add	sp, sp, #8
 1113              		@ sp needed
 1114 09d4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1115              	.LVL127:
 1116              	.L174:
2240:../uvc.c      ****             {
 1117              		.loc 1 2240 0
 1118 09d8 48319FE5 		ldr	r3, .L177+4
 1119 09dc B420D2E1 		ldrh	r2, [r2, #4]
 1120              	.LVL128:
2254:../uvc.c      ****                 fb++;
 1121              		.loc 1 2254 0
 1122 09e0 006095E5 		ldr	r6, [r5]
2240:../uvc.c      ****             {
 1123              		.loc 1 2240 0
 1124 09e4 030052E1 		cmp	r2, r3
 1125              	.LBB6:
 1126              	.LBB7:
1978:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1127              		.loc 1 1978 0
 1128 09e8 3C019FE5 		ldr	r0, .L177+8
 1129              	.LVL129:
 1130              	.LBE7:
 1131              	.LBE6:
2240:../uvc.c      ****             {
 1132              		.loc 1 2240 0
 1133 09ec 3100000A 		beq	.L175
 1134              	.LBB11:
 1135              	.LBB12:
1978:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1136              		.loc 1 1978 0
 1137 09f0 0010E0E3 		mvn	r1, #0
 1138              	.LVL130:
 1139 09f4 FEFFFFEB 		bl	_txe_mutex_get
 1140              	.LVL131:
1979:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1141              		.loc 1 1979 0
 1142 09f8 0C0046E2 		sub	r0, r6, #12
 1143 09fc 2C119FE5 		ldr	r1, .L177+12
 1144 0a00 0C20A0E3 		mov	r2, #12
 1145 0a04 FEFFFFEB 		bl	CyU3PMemCopy
 1146              	.LVL132:
1980:../uvc.c      **** 
 1147              		.loc 1 1980 0
 1148 0a08 1C019FE5 		ldr	r0, .L177+8
 1149 0a0c FEFFFFEB 		bl	_txe_mutex_put
 1150              	.LVL133:
1985:../uvc.c      ****     }
 1151              		.loc 1 1985 0
 1152 0a10 0B3056E5 		ldrb	r3, [r6, #-11]	@ zero_extendqisi2
 1153              	.LBE12:
 1154              	.LBE11:
2261:../uvc.c      ****                 pbc = input->buffer_p.count;
 1155              		.loc 1 2261 0
 1156 0a14 08419FE5 		ldr	r4, .L177
 1157              	.LBB15:
 1158              	.LBB13:
1985:../uvc.c      ****     }
 1159              		.loc 1 1985 0
 1160 0a18 023083E3 		orr	r3, r3, #2
 1161 0a1c 0B3046E5 		strb	r3, [r6, #-11]
 1162              	.LBE13:
 1163              	.LBE15:
2267:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1164              		.loc 1 2267 0
 1165 0a20 7210D4E5 		ldrb	r1, [r4, #114]	@ zero_extendqisi2
2261:../uvc.c      ****                 pbc = input->buffer_p.count;
 1166              		.loc 1 2261 0
 1167 0a24 B627D4E1 		ldrh	r2, [r4, #118]
2262:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1168              		.loc 1 2262 0
 1169 0a28 B430D5E1 		ldrh	r3, [r5, #4]
2261:../uvc.c      ****                 pbc = input->buffer_p.count;
 1170              		.loc 1 2261 0
 1171 0a2c 012082E2 		add	r2, r2, #1
2267:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1172              		.loc 1 2267 0
 1173 0a30 0F0051E3 		cmp	r1, #15
2261:../uvc.c      ****                 pbc = input->buffer_p.count;
 1174              		.loc 1 2261 0
 1175 0a34 B627C4E1 		strh	r2, [r4, #118]	@ movhi
2262:../uvc.c      ****                 //CyU3PDebugPrint (4, "((partition)buffer: Code = %d, size = %x, dmaRx %d, dmaTx %d
 1176              		.loc 1 2262 0
 1177 0a38 B837C4E1 		strh	r3, [r4, #120]	@ movhi
 1178              	.LBB16:
 1179              	.LBB14:
1979:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1180              		.loc 1 1979 0
 1181 0a3c F0609FE5 		ldr	r6, .L177+16
 1182              	.LBE14:
 1183              	.LBE16:
2267:../uvc.c      ****                 	CyU3PMutexGet(&imgHdMux, CYU3P_WAIT_FOREVER);
 1184              		.loc 1 2267 0
 1185 0a40 2B00000A 		beq	.L176
 1186              	.L167:
2274:../uvc.c      ****             }
 1187              		.loc 1 2274 0
 1188 0a44 0120A0E3 		mov	r2, #1
 1189 0a48 7C2084E5 		str	r2, [r4, #124]
 1190              	.L166:
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1191              		.loc 1 2278 0
 1192 0a4c B028D4E1 		ldrh	r2, [r4, #128]
2279:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1193              		.loc 1 2279 0
 1194 0a50 0C1083E2 		add	r1, r3, #12
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1195              		.loc 1 2278 0
 1196 0a54 013082E2 		add	r3, r2, #1
2279:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1197              		.loc 1 2279 0
 1198 0a58 0118A0E1 		mov	r1, r1, asl #16
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1199              		.loc 1 2278 0
 1200 0a5c 0338A0E1 		mov	r3, r3, asl #16
2279:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1201              		.loc 1 2279 0
 1202 0a60 2118A0E1 		mov	r1, r1, lsr #16
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1203              		.loc 1 2278 0
 1204 0a64 2338A0E1 		mov	r3, r3, lsr #16
2279:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1205              		.loc 1 2279 0
 1206 0a68 0020A0E3 		mov	r2, #0
 1207 0a6c C4009FE5 		ldr	r0, .L177+20
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1208              		.loc 1 2278 0
 1209 0a70 B038C4E1 		strh	r3, [r4, #128]	@ movhi
2279:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
 1210              		.loc 1 2279 0
 1211 0a74 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 1212              	.LVL134:
2278:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 1213              		.loc 1 2278 0
 1214 0a78 A4109FE5 		ldr	r1, .L177
2282:../uvc.c      ****             {
 1215              		.loc 1 2282 0
 1216 0a7c 002050E2 		subs	r2, r0, #0
 1217 0a80 D2FFFF0A 		beq	.L163
2284:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1218              		.loc 1 2284 0
 1219 0a84 B008D1E1 		ldrh	r0, [r1, #128]
 1220              	.LVL135:
2285:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1221              		.loc 1 2285 0
 1222 0a88 B430D5E1 		ldrh	r3, [r5, #4]
2284:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer(1): Code = %d, size = %x, dm
 1223              		.loc 1 2284 0
 1224 0a8c 010040E2 		sub	r0, r0, #1
 1225 0a90 0008A0E1 		mov	r0, r0, asl #16
 1226 0a94 2008A0E1 		mov	r0, r0, lsr #16
 1227 0a98 B008C1E1 		strh	r0, [r1, #128]	@ movhi
2285:../uvc.c      ****                         status, input->buffer_p.count, prodCount, consCount);
 1228              		.loc 1 2285 0
 1229 0a9c B008D1E1 		ldrh	r0, [r1, #128]
 1230 0aa0 B218D1E1 		ldrh	r1, [r1, #130]
 1231 0aa4 03008DE8 		stmia	sp, {r0, r1}
 1232 0aa8 8C109FE5 		ldr	r1, .L177+24
 1233 0aac 0400A0E3 		mov	r0, #4
 1234 0ab0 FEFFFFEB 		bl	CyU3PDebugPrint
 1235              	.LVL136:
 1236 0ab4 C5FFFFEA 		b	.L163
 1237              	.LVL137:
 1238              	.L175:
 1239              	.LBB17:
 1240              	.LBB8:
1978:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1241              		.loc 1 1978 0
 1242 0ab8 0010E0E3 		mvn	r1, #0
 1243              	.LVL138:
 1244              	.LBE8:
 1245              	.LBE17:
2255:../uvc.c      ****             }
 1246              		.loc 1 2255 0
 1247 0abc 60409FE5 		ldr	r4, .L177
 1248              	.LBB18:
 1249              	.LBB9:
1978:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 1250              		.loc 1 1978 0
 1251 0ac0 FEFFFFEB 		bl	_txe_mutex_get
 1252              	.LVL139:
 1253              	.LBE9:
 1254              	.LBE18:
2254:../uvc.c      ****                 fb++;
 1255              		.loc 1 2254 0
 1256 0ac4 0C6046E2 		sub	r6, r6, #12
 1257              	.LVL140:
 1258              	.LBB19:
 1259              	.LBB10:
1979:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 1260              		.loc 1 1979 0
 1261 0ac8 0C20A0E3 		mov	r2, #12
 1262 0acc 0600A0E1 		mov	r0, r6
 1263 0ad0 58109FE5 		ldr	r1, .L177+12
 1264 0ad4 FEFFFFEB 		bl	CyU3PMemCopy
 1265              	.LVL141:
1980:../uvc.c      **** 
 1266              		.loc 1 1980 0
 1267 0ad8 4C009FE5 		ldr	r0, .L177+8
 1268 0adc FEFFFFEB 		bl	_txe_mutex_put
 1269              	.LVL142:
 1270              	.LBE10:
 1271              	.LBE19:
2255:../uvc.c      ****             }
 1272              		.loc 1 2255 0
 1273 0ae0 B427D4E1 		ldrh	r2, [r4, #116]
 1274 0ae4 B430D5E1 		ldrh	r3, [r5, #4]
 1275 0ae8 012082E2 		add	r2, r2, #1
 1276 0aec B427C4E1 		strh	r2, [r4, #116]	@ movhi
 1277 0af0 D5FFFFEA 		b	.L166
 1278              	.LVL143:
 1279              	.L176:
2268:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 1280              		.loc 1 2268 0
 1281 0af4 0010E0E3 		mvn	r1, #0
 1282 0af8 2C009FE5 		ldr	r0, .L177+8
 1283 0afc FEFFFFEB 		bl	_txe_mutex_get
 1284              	.LVL144:
2269:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1285              		.loc 1 2269 0
 1286 0b00 ED34D6E5 		ldrb	r3, [r6, #1261]	@ zero_extendqisi2
2270:../uvc.c      ****                 	stiflag = 0xAA;
 1287              		.loc 1 2270 0
 1288 0b04 20009FE5 		ldr	r0, .L177+8
2269:../uvc.c      ****                 	CyU3PMutexPut(&imgHdMux);
 1289              		.loc 1 2269 0
 1290 0b08 DF3003E2 		and	r3, r3, #223
 1291 0b0c ED34C6E5 		strb	r3, [r6, #1261]
2270:../uvc.c      ****                 	stiflag = 0xAA;
 1292              		.loc 1 2270 0
 1293 0b10 FEFFFFEB 		bl	_txe_mutex_put
 1294              	.LVL145:
2271:../uvc.c      ****                 }
 1295              		.loc 1 2271 0
 1296 0b14 5530E0E3 		mvn	r3, #85
 1297 0b18 7230C4E5 		strb	r3, [r4, #114]
 1298 0b1c B430D5E1 		ldrh	r3, [r5, #4]
 1299 0b20 C7FFFFEA 		b	.L167
 1300              	.L178:
 1301              		.align	2
 1302              	.L177:
 1303 0b24 00000000 		.word	.LANCHOR0
 1304 0b28 F03F0000 		.word	16368
 1305 0b2c 00000000 		.word	imgHdMux
 1306 0b30 EC040000 		.word	.LANCHOR1+1260
 1307 0b34 00000000 		.word	.LANCHOR1
 1308 0b38 00000000 		.word	glChHandleUVCStream
 1309 0b3c DC010000 		.word	.LC13
 1310              		.cfi_endproc
 1311              	.LFE11:
 1313              		.align	2
 1315              	CyFxUVCApplnUSBEventCB:
 1316              	.LFB9:
2034:../uvc.c      ****     switch (evtype)
 1317              		.loc 1 2034 0
 1318              		.cfi_startproc
 1319              		@ args = 0, pretend = 0, frame = 8
 1320              		@ frame_needed = 0, uses_anonymous_args = 0
 1321              	.LVL146:
2035:../uvc.c      ****     {
 1322              		.loc 1 2035 0
 1323 0b40 020050E3 		cmp	r0, #2
2034:../uvc.c      ****     switch (evtype)
 1324              		.loc 1 2034 0
 1325 0b44 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1326              	.LCFI7:
 1327              		.cfi_def_cfa_offset 16
 1328              		.cfi_offset 4, -16
 1329              		.cfi_offset 5, -12
 1330              		.cfi_offset 6, -8
 1331              		.cfi_offset 14, -4
 1332 0b48 0040A0E1 		mov	r4, r0
 1333 0b4c 10D04DE2 		sub	sp, sp, #16
 1334              	.LCFI8:
 1335              		.cfi_def_cfa_offset 32
2035:../uvc.c      ****     {
 1336              		.loc 1 2035 0
 1337 0b50 3D00000A 		beq	.L181
 1338 0b54 040050E3 		cmp	r0, #4
 1339 0b58 2000000A 		beq	.L182
 1340 0b5c 010050E3 		cmp	r0, #1
 1341 0b60 0100000A 		beq	.L187
 1342              	.LVL147:
 1343              	.L179:
2071:../uvc.c      **** 
 1344              		.loc 1 2071 0
 1345 0b64 10D08DE2 		add	sp, sp, #16
 1346              		@ sp needed
 1347 0b68 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1348              	.LVL148:
 1349              	.L187:
 1350              	.LBB34:
 1351              	.LBB35:
2054:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1352              		.loc 1 2054 0
 1353 0b6c 0130A0E1 		mov	r3, r1
 1354 0b70 0420A0E1 		mov	r2, r4
2056:../uvc.c      ****             isUsbConnected = CyFalse;
 1355              		.loc 1 2056 0
 1356 0b74 40519FE5 		ldr	r5, .L188
2054:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1357              		.loc 1 2054 0
 1358 0b78 40119FE5 		ldr	r1, .L188+4
 1359              	.LVL149:
 1360 0b7c 0400A0E3 		mov	r0, #4
 1361              	.LVL150:
 1362 0b80 FEFFFFEB 		bl	CyU3PDebugPrint
 1363              	.LVL151:
2055:../uvc.c      ****             gpif_initialized = 0;
 1364              		.loc 1 2055 0
 1365 0b84 0400A0E1 		mov	r0, r4
 1366 0b88 FEFFFFEB 		bl	CyU3PGpifDisable
 1367              	.LVL152:
2056:../uvc.c      ****             isUsbConnected = CyFalse;
 1368              		.loc 1 2056 0
 1369 0b8c 00C0A0E3 		mov	ip, #0
 1370              	.LBB36:
 1371              	.LBB37:
2018:../uvc.c      **** 	{
 1372              		.loc 1 2018 0
 1373 0b90 00C08DE5 		str	ip, [sp]
 1374 0b94 0410A0E1 		mov	r1, r4
 1375 0b98 0500A0E1 		mov	r0, r5
 1376 0b9c 0220A0E3 		mov	r2, #2
 1377 0ba0 0C308DE2 		add	r3, sp, #12
 1378              	.LBE37:
 1379              	.LBE36:
2056:../uvc.c      ****             isUsbConnected = CyFalse;
 1380              		.loc 1 2056 0
 1381 0ba4 88C085E5 		str	ip, [r5, #136]
2057:../uvc.c      ****             streamingStarted = CyFalse;
 1382              		.loc 1 2057 0
 1383 0ba8 8CC085E5 		str	ip, [r5, #140]
2058:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1384              		.loc 1 2058 0
 1385 0bac 84C085E5 		str	ip, [r5, #132]
 1386              	.LBB41:
 1387              	.LBB40:
2018:../uvc.c      **** 	{
 1388              		.loc 1 2018 0
 1389 0bb0 FEFFFFEB 		bl	_txe_event_flags_get
 1390              	.LVL153:
 1391 0bb4 004050E2 		subs	r4, r0, #0
 1392 0bb8 E9FFFF1A 		bne	.L179
 1393              	.LBB38:
 1394              	.LBB39:
2021:../uvc.c      **** 
 1395              		.loc 1 2021 0
 1396 0bbc 0500A0E1 		mov	r0, r5
 1397 0bc0 0110E0E3 		mvn	r1, #1
 1398 0bc4 0220A0E3 		mov	r2, #2
 1399 0bc8 FEFFFFEB 		bl	_txe_event_flags_set
 1400              	.LVL154:
2024:../uvc.c      **** 	}
 1401              		.loc 1 2024 0
 1402 0bcc 0500A0E1 		mov	r0, r5
 1403 0bd0 0420A0E1 		mov	r2, r4
 1404 0bd4 0210A0E3 		mov	r1, #2
 1405 0bd8 FEFFFFEB 		bl	_txe_event_flags_set
 1406              	.LVL155:
 1407 0bdc E0FFFFEA 		b	.L179
 1408              	.LVL156:
 1409              	.L182:
 1410              	.LBE39:
 1411              	.LBE38:
 1412              	.LBE40:
 1413              	.LBE41:
 1414              	.LBE35:
 1415              	.LBE34:
2038:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1416              		.loc 1 2038 0
 1417 0be0 0130A0E1 		mov	r3, r1
 1418 0be4 0020A0E1 		mov	r2, r0
 1419 0be8 D4109FE5 		ldr	r1, .L188+8
 1420              	.LVL157:
 1421 0bec FEFFFFEB 		bl	CyU3PDebugPrint
 1422              	.LVL158:
2040:../uvc.c      ****             streamingStarted = CyFalse;
 1423              		.loc 1 2040 0
 1424 0bf0 C4409FE5 		ldr	r4, .L188
2039:../uvc.c      ****             gpif_initialized = 0;
 1425              		.loc 1 2039 0
 1426 0bf4 0100A0E3 		mov	r0, #1
 1427 0bf8 FEFFFFEB 		bl	CyU3PGpifDisable
 1428              	.LVL159:
2040:../uvc.c      ****             streamingStarted = CyFalse;
 1429              		.loc 1 2040 0
 1430 0bfc 00C0A0E3 		mov	ip, #0
 1431              	.LBB42:
 1432              	.LBB43:
2018:../uvc.c      **** 	{
 1433              		.loc 1 2018 0
 1434 0c00 00C08DE5 		str	ip, [sp]
 1435 0c04 0400A0E1 		mov	r0, r4
 1436 0c08 0110A0E3 		mov	r1, #1
 1437 0c0c 0220A0E3 		mov	r2, #2
 1438 0c10 0C308DE2 		add	r3, sp, #12
 1439              	.LBE43:
 1440              	.LBE42:
2040:../uvc.c      ****             streamingStarted = CyFalse;
 1441              		.loc 1 2040 0
 1442 0c14 88C084E5 		str	ip, [r4, #136]
2041:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1443              		.loc 1 2041 0
 1444 0c18 84C084E5 		str	ip, [r4, #132]
 1445              	.LBB47:
 1446              	.LBB46:
2018:../uvc.c      **** 	{
 1447              		.loc 1 2018 0
 1448 0c1c FEFFFFEB 		bl	_txe_event_flags_get
 1449              	.LVL160:
 1450 0c20 005050E2 		subs	r5, r0, #0
 1451 0c24 CEFFFF1A 		bne	.L179
 1452              	.LBB44:
 1453              	.LBB45:
2021:../uvc.c      **** 
 1454              		.loc 1 2021 0
 1455 0c28 0400A0E1 		mov	r0, r4
 1456 0c2c 0110E0E3 		mvn	r1, #1
 1457 0c30 0220A0E3 		mov	r2, #2
 1458 0c34 FEFFFFEB 		bl	_txe_event_flags_set
 1459              	.LVL161:
2024:../uvc.c      **** 	}
 1460              		.loc 1 2024 0
 1461 0c38 0400A0E1 		mov	r0, r4
 1462 0c3c 0520A0E1 		mov	r2, r5
 1463 0c40 0210A0E3 		mov	r1, #2
 1464 0c44 FEFFFFEB 		bl	_txe_event_flags_set
 1465              	.LVL162:
 1466 0c48 C5FFFFEA 		b	.L179
 1467              	.LVL163:
 1468              	.L181:
 1469              	.LBE45:
 1470              	.LBE44:
 1471              	.LBE46:
 1472              	.LBE47:
2046:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1473              		.loc 1 2046 0
 1474 0c4c 0130A0E1 		mov	r3, r1
 1475 0c50 0420A0E1 		mov	r2, r4
 1476 0c54 6C109FE5 		ldr	r1, .L188+12
 1477              	.LVL164:
2048:../uvc.c      ****             streamingStarted = CyFalse;
 1478              		.loc 1 2048 0
 1479 0c58 5C509FE5 		ldr	r5, .L188
2046:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 1480              		.loc 1 2046 0
 1481 0c5c 0400A0E3 		mov	r0, #4
 1482              	.LVL165:
 1483 0c60 FEFFFFEB 		bl	CyU3PDebugPrint
 1484              	.LVL166:
2047:../uvc.c      ****             gpif_initialized = 0;
 1485              		.loc 1 2047 0
 1486 0c64 0100A0E3 		mov	r0, #1
 1487 0c68 FEFFFFEB 		bl	CyU3PGpifDisable
 1488              	.LVL167:
2048:../uvc.c      ****             streamingStarted = CyFalse;
 1489              		.loc 1 2048 0
 1490 0c6c 00C0A0E3 		mov	ip, #0
 1491              	.LBB48:
 1492              	.LBB49:
2018:../uvc.c      **** 	{
 1493              		.loc 1 2018 0
 1494 0c70 00C08DE5 		str	ip, [sp]
 1495 0c74 0500A0E1 		mov	r0, r5
 1496 0c78 0110A0E3 		mov	r1, #1
 1497 0c7c 0420A0E1 		mov	r2, r4
 1498 0c80 0C308DE2 		add	r3, sp, #12
 1499              	.LBE49:
 1500              	.LBE48:
2048:../uvc.c      ****             streamingStarted = CyFalse;
 1501              		.loc 1 2048 0
 1502 0c84 88C085E5 		str	ip, [r5, #136]
2049:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
 1503              		.loc 1 2049 0
 1504 0c88 84C085E5 		str	ip, [r5, #132]
 1505              	.LBB53:
 1506              	.LBB52:
2018:../uvc.c      **** 	{
 1507              		.loc 1 2018 0
 1508 0c8c FEFFFFEB 		bl	_txe_event_flags_get
 1509              	.LVL168:
 1510 0c90 006050E2 		subs	r6, r0, #0
 1511 0c94 B2FFFF1A 		bne	.L179
 1512              	.LBB50:
 1513              	.LBB51:
2021:../uvc.c      **** 
 1514              		.loc 1 2021 0
 1515 0c98 0420A0E1 		mov	r2, r4
 1516 0c9c 0500A0E1 		mov	r0, r5
 1517 0ca0 0110E0E3 		mvn	r1, #1
 1518 0ca4 FEFFFFEB 		bl	_txe_event_flags_set
 1519              	.LVL169:
2024:../uvc.c      **** 	}
 1520              		.loc 1 2024 0
 1521 0ca8 0500A0E1 		mov	r0, r5
 1522 0cac 0410A0E1 		mov	r1, r4
 1523 0cb0 0620A0E1 		mov	r2, r6
 1524 0cb4 FEFFFFEB 		bl	_txe_event_flags_set
 1525              	.LVL170:
 1526 0cb8 A9FFFFEA 		b	.L179
 1527              	.L189:
 1528              		.align	2
 1529              	.L188:
 1530 0cbc 00000000 		.word	.LANCHOR0
 1531 0cc0 6C020000 		.word	.LC16
 1532 0cc4 28020000 		.word	.LC14
 1533 0cc8 48020000 		.word	.LC15
 1534              	.LBE51:
 1535              	.LBE50:
 1536              	.LBE52:
 1537              	.LBE53:
 1538              		.cfi_endproc
 1539              	.LFE9:
 1541              		.align	2
 1543              	CyFxUVCApplnUSBSetupCB:
 1544              	.LFB10:
2079:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1545              		.loc 1 2079 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 8
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0ccc F0432DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1551              	.LCFI9:
 1552              		.cfi_def_cfa_offset 28
 1553              		.cfi_offset 4, -28
 1554              		.cfi_offset 5, -24
 1555              		.cfi_offset 6, -20
 1556              		.cfi_offset 7, -16
 1557              		.cfi_offset 8, -12
 1558              		.cfi_offset 9, -8
 1559              		.cfi_offset 14, -4
2088:../uvc.c      **** 
 1560              		.loc 1 2088 0
 1561 0cd0 B0C29FE5 		ldr	ip, .L224
2085:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1562              		.loc 1 2085 0
 1563 0cd4 B0929FE5 		ldr	r9, .L224+4
2087:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1564              		.loc 1 2087 0
 1565 0cd8 B0829FE5 		ldr	r8, .L224+8
2084:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1566              		.loc 1 2084 0
 1567 0cdc B0229FE5 		ldr	r2, .L224+12
2086:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1568              		.loc 1 2086 0
 1569 0ce0 B0329FE5 		ldr	r3, .L224+16
2087:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1570              		.loc 1 2087 0
 1571 0ce4 0168A0E1 		mov	r6, r1, asl #16
2084:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1572              		.loc 1 2084 0
 1573 0ce8 FF4000E2 		and	r4, r0, #255
2085:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1574              		.loc 1 2085 0
 1575 0cec FF5C00E2 		and	r5, r0, #65280
 1576 0cf0 2554A0E1 		mov	r5, r5, lsr #8
2087:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1577              		.loc 1 2087 0
 1578 0cf4 2668A0E1 		mov	r6, r6, lsr #16
2088:../uvc.c      **** 
 1579              		.loc 1 2088 0
 1580 0cf8 2118A0E1 		mov	r1, r1, lsr #16
 1581              	.LVL172:
2086:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1582              		.loc 1 2086 0
 1583 0cfc 2078A0E1 		mov	r7, r0, lsr #16
2091:../uvc.c      ****     {
 1584              		.loc 1 2091 0
 1585 0d00 020054E3 		cmp	r4, #2
2079:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 1586              		.loc 1 2079 0
 1587 0d04 14D04DE2 		sub	sp, sp, #20
 1588              	.LCFI10:
 1589              		.cfi_def_cfa_offset 48
2085:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 1590              		.loc 1 2085 0
 1591 0d08 0050C9E5 		strb	r5, [r9]
2087:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 1592              		.loc 1 2087 0
 1593 0d0c B060C8E1 		strh	r6, [r8]	@ movhi
2088:../uvc.c      **** 
 1594              		.loc 1 2088 0
 1595 0d10 B010CCE1 		strh	r1, [ip]	@ movhi
2084:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 1596              		.loc 1 2084 0
 1597 0d14 0040C2E5 		strb	r4, [r2]
2086:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 1598              		.loc 1 2086 0
 1599 0d18 B070C3E1 		strh	r7, [r3]	@ movhi
2091:../uvc.c      ****     {
 1600              		.loc 1 2091 0
 1601 0d1c 4A00000A 		beq	.L192
 1602 0d20 0600009A 		bls	.L221
 1603 0d24 210054E3 		cmp	r4, #33
 1604 0d28 3900000A 		beq	.L195
 1605 0d2c A10054E3 		cmp	r4, #161
 1606 0d30 3700000A 		beq	.L195
 1607              	.L209:
2080:../uvc.c      ****     uint32_t status;
 1608              		.loc 1 2080 0
 1609 0d34 0000A0E3 		mov	r0, #0
 1610              	.LVL173:
 1611              	.L191:
2218:../uvc.c      **** 
 1612              		.loc 1 2218 0
 1613 0d38 14D08DE2 		add	sp, sp, #20
 1614              		@ sp needed
 1615 0d3c F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1616              	.LVL174:
 1617              	.L221:
2091:../uvc.c      ****     {
 1618              		.loc 1 2091 0
 1619 0d40 010054E3 		cmp	r4, #1
 1620 0d44 FAFFFF1A 		bne	.L209
2131:../uvc.c      ****             {
 1621              		.loc 1 2131 0
 1622 0d48 0B0055E3 		cmp	r5, #11
 1623 0d4c F8FFFF1A 		bne	.L209
2135:../uvc.c      ****                 {
 1624              		.loc 1 2135 0
 1625 0d50 010056E3 		cmp	r6, #1
 1626 0d54 F6FFFF1A 		bne	.L209
2135:../uvc.c      ****                 {
 1627              		.loc 1 2135 0 is_stmt 0 discriminator 1
 1628 0d58 000057E3 		cmp	r7, #0
 1629 0d5c F4FFFF1A 		bne	.L209
2140:../uvc.c      ****                     streamingStarted = CyFalse;
 1630              		.loc 1 2140 0 is_stmt 1
 1631 0d60 34429FE5 		ldr	r4, .L224+20
2138:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 1632              		.loc 1 2138 0
 1633 0d64 34129FE5 		ldr	r1, .L224+24
 1634 0d68 0400A0E3 		mov	r0, #4
 1635              	.LVL175:
 1636 0d6c FEFFFFEB 		bl	CyU3PDebugPrint
 1637              	.LVL176:
2139:../uvc.c      ****                     gpif_initialized = 0;
 1638              		.loc 1 2139 0
 1639 0d70 0600A0E1 		mov	r0, r6
 1640 0d74 FEFFFFEB 		bl	CyU3PGpifDisable
 1641              	.LVL177:
2143:../uvc.c      ****                     CyU3PBusyWait (100);
 1642              		.loc 1 2143 0
 1643 0d78 0610A0E1 		mov	r1, r6
 1644 0d7c 8300A0E3 		mov	r0, #131
2140:../uvc.c      ****                     streamingStarted = CyFalse;
 1645              		.loc 1 2140 0
 1646 0d80 887084E5 		str	r7, [r4, #136]
2141:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
 1647              		.loc 1 2141 0
 1648 0d84 847084E5 		str	r7, [r4, #132]
2143:../uvc.c      ****                     CyU3PBusyWait (100);
 1649              		.loc 1 2143 0
 1650 0d88 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1651              	.LVL178:
2144:../uvc.c      **** 
 1652              		.loc 1 2144 0
 1653 0d8c 6400A0E3 		mov	r0, #100
 1654 0d90 FEFFFFEB 		bl	CyFx3BusyWait
 1655              	.LVL179:
2147:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1656              		.loc 1 2147 0
 1657 0d94 08029FE5 		ldr	r0, .L224+28
 1658 0d98 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1659              	.LVL180:
2148:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1660              		.loc 1 2148 0
 1661 0d9c 8300A0E3 		mov	r0, #131
 1662 0da0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1663              	.LVL181:
2149:../uvc.c      ****                     CyU3PBusyWait (100);
 1664              		.loc 1 2149 0
 1665 0da4 0710A0E1 		mov	r1, r7
 1666 0da8 8300A0E3 		mov	r0, #131
 1667 0dac FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1668              	.LVL182:
2150:../uvc.c      **** 
 1669              		.loc 1 2150 0
 1670 0db0 6400A0E3 		mov	r0, #100
 1671 0db4 FEFFFFEB 		bl	CyFx3BusyWait
 1672              	.LVL183:
2153:../uvc.c      ****                     uvcHandleReq = CyTrue;
 1673              		.loc 1 2153 0
 1674 0db8 0710A0E1 		mov	r1, r7
 1675 0dbc 0620A0E1 		mov	r2, r6
 1676 0dc0 8300A0E3 		mov	r0, #131
 1677 0dc4 FEFFFFEB 		bl	CyU3PUsbStall
 1678              	.LVL184:
2156:../uvc.c      ****                     /* Indicate stop streaming to main thread */
 1679              		.loc 1 2156 0
 1680 0dc8 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1681              	.LVL185:
 1682              	.LBB62:
 1683              	.LBB63:
2018:../uvc.c      **** 	{
 1684              		.loc 1 2018 0
 1685 0dcc 00708DE5 		str	r7, [sp]
 1686 0dd0 0610A0E1 		mov	r1, r6
 1687 0dd4 0400A0E1 		mov	r0, r4
 1688 0dd8 0220A0E3 		mov	r2, #2
 1689 0ddc 0C308DE2 		add	r3, sp, #12
 1690              	.LBE63:
 1691              	.LBE62:
2158:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
 1692              		.loc 1 2158 0
 1693 0de0 906084E5 		str	r6, [r4, #144]
 1694              	.LBB67:
 1695              	.LBB66:
2018:../uvc.c      **** 	{
 1696              		.loc 1 2018 0
 1697 0de4 FEFFFFEB 		bl	_txe_event_flags_get
 1698              	.LVL186:
 1699 0de8 005050E2 		subs	r5, r0, #0
 1700 0dec 1300001A 		bne	.L220
 1701              	.LBB64:
 1702              	.LBB65:
2021:../uvc.c      **** 
 1703              		.loc 1 2021 0
 1704 0df0 0400A0E1 		mov	r0, r4
 1705 0df4 0110E0E3 		mvn	r1, #1
 1706 0df8 0220A0E3 		mov	r2, #2
 1707 0dfc FEFFFFEB 		bl	_txe_event_flags_set
 1708              	.LVL187:
2024:../uvc.c      **** 	}
 1709              		.loc 1 2024 0
 1710 0e00 0400A0E1 		mov	r0, r4
 1711 0e04 0520A0E1 		mov	r2, r5
 1712 0e08 0210A0E3 		mov	r1, #2
 1713 0e0c FEFFFFEB 		bl	_txe_event_flags_set
 1714              	.LVL188:
 1715 0e10 0A0000EA 		b	.L220
 1716              	.LVL189:
 1717              	.L195:
 1718              	.LBE65:
 1719              	.LBE64:
 1720              	.LBE66:
 1721              	.LBE67:
2096:../uvc.c      ****             {
 1722              		.loc 1 2096 0
 1723 0e14 FF6006E2 		and	r6, r6, #255
 1724 0e18 000056E3 		cmp	r6, #0
 1725 0e1c 1500000A 		beq	.L196
 1726 0e20 010056E3 		cmp	r6, #1
 1727 0e24 C2FFFF1A 		bne	.L209
 1728              	.LVL190:
2114:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1729              		.loc 1 2114 0
 1730 0e28 0020A0E3 		mov	r2, #0
 1731 0e2c 68019FE5 		ldr	r0, .L224+20
 1732              	.LVL191:
 1733 0e30 0810A0E3 		mov	r1, #8
 1734 0e34 FEFFFFEB 		bl	_txe_event_flags_set
 1735              	.LVL192:
2116:../uvc.c      ****                         {
 1736              		.loc 1 2116 0
 1737 0e38 002050E2 		subs	r2, r0, #0
 1738 0e3c 1B00001A 		bne	.L222
 1739              	.LVL193:
 1740              	.L220:
2100:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 1741              		.loc 1 2100 0
 1742 0e40 0100A0E3 		mov	r0, #1
 1743              	.LVL194:
2218:../uvc.c      **** 
 1744              		.loc 1 2218 0
 1745 0e44 14D08DE2 		add	sp, sp, #20
 1746              		@ sp needed
 1747 0e48 F083BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1748              	.LVL195:
 1749              	.L192:
2166:../uvc.c      ****             {
 1750              		.loc 1 2166 0
 1751 0e4c 010055E3 		cmp	r5, #1
 1752 0e50 B7FFFF1A 		bne	.L209
2168:../uvc.c      ****                 {
 1753              		.loc 1 2168 0
 1754 0e54 830056E3 		cmp	r6, #131
 1755 0e58 B5FFFF1A 		bne	.L209
2174:../uvc.c      ****                     {
 1756              		.loc 1 2174 0
 1757 0e5c 38819FE5 		ldr	r8, .L224+20
 1758 0e60 847098E5 		ldr	r7, [r8, #132]
 1759 0e64 010057E3 		cmp	r7, #1
 1760 0e68 1900000A 		beq	.L223
 1761              	.LVL196:
2206:../uvc.c      ****                     }
 1762              		.loc 1 2206 0
 1763 0e6c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1764              	.LVL197:
2205:../uvc.c      ****                         CyU3PUsbAckSetup ();
 1765              		.loc 1 2205 0
 1766 0e70 0500A0E1 		mov	r0, r5
 1767 0e74 AFFFFFEA 		b	.L191
 1768              	.LVL198:
 1769              	.L196:
2101:../uvc.c      ****                                 CYU3P_EVENT_OR);
 1770              		.loc 1 2101 0
 1771 0e78 0620A0E1 		mov	r2, r6
 1772 0e7c 18019FE5 		ldr	r0, .L224+20
 1773              	.LVL199:
 1774 0e80 0410A0E3 		mov	r1, #4
 1775 0e84 FEFFFFEB 		bl	_txe_event_flags_set
 1776              	.LVL200:
2103:../uvc.c      ****                         {
 1777              		.loc 1 2103 0
 1778 0e88 002050E2 		subs	r2, r0, #0
 1779 0e8c EBFFFF0A 		beq	.L220
2105:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1780              		.loc 1 2105 0
 1781 0e90 10119FE5 		ldr	r1, .L224+32
 1782 0e94 0400A0E3 		mov	r0, #4
 1783              	.LVL201:
 1784 0e98 FEFFFFEB 		bl	CyU3PDebugPrint
 1785              	.LVL202:
2106:../uvc.c      ****                         }
 1786              		.loc 1 2106 0
 1787 0e9c 0600A0E1 		mov	r0, r6
 1788 0ea0 0620A0E1 		mov	r2, r6
 1789 0ea4 0110A0E3 		mov	r1, #1
 1790 0ea8 FEFFFFEB 		bl	CyU3PUsbStall
 1791              	.LVL203:
 1792 0eac E3FFFFEA 		b	.L220
 1793              	.LVL204:
 1794              	.L222:
2119:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1795              		.loc 1 2119 0
 1796 0eb0 F4109FE5 		ldr	r1, .L224+36
 1797 0eb4 0400A0E3 		mov	r0, #4
 1798              	.LVL205:
 1799 0eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 1800              	.LVL206:
2120:../uvc.c      ****                         }
 1801              		.loc 1 2120 0
 1802 0ebc 0000A0E3 		mov	r0, #0
 1803 0ec0 0020A0E1 		mov	r2, r0
 1804 0ec4 0610A0E1 		mov	r1, r6
 1805 0ec8 FEFFFFEB 		bl	CyU3PUsbStall
 1806              	.LVL207:
2113:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 1807              		.loc 1 2113 0
 1808 0ecc 0600A0E1 		mov	r0, r6
 1809 0ed0 98FFFFEA 		b	.L191
 1810              	.LVL208:
 1811              	.L223:
2176:../uvc.c      **** 
 1812              		.loc 1 2176 0
 1813 0ed4 D4109FE5 		ldr	r1, .L224+40
 1814 0ed8 0400A0E3 		mov	r0, #4
 1815              	.LVL209:
 1816 0edc FEFFFFEB 		bl	CyU3PDebugPrint
 1817              	.LVL210:
2179:../uvc.c      ****                         gpif_initialized = 0;
 1818              		.loc 1 2179 0
 1819 0ee0 0700A0E1 		mov	r0, r7
 1820 0ee4 FEFFFFEB 		bl	CyU3PGpifDisable
 1821              	.LVL211:
2180:../uvc.c      ****                         streamingStarted = CyFalse;
 1822              		.loc 1 2180 0
 1823 0ee8 0050A0E3 		mov	r5, #0
2184:../uvc.c      ****                         CyU3PBusyWait (100);
 1824              		.loc 1 2184 0
 1825 0eec 0710A0E1 		mov	r1, r7
 1826 0ef0 0600A0E1 		mov	r0, r6
2180:../uvc.c      ****                         streamingStarted = CyFalse;
 1827              		.loc 1 2180 0
 1828 0ef4 885088E5 		str	r5, [r8, #136]
2181:../uvc.c      **** 
 1829              		.loc 1 2181 0
 1830 0ef8 845088E5 		str	r5, [r8, #132]
2184:../uvc.c      ****                         CyU3PBusyWait (100);
 1831              		.loc 1 2184 0
 1832 0efc FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1833              	.LVL212:
2185:../uvc.c      **** 
 1834              		.loc 1 2185 0
 1835 0f00 6400A0E3 		mov	r0, #100
 1836 0f04 FEFFFFEB 		bl	CyFx3BusyWait
 1837              	.LVL213:
2188:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 1838              		.loc 1 2188 0
 1839 0f08 94009FE5 		ldr	r0, .L224+28
 1840 0f0c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 1841              	.LVL214:
2189:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 1842              		.loc 1 2189 0
 1843 0f10 0600A0E1 		mov	r0, r6
 1844 0f14 FEFFFFEB 		bl	CyU3PUsbFlushEp
 1845              	.LVL215:
2190:../uvc.c      ****                         CyU3PBusyWait (100);
 1846              		.loc 1 2190 0
 1847 0f18 0510A0E1 		mov	r1, r5
 1848 0f1c 0600A0E1 		mov	r0, r6
 1849 0f20 FEFFFFEB 		bl	CyU3PUsbSetEpNak
 1850              	.LVL216:
2191:../uvc.c      **** 
 1851              		.loc 1 2191 0
 1852 0f24 6400A0E3 		mov	r0, #100
 1853 0f28 FEFFFFEB 		bl	CyFx3BusyWait
 1854              	.LVL217:
2194:../uvc.c      **** 
 1855              		.loc 1 2194 0
 1856 0f2c 0510A0E1 		mov	r1, r5
 1857 0f30 0720A0E1 		mov	r2, r7
 1858 0f34 0600A0E1 		mov	r0, r6
 1859 0f38 FEFFFFEB 		bl	CyU3PUsbStall
 1860              	.LVL218:
2198:../uvc.c      ****                         /* Indicate stop streaming to main thread */
 1861              		.loc 1 2198 0
 1862 0f3c FEFFFFEB 		bl	CyU3PUsbAckSetup
 1863              	.LVL219:
 1864              	.LBB68:
 1865              	.LBB69:
2018:../uvc.c      **** 	{
 1866              		.loc 1 2018 0
 1867 0f40 00508DE5 		str	r5, [sp]
 1868 0f44 0710A0E1 		mov	r1, r7
 1869 0f48 0800A0E1 		mov	r0, r8
 1870 0f4c 0420A0E1 		mov	r2, r4
 1871 0f50 0C308DE2 		add	r3, sp, #12
 1872              	.LBE69:
 1873              	.LBE68:
2200:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
 1874              		.loc 1 2200 0
 1875 0f54 907088E5 		str	r7, [r8, #144]
 1876              	.LBB73:
 1877              	.LBB72:
2018:../uvc.c      **** 	{
 1878              		.loc 1 2018 0
 1879 0f58 FEFFFFEB 		bl	_txe_event_flags_get
 1880              	.LVL220:
 1881 0f5c 005050E2 		subs	r5, r0, #0
 1882 0f60 B6FFFF1A 		bne	.L220
 1883              	.LBB70:
 1884              	.LBB71:
2021:../uvc.c      **** 
 1885              		.loc 1 2021 0
 1886 0f64 0420A0E1 		mov	r2, r4
 1887 0f68 0800A0E1 		mov	r0, r8
 1888 0f6c 0110E0E3 		mvn	r1, #1
 1889 0f70 FEFFFFEB 		bl	_txe_event_flags_set
 1890              	.LVL221:
2024:../uvc.c      **** 	}
 1891              		.loc 1 2024 0
 1892 0f74 0800A0E1 		mov	r0, r8
 1893 0f78 0410A0E1 		mov	r1, r4
 1894 0f7c 0520A0E1 		mov	r2, r5
 1895 0f80 FEFFFFEB 		bl	_txe_event_flags_set
 1896              	.LVL222:
 1897 0f84 ADFFFFEA 		b	.L220
 1898              	.L225:
 1899              		.align	2
 1900              	.L224:
 1901 0f88 00000000 		.word	wLength
 1902 0f8c 00000000 		.word	bRequest
 1903 0f90 00000000 		.word	wIndex
 1904 0f94 00000000 		.word	bmReqType
 1905 0f98 00000000 		.word	wValue
 1906 0f9c 00000000 		.word	.LANCHOR0
 1907 0fa0 F8020000 		.word	.LC19
 1908 0fa4 00000000 		.word	glChHandleUVCStream
 1909 0fa8 8C020000 		.word	.LC17
 1910 0fac C4020000 		.word	.LC18
 1911 0fb0 10030000 		.word	.LC20
 1912              	.LBE71:
 1913              	.LBE70:
 1914              	.LBE72:
 1915              	.LBE73:
 1916              		.cfi_endproc
 1917              	.LFE10:
 1919              		.align	2
 1920              		.global	I2CCmdHandler
 1922              	I2CCmdHandler:
 1923              	.LFB0:
 607:../uvc.c      **** 	uint8_t buf[2];
 1924              		.loc 1 607 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 8
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928 0fb4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1929              	.LCFI11:
 1930              		.cfi_def_cfa_offset 36
 1931              		.cfi_offset 4, -36
 1932              		.cfi_offset 5, -32
 1933              		.cfi_offset 6, -28
 1934              		.cfi_offset 7, -24
 1935              		.cfi_offset 8, -20
 1936              		.cfi_offset 9, -16
 1937              		.cfi_offset 10, -12
 1938              		.cfi_offset 11, -8
 1939              		.cfi_offset 14, -4
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1940              		.loc 1 610 0
 1941 0fb8 F8419FE5 		ldr	r4, .L248
 607:../uvc.c      **** 	uint8_t buf[2];
 1942              		.loc 1 607 0
 1943 0fbc 34D04DE2 		sub	sp, sp, #52
 1944              	.LCFI12:
 1945              		.cfi_def_cfa_offset 88
 615:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1946              		.loc 1 615 0
 1947 0fc0 9A30D4E5 		ldrb	r3, [r4, #154]	@ zero_extendqisi2
 610:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 1948              		.loc 1 610 0
 1949 0fc4 9450D4E5 		ldrb	r5, [r4, #148]	@ zero_extendqisi2
 1950              	.LVL223:
 611:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1951              		.loc 1 611 0
 1952 0fc8 9570D4E5 		ldrb	r7, [r4, #149]	@ zero_extendqisi2
 1953              	.LVL224:
 612:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 1954              		.loc 1 612 0
 1955 0fcc 9C60D4E5 		ldrb	r6, [r4, #156]	@ zero_extendqisi2
 1956              	.LVL225:
 615:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 1957              		.loc 1 615 0
 1958 0fd0 96B0D4E5 		ldrb	fp, [r4, #150]	@ zero_extendqisi2
 1959 0fd4 97A0D4E5 		ldrb	r10, [r4, #151]	@ zero_extendqisi2
 1960 0fd8 9890D4E5 		ldrb	r9, [r4, #152]	@ zero_extendqisi2
 1961 0fdc 9980D4E5 		ldrb	r8, [r4, #153]	@ zero_extendqisi2
 1962 0fe0 10308DE5 		str	r3, [sp, #16]
 1963 0fe4 9E10D4E5 		ldrb	r1, [r4, #158]	@ zero_extendqisi2
 1964 0fe8 9BE0D4E5 		ldrb	lr, [r4, #155]	@ zero_extendqisi2
 1965 0fec 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 1966 0ff0 0730A0E1 		mov	r3, r7
 1967 0ff4 20108DE5 		str	r1, [sp, #32]
 1968 0ff8 0400A0E3 		mov	r0, #4
 1969 0ffc 0520A0E1 		mov	r2, r5
 1970 1000 18608DE5 		str	r6, [sp, #24]
 1971 1004 00B08DE5 		str	fp, [sp]
 1972 1008 04A08DE5 		str	r10, [sp, #4]
 1973 100c 08908DE5 		str	r9, [sp, #8]
 1974 1010 0C808DE5 		str	r8, [sp, #12]
 1975 1014 14E08DE5 		str	lr, [sp, #20]
 1976 1018 1CC08DE5 		str	ip, [sp, #28]
 1977 101c 98119FE5 		ldr	r1, .L248+4
 1978 1020 FEFFFFEB 		bl	CyU3PDebugPrint
 1979              	.LVL226:
 618:../uvc.c      **** 	{
 1980              		.loc 1 618 0
 1981 1024 9730D4E5 		ldrb	r3, [r4, #151]	@ zero_extendqisi2
 1982 1028 520053E3 		cmp	r3, #82
 1983 102c 2D00000A 		beq	.L243
 1984              	.L227:
 628:../uvc.c      **** 	{
 1985              		.loc 1 628 0
 1986 1030 000055E3 		cmp	r5, #0
 1987 1034 1600000A 		beq	.L244
 653:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 1988              		.loc 1 653 0
 1989 1038 010055E3 		cmp	r5, #1
 1990 103c 0100000A 		beq	.L245
 1991              	.LVL227:
 1992              	.L226:
 672:../uvc.c      **** 
 1993              		.loc 1 672 0
 1994 1040 34D08DE2 		add	sp, sp, #52
 1995              		@ sp needed
 1996 1044 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1997              	.LVL228:
 1998              	.L245:
 655:../uvc.c      **** 				for(i = 0; i<4; i++)
 1999              		.loc 1 655 0
 2000 1048 020057E3 		cmp	r7, #2
 2001 104c 3800000A 		beq	.L246
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2002              		.loc 1 660 0
 2003 1050 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2004 1054 5C019FE5 		ldr	r0, .L248
 2005 1058 FE1001E2 		and	r1, r1, #254
 2006 105c 820051E3 		cmp	r1, #130
 2007 1060 0200001A 		bne	.L236
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2008              		.loc 1 660 0 is_stmt 0 discriminator 1
 2009 1064 9850D0E5 		ldrb	r5, [r0, #152]	@ zero_extendqisi2
 2010              	.LVL229:
 2011 1068 300055E3 		cmp	r5, #48
 2012 106c 3D00000A 		beq	.L247
 2013              	.L236:
 2014 1070 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2015 1074 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2016              	.LVL230:
 2017              	.L237:
 665:../uvc.c      **** 			}
 2018              		.loc 1 665 0 is_stmt 1
 2019 1078 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2020 107c 9DC0D4E5 		ldrb	ip, [r4, #157]	@ zero_extendqisi2
 2021 1080 FE0000E2 		and	r0, r0, #254
 2022 1084 00C08DE5 		str	ip, [sp]
 2023 1088 FEFFFFEB 		bl	SensorWrite2B
 2024              	.LVL231:
 672:../uvc.c      **** 
 2025              		.loc 1 672 0
 2026 108c 34D08DE2 		add	sp, sp, #52
 2027              		@ sp needed
 2028 1090 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2029              	.LVL232:
 2030              	.L244:
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2031              		.loc 1 644 0
 2032 1094 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2033 1098 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2034 109c 28C08DE2 		add	ip, sp, #40
 2035 10a0 9820D4E5 		ldrb	r2, [r4, #152]	@ zero_extendqisi2
 2036 10a4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2037 10a8 00C08DE5 		str	ip, [sp]
 630:../uvc.c      **** #if 0 //for debugging
 2038              		.loc 1 630 0
 2039 10ac 0FC0A0E3 		mov	ip, #15
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2040              		.loc 1 644 0
 2041 10b0 011081E3 		orr	r1, r1, #1
 630:../uvc.c      **** #if 0 //for debugging
 2042              		.loc 1 630 0
 2043 10b4 9FC0C4E5 		strb	ip, [r4, #159]
 644:../uvc.c      **** 				I2CCMDArry[9] = buf[0];
 2044              		.loc 1 644 0
 2045 10b8 010080E3 		orr	r0, r0, #1
 2046 10bc FEFFFFEB 		bl	SensorRead2B
 2047              	.LVL233:
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 2048              		.loc 1 645 0
 2049 10c0 2830DDE5 		ldrb	r3, [sp, #40]	@ zero_extendqisi2
 646:../uvc.c      **** 					I2CCMDArry[10] = buf[1];
 2050              		.loc 1 646 0
 2051 10c4 020056E3 		cmp	r6, #2
 645:../uvc.c      **** 				if(CmdDataLen == 2){
 2052              		.loc 1 645 0
 2053 10c8 9D30C4E5 		strb	r3, [r4, #157]
 647:../uvc.c      **** 				}
 2054              		.loc 1 647 0
 2055 10cc 2920DD05 		ldreqb	r2, [sp, #41]	@ zero_extendqisi2
 630:../uvc.c      **** #if 0 //for debugging
 2056              		.loc 1 630 0
 2057 10d0 E0309FE5 		ldr	r3, .L248
 647:../uvc.c      **** 				}
 2058              		.loc 1 647 0
 2059 10d4 9E20C305 		streqb	r2, [r3, #158]
 649:../uvc.c      **** 		}else{//not support currently
 2060              		.loc 1 649 0
 2061 10d8 0030E0E3 		mvn	r3, #0
 2062 10dc 9F30C4E5 		strb	r3, [r4, #159]
 672:../uvc.c      **** 
 2063              		.loc 1 672 0
 2064 10e0 34D08DE2 		add	sp, sp, #52
 2065              		@ sp needed
 2066 10e4 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2067              	.LVL234:
 2068              	.L243:
 618:../uvc.c      **** 	{
 2069              		.loc 1 618 0 discriminator 1
 2070 10e8 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2071 10ec 300053E3 		cmp	r3, #48
 2072 10f0 CEFFFF1A 		bne	.L227
 2073 10f4 9930D4E5 		ldrb	r3, [r4, #153]	@ zero_extendqisi2
 2074 10f8 010053E3 		cmp	r3, #1
 2075 10fc CBFFFF1A 		bne	.L227
 620:../uvc.c      **** 		if(is60Hz==CyFalse)
 2076              		.loc 1 620 0
 2077 1100 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2078 1104 B4309FE5 		ldr	r3, .L248+8
 2079 1108 031002E2 		and	r1, r2, #3
 2080 110c 5210C3E5 		strb	r1, [r3, #82]
 621:../uvc.c      **** 			{
 2081              		.loc 1 621 0
 2082 1110 6C1094E5 		ldr	r1, [r4, #108]
 625:../uvc.c      **** 
 2083              		.loc 1 625 0
 2084 1114 0400A0E3 		mov	r0, #4
 621:../uvc.c      **** 			{
 2085              		.loc 1 621 0
 2086 1118 000051E3 		cmp	r1, #0
 623:../uvc.c      **** 			}
 2087              		.loc 1 623 0
 2088 111c 80208203 		orreq	r2, r2, #128
 625:../uvc.c      **** 
 2089              		.loc 1 625 0
 2090 1120 5230D3E5 		ldrb	r3, [r3, #82]	@ zero_extendqisi2
 2091 1124 98109FE5 		ldr	r1, .L248+12
 623:../uvc.c      **** 			}
 2092              		.loc 1 623 0
 2093 1128 9D20C405 		streqb	r2, [r4, #157]
 625:../uvc.c      **** 
 2094              		.loc 1 625 0
 2095 112c FEFFFFEB 		bl	CyU3PDebugPrint
 2096              	.LVL235:
 2097 1130 BEFFFFEA 		b	.L227
 2098              	.L246:
 655:../uvc.c      **** 				for(i = 0; i<4; i++)
 2099              		.loc 1 655 0
 2100 1134 0450A0E3 		mov	r5, #4
 2101              	.LVL236:
 2102              	.L235:
 657:../uvc.c      **** 			}
 2103              		.loc 1 657 0 discriminator 2
 2104 1138 9600D4E5 		ldrb	r0, [r4, #150]	@ zero_extendqisi2
 2105 113c 9D20D4E5 		ldrb	r2, [r4, #157]	@ zero_extendqisi2
 2106 1140 9710D4E5 		ldrb	r1, [r4, #151]	@ zero_extendqisi2
 2107 1144 9830D4E5 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 2108 1148 FE0000E2 		and	r0, r0, #254
 2109 114c 00208DE5 		str	r2, [sp]
 2110 1150 015045E2 		sub	r5, r5, #1
 2111 1154 0020A0E3 		mov	r2, #0
 2112 1158 FEFFFFEB 		bl	SensorWrite2B2
 2113              	.LVL237:
 656:../uvc.c      **** 				SensorWrite2B2(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3], 0, I2CCMDArry[4], I2CCMDArry[9]);
 2114              		.loc 1 656 0 discriminator 2
 2115 115c FF5015E2 		ands	r5, r5, #255
 2116 1160 F4FFFF1A 		bne	.L235
 2117 1164 B5FFFFEA 		b	.L226
 2118              	.L247:
 660:../uvc.c      **** 					CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 2119              		.loc 1 660 0 discriminator 1
 2120 1168 9960D0E5 		ldrb	r6, [r0, #153]	@ zero_extendqisi2
 2121              	.LVL238:
 2122 116c 100056E3 		cmp	r6, #16
 2123 1170 0630A011 		movne	r3, r6
 2124 1174 0520A011 		movne	r2, r5
 2125 1178 BEFFFF1A 		bne	.L237
 661:../uvc.c      **** 					cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 2126              		.loc 1 661 0
 2127 117c 44409FE5 		ldr	r4, .L248+16
 2128 1180 0010E0E3 		mvn	r1, #0
 2129 1184 1C0094E5 		ldr	r0, [r4, #28]
 2130 1188 FEFFFFEB 		bl	_txe_mutex_get
 2131              	.LVL239:
 662:../uvc.c      **** 					CyU3PMutexPut(cmdQuptr->ringMux);
 2132              		.loc 1 662 0
 2133 118c 0010A0E3 		mov	r1, #0
 2134 1190 00108DE5 		str	r1, [sp]
 2135 1194 04108DE5 		str	r1, [sp, #4]
 2136 1198 0620A0E1 		mov	r2, r6
 2137 119c 0530A0E1 		mov	r3, r5
 2138 11a0 0400A0E1 		mov	r0, r4
 2139 11a4 1710A0E3 		mov	r1, #23
 2140 11a8 FEFFFFEB 		bl	cmdSet
 2141              	.LVL240:
 663:../uvc.c      **** 				}
 2142              		.loc 1 663 0
 2143 11ac 1C0094E5 		ldr	r0, [r4, #28]
 2144 11b0 FEFFFFEB 		bl	_txe_mutex_put
 2145              	.LVL241:
 2146 11b4 A1FFFFEA 		b	.L226
 2147              	.L249:
 2148              		.align	2
 2149              	.L248:
 2150 11b8 00000000 		.word	.LANCHOR0
 2151 11bc 34030000 		.word	.LC21
 2152 11c0 00000000 		.word	.LANCHOR1
 2153 11c4 80030000 		.word	.LC22
 2154 11c8 00000000 		.word	cmdQu
 2155              		.cfi_endproc
 2156              	.LFE0:
 2158              		.align	2
 2159              		.global	setIrisauto
 2161              	setIrisauto:
 2162              	.LFB1:
 678:../uvc.c      **** 	uint8_t dataIdx = 0;
 2163              		.loc 1 678 0
 2164              		.cfi_startproc
 2165              		@ args = 0, pretend = 0, frame = 0
 2166              		@ frame_needed = 0, uses_anonymous_args = 0
 2167              	.LVL242:
 2168 11cc 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 2169              	.LCFI13:
 2170              		.cfi_def_cfa_offset 16
 2171              		.cfi_offset 4, -16
 2172              		.cfi_offset 5, -12
 2173              		.cfi_offset 6, -8
 2174              		.cfi_offset 14, -4
 2175 11d0 0150A0E1 		mov	r5, r1
 2176 11d4 08D04DE2 		sub	sp, sp, #8
 2177              	.LCFI14:
 2178              		.cfi_def_cfa_offset 24
 678:../uvc.c      **** 	uint8_t dataIdx = 0;
 2179              		.loc 1 678 0
 2180 11d8 0040A0E1 		mov	r4, r0
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2181              		.loc 1 681 0
 2182 11dc 0060A0E3 		mov	r6, #0
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 2183              		.loc 1 680 0
 2184 11e0 0010E0E3 		mvn	r1, #0
 2185              	.LVL243:
 2186 11e4 1C0090E5 		ldr	r0, [r0, #28]
 2187              	.LVL244:
 2188 11e8 FEFFFFEB 		bl	_txe_mutex_get
 2189              	.LVL245:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 2190              		.loc 1 681 0
 2191 11ec 062055E0 		subs	r2, r5, r6
 2192 11f0 003072E2 		rsbs	r3, r2, #0
 2193 11f4 0230B3E0 		adcs	r3, r3, r2
 2194 11f8 00308DE5 		str	r3, [sp]
 2195 11fc 0400A0E1 		mov	r0, r4
 2196 1200 04608DE5 		str	r6, [sp, #4]
 2197 1204 2010A0E3 		mov	r1, #32
 2198 1208 2720A0E3 		mov	r2, #39
 2199 120c 3030A0E3 		mov	r3, #48
 2200 1210 FEFFFFEB 		bl	cmdSet
 2201              	.LVL246:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2202              		.loc 1 682 0
 2203 1214 060055E1 		cmp	r5, r6
 2204 1218 0250A003 		moveq	r5, #2
 2205 121c 0150A013 		movne	r5, #1
 2206 1220 60008DE8 		stmia	sp, {r5, r6}
 2207 1224 0400A0E1 		mov	r0, r4
 2208 1228 2110A0E3 		mov	r1, #33
 2209 122c 2520A0E3 		mov	r2, #37
 2210 1230 3030A0E3 		mov	r3, #48
 2211 1234 FEFFFFEB 		bl	cmdSet
 2212              	.LVL247:
 683:../uvc.c      **** }
 2213              		.loc 1 683 0
 2214 1238 1C0094E5 		ldr	r0, [r4, #28]
 684:../uvc.c      **** 
 2215              		.loc 1 684 0
 2216 123c 08D08DE2 		add	sp, sp, #8
 2217              		@ sp needed
 2218 1240 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 2219              	.LVL248:
 683:../uvc.c      **** }
 2220              		.loc 1 683 0
 2221 1244 FEFFFFEA 		b	_txe_mutex_put
 2222              	.LVL249:
 2223              		.cfi_endproc
 2224              	.LFE1:
 2226              		.align	2
 2227              		.global	getShutCtrl
 2229              	getShutCtrl:
 2230              	.LFB2:
 688:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2231              		.loc 1 688 0
 2232              		.cfi_startproc
 2233              		@ args = 0, pretend = 0, frame = 0
 2234              		@ frame_needed = 0, uses_anonymous_args = 0
 2235              	.LVL250:
 693:../uvc.c      **** 	case 1:
 2236              		.loc 1 693 0
 2237 1248 013040E2 		sub	r3, r0, #1
 688:../uvc.c      **** 	const uint16_t LnTm = 514;   // time of a line in microsecond for full Res. (2592x1944)
 2238              		.loc 1 688 0
 2239 124c 30402DE9 		stmfd	sp!, {r4, r5, lr}
 2240              	.LCFI15:
 2241              		.cfi_def_cfa_offset 12
 2242              		.cfi_offset 4, -12
 2243              		.cfi_offset 5, -8
 2244              		.cfi_offset 14, -4
 2245 1250 0020A0E1 		mov	r2, r0
 2246 1254 0CD04DE2 		sub	sp, sp, #12
 2247              	.LCFI16:
 2248              		.cfi_def_cfa_offset 24
 693:../uvc.c      **** 	case 1:
 2249              		.loc 1 693 0
 2250 1258 090053E3 		cmp	r3, #9
 2251 125c 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 2252 1260 350000EA 		b	.L254
 2253              	.L256:
 2254 1264 00130000 		.word	.L255
 2255 1268 00130000 		.word	.L255
 2256 126c 00130000 		.word	.L255
 2257 1270 00130000 		.word	.L255
 2258 1274 00130000 		.word	.L255
 2259 1278 8C120000 		.word	.L257
 2260 127c 8C120000 		.word	.L257
 2261 1280 8C120000 		.word	.L257
 2262 1284 8C120000 		.word	.L257
 2263 1288 8C120000 		.word	.L257
 2264              	.L257:
 2265              	.LVL251:
 715:../uvc.c      **** 		fRate = 30;
 2266              		.loc 1 715 0
 2267 128c D0009FE5 		ldr	r0, .L269
 2268              	.LVL252:
 2269 1290 8330A0E1 		mov	r3, r3, asl #1
 717:../uvc.c      **** 		if(NumLn > 1944)
 2270              		.loc 1 717 0
 2271 1294 B33090E1 		ldrh	r3, [r0, r3]
 2272 1298 C8C09FE5 		ldr	ip, .L269+4
 2273 129c 030263E0 		rsb	r0, r3, r3, asl #4
 2274 12a0 8000A0E1 		mov	r0, r0, asl #1
 2275 12a4 90ECCCE0 		smull	lr, ip, r0, ip
 2276 12a8 C00FA0E1 		mov	r0, r0, asr #31
 2277 12ac 4C0460E0 		rsb	r0, r0, ip, asr #8
 718:../uvc.c      **** 			NumLn =1944;
 2278              		.loc 1 718 0
 2279 12b0 B4E09FE5 		ldr	lr, .L269+8
 717:../uvc.c      **** 		if(NumLn > 1944)
 2280              		.loc 1 717 0
 2281 12b4 0008A0E1 		mov	r0, r0, asl #16
 2282 12b8 20C8A0E1 		mov	ip, r0, lsr #16
 2283              	.LVL253:
 718:../uvc.c      **** 			NumLn =1944;
 2284              		.loc 1 718 0
 2285 12bc 0E005CE1 		cmp	ip, lr
 2286 12c0 1A00008A 		bhi	.L263
 2287              	.LVL254:
 2288              	.L267:
 720:../uvc.c      **** 			NumLn = 8;
 2289              		.loc 1 720 0
 2290 12c4 07005CE3 		cmp	ip, #7
 2291 12c8 2100008A 		bhi	.L268
 2292 12cc 0100A0E3 		mov	r0, #1
 2293 12d0 0040A0E1 		mov	r4, r0
 2294 12d4 08E0A0E3 		mov	lr, #8
 2295              	.L260:
 2296              	.LVL255:
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2297              		.loc 1 723 0
 2298 12d8 0150A0E3 		mov	r5, #1
 724:../uvc.c      **** 		break;
 2299              		.loc 1 724 0
 2300 12dc 04008DE5 		str	r0, [sp, #4]
 2301 12e0 00E08DE5 		str	lr, [sp]
 2302 12e4 0400A0E3 		mov	r0, #4
 723:../uvc.c      **** 		CyU3PDebugPrint (4, "The shutter set value %d 0x%x 0x%x 0x%x\r\n", Data, shutTm, NumLn, LnVal); /
 2303              		.loc 1 723 0
 2304 12e8 0050C1E5 		strb	r5, [r1]
 724:../uvc.c      **** 		break;
 2305              		.loc 1 724 0
 2306 12ec 7C109FE5 		ldr	r1, .L269+12
 2307              	.LVL256:
 2308 12f0 FEFFFFEB 		bl	CyU3PDebugPrint
 2309              	.LVL257:
 733:../uvc.c      **** 
 2310              		.loc 1 733 0
 2311 12f4 0400A0E1 		mov	r0, r4
 2312 12f8 0CD08DE2 		add	sp, sp, #12
 2313              		@ sp needed
 2314 12fc 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2315              	.LVL258:
 2316              	.L255:
 699:../uvc.c      **** 		fRate = 30;
 2317              		.loc 1 699 0
 2318 1300 5C009FE5 		ldr	r0, .L269
 2319              	.LVL259:
 2320 1304 8330A0E1 		mov	r3, r3, asl #1
 2321 1308 B33090E1 		ldrh	r3, [r0, r3]
 2322              	.LVL260:
 701:../uvc.c      **** 		if(NumLn > 1944)
 2323              		.loc 1 701 0
 2324 130c 60009FE5 		ldr	r0, .L269+16
 2325              	.LVL261:
 702:../uvc.c      **** 			NumLn =1944;
 2326              		.loc 1 702 0
 2327 1310 54E09FE5 		ldr	lr, .L269+8
 701:../uvc.c      **** 		if(NumLn > 1944)
 2328              		.loc 1 701 0
 2329 1314 93C080E0 		umull	ip, r0, r3, r0
 2330 1318 A004A0E1 		mov	r0, r0, lsr #9
 2331 131c 000260E0 		rsb	r0, r0, r0, asl #4
 2332 1320 8008A0E1 		mov	r0, r0, asl #17
 2333 1324 20C8A0E1 		mov	ip, r0, lsr #16
 2334              	.LVL262:
 702:../uvc.c      **** 			NumLn =1944;
 2335              		.loc 1 702 0
 2336 1328 0E005CE1 		cmp	ip, lr
 2337 132c E4FFFF9A 		bls	.L267
 2338              	.LVL263:
 2339              	.L263:
 2340 1330 F300A0E3 		mov	r0, #243
 2341 1334 0040A0E1 		mov	r4, r0
 2342 1338 E6FFFFEA 		b	.L260
 2343              	.LVL264:
 2344              	.L254:
 729:../uvc.c      **** 		break;
 2345              		.loc 1 729 0
 2346 133c 0140A0E3 		mov	r4, #1
 728:../uvc.c      **** 		LnVal = 1;
 2347              		.loc 1 728 0
 2348 1340 0030A0E3 		mov	r3, #0
 733:../uvc.c      **** 
 2349              		.loc 1 733 0
 2350 1344 0400A0E1 		mov	r0, r4
 2351              	.LVL265:
 728:../uvc.c      **** 		LnVal = 1;
 2352              		.loc 1 728 0
 2353 1348 0030C1E5 		strb	r3, [r1]
 2354              	.LVL266:
 733:../uvc.c      **** 
 2355              		.loc 1 733 0
 2356 134c 0CD08DE2 		add	sp, sp, #12
 2357              		@ sp needed
 2358 1350 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 2359              	.LVL267:
 2360              	.L268:
 2361 1354 A009A0E1 		mov	r0, r0, lsr #19
 2362 1358 FF4000E2 		and	r4, r0, #255
 2363 135c 0CE0A0E1 		mov	lr, ip
 2364 1360 DCFFFFEA 		b	.L260
 2365              	.L270:
 2366              		.align	2
 2367              	.L269:
 2368 1364 00000000 		.word	.LANCHOR2
 2369 1368 817F807F 		.word	2139127681
 2370 136c 98070000 		.word	1944
 2371 1370 A8030000 		.word	.LC23
 2372 1374 01FF00FF 		.word	-16711935
 2373              		.cfi_endproc
 2374              	.LFE2:
 2376              		.align	2
 2377              		.global	ControlHandle
 2379              	ControlHandle:
 2380              	.LFB3:
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2381              		.loc 1 735 0
 2382              		.cfi_startproc
 2383              		@ args = 0, pretend = 0, frame = 24
 2384              		@ frame_needed = 0, uses_anonymous_args = 0
 2385              	.LVL268:
 2386 1378 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2387              	.LCFI17:
 2388              		.cfi_def_cfa_offset 36
 2389              		.cfi_offset 4, -36
 2390              		.cfi_offset 5, -32
 2391              		.cfi_offset 6, -28
 2392              		.cfi_offset 7, -24
 2393              		.cfi_offset 8, -20
 2394              		.cfi_offset 9, -16
 2395              		.cfi_offset 10, -12
 2396              		.cfi_offset 11, -8
 2397              		.cfi_offset 14, -4
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2398              		.loc 1 743 0
 2399 137c B86F9FE5 		ldr	r6, .L440+48
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2400              		.loc 1 741 0
 2401 1380 208040E2 		sub	r8, r0, #32
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2402              		.loc 1 742 0
 2403 1384 230050E3 		cmp	r0, #35
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2404              		.loc 1 735 0
 2405 1388 2CD04DE2 		sub	sp, sp, #44
 2406              	.LCFI18:
 2407              		.cfi_def_cfa_offset 80
 735:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 2408              		.loc 1 735 0
 2409 138c 0040A0E1 		mov	r4, r0
 741:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 2410              		.loc 1 741 0
 2411 1390 FF8008E2 		and	r8, r8, #255
 2412              	.LVL269:
 742:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 2413              		.loc 1 742 0
 2414 1394 2A00009A 		bls	.L272
 743:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 2415              		.loc 1 743 0
 2416 1398 882088E0 		add	r2, r8, r8, asl #1
 2417 139c 822186E0 		add	r2, r6, r2, asl #3
 2418 13a0 6C30D2E5 		ldrb	r3, [r2, #108]	@ zero_extendqisi2
 2419              	.LVL270:
 744:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 2420              		.loc 1 744 0
 2421 13a4 6DB0D2E5 		ldrb	fp, [r2, #109]	@ zero_extendqisi2
 2422              	.LVL271:
 745:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 2423              		.loc 1 745 0
 2424 13a8 7BA0D2E5 		ldrb	r10, [r2, #123]	@ zero_extendqisi2
 2425              	.LVL272:
 746:../uvc.c      ****     }else{
 2426              		.loc 1 746 0
 2427 13ac 6E90D2E5 		ldrb	r9, [r2, #110]	@ zero_extendqisi2
 2428              	.LVL273:
 757:../uvc.c      ****     /*
 2429              		.loc 1 757 0
 2430 13b0 542F9FE5 		ldr	r2, .L440
 2431              	.LVL274:
 2432 13b4 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2433              	.LVL275:
 765:../uvc.c      **** 		 {
 2434              		.loc 1 765 0
 2435 13b8 830055E3 		cmp	r5, #131
 2436 13bc 2A00000A 		beq	.L275
 2437              	.LVL276:
 2438              	.L433:
 2439 13c0 3300009A 		bls	.L432
 2440 13c4 850055E3 		cmp	r5, #133
 2441 13c8 BC00000A 		beq	.L280
 2442 13cc C700003A 		bcc	.L281
 2443 13d0 860055E3 		cmp	r5, #134
 2444 13d4 7500000A 		beq	.L282
 2445 13d8 870055E3 		cmp	r5, #135
 2446 13dc AE00001A 		bne	.L274
1180:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 2447              		.loc 1 1180 0
 2448 13e0 230054E3 		cmp	r4, #35
 2449 13e4 D100009A 		bls	.L353
1181:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2450              		.loc 1 1181 0
 2451 13e8 888088E0 		add	r8, r8, r8, asl #1
 2452              	.LVL277:
 2453 13ec 886186E0 		add	r6, r6, r8, asl #3
 2454 13f0 4C7F9FE5 		ldr	r7, .L440+56
 2455 13f4 7720D6E5 		ldrb	r2, [r6, #119]	@ zero_extendqisi2
1182:../uvc.c      **** 		 	 }
 2456              		.loc 1 1182 0
 2457 13f8 7830D6E5 		ldrb	r3, [r6, #120]	@ zero_extendqisi2
1181:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 2458              		.loc 1 1181 0
 2459 13fc 2820C7E5 		strb	r2, [r7, #40]
1182:../uvc.c      **** 		 	 }
 2460              		.loc 1 1182 0
 2461 1400 2930C7E5 		strb	r3, [r7, #41]
 2462              	.L354:
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2463              		.loc 1 1193 0
 2464 1404 0900A0E1 		mov	r0, r9
 2465              	.LVL278:
1195:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2466              		.loc 1 1195 0
 2467 1408 FF40A0E3 		mov	r4, #255
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2468              		.loc 1 1193 0
 2469 140c FC1E9FE5 		ldr	r1, .L440+4
 2470 1410 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2471              	.LVL279:
1195:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 2472              		.loc 1 1195 0
 2473 1414 0490A0E1 		mov	r9, r4
 2474 1418 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 2475 141c 0470A0E1 		mov	r7, r4
 2476              	.LVL280:
 2477              	.L284:
1654:../uvc.c      **** }
 2478              		.loc 1 1654 0
 2479 1420 00068DE8 		stmia	sp, {r9, r10}
 2480 1424 E81E9FE5 		ldr	r1, .L440+8
 2481 1428 08408DE5 		str	r4, [sp, #8]
 2482 142c 0520A0E1 		mov	r2, r5
 2483 1430 0730A0E1 		mov	r3, r7
 2484 1434 0400A0E3 		mov	r0, #4
 2485 1438 FEFFFFEB 		bl	CyU3PDebugPrint
 2486              	.LVL281:
1655:../uvc.c      **** /************** CT control requests handler *************************/
 2487              		.loc 1 1655 0
 2488 143c 2CD08DE2 		add	sp, sp, #44
 2489              		@ sp needed
 2490 1440 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2491              	.LVL282:
 2492              	.L272:
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 2493              		.loc 1 748 0
 2494 1444 802080E0 		add	r2, r0, r0, asl #1
 2495 1448 822186E0 		add	r2, r6, r2, asl #3
 2496 144c EC31D2E5 		ldrb	r3, [r2, #492]	@ zero_extendqisi2
 2497              	.LVL283:
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 2498              		.loc 1 749 0
 2499 1450 EDB1D2E5 		ldrb	fp, [r2, #493]	@ zero_extendqisi2
 2500              	.LVL284:
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 2501              		.loc 1 750 0
 2502 1454 FBA1D2E5 		ldrb	r10, [r2, #507]	@ zero_extendqisi2
 2503              	.LVL285:
 751:../uvc.c      ****     }
 2504              		.loc 1 751 0
 2505 1458 EE91D2E5 		ldrb	r9, [r2, #494]	@ zero_extendqisi2
 2506              	.LVL286:
 757:../uvc.c      ****     /*
 2507              		.loc 1 757 0
 2508 145c A82E9FE5 		ldr	r2, .L440
 2509              	.LVL287:
 2510 1460 0050D2E5 		ldrb	r5, [r2]	@ zero_extendqisi2
 2511              	.LVL288:
 765:../uvc.c      **** 		 {
 2512              		.loc 1 765 0
 2513 1464 830055E3 		cmp	r5, #131
 2514 1468 D4FFFF1A 		bne	.L433
 2515              	.LVL289:
 2516              	.L275:
1135:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 2517              		.loc 1 1135 0
 2518 146c 230054E3 		cmp	r4, #35
 2519 1470 C400009A 		bls	.L346
1136:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2520              		.loc 1 1136 0
 2521 1474 888088E0 		add	r8, r8, r8, asl #1
 2522              	.LVL290:
 2523 1478 886186E0 		add	r6, r6, r8, asl #3
 2524 147c C07E9FE5 		ldr	r7, .L440+56
 2525 1480 7120D6E5 		ldrb	r2, [r6, #113]	@ zero_extendqisi2
1137:../uvc.c      **** 		 	 }
 2526              		.loc 1 1137 0
 2527 1484 7230D6E5 		ldrb	r3, [r6, #114]	@ zero_extendqisi2
1136:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 2528              		.loc 1 1136 0
 2529 1488 2820C7E5 		strb	r2, [r7, #40]
1137:../uvc.c      **** 		 	 }
 2530              		.loc 1 1137 0
 2531 148c 2930C7E5 		strb	r3, [r7, #41]
 2532 1490 DBFFFFEA 		b	.L354
 2533              	.LVL291:
 2534              	.L432:
 765:../uvc.c      **** 		 {
 2535              		.loc 1 765 0
 2536 1494 810055E3 		cmp	r5, #129
 2537 1498 5500000A 		beq	.L277
 2538 149c 3900008A 		bhi	.L278
 2539 14a0 010055E3 		cmp	r5, #1
 2540 14a4 7C00001A 		bne	.L274
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 2541              		.loc 1 1197 0
 2542 14a8 947E9FE5 		ldr	r7, .L440+56
 2543 14ac 26208DE2 		add	r2, sp, #38
 2544 14b0 2000A0E3 		mov	r0, #32
 2545              	.LVL292:
 2546 14b4 281087E2 		add	r1, r7, #40
 2547 14b8 14308DE5 		str	r3, [sp, #20]
 2548 14bc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 2549              	.LVL293:
1199:../uvc.c      **** 			   {
 2550              		.loc 1 1199 0
 2551 14c0 14309DE5 		ldr	r3, [sp, #20]
 2552 14c4 002050E2 		subs	r2, r0, #0
 2553 14c8 4304001A 		bne	.L356
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2554              		.loc 1 1201 0
 2555 14cc 28C0D7E5 		ldrb	ip, [r7, #40]	@ zero_extendqisi2
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2556              		.loc 1 1204 0
 2557 14d0 2A00D7E5 		ldrb	r0, [r7, #42]	@ zero_extendqisi2
 2558              	.LVL294:
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 2559              		.loc 1 1201 0
 2560 14d4 18C08DE5 		str	ip, [sp, #24]
 2561              	.LVL295:
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2562              		.loc 1 1204 0
 2563 14d8 1C008DE5 		str	r0, [sp, #28]
1202:../uvc.c      **** 				  getData = glEp0Buffer[0];
 2564              		.loc 1 1202 0
 2565 14dc 29C0D7E5 		ldrb	ip, [r7, #41]	@ zero_extendqisi2
 2566              	.LVL296:
1208:../uvc.c      **** 					 {
 2567              		.loc 1 1208 0
 2568 14e0 260054E3 		cmp	r4, #38
 2569 14e4 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2570 14e8 1F0400EA 		b	.L357
 2571              	.L359:
 2572 14ec C0240000 		.word	.L358
 2573 14f0 54240000 		.word	.L360
 2574 14f4 401F0000 		.word	.L361
 2575 14f8 6C250000 		.word	.L357
 2576 14fc E01E0000 		.word	.L362
 2577 1500 981D0000 		.word	.L363
 2578 1504 101D0000 		.word	.L364
 2579 1508 0C210000 		.word	.L365
 2580 150c 6C250000 		.word	.L357
 2581 1510 6C250000 		.word	.L357
 2582 1514 6C250000 		.word	.L357
 2583 1518 80200000 		.word	.L366
 2584 151c 6C250000 		.word	.L357
 2585 1520 6C250000 		.word	.L357
 2586 1524 6C250000 		.word	.L357
 2587 1528 6C250000 		.word	.L357
 2588 152c A8210000 		.word	.L367
 2589 1530 6C250000 		.word	.L357
 2590 1534 6C250000 		.word	.L357
 2591 1538 6C250000 		.word	.L357
 2592 153c 6C250000 		.word	.L357
 2593 1540 6C250000 		.word	.L357
 2594 1544 6C250000 		.word	.L357
 2595 1548 6C250000 		.word	.L357
 2596 154c 6C250000 		.word	.L357
 2597 1550 A81F0000 		.word	.L368
 2598 1554 401F0000 		.word	.L361
 2599 1558 5C230000 		.word	.L369
 2600 155c 7C220000 		.word	.L370
 2601 1560 6C250000 		.word	.L357
 2602 1564 EC230000 		.word	.L371
 2603 1568 401B0000 		.word	.L372
 2604 156c 6C250000 		.word	.L357
 2605 1570 6C250000 		.word	.L357
 2606 1574 6C250000 		.word	.L357
 2607 1578 6C250000 		.word	.L357
 2608 157c 701C0000 		.word	.L373
 2609 1580 FC1B0000 		.word	.L374
 2610 1584 701B0000 		.word	.L375
 2611              	.LVL297:
 2612              	.L278:
1116:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 2613              		.loc 1 1116 0
 2614 1588 230054E3 		cmp	r4, #35
 2615 158c 7100009A 		bls	.L343
1117:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2616              		.loc 1 1117 0
 2617 1590 888088E0 		add	r8, r8, r8, asl #1
 2618              	.LVL298:
 2619 1594 886186E0 		add	r6, r6, r8, asl #3
 2620 1598 A47D9FE5 		ldr	r7, .L440+56
 2621 159c 6F20D6E5 		ldrb	r2, [r6, #111]	@ zero_extendqisi2
1118:../uvc.c      **** 		 	 }
 2622              		.loc 1 1118 0
 2623 15a0 7030D6E5 		ldrb	r3, [r6, #112]	@ zero_extendqisi2
1117:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 2624              		.loc 1 1117 0
 2625 15a4 2820C7E5 		strb	r2, [r7, #40]
1118:../uvc.c      **** 		 	 }
 2626              		.loc 1 1118 0
 2627 15a8 2930C7E5 		strb	r3, [r7, #41]
 2628 15ac 94FFFFEA 		b	.L354
 2629              	.LVL299:
 2630              	.L282:
1169:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 2631              		.loc 1 1169 0
 2632 15b0 230054E3 		cmp	r4, #35
1173:../uvc.c      **** 		 	 }
 2633              		.loc 1 1173 0
 2634 15b4 84408490 		addls	r4, r4, r4, asl #1
1170:../uvc.c      **** 		 	 }
 2635              		.loc 1 1170 0
 2636 15b8 88808880 		addhi	r8, r8, r8, asl #1
 2637              	.LVL300:
1173:../uvc.c      **** 		 	 }
 2638              		.loc 1 1173 0
 2639 15bc 84618690 		addls	r6, r6, r4, asl #3
1170:../uvc.c      **** 		 	 }
 2640              		.loc 1 1170 0
 2641 15c0 88618680 		addhi	r6, r6, r8, asl #3
 2642 15c4 7530D685 		ldrhib	r3, [r6, #117]	@ zero_extendqisi2
1173:../uvc.c      **** 		 	 }
 2643              		.loc 1 1173 0
 2644 15c8 F531D695 		ldrlsb	r3, [r6, #501]	@ zero_extendqisi2
 2645 15cc 706D9FE5 		ldr	r6, .L440+56
1178:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 2646              		.loc 1 1178 0
 2647 15d0 FF40A0E3 		mov	r4, #255
 2648 15d4 0610A0E1 		mov	r1, r6
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2649              		.loc 1 1175 0
 2650 15d8 0100A0E3 		mov	r0, #1
 2651              	.LVL301:
 2652 15dc 2830E1E5 		strb	r3, [r1, #40]!
 2653 15e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2654              	.LVL302:
1178:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 2655              		.loc 1 1178 0
 2656 15e4 0490A0E1 		mov	r9, r4
 2657 15e8 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 2658 15ec 0470A0E1 		mov	r7, r4
 2659 15f0 8AFFFFEA 		b	.L284
 2660              	.LVL303:
 2661              	.L277:
 776:../uvc.c      **** 			 {
 2662              		.loc 1 776 0
 2663 15f4 260054E3 		cmp	r4, #38
 2664 15f8 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 2665 15fc CE0300EA 		b	.L285
 2666              	.L287:
 2667 1600 2C1A0000 		.word	.L286
 2668 1604 40190000 		.word	.L288
 2669 1608 D8190000 		.word	.L289
 2670 160c 3C250000 		.word	.L285
 2671 1610 E0180000 		.word	.L290
 2672 1614 201B0000 		.word	.L291
 2673 1618 3C250000 		.word	.L285
 2674 161c 001A0000 		.word	.L292
 2675 1620 3C250000 		.word	.L285
 2676 1624 9C1A0000 		.word	.L293
 2677 1628 3C250000 		.word	.L285
 2678 162c 10190000 		.word	.L294
 2679 1630 3C250000 		.word	.L285
 2680 1634 3C250000 		.word	.L285
 2681 1638 3C250000 		.word	.L285
 2682 163c 3C250000 		.word	.L285
 2683 1640 C41A0000 		.word	.L295
 2684 1644 3C250000 		.word	.L285
 2685 1648 3C250000 		.word	.L285
 2686 164c 3C250000 		.word	.L285
 2687 1650 3C250000 		.word	.L285
 2688 1654 3C250000 		.word	.L285
 2689 1658 3C250000 		.word	.L285
 2690 165c 3C250000 		.word	.L285
 2691 1660 3C250000 		.word	.L285
 2692 1664 68190000 		.word	.L296
 2693 1668 D8190000 		.word	.L289
 2694 166c 581A0000 		.word	.L297
 2695 1670 B4180000 		.word	.L298
 2696 1674 3C250000 		.word	.L285
 2697 1678 3C250000 		.word	.L285
 2698 167c DC170000 		.word	.L299
 2699 1680 3C250000 		.word	.L285
 2700 1684 3C250000 		.word	.L285
 2701 1688 3C250000 		.word	.L285
 2702 168c 3C250000 		.word	.L285
 2703 1690 38180000 		.word	.L300
 2704 1694 88180000 		.word	.L301
 2705 1698 64180000 		.word	.L302
 2706              	.L274:
1651:../uvc.c      **** 			  break;
 2707              		.loc 1 1651 0
 2708 169c 0000A0E3 		mov	r0, #0
 2709              	.LVL304:
1652:../uvc.c      **** 		 }
 2710              		.loc 1 1652 0
 2711 16a0 FF40A0E3 		mov	r4, #255
1651:../uvc.c      **** 			  break;
 2712              		.loc 1 1651 0
 2713 16a4 0020A0E1 		mov	r2, r0
 2714 16a8 0110A0E3 		mov	r1, #1
 2715 16ac FEFFFFEB 		bl	CyU3PUsbStall
 2716              	.LVL305:
1652:../uvc.c      **** 		 }
 2717              		.loc 1 1652 0
 2718 16b0 04A0A0E1 		mov	r10, r4
 2719 16b4 0490A0E1 		mov	r9, r4
 2720 16b8 0470A0E1 		mov	r7, r4
 2721 16bc 57FFFFEA 		b	.L284
 2722              	.LVL306:
 2723              	.L280:
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2724              		.loc 1 769 0
 2725 16c0 7C6C9FE5 		ldr	r6, .L440+56
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2726              		.loc 1 770 0
 2727 16c4 0030A0E3 		mov	r3, #0
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2728              		.loc 1 773 0
 2729 16c8 FF40A0E3 		mov	r4, #255
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2730              		.loc 1 771 0
 2731 16cc 281086E2 		add	r1, r6, #40
 2732 16d0 0200A0E3 		mov	r0, #2
 2733              	.LVL307:
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 2734              		.loc 1 769 0
 2735 16d4 2890C6E5 		strb	r9, [r6, #40]
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 2736              		.loc 1 770 0
 2737 16d8 2930C6E5 		strb	r3, [r6, #41]
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2738              		.loc 1 773 0
 2739 16dc 0490A0E1 		mov	r9, r4
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 2740              		.loc 1 771 0
 2741 16e0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2742              	.LVL308:
 773:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 2743              		.loc 1 773 0
 2744 16e4 0470A0E1 		mov	r7, r4
 2745 16e8 28A0D6E5 		ldrb	r10, [r6, #40]	@ zero_extendqisi2
 2746 16ec 4BFFFFEA 		b	.L284
 2747              	.LVL309:
 2748              	.L281:
1153:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 2749              		.loc 1 1153 0
 2750 16f0 230054E3 		cmp	r4, #35
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2751              		.loc 1 1154 0
 2752 16f4 88808880 		addhi	r8, r8, r8, asl #1
 2753              	.LVL310:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2754              		.loc 1 1160 0
 2755 16f8 84408490 		addls	r4, r4, r4, asl #1
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2756              		.loc 1 1154 0
 2757 16fc 88618680 		addhi	r6, r6, r8, asl #3
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2758              		.loc 1 1160 0
 2759 1700 84618690 		addls	r6, r6, r4, asl #3
 2760 1704 387C9FE5 		ldr	r7, .L440+56
1154:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 2761              		.loc 1 1154 0
 2762 1708 7310D685 		ldrhib	r1, [r6, #115]	@ zero_extendqisi2
1155:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 2763              		.loc 1 1155 0
 2764 170c 7420D685 		ldrhib	r2, [r6, #116]	@ zero_extendqisi2
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2765              		.loc 1 1160 0
 2766 1710 F311D695 		ldrlsb	r1, [r6, #499]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2767              		.loc 1 1161 0
 2768 1714 F421D695 		ldrlsb	r2, [r6, #500]	@ zero_extendqisi2
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2769              		.loc 1 1162 0
 2770 1718 0030A0E3 		mov	r3, #0
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 2771              		.loc 1 1160 0
 2772 171c 2810C7E5 		strb	r1, [r7, #40]
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 2773              		.loc 1 1161 0
 2774 1720 2920C7E5 		strb	r2, [r7, #41]
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 2775              		.loc 1 1162 0
 2776 1724 2A30C7E5 		strb	r3, [r7, #42]
1163:../uvc.c      **** 		 	 }
 2777              		.loc 1 1163 0
 2778 1728 2B30C7E5 		strb	r3, [r7, #43]
 2779 172c 34FFFFEA 		b	.L354
 2780              	.LVL311:
 2781              	.L353:
1184:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 2782              		.loc 1 1184 0
 2783 1730 0B0054E3 		cmp	r4, #11
 2784 1734 1F00000A 		beq	.L434
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2785              		.loc 1 1190 0
 2786 1738 844084E0 		add	r4, r4, r4, asl #1
 2787 173c 846186E0 		add	r6, r6, r4, asl #3
 2788 1740 FC7B9FE5 		ldr	r7, .L440+56
 2789 1744 F721D6E5 		ldrb	r2, [r6, #503]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 2790              		.loc 1 1191 0
 2791 1748 F831D6E5 		ldrb	r3, [r6, #504]	@ zero_extendqisi2
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 2792              		.loc 1 1190 0
 2793 174c 2820C7E5 		strb	r2, [r7, #40]
1191:../uvc.c      **** 			 }
 2794              		.loc 1 1191 0
 2795 1750 2930C7E5 		strb	r3, [r7, #41]
 2796 1754 2AFFFFEA 		b	.L354
 2797              	.L343:
1121:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 2798              		.loc 1 1121 0
 2799 1758 0B0054E3 		cmp	r4, #11
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2800              		.loc 1 1128 0
 2801 175c 84408410 		addne	r4, r4, r4, asl #1
 2802 1760 84618610 		addne	r6, r6, r4, asl #3
 2803 1764 D87B9F15 		ldrne	r7, .L440+56
1122:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2804              		.loc 1 1122 0
 2805 1768 D47B9F05 		ldreq	r7, .L440+56
 2806 176c A43B9F05 		ldreq	r3, .L440+12
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2807              		.loc 1 1128 0
 2808 1770 EF21D615 		ldrneb	r2, [r6, #495]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 2809              		.loc 1 1129 0
 2810 1774 F031D615 		ldrneb	r3, [r6, #496]	@ zero_extendqisi2
1122:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2811              		.loc 1 1122 0
 2812 1778 28308705 		streq	r3, [r7, #40]
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 2813              		.loc 1 1128 0
 2814 177c 2820C715 		strneb	r2, [r7, #40]
1129:../uvc.c      **** 			 }
 2815              		.loc 1 1129 0
 2816 1780 2930C715 		strneb	r3, [r7, #41]
 2817 1784 1EFFFFEA 		b	.L354
 2818              	.L346:
1139:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 2819              		.loc 1 1139 0
 2820 1788 0B0054E3 		cmp	r4, #11
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2821              		.loc 1 1146 0
 2822 178c 84408410 		addne	r4, r4, r4, asl #1
 2823 1790 84618610 		addne	r6, r6, r4, asl #3
 2824 1794 A87B9F15 		ldrne	r7, .L440+56
1140:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2825              		.loc 1 1140 0
 2826 1798 A47B9F05 		ldreq	r7, .L440+56
 2827 179c 783B9F05 		ldreq	r3, .L440+16
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2828              		.loc 1 1146 0
 2829 17a0 F121D615 		ldrneb	r2, [r6, #497]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 2830              		.loc 1 1147 0
 2831 17a4 F231D615 		ldrneb	r3, [r6, #498]	@ zero_extendqisi2
1140:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 2832              		.loc 1 1140 0
 2833 17a8 28308705 		streq	r3, [r7, #40]
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 2834              		.loc 1 1146 0
 2835 17ac 2820C715 		strneb	r2, [r7, #40]
1147:../uvc.c      **** 			 }
 2836              		.loc 1 1147 0
 2837 17b0 2930C715 		strneb	r3, [r7, #41]
 2838 17b4 12FFFFEA 		b	.L354
 2839              	.L434:
1185:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2840              		.loc 1 1185 0
 2841 17b8 847B9FE5 		ldr	r7, .L440+56
 2842 17bc FF12D6E5 		ldrb	r1, [r6, #767]	@ zero_extendqisi2
1187:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2843              		.loc 1 1187 0
 2844 17c0 0023D6E5 		ldrb	r2, [r6, #768]	@ zero_extendqisi2
1186:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2845              		.loc 1 1186 0
 2846 17c4 0030A0E3 		mov	r3, #0
1185:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 2847              		.loc 1 1185 0
 2848 17c8 2810C7E5 		strb	r1, [r7, #40]
1187:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 2849              		.loc 1 1187 0
 2850 17cc 2A20C7E5 		strb	r2, [r7, #42]
1186:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 2851              		.loc 1 1186 0
 2852 17d0 2930C7E5 		strb	r3, [r7, #41]
1188:../uvc.c      **** 			 }else{
 2853              		.loc 1 1188 0
 2854 17d4 2B30C7E5 		strb	r3, [r7, #43]
 2855 17d8 09FFFFEA 		b	.L354
 2856              	.L299:
 2857              	.LVL312:
 891:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 2858              		.loc 1 891 0 discriminator 1
 2859 17dc 000059E3 		cmp	r9, #0
 2860 17e0 0300000A 		beq	.L319
 2861 17e4 240B9FE5 		ldr	r0, .L440+4
 2862              	.LVL313:
 2863 17e8 0920A0E1 		mov	r2, r9
 2864 17ec 6C1080E2 		add	r1, r0, #108
 2865 17f0 FEFFFFEB 		bl	memcpy
 2866              	.LVL314:
 2867              	.L319:
 894:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2868              		.loc 1 894 0
 2869 17f4 483B9FE5 		ldr	r3, .L440+56
 901:../uvc.c      **** 			 		 {
 2870              		.loc 1 901 0
 2871 17f8 9F20D3E5 		ldrb	r2, [r3, #159]	@ zero_extendqisi2
 894:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 2872              		.loc 1 894 0
 2873 17fc 31A0D3E5 		ldrb	r10, [r3, #49]	@ zero_extendqisi2
 2874              	.LVL315:
 901:../uvc.c      **** 			 		 {
 2875              		.loc 1 901 0
 2876 1800 FF0052E3 		cmp	r2, #255
 895:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 2877              		.loc 1 895 0
 2878 1804 3240D3E5 		ldrb	r4, [r3, #50]	@ zero_extendqisi2
 2879              	.LVL316:
 901:../uvc.c      **** 			 		 {
 2880              		.loc 1 901 0
 2881 1808 0400000A 		beq	.L308
 903:../uvc.c      **** 			 		 }
 2882              		.loc 1 903 0
 2883 180c 9D20D3E5 		ldrb	r2, [r3, #157]	@ zero_extendqisi2
 2884 1810 0400A0E3 		mov	r0, #4
 2885 1814 041B9FE5 		ldr	r1, .L440+20
 2886 1818 9E30D3E5 		ldrb	r3, [r3, #158]	@ zero_extendqisi2
 2887 181c FEFFFFEB 		bl	CyU3PDebugPrint
 2888              	.LVL317:
 2889              	.L308:
1109:../uvc.c      **** 
 2890              		.loc 1 1109 0
 2891 1820 0900A0E1 		mov	r0, r9
 2892 1824 E41A9FE5 		ldr	r1, .L440+4
 2893 1828 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2894              	.LVL318:
1114:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 2895              		.loc 1 1114 0
 2896 182c FF90A0E3 		mov	r9, #255
 2897 1830 0970A0E1 		mov	r7, r9
 2898 1834 F9FEFFEA 		b	.L284
 2899              	.LVL319:
 2900              	.L300:
 780:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2901              		.loc 1 780 0
 2902 1838 047B9FE5 		ldr	r7, .L440+56
 2903 183c C420D7E5 		ldrb	r2, [r7, #196]	@ zero_extendqisi2
 2904 1840 000052E3 		cmp	r2, #0
 2905 1844 7203000A 		beq	.L306
 781:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2906              		.loc 1 781 0
 2907 1848 05A5D6E5 		ldrb	r10, [r6, #1285]	@ zero_extendqisi2
 782:../uvc.c      **** 			 	 		 }else{
 2908              		.loc 1 782 0
 2909 184c 0645D6E5 		ldrb	r4, [r6, #1286]	@ zero_extendqisi2
 781:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2910              		.loc 1 781 0
 2911 1850 FFA00AE2 		and	r10, r10, #255
 782:../uvc.c      **** 			 	 		 }else{
 2912              		.loc 1 782 0
 2913 1854 FF4004E2 		and	r4, r4, #255
 781:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2914              		.loc 1 781 0
 2915 1858 28A0C7E5 		strb	r10, [r7, #40]
 782:../uvc.c      **** 			 	 		 }else{
 2916              		.loc 1 782 0
 2917 185c 2940C7E5 		strb	r4, [r7, #41]
 2918 1860 EEFFFFEA 		b	.L308
 2919              	.L302:
 813:../uvc.c      **** 							 glEp0Buffer[0] = ExUCtrlParArry[CtrlID-0x20][13];//ext_control array;
 2920              		.loc 1 813 0
 2921 1864 D87A9FE5 		ldr	r7, .L440+56
 2922 1868 C620D7E5 		ldrb	r2, [r7, #198]	@ zero_extendqisi2
 2923 186c 000052E3 		cmp	r2, #0
 2924 1870 7803000A 		beq	.L311
 814:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2925              		.loc 1 814 0
 2926 1874 09A1D6E5 		ldrb	r10, [r6, #265]	@ zero_extendqisi2
 815:../uvc.c      **** 			 	 		 }else{
 2927              		.loc 1 815 0
 2928 1878 0A41D6E5 		ldrb	r4, [r6, #266]	@ zero_extendqisi2
 814:../uvc.c      **** 							 glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 2929              		.loc 1 814 0
 2930 187c 28A0C7E5 		strb	r10, [r7, #40]
 815:../uvc.c      **** 			 	 		 }else{
 2931              		.loc 1 815 0
 2932 1880 2940C7E5 		strb	r4, [r7, #41]
 2933 1884 E5FFFFEA 		b	.L308
 2934              	.L301:
 795:../uvc.c      **** 							 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 2935              		.loc 1 795 0
 2936 1888 B47A9FE5 		ldr	r7, .L440+56
 2937 188c C520D7E5 		ldrb	r2, [r7, #197]	@ zero_extendqisi2
 2938 1890 000052E3 		cmp	r2, #0
 2939 1894 EC03000A 		beq	.L309
 796:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2940              		.loc 1 796 0
 2941 1898 19A5D6E5 		ldrb	r10, [r6, #1305]	@ zero_extendqisi2
 797:../uvc.c      **** 			 	 		 }else{
 2942              		.loc 1 797 0
 2943 189c 1A45D6E5 		ldrb	r4, [r6, #1306]	@ zero_extendqisi2
 796:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2944              		.loc 1 796 0
 2945 18a0 FFA00AE2 		and	r10, r10, #255
 797:../uvc.c      **** 			 	 		 }else{
 2946              		.loc 1 797 0
 2947 18a4 FF4004E2 		and	r4, r4, #255
 796:../uvc.c      **** 							 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 2948              		.loc 1 796 0
 2949 18a8 28A0C7E5 		strb	r10, [r7, #40]
 797:../uvc.c      **** 			 	 		 }else{
 2950              		.loc 1 797 0
 2951 18ac 2940C7E5 		strb	r4, [r7, #41]
 2952 18b0 DAFFFFEA 		b	.L308
 2953              	.L298:
 878:../uvc.c      **** 						if(sendData >= 3){
 2954              		.loc 1 878 0
 2955 18b4 887A9FE5 		ldr	r7, .L440+56
 876:../uvc.c      **** 
 2956              		.loc 1 876 0
 2957 18b8 99A4D6E5 		ldrb	r10, [r6, #1177]	@ zero_extendqisi2
 2958              	.LVL320:
 878:../uvc.c      **** 						if(sendData >= 3){
 2959              		.loc 1 878 0
 2960 18bc E020D7E5 		ldrb	r2, [r7, #224]	@ zero_extendqisi2
 876:../uvc.c      **** 
 2961              		.loc 1 876 0
 2962 18c0 744A9FE5 		ldr	r4, .L440+48
 878:../uvc.c      **** 						if(sendData >= 3){
 2963              		.loc 1 878 0
 2964 18c4 010052E3 		cmp	r2, #1
 2965 18c8 7704000A 		beq	.L435
 2966              	.LVL321:
 2967              	.L428:
 978:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2968              		.loc 1 978 0
 2969 18cc 0030A0E3 		mov	r3, #0
 977:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2970              		.loc 1 977 0
 2971 18d0 28A0C7E5 		strb	r10, [r7, #40]
 978:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 2972              		.loc 1 978 0
 2973 18d4 2930C7E5 		strb	r3, [r7, #41]
 2974              	.LVL322:
 980:../uvc.c      **** 				 case WBTLevCtlID11:
 2975              		.loc 1 980 0
 2976 18d8 FF40A0E3 		mov	r4, #255
 2977 18dc CFFFFFEA 		b	.L308
 2978              	.LVL323:
 2979              	.L290:
1068:../uvc.c      **** 
 2980              		.loc 1 1068 0
 2981 18e0 5C7A9FE5 		ldr	r7, .L440+56
 2982 18e4 A430D7E5 		ldrb	r3, [r7, #164]	@ zero_extendqisi2
 2983 18e8 000053E3 		cmp	r3, #0
 2984 18ec 0504000A 		beq	.L338
1070:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2985              		.loc 1 1070 0
 2986 18f0 6C3097E5 		ldr	r3, [r7, #108]
1076:../uvc.c      **** 		 	 		 }else{
 2987              		.loc 1 1076 0
 2988 18f4 5A42D6E5 		ldrb	r4, [r6, #602]	@ zero_extendqisi2
1070:../uvc.c      **** 		 	 				 glEp0Buffer[0] = 2;//CtrlParArry[CtrlID][13];//ext_control array;
 2989              		.loc 1 1070 0
 2990 18f8 000053E3 		cmp	r3, #0
 2991 18fc 02A0A013 		movne	r10, #2
 2992 1900 01A0A003 		moveq	r10, #1
 2993 1904 28A0C7E5 		strb	r10, [r7, #40]
1076:../uvc.c      **** 		 	 		 }else{
 2994              		.loc 1 1076 0
 2995 1908 2940C7E5 		strb	r4, [r7, #41]
 2996 190c C3FFFFEA 		b	.L308
 2997              	.L294:
 986:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2998              		.loc 1 986 0
 2999 1910 2C7A9FE5 		ldr	r7, .L440+56
 3000 1914 AB20D7E5 		ldrb	r2, [r7, #171]	@ zero_extendqisi2
 3001 1918 000052E3 		cmp	r2, #0
 3002 191c 3E04000A 		beq	.L328
 987:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3003              		.loc 1 987 0
 3004 1920 5CA5D6E5 		ldrb	r10, [r6, #1372]	@ zero_extendqisi2
 988:../uvc.c      **** 		 	 		 }else{
 3005              		.loc 1 988 0
 3006 1924 5E45D6E5 		ldrb	r4, [r6, #1374]	@ zero_extendqisi2
 987:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 3007              		.loc 1 987 0
 3008 1928 28A0C7E5 		strb	r10, [r7, #40]
 988:../uvc.c      **** 		 	 		 }else{
 3009              		.loc 1 988 0
 3010 192c 2A40C7E5 		strb	r4, [r7, #42]
 3011              	.LVL324:
 3012              	.L329:
 998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3013              		.loc 1 998 0
 3014 1930 0030A0E3 		mov	r3, #0
 3015 1934 2930C7E5 		strb	r3, [r7, #41]
 999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3016              		.loc 1 999 0
 3017 1938 2B30C7E5 		strb	r3, [r7, #43]
 3018              	.LVL325:
1002:../uvc.c      **** 				 case BLCCtlID0:
 3019              		.loc 1 1002 0
 3020 193c B7FFFFEA 		b	.L308
 3021              	.LVL326:
 3022              	.L288:
 951:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3023              		.loc 1 951 0
 3024 1940 FC799FE5 		ldr	r7, .L440+56
 3025 1944 A120D7E5 		ldrb	r2, [r7, #161]	@ zero_extendqisi2
 3026 1948 000052E3 		cmp	r2, #0
 3027 194c D903000A 		beq	.L322
 952:../uvc.c      **** 		 	 		 }else{
 3028              		.loc 1 952 0
 3029 1950 1102D6E5 		ldrb	r0, [r6, #529]	@ zero_extendqisi2
 3030              	.LVL327:
 3031              	.L323:
 959:../uvc.c      **** 						  Data0 = ~Data0;
 3032              		.loc 1 959 0
 3033 1954 800010E3 		tst	r0, #128
 960:../uvc.c      **** 					  }else{
 3034              		.loc 1 960 0
 3035 1958 0000E011 		mvnne	r0, r0
 3036              	.LVL328:
 962:../uvc.c      **** 					  }
 3037              		.loc 1 962 0
 3038 195c 80004002 		subeq	r0, r0, #128
 3039 1960 FFA000E2 		and	r10, r0, #255
 3040              	.LVL329:
 3041 1964 D8FFFFEA 		b	.L428
 3042              	.LVL330:
 3043              	.L296:
 913:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3044              		.loc 1 913 0
 3045 1968 D4799FE5 		ldr	r7, .L440+56
 907:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3046              		.loc 1 907 0
 3047 196c 4815D6E5 		ldrb	r1, [r6, #1352]	@ zero_extendqisi2
 913:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3048              		.loc 1 913 0
 3049 1970 B900D7E5 		ldrb	r0, [r7, #185]	@ zero_extendqisi2
 3050              	.LVL331:
 908:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3051              		.loc 1 908 0
 3052 1974 4925D6E5 		ldrb	r2, [r6, #1353]	@ zero_extendqisi2
 909:../uvc.c      **** 
 3053              		.loc 1 909 0
 3054 1978 5735D6E5 		ldrb	r3, [r6, #1367]	@ zero_extendqisi2
 913:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3055              		.loc 1 913 0
 3056 197c 000050E3 		cmp	r0, #0
 908:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3057              		.loc 1 908 0
 3058 1980 FF8002E2 		and	r8, r2, #255
 3059              	.LVL332:
 907:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3060              		.loc 1 907 0
 3061 1984 FF0001E2 		and	r0, r1, #255
 3062              	.LVL333:
 909:../uvc.c      **** 
 3063              		.loc 1 909 0
 3064 1988 FF4003E2 		and	r4, r3, #255
 3065              	.LVL334:
 907:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3066              		.loc 1 907 0
 3067 198c A8699FE5 		ldr	r6, .L440+48
 913:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3068              		.loc 1 913 0
 3069 1990 1204000A 		beq	.L320
 914:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3070              		.loc 1 914 0
 3071 1994 55A5D6E5 		ldrb	r10, [r6, #1365]	@ zero_extendqisi2
 915:../uvc.c      **** 		 	 		 }else{
 3072              		.loc 1 915 0
 3073 1998 5645D6E5 		ldrb	r4, [r6, #1366]	@ zero_extendqisi2
 3074              	.LVL335:
 914:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3075              		.loc 1 914 0
 3076 199c FFA00AE2 		and	r10, r10, #255
 915:../uvc.c      **** 		 	 		 }else{
 3077              		.loc 1 915 0
 3078 19a0 FF4004E2 		and	r4, r4, #255
 914:../uvc.c      **** 						 glEp0Buffer[2] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3079              		.loc 1 914 0
 3080 19a4 28A0C7E5 		strb	r10, [r7, #40]
 915:../uvc.c      **** 		 	 		 }else{
 3081              		.loc 1 915 0
 3082 19a8 2A40C7E5 		strb	r4, [r7, #42]
 3083              	.LVL336:
 3084              	.L321:
 929:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3085              		.loc 1 929 0
 3086 19ac 00C0A0E3 		mov	ip, #0
 934:../uvc.c      **** 					 break;
 3087              		.loc 1 934 0
 3088 19b0 00408DE5 		str	r4, [sp]
 3089 19b4 04C08DE5 		str	ip, [sp, #4]
 3090 19b8 0A20A0E1 		mov	r2, r10
 3091 19bc 0C30A0E1 		mov	r3, ip
 3092 19c0 5C199FE5 		ldr	r1, .L440+24
 929:../uvc.c      **** 					 //glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 3093              		.loc 1 929 0
 3094 19c4 29C0C7E5 		strb	ip, [r7, #41]
 931:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 3095              		.loc 1 931 0
 3096 19c8 2BC0C7E5 		strb	ip, [r7, #43]
 3097              	.LVL337:
 934:../uvc.c      **** 					 break;
 3098              		.loc 1 934 0
 3099 19cc 0400A0E3 		mov	r0, #4
 3100 19d0 FEFFFFEB 		bl	CyU3PDebugPrint
 3101              	.LVL338:
 935:../uvc.c      **** 
 3102              		.loc 1 935 0
 3103 19d4 91FFFFEA 		b	.L308
 3104              	.LVL339:
 3105              	.L289:
1038:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[ConsCtlID2][13];//ext_control array;
 3106              		.loc 1 1038 0
 3107 19d8 64799FE5 		ldr	r7, .L440+56
 3108 19dc 048087E0 		add	r8, r7, r4
 3109              	.LVL340:
 3110 19e0 A020D8E5 		ldrb	r2, [r8, #160]	@ zero_extendqisi2
 3111 19e4 000052E3 		cmp	r2, #0
 3112 19e8 E003000A 		beq	.L334
1039:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3113              		.loc 1 1039 0
 3114 19ec 29A2D6E5 		ldrb	r10, [r6, #553]	@ zero_extendqisi2
1040:../uvc.c      **** 		 	 		 }else{
 3115              		.loc 1 1040 0
 3116 19f0 2A42D6E5 		ldrb	r4, [r6, #554]	@ zero_extendqisi2
1039:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 3117              		.loc 1 1039 0
 3118 19f4 28A0C7E5 		strb	r10, [r7, #40]
1040:../uvc.c      **** 		 	 		 }else{
 3119              		.loc 1 1040 0
 3120 19f8 2940C7E5 		strb	r4, [r7, #41]
 3121 19fc 87FFFFEA 		b	.L308
 3122              	.LVL341:
 3123              	.L292:
1021:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3124              		.loc 1 1021 0
 3125 1a00 3C799FE5 		ldr	r7, .L440+56
 3126 1a04 A730D7E5 		ldrb	r3, [r7, #167]	@ zero_extendqisi2
 3127 1a08 000053E3 		cmp	r3, #0
 3128 1a0c 1204000A 		beq	.L332
1022:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3129              		.loc 1 1022 0
 3130 1a10 81A5D6E5 		ldrb	r10, [r6, #1409]	@ zero_extendqisi2
1023:../uvc.c      **** 		 	 		 }else{
 3131              		.loc 1 1023 0
 3132 1a14 8245D6E5 		ldrb	r4, [r6, #1410]	@ zero_extendqisi2
1022:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3133              		.loc 1 1022 0
 3134 1a18 FFA00AE2 		and	r10, r10, #255
1023:../uvc.c      **** 		 	 		 }else{
 3135              		.loc 1 1023 0
 3136 1a1c FF4004E2 		and	r4, r4, #255
1022:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3137              		.loc 1 1022 0
 3138 1a20 28A0C7E5 		strb	r10, [r7, #40]
1023:../uvc.c      **** 		 	 		 }else{
 3139              		.loc 1 1023 0
 3140 1a24 2940C7E5 		strb	r4, [r7, #41]
 3141 1a28 7CFFFFEA 		b	.L308
 3142              	.L286:
1004:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 3143              		.loc 1 1004 0
 3144 1a2c 10799FE5 		ldr	r7, .L440+56
 3145 1a30 A020D7E5 		ldrb	r2, [r7, #160]	@ zero_extendqisi2
 3146 1a34 000052E3 		cmp	r2, #0
 3147 1a38 9003000A 		beq	.L330
1005:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3148              		.loc 1 1005 0
 3149 1a3c 6DA5D6E5 		ldrb	r10, [r6, #1389]	@ zero_extendqisi2
1006:../uvc.c      **** 		 	 		 }else{
 3150              		.loc 1 1006 0
 3151 1a40 6E45D6E5 		ldrb	r4, [r6, #1390]	@ zero_extendqisi2
1005:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3152              		.loc 1 1005 0
 3153 1a44 FFA00AE2 		and	r10, r10, #255
1006:../uvc.c      **** 		 	 		 }else{
 3154              		.loc 1 1006 0
 3155 1a48 FF4004E2 		and	r4, r4, #255
1005:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 3156              		.loc 1 1005 0
 3157 1a4c 28A0C7E5 		strb	r10, [r7, #40]
1006:../uvc.c      **** 		 	 		 }else{
 3158              		.loc 1 1006 0
 3159 1a50 2940C7E5 		strb	r4, [r7, #41]
 3160 1a54 71FFFFEA 		b	.L308
 3161              	.L297:
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3162              		.loc 1 863 0
 3163 1a58 E4789FE5 		ldr	r7, .L440+56
 856:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3164              		.loc 1 856 0
 3165 1a5c 3435D6E5 		ldrb	r3, [r6, #1332]	@ zero_extendqisi2
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3166              		.loc 1 863 0
 3167 1a60 BB10D7E5 		ldrb	r1, [r7, #187]	@ zero_extendqisi2
 857:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3168              		.loc 1 857 0
 3169 1a64 3525D6E5 		ldrb	r2, [r6, #1333]	@ zero_extendqisi2
 858:../uvc.c      **** 
 3170              		.loc 1 858 0
 3171 1a68 4335D6E5 		ldrb	r3, [r6, #1347]	@ zero_extendqisi2
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3172              		.loc 1 863 0
 3173 1a6c 000051E3 		cmp	r1, #0
 857:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3174              		.loc 1 857 0
 3175 1a70 FF0002E2 		and	r0, r2, #255
 3176              	.LVL342:
 858:../uvc.c      **** 
 3177              		.loc 1 858 0
 3178 1a74 FF1003E2 		and	r1, r3, #255
 3179              	.LVL343:
 856:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3180              		.loc 1 856 0
 3181 1a78 BC489FE5 		ldr	r4, .L440+48
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3182              		.loc 1 863 0
 3183 1a7c B003000A 		beq	.L315
 864:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3184              		.loc 1 864 0
 3185 1a80 41A5D4E5 		ldrb	r10, [r4, #1345]	@ zero_extendqisi2
 865:../uvc.c      **** 		 	 		 }else{
 3186              		.loc 1 865 0
 3187 1a84 4245D4E5 		ldrb	r4, [r4, #1346]	@ zero_extendqisi2
 864:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3188              		.loc 1 864 0
 3189 1a88 FFA00AE2 		and	r10, r10, #255
 865:../uvc.c      **** 		 	 		 }else{
 3190              		.loc 1 865 0
 3191 1a8c FF4004E2 		and	r4, r4, #255
 864:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3192              		.loc 1 864 0
 3193 1a90 28A0C7E5 		strb	r10, [r7, #40]
 865:../uvc.c      **** 		 	 		 }else{
 3194              		.loc 1 865 0
 3195 1a94 2940C7E5 		strb	r4, [r7, #41]
 3196 1a98 60FFFFEA 		b	.L308
 3197              	.LVL344:
 3198              	.L293:
1051:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 3199              		.loc 1 1051 0
 3200 1a9c A0789FE5 		ldr	r7, .L440+56
 3201 1aa0 A920D7E5 		ldrb	r2, [r7, #169]	@ zero_extendqisi2
 3202 1aa4 000052E3 		cmp	r2, #0
 3203 1aa8 8903000A 		beq	.L336
1053:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3204              		.loc 1 1053 0
 3205 1aac D1A2D6E5 		ldrb	r10, [r6, #721]	@ zero_extendqisi2
1054:../uvc.c      **** 		 	 		 }else{
 3206              		.loc 1 1054 0
 3207 1ab0 D242D6E5 		ldrb	r4, [r6, #722]	@ zero_extendqisi2
1053:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 3208              		.loc 1 1053 0
 3209 1ab4 03A00AE2 		and	r10, r10, #3
 3210 1ab8 28A0C7E5 		strb	r10, [r7, #40]
1054:../uvc.c      **** 		 	 		 }else{
 3211              		.loc 1 1054 0
 3212 1abc 2940C7E5 		strb	r4, [r7, #41]
 3213 1ac0 56FFFFEA 		b	.L308
 3214              	.L295:
 838:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3215              		.loc 1 838 0
 3216 1ac4 78489FE5 		ldr	r4, .L440+56
 831:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3217              		.loc 1 831 0
 3218 1ac8 2025D6E5 		ldrb	r2, [r6, #1312]	@ zero_extendqisi2
 838:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3219              		.loc 1 838 0
 3220 1acc B010D4E5 		ldrb	r1, [r4, #176]	@ zero_extendqisi2
 832:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 3221              		.loc 1 832 0
 3222 1ad0 2135D6E5 		ldrb	r3, [r6, #1313]	@ zero_extendqisi2
 833:../uvc.c      **** 
 3223              		.loc 1 833 0
 3224 1ad4 2F35D6E5 		ldrb	r3, [r6, #1327]	@ zero_extendqisi2
 838:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3225              		.loc 1 838 0
 3226 1ad8 000051E3 		cmp	r1, #0
 831:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3227              		.loc 1 831 0
 3228 1adc FF0002E2 		and	r0, r2, #255
 3229              	.LVL345:
 833:../uvc.c      **** 
 3230              		.loc 1 833 0
 3231 1ae0 FF1003E2 		and	r1, r3, #255
 3232              	.LVL346:
 831:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3233              		.loc 1 831 0
 3234 1ae4 50689FE5 		ldr	r6, .L440+48
 838:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 3235              		.loc 1 838 0
 3236 1ae8 AC03000A 		beq	.L313
 839:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3237              		.loc 1 839 0
 3238 1aec 2DA5D6E5 		ldrb	r10, [r6, #1325]	@ zero_extendqisi2
 840:../uvc.c      **** 		 	 		 }else{
 3239              		.loc 1 840 0
 3240 1af0 2E35D6E5 		ldrb	r3, [r6, #1326]	@ zero_extendqisi2
 839:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 3241              		.loc 1 839 0
 3242 1af4 FFA00AE2 		and	r10, r10, #255
 3243 1af8 28A0C4E5 		strb	r10, [r4, #40]
 840:../uvc.c      **** 		 	 		 }else{
 3244              		.loc 1 840 0
 3245 1afc 2930C4E5 		strb	r3, [r4, #41]
 3246              	.LVL347:
 3247              	.L314:
 853:../uvc.c      **** 			 		 break;
 3248              		.loc 1 853 0
 3249 1b00 00708DE5 		str	r7, [sp]
 3250 1b04 0A20A0E1 		mov	r2, r10
 3251 1b08 0A30A0E1 		mov	r3, r10
 3252 1b0c 14189FE5 		ldr	r1, .L440+28
 3253 1b10 0400A0E3 		mov	r0, #4
 3254 1b14 0740A0E1 		mov	r4, r7
 3255 1b18 FEFFFFEB 		bl	CyU3PDebugPrint
 3256              	.LVL348:
 854:../uvc.c      **** 			 	 case ExtCtlShutlevCtlID11:
 3257              		.loc 1 854 0
 3258 1b1c 3FFFFFEA 		b	.L308
 3259              	.LVL349:
 3260              	.L291:
 969:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 3261              		.loc 1 969 0
 3262 1b20 1C789FE5 		ldr	r7, .L440+56
 3263 1b24 A520D7E5 		ldrb	r2, [r7, #165]	@ zero_extendqisi2
 3264 1b28 000052E3 		cmp	r2, #0
 3265 1b2c D703000A 		beq	.L326
 970:../uvc.c      **** 		 	 		 }else{
 3266              		.loc 1 970 0
 3267 1b30 7102D6E5 		ldrb	r0, [r6, #625]	@ zero_extendqisi2
 3268              	.LVL350:
 3269              	.L327:
 977:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 3270              		.loc 1 977 0
 3271 1b34 80A040E2 		sub	r10, r0, #128
 3272 1b38 FFA00AE2 		and	r10, r10, #255
 3273 1b3c 62FFFFEA 		b	.L428
 3274              	.LVL351:
 3275              	.L372:
1360:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 3276              		.loc 1 1360 0 discriminator 1
 3277 1b40 000059E3 		cmp	r9, #0
 3278 1b44 0300000A 		beq	.L388
 3279 1b48 DC079FE5 		ldr	r0, .L440+32
 3280 1b4c 0920A0E1 		mov	r2, r9
 3281              	.LVL352:
 3282 1b50 6C1040E2 		sub	r1, r0, #108
 3283 1b54 FEFFFFEB 		bl	memcpy
 3284              	.LVL353:
 3285              	.L388:
1364:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3286              		.loc 1 1364 0
 3287 1b58 FF40A0E3 		mov	r4, #255
1363:../uvc.c      **** 							 break;
 3288              		.loc 1 1363 0
 3289 1b5c FEFFFFEB 		bl	I2CCmdHandler
 3290              	.LVL354:
1364:../uvc.c      **** 						 case Ext1BLCRangeCtlID4: //registers value BLD window enable (0x17); position (0x13); size (
 3291              		.loc 1 1364 0
 3292 1b60 04A0A0E1 		mov	r10, r4
 3293 1b64 18709DE5 		ldr	r7, [sp, #24]
 3294 1b68 1C909DE5 		ldr	r9, [sp, #28]
 3295 1b6c 2BFEFFEA 		b	.L284
 3296              	.LVL355:
 3297              	.L375:
1422:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3298              		.loc 1 1422 0
 3299 1b70 18C09DE5 		ldr	ip, [sp, #24]
1421:../uvc.c      **** 							 if(Data0 == 1){
 3300              		.loc 1 1421 0
 3301 1b74 8870A0E1 		mov	r7, r8, asl #1
 3302 1b78 082087E0 		add	r2, r7, r8
 3303              	.LVL356:
 3304 1b7c 822186E0 		add	r2, r6, r2, asl #3
 3305 1b80 79C0C2E5 		strb	ip, [r2, #121]
 3306 1b84 B0279FE5 		ldr	r2, .L440+48
1427:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3307              		.loc 1 1427 0
 3308 1b88 C4479FE5 		ldr	r4, .L440+72
1423:../uvc.c      **** 							 }else{
 3309              		.loc 1 1423 0
 3310 1b8c 6D95D2E5 		ldrb	r9, [r2, #1389]	@ zero_extendqisi2
1422:../uvc.c      **** 								 Data0 = PUCBLC.UVCCurVLo|0x80;
 3311              		.loc 1 1422 0
 3312 1b90 01005CE3 		cmp	ip, #1
1427:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3313              		.loc 1 1427 0
 3314 1b94 1C0094E5 		ldr	r0, [r4, #28]
 3315 1b98 0010E0E3 		mvn	r1, #0
1423:../uvc.c      **** 							 }else{
 3316              		.loc 1 1423 0
 3317 1b9c 80908903 		orreq	r9, r9, #128
 3318              	.LVL357:
1425:../uvc.c      **** 							 }
 3319              		.loc 1 1425 0
 3320 1ba0 7F900912 		andne	r9, r9, #127
 3321              	.LVL358:
1427:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 3322              		.loc 1 1427 0
 3323 1ba4 14308DE5 		str	r3, [sp, #20]
 3324 1ba8 FEFFFFEB 		bl	_txe_mutex_get
 3325              	.LVL359:
1428:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3326              		.loc 1 1428 0
 3327 1bac 14309DE5 		ldr	r3, [sp, #20]
 3328 1bb0 0010A0E3 		mov	r1, #0
 3329 1bb4 0320A0E1 		mov	r2, r3
 3330 1bb8 00908DE5 		str	r9, [sp]
 3331 1bbc 0A30A0E1 		mov	r3, r10
 3332 1bc0 0400A0E1 		mov	r0, r4
 3333 1bc4 04108DE5 		str	r1, [sp, #4]
 3334 1bc8 2610A0E3 		mov	r1, #38
 3335 1bcc FEFFFFEB 		bl	cmdSet
 3336              	.LVL360:
1431:../uvc.c      **** 							 break;
 3337              		.loc 1 1431 0
 3338 1bd0 087087E0 		add	r7, r7, r8
1429:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3339              		.loc 1 1429 0
 3340 1bd4 1C0094E5 		ldr	r0, [r4, #28]
 3341 1bd8 FEFFFFEB 		bl	_txe_mutex_put
 3342              	.LVL361:
1431:../uvc.c      **** 							 break;
 3343              		.loc 1 1431 0
 3344 1bdc 876186E0 		add	r6, r6, r7, asl #3
 3345 1be0 0130A0E3 		mov	r3, #1
1432:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3346              		.loc 1 1432 0
 3347 1be4 FF40A0E3 		mov	r4, #255
 3348 1be8 18709DE5 		ldr	r7, [sp, #24]
 3349 1bec 1C909DE5 		ldr	r9, [sp, #28]
 3350              	.LVL362:
1431:../uvc.c      **** 							 break;
 3351              		.loc 1 1431 0
 3352 1bf0 7C30C6E5 		strb	r3, [r6, #124]
1432:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 3353              		.loc 1 1432 0
 3354 1bf4 04A0A0E1 		mov	r10, r4
 3355 1bf8 08FEFFEA 		b	.L284
 3356              	.LVL363:
 3357              	.L374:
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3358              		.loc 1 1411 0
 3359 1bfc 50479FE5 		ldr	r4, .L440+72
1406:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3360              		.loc 1 1406 0
 3361 1c00 0C85D6E5 		ldrb	r8, [r6, #1292]	@ zero_extendqisi2
 3362              	.LVL364:
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3363              		.loc 1 1411 0
 3364 1c04 1C0094E5 		ldr	r0, [r4, #28]
1407:../uvc.c      **** 							 devAdd = EXTBLCWeight.DeviceAdd;
 3365              		.loc 1 1407 0
 3366 1c08 0D35D6E5 		ldrb	r3, [r6, #1293]	@ zero_extendqisi2
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3367              		.loc 1 1411 0
 3368 1c0c 0010E0E3 		mvn	r1, #0
1408:../uvc.c      **** 
 3369              		.loc 1 1408 0
 3370 1c10 1B75D6E5 		ldrb	r7, [r6, #1307]	@ zero_extendqisi2
1411:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 3371              		.loc 1 1411 0
 3372 1c14 FEFFFFEB 		bl	_txe_mutex_get
 3373              	.LVL365:
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3374              		.loc 1 1412 0
 3375 1c18 18C09DE5 		ldr	ip, [sp, #24]
1408:../uvc.c      **** 
 3376              		.loc 1 1408 0
 3377 1c1c FF7007E2 		and	r7, r7, #255
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3378              		.loc 1 1412 0
 3379 1c20 0010A0E3 		mov	r1, #0
1406:../uvc.c      **** 						     RegAdd1 = EXTBLCWeight.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3380              		.loc 1 1406 0
 3381 1c24 FF8008E2 		and	r8, r8, #255
 3382              	.LVL366:
1412:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3383              		.loc 1 1412 0
 3384 1c28 0730A0E1 		mov	r3, r7
 3385 1c2c 00C08DE5 		str	ip, [sp]
 3386 1c30 0820A0E1 		mov	r2, r8
 3387 1c34 0400A0E1 		mov	r0, r4
 3388 1c38 04108DE5 		str	r1, [sp, #4]
 3389 1c3c 2510A0E3 		mov	r1, #37
 3390 1c40 FEFFFFEB 		bl	cmdSet
 3391              	.LVL367:
1413:../uvc.c      **** 							 EXTBLCWeight.UVCCurVLo = Data0;
 3392              		.loc 1 1413 0
 3393 1c44 1C0094E5 		ldr	r0, [r4, #28]
 3394 1c48 FEFFFFEB 		bl	_txe_mutex_put
 3395              	.LVL368:
1414:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3396              		.loc 1 1414 0
 3397 1c4c 18C09DE5 		ldr	ip, [sp, #24]
1418:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3398              		.loc 1 1418 0
 3399 1c50 FF40A0E3 		mov	r4, #255
1415:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3400              		.loc 1 1415 0
 3401 1c54 0130A0E3 		mov	r3, #1
1414:../uvc.c      **** 							 EXTBLCWeight.AvailableF = CyTrue;
 3402              		.loc 1 1414 0
 3403 1c58 19C5C6E5 		strb	ip, [r6, #1305]
 3404 1c5c 1C909DE5 		ldr	r9, [sp, #28]
 3405 1c60 0C70A0E1 		mov	r7, ip
 3406              	.LVL369:
1415:../uvc.c      **** 							 //ExUCtrlParArry[locCtrlID][13] = Data0;
 3407              		.loc 1 1415 0
 3408 1c64 1D35C6E5 		strb	r3, [r6, #1309]
1418:../uvc.c      **** 						 case Ext1BLCGridCtlID6:
 3409              		.loc 1 1418 0
 3410 1c68 04A0A0E1 		mov	r10, r4
 3411 1c6c EBFDFFEA 		b	.L284
 3412              	.LVL370:
 3413              	.L373:
1393:../uvc.c      **** 						     /* end test */
 3414              		.loc 1 1393 0
 3415 1c70 DC769FE5 		ldr	r7, .L440+72
1366:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3416              		.loc 1 1366 0
 3417 1c74 F884D6E5 		ldrb	r8, [r6, #1272]	@ zero_extendqisi2
 3418              	.LVL371:
1393:../uvc.c      **** 						     /* end test */
 3419              		.loc 1 1393 0
 3420 1c78 1C0097E5 		ldr	r0, [r7, #28]
1367:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3421              		.loc 1 1367 0
 3422 1c7c F994D6E5 		ldrb	r9, [r6, #1273]	@ zero_extendqisi2
1393:../uvc.c      **** 						     /* end test */
 3423              		.loc 1 1393 0
 3424 1c80 0010E0E3 		mvn	r1, #0
1368:../uvc.c      **** 
 3425              		.loc 1 1368 0
 3426 1c84 0745D6E5 		ldrb	r4, [r6, #1287]	@ zero_extendqisi2
 3427              	.LVL372:
1393:../uvc.c      **** 						     /* end test */
 3428              		.loc 1 1393 0
 3429 1c88 14C08DE5 		str	ip, [sp, #20]
 3430 1c8c FEFFFFEB 		bl	_txe_mutex_get
 3431              	.LVL373:
1395:../uvc.c      **** 							 dataIdx++;
 3432              		.loc 1 1395 0
 3433 1c90 18009DE5 		ldr	r0, [sp, #24]
1368:../uvc.c      **** 
 3434              		.loc 1 1368 0
 3435 1c94 FF4004E2 		and	r4, r4, #255
1366:../uvc.c      **** 						     RegAdd1 = EXTBLCWinPos.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3436              		.loc 1 1366 0
 3437 1c98 FF8008E2 		and	r8, r8, #255
 3438              	.LVL374:
1395:../uvc.c      **** 							 dataIdx++;
 3439              		.loc 1 1395 0
 3440 1c9c 0010A0E3 		mov	r1, #0
 3441 1ca0 0820A0E1 		mov	r2, r8
 3442 1ca4 0430A0E1 		mov	r3, r4
 3443 1ca8 00008DE5 		str	r0, [sp]
 3444 1cac 04108DE5 		str	r1, [sp, #4]
 3445 1cb0 0700A0E1 		mov	r0, r7
 3446 1cb4 2410A0E3 		mov	r1, #36
 3447 1cb8 FEFFFFEB 		bl	cmdSet
 3448              	.LVL375:
1397:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3449              		.loc 1 1397 0
 3450 1cbc 14C09DE5 		ldr	ip, [sp, #20]
1367:../uvc.c      **** 							 devAdd = EXTBLCWinPos.DeviceAdd;
 3451              		.loc 1 1367 0
 3452 1cc0 FF9009E2 		and	r9, r9, #255
 3453              	.LVL376:
1397:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3454              		.loc 1 1397 0
 3455 1cc4 0180A0E3 		mov	r8, #1
 3456              	.LVL377:
 3457 1cc8 0920A0E1 		mov	r2, r9
 3458 1ccc 0430A0E1 		mov	r3, r4
 3459 1cd0 00C08DE5 		str	ip, [sp]
 3460 1cd4 0700A0E1 		mov	r0, r7
 3461 1cd8 2410A0E3 		mov	r1, #36
 3462 1cdc 04808DE5 		str	r8, [sp, #4]
 3463 1ce0 FEFFFFEB 		bl	cmdSet
 3464              	.LVL378:
1398:../uvc.c      **** 							 getData1 = Data1;
 3465              		.loc 1 1398 0
 3466 1ce4 1C0097E5 		ldr	r0, [r7, #28]
 3467 1ce8 FEFFFFEB 		bl	_txe_mutex_put
 3468              	.LVL379:
 3469 1cec 18709DE5 		ldr	r7, [sp, #24]
1404:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3470              		.loc 1 1404 0
 3471 1cf0 FF40A0E3 		mov	r4, #255
 3472              	.LVL380:
1401:../uvc.c      **** 							 EXTBLCWinPos.UVCCurVHi = Data1; //ExUCtrlParArry[locCtrlID][14] = Data1;
 3473              		.loc 1 1401 0
 3474 1cf4 0575C6E5 		strb	r7, [r6, #1285]
 3475 1cf8 14C09DE5 		ldr	ip, [sp, #20]
1404:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3476              		.loc 1 1404 0
 3477 1cfc 04A0A0E1 		mov	r10, r4
1402:../uvc.c      **** 							 EXTBLCWinPos.AvailableF = CyTrue; //ExUCtrlParArry[locCtrlID][16] = CyTrue;
 3478              		.loc 1 1402 0
 3479 1d00 06C5C6E5 		strb	ip, [r6, #1286]
 3480 1d04 0C90A0E1 		mov	r9, ip
 3481              	.LVL381:
1403:../uvc.c      **** 							 break;
 3482              		.loc 1 1403 0
 3483 1d08 0985C6E5 		strb	r8, [r6, #1289]
1404:../uvc.c      **** 						 case Ext1BLCWeightCtlID5: //register value 0x11 (need check).
 3484              		.loc 1 1404 0
 3485 1d0c C3FDFFEA 		b	.L284
 3486              	.LVL382:
 3487              	.L364:
1495:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3488              		.loc 1 1495 0
 3489 1d10 3C769FE5 		ldr	r7, .L440+72
 3490 1d14 0010E0E3 		mvn	r1, #0
 3491 1d18 1C0097E5 		ldr	r0, [r7, #28]
 3492 1d1c 14308DE5 		str	r3, [sp, #20]
 3493 1d20 FEFFFFEB 		bl	_txe_mutex_get
 3494              	.LVL383:
1496:../uvc.c      **** 							 dataIdx++;
 3495              		.loc 1 1496 0
 3496 1d24 18C09DE5 		ldr	ip, [sp, #24]
 3497 1d28 14309DE5 		ldr	r3, [sp, #20]
 3498 1d2c 0010A0E3 		mov	r1, #0
 3499 1d30 0320A0E1 		mov	r2, r3
 3500 1d34 00C08DE5 		str	ip, [sp]
 3501 1d38 0A30A0E1 		mov	r3, r10
 3502 1d3c 0700A0E1 		mov	r0, r7
 3503 1d40 04108DE5 		str	r1, [sp, #4]
 3504 1d44 0610A0E3 		mov	r1, #6
 3505 1d48 FEFFFFEB 		bl	cmdSet
 3506              	.LVL384:
1498:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3507              		.loc 1 1498 0
 3508 1d4c 18C09DE5 		ldr	ip, [sp, #24]
 3509 1d50 0180A0E3 		mov	r8, #1
 3510              	.LVL385:
 3511 1d54 00C08DE5 		str	ip, [sp]
 3512 1d58 0A30A0E1 		mov	r3, r10
 3513 1d5c 0B20A0E1 		mov	r2, fp
 3514 1d60 0700A0E1 		mov	r0, r7
 3515 1d64 0610A0E3 		mov	r1, #6
 3516 1d68 04808DE5 		str	r8, [sp, #4]
 3517 1d6c FEFFFFEB 		bl	cmdSet
 3518              	.LVL386:
1499:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 3519              		.loc 1 1499 0
 3520 1d70 1C0097E5 		ldr	r0, [r7, #28]
 3521 1d74 FEFFFFEB 		bl	_txe_mutex_put
 3522              	.LVL387:
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3523              		.loc 1 1500 0
 3524 1d78 18C09DE5 		ldr	ip, [sp, #24]
1502:../uvc.c      **** 
 3525              		.loc 1 1502 0
 3526 1d7c FF40A0E3 		mov	r4, #255
 3527              	.LVL388:
 3528 1d80 1C909DE5 		ldr	r9, [sp, #28]
1501:../uvc.c      **** 							 break;
 3529              		.loc 1 1501 0
 3530 1d84 8C82C6E5 		strb	r8, [r6, #652]
1500:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3531              		.loc 1 1500 0
 3532 1d88 89C2C6E5 		strb	ip, [r6, #649]
 3533 1d8c 0C70A0E1 		mov	r7, ip
1502:../uvc.c      **** 
 3534              		.loc 1 1502 0
 3535 1d90 04A0A0E1 		mov	r10, r4
 3536 1d94 A1FDFFEA 		b	.L284
 3537              	.LVL389:
 3538              	.L363:
1475:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 3539              		.loc 1 1475 0
 3540 1d98 B4459FE5 		ldr	r4, .L440+72
 3541 1d9c 0010E0E3 		mvn	r1, #0
 3542 1da0 1C0094E5 		ldr	r0, [r4, #28]
 3543 1da4 14308DE5 		str	r3, [sp, #20]
 3544 1da8 FEFFFFEB 		bl	_txe_mutex_get
 3545              	.LVL390:
1476:../uvc.c      **** 							 dataIdx++;
 3546              		.loc 1 1476 0
 3547 1dac 18C09DE5 		ldr	ip, [sp, #24]
 3548 1db0 14309DE5 		ldr	r3, [sp, #20]
 3549 1db4 80004CE2 		sub	r0, ip, #128
 3550 1db8 FF0000E2 		and	r0, r0, #255
 3551 1dbc 0010A0E3 		mov	r1, #0
 3552 1dc0 0320A0E1 		mov	r2, r3
 3553 1dc4 00008DE5 		str	r0, [sp]
 3554 1dc8 0A30A0E1 		mov	r3, r10
 3555 1dcc 0400A0E1 		mov	r0, r4
 3556 1dd0 04108DE5 		str	r1, [sp, #4]
 3557 1dd4 0510A0E3 		mov	r1, #5
 3558 1dd8 FEFFFFEB 		bl	cmdSet
 3559              	.LVL391:
1478:../uvc.c      **** 							 dataIdx++;
 3560              		.loc 1 1478 0
 3561 1ddc 18C09DE5 		ldr	ip, [sp, #24]
 3562 1de0 0180A0E3 		mov	r8, #1
 3563              	.LVL392:
 3564 1de4 76304CE2 		sub	r3, ip, #118
 3565 1de8 FF3003E2 		and	r3, r3, #255
 3566 1dec 00308DE5 		str	r3, [sp]
 3567 1df0 0400A0E1 		mov	r0, r4
 3568 1df4 0A30A0E1 		mov	r3, r10
 3569 1df8 0510A0E3 		mov	r1, #5
 3570 1dfc DC20A0E3 		mov	r2, #220
 3571 1e00 04808DE5 		str	r8, [sp, #4]
 3572 1e04 FEFFFFEB 		bl	cmdSet
 3573              	.LVL393:
1480:../uvc.c      **** 							 dataIdx++;
 3574              		.loc 1 1480 0
 3575 1e08 18C09DE5 		ldr	ip, [sp, #24]
 3576 1e0c 0230A0E3 		mov	r3, #2
 3577 1e10 7E208CE2 		add	r2, ip, #126
 3578 1e14 FF2002E2 		and	r2, r2, #255
 3579 1e18 00208DE5 		str	r2, [sp]
 3580 1e1c 0400A0E1 		mov	r0, r4
 3581 1e20 04308DE5 		str	r3, [sp, #4]
 3582 1e24 0510A0E3 		mov	r1, #5
 3583 1e28 0A30A0E1 		mov	r3, r10
 3584 1e2c DE20A0E3 		mov	r2, #222
 3585 1e30 FEFFFFEB 		bl	cmdSet
 3586              	.LVL394:
1482:../uvc.c      **** 							 dataIdx++;
 3587              		.loc 1 1482 0
 3588 1e34 18C09DE5 		ldr	ip, [sp, #24]
 3589 1e38 0330A0E3 		mov	r3, #3
 3590 1e3c 72208CE2 		add	r2, ip, #114
 3591 1e40 FF2002E2 		and	r2, r2, #255
 3592 1e44 00208DE5 		str	r2, [sp]
 3593 1e48 0400A0E1 		mov	r0, r4
 3594 1e4c 04308DE5 		str	r3, [sp, #4]
 3595 1e50 0510A0E3 		mov	r1, #5
 3596 1e54 0A30A0E1 		mov	r3, r10
 3597 1e58 E020A0E3 		mov	r2, #224
 3598 1e5c FEFFFFEB 		bl	cmdSet
 3599              	.LVL395:
1484:../uvc.c      **** 							 dataIdx++;
 3600              		.loc 1 1484 0
 3601 1e60 18C09DE5 		ldr	ip, [sp, #24]
 3602 1e64 0430A0E3 		mov	r3, #4
 3603 1e68 6F204CE2 		sub	r2, ip, #111
 3604 1e6c FF2002E2 		and	r2, r2, #255
 3605 1e70 00208DE5 		str	r2, [sp]
 3606 1e74 0400A0E1 		mov	r0, r4
 3607 1e78 04308DE5 		str	r3, [sp, #4]
 3608 1e7c 0510A0E3 		mov	r1, #5
 3609 1e80 0A30A0E1 		mov	r3, r10
 3610 1e84 DD20A0E3 		mov	r2, #221
 3611 1e88 FEFFFFEB 		bl	cmdSet
 3612              	.LVL396:
1486:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3613              		.loc 1 1486 0
 3614 1e8c 2800D7E5 		ldrb	r0, [r7, #40]	@ zero_extendqisi2
 3615 1e90 0510A0E3 		mov	r1, #5
 3616 1e94 7F0080E2 		add	r0, r0, #127
 3617 1e98 FF0000E2 		and	r0, r0, #255
 3618 1e9c 0A30A0E1 		mov	r3, r10
 3619 1ea0 0B20A0E1 		mov	r2, fp
 3620 1ea4 00008DE5 		str	r0, [sp]
 3621 1ea8 04108DE5 		str	r1, [sp, #4]
 3622 1eac 0400A0E1 		mov	r0, r4
 3623 1eb0 FEFFFFEB 		bl	cmdSet
 3624              	.LVL397:
1487:../uvc.c      **** 
 3625              		.loc 1 1487 0
 3626 1eb4 1C0094E5 		ldr	r0, [r4, #28]
 3627 1eb8 FEFFFFEB 		bl	_txe_mutex_put
 3628              	.LVL398:
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3629              		.loc 1 1489 0
 3630 1ebc 2830D7E5 		ldrb	r3, [r7, #40]	@ zero_extendqisi2
1491:../uvc.c      **** 						 case SaturCtlID6:
 3631              		.loc 1 1491 0
 3632 1ec0 FF40A0E3 		mov	r4, #255
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3633              		.loc 1 1489 0
 3634 1ec4 803043E2 		sub	r3, r3, #128
 3635 1ec8 1C909DE5 		ldr	r9, [sp, #28]
 3636 1ecc 18709DE5 		ldr	r7, [sp, #24]
1490:../uvc.c      **** 							 break;
 3637              		.loc 1 1490 0
 3638 1ed0 7482C6E5 		strb	r8, [r6, #628]
1489:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3639              		.loc 1 1489 0
 3640 1ed4 7132C6E5 		strb	r3, [r6, #625]
1491:../uvc.c      **** 						 case SaturCtlID6:
 3641              		.loc 1 1491 0
 3642 1ed8 04A0A0E1 		mov	r10, r4
 3643 1edc 4FFDFFEA 		b	.L284
 3644              	.LVL399:
 3645              	.L362:
1522:../uvc.c      **** 							 is60Hz = Data0;
 3646              		.loc 1 1522 0
 3647 1ee0 18C09DE5 		ldr	ip, [sp, #24]
1523:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3648              		.loc 1 1523 0
 3649 1ee4 58349FE5 		ldr	r3, .L440+56
1522:../uvc.c      **** 							 is60Hz = Data0;
 3650              		.loc 1 1522 0
 3651 1ee8 01204CE2 		sub	r2, ip, #1
 3652              	.LVL400:
 3653 1eec FF2002E2 		and	r2, r2, #255
 3654              	.LVL401:
1529:../uvc.c      **** 							 {
 3655              		.loc 1 1529 0
 3656 1ef0 020052E3 		cmp	r2, #2
1523:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 3657              		.loc 1 1523 0
 3658 1ef4 6C2087E5 		str	r2, [r7, #108]
1532:../uvc.c      **** 							 }
 3659              		.loc 1 1532 0
 3660 1ef8 0120A083 		movhi	r2, #1
 3661 1efc 6C208385 		strhi	r2, [r3, #108]
 3662              	.LVL402:
1534:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3663              		.loc 1 1534 0
 3664 1f00 0400A0E3 		mov	r0, #4
 3665 1f04 6C3097E5 		ldr	r3, [r7, #108]
 3666 1f08 20149FE5 		ldr	r1, .L440+36
1521:../uvc.c      **** 							 Data0 = Data0 - 1;
 3667              		.loc 1 1521 0
 3668 1f0c 59C2C6E5 		strb	ip, [r6, #601]
1534:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3669              		.loc 1 1534 0
 3670 1f10 FEFFFFEB 		bl	CyU3PDebugPrint
 3671              	.LVL403:
1535:../uvc.c      **** 							 {
 3672              		.loc 1 1535 0
 3673 1f14 883097E5 		ldr	r3, [r7, #136]
1534:../uvc.c      **** 							 if (gpif_initialized == CyTrue)
 3674              		.loc 1 1534 0
 3675 1f18 24249FE5 		ldr	r2, .L440+56
1535:../uvc.c      **** 							 {
 3676              		.loc 1 1535 0
 3677 1f1c 010053E3 		cmp	r3, #1
 3678 1f20 D901000A 		beq	.L436
 3679              	.L394:
1565:../uvc.c      **** 							 break;
 3680              		.loc 1 1565 0
 3681 1f24 0130A0E3 		mov	r3, #1
1566:../uvc.c      **** 					 	 case BLCCtlID0:
 3682              		.loc 1 1566 0
 3683 1f28 FF40A0E3 		mov	r4, #255
 3684 1f2c 18709DE5 		ldr	r7, [sp, #24]
 3685 1f30 1C909DE5 		ldr	r9, [sp, #28]
1565:../uvc.c      **** 							 break;
 3686              		.loc 1 1565 0
 3687 1f34 5C32C6E5 		strb	r3, [r6, #604]
1566:../uvc.c      **** 					 	 case BLCCtlID0:
 3688              		.loc 1 1566 0
 3689 1f38 04A0A0E1 		mov	r10, r4
 3690 1f3c 37FDFFEA 		b	.L284
 3691              	.LVL404:
 3692              	.L361:
1621:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3693              		.loc 1 1621 0
 3694 1f40 0C749FE5 		ldr	r7, .L440+72
 3695 1f44 0010E0E3 		mvn	r1, #0
 3696 1f48 1C0097E5 		ldr	r0, [r7, #28]
 3697 1f4c 14308DE5 		str	r3, [sp, #20]
 3698 1f50 FEFFFFEB 		bl	_txe_mutex_get
 3699              	.LVL405:
1622:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3700              		.loc 1 1622 0
 3701 1f54 18C09DE5 		ldr	ip, [sp, #24]
 3702 1f58 14309DE5 		ldr	r3, [sp, #20]
 3703 1f5c 00E0A0E3 		mov	lr, #0
 3704 1f60 00C08DE5 		str	ip, [sp]
 3705 1f64 0410A0E1 		mov	r1, r4
 3706 1f68 0320A0E1 		mov	r2, r3
 3707 1f6c 0700A0E1 		mov	r0, r7
 3708 1f70 0A30A0E1 		mov	r3, r10
 3709 1f74 04E08DE5 		str	lr, [sp, #4]
 3710 1f78 FEFFFFEB 		bl	cmdSet
 3711              	.LVL406:
1623:../uvc.c      **** 
 3712              		.loc 1 1623 0
 3713 1f7c 1C0097E5 		ldr	r0, [r7, #28]
 3714 1f80 FEFFFFEB 		bl	_txe_mutex_put
 3715              	.LVL407:
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3716              		.loc 1 1625 0
 3717 1f84 18C09DE5 		ldr	ip, [sp, #24]
1630:../uvc.c      **** 						 default:
 3718              		.loc 1 1630 0
 3719 1f88 FF40A0E3 		mov	r4, #255
1626:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 3720              		.loc 1 1626 0
 3721 1f8c 0130A0E3 		mov	r3, #1
 3722 1f90 1C909DE5 		ldr	r9, [sp, #28]
1625:../uvc.c      **** 							 CtrlParArry[ConsCtlID2][16] = CyTrue;
 3723              		.loc 1 1625 0
 3724 1f94 29C2C6E5 		strb	ip, [r6, #553]
 3725 1f98 0C70A0E1 		mov	r7, ip
1626:../uvc.c      **** 							 //CtrlParArry[ExtExRefCtlID10][13] = Data0;  //it's canceled as the both is the same contro
 3726              		.loc 1 1626 0
 3727 1f9c 2C32C6E5 		strb	r3, [r6, #556]
1630:../uvc.c      **** 						 default:
 3728              		.loc 1 1630 0
 3729 1fa0 04A0A0E1 		mov	r10, r4
 3730 1fa4 1DFDFFEA 		b	.L284
 3731              	.LVL408:
 3732              	.L368:
1275:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3733              		.loc 1 1275 0
 3734 1fa8 A4439FE5 		ldr	r4, .L440+72
 3735 1fac 0010E0E3 		mvn	r1, #0
 3736 1fb0 1C0094E5 		ldr	r0, [r4, #28]
1271:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3737              		.loc 1 1271 0
 3738 1fb4 4895D6E5 		ldrb	r9, [r6, #1352]	@ zero_extendqisi2
1272:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3739              		.loc 1 1272 0
 3740 1fb8 49A5D6E5 		ldrb	r10, [r6, #1353]	@ zero_extendqisi2
1273:../uvc.c      **** 						     dataIdx = 0;
 3741              		.loc 1 1273 0
 3742 1fbc 5785D6E5 		ldrb	r8, [r6, #1367]	@ zero_extendqisi2
 3743              	.LVL409:
1275:../uvc.c      **** 							 if(EXTAexModGainlev.UVCCurVLo != getData)
 3744              		.loc 1 1275 0
 3745 1fc0 FEFFFFEB 		bl	_txe_mutex_get
 3746              	.LVL410:
1276:../uvc.c      **** 							 {
 3747              		.loc 1 1276 0
 3748 1fc4 18C09DE5 		ldr	ip, [sp, #24]
 3749 1fc8 5525D6E5 		ldrb	r2, [r6, #1365]	@ zero_extendqisi2
1271:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3750              		.loc 1 1271 0
 3751 1fcc FF9009E2 		and	r9, r9, #255
 3752              	.LVL411:
1276:../uvc.c      **** 							 {
 3753              		.loc 1 1276 0
 3754 1fd0 02005CE1 		cmp	ip, r2
1272:../uvc.c      **** 						     devAdd = EXTAexModGainlev.DeviceAdd;
 3755              		.loc 1 1272 0
 3756 1fd4 FFA00AE2 		and	r10, r10, #255
 3757              	.LVL412:
1273:../uvc.c      **** 						     dataIdx = 0;
 3758              		.loc 1 1273 0
 3759 1fd8 FF8008E2 		and	r8, r8, #255
 3760              	.LVL413:
1271:../uvc.c      **** 						     RegAdd1 = EXTAexModGainlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 3761              		.loc 1 1271 0
 3762 1fdc 58339FE5 		ldr	r3, .L440+48
 3763 1fe0 0C70A001 		moveq	r7, ip
1276:../uvc.c      **** 							 {
 3764              		.loc 1 1276 0
 3765 1fe4 0B00000A 		beq	.L379
1278:../uvc.c      **** 								 Data0 = Data0 | (EXTShutter.UVCCurVLo << 4);
 3766              		.loc 1 1278 0
 3767 1fe8 55C5C3E5 		strb	ip, [r3, #1365]
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3768              		.loc 1 1279 0
 3769 1fec 2D75D3E5 		ldrb	r7, [r3, #1325]	@ zero_extendqisi2
1280:../uvc.c      **** 								 /*
 3770              		.loc 1 1280 0
 3771 1ff0 0030A0E3 		mov	r3, #0
1279:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //Exposure
 3772              		.loc 1 1279 0
 3773 1ff4 07728CE1 		orr	r7, ip, r7, asl #4
 3774 1ff8 FF7007E2 		and	r7, r7, #255
 3775              	.LVL414:
1280:../uvc.c      **** 								 /*
 3776              		.loc 1 1280 0
 3777 1ffc 04308DE5 		str	r3, [sp, #4]
 3778 2000 00708DE5 		str	r7, [sp]
 3779 2004 0920A0E1 		mov	r2, r9
 3780 2008 0400A0E1 		mov	r0, r4
 3781 200c 1910A0E3 		mov	r1, #25
 3782 2010 0830A0E1 		mov	r3, r8
 3783 2014 FEFFFFEB 		bl	cmdSet
 3784              	.LVL415:
 3785              	.L379:
1292:../uvc.c      **** 								 EXTAexModGainlev.UVCCurVHi = getData1;//AGC. CtrlParArry[CtrlID][14]
 3786              		.loc 1 1292 0
 3787 2018 5635D6E5 		ldrb	r3, [r6, #1366]	@ zero_extendqisi2
 3788 201c 1CC09DE5 		ldr	ip, [sp, #28]
 3789 2020 14239FE5 		ldr	r2, .L440+48
 3790 2024 0C0053E1 		cmp	r3, ip
 3791 2028 0600000A 		beq	.L381
1294:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3792              		.loc 1 1294 0
 3793 202c 18C09DE5 		ldr	ip, [sp, #24]
 3794 2030 02304CE2 		sub	r3, ip, #2
1293:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3795              		.loc 1 1293 0
 3796 2034 1CC09DE5 		ldr	ip, [sp, #28]
1294:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3797              		.loc 1 1294 0
 3798 2038 FF3003E2 		and	r3, r3, #255
 3799 203c 010053E3 		cmp	r3, #1
1293:../uvc.c      **** 								 if(getData == 2 || getData == 3){
 3800              		.loc 1 1293 0
 3801 2040 56C5C2E5 		strb	ip, [r2, #1366]
1294:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 3802              		.loc 1 1294 0
 3803 2044 AF02009A 		bls	.L437
 3804              	.L381:
1299:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 3805              		.loc 1 1299 0
 3806 2048 1C0094E5 		ldr	r0, [r4, #28]
 3807 204c FEFFFFEB 		bl	_txe_mutex_put
 3808              	.LVL416:
1301:../uvc.c      **** 							 break;
 3809              		.loc 1 1301 0
 3810 2050 5525D6E5 		ldrb	r2, [r6, #1365]	@ zero_extendqisi2
1300:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3811              		.loc 1 1300 0
 3812 2054 1C909DE5 		ldr	r9, [sp, #28]
 3813              	.LVL417:
1301:../uvc.c      **** 							 break;
 3814              		.loc 1 1301 0
 3815 2058 5635D6E5 		ldrb	r3, [r6, #1366]	@ zero_extendqisi2
 3816 205c 2D15D6E5 		ldrb	r1, [r6, #1325]	@ zero_extendqisi2
1300:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutter.UVCCurVLo, Data0, getD
 3817              		.loc 1 1300 0
 3818 2060 0400A0E3 		mov	r0, #4
 3819 2064 82028DE8 		stmia	sp, {r1, r7, r9}
 3820 2068 C4129FE5 		ldr	r1, .L440+40
 3821 206c FEFFFFEB 		bl	CyU3PDebugPrint
 3822              	.LVL418:
1302:../uvc.c      **** 
 3823              		.loc 1 1302 0
 3824 2070 FF40A0E3 		mov	r4, #255
 3825 2074 18709DE5 		ldr	r7, [sp, #24]
 3826              	.LVL419:
 3827 2078 04A0A0E1 		mov	r10, r4
 3828              	.LVL420:
 3829 207c E7FCFFEA 		b	.L284
 3830              	.LVL421:
 3831              	.L366:
1509:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 3832              		.loc 1 1509 0
 3833 2080 CC729FE5 		ldr	r7, .L440+72
 3834 2084 0010E0E3 		mvn	r1, #0
 3835 2088 1C0097E5 		ldr	r0, [r7, #28]
 3836 208c 14308DE5 		str	r3, [sp, #20]
 3837 2090 FEFFFFEB 		bl	_txe_mutex_get
 3838              	.LVL422:
1510:../uvc.c      **** 							 dataIdx++;
 3839              		.loc 1 1510 0
 3840 2094 18C09DE5 		ldr	ip, [sp, #24]
 3841 2098 14309DE5 		ldr	r3, [sp, #20]
 3842 209c 0010A0E3 		mov	r1, #0
 3843 20a0 0320A0E1 		mov	r2, r3
 3844 20a4 00C08DE5 		str	ip, [sp]
 3845 20a8 0A30A0E1 		mov	r3, r10
 3846 20ac 0700A0E1 		mov	r0, r7
 3847 20b0 04108DE5 		str	r1, [sp, #4]
 3848 20b4 0B10A0E3 		mov	r1, #11
 3849 20b8 FEFFFFEB 		bl	cmdSet
 3850              	.LVL423:
1512:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3851              		.loc 1 1512 0
 3852 20bc 1CC09DE5 		ldr	ip, [sp, #28]
 3853 20c0 0180A0E3 		mov	r8, #1
 3854              	.LVL424:
 3855 20c4 00C08DE5 		str	ip, [sp]
 3856 20c8 0A30A0E1 		mov	r3, r10
 3857 20cc 0B20A0E1 		mov	r2, fp
 3858 20d0 0700A0E1 		mov	r0, r7
 3859 20d4 0B10A0E3 		mov	r1, #11
 3860 20d8 04808DE5 		str	r8, [sp, #4]
 3861 20dc FEFFFFEB 		bl	cmdSet
 3862              	.LVL425:
1513:../uvc.c      **** 
 3863              		.loc 1 1513 0
 3864 20e0 1C0097E5 		ldr	r0, [r7, #28]
 3865 20e4 FEFFFFEB 		bl	_txe_mutex_put
 3866              	.LVL426:
1516:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3867              		.loc 1 1516 0
 3868 20e8 1CC09DE5 		ldr	ip, [sp, #28]
 3869 20ec 18709DE5 		ldr	r7, [sp, #24]
1518:../uvc.c      **** 						 case MFreqCtlID4:
 3870              		.loc 1 1518 0
 3871 20f0 FF40A0E3 		mov	r4, #255
 3872              	.LVL427:
1517:../uvc.c      **** 							 break;
 3873              		.loc 1 1517 0
 3874 20f4 0483C6E5 		strb	r8, [r6, #772]
1515:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 3875              		.loc 1 1515 0
 3876 20f8 5C75C6E5 		strb	r7, [r6, #1372]
1516:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 3877              		.loc 1 1516 0
 3878 20fc 5EC5C6E5 		strb	ip, [r6, #1374]
 3879 2100 0C90A0E1 		mov	r9, ip
1518:../uvc.c      **** 						 case MFreqCtlID4:
 3880              		.loc 1 1518 0
 3881 2104 04A0A0E1 		mov	r10, r4
 3882 2108 C4FCFFEA 		b	.L284
 3883              	.LVL428:
 3884              	.L365:
1601:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3885              		.loc 1 1601 0
 3886 210c 18C09DE5 		ldr	ip, [sp, #24]
1600:../uvc.c      **** 							 if(Data0 != 0){
 3887              		.loc 1 1600 0
 3888 2110 0140A0E3 		mov	r4, #1
1595:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3889              		.loc 1 1595 0
 3890 2114 7485D6E5 		ldrb	r8, [r6, #1396]	@ zero_extendqisi2
 3891              	.LVL429:
1596:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3892              		.loc 1 1596 0
 3893 2118 7595D6E5 		ldrb	r9, [r6, #1397]	@ zero_extendqisi2
1597:../uvc.c      **** 						     dataIdx = 0;
 3894              		.loc 1 1597 0
 3895 211c 8375D6E5 		ldrb	r7, [r6, #1411]	@ zero_extendqisi2
1599:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 3896              		.loc 1 1599 0
 3897 2120 81C5C6E5 		strb	ip, [r6, #1409]
1600:../uvc.c      **** 							 if(Data0 != 0){
 3898              		.loc 1 1600 0
 3899 2124 8545C6E5 		strb	r4, [r6, #1413]
1602:../uvc.c      **** #ifdef COLOR
 3900              		.loc 1 1602 0
 3901 2128 24629FE5 		ldr	r6, .L440+72
1601:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3902              		.loc 1 1601 0
 3903 212c 00005CE3 		cmp	ip, #0
1595:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 3904              		.loc 1 1595 0
 3905 2130 FF8008E2 		and	r8, r8, #255
 3906              	.LVL430:
1596:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 3907              		.loc 1 1596 0
 3908 2134 FF9009E2 		and	r9, r9, #255
 3909              	.LVL431:
1597:../uvc.c      **** 						     dataIdx = 0;
 3910              		.loc 1 1597 0
 3911 2138 FF7007E2 		and	r7, r7, #255
 3912              	.LVL432:
1602:../uvc.c      **** #ifdef COLOR
 3913              		.loc 1 1602 0
 3914 213c 0010E0E3 		mvn	r1, #0
 3915 2140 1C0096E5 		ldr	r0, [r6, #28]
1601:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3916              		.loc 1 1601 0
 3917 2144 2C01000A 		beq	.L410
1602:../uvc.c      **** #ifdef COLOR
 3918              		.loc 1 1602 0
 3919 2148 FEFFFFEB 		bl	_txe_mutex_get
 3920              	.LVL433:
1606:../uvc.c      **** 								 dataIdx++;
 3921              		.loc 1 1606 0
 3922 214c 0030A0E3 		mov	r3, #0
 3923 2150 0820A0E1 		mov	r2, r8
 3924 2154 04308DE5 		str	r3, [sp, #4]
 3925 2158 00408DE5 		str	r4, [sp]
 3926 215c 0600A0E1 		mov	r0, r6
 3927 2160 0710A0E3 		mov	r1, #7
 3928 2164 0730A0E1 		mov	r3, r7
 3929 2168 FEFFFFEB 		bl	cmdSet
 3930              	.LVL434:
1608:../uvc.c      **** #endif
 3931              		.loc 1 1608 0
 3932 216c 18C09DE5 		ldr	ip, [sp, #24]
 3933 2170 0920A0E1 		mov	r2, r9
 3934 2174 00C08DE5 		str	ip, [sp]
 3935 2178 04408DE5 		str	r4, [sp, #4]
 3936              	.LVL435:
 3937              	.L431:
1613:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3938              		.loc 1 1613 0
 3939 217c 0730A0E1 		mov	r3, r7
 3940 2180 0710A0E3 		mov	r1, #7
 3941 2184 0600A0E1 		mov	r0, r6
 3942 2188 FEFFFFEB 		bl	cmdSet
 3943              	.LVL436:
1614:../uvc.c      **** 
 3944              		.loc 1 1614 0
 3945 218c FF40A0E3 		mov	r4, #255
 3946 2190 1C0096E5 		ldr	r0, [r6, #28]
 3947 2194 FEFFFFEB 		bl	_txe_mutex_put
 3948              	.LVL437:
 3949 2198 04A0A0E1 		mov	r10, r4
 3950 219c 1C909DE5 		ldr	r9, [sp, #28]
 3951              	.LVL438:
 3952 21a0 18709DE5 		ldr	r7, [sp, #24]
 3953              	.LVL439:
 3954 21a4 9DFCFFEA 		b	.L284
 3955              	.LVL440:
 3956              	.L367:
1214:../uvc.c      **** #if 1	// register setting directly
 3957              		.loc 1 1214 0
 3958 21a8 18109DE5 		ldr	r1, [sp, #24]
1211:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3959              		.loc 1 1211 0
 3960 21ac 2095D6E5 		ldrb	r9, [r6, #1312]	@ zero_extendqisi2
1212:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3961              		.loc 1 1212 0
 3962 21b0 2135D6E5 		ldrb	r3, [r6, #1313]	@ zero_extendqisi2
1213:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3963              		.loc 1 1213 0
 3964 21b4 2F45D6E5 		ldrb	r4, [r6, #1327]	@ zero_extendqisi2
1214:../uvc.c      **** #if 1	// register setting directly
 3965              		.loc 1 1214 0
 3966 21b8 2D15C6E5 		strb	r1, [r6, #1325]
1216:../uvc.c      **** 						     {
 3967              		.loc 1 1216 0
 3968 21bc 5525D6E5 		ldrb	r2, [r6, #1365]	@ zero_extendqisi2
 3969              	.LVL441:
1212:../uvc.c      **** 							 devAdd = EXTShutter.DeviceAdd;
 3970              		.loc 1 1212 0
 3971 21c0 FFB003E2 		and	fp, r3, #255
1216:../uvc.c      **** 						     {
 3972              		.loc 1 1216 0
 3973 21c4 030012E3 		tst	r2, #3
1211:../uvc.c      **** 						     RegAdd1 = EXTShutter.Reg2; //ExUCtrlParArry[locCtrlID][0];
 3974              		.loc 1 1211 0
 3975 21c8 6C319FE5 		ldr	r3, .L440+48
 3976 21cc FF9009E2 		and	r9, r9, #255
 3977              	.LVL442:
 3978 21d0 0170A0E1 		mov	r7, r1
1213:../uvc.c      **** 						     EXTShutter.UVCCurVLo = Data0; //CtrlParArry[CtrlID][13]
 3979              		.loc 1 1213 0
 3980 21d4 FF4004E2 		and	r4, r4, #255
 3981              	.LVL443:
1216:../uvc.c      **** 						     {
 3982              		.loc 1 1216 0
 3983 21d8 0130A001 		moveq	r3, r1
 3984 21dc 1B00000A 		beq	.L378
1218:../uvc.c      **** 						    	 dataIdx = 0;
 3985              		.loc 1 1218 0
 3986 21e0 55A5D3E5 		ldrb	r10, [r3, #1365]	@ zero_extendqisi2
1220:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3987              		.loc 1 1220 0
 3988 21e4 68819FE5 		ldr	r8, .L440+72
 3989              	.LVL444:
1218:../uvc.c      **** 						    	 dataIdx = 0;
 3990              		.loc 1 1218 0
 3991 21e8 01A28AE1 		orr	r10, r10, r1, asl #4
1220:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, 0x00, dataIdx);  //clean Axmode2 bit7
 3992              		.loc 1 1220 0
 3993 21ec 1C0098E5 		ldr	r0, [r8, #28]
 3994 21f0 0010E0E3 		mvn	r1, #0
 3995 21f4 14C08DE5 		str	ip, [sp, #20]
 3996 21f8 FEFFFFEB 		bl	_txe_mutex_get
 3997              	.LVL445:
1221:../uvc.c      **** 								 dataIdx++;
 3998              		.loc 1 1221 0
 3999 21fc 0030A0E3 		mov	r3, #0
 4000 2200 0B20A0E1 		mov	r2, fp
 4001 2204 00308DE5 		str	r3, [sp]
 4002 2208 04308DE5 		str	r3, [sp, #4]
 4003 220c 1010A0E3 		mov	r1, #16
 4004 2210 0430A0E1 		mov	r3, r4
 4005 2214 0800A0E1 		mov	r0, r8
 4006 2218 FEFFFFEB 		bl	cmdSet
 4007              	.LVL446:
1218:../uvc.c      **** 						    	 dataIdx = 0;
 4008              		.loc 1 1218 0
 4009 221c FFA00AE2 		and	r10, r10, #255
 4010              	.LVL447:
1223:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4011              		.loc 1 1223 0
 4012 2220 0110A0E3 		mov	r1, #1
 4013 2224 0430A0E1 		mov	r3, r4
 4014 2228 0920A0E1 		mov	r2, r9
 4015 222c 04108DE5 		str	r1, [sp, #4]
 4016 2230 00A08DE5 		str	r10, [sp]
 4017 2234 1010A0E3 		mov	r1, #16
 4018 2238 0800A0E1 		mov	r0, r8
 4019 223c FEFFFFEB 		bl	cmdSet
 4020              	.LVL448:
1224:../uvc.c      **** 						     }
 4021              		.loc 1 1224 0
 4022 2240 1C0098E5 		ldr	r0, [r8, #28]
 4023 2244 FEFFFFEB 		bl	_txe_mutex_put
 4024              	.LVL449:
 4025 2248 14C09DE5 		ldr	ip, [sp, #20]
 4026 224c 0A30A0E1 		mov	r3, r10
 4027              	.LVL450:
 4028              	.L378:
1227:../uvc.c      **** 						     break;
 4029              		.loc 1 1227 0
 4030 2250 5505D6E5 		ldrb	r0, [r6, #1365]	@ zero_extendqisi2
 4031 2254 2D15D6E5 		ldrb	r1, [r6, #1325]	@ zero_extendqisi2
1226:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4032              		.loc 1 1226 0
 4033 2258 0C20A0E1 		mov	r2, ip
 4034 225c 03008DE8 		stmia	sp, {r0, r1}
 4035 2260 D0109FE5 		ldr	r1, .L440+44
 4036 2264 0400A0E3 		mov	r0, #4
1228:../uvc.c      **** #else	// old fashion
 4037              		.loc 1 1228 0
 4038 2268 FF40A0E3 		mov	r4, #255
 4039              	.LVL451:
1226:../uvc.c      **** 						    		 Data1, Data0, EXTAexModGainlev.UVCCurVLo, EXTShutter.UVCCurVLo);
 4040              		.loc 1 1226 0
 4041 226c FEFFFFEB 		bl	CyU3PDebugPrint
 4042              	.LVL452:
1228:../uvc.c      **** #else	// old fashion
 4043              		.loc 1 1228 0
 4044 2270 04A0A0E1 		mov	r10, r4
 4045 2274 1C909DE5 		ldr	r9, [sp, #28]
 4046              	.LVL453:
 4047 2278 68FCFFEA 		b	.L284
 4048              	.LVL454:
 4049              	.L370:
1332:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 4050              		.loc 1 1332 0
 4051 227c 18C09DE5 		ldr	ip, [sp, #24]
1342:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4052              		.loc 1 1342 0
 4053 2280 CC809FE5 		ldr	r8, .L440+72
 4054              	.LVL455:
1332:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 4055              		.loc 1 1332 0
 4056 2284 03005CE3 		cmp	ip, #3
1337:../uvc.c      **** 							 }
 4057              		.loc 1 1337 0
 4058 2288 04E04C82 		subhi	lr, ip, #4
 4059 228c 18C09D85 		ldrhi	ip, [sp, #24]
 4060 2290 0CE0A091 		movls	lr, ip
1336:../uvc.c      **** 								 Data1 = Data0-4;
 4061              		.loc 1 1336 0
 4062 2294 0140A083 		movhi	r4, #1
 4063              	.LVL456:
1333:../uvc.c      **** 								 Data1 = Data0;
 4064              		.loc 1 1333 0
 4065 2298 0040A093 		movls	r4, #0
 4066 229c 0EC0A091 		movls	ip, lr
1337:../uvc.c      **** 							 }
 4067              		.loc 1 1337 0
 4068 22a0 FFE00E82 		andhi	lr, lr, #255
 4069              	.LVL457:
1341:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4070              		.loc 1 1341 0
 4071 22a4 0120A0E3 		mov	r2, #1
 4072              	.LVL458:
1342:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4073              		.loc 1 1342 0
 4074 22a8 1C0098E5 		ldr	r0, [r8, #28]
 4075 22ac 0010E0E3 		mvn	r1, #0
 4076 22b0 E040C7E5 		strb	r4, [r7, #224]
 4077              	.LVL459:
1340:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4078              		.loc 1 1340 0
 4079 22b4 F9E1C6E5 		strb	lr, [r6, #505]
1339:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 4080              		.loc 1 1339 0
 4081 22b8 99C4C6E5 		strb	ip, [r6, #1177]
1341:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 4082              		.loc 1 1341 0
 4083 22bc 9C24C6E5 		strb	r2, [r6, #1180]
1342:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4084              		.loc 1 1342 0
 4085 22c0 14308DE5 		str	r3, [sp, #20]
 4086 22c4 FEFFFFEB 		bl	_txe_mutex_get
 4087              	.LVL460:
1343:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4088              		.loc 1 1343 0
 4089 22c8 18C09DE5 		ldr	ip, [sp, #24]
 4090 22cc 14309DE5 		ldr	r3, [sp, #20]
 4091 22d0 0010A0E3 		mov	r1, #0
 4092 22d4 0320A0E1 		mov	r2, r3
 4093 22d8 00C08DE5 		str	ip, [sp]
 4094 22dc 0A30A0E1 		mov	r3, r10
 4095 22e0 04108DE5 		str	r1, [sp, #4]
 4096 22e4 0800A0E1 		mov	r0, r8
 4097 22e8 1C10A0E3 		mov	r1, #28
 4098 22ec FEFFFFEB 		bl	cmdSet
 4099              	.LVL461:
1346:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4100              		.loc 1 1346 0
 4101 22f0 FF40A0E3 		mov	r4, #255
1344:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 4102              		.loc 1 1344 0
 4103 22f4 1C0098E5 		ldr	r0, [r8, #28]
 4104 22f8 FEFFFFEB 		bl	_txe_mutex_put
 4105              	.LVL462:
1346:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 4106              		.loc 1 1346 0
 4107 22fc 04A0A0E1 		mov	r10, r4
 4108 2300 1C909DE5 		ldr	r9, [sp, #28]
 4109 2304 18709DE5 		ldr	r7, [sp, #24]
 4110 2308 44FCFFEA 		b	.L284
 4111              	.L441:
 4112              		.align	2
 4113              	.L440:
 4114 230c 00000000 		.word	bRequest
 4115 2310 28000000 		.word	.LANCHOR0+40
 4116 2314 CC050000 		.word	.LC35
 4117 2318 01000100 		.word	65537
 4118 231c FF00FF00 		.word	16711935
 4119 2320 5C040000 		.word	.LC27
 4120 2324 98040000 		.word	.LC28
 4121 2328 FC030000 		.word	.LC25
 4122 232c 94000000 		.word	.LANCHOR0+148
 4123 2330 58050000 		.word	.LC32
 4124 2334 EC040000 		.word	.LC30
 4125 2338 C0040000 		.word	.LC29
 4126 233c 00000000 		.word	.LANCHOR1
 4127 2340 20050000 		.word	.LC31
 4128 2344 00000000 		.word	.LANCHOR0
 4129 2348 9C050000 		.word	.LC34
 4130 234c 78050000 		.word	.LC33
 4131 2350 D4030000 		.word	.LC24
 4132 2354 00000000 		.word	cmdQu
 4133 2358 24040000 		.word	.LC26
 4134              	.LVL463:
 4135              	.L369:
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 4136              		.loc 1 1309 0
 4137 235c 10401FE5 		ldr	r4, .L440+72
 4138 2360 0010E0E3 		mvn	r1, #0
 4139 2364 1C0094E5 		ldr	r0, [r4, #28]
1305:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4140              		.loc 1 1305 0
 4141 2368 3495D6E5 		ldrb	r9, [r6, #1332]	@ zero_extendqisi2
1306:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 4142              		.loc 1 1306 0
 4143 236c 3585D6E5 		ldrb	r8, [r6, #1333]	@ zero_extendqisi2
 4144              	.LVL464:
1307:../uvc.c      **** 						     dataIdx = 0;
 4145              		.loc 1 1307 0
 4146 2370 4375D6E5 		ldrb	r7, [r6, #1347]	@ zero_extendqisi2
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 4147              		.loc 1 1309 0
 4148 2374 FEFFFFEB 		bl	_txe_mutex_get
 4149              	.LVL465:
1317:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4150              		.loc 1 1317 0
 4151 2378 4125D6E5 		ldrb	r2, [r6, #1345]	@ zero_extendqisi2
 4152 237c 18C09DE5 		ldr	ip, [sp, #24]
1305:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4153              		.loc 1 1305 0
 4154 2380 FF9009E2 		and	r9, r9, #255
 4155              	.LVL466:
1317:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4156              		.loc 1 1317 0
 4157 2384 02005CE1 		cmp	ip, r2
1306:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 4158              		.loc 1 1306 0
 4159 2388 FF8008E2 		and	r8, r8, #255
 4160              	.LVL467:
1307:../uvc.c      **** 						     dataIdx = 0;
 4161              		.loc 1 1307 0
 4162 238c FF7007E2 		and	r7, r7, #255
 4163              	.LVL468:
1305:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 4164              		.loc 1 1305 0
 4165 2390 5C301FE5 		ldr	r3, .L440+48
1317:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 4166              		.loc 1 1317 0
 4167 2394 0600000A 		beq	.L384
1318:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 4168              		.loc 1 1318 0
 4169 2398 41C5C3E5 		strb	ip, [r3, #1345]
1319:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4170              		.loc 1 1319 0
 4171 239c 5525D3E5 		ldrb	r2, [r3, #1365]	@ zero_extendqisi2
 4172 23a0 010052E3 		cmp	r2, #1
 4173 23a4 C501000A 		beq	.L385
1319:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 4174              		.loc 1 1319 0 is_stmt 0 discriminator 1
 4175 23a8 5535D3E5 		ldrb	r3, [r3, #1365]	@ zero_extendqisi2
 4176 23ac 030053E3 		cmp	r3, #3
 4177 23b0 C201000A 		beq	.L385
 4178              	.LVL469:
 4179              	.L384:
1326:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 4180              		.loc 1 1326 0 is_stmt 1
 4181 23b4 1C0094E5 		ldr	r0, [r4, #28]
 4182 23b8 FEFFFFEB 		bl	_txe_mutex_put
 4183              	.LVL470:
1328:../uvc.c      **** 							 break;
 4184              		.loc 1 1328 0
 4185 23bc 5525D6E5 		ldrb	r2, [r6, #1365]	@ zero_extendqisi2
1327:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4186              		.loc 1 1327 0
 4187 23c0 18709DE5 		ldr	r7, [sp, #24]
 4188              	.LVL471:
1328:../uvc.c      **** 							 break;
 4189              		.loc 1 1328 0
 4190 23c4 5635D6E5 		ldrb	r3, [r6, #1366]	@ zero_extendqisi2
1327:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4191              		.loc 1 1327 0
 4192 23c8 1C909DE5 		ldr	r9, [sp, #28]
 4193              	.LVL472:
1328:../uvc.c      **** 							 break;
 4194              		.loc 1 1328 0
 4195 23cc 4115D6E5 		ldrb	r1, [r6, #1345]	@ zero_extendqisi2
1327:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 4196              		.loc 1 1327 0
 4197 23d0 0400A0E3 		mov	r0, #4
 4198 23d4 82028DE8 		stmia	sp, {r1, r7, r9}
 4199 23d8 A0101FE5 		ldr	r1, .L440+52
 4200 23dc FEFFFFEB 		bl	CyU3PDebugPrint
 4201              	.LVL473:
1329:../uvc.c      **** 						 case ExtCamMCtlID12:
 4202              		.loc 1 1329 0
 4203 23e0 FF40A0E3 		mov	r4, #255
 4204 23e4 04A0A0E1 		mov	r10, r4
 4205 23e8 0CFCFFEA 		b	.L284
 4206              	.LVL474:
 4207              	.L371:
1354:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4208              		.loc 1 1354 0
 4209 23ec A0401FE5 		ldr	r4, .L440+72
 4210 23f0 0010E0E3 		mvn	r1, #0
 4211 23f4 1C0094E5 		ldr	r0, [r4, #28]
 4212 23f8 14308DE5 		str	r3, [sp, #20]
 4213 23fc FEFFFFEB 		bl	_txe_mutex_get
 4214              	.LVL475:
1355:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4215              		.loc 1 1355 0
 4216 2400 18C09DE5 		ldr	ip, [sp, #24]
 4217 2404 14309DE5 		ldr	r3, [sp, #20]
 4218 2408 01E07CE2 		rsbs	lr, ip, #1
 4219 240c 00E0A033 		movcc	lr, #0
 4220 2410 0010A0E3 		mov	r1, #0
 4221 2414 0320A0E1 		mov	r2, r3
 4222 2418 0400A0E1 		mov	r0, r4
 4223 241c 0A30A0E1 		mov	r3, r10
 4224 2420 00E08DE5 		str	lr, [sp]
 4225 2424 04108DE5 		str	r1, [sp, #4]
 4226 2428 1E10A0E3 		mov	r1, #30
 4227 242c FEFFFFEB 		bl	cmdSet
 4228              	.LVL476:
1356:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4229              		.loc 1 1356 0
 4230 2430 1C0094E5 		ldr	r0, [r4, #28]
 4231 2434 FEFFFFEB 		bl	_txe_mutex_put
 4232              	.LVL477:
1358:../uvc.c      **** 						 case ExtI2CCtlID15:
 4233              		.loc 1 1358 0
 4234 2438 FF40A0E3 		mov	r4, #255
1357:../uvc.c      **** 							 break;
 4235              		.loc 1 1357 0
 4236 243c 0130A0E3 		mov	r3, #1
 4237 2440 1C909DE5 		ldr	r9, [sp, #28]
 4238 2444 18709DE5 		ldr	r7, [sp, #24]
 4239 2448 CC34C6E5 		strb	r3, [r6, #1228]
1358:../uvc.c      **** 						 case ExtI2CCtlID15:
 4240              		.loc 1 1358 0
 4241 244c 04A0A0E1 		mov	r10, r4
 4242 2450 F2FBFFEA 		b	.L284
 4243              	.LVL478:
 4244              	.L360:
1457:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 4245              		.loc 1 1457 0
 4246 2454 08411FE5 		ldr	r4, .L440+72
 4247 2458 0010E0E3 		mvn	r1, #0
 4248 245c 1C0094E5 		ldr	r0, [r4, #28]
 4249 2460 FEFFFFEB 		bl	_txe_mutex_get
 4250              	.LVL479:
1459:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 4251              		.loc 1 1459 0
 4252 2464 18C09DE5 		ldr	ip, [sp, #24]
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4253              		.loc 1 1464 0
 4254 2468 0010A0E3 		mov	r1, #0
1459:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 4255              		.loc 1 1459 0
 4256 246c 80001CE3 		tst	ip, #128
1460:../uvc.c      **** 							  }else{
 4257              		.loc 1 1460 0
 4258 2470 80804C12 		subne	r8, ip, #128
 4259              	.LVL480:
1462:../uvc.c      **** 							  }
 4260              		.loc 1 1462 0
 4261 2474 0C80E001 		mvneq	r8, ip
 4262 2478 FF8008E2 		and	r8, r8, #255
 4263              	.LVL481:
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4264              		.loc 1 1464 0
 4265 247c 0A30A0E1 		mov	r3, r10
 4266 2480 0B20A0E1 		mov	r2, fp
 4267 2484 04108DE5 		str	r1, [sp, #4]
 4268 2488 00808DE5 		str	r8, [sp]
 4269 248c 0110A0E3 		mov	r1, #1
 4270 2490 44011FE5 		ldr	r0, .L440+72
 4271 2494 FEFFFFEB 		bl	cmdSet
 4272              	.LVL482:
1465:../uvc.c      **** 
 4273              		.loc 1 1465 0
 4274 2498 1C0094E5 		ldr	r0, [r4, #28]
 4275 249c FEFFFFEB 		bl	_txe_mutex_put
 4276              	.LVL483:
1471:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4277              		.loc 1 1471 0
 4278 24a0 FF40A0E3 		mov	r4, #255
1468:../uvc.c      **** 
 4279              		.loc 1 1468 0
 4280 24a4 0130A0E3 		mov	r3, #1
 4281 24a8 18709DE5 		ldr	r7, [sp, #24]
 4282 24ac 1C909DE5 		ldr	r9, [sp, #28]
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4283              		.loc 1 1467 0
 4284 24b0 1182C6E5 		strb	r8, [r6, #529]
1468:../uvc.c      **** 
 4285              		.loc 1 1468 0
 4286 24b4 1432C6E5 		strb	r3, [r6, #532]
1471:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 4287              		.loc 1 1471 0
 4288 24b8 04A0A0E1 		mov	r10, r4
 4289 24bc D7FBFFEA 		b	.L284
 4290              	.LVL484:
 4291              	.L358:
1578:../uvc.c      **** 							 {
 4292              		.loc 1 1578 0
 4293 24c0 E020D7E5 		ldrb	r2, [r7, #224]	@ zero_extendqisi2
 4294              	.LVL485:
1575:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4295              		.loc 1 1575 0
 4296 24c4 18C09DE5 		ldr	ip, [sp, #24]
1568:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4297              		.loc 1 1568 0
 4298 24c8 6075D6E5 		ldrb	r7, [r6, #1376]	@ zero_extendqisi2
1569:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 4299              		.loc 1 1569 0
 4300 24cc 6135D6E5 		ldrb	r3, [r6, #1377]	@ zero_extendqisi2
1570:../uvc.c      **** 						     dataIdx = 0;
 4301              		.loc 1 1570 0
 4302 24d0 6F45D6E5 		ldrb	r4, [r6, #1391]	@ zero_extendqisi2
1578:../uvc.c      **** 							 {
 4303              		.loc 1 1578 0
 4304 24d4 010052E3 		cmp	r2, #1
1576:../uvc.c      **** 
 4305              		.loc 1 1576 0
 4306 24d8 0130A0E3 		mov	r3, #1
1575:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 4307              		.loc 1 1575 0
 4308 24dc 6DC5C6E5 		strb	ip, [r6, #1389]
1568:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 4309              		.loc 1 1568 0
 4310 24e0 FF7007E2 		and	r7, r7, #255
 4311              	.LVL486:
1570:../uvc.c      **** 						     dataIdx = 0;
 4312              		.loc 1 1570 0
 4313 24e4 FF4004E2 		and	r4, r4, #255
 4314              	.LVL487:
1576:../uvc.c      **** 
 4315              		.loc 1 1576 0
 4316 24e8 7135C6E5 		strb	r3, [r6, #1393]
 4317 24ec 0C80A011 		movne	r8, ip
 4318              	.LVL488:
1578:../uvc.c      **** 							 {
 4319              		.loc 1 1578 0
 4320 24f0 C200000A 		beq	.L438
 4321              	.LVL489:
 4322              	.L408:
1589:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4323              		.loc 1 1589 0
 4324 24f4 A8611FE5 		ldr	r6, .L440+72
 4325 24f8 0010E0E3 		mvn	r1, #0
 4326 24fc 1C0096E5 		ldr	r0, [r6, #28]
 4327 2500 FEFFFFEB 		bl	_txe_mutex_get
 4328              	.LVL490:
1590:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4329              		.loc 1 1590 0
 4330 2504 0010A0E3 		mov	r1, #0
 4331 2508 0720A0E1 		mov	r2, r7
 4332 250c 0430A0E1 		mov	r3, r4
 4333 2510 04108DE5 		str	r1, [sp, #4]
 4334 2514 00808DE5 		str	r8, [sp]
 4335 2518 0600A0E1 		mov	r0, r6
 4336 251c FEFFFFEB 		bl	cmdSet
 4337              	.LVL491:
1593:../uvc.c      **** 					 	 case ShapCtlID7:
 4338              		.loc 1 1593 0
 4339 2520 FF40A0E3 		mov	r4, #255
 4340              	.LVL492:
1591:../uvc.c      **** 
 4341              		.loc 1 1591 0
 4342 2524 1C0096E5 		ldr	r0, [r6, #28]
 4343 2528 FEFFFFEB 		bl	_txe_mutex_put
 4344              	.LVL493:
1593:../uvc.c      **** 					 	 case ShapCtlID7:
 4345              		.loc 1 1593 0
 4346 252c 04A0A0E1 		mov	r10, r4
 4347 2530 18709DE5 		ldr	r7, [sp, #24]
 4348              	.LVL494:
 4349 2534 1C909DE5 		ldr	r9, [sp, #28]
 4350 2538 B8FBFFEA 		b	.L284
 4351              	.LVL495:
 4352              	.L285:
1093:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 4353              		.loc 1 1093 0
 4354 253c 00721FE5 		ldr	r7, .L440+56
 4355 2540 048087E0 		add	r8, r7, r4
 4356              	.LVL496:
 4357 2544 A020D8E5 		ldrb	r2, [r8, #160]	@ zero_extendqisi2
 4358 2548 000052E3 		cmp	r2, #0
 4359 254c B000000A 		beq	.L341
1094:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4360              		.loc 1 1094 0
 4361 2550 844084E0 		add	r4, r4, r4, asl #1
 4362 2554 846186E0 		add	r6, r6, r4, asl #3
 4363 2558 F9A1D6E5 		ldrb	r10, [r6, #505]	@ zero_extendqisi2
1095:../uvc.c      **** 		 	 		 }else{
 4364              		.loc 1 1095 0
 4365 255c FA41D6E5 		ldrb	r4, [r6, #506]	@ zero_extendqisi2
1094:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4366              		.loc 1 1094 0
 4367 2560 28A0C7E5 		strb	r10, [r7, #40]
1095:../uvc.c      **** 		 	 		 }else{
 4368              		.loc 1 1095 0
 4369 2564 2940C7E5 		strb	r4, [r7, #41]
 4370 2568 ACFCFFEA 		b	.L308
 4371              	.LVL497:
 4372              	.L357:
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 4373              		.loc 1 1634 0
 4374 256c 20721FE5 		ldr	r7, .L440+72
 4375 2570 0010E0E3 		mvn	r1, #0
 4376 2574 1C0097E5 		ldr	r0, [r7, #28]
 4377 2578 14308DE5 		str	r3, [sp, #20]
 4378 257c FEFFFFEB 		bl	_txe_mutex_get
 4379              	.LVL498:
1635:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4380              		.loc 1 1635 0
 4381 2580 18C09DE5 		ldr	ip, [sp, #24]
 4382 2584 14309DE5 		ldr	r3, [sp, #20]
 4383 2588 0010A0E3 		mov	r1, #0
 4384 258c 00C08DE5 		str	ip, [sp]
 4385 2590 0320A0E1 		mov	r2, r3
 4386 2594 0700A0E1 		mov	r0, r7
 4387 2598 0A30A0E1 		mov	r3, r10
 4388 259c 04108DE5 		str	r1, [sp, #4]
 4389 25a0 0410A0E1 		mov	r1, r4
 4390 25a4 FEFFFFEB 		bl	cmdSet
 4391              	.LVL499:
1636:../uvc.c      **** 
 4392              		.loc 1 1636 0
 4393 25a8 1C0097E5 		ldr	r0, [r7, #28]
 4394 25ac FEFFFFEB 		bl	_txe_mutex_put
 4395              	.LVL500:
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4396              		.loc 1 1638 0
 4397 25b0 18C09DE5 		ldr	ip, [sp, #24]
 4398 25b4 844084E0 		add	r4, r4, r4, asl #1
 4399 25b8 846186E0 		add	r6, r6, r4, asl #3
1639:../uvc.c      **** 							 break;
 4400              		.loc 1 1639 0
 4401 25bc 0130A0E3 		mov	r3, #1
1640:../uvc.c      **** 					 }
 4402              		.loc 1 1640 0
 4403 25c0 FF40A0E3 		mov	r4, #255
 4404 25c4 1C909DE5 		ldr	r9, [sp, #28]
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 4405              		.loc 1 1638 0
 4406 25c8 F9C1C6E5 		strb	ip, [r6, #505]
 4407 25cc 0C70A0E1 		mov	r7, ip
1639:../uvc.c      **** 							 break;
 4408              		.loc 1 1639 0
 4409 25d0 FC31C6E5 		strb	r3, [r6, #508]
1640:../uvc.c      **** 					 }
 4410              		.loc 1 1640 0
 4411 25d4 04A0A0E1 		mov	r10, r4
 4412 25d8 90FBFFEA 		b	.L284
 4413              	.LVL501:
 4414              	.L356:
1643:../uvc.c      **** 			   }
 4415              		.loc 1 1643 0
 4416 25dc FF40A0E3 		mov	r4, #255
 4417 25e0 0400A0E3 		mov	r0, #4
 4418              	.LVL502:
 4419 25e4 A4121FE5 		ldr	r1, .L440+60
 4420 25e8 FEFFFFEB 		bl	CyU3PDebugPrint
 4421              	.LVL503:
 4422 25ec 04A0A0E1 		mov	r10, r4
 4423 25f0 0490A0E1 		mov	r9, r4
 4424 25f4 0470A0E1 		mov	r7, r4
 4425 25f8 88FBFFEA 		b	.L284
 4426              	.LVL504:
 4427              	.L410:
1612:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 4428              		.loc 1 1612 0
 4429 25fc FEFFFFEB 		bl	_txe_mutex_get
 4430              	.LVL505:
1613:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 4431              		.loc 1 1613 0
 4432 2600 18C09DE5 		ldr	ip, [sp, #24]
 4433 2604 0820A0E1 		mov	r2, r8
 4434 2608 00C08DE5 		str	ip, [sp]
 4435 260c 04C08DE5 		str	ip, [sp, #4]
 4436 2610 D9FEFFEA 		b	.L431
 4437              	.LVL506:
 4438              	.L306:
 784:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4439              		.loc 1 784 0
 4440 2614 0A10A0E1 		mov	r1, r10
 4441 2618 0B00A0E1 		mov	r0, fp
 4442              	.LVL507:
 4443 261c 14308DE5 		str	r3, [sp, #20]
 4444 2620 FEFFFFEB 		bl	SensorGetControl
 4445              	.LVL508:
 786:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4446              		.loc 1 786 0
 4447 2624 14309DE5 		ldr	r3, [sp, #20]
 4448 2628 0A10A0E1 		mov	r1, r10
 784:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4449              		.loc 1 784 0
 4450 262c 0020A0E1 		mov	r2, r0
 786:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4451              		.loc 1 786 0
 4452 2630 0300A0E1 		mov	r0, r3
 784:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4453              		.loc 1 784 0
 4454 2634 2820C7E5 		strb	r2, [r7, #40]
 785:../uvc.c      **** 			 	 			glEp0Buffer[1] = SensorGetControl(RegAdd0, devAdd);
 4455              		.loc 1 785 0
 4456 2638 0525C6E5 		strb	r2, [r6, #1285]
 786:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4457              		.loc 1 786 0
 4458 263c FEFFFFEB 		bl	SensorGetControl
 4459              	.LVL509:
 787:../uvc.c      **** 			 	 		 }
 4460              		.loc 1 787 0
 4461 2640 0130A0E3 		mov	r3, #1
 4462 2644 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 4463 2648 C430C7E5 		strb	r3, [r7, #196]
 4464              	.LVL510:
 4465 264c 0040A0E1 		mov	r4, r0
 4466              	.LVL511:
 786:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4467              		.loc 1 786 0
 4468 2650 2900C7E5 		strb	r0, [r7, #41]
 791:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID5:
 4469              		.loc 1 791 0
 4470 2654 71FCFFEA 		b	.L308
 4471              	.LVL512:
 4472              	.L311:
 817:../uvc.c      **** 			 	 			if(Data0&0x80)
 4473              		.loc 1 817 0
 4474 2658 0300A0E1 		mov	r0, r3
 4475              	.LVL513:
 4476 265c 0A10A0E1 		mov	r1, r10
 4477 2660 FEFFFFEB 		bl	SensorGetControl
 4478              	.LVL514:
 823:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4479              		.loc 1 823 0
 4480 2664 0A31D6E5 		ldrb	r3, [r6, #266]	@ zero_extendqisi2
 824:../uvc.c      **** 			 	 		 }
 4481              		.loc 1 824 0
 4482 2668 0120A0E3 		mov	r2, #1
 4483 266c 0340A0E1 		mov	r4, r3
 823:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4484              		.loc 1 823 0
 4485 2670 2930C7E5 		strb	r3, [r7, #41]
 824:../uvc.c      **** 			 	 		 }
 4486              		.loc 1 824 0
 4487 2674 C620C7E5 		strb	r2, [r7, #198]
 818:../uvc.c      **** 			 	 				glEp0Buffer[0] = 1;
 4488              		.loc 1 818 0
 4489 2678 A003A0E1 		mov	r0, r0, lsr #7
 4490              	.LVL515:
 819:../uvc.c      **** 			 	 			else
 4491              		.loc 1 819 0
 4492 267c 02A000E0 		and	r10, r0, r2
 4493 2680 28A0C7E5 		strb	r10, [r7, #40]
 822:../uvc.c      **** 			 	 			glEp0Buffer[1] = ExUCtrlParArry[CtrlID-0x20][14];
 4494              		.loc 1 822 0
 4495 2684 09A1C6E5 		strb	r10, [r6, #265]
 4496              	.LVL516:
 828:../uvc.c      **** 			 	 }
 4497              		.loc 1 828 0
 4498 2688 64FCFFEA 		b	.L308
 4499              	.LVL517:
 4500              	.L436:
1538:../uvc.c      **** 			                         {
 4501              		.loc 1 1538 0
 4502 268c 7030D2E5 		ldrb	r3, [r2, #112]	@ zero_extendqisi2
 4503 2690 013043E2 		sub	r3, r3, #1
 4504 2694 030053E3 		cmp	r3, #3
 4505 2698 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 4506 269c 20FEFFEA 		b	.L394
 4507              	.L396:
 4508 26a0 B4270000 		.word	.L395
 4509 26a4 68270000 		.word	.L397
 4510 26a8 0C270000 		.word	.L398
 4511 26ac B0260000 		.word	.L399
 4512              	.L399:
1556:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4513              		.loc 1 1556 0
 4514 26b0 6C2097E5 		ldr	r2, [r7, #108]
 4515 26b4 5230D6E5 		ldrb	r3, [r6, #82]	@ zero_extendqisi2
 4516 26b8 000052E3 		cmp	r2, #0
 4517 26bc F420A003 		moveq	r2, #244
 4518 26c0 7420A013 		movne	r2, #116
 4519 26c4 032082E1 		orr	r2, r2, r3
 4520 26c8 3010A0E3 		mov	r1, #48
 4521 26cc 5230A0E3 		mov	r3, #82
 4522 26d0 0100A0E3 		mov	r0, #1
 4523 26d4 FEFFFFEB 		bl	SensorSetIrisControl
 4524              	.LVL518:
1557:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4525              		.loc 1 1557 0
 4526 26d8 7D0FA0E3 		mov	r0, #500
 4527 26dc FEFFFFEB 		bl	_tx_thread_sleep
 4528              	.LVL519:
1558:../uvc.c      **** 			                         	default:
 4529              		.loc 1 1558 0
 4530 26e0 6C1097E5 		ldr	r1, [r7, #108]
 4531 26e4 5220D6E5 		ldrb	r2, [r6, #82]	@ zero_extendqisi2
 4532 26e8 000051E3 		cmp	r1, #0
 4533 26ec F410A003 		moveq	r1, #244
 4534 26f0 7410A013 		movne	r1, #116
 4535 26f4 022081E1 		orr	r2, r1, r2
 4536 26f8 6C3097E5 		ldr	r3, [r7, #108]
 4537 26fc B8131FE5 		ldr	r1, .L440+64
 4538 2700 0400A0E3 		mov	r0, #4
 4539 2704 FEFFFFEB 		bl	CyU3PDebugPrint
 4540              	.LVL520:
 4541 2708 05FEFFEA 		b	.L394
 4542              	.L398:
1551:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4543              		.loc 1 1551 0
 4544 270c 6C2097E5 		ldr	r2, [r7, #108]
 4545 2710 5230D6E5 		ldrb	r3, [r6, #82]	@ zero_extendqisi2
 4546 2714 000052E3 		cmp	r2, #0
 4547 2718 C420A003 		moveq	r2, #196
 4548 271c 4420A013 		movne	r2, #68
 4549 2720 032082E1 		orr	r2, r2, r3
 4550 2724 3010A0E3 		mov	r1, #48
 4551 2728 5230A0E3 		mov	r3, #82
 4552 272c 0100A0E3 		mov	r0, #1
 4553 2730 FEFFFFEB 		bl	SensorSetIrisControl
 4554              	.LVL521:
1552:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", ((is60
 4555              		.loc 1 1552 0
 4556 2734 7D0FA0E3 		mov	r0, #500
 4557 2738 FEFFFFEB 		bl	_tx_thread_sleep
 4558              	.LVL522:
1553:../uvc.c      **** 			                         		break;
 4559              		.loc 1 1553 0
 4560 273c 6C1097E5 		ldr	r1, [r7, #108]
 4561 2740 5220D6E5 		ldrb	r2, [r6, #82]	@ zero_extendqisi2
 4562 2744 000051E3 		cmp	r1, #0
 4563 2748 C410A003 		moveq	r1, #196
 4564 274c 4410A013 		movne	r1, #68
 4565 2750 022081E1 		orr	r2, r1, r2
 4566 2754 6C3097E5 		ldr	r3, [r7, #108]
 4567 2758 14141FE5 		ldr	r1, .L440+64
 4568 275c 0400A0E3 		mov	r0, #4
 4569 2760 FEFFFFEB 		bl	CyU3PDebugPrint
 4570              	.LVL523:
1554:../uvc.c      **** 			                         	case 4: //VGA
 4571              		.loc 1 1554 0
 4572 2764 EEFDFFEA 		b	.L394
 4573              	.L397:
1546:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4574              		.loc 1 1546 0
 4575 2768 6C2097E5 		ldr	r2, [r7, #108]
 4576 276c 3010A0E3 		mov	r1, #48
 4577 2770 000052E3 		cmp	r2, #0
 4578 2774 D420A003 		moveq	r2, #212
 4579 2778 5420A013 		movne	r2, #84
 4580 277c 5230A0E3 		mov	r3, #82
 4581 2780 0100A0E3 		mov	r0, #1
 4582 2784 FEFFFFEB 		bl	SensorSetIrisControl
 4583              	.LVL524:
1547:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4584              		.loc 1 1547 0
 4585 2788 7D0FA0E3 		mov	r0, #500
 4586 278c FEFFFFEB 		bl	_tx_thread_sleep
 4587              	.LVL525:
1548:../uvc.c      **** 			                         		break;
 4588              		.loc 1 1548 0
 4589 2790 6C2097E5 		ldr	r2, [r7, #108]
 4590 2794 50141FE5 		ldr	r1, .L440+64
 4591 2798 000052E3 		cmp	r2, #0
 4592 279c 6C3097E5 		ldr	r3, [r7, #108]
 4593 27a0 D420A003 		moveq	r2, #212
 4594 27a4 5420A013 		movne	r2, #84
 4595 27a8 0400A0E3 		mov	r0, #4
 4596 27ac FEFFFFEB 		bl	CyU3PDebugPrint
 4597              	.LVL526:
1549:../uvc.c      **** 			                         	case 3: //720
 4598              		.loc 1 1549 0
 4599 27b0 DBFDFFEA 		b	.L394
 4600              	.L395:
1541:../uvc.c      **** 			                         		CyU3PThreadSleep(500);
 4601              		.loc 1 1541 0
 4602 27b4 6C2097E5 		ldr	r2, [r7, #108]
 4603 27b8 3010A0E3 		mov	r1, #48
 4604 27bc 000052E3 		cmp	r2, #0
 4605 27c0 E420A003 		moveq	r2, #228
 4606 27c4 6420A013 		movne	r2, #100
 4607 27c8 5230A0E3 		mov	r3, #82
 4608 27cc 0100A0E3 		mov	r0, #1
 4609 27d0 FEFFFFEB 		bl	SensorSetIrisControl
 4610              	.LVL527:
1542:../uvc.c      **** 			                                CyU3PDebugPrint (4, "FSet the video mode format %x %d\n", is60Hz
 4611              		.loc 1 1542 0
 4612 27d4 7D0FA0E3 		mov	r0, #500
 4613 27d8 FEFFFFEB 		bl	_tx_thread_sleep
 4614              	.LVL528:
1543:../uvc.c      **** 			                         		break;
 4615              		.loc 1 1543 0
 4616 27dc 6C2097E5 		ldr	r2, [r7, #108]
 4617 27e0 9C141FE5 		ldr	r1, .L440+64
 4618 27e4 000052E3 		cmp	r2, #0
 4619 27e8 6C3097E5 		ldr	r3, [r7, #108]
 4620 27ec E420A003 		moveq	r2, #228
 4621 27f0 6420A013 		movne	r2, #100
 4622 27f4 0400A0E3 		mov	r0, #4
 4623 27f8 FEFFFFEB 		bl	CyU3PDebugPrint
 4624              	.LVL529:
1544:../uvc.c      **** 			                         	case 2: //1080
 4625              		.loc 1 1544 0
 4626 27fc C8FDFFEA 		b	.L394
 4627              	.LVL530:
 4628              	.L438:
1580:../uvc.c      **** 					 				 Data0 += 4;
 4629              		.loc 1 1580 0
 4630 2800 02005CE3 		cmp	ip, #2
 4631 2804 D000008A 		bhi	.L409
1581:../uvc.c      **** 					 			 }else{
 4632              		.loc 1 1581 0
 4633 2808 04808CE2 		add	r8, ip, #4
 4634 280c FF8008E2 		and	r8, r8, #255
 4635              	.LVL531:
 4636 2810 37FFFFEA 		b	.L408
 4637              	.LVL532:
 4638              	.L341:
1097:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4639              		.loc 1 1097 0
 4640 2814 0300A0E1 		mov	r0, r3
 4641              	.LVL533:
 4642 2818 0A10A0E1 		mov	r1, r10
 4643 281c FEFFFFEB 		bl	SensorGetControl
 4644              	.LVL534:
1098:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4645              		.loc 1 1098 0
 4646 2820 844084E0 		add	r4, r4, r4, asl #1
 4647              	.LVL535:
 4648 2824 846186E0 		add	r6, r6, r4, asl #3
1099:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4649              		.loc 1 1099 0
 4650 2828 FA31D6E5 		ldrb	r3, [r6, #506]	@ zero_extendqisi2
1100:../uvc.c      **** 		 	 		 }
 4651              		.loc 1 1100 0
 4652 282c 0120A0E3 		mov	r2, #1
 4653 2830 0340A0E1 		mov	r4, r3
1099:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4654              		.loc 1 1099 0
 4655 2834 2930C7E5 		strb	r3, [r7, #41]
1100:../uvc.c      **** 		 	 		 }
 4656              		.loc 1 1100 0
 4657 2838 A020C8E5 		strb	r2, [r8, #160]
 4658 283c 00A0A0E1 		mov	r10, r0
 4659              	.LVL536:
1098:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4660              		.loc 1 1098 0
 4661 2840 F901C6E5 		strb	r0, [r6, #505]
1097:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4662              		.loc 1 1097 0
 4663 2844 2800C7E5 		strb	r0, [r7, #40]
1106:../uvc.c      **** 			 }
 4664              		.loc 1 1106 0
 4665 2848 F4FBFFEA 		b	.L308
 4666              	.LVL537:
 4667              	.L309:
 799:../uvc.c      **** 			 	 			glEp0Buffer[0] = Data0;
 4668              		.loc 1 799 0
 4669 284c 0300A0E1 		mov	r0, r3
 4670              	.LVL538:
 4671 2850 0A10A0E1 		mov	r1, r10
 4672 2854 FEFFFFEB 		bl	SensorGetControl
 4673              	.LVL539:
 803:../uvc.c      **** 			 	 		 }
 4674              		.loc 1 803 0
 4675 2858 0120A0E3 		mov	r2, #1
 4676 285c C520C7E5 		strb	r2, [r7, #197]
 801:../uvc.c      **** 			 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4677              		.loc 1 801 0
 4678 2860 1905C6E5 		strb	r0, [r6, #1305]
 802:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4679              		.loc 1 802 0
 4680 2864 1A35D6E5 		ldrb	r3, [r6, #1306]	@ zero_extendqisi2
 803:../uvc.c      **** 			 	 		 }
 4681              		.loc 1 803 0
 4682 2868 00A0A0E1 		mov	r10, r0
 4683              	.LVL540:
 802:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4684              		.loc 1 802 0
 4685 286c FF3003E2 		and	r3, r3, #255
 803:../uvc.c      **** 			 	 		 }
 4686              		.loc 1 803 0
 4687 2870 0340A0E1 		mov	r4, r3
 4688              	.LVL541:
 802:../uvc.c      **** 			 	 			curFlag[CtrlID] = CyTrue;
 4689              		.loc 1 802 0
 4690 2874 2930C7E5 		strb	r3, [r7, #41]
 800:../uvc.c      **** 			 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4691              		.loc 1 800 0
 4692 2878 2800C7E5 		strb	r0, [r7, #40]
 807:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID6:
 4693              		.loc 1 807 0
 4694 287c E7FBFFEA 		b	.L308
 4695              	.LVL542:
 4696              	.L330:
1008:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x1;
 4697              		.loc 1 1008 0
 4698 2880 0300A0E1 		mov	r0, r3
 4699              	.LVL543:
 4700 2884 0A10A0E1 		mov	r1, r10
 4701 2888 FEFFFFEB 		bl	SensorGetControl
 4702              	.LVL544:
1012:../uvc.c      **** 		 	 		 }
 4703              		.loc 1 1012 0
 4704 288c 0130A0E3 		mov	r3, #1
 4705 2890 A030C7E5 		strb	r3, [r7, #160]
1009:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4706              		.loc 1 1009 0
 4707 2894 030000E0 		and	r0, r0, r3
1010:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4708              		.loc 1 1010 0
 4709 2898 6D05C6E5 		strb	r0, [r6, #1389]
1011:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4710              		.loc 1 1011 0
 4711 289c 6E35D6E5 		ldrb	r3, [r6, #1390]	@ zero_extendqisi2
1012:../uvc.c      **** 		 	 		 }
 4712              		.loc 1 1012 0
 4713 28a0 00A0A0E1 		mov	r10, r0
1011:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4714              		.loc 1 1011 0
 4715 28a4 FF3003E2 		and	r3, r3, #255
1012:../uvc.c      **** 		 	 		 }
 4716              		.loc 1 1012 0
 4717 28a8 0340A0E1 		mov	r4, r3
1011:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4718              		.loc 1 1011 0
 4719 28ac 2930C7E5 		strb	r3, [r7, #41]
1009:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4720              		.loc 1 1009 0
 4721 28b0 2800C7E5 		strb	r0, [r7, #40]
 4722              	.LVL545:
1016:../uvc.c      **** 				 case ShapCtlID7:
 4723              		.loc 1 1016 0
 4724 28b4 D9FBFFEA 		b	.L308
 4725              	.LVL546:
 4726              	.L322:
 954:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4727              		.loc 1 954 0
 4728 28b8 0300A0E1 		mov	r0, r3
 4729              	.LVL547:
 4730 28bc 0A10A0E1 		mov	r1, r10
 4731 28c0 FEFFFFEB 		bl	SensorGetControl
 4732              	.LVL548:
 956:../uvc.c      **** 		 	 		 }
 4733              		.loc 1 956 0
 4734 28c4 0130A0E3 		mov	r3, #1
 4735 28c8 A130C7E5 		strb	r3, [r7, #161]
 955:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4736              		.loc 1 955 0
 4737 28cc 1102C6E5 		strb	r0, [r6, #529]
 4738 28d0 1FFCFFEA 		b	.L323
 4739              	.LVL549:
 4740              	.L336:
1056:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4741              		.loc 1 1056 0
 4742 28d4 0A10A0E1 		mov	r1, r10
 4743 28d8 0300A0E1 		mov	r0, r3
 4744              	.LVL550:
 4745 28dc FEFFFFEB 		bl	SensorGetControl
 4746              	.LVL551:
1059:../uvc.c      **** 
 4747              		.loc 1 1059 0
 4748 28e0 D232D6E5 		ldrb	r3, [r6, #722]	@ zero_extendqisi2
1061:../uvc.c      **** 		 	 		 }
 4749              		.loc 1 1061 0
 4750 28e4 0110A0E3 		mov	r1, #1
 4751 28e8 0340A0E1 		mov	r4, r3
1059:../uvc.c      **** 
 4752              		.loc 1 1059 0
 4753 28ec 2930C7E5 		strb	r3, [r7, #41]
1061:../uvc.c      **** 		 	 		 }
 4754              		.loc 1 1061 0
 4755 28f0 A910C7E5 		strb	r1, [r7, #169]
1058:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4756              		.loc 1 1058 0
 4757 28f4 032000E2 		and	r2, r0, #3
1061:../uvc.c      **** 		 	 		 }
 4758              		.loc 1 1061 0
 4759 28f8 02A0A0E1 		mov	r10, r2
 4760              	.LVL552:
1057:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 4761              		.loc 1 1057 0
 4762 28fc D102C6E5 		strb	r0, [r6, #721]
1058:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4763              		.loc 1 1058 0
 4764 2900 2820C7E5 		strb	r2, [r7, #40]
1065:../uvc.c      **** 				 case MFreqCtlID4:
 4765              		.loc 1 1065 0
 4766 2904 C5FBFFEA 		b	.L308
 4767              	.LVL553:
 4768              	.L338:
1078:../uvc.c      **** 		 	 			glEp0Buffer[0] = (Data0&0x80)>>7;
 4769              		.loc 1 1078 0
 4770 2908 0A10A0E1 		mov	r1, r10
 4771 290c 0100A0E3 		mov	r0, #1
 4772              	.LVL554:
 4773 2910 FEFFFFEB 		bl	SensorGetControl
 4774              	.LVL555:
1082:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4775              		.loc 1 1082 0
 4776 2914 5A32D6E5 		ldrb	r3, [r6, #602]	@ zero_extendqisi2
1083:../uvc.c      **** 		 	 		 }
 4777              		.loc 1 1083 0
 4778 2918 0120A0E3 		mov	r2, #1
 4779 291c 0340A0E1 		mov	r4, r3
1082:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4780              		.loc 1 1082 0
 4781 2920 2930C7E5 		strb	r3, [r7, #41]
1083:../uvc.c      **** 		 	 		 }
 4782              		.loc 1 1083 0
 4783 2924 A420C7E5 		strb	r2, [r7, #164]
1079:../uvc.c      **** 		 	 			glEp0Buffer[0]++;
 4784              		.loc 1 1079 0
 4785 2928 A003A0E1 		mov	r0, r0, lsr #7
 4786              	.LVL556:
1080:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 4787              		.loc 1 1080 0
 4788 292c 023080E0 		add	r3, r0, r2
 4789 2930 FF3003E2 		and	r3, r3, #255
 4790 2934 03A0A0E1 		mov	r10, r3
 4791 2938 2830C7E5 		strb	r3, [r7, #40]
1081:../uvc.c      **** 						glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 4792              		.loc 1 1081 0
 4793 293c 5932C6E5 		strb	r3, [r6, #601]
 4794              	.LVL557:
1088:../uvc.c      **** 				 case SaturCtlID6:
 4795              		.loc 1 1088 0
 4796 2940 B6FBFFEA 		b	.L308
 4797              	.LVL558:
 4798              	.L315:
 867:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4799              		.loc 1 867 0
 4800 2944 FEFFFFEB 		bl	SensorGetControl
 4801              	.LVL559:
 870:../uvc.c      **** 		 	 		 }
 4802              		.loc 1 870 0
 4803 2948 0120A0E3 		mov	r2, #1
 4804 294c BB20C7E5 		strb	r2, [r7, #187]
 868:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4805              		.loc 1 868 0
 4806 2950 4105C4E5 		strb	r0, [r4, #1345]
 869:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4807              		.loc 1 869 0
 4808 2954 4235D4E5 		ldrb	r3, [r4, #1346]	@ zero_extendqisi2
 870:../uvc.c      **** 		 	 		 }
 4809              		.loc 1 870 0
 4810 2958 00A0A0E1 		mov	r10, r0
 4811              	.LVL560:
 869:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4812              		.loc 1 869 0
 4813 295c FF3003E2 		and	r3, r3, #255
 870:../uvc.c      **** 		 	 		 }
 4814              		.loc 1 870 0
 4815 2960 0340A0E1 		mov	r4, r3
 4816              	.LVL561:
 869:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4817              		.loc 1 869 0
 4818 2964 2930C7E5 		strb	r3, [r7, #41]
 867:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4819              		.loc 1 867 0
 4820 2968 2800C7E5 		strb	r0, [r7, #40]
 874:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 4821              		.loc 1 874 0
 4822 296c ABFBFFEA 		b	.L308
 4823              	.LVL562:
 4824              	.L334:
1042:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4825              		.loc 1 1042 0
 4826 2970 0300A0E1 		mov	r0, r3
 4827              	.LVL563:
 4828 2974 0A10A0E1 		mov	r1, r10
 4829 2978 FEFFFFEB 		bl	SensorGetControl
 4830              	.LVL564:
1044:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4831              		.loc 1 1044 0
 4832 297c 2A32D6E5 		ldrb	r3, [r6, #554]	@ zero_extendqisi2
1045:../uvc.c      **** 		 	 		 }
 4833              		.loc 1 1045 0
 4834 2980 0120A0E3 		mov	r2, #1
 4835 2984 0340A0E1 		mov	r4, r3
 4836              	.LVL565:
1044:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4837              		.loc 1 1044 0
 4838 2988 2930C7E5 		strb	r3, [r7, #41]
1045:../uvc.c      **** 		 	 		 }
 4839              		.loc 1 1045 0
 4840 298c A020C8E5 		strb	r2, [r8, #160]
 4841 2990 00A0A0E1 		mov	r10, r0
 4842              	.LVL566:
1042:../uvc.c      **** 		 	 			CtrlParArry[ConsCtlID2][13] = glEp0Buffer[0];
 4843              		.loc 1 1042 0
 4844 2994 2800C7E5 		strb	r0, [r7, #40]
1043:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[ConsCtlID2][14];
 4845              		.loc 1 1043 0
 4846 2998 2902C6E5 		strb	r0, [r6, #553]
1049:../uvc.c      **** 				 case WBTMdCtlID9:
 4847              		.loc 1 1049 0
 4848 299c 9FFBFFEA 		b	.L308
 4849              	.LVL567:
 4850              	.L313:
 842:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = Data0;
 4851              		.loc 1 842 0
 4852 29a0 FEFFFFEB 		bl	SensorGetControl
 4853              	.LVL568:
 848:../uvc.c      **** 
 4854              		.loc 1 848 0
 4855 29a4 5C161FE5 		ldr	r1, .L440+68
 843:../uvc.c      **** 		 	 			Data1 = (Data0&0x70)>>4;
 4856              		.loc 1 843 0
 4857 29a8 2D05C6E5 		strb	r0, [r6, #1325]
 844:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4858              		.loc 1 844 0
 4859 29ac 707000E2 		and	r7, r0, #112
 846:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 4860              		.loc 1 846 0
 4861 29b0 2EC5D6E5 		ldrb	ip, [r6, #1326]	@ zero_extendqisi2
 844:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4862              		.loc 1 844 0
 4863 29b4 4772A0E1 		mov	r7, r7, asr #4
 848:../uvc.c      **** 
 4864              		.loc 1 848 0
 4865 29b8 0720A0E1 		mov	r2, r7
 844:../uvc.c      **** 		 	 			glEp0Buffer[0] = Data1;
 4866              		.loc 1 844 0
 4867 29bc FF7007E2 		and	r7, r7, #255
 4868              	.LVL569:
 848:../uvc.c      **** 
 4869              		.loc 1 848 0
 4870 29c0 00008DE5 		str	r0, [sp]
 4871 29c4 0230A0E1 		mov	r3, r2
 4872 29c8 0400A0E3 		mov	r0, #4
 4873              	.LVL570:
 846:../uvc.c      **** 		 	 			//curFlag[CtrlID] = CyTrue;
 4874              		.loc 1 846 0
 4875 29cc 29C0C4E5 		strb	ip, [r4, #41]
 845:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 4876              		.loc 1 845 0
 4877 29d0 2870C4E5 		strb	r7, [r4, #40]
 848:../uvc.c      **** 
 4878              		.loc 1 848 0
 4879 29d4 FEFFFFEB 		bl	CyU3PDebugPrint
 4880              	.LVL571:
 4881 29d8 28A0D4E5 		ldrb	r10, [r4, #40]	@ zero_extendqisi2
 4882 29dc 47FCFFEA 		b	.L314
 4883              	.LVL572:
 4884              	.L320:
 917:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0]&0x3; // get least two bits for Aex Mode
 4885              		.loc 1 917 0
 4886 29e0 0410A0E1 		mov	r1, r4
 4887 29e4 FEFFFFEB 		bl	SensorGetControl
 4888              	.LVL573:
 921:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4889              		.loc 1 921 0
 4890 29e8 0410A0E1 		mov	r1, r4
 918:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4891              		.loc 1 918 0
 4892 29ec 033000E2 		and	r3, r0, #3
 921:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4893              		.loc 1 921 0
 4894 29f0 0800A0E1 		mov	r0, r8
 918:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 4895              		.loc 1 918 0
 4896 29f4 2830C7E5 		strb	r3, [r7, #40]
 919:../uvc.c      **** 
 4897              		.loc 1 919 0
 4898 29f8 5535C6E5 		strb	r3, [r6, #1365]
 921:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4899              		.loc 1 921 0
 4900 29fc FEFFFFEB 		bl	SensorGetControl
 4901              	.LVL574:
 923:../uvc.c      **** 		 	 		 }
 4902              		.loc 1 923 0
 4903 2a00 0130A0E3 		mov	r3, #1
 4904 2a04 28A0D7E5 		ldrb	r10, [r7, #40]	@ zero_extendqisi2
 4905 2a08 B930C7E5 		strb	r3, [r7, #185]
 4906 2a0c 0040A0E1 		mov	r4, r0
 4907              	.LVL575:
 921:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi = glEp0Buffer[2];
 4908              		.loc 1 921 0
 4909 2a10 2A00C7E5 		strb	r0, [r7, #42]
 922:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4910              		.loc 1 922 0
 4911 2a14 5605C6E5 		strb	r0, [r6, #1366]
 4912 2a18 E3FBFFEA 		b	.L321
 4913              	.LVL576:
 4914              	.L328:
 990:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4915              		.loc 1 990 0
 4916 2a1c 0300A0E1 		mov	r0, r3
 4917              	.LVL577:
 4918 2a20 0A10A0E1 		mov	r1, r10
 4919 2a24 FEFFFFEB 		bl	SensorGetControl
 4920              	.LVL578:
 991:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4921              		.loc 1 991 0
 4922 2a28 0A10A0E1 		mov	r1, r10
 990:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 4923              		.loc 1 990 0
 4924 2a2c 0080A0E1 		mov	r8, r0
 4925              	.LVL579:
 991:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 4926              		.loc 1 991 0
 4927 2a30 0B00A0E1 		mov	r0, fp
 4928              	.LVL580:
 4929 2a34 FEFFFFEB 		bl	SensorGetControl
 4930              	.LVL581:
 996:../uvc.c      **** 		 	 		 }
 4931              		.loc 1 996 0
 4932 2a38 0130A0E3 		mov	r3, #1
 4933 2a3c 08A0A0E1 		mov	r10, r8
 992:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 4934              		.loc 1 992 0
 4935 2a40 2880C7E5 		strb	r8, [r7, #40]
 993:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 4936              		.loc 1 993 0
 4937 2a44 5C85C6E5 		strb	r8, [r6, #1372]
 996:../uvc.c      **** 		 	 		 }
 4938              		.loc 1 996 0
 4939 2a48 AB30C7E5 		strb	r3, [r7, #171]
 4940 2a4c 0040A0E1 		mov	r4, r0
 4941              	.LVL582:
 994:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 4942              		.loc 1 994 0
 4943 2a50 2A00C7E5 		strb	r0, [r7, #42]
 995:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4944              		.loc 1 995 0
 4945 2a54 5E05C6E5 		strb	r0, [r6, #1374]
 4946 2a58 B4FBFFEA 		b	.L329
 4947              	.LVL583:
 4948              	.L332:
1025:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4949              		.loc 1 1025 0
 4950 2a5c 0A10A0E1 		mov	r1, r10
 4951 2a60 0B00A0E1 		mov	r0, fp
 4952              	.LVL584:
 4953 2a64 FEFFFFEB 		bl	SensorGetControl
 4954              	.LVL585:
1028:../uvc.c      **** 		 	 		 }
 4955              		.loc 1 1028 0
 4956 2a68 0120A0E3 		mov	r2, #1
 4957 2a6c A720C7E5 		strb	r2, [r7, #167]
1026:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 4958              		.loc 1 1026 0
 4959 2a70 8105C6E5 		strb	r0, [r6, #1409]
1027:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4960              		.loc 1 1027 0
 4961 2a74 8235D6E5 		ldrb	r3, [r6, #1410]	@ zero_extendqisi2
1028:../uvc.c      **** 		 	 		 }
 4962              		.loc 1 1028 0
 4963 2a78 00A0A0E1 		mov	r10, r0
 4964              	.LVL586:
1027:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4965              		.loc 1 1027 0
 4966 2a7c FF3003E2 		and	r3, r3, #255
1028:../uvc.c      **** 		 	 		 }
 4967              		.loc 1 1028 0
 4968 2a80 0340A0E1 		mov	r4, r3
 4969              	.LVL587:
1027:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4970              		.loc 1 1027 0
 4971 2a84 2930C7E5 		strb	r3, [r7, #41]
1025:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 4972              		.loc 1 1025 0
 4973 2a88 2800C7E5 		strb	r0, [r7, #40]
1032:../uvc.c      **** 				 case ExtExRefCtlID10:
 4974              		.loc 1 1032 0
 4975 2a8c 63FBFFEA 		b	.L308
 4976              	.LVL588:
 4977              	.L326:
 972:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 4978              		.loc 1 972 0
 4979 2a90 0300A0E1 		mov	r0, r3
 4980              	.LVL589:
 4981 2a94 0A10A0E1 		mov	r1, r10
 4982 2a98 FEFFFFEB 		bl	SensorGetControl
 4983              	.LVL590:
 974:../uvc.c      **** 		 	 		 }
 4984              		.loc 1 974 0
 4985 2a9c 0130A0E3 		mov	r3, #1
 4986 2aa0 A530C7E5 		strb	r3, [r7, #165]
 973:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 4987              		.loc 1 973 0
 4988 2aa4 7102C6E5 		strb	r0, [r6, #625]
 4989 2aa8 21FCFFEA 		b	.L327
 4990              	.LVL591:
 4991              	.L435:
 879:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 4992              		.loc 1 879 0
 4993 2aac 02005AE3 		cmp	r10, #2
 4994 2ab0 1D00008A 		bhi	.L439
 4995              	.LVL592:
 4996              	.L318:
 884:../uvc.c      **** 					 }
 4997              		.loc 1 884 0
 4998 2ab4 04A08AE2 		add	r10, r10, #4
 4999              	.LVL593:
 5000 2ab8 FFA00AE2 		and	r10, r10, #255
 5001              	.LVL594:
 5002 2abc 82FBFFEA 		b	.L428
 5003              	.LVL595:
 5004              	.L385:
1320:../uvc.c      **** 									 dataIdx++;
 5005              		.loc 1 1320 0
 5006 2ac0 8010A0E3 		mov	r1, #128
 5007 2ac4 0030A0E3 		mov	r3, #0
 5008 2ac8 0A008DE8 		stmia	sp, {r1, r3}
 5009 2acc 80071FE5 		ldr	r0, .L440+72
 5010 2ad0 0920A0E1 		mov	r2, r9
 5011 2ad4 0730A0E1 		mov	r3, r7
 5012 2ad8 1B10A0E3 		mov	r1, #27
 5013 2adc FEFFFFEB 		bl	cmdSet
 5014              	.LVL596:
1322:../uvc.c      **** 								 }
 5015              		.loc 1 1322 0
 5016 2ae0 18C09DE5 		ldr	ip, [sp, #24]
 5017 2ae4 0110A0E3 		mov	r1, #1
 5018 2ae8 04108DE5 		str	r1, [sp, #4]
 5019 2aec 00C08DE5 		str	ip, [sp]
 5020 2af0 0820A0E1 		mov	r2, r8
 5021 2af4 0730A0E1 		mov	r3, r7
 5022 2af8 1B10A0E3 		mov	r1, #27
 5023 2afc B0071FE5 		ldr	r0, .L440+72
 5024 2b00 FEFFFFEB 		bl	cmdSet
 5025              	.LVL597:
 5026 2b04 2AFEFFEA 		b	.L384
 5027              	.LVL598:
 5028              	.L437:
1295:../uvc.c      **** 								 }
 5029              		.loc 1 1295 0
 5030 2b08 0010A0E3 		mov	r1, #0
 5031 2b0c 04108DE5 		str	r1, [sp, #4]
 5032 2b10 00C08DE5 		str	ip, [sp]
 5033 2b14 0A20A0E1 		mov	r2, r10
 5034 2b18 0830A0E1 		mov	r3, r8
 5035 2b1c 1910A0E3 		mov	r1, #25
 5036 2b20 D4071FE5 		ldr	r0, .L440+72
 5037 2b24 FEFFFFEB 		bl	cmdSet
 5038              	.LVL599:
 5039 2b28 46FDFFEA 		b	.L381
 5040              	.LVL600:
 5041              	.L439:
 880:../uvc.c      **** 							sendData = 0; //set back to default
 5042              		.loc 1 880 0
 5043 2b2c 0A30A0E1 		mov	r3, r10
 5044 2b30 0400A0E3 		mov	r0, #4
 5045              	.LVL601:
 5046 2b34 E4171FE5 		ldr	r1, .L440+76
 5047 2b38 FEFFFFEB 		bl	CyU3PDebugPrint
 5048              	.LVL602:
 882:../uvc.c      **** 						}
 5049              		.loc 1 882 0
 5050 2b3c 0030A0E3 		mov	r3, #0
 881:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 5051              		.loc 1 881 0
 5052 2b40 03A0A0E1 		mov	r10, r3
 882:../uvc.c      **** 						}
 5053              		.loc 1 882 0
 5054 2b44 9934C4E5 		strb	r3, [r4, #1177]
 5055 2b48 D9FFFFEA 		b	.L318
 5056              	.LVL603:
 5057              	.L409:
1583:../uvc.c      **** 									Data0 = 4; //set to default.
 5058              		.loc 1 1583 0
 5059 2b4c 0400A0E3 		mov	r0, #4
 5060 2b50 00181FE5 		ldr	r1, .L440+76
 5061 2b54 18309DE5 		ldr	r3, [sp, #24]
 5062 2b58 FEFFFFEB 		bl	CyU3PDebugPrint
 5063              	.LVL604:
1584:../uvc.c      **** 					 			 }
 5064              		.loc 1 1584 0
 5065 2b5c 0480A0E3 		mov	r8, #4
 5066 2b60 63FEFFEA 		b	.L408
 5067              		.cfi_endproc
 5068              	.LFE3:
 5070              		.align	2
 5071              		.global	CTControlHandle
 5073              	CTControlHandle:
 5074              	.LFB4:
1659:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5075              		.loc 1 1659 0
 5076              		.cfi_startproc
 5077              		@ args = 0, pretend = 0, frame = 24
 5078              		@ frame_needed = 0, uses_anonymous_args = 0
 5079              	.LVL605:
 5080 2b64 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5081              	.LCFI19:
 5082              		.cfi_def_cfa_offset 36
 5083              		.cfi_offset 4, -36
 5084              		.cfi_offset 5, -32
 5085              		.cfi_offset 6, -28
 5086              		.cfi_offset 7, -24
 5087              		.cfi_offset 8, -20
 5088              		.cfi_offset 9, -16
 5089              		.cfi_offset 10, -12
 5090              		.cfi_offset 11, -8
 5091              		.cfi_offset 14, -4
1678:../uvc.c      **** 
 5092              		.loc 1 1678 0
 5093 2b68 28B89FE5 		ldr	fp, .L480
1670:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5094              		.loc 1 1670 0
 5095 2b6c 28389FE5 		ldr	r3, .L480+4
1678:../uvc.c      **** 
 5096              		.loc 1 1678 0
 5097 2b70 0050DBE5 		ldrb	r5, [fp]	@ zero_extendqisi2
1670:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5098              		.loc 1 1670 0
 5099 2b74 8080A0E1 		mov	r8, r0, asl #1
 5100 2b78 002088E0 		add	r2, r8, r0
 5101 2b7c 822183E0 		add	r2, r3, r2, asl #3
1680:../uvc.c      **** 		 {
 5102              		.loc 1 1680 0
 5103 2b80 830055E3 		cmp	r5, #131
1659:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5104              		.loc 1 1659 0
 5105 2b84 34D04DE2 		sub	sp, sp, #52
 5106              	.LCFI20:
 5107              		.cfi_def_cfa_offset 88
1659:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 5108              		.loc 1 1659 0
 5109 2b88 0060A0E1 		mov	r6, r0
1670:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 5110              		.loc 1 1670 0
 5111 2b8c 9795D2E5 		ldrb	r9, [r2, #1431]	@ zero_extendqisi2
 5112              	.LVL606:
1671:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 5113              		.loc 1 1671 0
 5114 2b90 88A5D2E5 		ldrb	r10, [r2, #1416]	@ zero_extendqisi2
 5115              	.LVL607:
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 5116              		.loc 1 1673 0
 5117 2b94 8A75D2E5 		ldrb	r7, [r2, #1418]	@ zero_extendqisi2
 5118              	.LVL608:
1680:../uvc.c      **** 		 {
 5119              		.loc 1 1680 0
 5120 2b98 8000000A 		beq	.L444
 5121 2b9c 2600009A 		bls	.L478
 5122 2ba0 850055E3 		cmp	r5, #133
 5123 2ba4 7200000A 		beq	.L449
 5124 2ba8 5000003A 		bcc	.L450
 5125 2bac 860055E3 		cmp	r5, #134
 5126 2bb0 4300000A 		beq	.L451
 5127 2bb4 870055E3 		cmp	r5, #135
 5128 2bb8 5F00001A 		bne	.L443
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 5129              		.loc 1 1742 0
 5130 2bbc 93C5D2E5 		ldrb	ip, [r2, #1427]	@ zero_extendqisi2
 5131 2bc0 D8479FE5 		ldr	r4, .L480+8
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5132              		.loc 1 1743 0
 5133 2bc4 9425D2E5 		ldrb	r2, [r2, #1428]	@ zero_extendqisi2
 5134              	.LVL609:
 5135              	.L477:
1720:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5136              		.loc 1 1720 0
 5137 2bc8 0A1056E2 		subs	r1, r6, #10
 5138 2bcc 006071E2 		rsbs	r6, r1, #0
 5139 2bd0 0160B6E0 		adcs	r6, r6, r1
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5140              		.loc 1 1722 0
 5141 2bd4 0030A0E3 		mov	r3, #0
 5142              	.LVL610:
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5143              		.loc 1 1723 0
 5144 2bd8 281084E2 		add	r1, r4, #40
 5145 2bdc 0700A0E1 		mov	r0, r7
 5146              	.LVL611:
1720:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 5147              		.loc 1 1720 0
 5148 2be0 2A60C4E5 		strb	r6, [r4, #42]
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5149              		.loc 1 1718 0
 5150 2be4 28C0C4E5 		strb	ip, [r4, #40]
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5151              		.loc 1 1719 0
 5152 2be8 2920C4E5 		strb	r2, [r4, #41]
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 5153              		.loc 1 1722 0
 5154 2bec 2B30C4E5 		strb	r3, [r4, #43]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5155              		.loc 1 1723 0
 5156 2bf0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5157              	.LVL612:
 5158 2bf4 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
1725:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 5159              		.loc 1 1725 0
 5160 2bf8 FF80A0E3 		mov	r8, #255
 5161 2bfc 0860A0E1 		mov	r6, r8
 5162              	.LVL613:
 5163              	.L453:
1893:../uvc.c      **** }
 5164              		.loc 1 1893 0
 5165 2c00 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5166 2c04 FFC0A0E3 		mov	ip, #255
 5167 2c08 04108DE5 		str	r1, [sp, #4]
 5168 2c0c 10108DE5 		str	r1, [sp, #16]
 5169 2c10 08008DE5 		str	r0, [sp, #8]
 5170 2c14 00808DE5 		str	r8, [sp]
 5171 2c18 14708DE5 		str	r7, [sp, #20]
 5172 2c1c 0520A0E1 		mov	r2, r5
 5173 2c20 0630A0E1 		mov	r3, r6
 5174 2c24 0CC08DE5 		str	ip, [sp, #12]
 5175 2c28 74179FE5 		ldr	r1, .L480+12
 5176 2c2c 0400A0E3 		mov	r0, #4
 5177 2c30 FEFFFFEB 		bl	CyU3PDebugPrint
 5178              	.LVL614:
1894:../uvc.c      **** 
 5179              		.loc 1 1894 0
 5180 2c34 34D08DE2 		add	sp, sp, #52
 5181              		@ sp needed
 5182 2c38 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5183              	.LVL615:
 5184              	.L478:
1680:../uvc.c      **** 		 {
 5185              		.loc 1 1680 0
 5186 2c3c 810055E3 		cmp	r5, #129
 5187 2c40 2E00000A 		beq	.L446
 5188 2c44 1A00008A 		bhi	.L447
 5189 2c48 010055E3 		cmp	r5, #1
 5190 2c4c 3A00001A 		bne	.L443
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 5191              		.loc 1 1751 0
 5192 2c50 48479FE5 		ldr	r4, .L480+8
 5193 2c54 2E208DE2 		add	r2, sp, #46
 5194              	.LVL616:
 5195 2c58 2000A0E3 		mov	r0, #32
 5196              	.LVL617:
 5197 2c5c 281084E2 		add	r1, r4, #40
 5198 2c60 18308DE5 		str	r3, [sp, #24]
 5199 2c64 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5200              	.LVL618:
1753:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5201              		.loc 1 1753 0
 5202 2c68 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
1757:../uvc.c      **** 			  {
 5203              		.loc 1 1757 0
 5204 2c6c 012046E2 		sub	r2, r6, #1
1753:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 5205              		.loc 1 1753 0
 5206 2c70 1CC08DE5 		str	ip, [sp, #28]
 5207              	.LVL619:
1754:../uvc.c      **** 			  value = Data1;
 5208              		.loc 1 1754 0
 5209 2c74 29C0D4E5 		ldrb	ip, [r4, #41]	@ zero_extendqisi2
1757:../uvc.c      **** 			  {
 5210              		.loc 1 1757 0
 5211 2c78 18309DE5 		ldr	r3, [sp, #24]
1754:../uvc.c      **** 			  value = Data1;
 5212              		.loc 1 1754 0
 5213 2c7c 20C08DE5 		str	ip, [sp, #32]
 5214              	.LVL620:
1757:../uvc.c      **** 			  {
 5215              		.loc 1 1757 0
 5216 2c80 090052E3 		cmp	r2, #9
 5217 2c84 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5218 2c88 1D0100EA 		b	.L454
 5219              	.L456:
 5220 2c8c BC300000 		.word	.L455
 5221 2c90 04310000 		.word	.L454
 5222 2c94 BC2E0000 		.word	.L457
 5223 2c98 04310000 		.word	.L454
 5224 2c9c 04310000 		.word	.L454
 5225 2ca0 04310000 		.word	.L454
 5226 2ca4 2C2E0000 		.word	.L458
 5227 2ca8 04310000 		.word	.L454
 5228 2cac 04310000 		.word	.L454
 5229 2cb0 B02D0000 		.word	.L459
 5230              	.LVL621:
 5231              	.L447:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 5232              		.loc 1 1709 0
 5233 2cb4 8BC5D2E5 		ldrb	ip, [r2, #1419]	@ zero_extendqisi2
 5234 2cb8 E0469FE5 		ldr	r4, .L480+8
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 5235              		.loc 1 1710 0
 5236 2cbc 8C25D2E5 		ldrb	r2, [r2, #1420]	@ zero_extendqisi2
 5237              	.LVL622:
 5238 2cc0 C0FFFFEA 		b	.L477
 5239              	.LVL623:
 5240              	.L451:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 5241              		.loc 1 1736 0
 5242 2cc4 D4469FE5 		ldr	r4, .L480+8
 5243 2cc8 9135D2E5 		ldrb	r3, [r2, #1425]	@ zero_extendqisi2
 5244 2ccc 0410A0E1 		mov	r1, r4
 5245 2cd0 2830E1E5 		strb	r3, [r1, #40]!
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5246              		.loc 1 1737 0
 5247 2cd4 0100A0E3 		mov	r0, #1
 5248              	.LVL624:
1740:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5249              		.loc 1 1740 0
 5250 2cd8 FF80A0E3 		mov	r8, #255
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5251              		.loc 1 1737 0
 5252 2cdc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5253              	.LVL625:
1740:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 5254              		.loc 1 1740 0
 5255 2ce0 0860A0E1 		mov	r6, r8
 5256 2ce4 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
 5257 2ce8 0170A0E3 		mov	r7, #1
 5258 2cec C3FFFFEA 		b	.L453
 5259              	.LVL626:
 5260              	.L450:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 5261              		.loc 1 1727 0
 5262 2cf0 8FC5D2E5 		ldrb	ip, [r2, #1423]	@ zero_extendqisi2
 5263 2cf4 A4469FE5 		ldr	r4, .L480+8
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5264              		.loc 1 1728 0
 5265 2cf8 9025D2E5 		ldrb	r2, [r2, #1424]	@ zero_extendqisi2
 5266              	.LVL627:
 5267 2cfc B1FFFFEA 		b	.L477
 5268              	.LVL628:
 5269              	.L446:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5270              		.loc 1 1694 0
 5271 2d00 98469FE5 		ldr	r4, .L480+8
 5272 2d04 9595D2E5 		ldrb	r9, [r2, #1429]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5273              		.loc 1 1695 0
 5274 2d08 96C5D2E5 		ldrb	ip, [r2, #1430]	@ zero_extendqisi2
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5275              		.loc 1 1696 0
 5276 2d0c 0030A0E3 		mov	r3, #0
1702:../uvc.c      **** 
 5277              		.loc 1 1702 0
 5278 2d10 281084E2 		add	r1, r4, #40
 5279 2d14 0700A0E1 		mov	r0, r7
 5280              	.LVL629:
1707:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5281              		.loc 1 1707 0
 5282 2d18 FF80A0E3 		mov	r8, #255
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 5283              		.loc 1 1695 0
 5284 2d1c 29C0C4E5 		strb	ip, [r4, #41]
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 5285              		.loc 1 1694 0
 5286 2d20 2890C4E5 		strb	r9, [r4, #40]
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 5287              		.loc 1 1696 0
 5288 2d24 2A30C4E5 		strb	r3, [r4, #42]
1697:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 5289              		.loc 1 1697 0
 5290 2d28 2B30C4E5 		strb	r3, [r4, #43]
 5291              	.LVL630:
1707:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5292              		.loc 1 1707 0
 5293 2d2c 0860A0E1 		mov	r6, r8
 5294              	.LVL631:
1702:../uvc.c      **** 
 5295              		.loc 1 1702 0
 5296 2d30 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5297              	.LVL632:
 5298 2d34 0900A0E1 		mov	r0, r9
1707:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 5299              		.loc 1 1707 0
 5300 2d38 B0FFFFEA 		b	.L453
 5301              	.LVL633:
 5302              	.L443:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 5303              		.loc 1 1887 0
 5304 2d3c 0000A0E3 		mov	r0, #0
 5305              	.LVL634:
 5306 2d40 0020A0E1 		mov	r2, r0
 5307              	.LVL635:
 5308 2d44 0110A0E3 		mov	r1, #1
 5309 2d48 FEFFFFEB 		bl	CyU3PUsbStall
 5310              	.LVL636:
1888:../uvc.c      **** 			  break;
 5311              		.loc 1 1888 0
 5312 2d4c 0620A0E1 		mov	r2, r6
 5313 2d50 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5314 2d54 0400A0E3 		mov	r0, #4
 5315 2d58 48169FE5 		ldr	r1, .L480+16
 5316 2d5c FEFFFFEB 		bl	CyU3PDebugPrint
 5317              	.LVL637:
1889:../uvc.c      **** 		 }
 5318              		.loc 1 1889 0
 5319 2d60 FF00A0E3 		mov	r0, #255
 5320 2d64 34469FE5 		ldr	r4, .L480+8
 5321 2d68 0080A0E1 		mov	r8, r0
 5322 2d6c 0060A0E1 		mov	r6, r0
 5323 2d70 A2FFFFEA 		b	.L453
 5324              	.LVL638:
 5325              	.L449:
1684:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5326              		.loc 1 1684 0
 5327 2d74 24469FE5 		ldr	r4, .L480+8
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5328              		.loc 1 1685 0
 5329 2d78 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5330              		.loc 1 1686 0
 5331 2d7c 281084E2 		add	r1, r4, #40
 5332 2d80 0200A0E3 		mov	r0, #2
 5333              	.LVL639:
1688:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5334              		.loc 1 1688 0
 5335 2d84 FF80A0E3 		mov	r8, #255
1684:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 5336              		.loc 1 1684 0
 5337 2d88 2870C4E5 		strb	r7, [r4, #40]
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5338              		.loc 1 1685 0
 5339 2d8c 2930C4E5 		strb	r3, [r4, #41]
1688:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5340              		.loc 1 1688 0
 5341 2d90 0860A0E1 		mov	r6, r8
 5342              	.LVL640:
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 5343              		.loc 1 1686 0
 5344 2d94 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 5345              	.LVL641:
 5346 2d98 2800D4E5 		ldrb	r0, [r4, #40]	@ zero_extendqisi2
1688:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 5347              		.loc 1 1688 0
 5348 2d9c 97FFFFEA 		b	.L453
 5349              	.LVL642:
 5350              	.L444:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 5351              		.loc 1 1718 0
 5352 2da0 8DC5D2E5 		ldrb	ip, [r2, #1421]	@ zero_extendqisi2
 5353 2da4 F4459FE5 		ldr	r4, .L480+8
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 5354              		.loc 1 1719 0
 5355 2da8 8E25D2E5 		ldrb	r2, [r2, #1422]	@ zero_extendqisi2
 5356              	.LVL643:
 5357 2dac 85FFFFEA 		b	.L477
 5358              	.LVL644:
 5359              	.L459:
1866:../uvc.c      **** 					  if(getData == 1)
 5360              		.loc 1 1866 0
 5361 2db0 F4659FE5 		ldr	r6, .L480+20
 5362 2db4 0010E0E3 		mvn	r1, #0
 5363 2db8 1C0096E5 		ldr	r0, [r6, #28]
 5364 2dbc FEFFFFEB 		bl	_txe_mutex_get
 5365              	.LVL645:
1867:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5366              		.loc 1 1867 0
 5367 2dc0 1CC09DE5 		ldr	ip, [sp, #28]
 5368 2dc4 01005CE3 		cmp	ip, #1
1868:../uvc.c      **** 					  else if(getData == 0xff)
 5369              		.loc 1 1868 0
 5370 2dc8 0400A003 		moveq	r0, #4
1867:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 5371              		.loc 1 1867 0
 5372 2dcc 6901000A 		beq	.L476
1869:../uvc.c      **** 						  cmdSet(cmdQuptr, 0x23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 5373              		.loc 1 1869 0
 5374 2dd0 FF005CE3 		cmp	ip, #255
 5375 2dd4 6601000A 		beq	.L479
1872:../uvc.c      **** 					  //dataIdx++;
 5376              		.loc 1 1872 0
 5377 2dd8 0010A0E3 		mov	r1, #0
 5378 2ddc 00108DE5 		str	r1, [sp]
 5379 2de0 04108DE5 		str	r1, [sp, #4]
 5380 2de4 0A20A0E1 		mov	r2, r10
 5381 2de8 0930A0E1 		mov	r3, r9
 5382 2dec 0600A0E1 		mov	r0, r6
 5383 2df0 2310A0E3 		mov	r1, #35
 5384 2df4 FEFFFFEB 		bl	cmdSet
 5385              	.LVL646:
 5386              	.L471:
1875:../uvc.c      **** #endif
 5387              		.loc 1 1875 0
 5388 2df8 1C0096E5 		ldr	r0, [r6, #28]
 5389 2dfc FEFFFFEB 		bl	_txe_mutex_put
 5390              	.LVL647:
1877:../uvc.c      **** 					  break;
 5391              		.loc 1 1877 0
 5392 2e00 2A10D4E5 		ldrb	r1, [r4, #42]	@ zero_extendqisi2
 5393 2e04 1C609DE5 		ldr	r6, [sp, #28]
 5394 2e08 20809DE5 		ldr	r8, [sp, #32]
 5395 2e0c 00108DE5 		str	r1, [sp]
 5396 2e10 0620A0E1 		mov	r2, r6
 5397 2e14 0830A0E1 		mov	r3, r8
 5398 2e18 0400A0E3 		mov	r0, #4
 5399 2e1c 8C159FE5 		ldr	r1, .L480+24
 5400 2e20 FEFFFFEB 		bl	CyU3PDebugPrint
 5401              	.LVL648:
1878:../uvc.c      **** 
 5402              		.loc 1 1878 0
 5403 2e24 FF00A0E3 		mov	r0, #255
 5404 2e28 74FFFFEA 		b	.L453
 5405              	.LVL649:
 5406              	.L458:
1843:../uvc.c      **** 					  {
 5407              		.loc 1 1843 0
 5408 2e2c AD05D3E5 		ldrb	r0, [r3, #1453]	@ zero_extendqisi2
 5409 2e30 64C59FE5 		ldr	ip, .L480+4
 5410 2e34 010050E3 		cmp	r0, #1
 5411 2e38 08005013 		cmpne	r0, #8
 5412 2e3c 0000A013 		movne	r0, #0
 5413 2e40 0100A003 		moveq	r0, #1
 5414 2e44 4601001A 		bne	.L468
 5415              	.LVL650:
1846:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 5416              		.loc 1 1846 0
 5417 2e48 5CB59FE5 		ldr	fp, .L480+20
 5418 2e4c 0010E0E3 		mvn	r1, #0
 5419 2e50 1C009BE5 		ldr	r0, [fp, #28]
 5420 2e54 18C08DE5 		str	ip, [sp, #24]
 5421 2e58 FEFFFFEB 		bl	_txe_mutex_get
 5422              	.LVL651:
1847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5423              		.loc 1 1847 0
 5424 2e5c 1C009DE5 		ldr	r0, [sp, #28]
 5425 2e60 0010A0E3 		mov	r1, #0
 5426 2e64 0A20A0E1 		mov	r2, r10
 5427 2e68 0930A0E1 		mov	r3, r9
 5428 2e6c 00008DE5 		str	r0, [sp]
 5429 2e70 04108DE5 		str	r1, [sp, #4]
 5430 2e74 0B00A0E1 		mov	r0, fp
 5431 2e78 2210A0E3 		mov	r1, #34
 5432 2e7c FEFFFFEB 		bl	cmdSet
 5433              	.LVL652:
1848:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 5434              		.loc 1 1848 0
 5435 2e80 1C009BE5 		ldr	r0, [fp, #28]
 5436 2e84 FEFFFFEB 		bl	_txe_mutex_put
 5437              	.LVL653:
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5438              		.loc 1 1851 0
 5439 2e88 18C09DE5 		ldr	ip, [sp, #24]
 5440 2e8c 1C109DE5 		ldr	r1, [sp, #28]
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5441              		.loc 1 1852 0
 5442 2e90 20209DE5 		ldr	r2, [sp, #32]
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5443              		.loc 1 1851 0
 5444 2e94 066088E0 		add	r6, r8, r6
 5445 2e98 86C18CE0 		add	ip, ip, r6, asl #3
1853:../uvc.c      **** 					  }else{
 5446              		.loc 1 1853 0
 5447 2e9c 0130A0E3 		mov	r3, #1
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 5448              		.loc 1 1851 0
 5449 2ea0 9515CCE5 		strb	r1, [ip, #1429]
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 5450              		.loc 1 1852 0
 5451 2ea4 9625CCE5 		strb	r2, [ip, #1430]
1853:../uvc.c      **** 					  }else{
 5452              		.loc 1 1853 0
 5453 2ea8 9835CCE5 		strb	r3, [ip, #1432]
 5454              	.LVL654:
 5455              	.L469:
 5456 2eac 2860D4E5 		ldrb	r6, [r4, #40]	@ zero_extendqisi2
 5457 2eb0 2980D4E5 		ldrb	r8, [r4, #41]	@ zero_extendqisi2
1860:../uvc.c      **** 			  	  case ZmOpRCtlID10:
 5458              		.loc 1 1860 0
 5459 2eb4 FF00A0E3 		mov	r0, #255
 5460 2eb8 50FFFFEA 		b	.L453
 5461              	.LVL655:
 5462              	.L457:
1809:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 5463              		.loc 1 1809 0
 5464 2ebc AD35D3E5 		ldrb	r3, [r3, #1453]	@ zero_extendqisi2
 5465 2ec0 010053E3 		cmp	r3, #1
 5466 2ec4 04005313 		cmpne	r3, #4
 5467 2ec8 2001001A 		bne	.L466
1808:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 5468              		.loc 1 1808 0
 5469 2ecc 1CC09DE5 		ldr	ip, [sp, #28]
 5470 2ed0 20009DE5 		ldr	r0, [sp, #32]
 5471 2ed4 00348CE1 		orr	r3, ip, r0, asl #8
1810:../uvc.c      **** 					  {
 5472              		.loc 1 1810 0
 5473 2ed8 F90053E3 		cmp	r3, #249
 5474 2edc 1B01008A 		bhi	.L466
 5475              	.LVL656:
1815:../uvc.c      **** 							}else{
 5476              		.loc 1 1815 0
 5477 2ee0 C80043E2 		sub	r0, r3, #200
 5478 2ee4 C80053E3 		cmp	r3, #200
1817:../uvc.c      **** 							}
 5479              		.loc 1 1817 0
 5480 2ee8 C82063E2 		rsb	r2, r3, #200
 5481 2eec C0149FE5 		ldr	r1, .L480+28
 5482 2ef0 0208A091 		movls	r0, r2, asl #16
 5483 2ef4 0008A081 		movhi	r0, r0, asl #16
 5484 2ef8 642063E2 		rsb	r2, r3, #100
 5485 2efc 640053E3 		cmp	r3, #100
1815:../uvc.c      **** 							}else{
 5486              		.loc 1 1815 0
 5487 2f00 64C043E2 		sub	ip, r3, #100
 5488 2f04 2008A0E1 		mov	r0, r0, lsr #16
 5489 2f08 0C28A081 		movhi	r2, ip, asl #16
 5490 2f0c 0228A091 		movls	r2, r2, asl #16
 5491 2f10 010050E1 		cmp	r0, r1
 5492 2f14 00E0A031 		movcc	lr, r0
 5493 2f18 01E0A021 		movcs	lr, r1
 5494 2f1c 010050E1 		cmp	r0, r1
 5495 2f20 27C043E2 		sub	ip, r3, #39
1817:../uvc.c      **** 							}
 5496              		.loc 1 1817 0
 5497 2f24 271063E2 		rsb	r1, r3, #39
 5498 2f28 00B0A033 		movcc	fp, #0
 5499 2f2c 01B0A023 		movcs	fp, #1
 5500 2f30 270053E3 		cmp	r3, #39
1815:../uvc.c      **** 							}else{
 5501              		.loc 1 1815 0
 5502 2f34 140043E2 		sub	r0, r3, #20
 5503 2f38 01C8A091 		movls	ip, r1, asl #16
 5504 2f3c 2228A0E1 		mov	r2, r2, lsr #16
1817:../uvc.c      **** 							}
 5505              		.loc 1 1817 0
 5506 2f40 141063E2 		rsb	r1, r3, #20
 5507 2f44 0CC8A081 		movhi	ip, ip, asl #16
 5508 2f48 140053E3 		cmp	r3, #20
 5509 2f4c 0018A081 		movhi	r1, r0, asl #16
 5510 2f50 0118A091 		movls	r1, r1, asl #16
 5511 2f54 0E0052E1 		cmp	r2, lr
1815:../uvc.c      **** 							}else{
 5512              		.loc 1 1815 0
 5513 2f58 0A0043E2 		sub	r0, r3, #10
 5514 2f5c 01B0A033 		movcc	fp, #1
 5515 2f60 2CC8A0E1 		mov	ip, ip, lsr #16
 5516 2f64 02005EE1 		cmp	lr, r2
 5517 2f68 0E20A031 		movcc	r2, lr
 5518 2f6c 0A0053E3 		cmp	r3, #10
 5519 2f70 21E8A0E1 		mov	lr, r1, lsr #16
1817:../uvc.c      **** 							}
 5520              		.loc 1 1817 0
 5521 2f74 0A1063E2 		rsb	r1, r3, #10
 5522 2f78 0118A091 		movls	r1, r1, asl #16
 5523 2f7c 0018A081 		movhi	r1, r0, asl #16
 5524 2f80 0C0052E1 		cmp	r2, ip
 5525 2f84 02B0A083 		movhi	fp, #2
 5526 2f88 24B08DE5 		str	fp, [sp, #36]
1815:../uvc.c      **** 							}else{
 5527              		.loc 1 1815 0
 5528 2f8c 050043E2 		sub	r0, r3, #5
 5529 2f90 02005CE1 		cmp	ip, r2
 5530 2f94 0C20A031 		movcc	r2, ip
 5531 2f98 21B8A0E1 		mov	fp, r1, lsr #16
1817:../uvc.c      **** 							}
 5532              		.loc 1 1817 0
 5533 2f9c 05C063E2 		rsb	ip, r3, #5
 5534 2fa0 050053E3 		cmp	r3, #5
 5535 2fa4 24109DE5 		ldr	r1, [sp, #36]
 5536 2fa8 00C8A081 		movhi	ip, r0, asl #16
 5537 2fac 0CC8A091 		movls	ip, ip, asl #16
 5538 2fb0 0E0052E1 		cmp	r2, lr
 5539 2fb4 0310A083 		movhi	r1, #3
 5540 2fb8 24108DE5 		str	r1, [sp, #36]
 5541 2fbc 02005EE1 		cmp	lr, r2
 5542 2fc0 0E00A031 		movcc	r0, lr
 5543 2fc4 0200A021 		movcs	r0, r2
 5544 2fc8 021063E2 		rsb	r1, r3, #2
1815:../uvc.c      **** 							}else{
 5545              		.loc 1 1815 0
 5546 2fcc 022043E2 		sub	r2, r3, #2
 5547 2fd0 020053E3 		cmp	r3, #2
 5548 2fd4 0128A091 		movls	r2, r1, asl #16
 5549 2fd8 0228A081 		movhi	r2, r2, asl #16
 5550 2fdc 0B0050E1 		cmp	r0, fp
 5551 2fe0 24E09DE5 		ldr	lr, [sp, #36]
 5552 2fe4 2CC8A0E1 		mov	ip, ip, lsr #16
 5553 2fe8 04E0A083 		movhi	lr, #4
 5554 2fec 00005BE1 		cmp	fp, r0
 5555 2ff0 0B00A031 		movcc	r0, fp
 5556 2ff4 00005CE1 		cmp	ip, r0
 5557 2ff8 0C10A031 		movcc	r1, ip
 5558 2ffc 0010A021 		movcs	r1, r0
 5559 3000 0C0050E1 		cmp	r0, ip
 5560 3004 05E0A083 		movhi	lr, #5
 5561 3008 01C043E2 		sub	ip, r3, #1
 5562 300c 010053E3 		cmp	r3, #1
1817:../uvc.c      **** 							}
 5563              		.loc 1 1817 0
 5564 3010 010063E2 		rsb	r0, r3, #1
 5565 3014 0C38A081 		movhi	r3, ip, asl #16
1827:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 5566              		.loc 1 1827 0
 5567 3018 8CC39FE5 		ldr	ip, .L480+20
 5568 301c 2228A0E1 		mov	r2, r2, lsr #16
 5569 3020 0038A091 		movls	r3, r0, asl #16
 5570 3024 010052E1 		cmp	r2, r1
 5571 3028 0200A031 		movcc	r0, r2
 5572 302c 0100A021 		movcs	r0, r1
 5573 3030 020051E1 		cmp	r1, r2
 5574 3034 0E20A091 		movls	r2, lr
 5575 3038 0620A083 		movhi	r2, #6
 5576              	.LVL657:
 5577 303c 0010E0E3 		mvn	r1, #0
 5578              	.LVL658:
 5579 3040 230850E1 		cmp	r0, r3, lsr #16
 5580 3044 1C009CE5 		ldr	r0, [ip, #28]
 5581 3048 02B0A091 		movls	fp, r2
 5582 304c 07B0A083 		movhi	fp, #7
 5583              	.LVL659:
 5584 3050 18C08DE5 		str	ip, [sp, #24]
 5585 3054 FEFFFFEB 		bl	_txe_mutex_get
 5586              	.LVL660:
1828:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5587              		.loc 1 1828 0
 5588 3058 18C09DE5 		ldr	ip, [sp, #24]
1824:../uvc.c      **** 
 5589              		.loc 1 1824 0
 5590 305c 01B08BE2 		add	fp, fp, #1
 5591              	.LVL661:
1828:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5592              		.loc 1 1828 0
 5593 3060 0010A0E3 		mov	r1, #0
 5594 3064 0A20A0E1 		mov	r2, r10
 5595 3068 0930A0E1 		mov	r3, r9
 5596 306c 0C00A0E1 		mov	r0, ip
 5597 3070 04108DE5 		str	r1, [sp, #4]
 5598 3074 00B08DE5 		str	fp, [sp]
 5599 3078 0310A0E3 		mov	r1, #3
 5600 307c FEFFFFEB 		bl	cmdSet
 5601              	.LVL662:
1829:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
 5602              		.loc 1 1829 0
 5603 3080 18C09DE5 		ldr	ip, [sp, #24]
 5604 3084 1C009CE5 		ldr	r0, [ip, #28]
 5605 3088 FEFFFFEB 		bl	_txe_mutex_put
 5606              	.LVL663:
1835:../uvc.c      **** 					  }else{
 5607              		.loc 1 1835 0
 5608 308c 08C39FE5 		ldr	ip, .L480+4
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5609              		.loc 1 1832 0
 5610 3090 04239FE5 		ldr	r2, .L480+4
1835:../uvc.c      **** 					  }else{
 5611              		.loc 1 1835 0
 5612 3094 79B3CCE5 		strb	fp, [ip, #889]
1832:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 5613              		.loc 1 1832 0
 5614 3098 1CC09DE5 		ldr	ip, [sp, #28]
 5615 309c 063088E0 		add	r3, r8, r6
 5616 30a0 833182E0 		add	r3, r2, r3, asl #3
 5617 30a4 95C5C3E5 		strb	ip, [r3, #1429]
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5618              		.loc 1 1833 0
 5619 30a8 20C09DE5 		ldr	ip, [sp, #32]
1834:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5620              		.loc 1 1834 0
 5621 30ac 0120A0E3 		mov	r2, #1
1833:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 5622              		.loc 1 1833 0
 5623 30b0 96C5C3E5 		strb	ip, [r3, #1430]
1834:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 5624              		.loc 1 1834 0
 5625 30b4 9825C3E5 		strb	r2, [r3, #1432]
1835:../uvc.c      **** 					  }else{
 5626              		.loc 1 1835 0
 5627 30b8 7BFFFFEA 		b	.L469
 5628              	.LVL664:
 5629              	.L455:
1766:../uvc.c      **** 						case 1:
 5630              		.loc 1 1766 0
 5631 30bc 1CC09DE5 		ldr	ip, [sp, #28]
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5632              		.loc 1 1762 0
 5633 30c0 066088E0 		add	r6, r8, r6
 5634 30c4 866183E0 		add	r6, r3, r6, asl #3
1763:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5635              		.loc 1 1763 0
 5636 30c8 0110A0E3 		mov	r1, #1
1766:../uvc.c      **** 						case 1:
 5637              		.loc 1 1766 0
 5638 30cc 01204CE2 		sub	r2, ip, #1
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 5639              		.loc 1 1762 0
 5640 30d0 95C5C6E5 		strb	ip, [r6, #1429]
1763:../uvc.c      **** 				    getData = glEp0Buffer[0];
 5641              		.loc 1 1763 0
 5642 30d4 9815C6E5 		strb	r1, [r6, #1432]
 5643              	.LVL665:
1766:../uvc.c      **** 						case 1:
 5644              		.loc 1 1766 0
 5645 30d8 070052E3 		cmp	r2, #7
 5646 30dc 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 5647 30e0 960000EA 		b	.L460
 5648              	.L462:
 5649 30e4 DC320000 		.word	.L461
 5650 30e8 40320000 		.word	.L463
 5651 30ec 40330000 		.word	.L460
 5652 30f0 D8310000 		.word	.L464
 5653 30f4 40330000 		.word	.L460
 5654 30f8 40330000 		.word	.L460
 5655 30fc 40330000 		.word	.L460
 5656 3100 38310000 		.word	.L465
 5657              	.LVL666:
 5658              	.L454:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5659              		.loc 1 1881 0
 5660 3104 1CC09DE5 		ldr	ip, [sp, #28]
 5661 3108 068088E0 		add	r8, r8, r6
 5662 310c 888183E0 		add	r8, r3, r8, asl #3
1882:../uvc.c      **** 			  		 break;
 5663              		.loc 1 1882 0
 5664 3110 0620A0E1 		mov	r2, r6
 5665 3114 0030DBE5 		ldrb	r3, [fp]	@ zero_extendqisi2
 5666 3118 0400A0E3 		mov	r0, #4
 5667 311c 94129FE5 		ldr	r1, .L480+32
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 5668              		.loc 1 1881 0
 5669 3120 95C5C8E5 		strb	ip, [r8, #1429]
1882:../uvc.c      **** 			  		 break;
 5670              		.loc 1 1882 0
 5671 3124 FEFFFFEB 		bl	CyU3PDebugPrint
 5672              	.LVL667:
1883:../uvc.c      **** 			  }
 5673              		.loc 1 1883 0
 5674 3128 FF00A0E3 		mov	r0, #255
 5675 312c 0080A0E1 		mov	r8, r0
 5676 3130 0060A0E1 		mov	r6, r0
 5677 3134 B1FEFFEA 		b	.L453
 5678              	.LVL668:
 5679              	.L465:
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5680              		.loc 1 1785 0
 5681 3138 6C629FE5 		ldr	r6, .L480+20
1783:../uvc.c      **** 			  		    	dataIdx = 0;
 5682              		.loc 1 1783 0
 5683 313c 0080A0E3 		mov	r8, #0
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5684              		.loc 1 1785 0
 5685 3140 1C0096E5 		ldr	r0, [r6, #28]
 5686 3144 0010E0E3 		mvn	r1, #0
1783:../uvc.c      **** 			  		    	dataIdx = 0;
 5687              		.loc 1 1783 0
 5688 3148 7983C3E5 		strb	r8, [r3, #889]
 5689              	.LVL669:
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5690              		.loc 1 1785 0
 5691 314c FEFFFFEB 		bl	_txe_mutex_get
 5692              	.LVL670:
1786:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5693              		.loc 1 1786 0
 5694 3150 0A20A0E1 		mov	r2, r10
 5695 3154 0930A0E1 		mov	r3, r9
 5696 3158 1010A0E3 		mov	r1, #16
 5697 315c 00808DE5 		str	r8, [sp]
 5698 3160 04808DE5 		str	r8, [sp, #4]
 5699 3164 0600A0E1 		mov	r0, r6
 5700 3168 FEFFFFEB 		bl	cmdSet
 5701              	.LVL671:
1787:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 5702              		.loc 1 1787 0
 5703 316c 1C0096E5 		ldr	r0, [r6, #28]
 5704 3170 FEFFFFEB 		bl	_txe_mutex_put
 5705              	.LVL672:
 5706              	.LBB82:
 5707              	.LBB83:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5708              		.loc 1 680 0
 5709 3174 1C0096E5 		ldr	r0, [r6, #28]
 5710 3178 0010E0E3 		mvn	r1, #0
 5711 317c FEFFFFEB 		bl	_txe_mutex_get
 5712              	.LVL673:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5713              		.loc 1 681 0
 5714 3180 0130A0E3 		mov	r3, #1
 5715 3184 04808DE5 		str	r8, [sp, #4]
 5716 3188 0600A0E1 		mov	r0, r6
 5717 318c 00308DE5 		str	r3, [sp]
 5718 3190 2010A0E3 		mov	r1, #32
 5719 3194 2720A0E3 		mov	r2, #39
 5720 3198 3030A0E3 		mov	r3, #48
 5721 319c FEFFFFEB 		bl	cmdSet
 5722              	.LVL674:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5723              		.loc 1 682 0
 5724 31a0 0230A0E3 		mov	r3, #2
 5725 31a4 04808DE5 		str	r8, [sp, #4]
 5726 31a8 0600A0E1 		mov	r0, r6
 5727 31ac 00308DE5 		str	r3, [sp]
 5728 31b0 2110A0E3 		mov	r1, #33
 5729 31b4 2520A0E3 		mov	r2, #37
 5730 31b8 3030A0E3 		mov	r3, #48
 5731 31bc FEFFFFEB 		bl	cmdSet
 5732              	.LVL675:
 683:../uvc.c      **** }
 5733              		.loc 1 683 0
 5734 31c0 1C0096E5 		ldr	r0, [r6, #28]
 5735 31c4 FEFFFFEB 		bl	_txe_mutex_put
 5736              	.LVL676:
 5737 31c8 FF00A0E3 		mov	r0, #255
 5738 31cc 0080A0E1 		mov	r8, r0
 5739 31d0 0860A0E3 		mov	r6, #8
 5740 31d4 89FEFFEA 		b	.L453
 5741              	.LVL677:
 5742              	.L464:
 5743              	.LBE83:
 5744              	.LBE82:
 5745              	.LBB84:
 5746              	.LBB85:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5747              		.loc 1 680 0
 5748 31d8 CC619FE5 		ldr	r6, .L480+20
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5749              		.loc 1 681 0
 5750 31dc 0080A0E3 		mov	r8, #0
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5751              		.loc 1 680 0
 5752 31e0 0010E0E3 		mvn	r1, #0
 5753 31e4 1C0096E5 		ldr	r0, [r6, #28]
 5754 31e8 FEFFFFEB 		bl	_txe_mutex_get
 5755              	.LVL678:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5756              		.loc 1 681 0
 5757 31ec 0600A0E1 		mov	r0, r6
 5758 31f0 00808DE5 		str	r8, [sp]
 5759 31f4 04808DE5 		str	r8, [sp, #4]
 5760 31f8 2010A0E3 		mov	r1, #32
 5761 31fc 2720A0E3 		mov	r2, #39
 5762 3200 3030A0E3 		mov	r3, #48
 5763 3204 FEFFFFEB 		bl	cmdSet
 5764              	.LVL679:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5765              		.loc 1 682 0
 5766 3208 0130A0E3 		mov	r3, #1
 5767 320c 04808DE5 		str	r8, [sp, #4]
 5768 3210 0600A0E1 		mov	r0, r6
 5769 3214 00308DE5 		str	r3, [sp]
 5770 3218 2110A0E3 		mov	r1, #33
 5771 321c 2520A0E3 		mov	r2, #37
 5772 3220 3030A0E3 		mov	r3, #48
 5773 3224 FEFFFFEB 		bl	cmdSet
 5774              	.LVL680:
 683:../uvc.c      **** }
 5775              		.loc 1 683 0
 5776 3228 1C0096E5 		ldr	r0, [r6, #28]
 5777 322c FEFFFFEB 		bl	_txe_mutex_put
 5778              	.LVL681:
 5779 3230 FF00A0E3 		mov	r0, #255
 5780 3234 0080A0E1 		mov	r8, r0
 5781 3238 0460A0E3 		mov	r6, #4
 5782 323c 6FFEFFEA 		b	.L453
 5783              	.LVL682:
 5784              	.L463:
 5785              	.LBE85:
 5786              	.LBE84:
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5787              		.loc 1 1773 0
 5788 3240 64619FE5 		ldr	r6, .L480+20
1771:../uvc.c      **** 							dataIdx = 0;
 5789              		.loc 1 1771 0
 5790 3244 0080A0E3 		mov	r8, #0
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5791              		.loc 1 1773 0
 5792 3248 1C0096E5 		ldr	r0, [r6, #28]
 5793 324c 0010E0E3 		mvn	r1, #0
1771:../uvc.c      **** 							dataIdx = 0;
 5794              		.loc 1 1771 0
 5795 3250 7983C3E5 		strb	r8, [r3, #889]
 5796              	.LVL683:
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 5797              		.loc 1 1773 0
 5798 3254 FEFFFFEB 		bl	_txe_mutex_get
 5799              	.LVL684:
1774:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5800              		.loc 1 1774 0
 5801 3258 0A20A0E1 		mov	r2, r10
 5802 325c 0930A0E1 		mov	r3, r9
 5803 3260 1010A0E3 		mov	r1, #16
 5804 3264 00808DE5 		str	r8, [sp]
 5805 3268 04808DE5 		str	r8, [sp, #4]
 5806 326c 0600A0E1 		mov	r0, r6
 5807 3270 FEFFFFEB 		bl	cmdSet
 5808              	.LVL685:
1775:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 5809              		.loc 1 1775 0
 5810 3274 1C0096E5 		ldr	r0, [r6, #28]
 5811 3278 FEFFFFEB 		bl	_txe_mutex_put
 5812              	.LVL686:
 5813              	.LBB86:
 5814              	.LBB87:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5815              		.loc 1 680 0
 5816 327c 1C0096E5 		ldr	r0, [r6, #28]
 5817 3280 0010E0E3 		mvn	r1, #0
 5818 3284 FEFFFFEB 		bl	_txe_mutex_get
 5819              	.LVL687:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5820              		.loc 1 681 0
 5821 3288 00808DE5 		str	r8, [sp]
 5822 328c 04808DE5 		str	r8, [sp, #4]
 5823 3290 0600A0E1 		mov	r0, r6
 5824 3294 2010A0E3 		mov	r1, #32
 5825 3298 2720A0E3 		mov	r2, #39
 5826 329c 3030A0E3 		mov	r3, #48
 5827 32a0 FEFFFFEB 		bl	cmdSet
 5828              	.LVL688:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5829              		.loc 1 682 0
 5830 32a4 0130A0E3 		mov	r3, #1
 5831 32a8 04808DE5 		str	r8, [sp, #4]
 5832 32ac 0600A0E1 		mov	r0, r6
 5833 32b0 00308DE5 		str	r3, [sp]
 5834 32b4 2110A0E3 		mov	r1, #33
 5835 32b8 2520A0E3 		mov	r2, #37
 5836 32bc 3030A0E3 		mov	r3, #48
 5837 32c0 FEFFFFEB 		bl	cmdSet
 5838              	.LVL689:
 683:../uvc.c      **** }
 5839              		.loc 1 683 0
 5840 32c4 1C0096E5 		ldr	r0, [r6, #28]
 5841 32c8 FEFFFFEB 		bl	_txe_mutex_put
 5842              	.LVL690:
 5843 32cc FF00A0E3 		mov	r0, #255
 5844 32d0 0080A0E1 		mov	r8, r0
 5845 32d4 0260A0E3 		mov	r6, #2
 5846 32d8 48FEFFEA 		b	.L453
 5847              	.LVL691:
 5848              	.L461:
 5849              	.LBE87:
 5850              	.LBE86:
 5851              	.LBB88:
 5852              	.LBB89:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 5853              		.loc 1 680 0
 5854 32dc C8809FE5 		ldr	r8, .L480+20
 5855 32e0 0010E0E3 		mvn	r1, #0
 5856 32e4 1C0098E5 		ldr	r0, [r8, #28]
 5857 32e8 FEFFFFEB 		bl	_txe_mutex_get
 5858              	.LVL692:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 5859              		.loc 1 681 0
 5860 32ec 0090A0E3 		mov	r9, #0
 5861              	.LVL693:
 5862 32f0 0160A0E3 		mov	r6, #1
 5863 32f4 0800A0E1 		mov	r0, r8
 5864 32f8 2010A0E3 		mov	r1, #32
 5865 32fc 2720A0E3 		mov	r2, #39
 5866 3300 3030A0E3 		mov	r3, #48
 5867 3304 40028DE8 		stmia	sp, {r6, r9}
 5868 3308 FEFFFFEB 		bl	cmdSet
 5869              	.LVL694:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5870              		.loc 1 682 0
 5871 330c 0230A0E3 		mov	r3, #2
 5872 3310 0800A0E1 		mov	r0, r8
 5873 3314 00308DE5 		str	r3, [sp]
 5874 3318 2110A0E3 		mov	r1, #33
 5875 331c 2520A0E3 		mov	r2, #37
 5876 3320 3030A0E3 		mov	r3, #48
 5877 3324 04908DE5 		str	r9, [sp, #4]
 5878 3328 FEFFFFEB 		bl	cmdSet
 5879              	.LVL695:
 683:../uvc.c      **** }
 5880              		.loc 1 683 0
 5881 332c 1C0098E5 		ldr	r0, [r8, #28]
 5882 3330 FEFFFFEB 		bl	_txe_mutex_put
 5883              	.LVL696:
 5884 3334 FF00A0E3 		mov	r0, #255
 5885 3338 0080A0E1 		mov	r8, r0
 5886 333c 2FFEFFEA 		b	.L453
 5887              	.LVL697:
 5888              	.L460:
 5889              	.LBE89:
 5890              	.LBE88:
1766:../uvc.c      **** 						case 1:
 5891              		.loc 1 1766 0
 5892 3340 FF00A0E3 		mov	r0, #255
 5893 3344 0C60A0E1 		mov	r6, ip
 5894 3348 0080A0E1 		mov	r8, r0
 5895 334c 2BFEFFEA 		b	.L453
 5896              	.LVL698:
 5897              	.L466:
1837:../uvc.c      **** 					  }
 5898              		.loc 1 1837 0
 5899 3350 0000A0E3 		mov	r0, #0
 5900 3354 0020A0E1 		mov	r2, r0
 5901 3358 0110A0E3 		mov	r1, #1
 5902 335c FEFFFFEB 		bl	CyU3PUsbStall
 5903              	.LVL699:
 5904 3360 D1FEFFEA 		b	.L469
 5905              	.LVL700:
 5906              	.L468:
1855:../uvc.c      **** 					  }
 5907              		.loc 1 1855 0
 5908 3364 0020A0E1 		mov	r2, r0
 5909 3368 0110A0E3 		mov	r1, #1
 5910 336c FEFFFFEB 		bl	CyU3PUsbStall
 5911              	.LVL701:
 5912 3370 CDFEFFEA 		b	.L469
 5913              	.LVL702:
 5914              	.L479:
1870:../uvc.c      **** 					  else
 5915              		.loc 1 1870 0
 5916 3374 0800A0E3 		mov	r0, #8
 5917              	.L476:
 5918 3378 0010A0E3 		mov	r1, #0
 5919 337c 03008DE8 		stmia	sp, {r0, r1}
 5920 3380 0A20A0E1 		mov	r2, r10
 5921 3384 0930A0E1 		mov	r3, r9
 5922 3388 0600A0E1 		mov	r0, r6
 5923 338c 2310A0E3 		mov	r1, #35
 5924 3390 FEFFFFEB 		bl	cmdSet
 5925              	.LVL703:
 5926 3394 97FEFFEA 		b	.L471
 5927              	.L481:
 5928              		.align	2
 5929              	.L480:
 5930 3398 00000000 		.word	bRequest
 5931 339c 00000000 		.word	.LANCHOR1
 5932 33a0 00000000 		.word	.LANCHOR0
 5933 33a4 8C060000 		.word	.LC39
 5934 33a8 68060000 		.word	.LC38
 5935 33ac 00000000 		.word	cmdQu
 5936 33b0 1C060000 		.word	.LC36
 5937 33b4 FFFF0000 		.word	65535
 5938 33b8 44060000 		.word	.LC37
 5939              		.cfi_endproc
 5940              	.LFE4:
 5942              		.align	2
 5943              		.global	CamDefSet
 5945              	CamDefSet:
 5946              	.LFB5:
1898:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5947              		.loc 1 1898 0
 5948              		.cfi_startproc
 5949              		@ args = 0, pretend = 0, frame = 24
 5950              		@ frame_needed = 0, uses_anonymous_args = 0
 5951              	.LVL704:
 5952 33bc F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5953              	.LCFI21:
 5954              		.cfi_def_cfa_offset 36
 5955              		.cfi_offset 4, -36
 5956              		.cfi_offset 5, -32
 5957              		.cfi_offset 6, -28
 5958              		.cfi_offset 7, -24
 5959              		.cfi_offset 8, -20
 5960              		.cfi_offset 9, -16
 5961              		.cfi_offset 10, -12
 5962              		.cfi_offset 11, -8
 5963              		.cfi_offset 14, -4
1905:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5964              		.loc 1 1905 0
 5965 33c0 B0429FE5 		ldr	r4, .L485
1910:../uvc.c      ****     if(Data1&0x80){
 5966              		.loc 1 1910 0
 5967 33c4 B0229FE5 		ldr	r2, .L485+4
1907:../uvc.c      ****     Data1 = Data0;
 5968              		.loc 1 1907 0
 5969 33c8 0F52D4E5 		ldrb	r5, [r4, #527]	@ zero_extendqisi2
1898:../uvc.c      ****     //VdRingBuf *cmdQuptr = &cmdQu;
 5970              		.loc 1 1898 0
 5971 33cc 2CD04DE2 		sub	sp, sp, #44
 5972              	.LCFI22:
 5973              		.cfi_def_cfa_offset 80
1910:../uvc.c      ****     if(Data1&0x80){
 5974              		.loc 1 1910 0
 5975 33d0 1C0092E5 		ldr	r0, [r2, #28]
 5976 33d4 0010E0E3 		mvn	r1, #0
1912:../uvc.c      ****     }else{
 5977              		.loc 1 1912 0
 5978 33d8 2563A0E1 		mov	r6, r5, lsr #6
1906:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5979              		.loc 1 1906 0
 5980 33dc 1372D4E5 		ldrb	r7, [r4, #531]	@ zero_extendqisi2
1905:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5981              		.loc 1 1905 0
 5982 33e0 0592D4E5 		ldrb	r9, [r4, #517]	@ zero_extendqisi2
 5983              	.LVL705:
1910:../uvc.c      ****     if(Data1&0x80){
 5984              		.loc 1 1910 0
 5985 33e4 FEFFFFEB 		bl	_txe_mutex_get
 5986              	.LVL706:
1911:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5987              		.loc 1 1911 0
 5988 33e8 800015E3 		tst	r5, #128
1912:../uvc.c      ****     }else{
 5989              		.loc 1 1912 0
 5990 33ec 01600612 		andne	r6, r6, #1
 5991 33f0 0660E011 		mvnne	r6, r6
 5992 33f4 3B600612 		andne	r6, r6, #59
 5993 33f8 0660E011 		mvnne	r6, r6
 5994 33fc FF600612 		andne	r6, r6, #255
 5995              	.LVL707:
1914:../uvc.c      ****     }
 5996              		.loc 1 1914 0
 5997 3400 C6608603 		orreq	r6, r6, #198
 5998              	.LVL708:
1918:../uvc.c      **** 
 5999              		.loc 1 1918 0
 6000 3404 0080A0E3 		mov	r8, #0
1916:../uvc.c      **** 
 6001              		.loc 1 1916 0
 6002 3408 0551A0E1 		mov	r5, r5, asl #2
 6003              	.LVL709:
 6004 340c FF5005E2 		and	r5, r5, #255
 6005              	.LVL710:
1921:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6006              		.loc 1 1921 0
 6007 3410 01A0A0E3 		mov	r10, #1
1918:../uvc.c      **** 
 6008              		.loc 1 1918 0
 6009 3414 00608DE5 		str	r6, [sp]
 6010 3418 0920A0E1 		mov	r2, r9
 6011 341c 0730A0E1 		mov	r3, r7
 6012 3420 04808DE5 		str	r8, [sp, #4]
 6013 3424 0110A0E3 		mov	r1, #1
 6014 3428 4C029FE5 		ldr	r0, .L485+4
 6015 342c FEFFFFEB 		bl	cmdSet
 6016              	.LVL711:
1921:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6017              		.loc 1 1921 0
 6018 3430 0422D4E5 		ldrb	r2, [r4, #516]	@ zero_extendqisi2
 6019 3434 0730A0E1 		mov	r3, r7
 6020 3438 0A10A0E1 		mov	r1, r10
 6021 343c 00508DE5 		str	r5, [sp]
 6022 3440 04A08DE5 		str	r10, [sp, #4]
 6023 3444 30029FE5 		ldr	r0, .L485+4
 6024 3448 FEFFFFEB 		bl	cmdSet
 6025              	.LVL712:
1924:../uvc.c      **** 
 6026              		.loc 1 1924 0
 6027 344c 0620A0E1 		mov	r2, r6
 6028 3450 0530A0E1 		mov	r3, r5
 6029 3454 24129FE5 		ldr	r1, .L485+8
 6030 3458 0400A0E3 		mov	r0, #4
1923:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 6031              		.loc 1 1923 0
 6032 345c 1262C4E5 		strb	r6, [r4, #530]
1922:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 6033              		.loc 1 1922 0
 6034 3460 1152C4E5 		strb	r5, [r4, #529]
1924:../uvc.c      **** 
 6035              		.loc 1 1924 0
 6036 3464 FEFFFFEB 		bl	CyU3PDebugPrint
 6037              	.LVL713:
1929:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 6038              		.loc 1 1929 0
 6039 3468 2762D4E5 		ldrb	r6, [r4, #551]	@ zero_extendqisi2
 6040              	.LVL714:
1930:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6041              		.loc 1 1930 0
 6042 346c 1C22D4E5 		ldrb	r2, [r4, #540]	@ zero_extendqisi2
 6043 3470 2B32D4E5 		ldrb	r3, [r4, #555]	@ zero_extendqisi2
 6044 3474 40018DE8 		stmia	sp, {r6, r8}
 6045 3478 FC019FE5 		ldr	r0, .L485+4
 6046 347c 0210A0E3 		mov	r1, #2
 6047 3480 FEFFFFEB 		bl	cmdSet
 6048              	.LVL715:
1933:../uvc.c      **** 
 6049              		.loc 1 1933 0
 6050 3484 0620A0E1 		mov	r2, r6
 6051 3488 0530A0E1 		mov	r3, r5
 6052 348c EC119FE5 		ldr	r1, .L485+8
 6053 3490 0400A0E3 		mov	r0, #4
1931:../uvc.c      **** 	CtrlParArry[ExtExRefCtlID10][13] = Data0;
 6054              		.loc 1 1931 0
 6055 3494 2952C4E5 		strb	r5, [r4, #553]
1932:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6056              		.loc 1 1932 0
 6057 3498 6954C4E5 		strb	r5, [r4, #1129]
1933:../uvc.c      **** 
 6058              		.loc 1 1933 0
 6059 349c FEFFFFEB 		bl	CyU3PDebugPrint
 6060              	.LVL716:
1938:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 6061              		.loc 1 1938 0
 6062 34a0 6F72D4E5 		ldrb	r7, [r4, #623]	@ zero_extendqisi2
1937:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6063              		.loc 1 1937 0
 6064 34a4 7362D4E5 		ldrb	r6, [r4, #627]	@ zero_extendqisi2
 6065              	.LVL717:
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6066              		.loc 1 1939 0
 6067 34a8 80C047E2 		sub	ip, r7, #128
 6068 34ac FF300CE2 		and	r3, ip, #255
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6069              		.loc 1 1940 0
 6070 34b0 76E047E2 		sub	lr, r7, #118
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6071              		.loc 1 1939 0
 6072 34b4 18308DE5 		str	r3, [sp, #24]
 6073 34b8 08018DE8 		stmia	sp, {r3, r8}
 6074 34bc B8019FE5 		ldr	r0, .L485+4
 6075 34c0 0630A0E1 		mov	r3, r6
 6076 34c4 0510A0E3 		mov	r1, #5
 6077 34c8 DF20A0E3 		mov	r2, #223
 6078 34cc 14C08DE5 		str	ip, [sp, #20]
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6079              		.loc 1 1940 0
 6080 34d0 1CE08DE5 		str	lr, [sp, #28]
1939:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 6081              		.loc 1 1939 0
 6082 34d4 FEFFFFEB 		bl	cmdSet
 6083              	.LVL718:
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6084              		.loc 1 1940 0
 6085 34d8 1C209DE5 		ldr	r2, [sp, #28]
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6086              		.loc 1 1941 0
 6087 34dc 7EE087E2 		add	lr, r7, #126
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6088              		.loc 1 1940 0
 6089 34e0 FF3002E2 		and	r3, r2, #255
 6090 34e4 08048DE8 		stmia	sp, {r3, r10}
 6091 34e8 8C019FE5 		ldr	r0, .L485+4
 6092 34ec 0630A0E1 		mov	r3, r6
 6093 34f0 0510A0E3 		mov	r1, #5
 6094 34f4 DC20A0E3 		mov	r2, #220
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6095              		.loc 1 1941 0
 6096 34f8 20E08DE5 		str	lr, [sp, #32]
1940:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 6097              		.loc 1 1940 0
 6098 34fc FEFFFFEB 		bl	cmdSet
 6099              	.LVL719:
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6100              		.loc 1 1941 0
 6101 3500 20209DE5 		ldr	r2, [sp, #32]
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6102              		.loc 1 1942 0
 6103 3504 72E087E2 		add	lr, r7, #114
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6104              		.loc 1 1941 0
 6105 3508 FF3002E2 		and	r3, r2, #255
 6106 350c 0220A0E3 		mov	r2, #2
 6107 3510 00308DE5 		str	r3, [sp]
 6108 3514 04208DE5 		str	r2, [sp, #4]
 6109 3518 0630A0E1 		mov	r3, r6
 6110 351c 0510A0E3 		mov	r1, #5
 6111 3520 DE20A0E3 		mov	r2, #222
 6112 3524 50019FE5 		ldr	r0, .L485+4
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6113              		.loc 1 1942 0
 6114 3528 24E08DE5 		str	lr, [sp, #36]
1941:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 6115              		.loc 1 1941 0
 6116 352c FEFFFFEB 		bl	cmdSet
 6117              	.LVL720:
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6118              		.loc 1 1942 0
 6119 3530 24209DE5 		ldr	r2, [sp, #36]
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6120              		.loc 1 1943 0
 6121 3534 6FB047E2 		sub	fp, r7, #111
1942:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 6122              		.loc 1 1942 0
 6123 3538 FF3002E2 		and	r3, r2, #255
 6124 353c 0320A0E3 		mov	r2, #3
 6125 3540 00308DE5 		str	r3, [sp]
 6126 3544 04208DE5 		str	r2, [sp, #4]
 6127 3548 0630A0E1 		mov	r3, r6
 6128 354c 0510A0E3 		mov	r1, #5
 6129 3550 E020A0E3 		mov	r2, #224
 6130 3554 20019FE5 		ldr	r0, .L485+4
 6131 3558 FEFFFFEB 		bl	cmdSet
 6132              	.LVL721:
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6133              		.loc 1 1943 0
 6134 355c 0490A0E3 		mov	r9, #4
 6135 3560 FF300BE2 		and	r3, fp, #255
1944:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6136              		.loc 1 1944 0
 6137 3564 7F7087E2 		add	r7, r7, #127
 6138              	.LVL722:
1943:../uvc.c      ****     cmdSet(statQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 6139              		.loc 1 1943 0
 6140 3568 00308DE5 		str	r3, [sp]
 6141 356c 04908DE5 		str	r9, [sp, #4]
 6142 3570 0630A0E1 		mov	r3, r6
 6143 3574 0510A0E3 		mov	r1, #5
 6144 3578 DD20A0E3 		mov	r2, #221
 6145 357c F8009FE5 		ldr	r0, .L485+4
 6146 3580 FEFFFFEB 		bl	cmdSet
 6147              	.LVL723:
1944:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 6148              		.loc 1 1944 0
 6149 3584 FF2007E2 		and	r2, r7, #255
 6150 3588 0510A0E3 		mov	r1, #5
 6151 358c 0630A0E1 		mov	r3, r6
 6152 3590 00208DE5 		str	r2, [sp]
 6153 3594 04108DE5 		str	r1, [sp, #4]
 6154 3598 E120A0E3 		mov	r2, #225
 6155 359c D8009FE5 		ldr	r0, .L485+4
 6156 35a0 FEFFFFEB 		bl	cmdSet
 6157              	.LVL724:
1946:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6158              		.loc 1 1946 0
 6159 35a4 14C09DE5 		ldr	ip, [sp, #20]
 6160 35a8 24E09DE5 		ldr	lr, [sp, #36]
 6161 35ac 20309DE5 		ldr	r3, [sp, #32]
 6162 35b0 0C20A0E1 		mov	r2, ip
1945:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6163              		.loc 1 1945 0
 6164 35b4 18C09DE5 		ldr	ip, [sp, #24]
1946:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6165              		.loc 1 1946 0
 6166 35b8 04E08DE5 		str	lr, [sp, #4]
 6167 35bc 00308DE5 		str	r3, [sp]
 6168 35c0 0C708DE5 		str	r7, [sp, #12]
 6169 35c4 1C309DE5 		ldr	r3, [sp, #28]
 6170 35c8 08B08DE5 		str	fp, [sp, #8]
 6171 35cc 0900A0E1 		mov	r0, r9
 6172 35d0 AC109FE5 		ldr	r1, .L485+12
1945:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 6173              		.loc 1 1945 0
 6174 35d4 71C2C4E5 		strb	ip, [r4, #625]
1946:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
 6175              		.loc 1 1946 0
 6176 35d8 FEFFFFEB 		bl	CyU3PDebugPrint
 6177              	.LVL725:
1951:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 6178              		.loc 1 1951 0
 6179 35dc 8762D4E5 		ldrb	r6, [r4, #647]	@ zero_extendqisi2
 6180              	.LVL726:
1950:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 6181              		.loc 1 1950 0
 6182 35e0 8B72D4E5 		ldrb	r7, [r4, #651]	@ zero_extendqisi2
 6183              	.LVL727:
1952:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 6184              		.loc 1 1952 0
 6185 35e4 00608DE5 		str	r6, [sp]
 6186 35e8 0730A0E1 		mov	r3, r7
 6187 35ec 04808DE5 		str	r8, [sp, #4]
 6188 35f0 0610A0E3 		mov	r1, #6
 6189 35f4 8520A0E3 		mov	r2, #133
 6190 35f8 7C009FE5 		ldr	r0, .L485+4
 6191 35fc FEFFFFEB 		bl	cmdSet
 6192              	.LVL728:
1953:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 6193              		.loc 1 1953 0
 6194 3600 40048DE8 		stmia	sp, {r6, r10}
 6195 3604 70009FE5 		ldr	r0, .L485+4
 6196 3608 0730A0E1 		mov	r3, r7
 6197 360c 0610A0E3 		mov	r1, #6
 6198 3610 8620A0E3 		mov	r2, #134
 6199 3614 FEFFFFEB 		bl	cmdSet
 6200              	.LVL729:
1955:../uvc.c      **** 
 6201              		.loc 1 1955 0
 6202 3618 0620A0E1 		mov	r2, r6
 6203 361c 0530A0E1 		mov	r3, r5
 6204 3620 0900A0E1 		mov	r0, r9
 6205 3624 54109FE5 		ldr	r1, .L485+8
1954:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6206              		.loc 1 1954 0
 6207 3628 8962C4E5 		strb	r6, [r4, #649]
1955:../uvc.c      **** 
 6208              		.loc 1 1955 0
 6209 362c FEFFFFEB 		bl	CyU3PDebugPrint
 6210              	.LVL730:
1960:../uvc.c      **** 	cmdSet(statQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 6211              		.loc 1 1960 0
 6212 3630 9F62D4E5 		ldrb	r6, [r4, #671]	@ zero_extendqisi2
 6213              	.LVL731:
1961:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 6214              		.loc 1 1961 0
 6215 3634 9422D4E5 		ldrb	r2, [r4, #660]	@ zero_extendqisi2
 6216 3638 A332D4E5 		ldrb	r3, [r4, #675]	@ zero_extendqisi2
 6217 363c 40018DE8 		stmia	sp, {r6, r8}
 6218 3640 34009FE5 		ldr	r0, .L485+4
 6219 3644 0710A0E3 		mov	r1, #7
 6220 3648 FEFFFFEB 		bl	cmdSet
 6221              	.LVL732:
1963:../uvc.c      **** 
 6222              		.loc 1 1963 0
 6223 364c 0620A0E1 		mov	r2, r6
 6224 3650 0530A0E1 		mov	r3, r5
 6225 3654 0900A0E1 		mov	r0, r9
 6226 3658 20109FE5 		ldr	r1, .L485+8
1962:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 6227              		.loc 1 1962 0
 6228 365c A152C4E5 		strb	r5, [r4, #673]
1963:../uvc.c      **** 
 6229              		.loc 1 1963 0
 6230 3660 FEFFFFEB 		bl	CyU3PDebugPrint
 6231              	.LVL733:
1965:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6232              		.loc 1 1965 0
 6233 3664 10209FE5 		ldr	r2, .L485+4
 6234 3668 1C0092E5 		ldr	r0, [r2, #28]
1968:../uvc.c      **** 
 6235              		.loc 1 1968 0
 6236 366c 2CD08DE2 		add	sp, sp, #44
 6237              		@ sp needed
 6238 3670 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 6239              	.LVL734:
1965:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
 6240              		.loc 1 1965 0
 6241 3674 FEFFFFEA 		b	_txe_mutex_put
 6242              	.LVL735:
 6243              	.L486:
 6244              		.align	2
 6245              	.L485:
 6246 3678 00000000 		.word	.LANCHOR1
 6247 367c 00000000 		.word	statQu
 6248 3680 F0060000 		.word	.LC40
 6249 3684 10070000 		.word	.LC41
 6250              		.cfi_endproc
 6251              	.LFE5:
 6253              		.align	2
 6254              		.global	CyFxUVCAddHeader
 6256              	CyFxUVCAddHeader:
 6257              	.LFB6:
1976:../uvc.c      ****     /* Copy header to buffer */
 6258              		.loc 1 1976 0
 6259              		.cfi_startproc
 6260              		@ args = 0, pretend = 0, frame = 0
 6261              		@ frame_needed = 0, uses_anonymous_args = 0
 6262              	.LVL736:
 6263 3688 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 6264              	.LCFI23:
 6265              		.cfi_def_cfa_offset 16
 6266              		.cfi_offset 3, -16
 6267              		.cfi_offset 4, -12
 6268              		.cfi_offset 5, -8
 6269              		.cfi_offset 14, -4
1976:../uvc.c      ****     /* Copy header to buffer */
 6270              		.loc 1 1976 0
 6271 368c 0040A0E1 		mov	r4, r0
 6272 3690 0150A0E1 		mov	r5, r1
1978:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 6273              		.loc 1 1978 0
 6274 3694 30009FE5 		ldr	r0, .L492
 6275              	.LVL737:
 6276 3698 0010E0E3 		mvn	r1, #0
 6277              	.LVL738:
 6278 369c FEFFFFEB 		bl	_txe_mutex_get
 6279              	.LVL739:
1979:../uvc.c      **** 	CyU3PMutexPut(&imgHdMux);
 6280              		.loc 1 1979 0
 6281 36a0 0400A0E1 		mov	r0, r4
 6282 36a4 24109FE5 		ldr	r1, .L492+4
 6283 36a8 0C20A0E3 		mov	r2, #12
 6284 36ac FEFFFFEB 		bl	CyU3PMemCopy
 6285              	.LVL740:
1980:../uvc.c      **** 
 6286              		.loc 1 1980 0
 6287 36b0 14009FE5 		ldr	r0, .L492
 6288 36b4 FEFFFFEB 		bl	_txe_mutex_put
 6289              	.LVL741:
1983:../uvc.c      ****     {
 6290              		.loc 1 1983 0
 6291 36b8 020015E3 		tst	r5, #2
1985:../uvc.c      ****     }
 6292              		.loc 1 1985 0
 6293 36bc 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 6294 36c0 02308313 		orrne	r3, r3, #2
 6295 36c4 0130C415 		strneb	r3, [r4, #1]
 6296 36c8 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 6297              	.L493:
 6298              		.align	2
 6299              	.L492:
 6300 36cc 00000000 		.word	imgHdMux
 6301 36d0 EC040000 		.word	.LANCHOR1+1260
 6302              		.cfi_endproc
 6303              	.LFE6:
 6305              		.align	2
 6306              		.global	CyFxAppErrorHandler
 6308              	CyFxAppErrorHandler:
 6309              	.LFB7:
1995:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
 6310              		.loc 1 1995 0
 6311              		.cfi_startproc
 6312              		@ Volatile: function does not return.
 6313              		@ args = 0, pretend = 0, frame = 0
 6314              		@ frame_needed = 0, uses_anonymous_args = 0
 6315              	.LVL742:
 6316 36d4 08402DE9 		stmfd	sp!, {r3, lr}
 6317              	.LCFI24:
 6318              		.cfi_def_cfa_offset 8
 6319              		.cfi_offset 3, -8
 6320              		.cfi_offset 14, -4
 6321              	.LVL743:
 6322              	.L495:
2005:../uvc.c      ****         CyU3PThreadSleep (1000);
 6323              		.loc 1 2005 0 discriminator 1
 6324 36d8 10109FE5 		ldr	r1, .L496
 6325 36dc 0400A0E3 		mov	r0, #4
 6326 36e0 FEFFFFEB 		bl	CyU3PDebugPrint
 6327              	.LVL744:
2006:../uvc.c      ****     }
 6328              		.loc 1 2006 0 discriminator 1
 6329 36e4 FA0FA0E3 		mov	r0, #1000
 6330 36e8 FEFFFFEB 		bl	_tx_thread_sleep
 6331              	.LVL745:
 6332 36ec F9FFFFEA 		b	.L495
 6333              	.L497:
 6334              		.align	2
 6335              	.L496:
 6336 36f0 48070000 		.word	.LC42
 6337              		.cfi_endproc
 6338              	.LFE7:
 6340              		.align	2
 6341              		.global	UVCAppThread_Entry
 6343              	UVCAppThread_Entry:
 6344              	.LFB19:
2982:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
 6345              		.loc 1 2982 0
 6346              		.cfi_startproc
 6347              		@ args = 0, pretend = 0, frame = 128
 6348              		@ frame_needed = 0, uses_anonymous_args = 0
 6349              	.LVL746:
 6350 36f4 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 6351              	.LCFI25:
 6352              		.cfi_def_cfa_offset 32
 6353              		.cfi_offset 4, -32
 6354              		.cfi_offset 5, -28
 6355              		.cfi_offset 6, -24
 6356              		.cfi_offset 7, -20
 6357              		.cfi_offset 8, -16
 6358              		.cfi_offset 9, -12
 6359              		.cfi_offset 10, -8
 6360              		.cfi_offset 14, -4
 6361 36f8 88D04DE2 		sub	sp, sp, #136
 6362              	.LCFI26:
 6363              		.cfi_def_cfa_offset 168
 6364              	.LBB98:
 6365              	.LBB99:
2438:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6366              		.loc 1 2438 0
 6367 36fc FEFFFFEB 		bl	CyU3PUartInit
 6368              	.LVL747:
2439:../uvc.c      ****     {
 6369              		.loc 1 2439 0
 6370 3700 004050E2 		subs	r4, r0, #0
 6371 3704 2902001A 		bne	.L579
2446:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6372              		.loc 1 2446 0
 6373 3708 582A9FE5 		ldr	r2, .L610
2447:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6374              		.loc 1 2447 0
 6375 370c 0130A0E3 		mov	r3, #1
2455:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6376              		.loc 1 2455 0
 6377 3710 0410A0E1 		mov	r1, r4
 6378 3714 60008DE2 		add	r0, sp, #96
 6379              	.LVL748:
2448:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 6380              		.loc 1 2448 0
 6381 3718 7540CDE5 		strb	r4, [sp, #117]
2450:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 6382              		.loc 1 2450 0
 6383 371c 64408DE5 		str	r4, [sp, #100]
2451:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 6384              		.loc 1 2451 0
 6385 3720 68408DE5 		str	r4, [sp, #104]
2446:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 6386              		.loc 1 2446 0
 6387 3724 70208DE5 		str	r2, [sp, #112]
2447:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 6388              		.loc 1 2447 0
 6389 3728 7430CDE5 		strb	r3, [sp, #116]
2449:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 6390              		.loc 1 2449 0
 6391 372c 60308DE5 		str	r3, [sp, #96]
2452:../uvc.c      **** 
 6392              		.loc 1 2452 0
 6393 3730 6C308DE5 		str	r3, [sp, #108]
2455:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6394              		.loc 1 2455 0
 6395 3734 FEFFFFEB 		bl	CyU3PUartSetConfig
 6396              	.LVL749:
2456:../uvc.c      ****     {
 6397              		.loc 1 2456 0
 6398 3738 000050E3 		cmp	r0, #0
 6399 373c B201001A 		bne	.L578
2462:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6400              		.loc 1 2462 0
 6401 3740 0000E0E3 		mvn	r0, #0
 6402              	.LVL750:
 6403 3744 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 6404              	.LVL751:
2463:../uvc.c      ****     {
 6405              		.loc 1 2463 0
 6406 3748 000050E3 		cmp	r0, #0
 6407 374c AE01001A 		bne	.L578
2469:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6408              		.loc 1 2469 0
 6409 3750 0300A0E3 		mov	r0, #3
 6410              	.LVL752:
 6411 3754 0410A0E3 		mov	r1, #4
 6412 3758 FEFFFFEB 		bl	CyU3PDebugInit
 6413              	.LVL753:
2470:../uvc.c      ****     {
 6414              		.loc 1 2470 0
 6415 375c 000050E3 		cmp	r0, #0
 6416 3760 A901001A 		bne	.L578
2476:../uvc.c      **** }
 6417              		.loc 1 2476 0
 6418 3764 FEFFFFEB 		bl	CyU3PDebugPreamble
 6419              	.LVL754:
 6420 3768 0640A0E3 		mov	r4, #6
 6421              	.LVL755:
 6422              	.L504:
 6423              	.LBE99:
 6424              	.LBE98:
2998:../uvc.c      **** 	}
 6425              		.loc 1 2998 0
 6426 376c 7D0FA0E3 		mov	r0, #500
 6427 3770 014044E2 		sub	r4, r4, #1
 6428 3774 FEFFFFEB 		bl	_tx_thread_sleep
 6429              	.LVL756:
2997:../uvc.c      **** 		CyU3PThreadSleep(500);
 6430              		.loc 1 2997 0
 6431 3778 FF4014E2 		ands	r4, r4, #255
 6432 377c FAFFFF1A 		bne	.L504
 6433              	.LBB101:
 6434              	.LBB102:
2486:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 6435              		.loc 1 2486 0
 6436 3780 FEFFFFEB 		bl	CyU3PI2cInit
 6437              	.LVL757:
2487:../uvc.c      ****     {
 6438              		.loc 1 2487 0
 6439 3784 005050E2 		subs	r5, r0, #0
 6440 3788 3002001A 		bne	.L580
2494:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6441              		.loc 1 2494 0
 6442 378c D8299FE5 		ldr	r2, .L610+4
2496:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6443              		.loc 1 2496 0
 6444 3790 0030E0E3 		mvn	r3, #0
2499:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6445              		.loc 1 2499 0
 6446 3794 60008DE2 		add	r0, sp, #96
 6447              	.LVL758:
 6448 3798 0410A0E1 		mov	r1, r4
2495:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 6449              		.loc 1 2495 0
 6450 379c 64408DE5 		str	r4, [sp, #100]
2494:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 6451              		.loc 1 2494 0
 6452 37a0 60208DE5 		str	r2, [sp, #96]
2496:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 6453              		.loc 1 2496 0
 6454 37a4 68308DE5 		str	r3, [sp, #104]
2497:../uvc.c      **** 
 6455              		.loc 1 2497 0
 6456 37a8 BC36CDE1 		strh	r3, [sp, #108]	@ movhi
2499:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 6457              		.loc 1 2499 0
 6458 37ac FEFFFFEB 		bl	CyU3PI2cSetConfig
 6459              	.LVL759:
2500:../uvc.c      ****     {
 6460              		.loc 1 2500 0
 6461 37b0 005050E2 		subs	r5, r0, #0
 6462 37b4 2002001A 		bne	.L581
 6463              	.LBE102:
 6464              	.LBE101:
 6465              	.LBB104:
 6466              	.LBB105:
2573:../uvc.c      ****     if (apiRetStatus != 0)
 6467              		.loc 1 2573 0
 6468 37b8 B0799FE5 		ldr	r7, .L610+8
 6469 37bc 0410A0E1 		mov	r1, r4
 6470 37c0 0700A0E1 		mov	r0, r7
 6471              	.LVL760:
 6472 37c4 2820A0E3 		mov	r2, #40
 6473 37c8 FEFFFFEB 		bl	_txe_event_flags_create
 6474              	.LVL761:
2574:../uvc.c      ****     {
 6475              		.loc 1 2574 0
 6476 37cc 005050E2 		subs	r5, r0, #0
 6477              	.LVL762:
 6478 37d0 1302001A 		bne	.L582
2588:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6479              		.loc 1 2588 0
 6480 37d4 0230A0E3 		mov	r3, #2
2591:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6481              		.loc 1 2591 0
 6482 37d8 0320A0E3 		mov	r2, #3
2595:../uvc.c      ****     if (apiRetStatus != 0)
 6483              		.loc 1 2595 0
 6484 37dc 14008DE2 		add	r0, sp, #20
 6485              	.LVL763:
 6486 37e0 0410A0E1 		mov	r1, r4
2584:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 6487              		.loc 1 2584 0
 6488 37e4 8C4087E5 		str	r4, [r7, #140]
2585:../uvc.c      **** 
 6489              		.loc 1 2585 0
 6490 37e8 904087E5 		str	r4, [r7, #144]
2590:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 6491              		.loc 1 2590 0
 6492 37ec 1C40CDE5 		strb	r4, [sp, #28]
2592:../uvc.c      **** 
 6493              		.loc 1 2592 0
 6494 37f0 18408DE5 		str	r4, [sp, #24]
2588:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 6495              		.loc 1 2588 0
 6496 37f4 1430CDE5 		strb	r3, [sp, #20]
2589:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 6497              		.loc 1 2589 0
 6498 37f8 1530CDE5 		strb	r3, [sp, #21]
2591:../uvc.c      ****     gpioClock.halfDiv    = 0;
 6499              		.loc 1 2591 0
 6500 37fc 1D20CDE5 		strb	r2, [sp, #29]
2595:../uvc.c      ****     if (apiRetStatus != 0)
 6501              		.loc 1 2595 0
 6502 3800 FEFFFFEB 		bl	CyU3PGpioInit
 6503              	.LVL764:
2596:../uvc.c      ****     {
 6504              		.loc 1 2596 0
 6505 3804 005050E2 		subs	r5, r0, #0
 6506 3808 FF01001A 		bne	.L583
2604:../uvc.c      ****     if (apiRetStatus != 0)
 6507              		.loc 1 2604 0
 6508 380c 1600A0E3 		mov	r0, #22
 6509              	.LVL765:
 6510 3810 0110A0E3 		mov	r1, #1
 6511 3814 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6512              	.LVL766:
2605:../uvc.c      ****     {
 6513              		.loc 1 2605 0
 6514 3818 005050E2 		subs	r5, r0, #0
 6515 381c 3A02001A 		bne	.L584
2610:../uvc.c      ****     if (apiRetStatus != 0)
 6516              		.loc 1 2610 0
 6517 3820 1400A0E3 		mov	r0, #20
 6518              	.LVL767:
 6519 3824 0110A0E3 		mov	r1, #1
 6520 3828 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6521              	.LVL768:
2611:../uvc.c      ****     {
 6522              		.loc 1 2611 0
 6523 382c 005050E2 		subs	r5, r0, #0
 6524 3830 2F02001A 		bne	.L585
2616:../uvc.c      ****     if (apiRetStatus != 0)
 6525              		.loc 1 2616 0
 6526 3834 1800A0E3 		mov	r0, #24
 6527              	.LVL769:
 6528 3838 0110A0E3 		mov	r1, #1
 6529 383c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 6530              	.LVL770:
2617:../uvc.c      ****     {
 6531              		.loc 1 2617 0
 6532 3840 005050E2 		subs	r5, r0, #0
 6533 3844 2402001A 		bne	.L586
2624:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6534              		.loc 1 2624 0
 6535 3848 0150A0E3 		mov	r5, #1
2629:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6536              		.loc 1 2629 0
 6537 384c 30108DE2 		add	r1, sp, #48
 6538 3850 1600A0E3 		mov	r0, #22
 6539              	.LVL771:
2627:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6540              		.loc 1 2627 0
 6541 3854 3C408DE5 		str	r4, [sp, #60]
2628:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 6542              		.loc 1 2628 0
 6543 3858 4040CDE5 		strb	r4, [sp, #64]
2624:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6544              		.loc 1 2624 0
 6545 385c 30508DE5 		str	r5, [sp, #48]
2625:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6546              		.loc 1 2625 0
 6547 3860 34508DE5 		str	r5, [sp, #52]
2626:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6548              		.loc 1 2626 0
 6549 3864 38508DE5 		str	r5, [sp, #56]
2629:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6550              		.loc 1 2629 0
 6551 3868 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6552              	.LVL772:
2630:../uvc.c      ****     {
 6553              		.loc 1 2630 0
 6554 386c 006050E2 		subs	r6, r0, #0
 6555 3870 1302001A 		bne	.L587
2643:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6556              		.loc 1 2643 0
 6557 3874 1400A0E3 		mov	r0, #20
 6558              	.LVL773:
 6559 3878 30108DE2 		add	r1, sp, #48
2641:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6560              		.loc 1 2641 0
 6561 387c 3C408DE5 		str	r4, [sp, #60]
2642:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 6562              		.loc 1 2642 0
 6563 3880 4040CDE5 		strb	r4, [sp, #64]
2638:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 6564              		.loc 1 2638 0
 6565 3884 30508DE5 		str	r5, [sp, #48]
2639:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 6566              		.loc 1 2639 0
 6567 3888 34508DE5 		str	r5, [sp, #52]
2640:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 6568              		.loc 1 2640 0
 6569 388c 38508DE5 		str	r5, [sp, #56]
2643:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6570              		.loc 1 2643 0
 6571 3890 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6572              	.LVL774:
2644:../uvc.c      ****     {
 6573              		.loc 1 2644 0
 6574 3894 004050E2 		subs	r4, r0, #0
 6575 3898 0302001A 		bne	.L588
2652:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6576              		.loc 1 2652 0
 6577 389c 0030A0E3 		mov	r3, #0
2657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6578              		.loc 1 2657 0
 6579 38a0 30108DE2 		add	r1, sp, #48
2655:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6580              		.loc 1 2655 0
 6581 38a4 0150A0E3 		mov	r5, #1
2657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6582              		.loc 1 2657 0
 6583 38a8 1800A0E3 		mov	r0, #24
 6584              	.LVL775:
2652:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 6585              		.loc 1 2652 0
 6586 38ac 30308DE5 		str	r3, [sp, #48]
2653:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 6587              		.loc 1 2653 0
 6588 38b0 34308DE5 		str	r3, [sp, #52]
2654:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 6589              		.loc 1 2654 0
 6590 38b4 38308DE5 		str	r3, [sp, #56]
2656:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 6591              		.loc 1 2656 0
 6592 38b8 4030CDE5 		strb	r3, [sp, #64]
2655:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 6593              		.loc 1 2655 0
 6594 38bc 3C508DE5 		str	r5, [sp, #60]
2657:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6595              		.loc 1 2657 0
 6596 38c0 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 6597              	.LVL776:
2658:../uvc.c      ****     {
 6598              		.loc 1 2658 0
 6599 38c4 004050E2 		subs	r4, r0, #0
 6600 38c8 F101001A 		bne	.L589
2665:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6601              		.loc 1 2665 0
 6602 38cc 0260A0E3 		mov	r6, #2
2666:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6603              		.loc 1 2666 0
 6604 38d0 0380A0E3 		mov	r8, #3
2670:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6605              		.loc 1 2670 0
 6606 38d4 0500A0E1 		mov	r0, r5
 6607              	.LVL777:
 6608 38d8 20108DE2 		add	r1, sp, #32
2667:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 6609              		.loc 1 2667 0
 6610 38dc 28408DE5 		str	r4, [sp, #40]
2668:../uvc.c      **** 
 6611              		.loc 1 2668 0
 6612 38e0 24408DE5 		str	r4, [sp, #36]
2665:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 6613              		.loc 1 2665 0
 6614 38e4 B062CDE1 		strh	r6, [sp, #32]	@ movhi
2666:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 6615              		.loc 1 2666 0
 6616 38e8 2C80CDE5 		strb	r8, [sp, #44]
2670:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6617              		.loc 1 2670 0
 6618 38ec FEFFFFEB 		bl	CyU3PPibInit
 6619              	.LVL778:
2671:../uvc.c      ****     {
 6620              		.loc 1 2671 0
 6621 38f0 004050E2 		subs	r4, r0, #0
 6622 38f4 E001001A 		bne	.L590
2678:../uvc.c      **** 
 6623              		.loc 1 2678 0
 6624 38f8 74089FE5 		ldr	r0, .L610+12
 6625              	.LVL779:
 6626 38fc FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 6627              	.LVL780:
2686:../uvc.c      ****     CyU3PThreadSleep(5000);
 6628              		.loc 1 2686 0
 6629 3900 FEFFFFEB 		bl	SensorReset
 6630              	.LVL781:
2687:../uvc.c      ****     //SensorInit ();
 6631              		.loc 1 2687 0
 6632 3904 6C089FE5 		ldr	r0, .L610+16
 6633 3908 FEFFFFEB 		bl	_tx_thread_sleep
 6634              	.LVL782:
2691:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6635              		.loc 1 2691 0
 6636 390c FEFFFFEB 		bl	CyU3PUsbStart
 6637              	.LVL783:
2692:../uvc.c      ****     {
 6638              		.loc 1 2692 0
 6639 3910 004050E2 		subs	r4, r0, #0
 6640 3914 D201001A 		bne	.L591
2698:../uvc.c      **** 
 6641              		.loc 1 2698 0
 6642 3918 0410A0E1 		mov	r1, r4
 6643 391c 58089FE5 		ldr	r0, .L610+20
 6644              	.LVL784:
 6645 3920 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 6646              	.LVL785:
2701:../uvc.c      **** 
 6647              		.loc 1 2701 0
 6648 3924 54089FE5 		ldr	r0, .L610+24
 6649 3928 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 6650              	.LVL786:
2707:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 6651              		.loc 1 2707 0
 6652 392c 0410A0E1 		mov	r1, r4
 6653 3930 4C289FE5 		ldr	r2, .L610+28
 6654 3934 0500A0E1 		mov	r0, r5
 6655 3938 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6656              	.LVL787:
2708:../uvc.c      **** 
 6657              		.loc 1 2708 0
 6658 393c 0410A0E1 		mov	r1, r4
 6659 3940 0400A0E1 		mov	r0, r4
 6660 3944 3C289FE5 		ldr	r2, .L610+32
 6661 3948 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6662              	.LVL788:
2711:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 6663              		.loc 1 2711 0
 6664 394c 0410A0E1 		mov	r1, r4
 6665 3950 34289FE5 		ldr	r2, .L610+36
 6666 3954 0600A0E1 		mov	r0, r6
 6667 3958 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6668              	.LVL789:
2712:../uvc.c      **** 
 6669              		.loc 1 2712 0
 6670 395c 0410A0E1 		mov	r1, r4
 6671 3960 28289FE5 		ldr	r2, .L610+40
 6672 3964 0700A0E3 		mov	r0, #7
 6673 3968 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6674              	.LVL790:
2715:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 6675              		.loc 1 2715 0
 6676 396c 0410A0E1 		mov	r1, r4
 6677 3970 1C289FE5 		ldr	r2, .L610+44
 6678 3974 0400A0E3 		mov	r0, #4
 6679 3978 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6680              	.LVL791:
2716:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 6681              		.loc 1 2716 0
 6682 397c 0410A0E1 		mov	r1, r4
 6683 3980 10289FE5 		ldr	r2, .L610+48
 6684 3984 0800A0E1 		mov	r0, r8
 6685 3988 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6686              	.LVL792:
2717:../uvc.c      **** 
 6687              		.loc 1 2717 0
 6688 398c 0410A0E1 		mov	r1, r4
 6689 3990 04289FE5 		ldr	r2, .L610+52
 6690 3994 0600A0E3 		mov	r0, #6
 6691 3998 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6692              	.LVL793:
2720:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 6693              		.loc 1 2720 0
 6694 399c 0410A0E1 		mov	r1, r4
 6695 39a0 F8279FE5 		ldr	r2, .L610+56
 6696 39a4 0500A0E3 		mov	r0, #5
 6697 39a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6698              	.LVL794:
2721:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 6699              		.loc 1 2721 0
 6700 39ac 0510A0E1 		mov	r1, r5
 6701 39b0 EC279FE5 		ldr	r2, .L610+60
 6702 39b4 0500A0E3 		mov	r0, #5
 6703 39b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6704              	.LVL795:
2722:../uvc.c      **** 
 6705              		.loc 1 2722 0
 6706 39bc 0610A0E1 		mov	r1, r6
 6707 39c0 E0279FE5 		ldr	r2, .L610+64
 6708 39c4 0500A0E3 		mov	r0, #5
 6709 39c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
 6710              	.LVL796:
2731:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6711              		.loc 1 2731 0
 6712 39cc 4030A0E3 		mov	r3, #64
2735:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6713              		.loc 1 2735 0
 6714 39d0 08108DE2 		add	r1, sp, #8
 6715 39d4 8200A0E3 		mov	r0, #130
2732:../uvc.c      ****     endPointConfig.streams  = 0;
 6716              		.loc 1 2732 0
 6717 39d8 1340CDE5 		strb	r4, [sp, #19]
2733:../uvc.c      ****     endPointConfig.burstLen = 1;
 6718              		.loc 1 2733 0
 6719 39dc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2729:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6720              		.loc 1 2729 0
 6721 39e0 08508DE5 		str	r5, [sp, #8]
2730:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6722              		.loc 1 2730 0
 6723 39e4 0C80CDE5 		strb	r8, [sp, #12]
2734:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6724              		.loc 1 2734 0
 6725 39e8 1250CDE5 		strb	r5, [sp, #18]
2731:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6726              		.loc 1 2731 0
 6727 39ec B031CDE1 		strh	r3, [sp, #16]	@ movhi
2735:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6728              		.loc 1 2735 0
 6729 39f0 FEFFFFEB 		bl	CyU3PSetEpConfig
 6730              	.LVL797:
2736:../uvc.c      ****     {
 6731              		.loc 1 2736 0
 6732 39f4 004050E2 		subs	r4, r0, #0
2739:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 6733              		.loc 1 2739 0
 6734 39f8 0400A013 		movne	r0, #4
 6735              	.LVL798:
2736:../uvc.c      ****     {
 6736              		.loc 1 2736 0
 6737 39fc 7101001A 		bne	.L576
2744:../uvc.c      ****     dmaInterConfig.count          = 1;
 6738              		.loc 1 2744 0
 6739 3a00 A4C79FE5 		ldr	ip, .L610+68
 6740 3a04 413BA0E3 		mov	r3, #66560
2753:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6741              		.loc 1 2753 0
 6742 3a08 1080A0E3 		mov	r8, #16
2755:../uvc.c      ****             &dmaInterConfig);
 6743              		.loc 1 2755 0
 6744 3a0c 9C079FE5 		ldr	r0, .L610+72
 6745 3a10 0410A0E3 		mov	r1, #4
 6746 3a14 44208DE2 		add	r2, sp, #68
2744:../uvc.c      ****     dmaInterConfig.count          = 1;
 6747              		.loc 1 2744 0
 6748 3a18 4C408DE5 		str	r4, [sp, #76]
 6749 3a1c 50408DE5 		str	r4, [sp, #80]
2752:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6750              		.loc 1 2752 0
 6751 3a20 5440CDE5 		strb	r4, [sp, #84]
2754:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6752              		.loc 1 2754 0
 6753 3a24 5C408DE5 		str	r4, [sp, #92]
2744:../uvc.c      ****     dmaInterConfig.count          = 1;
 6754              		.loc 1 2744 0
 6755 3a28 48C08DE5 		str	ip, [sp, #72]
 6756 3a2c 44308DE5 		str	r3, [sp, #68]
2753:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6757              		.loc 1 2753 0
 6758 3a30 58808DE5 		str	r8, [sp, #88]
2755:../uvc.c      ****             &dmaInterConfig);
 6759              		.loc 1 2755 0
 6760 3a34 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6761              	.LVL799:
2757:../uvc.c      ****     {
 6762              		.loc 1 2757 0
 6763 3a38 004050E2 		subs	r4, r0, #0
 6764 3a3c BE01001A 		bne	.L592
2764:../uvc.c      ****     if (glInterStaBuffer == 0)
 6765              		.loc 1 2764 0
 6766 3a40 010BA0E3 		mov	r0, #1024
 6767              	.LVL800:
 6768 3a44 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6769              	.LVL801:
 6770 3a48 64379FE5 		ldr	r3, .L610+76
2765:../uvc.c      ****     {
 6771              		.loc 1 2765 0
 6772 3a4c 000050E3 		cmp	r0, #0
2764:../uvc.c      ****     if (glInterStaBuffer == 0)
 6773              		.loc 1 2764 0
 6774 3a50 000083E5 		str	r0, [r3]
2765:../uvc.c      ****     {
 6775              		.loc 1 2765 0
 6776 3a54 BE01000A 		beq	.L593
2772:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6777              		.loc 1 2772 0
 6778 3a58 0410A0E1 		mov	r1, r4
 6779 3a5c 0420A0E1 		mov	r2, r4
 6780 3a60 3830A0E3 		mov	r3, #56
 6781 3a64 4C079FE5 		ldr	r0, .L610+80
 6782 3a68 FEFFFFEB 		bl	_txe_mutex_create
 6783              	.LVL802:
2777:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6784              		.loc 1 2777 0
 6785 3a6c 48179FE5 		ldr	r1, .L610+84
2778:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6786              		.loc 1 2778 0
 6787 3a70 48279FE5 		ldr	r2, .L610+88
2785:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6788              		.loc 1 2785 0
 6789 3a74 48A79FE5 		ldr	r10, .L610+92
2774:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6790              		.loc 1 2774 0
 6791 3a78 0480A0E3 		mov	r8, #4
2776:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6792              		.loc 1 2776 0
 6793 3a7c 01ECA0E3 		mov	lr, #256
2780:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6794              		.loc 1 2780 0
 6795 3a80 0CC0A0E3 		mov	ip, #12
2784:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6796              		.loc 1 2784 0
 6797 3a84 1830A0E3 		mov	r3, #24
2777:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6798              		.loc 1 2777 0
 6799 3a88 B816CDE1 		strh	r1, [sp, #104]	@ movhi
2778:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6800              		.loc 1 2778 0
 6801 3a8c BE26CDE1 		strh	r2, [sp, #110]	@ movhi
2773:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6802              		.loc 1 2773 0
 6803 3a90 0199A0E3 		mov	r9, #16384
2786:../uvc.c      ****             &dmaMultiConfig);
 6804              		.loc 1 2786 0
 6805 3a94 2C079FE5 		ldr	r0, .L610+96
 6806 3a98 0710A0E3 		mov	r1, #7
 6807 3a9c 60208DE2 		add	r2, sp, #96
2779:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6808              		.loc 1 2779 0
 6809 3aa0 B647CDE1 		strh	r4, [sp, #118]	@ movhi
2782:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6810              		.loc 1 2782 0
 6811 3aa4 BC47CDE1 		strh	r4, [sp, #124]	@ movhi
2783:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6812              		.loc 1 2783 0
 6813 3aa8 7E40CDE5 		strb	r4, [sp, #126]
2775:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6814              		.loc 1 2775 0
 6815 3aac B466CDE1 		strh	r6, [sp, #100]	@ movhi
2785:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6816              		.loc 1 2785 0
 6817 3ab0 84A08DE5 		str	r10, [sp, #132]
2773:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6818              		.loc 1 2773 0
 6819 3ab4 B096CDE1 		strh	r9, [sp, #96]	@ movhi
2774:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6820              		.loc 1 2774 0
 6821 3ab8 B286CDE1 		strh	r8, [sp, #98]	@ movhi
2781:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6822              		.loc 1 2781 0
 6823 3abc BA87CDE1 		strh	r8, [sp, #122]	@ movhi
2776:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6824              		.loc 1 2776 0
 6825 3ac0 B6E6CDE1 		strh	lr, [sp, #102]	@ movhi
2780:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6826              		.loc 1 2780 0
 6827 3ac4 B8C7CDE1 		strh	ip, [sp, #120]	@ movhi
2784:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6828              		.loc 1 2784 0
 6829 3ac8 80308DE5 		str	r3, [sp, #128]
2786:../uvc.c      ****             &dmaMultiConfig);
 6830              		.loc 1 2786 0
 6831 3acc FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6832              	.LVL803:
2788:../uvc.c      ****     {
 6833              		.loc 1 2788 0
 6834 3ad0 004050E2 		subs	r4, r0, #0
 6835 3ad4 9201001A 		bne	.L594
2879:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6836              		.loc 1 2879 0
 6837 3ad8 0500A0E1 		mov	r0, r5
 6838              	.LVL804:
 6839 3adc 0510A0E1 		mov	r1, r5
 6840 3ae0 FEFFFFEB 		bl	CyU3PConnectState
 6841              	.LVL805:
2880:../uvc.c      ****     {
 6842              		.loc 1 2880 0
 6843 3ae4 004050E2 		subs	r4, r0, #0
 6844 3ae8 3B01001A 		bne	.L595
2886:../uvc.c      **** 
 6845              		.loc 1 2886 0
 6846 3aec 6400A0E3 		mov	r0, #100
 6847              	.LVL806:
 6848 3af0 FEFFFFEB 		bl	CyFx3BusyWait
 6849              	.LVL807:
2888:../uvc.c      **** 
 6850              		.loc 1 2888 0
 6851 3af4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 6852              	.LVL808:
2903:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6853              		.loc 1 2903 0
 6854 3af8 08108DE2 		add	r1, sp, #8
2902:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6855              		.loc 1 2902 0
 6856 3afc BE40CDE1 		strh	r4, [sp, #14]	@ movhi
2890:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6857              		.loc 1 2890 0
 6858 3b00 08508DE5 		str	r5, [sp, #8]
2891:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6859              		.loc 1 2891 0
 6860 3b04 0C60CDE5 		strb	r6, [sp, #12]
2895:../uvc.c      ****     }
 6861              		.loc 1 2895 0
 6862 3b08 030050E3 		cmp	r0, #3
2888:../uvc.c      **** 
 6863              		.loc 1 2888 0
 6864 3b0c 0030A0E1 		mov	r3, r0
2895:../uvc.c      ****     }
 6865              		.loc 1 2895 0
 6866 3b10 01C0A013 		movne	ip, #1
 6867 3b14 10C0A003 		moveq	ip, #16
 6868 3b18 022CA013 		movne	r2, #512
 6869 3b1c 012BA003 		moveq	r2, #1024
2903:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6870              		.loc 1 2903 0
 6871 3b20 8300A0E3 		mov	r0, #131
2888:../uvc.c      **** 
 6872              		.loc 1 2888 0
 6873 3b24 4830C7E5 		strb	r3, [r7, #72]
 6874 3b28 12C0CDE5 		strb	ip, [sp, #18]
 6875 3b2c B021CDE1 		strh	r2, [sp, #16]	@ movhi
2903:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6876              		.loc 1 2903 0
 6877 3b30 FEFFFFEB 		bl	CyU3PSetEpConfig
 6878              	.LVL809:
2904:../uvc.c      ****     {
 6879              		.loc 1 2904 0
 6880 3b34 004050E2 		subs	r4, r0, #0
 6881              	.LBE105:
 6882              	.LBE104:
3027:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6883              		.loc 1 3027 0
 6884 3b38 30469F05 		ldreq	r4, .L610+8
 6885              	.LBB110:
 6886              	.LBB106:
2904:../uvc.c      ****     {
 6887              		.loc 1 2904 0
 6888 3b3c 0C00000A 		beq	.L555
 6889 3b40 1F0100EA 		b	.L609
 6890              	.LVL810:
 6891              	.L598:
 6892              	.LBE106:
 6893              	.LBE110:
3073:../uvc.c      ****             {
 6894              		.loc 1 3073 0
 6895 3b44 7C3094E5 		ldr	r3, [r4, #124]
 6896 3b48 050053E1 		cmp	r3, r5
 6897 3b4c 0300000A 		beq	.L525
3073:../uvc.c      ****             {
 6898              		.loc 1 3073 0 is_stmt 0 discriminator 1
 6899 3b50 B028D4E1 		ldrh	r2, [r4, #128]
 6900 3b54 B238D4E1 		ldrh	r3, [r4, #130]
 6901 3b58 030052E1 		cmp	r2, r3
 6902 3b5c 3B00000A 		beq	.L597
 6903              	.L525:
3277:../uvc.c      **** 
 6904              		.loc 1 3277 0 is_stmt 1
 6905 3b60 4010A0E3 		mov	r1, #64
 6906 3b64 0020A0E3 		mov	r2, #0
 6907 3b68 00069FE5 		ldr	r0, .L610+8
 6908 3b6c FEFFFFEB 		bl	_txe_event_flags_set
 6909              	.LVL811:
3280:../uvc.c      ****     }
 6910              		.loc 1 3280 0
 6911 3b70 FEFFFFEB 		bl	_txe_thread_relinquish
 6912              	.LVL812:
 6913              	.L555:
3027:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6914              		.loc 1 3027 0
 6915 3b74 0050A0E3 		mov	r5, #0
 6916 3b78 00508DE5 		str	r5, [sp]
 6917 3b7c EC059FE5 		ldr	r0, .L610+8
 6918 3b80 0110A0E3 		mov	r1, #1
 6919 3b84 0220A0E3 		mov	r2, #2
 6920 3b88 60308DE2 		add	r3, sp, #96
 6921 3b8c FEFFFFEB 		bl	_txe_event_flags_get
 6922              	.LVL813:
 6923 3b90 006050E2 		subs	r6, r0, #0
 6924 3b94 EAFFFF0A 		beq	.L598
3184:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
 6925              		.loc 1 3184 0
 6926 3b98 00508DE5 		str	r5, [sp]
 6927 3b9c CC059FE5 		ldr	r0, .L610+8
 6928 3ba0 0210A0E3 		mov	r1, #2
 6929 3ba4 0320A0E3 		mov	r2, #3
 6930 3ba8 60308DE2 		add	r3, sp, #96
 6931 3bac FEFFFFEB 		bl	_txe_event_flags_get
 6932              	.LVL814:
 6933 3bb0 000050E3 		cmp	r0, #0
 6934 3bb4 0B00001A 		bne	.L547
3199:../uvc.c      ****                 {
 6935              		.loc 1 3199 0
 6936 3bb8 903094E5 		ldr	r3, [r4, #144]
3187:../uvc.c      ****                 prodCount = 0;
 6937              		.loc 1 3187 0
 6938 3bbc 7C0084E5 		str	r0, [r4, #124]
3199:../uvc.c      ****                 {
 6939              		.loc 1 3199 0
 6940 3bc0 000053E3 		cmp	r3, #0
3188:../uvc.c      ****                 consCount = 0;
 6941              		.loc 1 3188 0
 6942 3bc4 B008C4E1 		strh	r0, [r4, #128]	@ movhi
3195:../uvc.c      ****                 pb=0;
 6943              		.loc 1 3195 0
 6944 3bc8 B407C4E1 		strh	r0, [r4, #116]	@ movhi
3189:../uvc.c      ****                 if(0&&(prinflag == 0)){
 6945              		.loc 1 3189 0
 6946 3bcc B208C4E1 		strh	r0, [r4, #130]	@ movhi
3196:../uvc.c      ****                 pbc=0;
 6947              		.loc 1 3196 0
 6948 3bd0 B607C4E1 		strh	r0, [r4, #118]	@ movhi
3197:../uvc.c      **** 
 6949              		.loc 1 3197 0
 6950 3bd4 B807C4E1 		strh	r0, [r4, #120]	@ movhi
3199:../uvc.c      ****                 {
 6951              		.loc 1 3199 0
 6952 3bd8 4600000A 		beq	.L599
 6953              	.L548:
3211:../uvc.c      ****             }
 6954              		.loc 1 3211 0
 6955 3bdc 0030A0E3 		mov	r3, #0
 6956 3be0 903087E5 		str	r3, [r7, #144]
 6957 3be4 DDFFFFEA 		b	.L525
 6958              	.L547:
3216:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
 6959              		.loc 1 3216 0
 6960 3be8 0030E0E3 		mvn	r3, #0
 6961 3bec 00308DE5 		str	r3, [sp]
 6962 3bf0 0110A0E3 		mov	r1, #1
 6963 3bf4 0220A0E3 		mov	r2, #2
 6964 3bf8 60308DE2 		add	r3, sp, #96
 6965 3bfc 6C059FE5 		ldr	r0, .L610+8
 6966 3c00 FEFFFFEB 		bl	_txe_event_flags_get
 6967              	.LVL815:
3220:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6968              		.loc 1 3220 0
 6969 3c04 0510A0E1 		mov	r1, r5
 6970 3c08 0520A0E1 		mov	r2, r5
 6971 3c0c B4059FE5 		ldr	r0, .L610+96
 6972 3c10 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6973              	.LVL816:
3221:../uvc.c      ****                 {
 6974              		.loc 1 3221 0
 6975 3c14 005050E2 		subs	r5, r0, #0
 6976 3c18 9D00001A 		bne	.L600
3229:../uvc.c      ****                 {
 6977              		.loc 1 3229 0
 6978 3c1c 883094E5 		ldr	r3, [r4, #136]
 6979 3c20 000053E3 		cmp	r3, #0
 6980 3c24 2B00001A 		bne	.L546
 6981              	.LVL817:
 6982              	.LBB111:
 6983              	.LBB112:
2932:../uvc.c      ****     {
 6984              		.loc 1 2932 0
 6985 3c28 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6986 3c2c 030053E3 		cmp	r3, #3
 6987 3c30 5E00000A 		beq	.L601
2937:../uvc.c      ****     {
 6988              		.loc 1 2937 0
 6989 3c34 020053E3 		cmp	r3, #2
 6990 3c38 7400000A 		beq	.L602
 6991              	.LVL818:
 6992              	.L553:
 6993              	.LBE112:
 6994              	.LBE111:
3265:../uvc.c      ****                     CyU3PThreadSleep(200);
 6995              		.loc 1 3265 0
 6996 3c3c 0130A0E3 		mov	r3, #1
3266:../uvc.c      ****                     
 6997              		.loc 1 3266 0
 6998 3c40 C800A0E3 		mov	r0, #200
3265:../uvc.c      ****                     CyU3PThreadSleep(200);
 6999              		.loc 1 3265 0
 7000 3c44 883087E5 		str	r3, [r7, #136]
3266:../uvc.c      ****                     
 7001              		.loc 1 3266 0
 7002 3c48 FEFFFFEB 		bl	_tx_thread_sleep
 7003              	.LVL819:
 7004 3c4c C3FFFFEA 		b	.L525
 7005              	.L597:
3099:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7006              		.loc 1 3099 0
 7007 3c50 74559FE5 		ldr	r5, .L610+100
3098:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7008              		.loc 1 3098 0
 7009 3c54 5C059FE5 		ldr	r0, .L610+80
 7010 3c58 0010E0E3 		mvn	r1, #0
3083:../uvc.c      ****                 consCount = 0;
 7011              		.loc 1 3083 0
 7012 3c5c B068C4E1 		strh	r6, [r4, #128]	@ movhi
3080:../uvc.c      ****             	pb=0;
 7013              		.loc 1 3080 0
 7014 3c60 B467C4E1 		strh	r6, [r4, #116]	@ movhi
3084:../uvc.c      ****                 hitFV     = CyFalse;
 7015              		.loc 1 3084 0
 7016 3c64 B268C4E1 		strh	r6, [r4, #130]	@ movhi
3081:../uvc.c      ****             	pbc=0;
 7017              		.loc 1 3081 0
 7018 3c68 B667C4E1 		strh	r6, [r4, #118]	@ movhi
3082:../uvc.c      ****                 prodCount = 0;
 7019              		.loc 1 3082 0
 7020 3c6c B867C4E1 		strh	r6, [r4, #120]	@ movhi
3085:../uvc.c      **** 
 7021              		.loc 1 3085 0
 7022 3c70 7C6084E5 		str	r6, [r4, #124]
3098:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 7023              		.loc 1 3098 0
 7024 3c74 FEFFFFEB 		bl	_txe_mutex_get
 7025              	.LVL820:
3099:../uvc.c      ****             	//CyU3PMutexPut(&imgHdMux);
 7026              		.loc 1 3099 0
 7027 3c78 ED34D5E5 		ldrb	r3, [r5, #1261]	@ zero_extendqisi2
 7028 3c7c 013023E2 		eor	r3, r3, #1
 7029 3c80 ED34C5E5 		strb	r3, [r5, #1261]
3101:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7030              		.loc 1 3101 0
 7031 3c84 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 7032 3c88 F00053E3 		cmp	r3, #240
 7033 3c8c 3B00000A 		beq	.L603
 7034              	.L526:
3109:../uvc.c      **** 
 7035              		.loc 1 3109 0
 7036 3c90 7230D7E5 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 7037 3c94 FF0053E3 		cmp	r3, #255
 7038 3c98 1D00000A 		beq	.L604
3121:../uvc.c      ****                     //CyU3PThreadSleep(400);
 7039              		.loc 1 3121 0
 7040 3c9c 7230D4E5 		ldrb	r3, [r4, #114]	@ zero_extendqisi2
 7041 3ca0 AA0053E3 		cmp	r3, #170
 7042 3ca4 2700000A 		beq	.L605
 7043              	.L527:
3159:../uvc.c      ****                 /* Reset the DMA channel. */
 7044              		.loc 1 3159 0
 7045 3ca8 08059FE5 		ldr	r0, .L610+80
 7046 3cac FEFFFFEB 		bl	_txe_mutex_put
 7047              	.LVL821:
3161:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7048              		.loc 1 3161 0
 7049 3cb0 10059FE5 		ldr	r0, .L610+96
 7050 3cb4 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7051              	.LVL822:
3162:../uvc.c      ****                 {
 7052              		.loc 1 3162 0
 7053 3cb8 005050E2 		subs	r5, r0, #0
 7054 3cbc 7A00001A 		bne	.L606
3169:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 7055              		.loc 1 3169 0
 7056 3cc0 0510A0E1 		mov	r1, r5
 7057 3cc4 0520A0E1 		mov	r2, r5
 7058 3cc8 F8049FE5 		ldr	r0, .L610+96
 7059              	.LVL823:
 7060 3ccc FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 7061              	.LVL824:
3170:../uvc.c      ****                 {
 7062              		.loc 1 3170 0
 7063 3cd0 005050E2 		subs	r5, r0, #0
 7064 3cd4 6800001A 		bne	.L607
 7065              	.L546:
3178:../uvc.c      ****                 }
 7066              		.loc 1 3178 0
 7067 3cd8 DC049FE5 		ldr	r0, .L610+84
 7068              	.LVL825:
 7069 3cdc 0230A0E3 		mov	r3, #2
 7070 3ce0 0010A0E3 		mov	r1, #0
 7071 3ce4 00308DE5 		str	r3, [sp]
 7072 3ce8 0020A0E1 		mov	r2, r0
 7073 3cec 0130A0E1 		mov	r3, r1
 7074 3cf0 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 7075              	.LVL826:
 7076 3cf4 99FFFFEA 		b	.L525
 7077              	.LVL827:
 7078              	.L599:
3201:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 7079              		.loc 1 3201 0
 7080 3cf8 C8049FE5 		ldr	r0, .L610+96
 7081 3cfc FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 7082              	.LVL828:
3202:../uvc.c      ****                     {
 7083              		.loc 1 3202 0
 7084 3d00 000050E3 		cmp	r0, #0
 7085 3d04 4000001A 		bne	.L578
3208:../uvc.c      ****                 }
 7086              		.loc 1 3208 0
 7087 3d08 8300A0E3 		mov	r0, #131
 7088              	.LVL829:
 7089 3d0c FEFFFFEB 		bl	CyU3PUsbFlushEp
 7090              	.LVL830:
 7091 3d10 B1FFFFEA 		b	.L548
 7092              	.L604:
3111:../uvc.c      ****                  		glUVCHeader[1] |= (1<<5);    //set still image flag
 7093              		.loc 1 3111 0
 7094 3d14 E130D4E5 		ldrb	r3, [r4, #225]	@ zero_extendqisi2
 7095 3d18 020053E3 		cmp	r3, #2
 7096 3d1c 013083E2 		add	r3, r3, #1
 7097 3d20 E130C4E5 		strb	r3, [r4, #225]
 7098 3d24 DFFFFF9A 		bls	.L527
3112:../uvc.c      ****                 		stiflag = 0x0F;
 7099              		.loc 1 3112 0
 7100 3d28 ED14D5E5 		ldrb	r1, [r5, #1261]	@ zero_extendqisi2
3113:../uvc.c      ****                 		IMcount = 0;
 7101              		.loc 1 3113 0
 7102 3d2c 0F30A0E3 		mov	r3, #15
3112:../uvc.c      ****                 		stiflag = 0x0F;
 7103              		.loc 1 3112 0
 7104 3d30 201081E3 		orr	r1, r1, #32
3114:../uvc.c      ****                 		}
 7105              		.loc 1 3114 0
 7106 3d34 0020A0E3 		mov	r2, #0
3112:../uvc.c      ****                 		stiflag = 0x0F;
 7107              		.loc 1 3112 0
 7108 3d38 ED14C5E5 		strb	r1, [r5, #1261]
3114:../uvc.c      ****                 		}
 7109              		.loc 1 3114 0
 7110 3d3c E120C4E5 		strb	r2, [r4, #225]
3113:../uvc.c      ****                 		IMcount = 0;
 7111              		.loc 1 3113 0
 7112 3d40 7230C4E5 		strb	r3, [r4, #114]
 7113 3d44 D7FFFFEA 		b	.L527
 7114              	.L605:
3127:../uvc.c      ****                 	{
 7115              		.loc 1 3127 0
 7116 3d48 E130D4E5 		ldrb	r3, [r4, #225]	@ zero_extendqisi2
 7117 3d4c 020053E3 		cmp	r3, #2
 7118 3d50 013083E2 		add	r3, r3, #1
 7119 3d54 E130C4E5 		strb	r3, [r4, #225]
 7120 3d58 D2FFFF9A 		bls	.L527
3129:../uvc.c      ****                      {
 7121              		.loc 1 3129 0
 7122 3d5c 7030D4E5 		ldrb	r3, [r4, #112]	@ zero_extendqisi2
 7123 3d60 013043E2 		sub	r3, r3, #1
 7124 3d64 030053E3 		cmp	r3, #3
 7125 3d68 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 7126 3d6c 3E0000EA 		b	.L531
 7127              	.L533:
 7128 3d70 2C3E0000 		.word	.L532
 7129 3d74 183F0000 		.word	.L534
 7130 3d78 5C3F0000 		.word	.L535
 7131 3d7c C43E0000 		.word	.L536
 7132              	.L603:
3101:../uvc.c      ****                 	                    CYU3P_NO_WAIT) == CY_U3P_SUCCESS){ //start full res.
 7133              		.loc 1 3101 0 discriminator 1
 7134 3d80 00608DE5 		str	r6, [sp]
 7135 3d84 E4039FE5 		ldr	r0, .L610+8
 7136 3d88 8010A0E3 		mov	r1, #128
 7137 3d8c 0320A0E3 		mov	r2, #3
 7138 3d90 60308DE2 		add	r3, sp, #96
 7139 3d94 FEFFFFEB 		bl	_txe_event_flags_get
 7140              	.LVL831:
 7141 3d98 000050E3 		cmp	r0, #0
 7142 3d9c BBFFFF1A 		bne	.L526
3106:../uvc.c      ****                 		IMcount = 0;
 7143              		.loc 1 3106 0
 7144 3da0 0030E0E3 		mvn	r3, #0
3107:../uvc.c      ****                 	}
 7145              		.loc 1 3107 0
 7146 3da4 E100C4E5 		strb	r0, [r4, #225]
3106:../uvc.c      ****                 		IMcount = 0;
 7147              		.loc 1 3106 0
 7148 3da8 7230C4E5 		strb	r3, [r4, #114]
3107:../uvc.c      ****                 	}
 7149              		.loc 1 3107 0
 7150 3dac BDFFFFEA 		b	.L527
 7151              	.LVL832:
 7152              	.L601:
 7153              	.LBB115:
 7154              	.LBB113:
2934:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 7155              		.loc 1 2934 0
 7156 3db0 18149FE5 		ldr	r1, .L610+104
 7157 3db4 0100A0E3 		mov	r0, #1
 7158              	.LVL833:
 7159 3db8 FEFFFFEB 		bl	CyU3PDebugPrint
 7160              	.LVL834:
2935:../uvc.c      ****     }
 7161              		.loc 1 2935 0
 7162 3dbc 10049FE5 		ldr	r0, .L610+108
 7163 3dc0 FEFFFFEB 		bl	CyU3PGpifLoad
 7164              	.LVL835:
 7165 3dc4 0050A0E1 		mov	r5, r0
 7166              	.LVL836:
 7167              	.L552:
2942:../uvc.c      ****     {
 7168              		.loc 1 2942 0
 7169 3dc8 000055E3 		cmp	r5, #0
 7170 3dcc 8800001A 		bne	.L608
 7171              	.LVL837:
2954:../uvc.c      ****     {
 7172              		.loc 1 2954 0
 7173 3dd0 4830D7E5 		ldrb	r3, [r7, #72]	@ zero_extendqisi2
 7174 3dd4 023043E2 		sub	r3, r3, #2
 7175 3dd8 FF3003E2 		and	r3, r3, #255
 7176 3ddc 010053E3 		cmp	r3, #1
 7177 3de0 95FFFF8A 		bhi	.L553
2952:../uvc.c      ****     }
 7178              		.loc 1 2952 0
 7179 3de4 0500A0E1 		mov	r0, r5
 7180 3de8 0510A0E1 		mov	r1, r5
 7181 3dec FEFFFFEB 		bl	CyU3PGpifSMStart
 7182              	.LVL838:
2958:../uvc.c      ****     {
 7183              		.loc 1 2958 0
 7184 3df0 005050E2 		subs	r5, r0, #0
 7185 3df4 90FFFF0A 		beq	.L553
2961:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7186              		.loc 1 2961 0
 7187 3df8 0400A0E3 		mov	r0, #4
 7188              	.LVL839:
 7189 3dfc D4139FE5 		ldr	r1, .L610+112
 7190 3e00 0520A0E1 		mov	r2, r5
 7191 3e04 FEFFFFEB 		bl	CyU3PDebugPrint
 7192              	.LVL840:
2962:../uvc.c      ****     }
 7193              		.loc 1 2962 0
 7194 3e08 0500A0E1 		mov	r0, r5
 7195              	.LVL841:
 7196              	.L578:
2946:../uvc.c      ****     }
 7197              		.loc 1 2946 0
 7198 3e0c FEFFFFEB 		bl	CyFxAppErrorHandler
 7199              	.LVL842:
 7200              	.L602:
2939:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 7201              		.loc 1 2939 0
 7202 3e10 C4139FE5 		ldr	r1, .L610+116
 7203 3e14 0100A0E3 		mov	r0, #1
 7204              	.LVL843:
 7205 3e18 FEFFFFEB 		bl	CyU3PDebugPrint
 7206              	.LVL844:
2940:../uvc.c      ****     }
 7207              		.loc 1 2940 0
 7208 3e1c BC039FE5 		ldr	r0, .L610+120
 7209 3e20 FEFFFFEB 		bl	CyU3PGpifLoad
 7210              	.LVL845:
 7211 3e24 0050A0E1 		mov	r5, r0
 7212              	.LVL846:
 7213 3e28 E6FFFFEA 		b	.L552
 7214              	.LVL847:
 7215              	.L532:
 7216              	.LBE113:
 7217              	.LBE115:
3132:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7218              		.loc 1 3132 0
 7219 3e2c 6C2097E5 		ldr	r2, [r7, #108]
 7220 3e30 3010A0E3 		mov	r1, #48
 7221 3e34 000052E3 		cmp	r2, #0
 7222 3e38 E420A003 		moveq	r2, #228
 7223 3e3c 6420A013 		movne	r2, #100
 7224 3e40 5230A0E3 		mov	r3, #82
 7225 3e44 0100A0E3 		mov	r0, #1
 7226 3e48 FEFFFFEB 		bl	SensorSetIrisControl
 7227              	.LVL848:
3134:../uvc.c      ****                  		break;
 7228              		.loc 1 3134 0
 7229 3e4c 6C2097E5 		ldr	r2, [r7, #108]
 7230 3e50 0400A0E3 		mov	r0, #4
 7231 3e54 000052E3 		cmp	r2, #0
 7232 3e58 6C3097E5 		ldr	r3, [r7, #108]
 7233 3e5c E420A003 		moveq	r2, #228
 7234 3e60 6420A013 		movne	r2, #100
 7235 3e64 78139FE5 		ldr	r1, .L610+124
 7236 3e68 FEFFFFEB 		bl	CyU3PDebugPrint
 7237              	.LVL849:
 7238              	.L531:
3154:../uvc.c      ****                 	//glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 7239              		.loc 1 3154 0
 7240 3e6c 0030A0E3 		mov	r3, #0
 7241 3e70 E130C7E5 		strb	r3, [r7, #225]
3156:../uvc.c      ****                 	}
 7242              		.loc 1 3156 0
 7243 3e74 7230C7E5 		strb	r3, [r7, #114]
 7244 3e78 8AFFFFEA 		b	.L527
 7245              	.LVL850:
 7246              	.L607:
3172:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7247              		.loc 1 3172 0
 7248 3e7c 0400A0E3 		mov	r0, #4
 7249              	.LVL851:
 7250 3e80 60139FE5 		ldr	r1, .L610+128
 7251 3e84 0520A0E1 		mov	r2, r5
 7252 3e88 FEFFFFEB 		bl	CyU3PDebugPrint
 7253              	.LVL852:
3173:../uvc.c      ****                 }
 7254              		.loc 1 3173 0
 7255 3e8c 0500A0E1 		mov	r0, r5
 7256 3e90 FEFFFFEB 		bl	CyFxAppErrorHandler
 7257              	.LVL853:
 7258              	.L600:
3224:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7259              		.loc 1 3224 0
 7260 3e94 0400A0E3 		mov	r0, #4
 7261              	.LVL854:
 7262 3e98 4C139FE5 		ldr	r1, .L610+132
 7263 3e9c 0520A0E1 		mov	r2, r5
 7264 3ea0 FEFFFFEB 		bl	CyU3PDebugPrint
 7265              	.LVL855:
3225:../uvc.c      ****                 }
 7266              		.loc 1 3225 0
 7267 3ea4 0500A0E1 		mov	r0, r5
 7268 3ea8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7269              	.LVL856:
 7270              	.L606:
3164:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
 7271              		.loc 1 3164 0
 7272 3eac 0400A0E3 		mov	r0, #4
 7273              	.LVL857:
 7274 3eb0 38139FE5 		ldr	r1, .L610+136
 7275 3eb4 0520A0E1 		mov	r2, r5
 7276 3eb8 FEFFFFEB 		bl	CyU3PDebugPrint
 7277              	.LVL858:
3165:../uvc.c      ****                 }
 7278              		.loc 1 3165 0
 7279 3ebc 0500A0E1 		mov	r0, r5
 7280 3ec0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7281              	.LVL859:
 7282              	.L536:
3147:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7283              		.loc 1 3147 0
 7284 3ec4 6C2097E5 		ldr	r2, [r7, #108]
 7285 3ec8 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7286 3ecc 000052E3 		cmp	r2, #0
 7287 3ed0 F420A003 		moveq	r2, #244
 7288 3ed4 7420A013 		movne	r2, #116
 7289 3ed8 032082E1 		orr	r2, r2, r3
 7290 3edc 3010A0E3 		mov	r1, #48
 7291 3ee0 5230A0E3 		mov	r3, #82
 7292 3ee4 0100A0E3 		mov	r0, #1
 7293 3ee8 FEFFFFEB 		bl	SensorSetIrisControl
 7294              	.LVL860:
3149:../uvc.c      ****                  		break;
 7295              		.loc 1 3149 0
 7296 3eec 6C1097E5 		ldr	r1, [r7, #108]
 7297 3ef0 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7298 3ef4 000051E3 		cmp	r1, #0
 7299 3ef8 F410A003 		moveq	r1, #244
 7300 3efc 7410A013 		movne	r1, #116
 7301 3f00 022081E1 		orr	r2, r1, r2
 7302 3f04 6C3097E5 		ldr	r3, [r7, #108]
 7303 3f08 D4129FE5 		ldr	r1, .L610+124
 7304 3f0c 0400A0E3 		mov	r0, #4
 7305 3f10 FEFFFFEB 		bl	CyU3PDebugPrint
 7306              	.LVL861:
3150:../uvc.c      ****                  	default:
 7307              		.loc 1 3150 0
 7308 3f14 D4FFFFEA 		b	.L531
 7309              	.L534:
3137:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7310              		.loc 1 3137 0
 7311 3f18 6C2097E5 		ldr	r2, [r7, #108]
 7312 3f1c 3010A0E3 		mov	r1, #48
 7313 3f20 000052E3 		cmp	r2, #0
 7314 3f24 D420A003 		moveq	r2, #212
 7315 3f28 5420A013 		movne	r2, #84
 7316 3f2c 5230A0E3 		mov	r3, #82
 7317 3f30 0100A0E3 		mov	r0, #1
 7318 3f34 FEFFFFEB 		bl	SensorSetIrisControl
 7319              	.LVL862:
3139:../uvc.c      ****                  		break;
 7320              		.loc 1 3139 0
 7321 3f38 6C2097E5 		ldr	r2, [r7, #108]
 7322 3f3c A0129FE5 		ldr	r1, .L610+124
 7323 3f40 000052E3 		cmp	r2, #0
 7324 3f44 6C3097E5 		ldr	r3, [r7, #108]
 7325 3f48 D420A003 		moveq	r2, #212
 7326 3f4c 5420A013 		movne	r2, #84
 7327 3f50 0400A0E3 		mov	r0, #4
 7328 3f54 FEFFFFEB 		bl	CyU3PDebugPrint
 7329              	.LVL863:
3140:../uvc.c      ****                  	case 3: //720
 7330              		.loc 1 3140 0
 7331 3f58 C3FFFFEA 		b	.L531
 7332              	.L535:
3142:../uvc.c      ****                  		//CyU3PThreadSleep(100);
 7333              		.loc 1 3142 0
 7334 3f5c 6C2097E5 		ldr	r2, [r7, #108]
 7335 3f60 5230D5E5 		ldrb	r3, [r5, #82]	@ zero_extendqisi2
 7336 3f64 000052E3 		cmp	r2, #0
 7337 3f68 C420A003 		moveq	r2, #196
 7338 3f6c 4420A013 		movne	r2, #68
 7339 3f70 032082E1 		orr	r2, r2, r3
 7340 3f74 3010A0E3 		mov	r1, #48
 7341 3f78 5230A0E3 		mov	r3, #82
 7342 3f7c 0100A0E3 		mov	r0, #1
 7343 3f80 FEFFFFEB 		bl	SensorSetIrisControl
 7344              	.LVL864:
3144:../uvc.c      ****                  		break;
 7345              		.loc 1 3144 0
 7346 3f84 6C1097E5 		ldr	r1, [r7, #108]
 7347 3f88 5220D5E5 		ldrb	r2, [r5, #82]	@ zero_extendqisi2
 7348 3f8c 000051E3 		cmp	r1, #0
 7349 3f90 C410A003 		moveq	r1, #196
 7350 3f94 4410A013 		movne	r1, #68
 7351 3f98 022081E1 		orr	r2, r1, r2
 7352 3f9c 6C3097E5 		ldr	r3, [r7, #108]
 7353 3fa0 3C129FE5 		ldr	r1, .L610+124
 7354 3fa4 0400A0E3 		mov	r0, #4
 7355 3fa8 FEFFFFEB 		bl	CyU3PDebugPrint
 7356              	.LVL865:
3145:../uvc.c      ****                  	case 4: //VGA
 7357              		.loc 1 3145 0
 7358 3fac AEFFFFEA 		b	.L531
 7359              	.LVL866:
 7360              	.L579:
 7361              	.LBB116:
 7362              	.LBB100:
2441:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7363              		.loc 1 2441 0
 7364 3fb0 0400A0E3 		mov	r0, #4
 7365              	.LVL867:
 7366 3fb4 38129FE5 		ldr	r1, .L610+140
 7367 3fb8 FEFFFFEB 		bl	CyU3PDebugPrint
 7368              	.LVL868:
2442:../uvc.c      ****     }
 7369              		.loc 1 2442 0
 7370 3fbc 0400A0E1 		mov	r0, r4
 7371 3fc0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7372              	.LVL869:
 7373              	.L609:
 7374              	.LBE100:
 7375              	.LBE116:
 7376              	.LBB117:
 7377              	.LBB107:
2907:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7378              		.loc 1 2907 0
 7379 3fc4 0800A0E1 		mov	r0, r8
 7380              	.LVL870:
 7381              	.L576:
 7382 3fc8 28129FE5 		ldr	r1, .L610+144
 7383 3fcc 0420A0E1 		mov	r2, r4
 7384 3fd0 FEFFFFEB 		bl	CyU3PDebugPrint
 7385              	.LVL871:
2908:../uvc.c      ****     }
 7386              		.loc 1 2908 0
 7387 3fd4 0400A0E1 		mov	r0, r4
 7388 3fd8 8BFFFFEA 		b	.L578
 7389              	.LVL872:
 7390              	.L595:
2882:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7391              		.loc 1 2882 0
 7392 3fdc 0800A0E1 		mov	r0, r8
 7393              	.LVL873:
 7394 3fe0 14129FE5 		ldr	r1, .L610+148
 7395 3fe4 0420A0E1 		mov	r2, r4
 7396 3fe8 FEFFFFEB 		bl	CyU3PDebugPrint
 7397              	.LVL874:
2883:../uvc.c      ****     }
 7398              		.loc 1 2883 0
 7399 3fec 0400A0E1 		mov	r0, r4
 7400 3ff0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7401              	.LVL875:
 7402              	.L608:
 7403              	.LBE107:
 7404              	.LBE117:
 7405              	.LBB118:
 7406              	.LBB114:
2945:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7407              		.loc 1 2945 0
 7408 3ff4 0400A0E3 		mov	r0, #4
 7409              	.LVL876:
 7410 3ff8 00129FE5 		ldr	r1, .L610+152
 7411 3ffc 0520A0E1 		mov	r2, r5
 7412 4000 FEFFFFEB 		bl	CyU3PDebugPrint
 7413              	.LVL877:
2946:../uvc.c      ****     }
 7414              		.loc 1 2946 0
 7415 4004 0500A0E1 		mov	r0, r5
 7416 4008 7FFFFFEA 		b	.L578
 7417              	.LVL878:
 7418              	.L583:
 7419              	.LBE114:
 7420              	.LBE118:
 7421              	.LBB119:
 7422              	.LBB108:
2598:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7423              		.loc 1 2598 0
 7424 400c 0400A0E3 		mov	r0, #4
 7425              	.LVL879:
 7426 4010 EC119FE5 		ldr	r1, .L610+156
 7427 4014 0520A0E1 		mov	r2, r5
 7428 4018 FEFFFFEB 		bl	CyU3PDebugPrint
 7429              	.LVL880:
2599:../uvc.c      ****     }
 7430              		.loc 1 2599 0
 7431 401c 0500A0E1 		mov	r0, r5
 7432 4020 FEFFFFEB 		bl	CyFxAppErrorHandler
 7433              	.LVL881:
 7434              	.L582:
2576:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7435              		.loc 1 2576 0
 7436 4024 0400A0E3 		mov	r0, #4
 7437              	.LVL882:
 7438 4028 D8119FE5 		ldr	r1, .L610+160
 7439 402c 0520A0E1 		mov	r2, r5
 7440 4030 FEFFFFEB 		bl	CyU3PDebugPrint
 7441              	.LVL883:
2577:../uvc.c      ****     }
 7442              		.loc 1 2577 0
 7443 4034 0500A0E1 		mov	r0, r5
 7444 4038 FEFFFFEB 		bl	CyFxAppErrorHandler
 7445              	.LVL884:
 7446              	.L581:
 7447              	.LBE108:
 7448              	.LBE119:
 7449              	.LBB120:
 7450              	.LBB103:
2502:../uvc.c      ****         CyFxAppErrorHandler (status);
 7451              		.loc 1 2502 0
 7452 403c 0400A0E3 		mov	r0, #4
 7453              	.LVL885:
 7454 4040 C4119FE5 		ldr	r1, .L610+164
 7455 4044 FEFFFFEB 		bl	CyU3PDebugPrint
 7456              	.LVL886:
2503:../uvc.c      ****     }
 7457              		.loc 1 2503 0
 7458 4048 0500A0E1 		mov	r0, r5
 7459 404c FEFFFFEB 		bl	CyFxAppErrorHandler
 7460              	.LVL887:
 7461              	.L580:
2489:../uvc.c      ****         CyFxAppErrorHandler (status);
 7462              		.loc 1 2489 0
 7463 4050 0400A0E3 		mov	r0, #4
 7464              	.LVL888:
 7465 4054 B4119FE5 		ldr	r1, .L610+168
 7466 4058 FEFFFFEB 		bl	CyU3PDebugPrint
 7467              	.LVL889:
2490:../uvc.c      ****     }
 7468              		.loc 1 2490 0
 7469 405c 0500A0E1 		mov	r0, r5
 7470 4060 FEFFFFEB 		bl	CyFxAppErrorHandler
 7471              	.LVL890:
 7472              	.L591:
 7473              	.LBE103:
 7474              	.LBE120:
 7475              	.LBB121:
 7476              	.LBB109:
2694:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7477              		.loc 1 2694 0
 7478 4064 0400A0E3 		mov	r0, #4
 7479              	.LVL891:
 7480 4068 A4119FE5 		ldr	r1, .L610+172
 7481 406c 0420A0E1 		mov	r2, r4
 7482 4070 FEFFFFEB 		bl	CyU3PDebugPrint
 7483              	.LVL892:
2695:../uvc.c      ****     }
 7484              		.loc 1 2695 0
 7485 4074 0400A0E1 		mov	r0, r4
 7486 4078 FEFFFFEB 		bl	CyFxAppErrorHandler
 7487              	.LVL893:
 7488              	.L590:
2673:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7489              		.loc 1 2673 0
 7490 407c 0400A0E3 		mov	r0, #4
 7491              	.LVL894:
 7492 4080 90119FE5 		ldr	r1, .L610+176
 7493 4084 0420A0E1 		mov	r2, r4
 7494 4088 FEFFFFEB 		bl	CyU3PDebugPrint
 7495              	.LVL895:
2674:../uvc.c      ****     }
 7496              		.loc 1 2674 0
 7497 408c 0400A0E1 		mov	r0, r4
 7498 4090 FEFFFFEB 		bl	CyFxAppErrorHandler
 7499              	.LVL896:
 7500              	.L589:
2660:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7501              		.loc 1 2660 0
 7502 4094 0400A0E3 		mov	r0, #4
 7503              	.LVL897:
 7504 4098 7C119FE5 		ldr	r1, .L610+180
 7505 409c 0420A0E1 		mov	r2, r4
 7506 40a0 FEFFFFEB 		bl	CyU3PDebugPrint
 7507              	.LVL898:
2661:../uvc.c      ****     }
 7508              		.loc 1 2661 0
 7509 40a4 0400A0E1 		mov	r0, r4
 7510 40a8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7511              	.LVL899:
 7512              	.L588:
2646:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7513              		.loc 1 2646 0
 7514 40ac 0400A0E3 		mov	r0, #4
 7515              	.LVL900:
 7516 40b0 68119FE5 		ldr	r1, .L610+184
 7517 40b4 0420A0E1 		mov	r2, r4
 7518 40b8 FEFFFFEB 		bl	CyU3PDebugPrint
 7519              	.LVL901:
2647:../uvc.c      ****     }
 7520              		.loc 1 2647 0
 7521 40bc 0400A0E1 		mov	r0, r4
 7522 40c0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7523              	.LVL902:
 7524              	.L587:
2632:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7525              		.loc 1 2632 0
 7526 40c4 0400A0E3 		mov	r0, #4
 7527              	.LVL903:
 7528 40c8 54119FE5 		ldr	r1, .L610+188
 7529 40cc 0620A0E1 		mov	r2, r6
 7530 40d0 FEFFFFEB 		bl	CyU3PDebugPrint
 7531              	.LVL904:
2633:../uvc.c      ****     }
 7532              		.loc 1 2633 0
 7533 40d4 0600A0E1 		mov	r0, r6
 7534 40d8 FEFFFFEB 		bl	CyFxAppErrorHandler
 7535              	.LVL905:
 7536              	.L586:
2619:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7537              		.loc 1 2619 0
 7538 40dc 0400A0E3 		mov	r0, #4
 7539              	.LVL906:
 7540 40e0 40119FE5 		ldr	r1, .L610+192
 7541 40e4 0520A0E1 		mov	r2, r5
 7542 40e8 FEFFFFEB 		bl	CyU3PDebugPrint
 7543              	.LVL907:
2620:../uvc.c      ****     }
 7544              		.loc 1 2620 0
 7545 40ec 0500A0E1 		mov	r0, r5
 7546 40f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 7547              	.LVL908:
 7548              	.L585:
2613:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7549              		.loc 1 2613 0
 7550 40f4 0400A0E3 		mov	r0, #4
 7551              	.LVL909:
 7552 40f8 2C119FE5 		ldr	r1, .L610+196
 7553 40fc 0520A0E1 		mov	r2, r5
 7554 4100 FEFFFFEB 		bl	CyU3PDebugPrint
 7555              	.LVL910:
2614:../uvc.c      ****     }
 7556              		.loc 1 2614 0
 7557 4104 0500A0E1 		mov	r0, r5
 7558 4108 FEFFFFEB 		bl	CyFxAppErrorHandler
 7559              	.LVL911:
 7560              	.L584:
2607:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7561              		.loc 1 2607 0
 7562 410c 0400A0E3 		mov	r0, #4
 7563              	.LVL912:
 7564 4110 18119FE5 		ldr	r1, .L610+200
 7565 4114 0520A0E1 		mov	r2, r5
 7566 4118 FEFFFFEB 		bl	CyU3PDebugPrint
 7567              	.LVL913:
2608:../uvc.c      ****     }
 7568              		.loc 1 2608 0
 7569 411c 0500A0E1 		mov	r0, r5
 7570 4120 FEFFFFEB 		bl	CyFxAppErrorHandler
 7571              	.LVL914:
 7572              	.L594:
2791:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7573              		.loc 1 2791 0
 7574 4124 0800A0E1 		mov	r0, r8
 7575              	.LVL915:
 7576 4128 04119FE5 		ldr	r1, .L610+204
 7577 412c 0420A0E1 		mov	r2, r4
 7578 4130 FEFFFFEB 		bl	CyU3PDebugPrint
 7579              	.LVL916:
2792:../uvc.c      ****     }
 7580              		.loc 1 2792 0
 7581 4134 0400A0E1 		mov	r0, r4
 7582 4138 FEFFFFEB 		bl	CyFxAppErrorHandler
 7583              	.LVL917:
 7584              	.L592:
2760:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 7585              		.loc 1 2760 0
 7586 413c 0400A0E3 		mov	r0, #4
 7587              	.LVL918:
 7588 4140 F0109FE5 		ldr	r1, .L610+208
 7589 4144 0420A0E1 		mov	r2, r4
 7590 4148 FEFFFFEB 		bl	CyU3PDebugPrint
 7591              	.LVL919:
2761:../uvc.c      ****     }
 7592              		.loc 1 2761 0
 7593 414c 0400A0E1 		mov	r0, r4
 7594 4150 FEFFFFEB 		bl	CyFxAppErrorHandler
 7595              	.LVL920:
 7596              	.L593:
2767:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
 7597              		.loc 1 2767 0
 7598 4154 0400A0E3 		mov	r0, #4
 7599 4158 DC109FE5 		ldr	r1, .L610+212
 7600 415c FEFFFFEB 		bl	CyU3PDebugPrint
 7601              	.LVL921:
2768:../uvc.c      ****     }
 7602              		.loc 1 2768 0
 7603 4160 0800A0E1 		mov	r0, r8
 7604 4164 FEFFFFEB 		bl	CyFxAppErrorHandler
 7605              	.LVL922:
 7606              	.L611:
 7607              		.align	2
 7608              	.L610:
 7609 4168 00C20100 		.word	115200
 7610 416c A0860100 		.word	100000
 7611 4170 00000000 		.word	.LANCHOR0
 7612 4174 00000000 		.word	CyFxGpifCB
 7613 4178 88130000 		.word	5000
 7614 417c 00000000 		.word	CyFxUVCApplnUSBSetupCB
 7615 4180 00000000 		.word	CyFxUVCApplnUSBEventCB
 7616 4184 00000000 		.word	CyFxUSBDeviceDscr
 7617 4188 00000000 		.word	CyFxUSBDeviceDscrSS
 7618 418c 00000000 		.word	CyFxUSBDeviceQualDscr
 7619 4190 00000000 		.word	CyFxUSBBOSDscr
 7620 4194 00000000 		.word	CyFxUSBHSConfigDscr
 7621 4198 00000000 		.word	CyFxUSBFSConfigDscr
 7622 419c 00000000 		.word	CyFxUSBSSConfigDscr
 7623 41a0 00000000 		.word	CyFxUSBStringLangIDDscr
 7624 41a4 00000000 		.word	CyFxUSBManufactureDscr
 7625 41a8 00000000 		.word	CyFxUSBProductDscr
 7626 41ac 013F0203 		.word	50478849
 7627 41b0 00000000 		.word	glChHandleInterStat
 7628 41b4 00000000 		.word	glInterStaBuffer
 7629 41b8 00000000 		.word	imgHdMux
 7630 41bc 01010000 		.word	257
 7631 41c0 03030000 		.word	771
 7632 41c4 00000000 		.word	CyFxUvcApplnDmaCallback
 7633 41c8 00000000 		.word	glChHandleUVCStream
 7634 41cc 00000000 		.word	.LANCHOR1
 7635 41d0 400B0000 		.word	.LC65
 7636 41d4 20000000 		.word	.LANCHOR2+32
 7637 41d8 980B0000 		.word	.LC68
 7638 41dc 500B0000 		.word	.LC66
 7639 41e0 3C000000 		.word	.LANCHOR2+60
 7640 41e4 880A0000 		.word	.LC61
 7641 41e8 D80A0000 		.word	.LC63
 7642 41ec 0C0B0000 		.word	.LC64
 7643 41f0 AC0A0000 		.word	.LC62
 7644 41f4 5C070000 		.word	.LC43
 7645 41f8 84090000 		.word	.LC56
 7646 41fc 600A0000 		.word	.LC60
 7647 4200 600B0000 		.word	.LC67
 7648 4204 E0070000 		.word	.LC47
 7649 4208 B4070000 		.word	.LC46
 7650 420c 98070000 		.word	.LC45
 7651 4210 7C070000 		.word	.LC44
 7652 4214 54090000 		.word	.LC55
 7653 4218 24090000 		.word	.LC54
 7654 421c EC080000 		.word	.LC53
 7655 4220 B8080000 		.word	.LC52
 7656 4224 84080000 		.word	.LC51
 7657 4228 58080000 		.word	.LC50
 7658 422c 2C080000 		.word	.LC49
 7659 4230 04080000 		.word	.LC48
 7660 4234 300A0000 		.word	.LC59
 7661 4238 B8090000 		.word	.LC57
 7662 423c F8090000 		.word	.LC58
 7663              	.LBE109:
 7664              	.LBE121:
 7665              		.cfi_endproc
 7666              	.LFE19:
 7668              		.align	2
 7669              		.global	UVCAppEP0Thread_Entry
 7671              	UVCAppEP0Thread_Entry:
 7672              	.LFB25:
4048:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7673              		.loc 1 4048 0
 7674              		.cfi_startproc
 7675              		@ args = 0, pretend = 0, frame = 48
 7676              		@ frame_needed = 0, uses_anonymous_args = 0
 7677              	.LVL923:
 7678 4240 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7679              	.LCFI27:
 7680              		.cfi_def_cfa_offset 36
 7681              		.cfi_offset 4, -36
 7682              		.cfi_offset 5, -32
 7683              		.cfi_offset 6, -28
 7684              		.cfi_offset 7, -24
 7685              		.cfi_offset 8, -20
 7686              		.cfi_offset 9, -16
 7687              		.cfi_offset 10, -12
 7688              		.cfi_offset 11, -8
 7689              		.cfi_offset 14, -4
 7690 4244 58BF9FE5 		ldr	fp, .L981
 7691 4248 9CAF9FE5 		ldr	r10, .L981+72
 7692 424c 545F9FE5 		ldr	r5, .L981+4
4122:../uvc.c      ****                 {
 7693              		.loc 1 4122 0
 7694 4250 549F9FE5 		ldr	r9, .L981+8
4048:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
 7695              		.loc 1 4048 0
 7696 4254 4CD04DE2 		sub	sp, sp, #76
 7697              	.LCFI28:
 7698              		.cfi_def_cfa_offset 112
 7699              	.LVL924:
4070:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
 7700              		.loc 1 4070 0
 7701 4258 0B40A0E1 		mov	r4, fp
 7702              	.LVL925:
 7703              	.L888:
 7704 425c 0030E0E3 		mvn	r3, #0
 7705 4260 00308DE5 		str	r3, [sp]
 7706 4264 380F9FE5 		ldr	r0, .L981
 7707 4268 4C10A0E3 		mov	r1, #76
 7708 426c 0120A0E3 		mov	r2, #1
 7709 4270 34308DE2 		add	r3, sp, #52
 7710 4274 FEFFFFEB 		bl	_txe_event_flags_get
 7711              	.LVL926:
 7712 4278 000050E3 		cmp	r0, #0
 7713 427c 3C00001A 		bne	.L614
4074:../uvc.c      ****             {
 7714              		.loc 1 4074 0
 7715 4280 8C3094E5 		ldr	r3, [r4, #140]
 7716 4284 000053E3 		cmp	r3, #0
 7717 4288 8B00000A 		beq	.L950
 7718              	.L616:
4083:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 7719              		.loc 1 4083 0
 7720 428c 34309DE5 		ldr	r3, [sp, #52]
 7721 4290 0C0013E3 		tst	r3, #12
 7722 4294 7200001A 		bne	.L951
 7723              	.L618:
4090:../uvc.c      ****             {
 7724              		.loc 1 4090 0
 7725 4298 040013E3 		tst	r3, #4
 7726 429c 2000000A 		beq	.L619
4092:../uvc.c      ****                 {
 7727              		.loc 1 4092 0
 7728 42a0 B020D9E1 		ldrh	r2, [r9]
 7729 42a4 2224A0E1 		mov	r2, r2, lsr #8
 7730 42a8 030052E3 		cmp	r2, #3
 7731 42ac 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 7732 42b0 160000EA 		b	.L620
 7733              	.L622:
 7734 42b4 10430000 		.word	.L620
 7735 42b8 C4420000 		.word	.L623
 7736 42bc 7C430000 		.word	.L624
 7737 42c0 18440000 		.word	.L625
 7738              	.L623:
 7739              	.LBB168:
 7740              	.LBB169:
3371:../uvc.c      ****     {
 7741              		.loc 1 3371 0
 7742 42c4 E46E9FE5 		ldr	r6, .L981+12
 7743 42c8 B020D6E1 		ldrh	r2, [r6]
 7744 42cc 060C52E3 		cmp	r2, #1536
 7745 42d0 4302000A 		beq	.L716
 7746 42d4 F400009A 		bls	.L952
 7747 42d8 090C52E3 		cmp	r2, #2304
 7748 42dc 5102000A 		beq	.L724
 7749 42e0 5501009A 		bls	.L953
 7750 42e4 0B0C52E3 		cmp	r2, #2816
 7751 42e8 C101000A 		beq	.L727
 7752 42ec 030B52E3 		cmp	r2, #3072
 7753 42f0 F201000A 		beq	.L728
 7754 42f4 0A0C52E3 		cmp	r2, #2560
 7755 42f8 D601000A 		beq	.L954
 7756              	.L715:
3428:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 7757              		.loc 1 3428 0
 7758 42fc B03E9FE5 		ldr	r3, .L981+16
 7759 4300 0400A0E3 		mov	r0, #4
 7760 4304 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 7761 4308 A81E9FE5 		ldr	r1, .L981+20
 7762 430c FEFFFFEB 		bl	CyU3PDebugPrint
 7763              	.LVL927:
 7764              	.L620:
 7765              	.LBE169:
 7766              	.LBE168:
4113:../uvc.c      ****                         break;
 7767              		.loc 1 4113 0
 7768 4310 0000A0E3 		mov	r0, #0
 7769 4314 0020A0E1 		mov	r2, r0
 7770 4318 0110A0E3 		mov	r1, #1
 7771 431c FEFFFFEB 		bl	CyU3PUsbStall
 7772              	.LVL928:
 7773 4320 34309DE5 		ldr	r3, [sp, #52]
 7774              	.L619:
4118:../uvc.c      ****             {
 7775              		.loc 1 4118 0
 7776 4324 080013E3 		tst	r3, #8
 7777 4328 0700000A 		beq	.L882
4122:../uvc.c      ****                 {
 7778              		.loc 1 4122 0
 7779 432c B030D9E1 		ldrh	r3, [r9]
 7780 4330 010053E3 		cmp	r3, #1
 7781 4334 6600000A 		beq	.L883
4124:../uvc.c      ****                 }
 7782              		.loc 1 4124 0
 7783 4338 0000A0E3 		mov	r0, #0
 7784 433c 0020A0E1 		mov	r2, r0
 7785 4340 0110A0E3 		mov	r1, #1
 7786 4344 FEFFFFEB 		bl	CyU3PUsbStall
 7787              	.LVL929:
 7788 4348 34309DE5 		ldr	r3, [sp, #52]
 7789              	.L882:
4133:../uvc.c      ****             {
 7790              		.loc 1 4133 0
 7791 434c 400013E3 		tst	r3, #64
 7792 4350 0700000A 		beq	.L614
4138:../uvc.c      **** 
 7793              		.loc 1 4138 0
 7794 4354 1800A0E3 		mov	r0, #24
 7795 4358 38108DE2 		add	r1, sp, #56
 7796              	.LVL930:
 7797 435c FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
 7798              	.LVL931:
4195:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7799              		.loc 1 4195 0
 7800 4360 0837DAE5 		ldrb	r3, [r10, #1800]	@ zero_extendqisi2
 7801 4364 0F0053E3 		cmp	r3, #15
 7802 4368 7C00000A 		beq	.L955
4222:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
 7803              		.loc 1 4222 0
 7804 436c 000053E3 		cmp	r3, #0
 7805 4370 5A00000A 		beq	.L956
 7806              	.L614:
4346:../uvc.c      ****     }
 7807              		.loc 1 4346 0
 7808 4374 FEFFFFEB 		bl	_txe_thread_relinquish
 7809              	.LVL932:
4347:../uvc.c      **** }
 7810              		.loc 1 4347 0
 7811 4378 B7FFFFEA 		b	.L888
 7812              	.L624:
 7813              	.LBB329:
 7814              	.LBB330:
3296:../uvc.c      ****     {
 7815              		.loc 1 3296 0
 7816 437c 2CEE9FE5 		ldr	lr, .L981+12
 7817 4380 B020DEE1 		ldrh	r2, [lr]
 7818 4384 060C52E3 		cmp	r2, #1536
 7819 4388 6001000A 		beq	.L627
 7820 438c 9300008A 		bhi	.L628
 7821 4390 030C52E3 		cmp	r2, #768
 7822 4394 5501000A 		beq	.L629
 7823 4398 0001008A 		bhi	.L630
 7824 439c 010C52E3 		cmp	r2, #256
 7825 43a0 8F01000A 		beq	.L631
 7826 43a4 020C52E3 		cmp	r2, #512
 7827 43a8 D3FFFF1A 		bne	.L715
 7828              	.LVL933:
 7829              	.LBB331:
 7830              	.LBB332:
 757:../uvc.c      ****     /*
 7831              		.loc 1 757 0
 7832 43ac 003E9FE5 		ldr	r3, .L981+16
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 7833              		.loc 1 748 0
 7834 43b0 0402DAE5 		ldrb	r0, [r10, #516]	@ zero_extendqisi2
 7835              	.LVL934:
 757:../uvc.c      ****     /*
 7836              		.loc 1 757 0
 7837 43b4 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 7838              		.loc 1 749 0
 7839 43b8 05C2DAE5 		ldrb	ip, [r10, #517]	@ zero_extendqisi2
 7840              	.LVL935:
 765:../uvc.c      **** 		 {
 7841              		.loc 1 765 0
 7842 43bc 830056E3 		cmp	r6, #131
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 7843              		.loc 1 750 0
 7844 43c0 1332DAE5 		ldrb	r3, [r10, #531]	@ zero_extendqisi2
 7845              	.LVL936:
 751:../uvc.c      ****     }
 7846              		.loc 1 751 0
 7847 43c4 0672DAE5 		ldrb	r7, [r10, #518]	@ zero_extendqisi2
 7848              	.LVL937:
 765:../uvc.c      **** 		 {
 7849              		.loc 1 765 0
 7850 43c8 0D06000A 		beq	.L641
 7851 43cc 3E03009A 		bls	.L957
 7852 43d0 850056E3 		cmp	r6, #133
 7853 43d4 9405000A 		beq	.L646
 7854 43d8 DB05003A 		bcc	.L647
 7855 43dc 860056E3 		cmp	r6, #134
 7856 43e0 0E05000A 		beq	.L648
 7857 43e4 870056E3 		cmp	r6, #135
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 7858              		.loc 1 1190 0
 7859 43e8 0F22DA05 		ldreqb	r2, [r10, #527]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 7860              		.loc 1 1191 0
 7861 43ec 1032DA05 		ldreqb	r3, [r10, #528]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 7862              		.loc 1 765 0
 7863 43f0 CD05001A 		bne	.L640
 7864              	.L920:
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7865              		.loc 1 1131 0
 7866 43f4 F41D9FE5 		ldr	r1, .L981+76
 7867 43f8 0700A0E1 		mov	r0, r7
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 7868              		.loc 1 1128 0
 7869 43fc 2820CBE5 		strb	r2, [fp, #40]
 7870              	.L919:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7871              		.loc 1 753 0
 7872 4400 FF70A0E3 		mov	r7, #255
1129:../uvc.c      **** 			 }
 7873              		.loc 1 1129 0
 7874 4404 2930CBE5 		strb	r3, [fp, #41]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 7875              		.loc 1 753 0
 7876 4408 0780A0E1 		mov	r8, r7
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 7877              		.loc 1 1131 0
 7878 440c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 7879              	.LVL938:
1132:../uvc.c      **** 			  break;
 7880              		.loc 1 1132 0
 7881 4410 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 7882              	.LVL939:
 7883 4414 570300EA 		b	.L650
 7884              	.LVL940:
 7885              	.L625:
 7886              	.LBE332:
 7887              	.LBE331:
 7888              	.LBE330:
 7889              	.LBE329:
 7890              	.LBB434:
 7891              	.LBB435:
3596:../uvc.c      ****     {
 7892              		.loc 1 3596 0
 7893 4418 902D9FE5 		ldr	r2, .L981+12
 7894 441c B030D2E1 		ldrh	r3, [r2]
 7895 4420 090C53E3 		cmp	r3, #2304
 7896 4424 7202000A 		beq	.L840
 7897 4428 9100009A 		bls	.L958
 7898 442c 0F0C53E3 		cmp	r3, #3840
 7899 4430 7B02000A 		beq	.L852
 7900 4434 CE00008A 		bhi	.L853
 7901 4438 0B0C53E3 		cmp	r3, #2816
 7902 443c 6802000A 		beq	.L854
 7903 4440 3302009A 		bls	.L959
 7904 4444 030B53E3 		cmp	r3, #3072
 7905 4448 3E02000A 		beq	.L857
 7906 444c 0D0C53E3 		cmp	r3, #3328
 7907 4450 AEFFFF1A 		bne	.L620
 7908              	.LVL941:
3653:../uvc.c      ****     		break;
 7909              		.loc 1 3653 0
 7910 4454 1C00A0E3 		mov	r0, #28
 7911 4458 FEFFFFEB 		bl	ControlHandle
 7912              	.LVL942:
 7913 445c 34309DE5 		ldr	r3, [sp, #52]
 7914 4460 AFFFFFEA 		b	.L619
 7915              	.L951:
 7916              	.LBE435:
 7917              	.LBE434:
4084:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
 7918              		.loc 1 4084 0
 7919 4464 500D9FE5 		ldr	r0, .L981+24
 7920 4468 441D9FE5 		ldr	r1, .L981+16
 7921 446c 4C2D9FE5 		ldr	r2, .L981+28
 7922 4470 0000D0E5 		ldrb	r0, [r0]	@ zero_extendqisi2
 7923 4474 346D9FE5 		ldr	r6, .L981+12
 7924 4478 00E0D1E5 		ldrb	lr, [r1]	@ zero_extendqisi2
 7925 447c B010D2E1 		ldrh	r1, [r2]
 7926 4480 B0C0D6E1 		ldrh	ip, [r6]
 7927 4484 4820DBE5 		ldrb	r2, [fp, #72]	@ zero_extendqisi2
 7928 4488 00008DE5 		str	r0, [sp]
 7929 448c B000D9E1 		ldrh	r0, [r9]
 7930 4490 10108DE5 		str	r1, [sp, #16]
 7931 4494 0010A0E3 		mov	r1, #0
 7932 4498 0C008DE5 		str	r0, [sp, #12]
 7933 449c 14108DE5 		str	r1, [sp, #20]
 7934 44a0 04E08DE5 		str	lr, [sp, #4]
 7935 44a4 08C08DE5 		str	ip, [sp, #8]
 7936 44a8 0400A0E3 		mov	r0, #4
 7937 44ac 101D9FE5 		ldr	r1, .L981+32
 7938 44b0 FEFFFFEB 		bl	CyU3PDebugPrint
 7939              	.LVL943:
 7940 44b4 34309DE5 		ldr	r3, [sp, #52]
 7941 44b8 76FFFFEA 		b	.L618
 7942              	.L950:
4076:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7943              		.loc 1 4076 0
 7944 44bc FEFFFFEB 		bl	CyU3PUsbGetSpeed
 7945              	.LVL944:
4077:../uvc.c      ****                 {
 7946              		.loc 1 4077 0
 7947 44c0 000050E3 		cmp	r0, #0
4079:../uvc.c      ****                 }
 7948              		.loc 1 4079 0
 7949 44c4 0130A013 		movne	r3, #1
4076:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 7950              		.loc 1 4076 0
 7951 44c8 4800C4E5 		strb	r0, [r4, #72]
4079:../uvc.c      ****                 }
 7952              		.loc 1 4079 0
 7953 44cc 8C308415 		strne	r3, [r4, #140]
 7954 44d0 6DFFFFEA 		b	.L616
 7955              	.L883:
4128:../uvc.c      ****                 }
 7956              		.loc 1 4128 0
 7957 44d4 D8EEFFEB 		bl	UVCHandleVideoStreamingRqts
 7958              	.LVL945:
 7959 44d8 34309DE5 		ldr	r3, [sp, #52]
 7960 44dc 9AFFFFEA 		b	.L882
 7961              	.L956:
4224:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 7962              		.loc 1 4224 0
 7963 44e0 002095E5 		ldr	r2, [r5]
 7964 44e4 0210A0E3 		mov	r1, #2
 7965 44e8 0010C2E5 		strb	r1, [r2]
4225:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 7966              		.loc 1 4225 0
 7967 44ec 002095E5 		ldr	r2, [r5]
 7968 44f0 0160A0E3 		mov	r6, #1
 7969 44f4 0160C2E5 		strb	r6, [r2, #1]
4226:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7970              		.loc 1 4226 0
 7971 44f8 001095E5 		ldr	r1, [r5]
4230:../uvc.c      **** 					interStabuf.status = 0;
 7972              		.loc 1 4230 0
 7973 44fc 012BA0E3 		mov	r2, #1024
4226:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 7974              		.loc 1 4226 0
 7975 4500 0230C1E5 		strb	r3, [r1, #2]
4227:../uvc.c      **** 
 7976              		.loc 1 4227 0
 7977 4504 001095E5 		ldr	r1, [r5]
4233:../uvc.c      **** 
 7978              		.loc 1 4233 0
 7979 4508 0470A0E3 		mov	r7, #4
4227:../uvc.c      **** 
 7980              		.loc 1 4227 0
 7981 450c 0360C1E5 		strb	r6, [r1, #3]
4229:../uvc.c      **** 					interStabuf.size   = 1024;
 7982              		.loc 1 4229 0
 7983 4510 001095E5 		ldr	r1, [r5]
4236:../uvc.c      **** 
 7984              		.loc 1 4236 0
 7985 4514 AC0C9FE5 		ldr	r0, .L981+36
4229:../uvc.c      **** 					interStabuf.size   = 1024;
 7986              		.loc 1 4229 0
 7987 4518 3C108DE5 		str	r1, [sp, #60]
4236:../uvc.c      **** 
 7988              		.loc 1 4236 0
 7989 451c 0010E0E3 		mvn	r1, #0
4231:../uvc.c      **** 
 7990              		.loc 1 4231 0
 7991 4520 B434CDE1 		strh	r3, [sp, #68]	@ movhi
4230:../uvc.c      **** 					interStabuf.status = 0;
 7992              		.loc 1 4230 0
 7993 4524 B224CDE1 		strh	r2, [sp, #66]	@ movhi
4233:../uvc.c      **** 
 7994              		.loc 1 4233 0
 7995 4528 B074CDE1 		strh	r7, [sp, #64]	@ movhi
4236:../uvc.c      **** 
 7996              		.loc 1 4236 0
 7997 452c FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 7998              	.LVL946:
4239:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 7999              		.loc 1 4239 0
 8000 4530 900C9FE5 		ldr	r0, .L981+36
 8001 4534 3C108DE2 		add	r1, sp, #60
 8002 4538 FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8003              	.LVL947:
4241:../uvc.c      **** 					{
 8004              		.loc 1 4241 0
 8005 453c 000050E3 		cmp	r0, #0
 8006 4540 F901001A 		bne	.L960
4247:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
 8007              		.loc 1 4247 0
 8008 4544 0500A0E3 		mov	r0, #5
 8009              	.LVL948:
 8010 4548 3010A0E3 		mov	r1, #48
 8011 454c 0620A0E1 		mov	r2, r6
 8012 4550 FEFFFFEB 		bl	SensorSetControl
 8013              	.LVL949:
4248:../uvc.c      **** 				}
 8014              		.loc 1 4248 0
 8015 4554 90EC9FE5 		ldr	lr, .L981+72
 8016 4558 0867CEE5 		strb	r6, [lr, #1800]
 8017 455c 84FFFFEA 		b	.L614
 8018              	.L955:
4197:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 8019              		.loc 1 4197 0
 8020 4560 003095E5 		ldr	r3, [r5]
 8021 4564 0220A0E3 		mov	r2, #2
 8022 4568 0020C3E5 		strb	r2, [r3]
4198:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 8023              		.loc 1 4198 0
 8024 456c 003095E5 		ldr	r3, [r5]
 8025 4570 0160A0E3 		mov	r6, #1
 8026 4574 0160C3E5 		strb	r6, [r3, #1]
4199:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 8027              		.loc 1 4199 0
 8028 4578 002095E5 		ldr	r2, [r5]
 8029 457c 0030A0E3 		mov	r3, #0
 8030 4580 0230C2E5 		strb	r3, [r2, #2]
4200:../uvc.c      **** 
 8031              		.loc 1 4200 0
 8032 4584 001095E5 		ldr	r1, [r5]
4203:../uvc.c      **** 					interStabuf.status = 0;
 8033              		.loc 1 4203 0
 8034 4588 012BA0E3 		mov	r2, #1024
4200:../uvc.c      **** 
 8035              		.loc 1 4200 0
 8036 458c 0330C1E5 		strb	r3, [r1, #3]
4202:../uvc.c      **** 					interStabuf.size   = 1024;
 8037              		.loc 1 4202 0
 8038 4590 001095E5 		ldr	r1, [r5]
4206:../uvc.c      **** 
 8039              		.loc 1 4206 0
 8040 4594 0480A0E3 		mov	r8, #4
4202:../uvc.c      **** 					interStabuf.size   = 1024;
 8041              		.loc 1 4202 0
 8042 4598 3C108DE5 		str	r1, [sp, #60]
4209:../uvc.c      **** 
 8043              		.loc 1 4209 0
 8044 459c 240C9FE5 		ldr	r0, .L981+36
 8045 45a0 0010E0E3 		mvn	r1, #0
4203:../uvc.c      **** 					interStabuf.status = 0;
 8046              		.loc 1 4203 0
 8047 45a4 B224CDE1 		strh	r2, [sp, #66]	@ movhi
4204:../uvc.c      **** 
 8048              		.loc 1 4204 0
 8049 45a8 B434CDE1 		strh	r3, [sp, #68]	@ movhi
4206:../uvc.c      **** 
 8050              		.loc 1 4206 0
 8051 45ac B084CDE1 		strh	r8, [sp, #64]	@ movhi
4209:../uvc.c      **** 
 8052              		.loc 1 4209 0
 8053 45b0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
 8054              	.LVL950:
4212:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
 8055              		.loc 1 4212 0
 8056 45b4 0C0C9FE5 		ldr	r0, .L981+36
 8057 45b8 3C108DE2 		add	r1, sp, #60
 8058 45bc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 8059              	.LVL951:
4214:../uvc.c      **** 					{
 8060              		.loc 1 4214 0
 8061 45c0 002050E2 		subs	r2, r0, #0
 8062 45c4 4A04001A 		bne	.L961
4219:../uvc.c      **** 
 8063              		.loc 1 4219 0
 8064 45c8 0500A0E3 		mov	r0, #5
 8065              	.LVL952:
 8066 45cc 3010A0E3 		mov	r1, #48
 8067 45d0 FEFFFFEB 		bl	SensorSetControl
 8068              	.LVL953:
4221:../uvc.c      **** 				}else if(!snapButFlag){
 8069              		.loc 1 4221 0
 8070 45d4 103C9FE5 		ldr	r3, .L981+72
 8071 45d8 0867C3E5 		strb	r6, [r3, #1800]
 8072 45dc 64FFFFEA 		b	.L614
 8073              	.L628:
 8074              	.LBB461:
 8075              	.LBB425:
3296:../uvc.c      ****     {
 8076              		.loc 1 3296 0
 8077 45e0 0A0C52E3 		cmp	r2, #2560
 8078 45e4 CD00000A 		beq	.L634
 8079 45e8 7400009A 		bls	.L962
 8080 45ec 0D0C52E3 		cmp	r2, #3328
 8081 45f0 CA00000A 		beq	.L634
 8082 45f4 0E0C52E3 		cmp	r2, #3584
 8083 45f8 DF00000A 		beq	.L638
 8084 45fc 030B52E3 		cmp	r2, #3072
 8085 4600 3DFFFF1A 		bne	.L715
 8086              	.L683:
 8087              	.LVL954:
 8088              	.LBB342:
 8089              	.LBB343:
 757:../uvc.c      ****     /*
 8090              		.loc 1 757 0
 8091 4604 A82B9FE5 		ldr	r2, .L981+16
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 8092              		.loc 1 749 0
 8093 4608 F512DAE5 		ldrb	r1, [r10, #757]	@ zero_extendqisi2
 757:../uvc.c      ****     /*
 8094              		.loc 1 757 0
 8095 460c 0060D2E5 		ldrb	r6, [r2]	@ zero_extendqisi2
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8096              		.loc 1 748 0
 8097 4610 F432DAE5 		ldrb	r3, [r10, #756]	@ zero_extendqisi2
 8098              	.LVL955:
 765:../uvc.c      **** 		 {
 8099              		.loc 1 765 0
 8100 4614 830056E3 		cmp	r6, #131
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 8101              		.loc 1 749 0
 8102 4618 24108DE5 		str	r1, [sp, #36]
 8103              	.LVL956:
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8104              		.loc 1 750 0
 8105 461c 03C3DAE5 		ldrb	ip, [r10, #771]	@ zero_extendqisi2
 8106              	.LVL957:
 751:../uvc.c      ****     }
 8107              		.loc 1 751 0
 8108 4620 F672DAE5 		ldrb	r7, [r10, #758]	@ zero_extendqisi2
 8109              	.LVL958:
 765:../uvc.c      **** 		 {
 8110              		.loc 1 765 0
 8111 4624 8605000A 		beq	.L688
 8112 4628 7602009A 		bls	.L963
 8113 462c 850056E3 		cmp	r6, #133
 8114 4630 0205000A 		beq	.L693
 8115 4634 8E05003A 		bcc	.L694
 8116 4638 860056E3 		cmp	r6, #134
 8117 463c 5704000A 		beq	.L695
 8118 4640 870056E3 		cmp	r6, #135
 8119 4644 EF04001A 		bne	.L864
1185:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 8120              		.loc 1 1185 0
 8121 4648 FF32DAE5 		ldrb	r3, [r10, #767]	@ zero_extendqisi2
1187:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 8122              		.loc 1 1187 0
 8123 464c 00C3DAE5 		ldrb	ip, [r10, #768]	@ zero_extendqisi2
1186:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 8124              		.loc 1 1186 0
 8125 4650 0020A0E3 		mov	r2, #0
1185:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 8126              		.loc 1 1185 0
 8127 4654 2830CBE5 		strb	r3, [fp, #40]
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8128              		.loc 1 1193 0
 8129 4658 0700A0E1 		mov	r0, r7
 8130 465c 8C1B9FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8131              		.loc 1 753 0
 8132 4660 FF30A0E3 		mov	r3, #255
1187:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 8133              		.loc 1 1187 0
 8134 4664 2AC0CBE5 		strb	ip, [fp, #42]
1186:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 8135              		.loc 1 1186 0
 8136 4668 2920CBE5 		strb	r2, [fp, #41]
1188:../uvc.c      **** 			 }else{
 8137              		.loc 1 1188 0
 8138 466c 2B20CBE5 		strb	r2, [fp, #43]
 8139 4670 C80100EA 		b	.L944
 8140              	.LVL959:
 8141              	.L958:
 8142              	.LBE343:
 8143              	.LBE342:
 8144              	.LBE425:
 8145              	.LBE461:
 8146              	.LBB462:
 8147              	.LBB450:
3596:../uvc.c      ****     {
 8148              		.loc 1 3596 0
 8149 4674 010B53E3 		cmp	r3, #1024
 8150 4678 ED01000A 		beq	.L842
 8151 467c 9100009A 		bls	.L964
 8152 4680 060C53E3 		cmp	r3, #1536
 8153 4684 EE01000A 		beq	.L847
 8154 4688 9501009A 		bls	.L965
 8155 468c 070C53E3 		cmp	r3, #1792
 8156 4690 DB01000A 		beq	.L850
 8157 4694 020B53E3 		cmp	r3, #2048
 8158 4698 1CFFFF1A 		bne	.L620
 8159              	.LVL960:
3628:../uvc.c      ****     		break;
 8160              		.loc 1 3628 0
 8161 469c 1700A0E3 		mov	r0, #23
 8162 46a0 FEFFFFEB 		bl	ControlHandle
 8163              	.LVL961:
 8164 46a4 34309DE5 		ldr	r3, [sp, #52]
 8165 46a8 1DFFFFEA 		b	.L619
 8166              	.L952:
 8167              	.LBE450:
 8168              	.LBE462:
 8169              	.LBB463:
 8170              	.LBB320:
3371:../uvc.c      ****     {
 8171              		.loc 1 3371 0
 8172 46ac 030C52E3 		cmp	r2, #768
 8173 46b0 2001000A 		beq	.L718
 8174 46b4 6500008A 		bhi	.L719
 8175 46b8 010C52E3 		cmp	r2, #256
 8176 46bc 0301000A 		beq	.L720
 8177 46c0 020C52E3 		cmp	r2, #512
 8178 46c4 0CFFFF1A 		bne	.L715
 8179              	.LVL962:
 8180              	.LBB170:
 8181              	.LBB171:
1678:../uvc.c      **** 
 8182              		.loc 1 1678 0
 8183 46c8 E47A9FE5 		ldr	r7, .L981+16
1671:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8184              		.loc 1 1671 0
 8185 46cc A015DAE5 		ldrb	r1, [r10, #1440]	@ zero_extendqisi2
1678:../uvc.c      **** 
 8186              		.loc 1 1678 0
 8187 46d0 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
1670:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8188              		.loc 1 1670 0
 8189 46d4 AF35DAE5 		ldrb	r3, [r10, #1455]	@ zero_extendqisi2
 8190              	.LVL963:
1680:../uvc.c      **** 		 {
 8191              		.loc 1 1680 0
 8192 46d8 830056E3 		cmp	r6, #131
1671:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8193              		.loc 1 1671 0
 8194 46dc 24108DE5 		str	r1, [sp, #36]
 8195              	.LVL964:
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8196              		.loc 1 1673 0
 8197 46e0 A285DAE5 		ldrb	r8, [r10, #1442]	@ zero_extendqisi2
 8198              	.LVL965:
1680:../uvc.c      **** 		 {
 8199              		.loc 1 1680 0
 8200 46e4 2206000A 		beq	.L742
 8201 46e8 FC02009A 		bls	.L966
 8202 46ec 850056E3 		cmp	r6, #133
 8203 46f0 9505000A 		beq	.L747
 8204 46f4 9105003A 		bcc	.L748
 8205 46f8 860056E3 		cmp	r6, #134
 8206 46fc 7604000A 		beq	.L749
 8207 4700 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8208              		.loc 1 1742 0
 8209 4704 AB15DA05 		ldreqb	r1, [r10, #1451]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8210              		.loc 1 1743 0
 8211 4708 AC25DA05 		ldreqb	r2, [r10, #1452]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8212              		.loc 1 1680 0
 8213 470c 9A05001A 		bne	.L741
 8214              	.L932:
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8215              		.loc 1 1721 0
 8216 4710 0030A0E3 		mov	r3, #0
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8217              		.loc 1 1718 0
 8218 4714 2810CBE5 		strb	r1, [fp, #40]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8219              		.loc 1 1723 0
 8220 4718 0800A0E1 		mov	r0, r8
 8221 471c CC1A9FE5 		ldr	r1, .L981+76
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8222              		.loc 1 1719 0
 8223 4720 2920CBE5 		strb	r2, [fp, #41]
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8224              		.loc 1 1721 0
 8225 4724 2A30CBE5 		strb	r3, [fp, #42]
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8226              		.loc 1 1722 0
 8227 4728 2B30CBE5 		strb	r3, [fp, #43]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8228              		.loc 1 1723 0
 8229 472c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8230              	.LVL966:
1724:../uvc.c      **** 			  break;
 8231              		.loc 1 1724 0
 8232 4730 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 8233              	.LVL967:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8234              		.loc 1 1674 0
 8235 4734 FFC0A0E3 		mov	ip, #255
 8236              	.LVL968:
 8237              	.L751:
1893:../uvc.c      **** }
 8238              		.loc 1 1893 0
 8239 4738 2A00DBE5 		ldrb	r0, [fp, #42]	@ zero_extendqisi2
 8240 473c FF10A0E3 		mov	r1, #255
 8241 4740 0C30A0E1 		mov	r3, ip
 8242 4744 04008DE5 		str	r0, [sp, #4]
 8243 4748 10008DE5 		str	r0, [sp, #16]
 8244 474c 00108DE5 		str	r1, [sp]
 8245 4750 0C108DE5 		str	r1, [sp, #12]
 8246 4754 08708DE5 		str	r7, [sp, #8]
 8247 4758 14808DE5 		str	r8, [sp, #20]
 8248 475c 0620A0E1 		mov	r2, r6
 8249 4760 0400A0E3 		mov	r0, #4
 8250 4764 681A9FE5 		ldr	r1, .L981+48
 8251 4768 FEFFFFEB 		bl	CyU3PDebugPrint
 8252              	.LVL969:
 8253 476c 34309DE5 		ldr	r3, [sp, #52]
 8254 4770 EBFEFFEA 		b	.L619
 8255              	.LVL970:
 8256              	.L853:
 8257              	.LBE171:
 8258              	.LBE170:
 8259              	.LBE320:
 8260              	.LBE463:
 8261              	.LBB464:
 8262              	.LBB451:
3596:../uvc.c      ****     {
 8263              		.loc 1 3596 0
 8264 4774 110C53E3 		cmp	r3, #4352
 8265 4778 9501000A 		beq	.L859
 8266 477c 5E01009A 		bls	.L967
 8267 4780 120C53E3 		cmp	r3, #4608
 8268 4784 A201000A 		beq	.L862
 8269 4788 130C53E3 		cmp	r3, #4864
 8270 478c DFFEFF1A 		bne	.L620
 8271              	.LVL971:
3677:../uvc.c      ****     		break;
 8272              		.loc 1 3677 0
 8273 4790 2600A0E3 		mov	r0, #38
 8274 4794 FEFFFFEB 		bl	ControlHandle
 8275              	.LVL972:
 8276 4798 34309DE5 		ldr	r3, [sp, #52]
 8277 479c E0FEFFEA 		b	.L619
 8278              	.L630:
 8279              	.LBE451:
 8280              	.LBE464:
 8281              	.LBB465:
 8282              	.LBB426:
3296:../uvc.c      ****     {
 8283              		.loc 1 3296 0
 8284 47a0 010B52E3 		cmp	r2, #1024
 8285 47a4 DEFEFF0A 		beq	.L619
 8286 47a8 050C52E3 		cmp	r2, #1280
 8287 47ac D2FEFF1A 		bne	.L715
 8288              	.LVL973:
3315:../uvc.c      ****       		break;
 8289              		.loc 1 3315 0
 8290 47b0 0400A0E3 		mov	r0, #4
 8291 47b4 FEFFFFEB 		bl	ControlHandle
 8292              	.LVL974:
 8293 47b8 34309DE5 		ldr	r3, [sp, #52]
 8294 47bc D8FEFFEA 		b	.L619
 8295              	.L962:
3296:../uvc.c      ****     {
 8296              		.loc 1 3296 0
 8297 47c0 070C52E3 		cmp	r2, #1792
 8298 47c4 4D00000A 		beq	.L636
 8299 47c8 020B52E3 		cmp	r2, #2048
 8300 47cc CAFEFF1A 		bne	.L715
 8301              	.LVL975:
 8302              	.LBB351:
 8303              	.LBB352:
 757:../uvc.c      ****     /*
 8304              		.loc 1 757 0
 8305 47d0 DC399FE5 		ldr	r3, .L981+16
 749:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 8306              		.loc 1 749 0
 8307 47d4 9502DAE5 		ldrb	r0, [r10, #661]	@ zero_extendqisi2
 8308              	.LVL976:
 757:../uvc.c      ****     /*
 8309              		.loc 1 757 0
 8310 47d8 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8311              		.loc 1 750 0
 8312 47dc A312DAE5 		ldrb	r1, [r10, #675]	@ zero_extendqisi2
 8313              	.LVL977:
 765:../uvc.c      **** 		 {
 8314              		.loc 1 765 0
 8315 47e0 830056E3 		cmp	r6, #131
 751:../uvc.c      ****     }
 8316              		.loc 1 751 0
 8317 47e4 9672DAE5 		ldrb	r7, [r10, #662]	@ zero_extendqisi2
 8318              	.LVL978:
 765:../uvc.c      **** 		 {
 8319              		.loc 1 765 0
 8320 47e8 0D05000A 		beq	.L659
 8321 47ec C701009A 		bls	.L968
 8322 47f0 850056E3 		cmp	r6, #133
 8323 47f4 F104000A 		beq	.L664
 8324 47f8 E104003A 		bcc	.L665
 8325 47fc 860056E3 		cmp	r6, #134
 8326 4800 D603000A 		beq	.L666
 8327 4804 870056E3 		cmp	r6, #135
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8328              		.loc 1 1190 0
 8329 4808 9F22DA05 		ldreqb	r2, [r10, #671]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 8330              		.loc 1 1191 0
 8331 480c A032DA05 		ldreqb	r3, [r10, #672]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 8332              		.loc 1 765 0
 8333 4810 1E05001A 		bne	.L658
 8334              	.L922:
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8335              		.loc 1 1193 0
 8336 4814 D4199FE5 		ldr	r1, .L981+76
 8337 4818 0700A0E1 		mov	r0, r7
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8338              		.loc 1 753 0
 8339 481c FF80A0E3 		mov	r8, #255
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8340              		.loc 1 1190 0
 8341 4820 2820CBE5 		strb	r2, [fp, #40]
 8342              	.L921:
1191:../uvc.c      **** 			 }
 8343              		.loc 1 1191 0
 8344 4824 2930CBE5 		strb	r3, [fp, #41]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8345              		.loc 1 753 0
 8346 4828 0870A0E1 		mov	r7, r8
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8347              		.loc 1 1193 0
 8348 482c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8349              	.LVL979:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8350              		.loc 1 753 0
 8351 4830 08C0A0E1 		mov	ip, r8
1194:../uvc.c      **** 			  break;
 8352              		.loc 1 1194 0
 8353 4834 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 8354              	.LVL980:
 8355 4838 E90100EA 		b	.L668
 8356              	.LVL981:
 8357              	.L953:
 8358              	.LBE352:
 8359              	.LBE351:
 8360              	.LBE426:
 8361              	.LBE465:
 8362              	.LBB466:
 8363              	.LBB321:
3371:../uvc.c      ****     {
 8364              		.loc 1 3371 0
 8365 483c 070C52E3 		cmp	r2, #1792
 8366 4840 CD00000A 		beq	.L726
 8367 4844 020B52E3 		cmp	r2, #2048
 8368 4848 B5FEFF0A 		beq	.L619
 8369 484c AAFEFFEA 		b	.L715
 8370              	.L719:
 8371 4850 010B52E3 		cmp	r2, #1024
 8372 4854 1E01000A 		beq	.L722
 8373 4858 050C52E3 		cmp	r2, #1280
 8374 485c A6FEFF1A 		bne	.L715
 8375              	.LVL982:
 8376              	.LBB188:
 8377              	.LBB189:
1678:../uvc.c      **** 
 8378              		.loc 1 1678 0
 8379 4860 4C799FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8380              		.loc 1 1673 0
 8381 4864 EA85DAE5 		ldrb	r8, [r10, #1514]	@ zero_extendqisi2
 8382              	.LVL983:
1678:../uvc.c      **** 
 8383              		.loc 1 1678 0
 8384 4868 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8385              	.LVL984:
1680:../uvc.c      **** 		 {
 8386              		.loc 1 1680 0
 8387 486c 830056E3 		cmp	r6, #131
 8388 4870 E205000A 		beq	.L769
 8389 4874 8702009A 		bls	.L969
 8390 4878 850056E3 		cmp	r6, #133
 8391 487c 8703000A 		beq	.L831
 8392 4880 3A05003A 		bcc	.L775
 8393 4884 860056E3 		cmp	r6, #134
 8394 4888 0004000A 		beq	.L776
 8395 488c 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8396              		.loc 1 1742 0
 8397 4890 F315DA05 		ldreqb	r1, [r10, #1523]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8398              		.loc 1 1743 0
 8399 4894 F425DA05 		ldreqb	r2, [r10, #1524]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8400              		.loc 1 1680 0
 8401 4898 6400000A 		beq	.L941
 8402              	.L768:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8403              		.loc 1 1887 0
 8404 489c 0000A0E3 		mov	r0, #0
 8405 48a0 0020A0E1 		mov	r2, r0
 8406 48a4 0110A0E3 		mov	r1, #1
 8407 48a8 FEFFFFEB 		bl	CyU3PUsbStall
 8408              	.LVL985:
1888:../uvc.c      **** 			  break;
 8409              		.loc 1 1888 0
 8410 48ac 0400A0E3 		mov	r0, #4
 8411 48b0 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 8412 48b4 0020A0E1 		mov	r2, r0
 8413 48b8 28199FE5 		ldr	r1, .L981+68
 8414 48bc FEFFFFEB 		bl	CyU3PDebugPrint
 8415              	.LVL986:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8416              		.loc 1 1674 0
 8417 48c0 FF70A0E3 		mov	r7, #255
 8418              	.LVL987:
 8419 48c4 7C0300EA 		b	.L835
 8420              	.LVL988:
 8421              	.L964:
 8422              	.LBE189:
 8423              	.LBE188:
 8424              	.LBE321:
 8425              	.LBE466:
 8426              	.LBB467:
 8427              	.LBB452:
3596:../uvc.c      ****     {
 8428              		.loc 1 3596 0
 8429 48c8 020C53E3 		cmp	r3, #512
 8430 48cc 6401000A 		beq	.L844
 8431 48d0 030C53E3 		cmp	r3, #768
 8432 48d4 5E01000A 		beq	.L845
 8433 48d8 010C53E3 		cmp	r3, #256
 8434 48dc 8BFEFF1A 		bne	.L620
 8435              	.LVL989:
3600:../uvc.c      ****     		break;
 8436              		.loc 1 3600 0
 8437 48e0 1000A0E3 		mov	r0, #16
 8438 48e4 FEFFFFEB 		bl	ControlHandle
 8439              	.LVL990:
 8440 48e8 34309DE5 		ldr	r3, [sp, #52]
 8441 48ec 8CFEFFEA 		b	.L619
 8442              	.L629:
 8443              	.LVL991:
 8444              	.LBE452:
 8445              	.LBE467:
 8446              	.LBB468:
 8447              	.LBB427:
3308:../uvc.c      **** 			break;
 8448              		.loc 1 3308 0
 8449 48f0 0200A0E3 		mov	r0, #2
 8450 48f4 FEFFFFEB 		bl	ControlHandle
 8451              	.LVL992:
 8452 48f8 34309DE5 		ldr	r3, [sp, #52]
 8453 48fc 88FEFFEA 		b	.L619
 8454              	.L636:
 8455              	.LVL993:
3323:../uvc.c      ****           		break;
 8456              		.loc 1 3323 0
 8457 4900 0600A0E3 		mov	r0, #6
 8458 4904 FEFFFFEB 		bl	ControlHandle
 8459              	.LVL994:
 8460 4908 34309DE5 		ldr	r3, [sp, #52]
 8461 490c 84FEFFEA 		b	.L619
 8462              	.L627:
 8463              	.LVL995:
3319:../uvc.c      ****      		break;
 8464              		.loc 1 3319 0
 8465 4910 0500A0E3 		mov	r0, #5
 8466 4914 FEFFFFEB 		bl	ControlHandle
 8467              	.LVL996:
 8468 4918 34309DE5 		ldr	r3, [sp, #52]
 8469 491c 80FEFFEA 		b	.L619
 8470              	.L634:
 8471              	.LVL997:
 8472              	.LBB363:
 8473              	.LBB364:
 757:../uvc.c      ****     /*
 8474              		.loc 1 757 0
 8475 4920 8C389FE5 		ldr	r3, .L981+16
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8476              		.loc 1 748 0
 8477 4924 C4C2DAE5 		ldrb	ip, [r10, #708]	@ zero_extendqisi2
 8478              	.LVL998:
 757:../uvc.c      ****     /*
 8479              		.loc 1 757 0
 8480 4928 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
 751:../uvc.c      ****     }
 8481              		.loc 1 751 0
 8482 492c C672DAE5 		ldrb	r7, [r10, #710]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 8483              		.loc 1 765 0
 8484 4930 830056E3 		cmp	r6, #131
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8485              		.loc 1 750 0
 8486 4934 D332DAE5 		ldrb	r3, [r10, #723]	@ zero_extendqisi2
 8487              	.LVL999:
 765:../uvc.c      **** 		 {
 8488              		.loc 1 765 0
 8489 4938 B504000A 		beq	.L674
 8490 493c 2D02009A 		bls	.L970
 8491 4940 850056E3 		cmp	r6, #133
 8492 4944 7003000A 		beq	.L707
 8493 4948 CC04003A 		bcc	.L680
 8494 494c 860056E3 		cmp	r6, #134
 8495 4950 9803000A 		beq	.L681
 8496 4954 870056E3 		cmp	r6, #135
 8497 4958 1800001A 		bne	.L701
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8498              		.loc 1 1190 0
 8499 495c 88E89FE5 		ldr	lr, .L981+72
 8500 4960 CFC2DEE5 		ldrb	ip, [lr, #719]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 8501              		.loc 1 1191 0
 8502 4964 D022DEE5 		ldrb	r2, [lr, #720]	@ zero_extendqisi2
 8503              	.LVL1000:
 8504              	.L929:
 8505              	.LBE364:
 8506              	.LBE363:
 8507              	.LBB372:
 8508              	.LBB373:
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8509              		.loc 1 1131 0
 8510 4968 0700A0E1 		mov	r0, r7
 8511 496c 7C189FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8512              		.loc 1 753 0
 8513 4970 FF30A0E3 		mov	r3, #255
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 8514              		.loc 1 1128 0
 8515 4974 28C0CBE5 		strb	ip, [fp, #40]
 8516 4978 680300EA 		b	.L928
 8517              	.L697:
 8518              	.L638:
 8519              	.LVL1001:
 757:../uvc.c      ****     /*
 8520              		.loc 1 757 0
 8521 497c 30389FE5 		ldr	r3, .L981+16
 748:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 8522              		.loc 1 748 0
 8523 4980 3CC3DAE5 		ldrb	ip, [r10, #828]	@ zero_extendqisi2
 8524              	.LVL1002:
 757:../uvc.c      ****     /*
 8525              		.loc 1 757 0
 8526 4984 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
 751:../uvc.c      ****     }
 8527              		.loc 1 751 0
 8528 4988 3E73DAE5 		ldrb	r7, [r10, #830]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 8529              		.loc 1 765 0
 8530 498c 830056E3 		cmp	r6, #131
 750:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 8531              		.loc 1 750 0
 8532 4990 4B33DAE5 		ldrb	r3, [r10, #843]	@ zero_extendqisi2
 8533              	.LVL1003:
 765:../uvc.c      **** 		 {
 8534              		.loc 1 765 0
 8535 4994 A604000A 		beq	.L702
 8536 4998 3501009A 		bls	.L971
 8537 499c 850056E3 		cmp	r6, #133
 8538 49a0 5903000A 		beq	.L707
 8539 49a4 8B04003A 		bcc	.L708
 8540 49a8 860056E3 		cmp	r6, #134
 8541 49ac 7503000A 		beq	.L709
 8542 49b0 870056E3 		cmp	r6, #135
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 8543              		.loc 1 1190 0
 8544 49b4 47C3DA05 		ldreqb	ip, [r10, #839]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 8545              		.loc 1 1191 0
 8546 49b8 4823DA05 		ldreqb	r2, [r10, #840]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 8547              		.loc 1 765 0
 8548 49bc E9FFFF0A 		beq	.L929
 8549              	.LVL1004:
 8550              	.L701:
1651:../uvc.c      **** 			  break;
 8551              		.loc 1 1651 0
 8552 49c0 0000A0E3 		mov	r0, #0
 8553 49c4 0020A0E1 		mov	r2, r0
 8554 49c8 0110A0E3 		mov	r1, #1
 8555 49cc FEFFFFEB 		bl	CyU3PUsbStall
 8556              	.LVL1005:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8557              		.loc 1 753 0
 8558 49d0 FF30A0E3 		mov	r3, #255
 8559 49d4 0320A0E1 		mov	r2, r3
 8560 49d8 0380A0E1 		mov	r8, r3
 8561 49dc 0370A0E1 		mov	r7, r3
 8562 49e0 550300EA 		b	.L711
 8563              	.L631:
 8564              	.LVL1006:
 8565              	.LBE373:
 8566              	.LBE372:
3300:../uvc.c      ****     		break;
 8567              		.loc 1 3300 0
 8568 49e4 0000A0E3 		mov	r0, #0
 8569 49e8 FEFFFFEB 		bl	ControlHandle
 8570              	.LVL1007:
 8571 49ec 34309DE5 		ldr	r3, [sp, #52]
 8572 49f0 4BFEFFEA 		b	.L619
 8573              	.L727:
 8574              	.LVL1008:
 8575              	.LBE427:
 8576              	.LBE468:
 8577              	.LBB469:
 8578              	.LBB322:
 8579              	.LBB196:
 8580              	.LBB197:
1678:../uvc.c      **** 
 8581              		.loc 1 1678 0
 8582 49f4 B8779FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8583              		.loc 1 1673 0
 8584 49f8 6286DAE5 		ldrb	r8, [r10, #1634]	@ zero_extendqisi2
 8585              	.LVL1009:
1678:../uvc.c      **** 
 8586              		.loc 1 1678 0
 8587 49fc 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8588              	.LVL1010:
1680:../uvc.c      **** 		 {
 8589              		.loc 1 1680 0
 8590 4a00 830056E3 		cmp	r6, #131
 8591 4a04 8905000A 		beq	.L826
 8592 4a08 6002009A 		bls	.L972
 8593 4a0c 850056E3 		cmp	r6, #133
 8594 4a10 2203000A 		beq	.L831
 8595 4a14 E704003A 		bcc	.L832
 8596 4a18 860056E3 		cmp	r6, #134
 8597 4a1c C003000A 		beq	.L833
 8598 4a20 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8599              		.loc 1 1742 0
 8600 4a24 6B16DA05 		ldreqb	r1, [r10, #1643]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8601              		.loc 1 1743 0
 8602 4a28 6C26DA05 		ldreqb	r2, [r10, #1644]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8603              		.loc 1 1680 0
 8604 4a2c E504001A 		bne	.L825
 8605              	.LVL1011:
 8606              	.L941:
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8607              		.loc 1 1721 0
 8608 4a30 0030A0E3 		mov	r3, #0
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8609              		.loc 1 1718 0
 8610 4a34 2810CBE5 		strb	r1, [fp, #40]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8611              		.loc 1 1723 0
 8612 4a38 0800A0E1 		mov	r0, r8
 8613 4a3c AC179FE5 		ldr	r1, .L981+76
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8614              		.loc 1 1719 0
 8615 4a40 2920CBE5 		strb	r2, [fp, #41]
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8616              		.loc 1 1721 0
 8617 4a44 2A30CBE5 		strb	r3, [fp, #42]
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8618              		.loc 1 1722 0
 8619 4a48 2B30CBE5 		strb	r3, [fp, #43]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8620              		.loc 1 1723 0
 8621 4a4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8622              	.LVL1012:
1724:../uvc.c      **** 			  break;
 8623              		.loc 1 1724 0
 8624 4a50 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 8625              	.LVL1013:
 8626 4a54 180300EA 		b	.L835
 8627              	.LVL1014:
 8628              	.L954:
 8629              	.LBE197:
 8630              	.LBE196:
 8631              	.LBB207:
 8632              	.LBB208:
1678:../uvc.c      **** 
 8633              		.loc 1 1678 0
 8634 4a58 54779FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8635              		.loc 1 1673 0
 8636 4a5c 4A86DAE5 		ldrb	r8, [r10, #1610]	@ zero_extendqisi2
 8637              	.LVL1015:
1678:../uvc.c      **** 
 8638              		.loc 1 1678 0
 8639 4a60 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8640              	.LVL1016:
1680:../uvc.c      **** 		 {
 8641              		.loc 1 1680 0
 8642 4a64 830056E3 		cmp	r6, #131
 8643 4a68 6805000A 		beq	.L815
 8644 4a6c 3502009A 		bls	.L973
 8645 4a70 850056E3 		cmp	r6, #133
 8646 4a74 0903000A 		beq	.L831
 8647 4a78 0305003A 		bcc	.L821
 8648 4a7c 860056E3 		cmp	r6, #134
 8649 4a80 A503000A 		beq	.L822
 8650 4a84 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8651              		.loc 1 1742 0
 8652 4a88 5316DA05 		ldreqb	r1, [r10, #1619]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8653              		.loc 1 1743 0
 8654 4a8c 5426DA05 		ldreqb	r2, [r10, #1620]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8655              		.loc 1 1680 0
 8656 4a90 E6FFFF0A 		beq	.L941
 8657              	.L814:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8658              		.loc 1 1887 0
 8659 4a94 0000A0E3 		mov	r0, #0
 8660 4a98 0020A0E1 		mov	r2, r0
 8661 4a9c 0110A0E3 		mov	r1, #1
 8662 4aa0 FEFFFFEB 		bl	CyU3PUsbStall
 8663              	.LVL1017:
1888:../uvc.c      **** 			  break;
 8664              		.loc 1 1888 0
 8665 4aa4 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 8666 4aa8 0400A0E3 		mov	r0, #4
 8667 4aac 34179FE5 		ldr	r1, .L981+68
 8668 4ab0 0820A0E3 		mov	r2, #8
 8669 4ab4 FEFFFFEB 		bl	CyU3PDebugPrint
 8670              	.LVL1018:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8671              		.loc 1 1674 0
 8672 4ab8 FF70A0E3 		mov	r7, #255
 8673              	.LVL1019:
 8674 4abc FE0200EA 		b	.L835
 8675              	.LVL1020:
 8676              	.L728:
 8677              	.LBE208:
 8678              	.LBE207:
3420:../uvc.c      ****     		break;
 8679              		.loc 1 3420 0
 8680 4ac0 0A00A0E3 		mov	r0, #10
 8681 4ac4 FEFFFFEB 		bl	CTControlHandle
 8682              	.LVL1021:
 8683 4ac8 34309DE5 		ldr	r3, [sp, #52]
 8684 4acc 14FEFFEA 		b	.L619
 8685              	.L720:
 8686              	.LVL1022:
 8687              	.LBB215:
 8688              	.LBB216:
1678:../uvc.c      **** 
 8689              		.loc 1 1678 0
 8690 4ad0 DC769FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8691              		.loc 1 1673 0
 8692 4ad4 8A85DAE5 		ldrb	r8, [r10, #1418]	@ zero_extendqisi2
 8693              	.LVL1023:
1678:../uvc.c      **** 
 8694              		.loc 1 1678 0
 8695 4ad8 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8696              	.LVL1024:
1680:../uvc.c      **** 		 {
 8697              		.loc 1 1680 0
 8698 4adc 830056E3 		cmp	r6, #131
 8699 4ae0 4E05000A 		beq	.L731
 8700 4ae4 6C02009A 		bls	.L974
 8701 4ae8 850056E3 		cmp	r6, #133
 8702 4aec EB02000A 		beq	.L831
 8703 4af0 D004003A 		bcc	.L737
 8704 4af4 860056E3 		cmp	r6, #134
 8705 4af8 8503000A 		beq	.L738
 8706 4afc 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8707              		.loc 1 1742 0
 8708 4b00 9315DA05 		ldreqb	r1, [r10, #1427]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8709              		.loc 1 1743 0
 8710 4b04 9425DA05 		ldreqb	r2, [r10, #1428]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8711              		.loc 1 1680 0
 8712 4b08 C8FFFF0A 		beq	.L941
 8713              	.L730:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8714              		.loc 1 1887 0
 8715 4b0c 0000A0E3 		mov	r0, #0
 8716 4b10 0020A0E1 		mov	r2, r0
 8717 4b14 0110A0E3 		mov	r1, #1
 8718 4b18 FEFFFFEB 		bl	CyU3PUsbStall
 8719              	.LVL1025:
1888:../uvc.c      **** 			  break;
 8720              		.loc 1 1888 0
 8721 4b1c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 8722 4b20 0400A0E3 		mov	r0, #4
 8723 4b24 BC169FE5 		ldr	r1, .L981+68
 8724 4b28 0020A0E3 		mov	r2, #0
 8725 4b2c FEFFFFEB 		bl	CyU3PDebugPrint
 8726              	.LVL1026:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8727              		.loc 1 1674 0
 8728 4b30 FF70A0E3 		mov	r7, #255
 8729              	.LVL1027:
 8730 4b34 E00200EA 		b	.L835
 8731              	.LVL1028:
 8732              	.L718:
 8733              	.LBE216:
 8734              	.LBE215:
 8735              	.LBB223:
 8736              	.LBB224:
1678:../uvc.c      **** 
 8737              		.loc 1 1678 0
 8738 4b38 74769FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8739              		.loc 1 1673 0
 8740 4b3c BA85DAE5 		ldrb	r8, [r10, #1466]	@ zero_extendqisi2
 8741              	.LVL1029:
1678:../uvc.c      **** 
 8742              		.loc 1 1678 0
 8743 4b40 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8744              	.LVL1030:
1680:../uvc.c      **** 		 {
 8745              		.loc 1 1680 0
 8746 4b44 830056E3 		cmp	r6, #131
 8747 4b48 2005000A 		beq	.L758
 8748 4b4c 8902009A 		bls	.L975
 8749 4b50 850056E3 		cmp	r6, #133
 8750 4b54 D102000A 		beq	.L831
 8751 4b58 B204003A 		bcc	.L764
 8752 4b5c 860056E3 		cmp	r6, #134
 8753 4b60 7703000A 		beq	.L765
 8754 4b64 870056E3 		cmp	r6, #135
 8755 4b68 0905001A 		bne	.L757
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8756              		.loc 1 1742 0
 8757 4b6c 78269FE5 		ldr	r2, .L981+72
 8758 4b70 C315D2E5 		ldrb	r1, [r2, #1475]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8759              		.loc 1 1743 0
 8760 4b74 C425D2E5 		ldrb	r2, [r2, #1476]	@ zero_extendqisi2
 8761 4b78 ACFFFFEA 		b	.L941
 8762              	.LVL1031:
 8763              	.L726:
 8764              	.LBE224:
 8765              	.LBE223:
 8766              	.LBB232:
 8767              	.LBB233:
1678:../uvc.c      **** 
 8768              		.loc 1 1678 0
 8769 4b7c 30769FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8770              		.loc 1 1673 0
 8771 4b80 1A86DAE5 		ldrb	r8, [r10, #1562]	@ zero_extendqisi2
 8772              	.LVL1032:
1678:../uvc.c      **** 
 8773              		.loc 1 1678 0
 8774 4b84 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8775              	.LVL1033:
1680:../uvc.c      **** 		 {
 8776              		.loc 1 1680 0
 8777 4b88 830056E3 		cmp	r6, #131
 8778 4b8c 1305000A 		beq	.L791
 8779 4b90 6602009A 		bls	.L976
 8780 4b94 850056E3 		cmp	r6, #133
 8781 4b98 C002000A 		beq	.L831
 8782 4b9c CB04003A 		bcc	.L797
 8783 4ba0 860056E3 		cmp	r6, #134
 8784 4ba4 6903000A 		beq	.L798
 8785 4ba8 870056E3 		cmp	r6, #135
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8786              		.loc 1 1742 0
 8787 4bac 2316DA05 		ldreqb	r1, [r10, #1571]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8788              		.loc 1 1743 0
 8789 4bb0 2426DA05 		ldreqb	r2, [r10, #1572]	@ zero_extendqisi2
1680:../uvc.c      **** 		 {
 8790              		.loc 1 1680 0
 8791 4bb4 9DFFFF0A 		beq	.L941
 8792              	.L790:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 8793              		.loc 1 1887 0
 8794 4bb8 0000A0E3 		mov	r0, #0
 8795 4bbc 0020A0E1 		mov	r2, r0
 8796 4bc0 0110A0E3 		mov	r1, #1
 8797 4bc4 FEFFFFEB 		bl	CyU3PUsbStall
 8798              	.LVL1034:
1888:../uvc.c      **** 			  break;
 8799              		.loc 1 1888 0
 8800 4bc8 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 8801 4bcc 0400A0E3 		mov	r0, #4
 8802 4bd0 10169FE5 		ldr	r1, .L981+68
 8803 4bd4 0620A0E3 		mov	r2, #6
 8804 4bd8 FEFFFFEB 		bl	CyU3PDebugPrint
 8805              	.LVL1035:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8806              		.loc 1 1674 0
 8807 4bdc FF70A0E3 		mov	r7, #255
 8808              	.LVL1036:
 8809 4be0 B50200EA 		b	.L835
 8810              	.LVL1037:
 8811              	.L716:
 8812              	.LBE233:
 8813              	.LBE232:
 8814              	.LBB240:
 8815              	.LBB241:
1678:../uvc.c      **** 
 8816              		.loc 1 1678 0
 8817 4be4 C8759FE5 		ldr	r7, .L981+16
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8818              		.loc 1 1673 0
 8819 4be8 0286DAE5 		ldrb	r8, [r10, #1538]	@ zero_extendqisi2
 8820              	.LVL1038:
1678:../uvc.c      **** 
 8821              		.loc 1 1678 0
 8822 4bec 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
 8823              	.LVL1039:
1680:../uvc.c      **** 		 {
 8824              		.loc 1 1680 0
 8825 4bf0 830056E3 		cmp	r6, #131
 8826 4bf4 FD04000A 		beq	.L780
 8827 4bf8 3902009A 		bls	.L977
 8828 4bfc 850056E3 		cmp	r6, #133
 8829 4c00 A602000A 		beq	.L831
 8830 4c04 D604003A 		bcc	.L786
 8831 4c08 860056E3 		cmp	r6, #134
 8832 4c0c 3D03000A 		beq	.L787
 8833 4c10 870056E3 		cmp	r6, #135
 8834 4c14 C704001A 		bne	.L779
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8835              		.loc 1 1742 0
 8836 4c18 CC259FE5 		ldr	r2, .L981+72
 8837 4c1c 0B16D2E5 		ldrb	r1, [r2, #1547]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8838              		.loc 1 1743 0
 8839 4c20 0C26D2E5 		ldrb	r2, [r2, #1548]	@ zero_extendqisi2
 8840 4c24 81FFFFEA 		b	.L941
 8841              	.LVL1040:
 8842              	.L724:
 8843              	.LBE241:
 8844              	.LBE240:
 8845              	.LBB248:
 8846              	.LBB249:
1678:../uvc.c      **** 
 8847              		.loc 1 1678 0
 8848 4c28 84759FE5 		ldr	r7, .L981+16
1670:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 8849              		.loc 1 1670 0
 8850 4c2c 3FC6DAE5 		ldrb	ip, [r10, #1599]	@ zero_extendqisi2
 8851              	.LVL1041:
1678:../uvc.c      **** 
 8852              		.loc 1 1678 0
 8853 4c30 0060D7E5 		ldrb	r6, [r7]	@ zero_extendqisi2
1671:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 8854              		.loc 1 1671 0
 8855 4c34 3036DAE5 		ldrb	r3, [r10, #1584]	@ zero_extendqisi2
 8856              	.LVL1042:
1680:../uvc.c      **** 		 {
 8857              		.loc 1 1680 0
 8858 4c38 830056E3 		cmp	r6, #131
1673:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 8859              		.loc 1 1673 0
 8860 4c3c 3286DAE5 		ldrb	r8, [r10, #1586]	@ zero_extendqisi2
 8861              	.LVL1043:
1680:../uvc.c      **** 		 {
 8862              		.loc 1 1680 0
 8863 4c40 DE04000A 		beq	.L802
 8864 4c44 E301009A 		bls	.L978
 8865 4c48 850056E3 		cmp	r6, #133
 8866 4c4c 9504000A 		beq	.L807
 8867 4c50 9004003A 		bcc	.L808
 8868 4c54 860056E3 		cmp	r6, #134
 8869 4c58 1403000A 		beq	.L809
 8870 4c5c 870056E3 		cmp	r6, #135
 8871 4c60 7804001A 		bne	.L801
1742:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 8872              		.loc 1 1742 0
 8873 4c64 80259FE5 		ldr	r2, .L981+72
 8874 4c68 3B16D2E5 		ldrb	r1, [r2, #1595]	@ zero_extendqisi2
1743:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8875              		.loc 1 1743 0
 8876 4c6c 3C26D2E5 		ldrb	r2, [r2, #1596]	@ zero_extendqisi2
 8877              	.L939:
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8878              		.loc 1 1721 0
 8879 4c70 0030A0E3 		mov	r3, #0
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 8880              		.loc 1 1718 0
 8881 4c74 2810CBE5 		strb	r1, [fp, #40]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8882              		.loc 1 1723 0
 8883 4c78 0800A0E1 		mov	r0, r8
 8884 4c7c 6C159FE5 		ldr	r1, .L981+76
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 8885              		.loc 1 1719 0
 8886 4c80 2920CBE5 		strb	r2, [fp, #41]
1721:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 8887              		.loc 1 1721 0
 8888 4c84 2A30CBE5 		strb	r3, [fp, #42]
1722:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 8889              		.loc 1 1722 0
 8890 4c88 2B30CBE5 		strb	r3, [fp, #43]
1723:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 8891              		.loc 1 1723 0
 8892 4c8c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 8893              	.LVL1044:
1724:../uvc.c      **** 			  break;
 8894              		.loc 1 1724 0
 8895 4c90 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 8896              	.LVL1045:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 8897              		.loc 1 1674 0
 8898 4c94 FF20A0E3 		mov	r2, #255
 8899 4c98 0230A0E1 		mov	r3, r2
 8900              	.LVL1046:
 8901              	.L811:
1893:../uvc.c      **** }
 8902              		.loc 1 1893 0
 8903 4c9c 2A10DBE5 		ldrb	r1, [fp, #42]	@ zero_extendqisi2
 8904 4ca0 FF00A0E3 		mov	r0, #255
 8905 4ca4 00208DE5 		str	r2, [sp]
 8906 4ca8 04108DE5 		str	r1, [sp, #4]
 8907 4cac 10108DE5 		str	r1, [sp, #16]
 8908 4cb0 0C008DE5 		str	r0, [sp, #12]
 8909 4cb4 08708DE5 		str	r7, [sp, #8]
 8910 4cb8 14808DE5 		str	r8, [sp, #20]
 8911 4cbc 0620A0E1 		mov	r2, r6
 8912              	.LVL1047:
 8913 4cc0 0400A0E3 		mov	r0, #4
 8914 4cc4 08159FE5 		ldr	r1, .L981+48
 8915 4cc8 FEFFFFEB 		bl	CyU3PDebugPrint
 8916              	.LVL1048:
 8917 4ccc 34309DE5 		ldr	r3, [sp, #52]
 8918 4cd0 93FDFFEA 		b	.L619
 8919              	.LVL1049:
 8920              	.L722:
 8921              	.LBE249:
 8922              	.LBE248:
3388:../uvc.c      **** 			break;
 8923              		.loc 1 3388 0
 8924 4cd4 0300A0E3 		mov	r0, #3
 8925 4cd8 FEFFFFEB 		bl	CTControlHandle
 8926              	.LVL1050:
 8927 4cdc 34309DE5 		ldr	r3, [sp, #52]
 8928 4ce0 8FFDFFEA 		b	.L619
 8929              	.L965:
 8930              	.LBE322:
 8931              	.LBE469:
 8932              	.LBB470:
 8933              	.LBB453:
3596:../uvc.c      ****     {
 8934              		.loc 1 3596 0
 8935 4ce4 050C53E3 		cmp	r3, #1280
 8936 4ce8 88FDFF1A 		bne	.L620
 8937              	.LVL1051:
3616:../uvc.c      ****     		break;
 8938              		.loc 1 3616 0
 8939 4cec 1400A0E3 		mov	r0, #20
 8940 4cf0 FEFFFFEB 		bl	ControlHandle
 8941              	.LVL1052:
 8942 4cf4 34309DE5 		ldr	r3, [sp, #52]
 8943 4cf8 89FDFFEA 		b	.L619
 8944              	.L967:
3596:../uvc.c      ****     {
 8945              		.loc 1 3596 0
 8946 4cfc 010A53E3 		cmp	r3, #4096
 8947 4d00 82FDFF1A 		bne	.L620
 8948              	.LVL1053:
3665:../uvc.c      ****     		break;
 8949              		.loc 1 3665 0
 8950 4d04 1F00A0E3 		mov	r0, #31
 8951 4d08 FEFFFFEB 		bl	ControlHandle
 8952              	.LVL1054:
 8953 4d0c 34309DE5 		ldr	r3, [sp, #52]
 8954 4d10 83FDFFEA 		b	.L619
 8955              	.L959:
3596:../uvc.c      ****     {
 8956              		.loc 1 3596 0
 8957 4d14 0A0C53E3 		cmp	r3, #2560
 8958 4d18 7CFDFF1A 		bne	.L620
 8959              	.LVL1055:
3637:../uvc.c      ****     		}else/* no support for 1080p camera */
 8960              		.loc 1 3637 0
 8961 4d1c 1900A0E3 		mov	r0, #25
 8962 4d20 FEFFFFEB 		bl	ControlHandle
 8963              	.LVL1056:
 8964 4d24 34309DE5 		ldr	r3, [sp, #52]
 8965 4d28 7DFDFFEA 		b	.L619
 8966              	.LVL1057:
 8967              	.L960:
 8968 4d2c 0080A0E1 		mov	r8, r0
 8969              	.LBE453:
 8970              	.LBE470:
4243:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 8971              		.loc 1 4243 0
 8972 4d30 A0149FE5 		ldr	r1, .L981+52
 8973 4d34 0700A0E1 		mov	r0, r7
 8974              	.LVL1058:
 8975 4d38 0820A0E1 		mov	r2, r8
 8976 4d3c FEFFFFEB 		bl	CyU3PDebugPrint
 8977              	.LVL1059:
4244:../uvc.c      **** 					}
 8978              		.loc 1 4244 0
 8979 4d40 0800A0E1 		mov	r0, r8
 8980 4d44 FEFFFFEB 		bl	CyFxAppErrorHandler
 8981              	.LVL1060:
 8982              	.L857:
 8983              	.LBB471:
 8984              	.LBB454:
 8985              	.LBB436:
 8986              	.LBB437:
 757:../uvc.c      ****     /*
 8987              		.loc 1 757 0
 8988 4d48 64349FE5 		ldr	r3, .L981+16
 751:../uvc.c      ****     }
 8989              		.loc 1 751 0
 8990 4d4c 7674DAE5 		ldrb	r7, [r10, #1142]	@ zero_extendqisi2
 8991              	.LVL1061:
 757:../uvc.c      ****     /*
 8992              		.loc 1 757 0
 8993 4d50 0060D3E5 		ldrb	r6, [r3]	@ zero_extendqisi2
 8994              	.LVL1062:
 765:../uvc.c      **** 		 {
 8995              		.loc 1 765 0
 8996 4d54 830056E3 		cmp	r6, #131
 8997 4d58 B804000A 		beq	.L865
 8998 4d5c 1802009A 		bls	.L979
 8999 4d60 850056E3 		cmp	r6, #133
 9000 4d64 BF04000A 		beq	.L870
 9001 4d68 1B03003A 		bcc	.L871
 9002 4d6c 860056E3 		cmp	r6, #134
 9003 4d70 B604000A 		beq	.L872
 9004 4d74 870056E3 		cmp	r6, #135
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9005              		.loc 1 1190 0
 9006 4d78 7FC4DA05 		ldreqb	ip, [r10, #1151]	@ zero_extendqisi2
1191:../uvc.c      **** 			 }
 9007              		.loc 1 1191 0
 9008 4d7c 8024DA05 		ldreqb	r2, [r10, #1152]	@ zero_extendqisi2
 765:../uvc.c      **** 		 {
 9009              		.loc 1 765 0
 9010 4d80 2003001A 		bne	.L864
 9011              	.L943:
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9012              		.loc 1 1193 0
 9013 4d84 64149FE5 		ldr	r1, .L981+76
 9014 4d88 0700A0E1 		mov	r0, r7
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9015              		.loc 1 753 0
 9016 4d8c FF30A0E3 		mov	r3, #255
1190:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 9017              		.loc 1 1190 0
 9018 4d90 28C0CBE5 		strb	ip, [fp, #40]
 9019              	.L942:
1191:../uvc.c      **** 			 }
 9020              		.loc 1 1191 0
 9021 4d94 2920CBE5 		strb	r2, [fp, #41]
 9022              	.LVL1063:
 9023              	.L944:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9024              		.loc 1 753 0
 9025 4d98 0370A0E1 		mov	r7, r3
1193:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 9026              		.loc 1 1193 0
 9027 4d9c 18308DE5 		str	r3, [sp, #24]
 9028 4da0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 9029              	.LVL1064:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9030              		.loc 1 753 0
 9031 4da4 18309DE5 		ldr	r3, [sp, #24]
1194:../uvc.c      **** 			  break;
 9032              		.loc 1 1194 0
 9033 4da8 2820DBE5 		ldrb	r2, [fp, #40]	@ zero_extendqisi2
 9034              	.LVL1065:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9035              		.loc 1 753 0
 9036 4dac 0380A0E1 		mov	r8, r3
 9037              	.LVL1066:
 9038              	.L874:
1654:../uvc.c      **** }
 9039              		.loc 1 1654 0
 9040 4db0 0C008DE9 		stmib	sp, {r2, r3}
 9041 4db4 20149FE5 		ldr	r1, .L981+56
 9042 4db8 0830A0E1 		mov	r3, r8
 9043              	.LVL1067:
 9044 4dbc 00708DE5 		str	r7, [sp]
 9045 4dc0 0620A0E1 		mov	r2, r6
 9046              	.LVL1068:
 9047 4dc4 0400A0E3 		mov	r0, #4
 9048 4dc8 FEFFFFEB 		bl	CyU3PDebugPrint
 9049              	.LVL1069:
 9050 4dcc 34309DE5 		ldr	r3, [sp, #52]
 9051 4dd0 53FDFFEA 		b	.L619
 9052              	.LVL1070:
 9053              	.L859:
 9054              	.LBE437:
 9055              	.LBE436:
3669:../uvc.c      ****     		break;
 9056              		.loc 1 3669 0
 9057 4dd4 2400A0E3 		mov	r0, #36
 9058 4dd8 FEFFFFEB 		bl	ControlHandle
 9059              	.LVL1071:
 9060 4ddc 34309DE5 		ldr	r3, [sp, #52]
 9061 4de0 4FFDFFEA 		b	.L619
 9062              	.L854:
 9063              	.LVL1072:
3643:../uvc.c      ****     		break;
 9064              		.loc 1 3643 0
 9065 4de4 1A00A0E3 		mov	r0, #26
 9066 4de8 FEFFFFEB 		bl	ControlHandle
 9067              	.LVL1073:
 9068 4dec 34309DE5 		ldr	r3, [sp, #52]
 9069 4df0 4BFDFFEA 		b	.L619
 9070              	.L840:
 9071              	.LVL1074:
3632:../uvc.c      ****      		break;
 9072              		.loc 1 3632 0
 9073 4df4 1800A0E3 		mov	r0, #24
 9074 4df8 FEFFFFEB 		bl	ControlHandle
 9075              	.LVL1075:
 9076 4dfc 34309DE5 		ldr	r3, [sp, #52]
 9077 4e00 47FDFFEA 		b	.L619
 9078              	.L850:
 9079              	.LVL1076:
3624:../uvc.c      ****     		break;
 9080              		.loc 1 3624 0
 9081 4e04 1600A0E3 		mov	r0, #22
 9082 4e08 FEFFFFEB 		bl	ControlHandle
 9083              	.LVL1077:
 9084 4e0c 34309DE5 		ldr	r3, [sp, #52]
 9085 4e10 43FDFFEA 		b	.L619
 9086              	.L862:
 9087              	.LVL1078:
3673:../uvc.c      ****     		break;
 9088              		.loc 1 3673 0
 9089 4e14 2500A0E3 		mov	r0, #37
 9090 4e18 FEFFFFEB 		bl	ControlHandle
 9091              	.LVL1079:
 9092 4e1c 34309DE5 		ldr	r3, [sp, #52]
 9093 4e20 3FFDFFEA 		b	.L619
 9094              	.L852:
 9095              	.LVL1080:
3661:../uvc.c      ****     		break;
 9096              		.loc 1 3661 0
 9097 4e24 1E00A0E3 		mov	r0, #30
 9098 4e28 FEFFFFEB 		bl	ControlHandle
 9099              	.LVL1081:
 9100 4e2c 34309DE5 		ldr	r3, [sp, #52]
 9101 4e30 3BFDFFEA 		b	.L619
 9102              	.L842:
 9103              	.LVL1082:
3612:../uvc.c      ****     		break;
 9104              		.loc 1 3612 0
 9105 4e34 1300A0E3 		mov	r0, #19
 9106 4e38 FEFFFFEB 		bl	ControlHandle
 9107              	.LVL1083:
 9108 4e3c 34309DE5 		ldr	r3, [sp, #52]
 9109 4e40 37FDFFEA 		b	.L619
 9110              	.L847:
 9111              	.LVL1084:
3620:../uvc.c      ****      		break;
 9112              		.loc 1 3620 0
 9113 4e44 1500A0E3 		mov	r0, #21
 9114 4e48 FEFFFFEB 		bl	ControlHandle
 9115              	.LVL1085:
 9116 4e4c 34309DE5 		ldr	r3, [sp, #52]
 9117 4e50 33FDFFEA 		b	.L619
 9118              	.L845:
 9119              	.LVL1086:
3608:../uvc.c      ****      		break;
 9120              		.loc 1 3608 0
 9121 4e54 1200A0E3 		mov	r0, #18
 9122 4e58 FEFFFFEB 		bl	ControlHandle
 9123              	.LVL1087:
 9124 4e5c 34309DE5 		ldr	r3, [sp, #52]
 9125 4e60 2FFDFFEA 		b	.L619
 9126              	.L844:
 9127              	.LVL1088:
3604:../uvc.c      ****     		break;
 9128              		.loc 1 3604 0
 9129 4e64 1100A0E3 		mov	r0, #17
 9130 4e68 FEFFFFEB 		bl	ControlHandle
 9131              	.LVL1089:
 9132 4e6c 34309DE5 		ldr	r3, [sp, #52]
 9133 4e70 2BFDFFEA 		b	.L619
 9134              	.LVL1090:
 9135              	.L971:
 9136              	.LBE454:
 9137              	.LBE471:
 9138              	.LBB472:
 9139              	.LBB428:
 9140              	.LBB383:
 9141              	.LBB374:
 765:../uvc.c      **** 		 {
 9142              		.loc 1 765 0
 9143 4e74 810056E3 		cmp	r6, #129
 9144 4e78 0703000A 		beq	.L704
 9145 4e7c 6402008A 		bhi	.L705
 9146 4e80 010056E3 		cmp	r6, #1
 9147 4e84 CDFEFF1A 		bne	.L701
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9148              		.loc 1 1197 0
 9149 4e88 32208DE2 		add	r2, sp, #50
 9150 4e8c 2000A0E3 		mov	r0, #32
 9151 4e90 58139FE5 		ldr	r1, .L981+76
 9152 4e94 18308DE5 		str	r3, [sp, #24]
 9153 4e98 1CC08DE5 		str	ip, [sp, #28]
 9154 4e9c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9155              	.LVL1091:
1199:../uvc.c      **** 			   {
 9156              		.loc 1 1199 0
 9157 4ea0 002050E2 		subs	r2, r0, #0
 9158 4ea4 1705001A 		bne	.L714
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9159              		.loc 1 1634 0
 9160 4ea8 44E39FE5 		ldr	lr, .L981+80
 9161 4eac 0010E0E3 		mvn	r1, #0
 9162 4eb0 1C009EE5 		ldr	r0, [lr, #28]
 9163              	.LVL1092:
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9164              		.loc 1 1201 0
 9165 4eb4 2870D4E5 		ldrb	r7, [r4, #40]	@ zero_extendqisi2
 9166              	.LVL1093:
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9167              		.loc 1 1204 0
 9168 4eb8 2A80D4E5 		ldrb	r8, [r4, #42]	@ zero_extendqisi2
 9169              	.LVL1094:
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9170              		.loc 1 1634 0
 9171 4ebc 20208DE5 		str	r2, [sp, #32]
 9172 4ec0 FEFFFFEB 		bl	_txe_mutex_get
 9173              	.LVL1095:
1635:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9174              		.loc 1 1635 0
 9175 4ec4 20209DE5 		ldr	r2, [sp, #32]
 9176 4ec8 1CC09DE5 		ldr	ip, [sp, #28]
 9177 4ecc 04208DE5 		str	r2, [sp, #4]
 9178 4ed0 18309DE5 		ldr	r3, [sp, #24]
 9179 4ed4 0C20A0E1 		mov	r2, ip
 9180 4ed8 0E10A0E3 		mov	r1, #14
 9181 4edc 00708DE5 		str	r7, [sp]
 9182 4ee0 0C039FE5 		ldr	r0, .L981+80
 9183 4ee4 FEFFFFEB 		bl	cmdSet
 9184              	.LVL1096:
1636:../uvc.c      **** 
 9185              		.loc 1 1636 0
 9186 4ee8 04139FE5 		ldr	r1, .L981+80
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9187              		.loc 1 753 0
 9188 4eec FF30A0E3 		mov	r3, #255
1636:../uvc.c      **** 
 9189              		.loc 1 1636 0
 9190 4ef0 1C0091E5 		ldr	r0, [r1, #28]
 9191 4ef4 18308DE5 		str	r3, [sp, #24]
 9192 4ef8 FEFFFFEB 		bl	_txe_mutex_put
 9193              	.LVL1097:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9194              		.loc 1 753 0
 9195 4efc 18309DE5 		ldr	r3, [sp, #24]
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9196              		.loc 1 1638 0
 9197 4f00 4973CAE5 		strb	r7, [r10, #841]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9198              		.loc 1 753 0
 9199 4f04 0320A0E1 		mov	r2, r3
1639:../uvc.c      **** 							 break;
 9200              		.loc 1 1639 0
 9201 4f08 4C63CAE5 		strb	r6, [r10, #844]
 9202 4f0c 0A0200EA 		b	.L711
 9203              	.LVL1098:
 9204              	.L968:
 9205              	.LBE374:
 9206              	.LBE383:
 9207              	.LBB384:
 9208              	.LBB353:
 765:../uvc.c      **** 		 {
 9209              		.loc 1 765 0
 9210 4f10 810056E3 		cmp	r6, #129
 9211 4f14 F302000A 		beq	.L661
 9212 4f18 3A02008A 		bhi	.L662
 9213 4f1c 010056E3 		cmp	r6, #1
 9214 4f20 5A03001A 		bne	.L658
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9215              		.loc 1 1197 0
 9216 4f24 32208DE2 		add	r2, sp, #50
 9217 4f28 2000A0E3 		mov	r0, #32
 9218 4f2c BC129FE5 		ldr	r1, .L981+76
 9219 4f30 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9220              	.LVL1099:
1199:../uvc.c      **** 			   {
 9221              		.loc 1 1199 0
 9222 4f34 002050E2 		subs	r2, r0, #0
 9223 4f38 3F05001A 		bne	.L671
1595:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 9224              		.loc 1 1595 0
 9225 4f3c 7415DAE5 		ldrb	r1, [r10, #1396]	@ zero_extendqisi2
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9226              		.loc 1 1201 0
 9227 4f40 28C0D4E5 		ldrb	ip, [r4, #40]	@ zero_extendqisi2
 9228              	.LVL1100:
1596:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 9229              		.loc 1 1596 0
 9230 4f44 7535DAE5 		ldrb	r3, [r10, #1397]	@ zero_extendqisi2
1597:../uvc.c      **** 						     dataIdx = 0;
 9231              		.loc 1 1597 0
 9232 4f48 8385DAE5 		ldrb	r8, [r10, #1411]	@ zero_extendqisi2
1595:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 9233              		.loc 1 1595 0
 9234 4f4c FF1001E2 		and	r1, r1, #255
1596:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 9235              		.loc 1 1596 0
 9236 4f50 FF3003E2 		and	r3, r3, #255
1601:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 9237              		.loc 1 1601 0
 9238 4f54 00005CE3 		cmp	ip, #0
1595:../uvc.c      **** 						     RegAdd1 = pPUCSenCtrl[CtrlID]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 9239              		.loc 1 1595 0
 9240 4f58 24108DE5 		str	r1, [sp, #36]
1599:../uvc.c      **** 							 pPUCSenCtrl[CtrlID]->AvailableF = CyTrue;
 9241              		.loc 1 1599 0
 9242 4f5c 81C5CAE5 		strb	ip, [r10, #1409]
1596:../uvc.c      **** 						     devAdd = pPUCSenCtrl[CtrlID]->DeviceAdd;
 9243              		.loc 1 1596 0
 9244 4f60 28308DE5 		str	r3, [sp, #40]
1597:../uvc.c      **** 						     dataIdx = 0;
 9245              		.loc 1 1597 0
 9246 4f64 FF8008E2 		and	r8, r8, #255
1600:../uvc.c      **** 							 if(Data0 != 0){
 9247              		.loc 1 1600 0
 9248 4f68 8565CAE5 		strb	r6, [r10, #1413]
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9249              		.loc 1 1204 0
 9250 4f6c 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 9251              	.LVL1101:
1602:../uvc.c      **** #ifdef COLOR
 9252              		.loc 1 1602 0
 9253 4f70 0010E0E3 		mvn	r1, #0
1601:../uvc.c      **** 								 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 9254              		.loc 1 1601 0
 9255 4f74 4404000A 		beq	.L672
1602:../uvc.c      **** #ifdef COLOR
 9256              		.loc 1 1602 0
 9257 4f78 74E29FE5 		ldr	lr, .L981+80
 9258 4f7c 1C009EE5 		ldr	r0, [lr, #28]
 9259              	.LVL1102:
 9260 4f80 1CC08DE5 		str	ip, [sp, #28]
 9261 4f84 20208DE5 		str	r2, [sp, #32]
 9262 4f88 FEFFFFEB 		bl	_txe_mutex_get
 9263              	.LVL1103:
1606:../uvc.c      **** 								 dataIdx++;
 9264              		.loc 1 1606 0
 9265 4f8c 20209DE5 		ldr	r2, [sp, #32]
 9266 4f90 0830A0E1 		mov	r3, r8
 9267 4f94 04208DE5 		str	r2, [sp, #4]
 9268 4f98 0710A0E3 		mov	r1, #7
 9269 4f9c 24209DE5 		ldr	r2, [sp, #36]
 9270 4fa0 00608DE5 		str	r6, [sp]
 9271 4fa4 48029FE5 		ldr	r0, .L981+80
 9272 4fa8 FEFFFFEB 		bl	cmdSet
 9273              	.LVL1104:
1608:../uvc.c      **** #endif
 9274              		.loc 1 1608 0
 9275 4fac 1CC09DE5 		ldr	ip, [sp, #28]
 9276 4fb0 0830A0E1 		mov	r3, r8
 9277 4fb4 00C08DE5 		str	ip, [sp]
 9278 4fb8 28209DE5 		ldr	r2, [sp, #40]
 9279 4fbc 0710A0E3 		mov	r1, #7
 9280 4fc0 04608DE5 		str	r6, [sp, #4]
 9281 4fc4 28029FE5 		ldr	r0, .L981+80
 9282 4fc8 FEFFFFEB 		bl	cmdSet
 9283              	.LVL1105:
1610:../uvc.c      **** 							 }else{
 9284              		.loc 1 1610 0
 9285 4fcc 20129FE5 		ldr	r1, .L981+80
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9286              		.loc 1 753 0
 9287 4fd0 FF80A0E3 		mov	r8, #255
 9288              	.LVL1106:
1610:../uvc.c      **** 							 }else{
 9289              		.loc 1 1610 0
 9290 4fd4 1C0091E5 		ldr	r0, [r1, #28]
 9291 4fd8 FEFFFFEB 		bl	_txe_mutex_put
 9292              	.LVL1107:
 9293 4fdc 1CC09DE5 		ldr	ip, [sp, #28]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9294              		.loc 1 753 0
 9295 4fe0 0830A0E1 		mov	r3, r8
 9296              	.LVL1108:
 9297              	.L668:
1654:../uvc.c      **** }
 9298              		.loc 1 1654 0
 9299 4fe4 08018DE9 		stmib	sp, {r3, r8}
 9300 4fe8 EC119FE5 		ldr	r1, .L981+56
 9301 4fec 0C30A0E1 		mov	r3, ip
 9302              	.LVL1109:
 9303 4ff0 00708DE5 		str	r7, [sp]
 9304 4ff4 0620A0E1 		mov	r2, r6
 9305 4ff8 0400A0E3 		mov	r0, #4
 9306 4ffc FEFFFFEB 		bl	CyU3PDebugPrint
 9307              	.LVL1110:
 9308 5000 34309DE5 		ldr	r3, [sp, #52]
 9309 5004 C6FCFFEA 		b	.L619
 9310              	.LVL1111:
 9311              	.L963:
 9312              	.LBE353:
 9313              	.LBE384:
 9314              	.LBB385:
 9315              	.LBB344:
 765:../uvc.c      **** 		 {
 9316              		.loc 1 765 0
 9317 5008 810056E3 		cmp	r6, #129
 9318 500c 9202000A 		beq	.L690
 9319 5010 F601008A 		bhi	.L691
 9320 5014 010056E3 		cmp	r6, #1
 9321 5018 7A02001A 		bne	.L864
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9322              		.loc 1 1197 0
 9323 501c 32208DE2 		add	r2, sp, #50
 9324 5020 2000A0E3 		mov	r0, #32
 9325 5024 C4119FE5 		ldr	r1, .L981+76
 9326 5028 18308DE5 		str	r3, [sp, #24]
 9327 502c 1CC08DE5 		str	ip, [sp, #28]
 9328 5030 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9329              	.LVL1112:
1199:../uvc.c      **** 			   {
 9330              		.loc 1 1199 0
 9331 5034 002050E2 		subs	r2, r0, #0
 9332 5038 AA04001A 		bne	.L877
1509:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9333              		.loc 1 1509 0
 9334 503c B0E19FE5 		ldr	lr, .L981+80
 9335 5040 0010E0E3 		mvn	r1, #0
 9336 5044 1C009EE5 		ldr	r0, [lr, #28]
 9337              	.LVL1113:
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9338              		.loc 1 1201 0
 9339 5048 2880D4E5 		ldrb	r8, [r4, #40]	@ zero_extendqisi2
 9340              	.LVL1114:
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9341              		.loc 1 1204 0
 9342 504c 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 9343              	.LVL1115:
1509:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9344              		.loc 1 1509 0
 9345 5050 20208DE5 		str	r2, [sp, #32]
 9346 5054 FEFFFFEB 		bl	_txe_mutex_get
 9347              	.LVL1116:
1510:../uvc.c      **** 							 dataIdx++;
 9348              		.loc 1 1510 0
 9349 5058 20209DE5 		ldr	r2, [sp, #32]
 9350 505c 18309DE5 		ldr	r3, [sp, #24]
 9351 5060 1CC09DE5 		ldr	ip, [sp, #28]
 9352 5064 04208DE5 		str	r2, [sp, #4]
 9353 5068 0B10A0E3 		mov	r1, #11
 9354 506c 0320A0E1 		mov	r2, r3
 9355 5070 00808DE5 		str	r8, [sp]
 9356 5074 0C30A0E1 		mov	r3, ip
 9357 5078 74019FE5 		ldr	r0, .L981+80
 9358 507c FEFFFFEB 		bl	cmdSet
 9359              	.LVL1117:
1512:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9360              		.loc 1 1512 0
 9361 5080 1CC09DE5 		ldr	ip, [sp, #28]
 9362 5084 24209DE5 		ldr	r2, [sp, #36]
 9363 5088 0C30A0E1 		mov	r3, ip
 9364 508c 0B10A0E3 		mov	r1, #11
 9365 5090 00708DE5 		str	r7, [sp]
 9366 5094 04608DE5 		str	r6, [sp, #4]
 9367 5098 54019FE5 		ldr	r0, .L981+80
 9368 509c FEFFFFEB 		bl	cmdSet
 9369              	.LVL1118:
1513:../uvc.c      **** 
 9370              		.loc 1 1513 0
 9371 50a0 4C119FE5 		ldr	r1, .L981+80
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9372              		.loc 1 753 0
 9373 50a4 FF30A0E3 		mov	r3, #255
1513:../uvc.c      **** 
 9374              		.loc 1 1513 0
 9375 50a8 1C0091E5 		ldr	r0, [r1, #28]
 9376 50ac 18308DE5 		str	r3, [sp, #24]
 9377 50b0 FEFFFFEB 		bl	_txe_mutex_put
 9378              	.LVL1119:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9379              		.loc 1 753 0
 9380 50b4 18309DE5 		ldr	r3, [sp, #24]
1515:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 9381              		.loc 1 1515 0
 9382 50b8 5C85CAE5 		strb	r8, [r10, #1372]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9383              		.loc 1 753 0
 9384 50bc 0320A0E1 		mov	r2, r3
1516:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9385              		.loc 1 1516 0
 9386 50c0 5E75CAE5 		strb	r7, [r10, #1374]
1517:../uvc.c      **** 							 break;
 9387              		.loc 1 1517 0
 9388 50c4 0463CAE5 		strb	r6, [r10, #772]
 9389 50c8 38FFFFEA 		b	.L874
 9390              	.LVL1120:
 9391              	.L957:
 9392              	.LBE344:
 9393              	.LBE385:
 9394              	.LBB386:
 9395              	.LBB333:
 765:../uvc.c      **** 		 {
 9396              		.loc 1 765 0
 9397 50cc 810056E3 		cmp	r6, #129
 9398 50d0 F702000A 		beq	.L643
 9399 50d4 BE01008A 		bhi	.L644
 9400 50d8 010056E3 		cmp	r6, #1
 9401 50dc 9202001A 		bne	.L640
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9402              		.loc 1 1197 0
 9403 50e0 32208DE2 		add	r2, sp, #50
 9404 50e4 2000A0E3 		mov	r0, #32
 9405 50e8 00119FE5 		ldr	r1, .L981+76
 9406 50ec 18308DE5 		str	r3, [sp, #24]
 9407 50f0 1CC08DE5 		str	ip, [sp, #28]
 9408 50f4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9409              	.LVL1121:
1199:../uvc.c      **** 			   {
 9410              		.loc 1 1199 0
 9411 50f8 002050E2 		subs	r2, r0, #0
 9412 50fc C704001A 		bne	.L655
1457:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 9413              		.loc 1 1457 0
 9414 5100 EC209FE5 		ldr	r2, .L981+80
 9415 5104 0010E0E3 		mvn	r1, #0
 9416 5108 1C0092E5 		ldr	r0, [r2, #28]
 9417              	.LVL1122:
 9418 510c 24208DE5 		str	r2, [sp, #36]
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9419              		.loc 1 1201 0
 9420 5110 2880D4E5 		ldrb	r8, [r4, #40]	@ zero_extendqisi2
 9421              	.LVL1123:
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9422              		.loc 1 1204 0
 9423 5114 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 9424              	.LVL1124:
1457:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 9425              		.loc 1 1457 0
 9426 5118 FEFFFFEB 		bl	_txe_mutex_get
 9427              	.LVL1125:
1459:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 9428              		.loc 1 1459 0
 9429 511c 800018E3 		tst	r8, #128
1460:../uvc.c      **** 							  }else{
 9430              		.loc 1 1460 0
 9431 5120 80204812 		subne	r2, r8, #128
1462:../uvc.c      **** 							  }
 9432              		.loc 1 1462 0
 9433 5124 0820E001 		mvneq	r2, r8
1459:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 9434              		.loc 1 1459 0
 9435 5128 1CC09DE5 		ldr	ip, [sp, #28]
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9436              		.loc 1 1464 0
 9437 512c 0010A0E3 		mov	r1, #0
1459:../uvc.c      **** 								  Data0 = Data0 - 0x80;
 9438              		.loc 1 1459 0
 9439 5130 18309DE5 		ldr	r3, [sp, #24]
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9440              		.loc 1 1464 0
 9441 5134 04108DE5 		str	r1, [sp, #4]
 9442 5138 B4009FE5 		ldr	r0, .L981+80
 9443 513c 0110A0E3 		mov	r1, #1
1462:../uvc.c      **** 							  }
 9444              		.loc 1 1462 0
 9445 5140 FF2002E2 		and	r2, r2, #255
 9446 5144 28208DE5 		str	r2, [sp, #40]
 9447              	.LVL1126:
1464:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9448              		.loc 1 1464 0
 9449 5148 28E09DE5 		ldr	lr, [sp, #40]
 9450 514c 0C20A0E1 		mov	r2, ip
 9451 5150 00E08DE5 		str	lr, [sp]
 9452 5154 FEFFFFEB 		bl	cmdSet
 9453              	.LVL1127:
1465:../uvc.c      **** 
 9454              		.loc 1 1465 0
 9455 5158 24109DE5 		ldr	r1, [sp, #36]
 9456 515c 1C0091E5 		ldr	r0, [r1, #28]
 9457 5160 FEFFFFEB 		bl	_txe_mutex_put
 9458              	.LVL1128:
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9459              		.loc 1 1467 0
 9460 5164 28209DE5 		ldr	r2, [sp, #40]
1468:../uvc.c      **** 
 9461              		.loc 1 1468 0
 9462 5168 0130A0E3 		mov	r3, #1
 9463 516c 1432CAE5 		strb	r3, [r10, #532]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9464              		.loc 1 753 0
 9465 5170 FF30A0E3 		mov	r3, #255
1467:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9466              		.loc 1 1467 0
 9467 5174 1122CAE5 		strb	r2, [r10, #529]
 9468              	.LVL1129:
 9469              	.L650:
1654:../uvc.c      **** }
 9470              		.loc 1 1654 0
 9471 5178 FF10A0E3 		mov	r1, #255
 9472 517c 04308DE5 		str	r3, [sp, #4]
 9473 5180 08108DE5 		str	r1, [sp, #8]
 9474 5184 0830A0E1 		mov	r3, r8
 9475              	.LVL1130:
 9476 5188 00708DE5 		str	r7, [sp]
 9477 518c 0620A0E1 		mov	r2, r6
 9478 5190 0400A0E3 		mov	r0, #4
 9479 5194 40109FE5 		ldr	r1, .L981+56
 9480 5198 FEFFFFEB 		bl	CyU3PDebugPrint
 9481              	.LVL1131:
 9482 519c 34309DE5 		ldr	r3, [sp, #52]
 9483 51a0 5FFCFFEA 		b	.L619
 9484              	.L982:
 9485              		.align	2
 9486              	.L981:
 9487 51a4 00000000 		.word	.LANCHOR0
 9488 51a8 00000000 		.word	glInterStaBuffer
 9489 51ac 00000000 		.word	wIndex
 9490 51b0 00000000 		.word	wValue
 9491 51b4 00000000 		.word	bRequest
 9492 51b8 4C0C0000 		.word	.LC70
 9493 51bc 00000000 		.word	bmReqType
 9494 51c0 00000000 		.word	wLength
 9495 51c4 D00B0000 		.word	.LC69
 9496 51c8 00000000 		.word	glChHandleInterStat
 9497 51cc 44060000 		.word	.LC37
 9498 51d0 20050000 		.word	.LC31
 9499 51d4 8C060000 		.word	.LC39
 9500 51d8 780C0000 		.word	.LC71
 9501 51dc CC050000 		.word	.LC35
 9502 51e0 01000100 		.word	65537
 9503 51e4 FF00FF00 		.word	16711935
 9504 51e8 68060000 		.word	.LC38
 9505 51ec 00000000 		.word	.LANCHOR1
 9506 51f0 28000000 		.word	.LANCHOR0+40
 9507 51f4 00000000 		.word	cmdQu
 9508              	.LVL1132:
 9509              	.L970:
 9510              	.LBE333:
 9511              	.LBE386:
 9512              	.LBB387:
 9513              	.LBB365:
 765:../uvc.c      **** 		 {
 9514              		.loc 1 765 0
 9515 51f8 810056E3 		cmp	r6, #129
 9516 51fc 9202000A 		beq	.L676
 9517 5200 7601008A 		bhi	.L677
 9518 5204 010056E3 		cmp	r6, #1
 9519 5208 ECFDFF1A 		bne	.L701
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9520              		.loc 1 1197 0
 9521 520c 32208DE2 		add	r2, sp, #50
 9522 5210 2000A0E3 		mov	r0, #32
 9523 5214 2C101FE5 		ldr	r1, .L981+76
 9524 5218 18308DE5 		str	r3, [sp, #24]
 9525 521c 1CC08DE5 		str	ip, [sp, #28]
 9526 5220 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9527              	.LVL1133:
1199:../uvc.c      **** 			   {
 9528              		.loc 1 1199 0
 9529 5224 002050E2 		subs	r2, r0, #0
 9530 5228 3604001A 		bne	.L714
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9531              		.loc 1 1634 0
 9532 522c 40101FE5 		ldr	r1, .L981+80
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9533              		.loc 1 1201 0
 9534 5230 2870D4E5 		ldrb	r7, [r4, #40]	@ zero_extendqisi2
 9535              	.LVL1134:
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9536              		.loc 1 1634 0
 9537 5234 1C0091E5 		ldr	r0, [r1, #28]
 9538              	.LVL1135:
 9539 5238 0010E0E3 		mvn	r1, #0
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9540              		.loc 1 1204 0
 9541 523c 2A80D4E5 		ldrb	r8, [r4, #42]	@ zero_extendqisi2
 9542              	.LVL1136:
1634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 9543              		.loc 1 1634 0
 9544 5240 20208DE5 		str	r2, [sp, #32]
 9545 5244 FEFFFFEB 		bl	_txe_mutex_get
 9546              	.LVL1137:
1635:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9547              		.loc 1 1635 0
 9548 5248 20209DE5 		ldr	r2, [sp, #32]
 9549 524c 1CC09DE5 		ldr	ip, [sp, #28]
 9550 5250 04208DE5 		str	r2, [sp, #4]
 9551 5254 18309DE5 		ldr	r3, [sp, #24]
 9552 5258 0C20A0E1 		mov	r2, ip
 9553 525c 0910A0E3 		mov	r1, #9
 9554 5260 00708DE5 		str	r7, [sp]
 9555 5264 78001FE5 		ldr	r0, .L981+80
 9556 5268 FEFFFFEB 		bl	cmdSet
 9557              	.LVL1138:
1636:../uvc.c      **** 
 9558              		.loc 1 1636 0
 9559 526c 80201FE5 		ldr	r2, .L981+80
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9560              		.loc 1 753 0
 9561 5270 FF30A0E3 		mov	r3, #255
1636:../uvc.c      **** 
 9562              		.loc 1 1636 0
 9563 5274 1C0092E5 		ldr	r0, [r2, #28]
 9564 5278 18308DE5 		str	r3, [sp, #24]
 9565 527c FEFFFFEB 		bl	_txe_mutex_put
 9566              	.LVL1139:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9567              		.loc 1 753 0
 9568 5280 18309DE5 		ldr	r3, [sp, #24]
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9569              		.loc 1 1638 0
 9570 5284 A0E01FE5 		ldr	lr, .L981+72
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9571              		.loc 1 753 0
 9572 5288 0320A0E1 		mov	r2, r3
1638:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 9573              		.loc 1 1638 0
 9574 528c D172CEE5 		strb	r7, [lr, #721]
1639:../uvc.c      **** 							 break;
 9575              		.loc 1 1639 0
 9576 5290 D462CEE5 		strb	r6, [lr, #724]
 9577 5294 280100EA 		b	.L711
 9578              	.LVL1140:
 9579              	.L969:
 9580              	.LBE365:
 9581              	.LBE387:
 9582              	.LBE428:
 9583              	.LBE472:
 9584              	.LBB473:
 9585              	.LBB323:
 9586              	.LBB258:
 9587              	.LBB190:
1680:../uvc.c      **** 		 {
 9588              		.loc 1 1680 0
 9589 5298 810056E3 		cmp	r6, #129
 9590 529c 3803000A 		beq	.L771
 9591 52a0 A101008A 		bhi	.L772
 9592 52a4 010056E3 		cmp	r6, #1
 9593 52a8 7BFDFF1A 		bne	.L768
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9594              		.loc 1 1751 0
 9595 52ac C4101FE5 		ldr	r1, .L981+76
 9596 52b0 32208DE2 		add	r2, sp, #50
 9597 52b4 2000A0E3 		mov	r0, #32
 9598 52b8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9599              	.LVL1141:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9600              		.loc 1 1881 0
 9601 52bc 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1882:../uvc.c      **** 			  		 break;
 9602              		.loc 1 1882 0
 9603 52c0 0400A0E3 		mov	r0, #4
 9604 52c4 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9605 52c8 0020A0E1 		mov	r2, r0
 9606 52cc 08111FE5 		ldr	r1, .L981+40
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9607              		.loc 1 1881 0
 9608 52d0 F5C5CAE5 		strb	ip, [r10, #1525]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9609              		.loc 1 1674 0
 9610 52d4 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9611              		.loc 1 1882 0
 9612 52d8 FEFFFFEB 		bl	CyU3PDebugPrint
 9613              	.LVL1142:
 9614 52dc F60000EA 		b	.L835
 9615              	.LVL1143:
 9616              	.L966:
 9617              	.LBE190:
 9618              	.LBE258:
 9619              	.LBB259:
 9620              	.LBB180:
1680:../uvc.c      **** 		 {
 9621              		.loc 1 1680 0
 9622 52e0 810056E3 		cmp	r6, #129
 9623 52e4 C202000A 		beq	.L744
 9624 52e8 9201008A 		bhi	.L745
 9625 52ec 010056E3 		cmp	r6, #1
 9626 52f0 A102001A 		bne	.L741
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9627              		.loc 1 1751 0
 9628 52f4 32208DE2 		add	r2, sp, #50
 9629 52f8 2000A0E3 		mov	r0, #32
 9630 52fc 14111FE5 		ldr	r1, .L981+76
 9631 5300 18308DE5 		str	r3, [sp, #24]
 9632 5304 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9633              	.LVL1144:
1753:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9634              		.loc 1 1753 0
 9635 5308 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 9636              	.LVL1145:
1763:../uvc.c      **** 				    getData = glEp0Buffer[0];
 9637              		.loc 1 1763 0
 9638 530c B065CAE5 		strb	r6, [r10, #1456]
 9639              	.LVL1146:
1766:../uvc.c      **** 						case 1:
 9640              		.loc 1 1766 0
 9641 5310 01204CE2 		sub	r2, ip, #1
1762:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 9642              		.loc 1 1762 0
 9643 5314 ADC5CAE5 		strb	ip, [r10, #1453]
1766:../uvc.c      **** 						case 1:
 9644              		.loc 1 1766 0
 9645 5318 18309DE5 		ldr	r3, [sp, #24]
 9646 531c 070052E3 		cmp	r2, #7
 9647 5320 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 9648 5324 ED0300EA 		b	.L890
 9649              	.L753:
 9650 5328 98620000 		.word	.L752
 9651 532c 1C620000 		.word	.L754
 9652 5330 E0620000 		.word	.L890
 9653 5334 D8610000 		.word	.L755
 9654 5338 E0620000 		.word	.L890
 9655 533c E0620000 		.word	.L890
 9656 5340 E0620000 		.word	.L890
 9657 5344 28610000 		.word	.L756
 9658              	.LVL1147:
 9659              	.L973:
 9660              	.LBE180:
 9661              	.LBE259:
 9662              	.LBB260:
 9663              	.LBB209:
1680:../uvc.c      **** 		 {
 9664              		.loc 1 1680 0
 9665 5348 810056E3 		cmp	r6, #129
 9666 534c 9602000A 		beq	.L817
 9667 5350 3F01008A 		bhi	.L818
 9668 5354 010056E3 		cmp	r6, #1
 9669 5358 CDFDFF1A 		bne	.L814
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9670              		.loc 1 1751 0
 9671 535c 74111FE5 		ldr	r1, .L981+76
 9672 5360 32208DE2 		add	r2, sp, #50
 9673 5364 2000A0E3 		mov	r0, #32
 9674 5368 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9675              	.LVL1148:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9676              		.loc 1 1881 0
 9677 536c 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1882:../uvc.c      **** 			  		 break;
 9678              		.loc 1 1882 0
 9679 5370 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9680 5374 0400A0E3 		mov	r0, #4
 9681 5378 B4111FE5 		ldr	r1, .L981+40
 9682 537c 0820A0E3 		mov	r2, #8
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9683              		.loc 1 1881 0
 9684 5380 55C6CAE5 		strb	ip, [r10, #1621]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9685              		.loc 1 1674 0
 9686 5384 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9687              		.loc 1 1882 0
 9688 5388 FEFFFFEB 		bl	CyU3PDebugPrint
 9689              	.LVL1149:
 9690 538c CA0000EA 		b	.L835
 9691              	.LVL1150:
 9692              	.L972:
 9693              	.LBE209:
 9694              	.LBE260:
 9695              	.LBB261:
 9696              	.LBB198:
1680:../uvc.c      **** 		 {
 9697              		.loc 1 1680 0
 9698 5390 810056E3 		cmp	r6, #129
 9699 5394 B802000A 		beq	.L828
 9700 5398 7201008A 		bhi	.L829
 9701 539c 010056E3 		cmp	r6, #1
 9702 53a0 8802001A 		bne	.L825
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9703              		.loc 1 1751 0
 9704 53a4 BC111FE5 		ldr	r1, .L981+76
 9705 53a8 32208DE2 		add	r2, sp, #50
 9706 53ac 2000A0E3 		mov	r0, #32
 9707 53b0 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9708              	.LVL1151:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9709              		.loc 1 1881 0
 9710 53b4 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1882:../uvc.c      **** 			  		 break;
 9711              		.loc 1 1882 0
 9712 53b8 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9713 53bc 0400A0E3 		mov	r0, #4
 9714 53c0 FC111FE5 		ldr	r1, .L981+40
 9715 53c4 0920A0E3 		mov	r2, #9
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9716              		.loc 1 1881 0
 9717 53c8 6DC6CAE5 		strb	ip, [r10, #1645]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9718              		.loc 1 1674 0
 9719 53cc FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9720              		.loc 1 1882 0
 9721 53d0 FEFFFFEB 		bl	CyU3PDebugPrint
 9722              	.LVL1152:
 9723 53d4 B80000EA 		b	.L835
 9724              	.LVL1153:
 9725              	.L978:
 9726              	.LBE198:
 9727              	.LBE261:
 9728              	.LBB262:
 9729              	.LBB250:
1680:../uvc.c      **** 		 {
 9730              		.loc 1 1680 0
 9731 53d8 810056E3 		cmp	r6, #129
 9732 53dc C302000A 		beq	.L804
 9733 53e0 1701008A 		bhi	.L805
 9734 53e4 010056E3 		cmp	r6, #1
 9735 53e8 9602001A 		bne	.L801
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9736              		.loc 1 1751 0
 9737 53ec 04121FE5 		ldr	r1, .L981+76
 9738 53f0 32208DE2 		add	r2, sp, #50
 9739 53f4 2000A0E3 		mov	r0, #32
 9740 53f8 18308DE5 		str	r3, [sp, #24]
 9741 53fc 1CC08DE5 		str	ip, [sp, #28]
 9742 5400 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9743              	.LVL1154:
1843:../uvc.c      **** 					  {
 9744              		.loc 1 1843 0
 9745 5404 20E21FE5 		ldr	lr, .L981+72
1753:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9746              		.loc 1 1753 0
 9747 5408 2810DBE5 		ldrb	r1, [fp, #40]	@ zero_extendqisi2
1843:../uvc.c      **** 					  {
 9748              		.loc 1 1843 0
 9749 540c AD05DEE5 		ldrb	r0, [lr, #1453]	@ zero_extendqisi2
1754:../uvc.c      **** 			  value = Data1;
 9750              		.loc 1 1754 0
 9751 5410 2920DBE5 		ldrb	r2, [fp, #41]	@ zero_extendqisi2
1843:../uvc.c      **** 					  {
 9752              		.loc 1 1843 0
 9753 5414 010050E3 		cmp	r0, #1
 9754 5418 08005013 		cmpne	r0, #8
1753:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 9755              		.loc 1 1753 0
 9756 541c 24108DE5 		str	r1, [sp, #36]
 9757              	.LVL1155:
1843:../uvc.c      **** 					  {
 9758              		.loc 1 1843 0
 9759 5420 0000A013 		movne	r0, #0
 9760 5424 0100A003 		moveq	r0, #1
1754:../uvc.c      **** 			  value = Data1;
 9761              		.loc 1 1754 0
 9762 5428 28208DE5 		str	r2, [sp, #40]
 9763              	.LVL1156:
1843:../uvc.c      **** 					  {
 9764              		.loc 1 1843 0
 9765 542c 2903001A 		bne	.L812
 9766              	.LVL1157:
1846:../uvc.c      **** 							 cmdSet(cmdQuptr, 0x22, RegAdd0, devAdd, Data0, dataIdx);  //First
 9767              		.loc 1 1846 0
 9768 5430 44721FE5 		ldr	r7, .L981+80
 9769 5434 0010E0E3 		mvn	r1, #0
 9770 5438 1C0097E5 		ldr	r0, [r7, #28]
 9771 543c FEFFFFEB 		bl	_txe_mutex_get
 9772              	.LVL1158:
1847:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 9773              		.loc 1 1847 0
 9774 5440 24E09DE5 		ldr	lr, [sp, #36]
 9775 5444 18309DE5 		ldr	r3, [sp, #24]
 9776 5448 1CC09DE5 		ldr	ip, [sp, #28]
 9777 544c 0010A0E3 		mov	r1, #0
 9778 5450 0320A0E1 		mov	r2, r3
 9779 5454 00E08DE5 		str	lr, [sp]
 9780 5458 0C30A0E1 		mov	r3, ip
 9781 545c 04108DE5 		str	r1, [sp, #4]
 9782 5460 0700A0E1 		mov	r0, r7
 9783 5464 2210A0E3 		mov	r1, #34
 9784 5468 FEFFFFEB 		bl	cmdSet
 9785              	.LVL1159:
1848:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
 9786              		.loc 1 1848 0
 9787 546c 1C0097E5 		ldr	r0, [r7, #28]
 9788 5470 FEFFFFEB 		bl	_txe_mutex_put
 9789              	.LVL1160:
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9790              		.loc 1 1851 0
 9791 5474 90221FE5 		ldr	r2, .L981+72
 9792 5478 24109DE5 		ldr	r1, [sp, #36]
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9793              		.loc 1 1852 0
 9794 547c 28309DE5 		ldr	r3, [sp, #40]
1851:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 9795              		.loc 1 1851 0
 9796 5480 3D16C2E5 		strb	r1, [r2, #1597]
1852:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 9797              		.loc 1 1852 0
 9798 5484 3E36C2E5 		strb	r3, [r2, #1598]
1853:../uvc.c      **** 					  }else{
 9799              		.loc 1 1853 0
 9800 5488 4066C2E5 		strb	r6, [r2, #1600]
 9801              	.LVL1161:
 9802              	.L813:
1857:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
 9803              		.loc 1 1857 0
 9804 548c 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 9805              	.LVL1162:
1858:../uvc.c      **** 
 9806              		.loc 1 1858 0
 9807 5490 2920DBE5 		ldrb	r2, [fp, #41]	@ zero_extendqisi2
 9808              	.LVL1163:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9809              		.loc 1 1674 0
 9810 5494 FF70A0E3 		mov	r7, #255
 9811 5498 FFFDFFEA 		b	.L811
 9812              	.LVL1164:
 9813              	.L974:
 9814              	.LBE250:
 9815              	.LBE262:
 9816              	.LBB263:
 9817              	.LBB217:
1680:../uvc.c      **** 		 {
 9818              		.loc 1 1680 0
 9819 549c 810056E3 		cmp	r6, #129
 9820 54a0 8E02000A 		beq	.L733
 9821 54a4 2B01008A 		bhi	.L734
 9822 54a8 010056E3 		cmp	r6, #1
 9823 54ac 96FDFF1A 		bne	.L730
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9824              		.loc 1 1751 0
 9825 54b0 C8121FE5 		ldr	r1, .L981+76
 9826 54b4 32208DE2 		add	r2, sp, #50
 9827 54b8 2000A0E3 		mov	r0, #32
 9828 54bc FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9829              	.LVL1165:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9830              		.loc 1 1881 0
 9831 54c0 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1882:../uvc.c      **** 			  		 break;
 9832              		.loc 1 1882 0
 9833 54c4 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9834 54c8 0400A0E3 		mov	r0, #4
 9835 54cc 08131FE5 		ldr	r1, .L981+40
 9836 54d0 0020A0E3 		mov	r2, #0
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9837              		.loc 1 1881 0
 9838 54d4 95C5CAE5 		strb	ip, [r10, #1429]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9839              		.loc 1 1674 0
 9840 54d8 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9841              		.loc 1 1882 0
 9842 54dc FEFFFFEB 		bl	CyU3PDebugPrint
 9843              	.LVL1166:
 9844 54e0 750000EA 		b	.L835
 9845              	.LVL1167:
 9846              	.L977:
 9847              	.LBE217:
 9848              	.LBE263:
 9849              	.LBB264:
 9850              	.LBB242:
1680:../uvc.c      **** 		 {
 9851              		.loc 1 1680 0
 9852 54e4 810056E3 		cmp	r6, #129
 9853 54e8 1002000A 		beq	.L782
 9854 54ec DF00008A 		bhi	.L783
 9855 54f0 010056E3 		cmp	r6, #1
 9856 54f4 8F02001A 		bne	.L779
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9857              		.loc 1 1751 0
 9858 54f8 10131FE5 		ldr	r1, .L981+76
 9859 54fc 32208DE2 		add	r2, sp, #50
 9860 5500 2000A0E3 		mov	r0, #32
 9861 5504 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9862              	.LVL1168:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9863              		.loc 1 1881 0
 9864 5508 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 9865 550c 28E31FE5 		ldr	lr, .L981+72
1882:../uvc.c      **** 			  		 break;
 9866              		.loc 1 1882 0
 9867 5510 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9868 5514 0400A0E3 		mov	r0, #4
 9869 5518 54131FE5 		ldr	r1, .L981+40
 9870 551c 0520A0E3 		mov	r2, #5
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9871              		.loc 1 1881 0
 9872 5520 0DC6CEE5 		strb	ip, [lr, #1549]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9873              		.loc 1 1674 0
 9874 5524 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9875              		.loc 1 1882 0
 9876 5528 FEFFFFEB 		bl	CyU3PDebugPrint
 9877              	.LVL1169:
 9878 552c 620000EA 		b	.L835
 9879              	.LVL1170:
 9880              	.L976:
 9881              	.LBE242:
 9882              	.LBE264:
 9883              	.LBB265:
 9884              	.LBB234:
1680:../uvc.c      **** 		 {
 9885              		.loc 1 1680 0
 9886 5530 810056E3 		cmp	r6, #129
 9887 5534 7B02000A 		beq	.L793
 9888 5538 C800008A 		bhi	.L794
 9889 553c 010056E3 		cmp	r6, #1
 9890 5540 9CFDFF1A 		bne	.L790
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9891              		.loc 1 1751 0
 9892 5544 5C131FE5 		ldr	r1, .L981+76
 9893 5548 32208DE2 		add	r2, sp, #50
 9894 554c 2000A0E3 		mov	r0, #32
 9895 5550 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9896              	.LVL1171:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9897              		.loc 1 1881 0
 9898 5554 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
1882:../uvc.c      **** 			  		 break;
 9899              		.loc 1 1882 0
 9900 5558 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9901 555c 0400A0E3 		mov	r0, #4
 9902 5560 9C131FE5 		ldr	r1, .L981+40
 9903 5564 0620A0E3 		mov	r2, #6
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9904              		.loc 1 1881 0
 9905 5568 25C6CAE5 		strb	ip, [r10, #1573]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9906              		.loc 1 1674 0
 9907 556c FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9908              		.loc 1 1882 0
 9909 5570 FEFFFFEB 		bl	CyU3PDebugPrint
 9910              	.LVL1172:
 9911 5574 500000EA 		b	.L835
 9912              	.LVL1173:
 9913              	.L975:
 9914              	.LBE234:
 9915              	.LBE265:
 9916              	.LBB266:
 9917              	.LBB225:
1680:../uvc.c      **** 		 {
 9918              		.loc 1 1680 0
 9919 5578 810056E3 		cmp	r6, #129
 9920 557c DF01000A 		beq	.L760
 9921 5580 BE00008A 		bhi	.L761
 9922 5584 010056E3 		cmp	r6, #1
 9923 5588 8102001A 		bne	.L757
1751:../uvc.c      **** 			  glEp0Buffer, &readCount);
 9924              		.loc 1 1751 0
 9925 558c A4131FE5 		ldr	r1, .L981+76
 9926 5590 32208DE2 		add	r2, sp, #50
 9927 5594 2000A0E3 		mov	r0, #32
 9928 5598 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9929              	.LVL1174:
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9930              		.loc 1 1881 0
 9931 559c 28C0DBE5 		ldrb	ip, [fp, #40]	@ zero_extendqisi2
 9932 55a0 BCE31FE5 		ldr	lr, .L981+72
1882:../uvc.c      **** 			  		 break;
 9933              		.loc 1 1882 0
 9934 55a4 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 9935 55a8 0400A0E3 		mov	r0, #4
 9936 55ac E8131FE5 		ldr	r1, .L981+40
 9937 55b0 0220A0E3 		mov	r2, #2
1881:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 9938              		.loc 1 1881 0
 9939 55b4 C5C5CEE5 		strb	ip, [lr, #1477]
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9940              		.loc 1 1674 0
 9941 55b8 FF70A0E3 		mov	r7, #255
1882:../uvc.c      **** 			  		 break;
 9942              		.loc 1 1882 0
 9943 55bc FEFFFFEB 		bl	CyU3PDebugPrint
 9944              	.LVL1175:
 9945 55c0 3D0000EA 		b	.L835
 9946              	.LVL1176:
 9947              	.L979:
 9948              	.LBE225:
 9949              	.LBE266:
 9950              	.LBE323:
 9951              	.LBE473:
 9952              	.LBB474:
 9953              	.LBB455:
 9954              	.LBB444:
 9955              	.LBB438:
 765:../uvc.c      **** 		 {
 9956              		.loc 1 765 0
 9957 55c4 810056E3 		cmp	r6, #129
 9958 55c8 EA00000A 		beq	.L867
 9959 55cc AB02008A 		bhi	.L868
 9960 55d0 010056E3 		cmp	r6, #1
 9961 55d4 0B01001A 		bne	.L864
1197:../uvc.c      **** 				  glEp0Buffer, &readCount);
 9962              		.loc 1 1197 0
 9963 55d8 32208DE2 		add	r2, sp, #50
 9964 55dc 2000A0E3 		mov	r0, #32
 9965 55e0 F8131FE5 		ldr	r1, .L981+76
 9966 55e4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 9967              	.LVL1177:
1199:../uvc.c      **** 			   {
 9968              		.loc 1 1199 0
 9969 55e8 002050E2 		subs	r2, r0, #0
 9970 55ec 3D03001A 		bne	.L877
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 9971              		.loc 1 1309 0
 9972 55f0 04241FE5 		ldr	r2, .L981+80
 9973 55f4 08E41FE5 		ldr	lr, .L981+80
 9974 55f8 24208DE5 		str	r2, [sp, #36]
1305:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 9975              		.loc 1 1305 0
 9976 55fc 3425DAE5 		ldrb	r2, [r10, #1332]	@ zero_extendqisi2
1306:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 9977              		.loc 1 1306 0
 9978 5600 35C5DAE5 		ldrb	ip, [r10, #1333]	@ zero_extendqisi2
1307:../uvc.c      **** 						     dataIdx = 0;
 9979              		.loc 1 1307 0
 9980 5604 4335DAE5 		ldrb	r3, [r10, #1347]	@ zero_extendqisi2
1305:../uvc.c      **** 						     RegAdd1 = EXTShutlev.Reg2; //ExUCtrlParArry[locCtrlID][1];
 9981              		.loc 1 1305 0
 9982 5608 FF2002E2 		and	r2, r2, #255
1307:../uvc.c      **** 						     dataIdx = 0;
 9983              		.loc 1 1307 0
 9984 560c FF3003E2 		and	r3, r3, #255
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 9985              		.loc 1 1309 0
 9986 5610 1C009EE5 		ldr	r0, [lr, #28]
 9987              	.LVL1178:
1306:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 9988              		.loc 1 1306 0
 9989 5614 FFC00CE2 		and	ip, ip, #255
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 9990              		.loc 1 1309 0
 9991 5618 0010E0E3 		mvn	r1, #0
1201:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 9992              		.loc 1 1201 0
 9993 561c 2880D4E5 		ldrb	r8, [r4, #40]	@ zero_extendqisi2
 9994              	.LVL1179:
1307:../uvc.c      **** 						     dataIdx = 0;
 9995              		.loc 1 1307 0
 9996 5620 28308DE5 		str	r3, [sp, #40]
1204:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 9997              		.loc 1 1204 0
 9998 5624 2A70D4E5 		ldrb	r7, [r4, #42]	@ zero_extendqisi2
 9999              	.LVL1180:
1306:../uvc.c      **** 						     devAdd = EXTShutlev.DeviceAdd;
 10000              		.loc 1 1306 0
 10001 5628 2CC08DE5 		str	ip, [sp, #44]
 10002              	.LVL1181:
1309:../uvc.c      **** 							 if(0&&EXTShutlev.UVCCurVLo != getData)
 10003              		.loc 1 1309 0
 10004 562c 20208DE5 		str	r2, [sp, #32]
 10005 5630 FEFFFFEB 		bl	_txe_mutex_get
 10006              	.LVL1182:
1317:../uvc.c      **** 								 EXTShutlev.UVCCurVLo = getData;//AGC. CtrlParArry[CtrlID][14]
 10007              		.loc 1 1317 0
 10008 5634 4135DAE5 		ldrb	r3, [r10, #1345]	@ zero_extendqisi2
 10009 5638 20209DE5 		ldr	r2, [sp, #32]
 10010 563c 030058E1 		cmp	r8, r3
 10011 5640 0700000A 		beq	.L879
1318:../uvc.c      **** 								 if(EXTAexModGainlev.UVCCurVLo == 1 || EXTAexModGainlev.UVCCurVLo == 3){
 10012              		.loc 1 1318 0
 10013 5644 60141FE5 		ldr	r1, .L981+72
 10014 5648 4185C1E5 		strb	r8, [r1, #1345]
1319:../uvc.c      **** 									 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x80, dataIdx);  //set AxMode2 bit7
 10015              		.loc 1 1319 0
 10016 564c 5535D1E5 		ldrb	r3, [r1, #1365]	@ zero_extendqisi2
 10017 5650 010053E3 		cmp	r3, #1
 10018 5654 A302000A 		beq	.L880
 10019 5658 5535D1E5 		ldrb	r3, [r1, #1365]	@ zero_extendqisi2
 10020 565c 030053E3 		cmp	r3, #3
 10021 5660 A002000A 		beq	.L880
 10022              	.LVL1183:
 10023              	.L879:
1326:../uvc.c      **** 							 CyU3PDebugPrint (4, "Shutter level gotten from host. 0x%x %d; 0x%x 0x%x %d\r\n",
 10024              		.loc 1 1326 0
 10025 5664 24209DE5 		ldr	r2, [sp, #36]
 10026 5668 1C0092E5 		ldr	r0, [r2, #28]
 10027 566c FEFFFFEB 		bl	_txe_mutex_put
 10028              	.LVL1184:
1328:../uvc.c      **** 							 break;
 10029              		.loc 1 1328 0
 10030 5670 5525DAE5 		ldrb	r2, [r10, #1365]	@ zero_extendqisi2
 10031 5674 5635DAE5 		ldrb	r3, [r10, #1366]	@ zero_extendqisi2
 10032 5678 4115DAE5 		ldrb	r1, [r10, #1345]	@ zero_extendqisi2
1327:../uvc.c      **** 									 EXTAexModGainlev.UVCCurVLo, EXTAexModGainlev.UVCCurVHi, EXTShutlev.UVCCurVLo, getData, ge
 10033              		.loc 1 1327 0
 10034 567c 04808DE5 		str	r8, [sp, #4]
 10035 5680 00108DE5 		str	r1, [sp]
 10036 5684 08708DE5 		str	r7, [sp, #8]
 10037 5688 0400A0E3 		mov	r0, #4
 10038 568c C4141FE5 		ldr	r1, .L981+44
 10039 5690 FEFFFFEB 		bl	CyU3PDebugPrint
 10040              	.LVL1185:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10041              		.loc 1 753 0
 10042 5694 FF30A0E3 		mov	r3, #255
 10043 5698 0320A0E1 		mov	r2, r3
 10044 569c C3FDFFEA 		b	.L874
 10045              	.LVL1186:
 10046              	.L831:
 10047              	.LBE438:
 10048              	.LBE444:
 10049              	.LBE455:
 10050              	.LBE474:
 10051              	.LBB475:
 10052              	.LBB324:
 10053              	.LBB267:
 10054              	.LBB199:
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10055              		.loc 1 1685 0
 10056 56a0 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10057              		.loc 1 1686 0
 10058 56a4 0200A0E3 		mov	r0, #2
 10059 56a8 C0141FE5 		ldr	r1, .L981+76
1684:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10060              		.loc 1 1684 0
 10061 56ac 2880CBE5 		strb	r8, [fp, #40]
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10062              		.loc 1 1685 0
 10063 56b0 2930CBE5 		strb	r3, [fp, #41]
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10064              		.loc 1 1686 0
 10065 56b4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10066              	.LVL1187:
1687:../uvc.c      **** 			  break;
 10067              		.loc 1 1687 0
 10068 56b8 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 10069              	.LVL1188:
 10070              	.L835:
1893:../uvc.c      **** }
 10071              		.loc 1 1893 0
 10072 56bc 2A10DBE5 		ldrb	r1, [fp, #42]	@ zero_extendqisi2
 10073 56c0 FF30A0E3 		mov	r3, #255
 10074 56c4 04108DE5 		str	r1, [sp, #4]
 10075 56c8 10108DE5 		str	r1, [sp, #16]
 10076 56cc 00308DE5 		str	r3, [sp]
 10077 56d0 0C308DE5 		str	r3, [sp, #12]
 10078 56d4 08708DE5 		str	r7, [sp, #8]
 10079 56d8 14808DE5 		str	r8, [sp, #20]
 10080 56dc 0620A0E1 		mov	r2, r6
 10081 56e0 0400A0E3 		mov	r0, #4
 10082 56e4 18151FE5 		ldr	r1, .L981+48
 10083 56e8 FEFFFFEB 		bl	CyU3PDebugPrint
 10084              	.LVL1189:
 10085 56ec 34309DE5 		ldr	r3, [sp, #52]
 10086 56f0 0BFBFFEA 		b	.L619
 10087              	.LVL1190:
 10088              	.L961:
 10089 56f4 0270A0E1 		mov	r7, r2
 10090              	.LBE199:
 10091              	.LBE267:
 10092              	.LBE324:
 10093              	.LBE475:
4216:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
 10094              		.loc 1 4216 0
 10095 56f8 0800A0E1 		mov	r0, r8
 10096              	.LVL1191:
 10097 56fc 2C151FE5 		ldr	r1, .L981+52
 10098 5700 FEFFFFEB 		bl	CyU3PDebugPrint
 10099              	.LVL1192:
4217:../uvc.c      **** 					}
 10100              		.loc 1 4217 0
 10101 5704 0700A0E1 		mov	r0, r7
 10102 5708 FEFFFFEB 		bl	CyFxAppErrorHandler
 10103              	.LVL1193:
 10104              	.L707:
 10105              	.LBB476:
 10106              	.LBB429:
 10107              	.LBB388:
 10108              	.LBB375:
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10109              		.loc 1 771 0
 10110 570c 24151FE5 		ldr	r1, .L981+76
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10111              		.loc 1 770 0
 10112 5710 0020A0E3 		mov	r2, #0
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10113              		.loc 1 771 0
 10114 5714 0200A0E3 		mov	r0, #2
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10115              		.loc 1 753 0
 10116 5718 FF30A0E3 		mov	r3, #255
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10117              		.loc 1 769 0
 10118 571c 2870CBE5 		strb	r7, [fp, #40]
 10119              	.L928:
1129:../uvc.c      **** 			 }
 10120              		.loc 1 1129 0
 10121 5720 2920CBE5 		strb	r2, [fp, #41]
 10122              	.L930:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10123              		.loc 1 753 0
 10124 5724 0380A0E1 		mov	r8, r3
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10125              		.loc 1 1131 0
 10126 5728 18308DE5 		str	r3, [sp, #24]
 10127 572c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10128              	.LVL1194:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10129              		.loc 1 753 0
 10130 5730 18309DE5 		ldr	r3, [sp, #24]
1132:../uvc.c      **** 			  break;
 10131              		.loc 1 1132 0
 10132 5734 2820DBE5 		ldrb	r2, [fp, #40]	@ zero_extendqisi2
 10133              	.LVL1195:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10134              		.loc 1 753 0
 10135 5738 0370A0E1 		mov	r7, r3
 10136              	.LVL1196:
 10137              	.L711:
1654:../uvc.c      **** }
 10138              		.loc 1 1654 0
 10139 573c 0C008DE9 		stmib	sp, {r2, r3}
 10140 5740 6C151FE5 		ldr	r1, .L981+56
 10141 5744 0730A0E1 		mov	r3, r7
 10142              	.LVL1197:
 10143 5748 00808DE5 		str	r8, [sp]
 10144 574c 0620A0E1 		mov	r2, r6
 10145              	.LVL1198:
 10146 5750 0400A0E3 		mov	r0, #4
 10147 5754 FEFFFFEB 		bl	CyU3PDebugPrint
 10148              	.LVL1199:
 10149 5758 34309DE5 		ldr	r3, [sp, #52]
 10150 575c F0FAFFEA 		b	.L619
 10151              	.LVL1200:
 10152              	.L666:
 10153              	.LBE375:
 10154              	.LBE388:
 10155              	.LBB389:
 10156              	.LBB354:
1173:../uvc.c      **** 		 	 }
 10157              		.loc 1 1173 0
 10158 5760 9D32DAE5 		ldrb	r3, [r10, #669]	@ zero_extendqisi2
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10159              		.loc 1 753 0
 10160 5764 FF80A0E3 		mov	r8, #255
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10161              		.loc 1 1175 0
 10162 5768 0100A0E3 		mov	r0, #1
 10163 576c 84151FE5 		ldr	r1, .L981+76
1173:../uvc.c      **** 		 	 }
 10164              		.loc 1 1173 0
 10165 5770 2830CBE5 		strb	r3, [fp, #40]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10166              		.loc 1 753 0
 10167 5774 0870A0E1 		mov	r7, r8
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10168              		.loc 1 1175 0
 10169 5778 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10170              	.LVL1201:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10171              		.loc 1 753 0
 10172 577c 08C0A0E1 		mov	ip, r8
1176:../uvc.c      **** 			  Len = 1;
 10173              		.loc 1 1176 0
 10174 5780 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 10175              	.LVL1202:
 10176 5784 16FEFFEA 		b	.L668
 10177              	.LVL1203:
 10178              	.L709:
 10179              	.LBE354:
 10180              	.LBE389:
 10181              	.LBB390:
 10182              	.LBB376:
1173:../uvc.c      **** 		 	 }
 10183              		.loc 1 1173 0
 10184 5788 4523DAE5 		ldrb	r2, [r10, #837]	@ zero_extendqisi2
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10185              		.loc 1 1175 0
 10186 578c 0100A0E3 		mov	r0, #1
 10187 5790 A8151FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10188              		.loc 1 753 0
 10189 5794 FF30A0E3 		mov	r3, #255
1173:../uvc.c      **** 		 	 }
 10190              		.loc 1 1173 0
 10191 5798 2820CBE5 		strb	r2, [fp, #40]
 10192 579c E0FFFFEA 		b	.L930
 10193              	.LVL1204:
 10194              	.L695:
 10195              	.LBE376:
 10196              	.LBE390:
 10197              	.LBB391:
 10198              	.LBB345:
 10199 57a0 FD22DAE5 		ldrb	r2, [r10, #765]	@ zero_extendqisi2
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10200              		.loc 1 1175 0
 10201 57a4 0100A0E3 		mov	r0, #1
 10202 57a8 C0151FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10203              		.loc 1 753 0
 10204 57ac FF30A0E3 		mov	r3, #255
1173:../uvc.c      **** 		 	 }
 10205              		.loc 1 1173 0
 10206 57b0 2820CBE5 		strb	r2, [fp, #40]
 10207 57b4 77FDFFEA 		b	.L944
 10208              	.LVL1205:
 10209              	.L681:
 10210              	.LBE345:
 10211              	.LBE391:
 10212              	.LBB392:
 10213              	.LBB366:
 10214 57b8 D4351FE5 		ldr	r3, .L981+72
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10215              		.loc 1 1175 0
 10216 57bc 0100A0E3 		mov	r0, #1
1173:../uvc.c      **** 		 	 }
 10217              		.loc 1 1173 0
 10218 57c0 CD22D3E5 		ldrb	r2, [r3, #717]	@ zero_extendqisi2
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10219              		.loc 1 1175 0
 10220 57c4 DC151FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10221              		.loc 1 753 0
 10222 57c8 FF30A0E3 		mov	r3, #255
1173:../uvc.c      **** 		 	 }
 10223              		.loc 1 1173 0
 10224 57cc 2820CBE5 		strb	r2, [fp, #40]
 10225 57d0 D3FFFFEA 		b	.L930
 10226              	.LVL1206:
 10227              	.L644:
 10228              	.LBE366:
 10229              	.LBE392:
 10230              	.LBB393:
 10231              	.LBB334:
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10232              		.loc 1 1128 0
 10233 57d4 0722DAE5 		ldrb	r2, [r10, #519]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 10234              		.loc 1 1129 0
 10235 57d8 0832DAE5 		ldrb	r3, [r10, #520]	@ zero_extendqisi2
 10236 57dc 04FBFFEA 		b	.L920
 10237              	.LVL1207:
 10238              	.L677:
 10239              	.LBE334:
 10240              	.LBE393:
 10241              	.LBB394:
 10242              	.LBB367:
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10243              		.loc 1 1128 0
 10244 57e0 FCE51FE5 		ldr	lr, .L981+72
 10245 57e4 C7C2DEE5 		ldrb	ip, [lr, #711]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 10246              		.loc 1 1129 0
 10247 57e8 C822DEE5 		ldrb	r2, [lr, #712]	@ zero_extendqisi2
 10248 57ec 5DFCFFEA 		b	.L929
 10249              	.LVL1208:
 10250              	.L691:
 10251              	.LBE367:
 10252              	.LBE394:
 10253              	.LBB395:
 10254              	.LBB346:
1122:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 10255              		.loc 1 1122 0
 10256 57f0 18261FE5 		ldr	r2, .L981+60
 10257              	.L927:
1131:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10258              		.loc 1 1131 0
 10259 57f4 0700A0E1 		mov	r0, r7
 10260 57f8 10161FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10261              		.loc 1 753 0
 10262 57fc FF30A0E3 		mov	r3, #255
1122:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 10263              		.loc 1 1122 0
 10264 5800 28208BE5 		str	r2, [fp, #40]
 10265 5804 63FDFFEA 		b	.L944
 10266              	.LVL1209:
 10267              	.L662:
 10268              	.LBE346:
 10269              	.LBE395:
 10270              	.LBB396:
 10271              	.LBB355:
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10272              		.loc 1 1128 0
 10273 5808 9722DAE5 		ldrb	r2, [r10, #663]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 10274              		.loc 1 1129 0
 10275 580c 9832DAE5 		ldrb	r3, [r10, #664]	@ zero_extendqisi2
 10276 5810 FFFBFFEA 		b	.L922
 10277              	.LVL1210:
 10278              	.L705:
 10279              	.LBE355:
 10280              	.LBE396:
 10281              	.LBB397:
 10282              	.LBB377:
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 10283              		.loc 1 1128 0
 10284 5814 3FC3DAE5 		ldrb	ip, [r10, #831]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 10285              		.loc 1 1129 0
 10286 5818 4023DAE5 		ldrb	r2, [r10, #832]	@ zero_extendqisi2
 10287 581c 51FCFFEA 		b	.L929
 10288              	.LVL1211:
 10289              	.L648:
 10290              	.LBE377:
 10291              	.LBE397:
 10292              	.LBB398:
 10293              	.LBB335:
1173:../uvc.c      **** 		 	 }
 10294              		.loc 1 1173 0
 10295 5820 0D32DAE5 		ldrb	r3, [r10, #525]	@ zero_extendqisi2
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10296              		.loc 1 1175 0
 10297 5824 0100A0E3 		mov	r0, #1
 10298 5828 40161FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10299              		.loc 1 753 0
 10300 582c FF70A0E3 		mov	r7, #255
1173:../uvc.c      **** 		 	 }
 10301              		.loc 1 1173 0
 10302 5830 2830CBE5 		strb	r3, [fp, #40]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10303              		.loc 1 753 0
 10304 5834 0780A0E1 		mov	r8, r7
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10305              		.loc 1 1175 0
 10306 5838 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10307              	.LVL1212:
1176:../uvc.c      **** 			  Len = 1;
 10308              		.loc 1 1176 0
 10309 583c 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 10310              	.LVL1213:
 10311 5840 4CFEFFEA 		b	.L650
 10312              	.LVL1214:
 10313              	.L805:
 10314              	.LBE335:
 10315              	.LBE398:
 10316              	.LBE429:
 10317              	.LBE476:
 10318              	.LBB477:
 10319              	.LBB325:
 10320              	.LBB268:
 10321              	.LBB251:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10322              		.loc 1 1709 0
 10323 5844 60261FE5 		ldr	r2, .L981+72
 10324 5848 3316D2E5 		ldrb	r1, [r2, #1587]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10325              		.loc 1 1710 0
 10326 584c 3426D2E5 		ldrb	r2, [r2, #1588]	@ zero_extendqisi2
 10327 5850 06FDFFEA 		b	.L939
 10328              	.LVL1215:
 10329              	.L818:
 10330              	.LBE251:
 10331              	.LBE268:
 10332              	.LBB269:
 10333              	.LBB210:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10334              		.loc 1 1709 0
 10335 5854 4B16DAE5 		ldrb	r1, [r10, #1611]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10336              		.loc 1 1710 0
 10337 5858 4C26DAE5 		ldrb	r2, [r10, #1612]	@ zero_extendqisi2
 10338 585c 73FCFFEA 		b	.L941
 10339              	.LVL1216:
 10340              	.L794:
 10341              	.LBE210:
 10342              	.LBE269:
 10343              	.LBB270:
 10344              	.LBB235:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10345              		.loc 1 1709 0
 10346 5860 7C261FE5 		ldr	r2, .L981+72
 10347 5864 1B16D2E5 		ldrb	r1, [r2, #1563]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10348              		.loc 1 1710 0
 10349 5868 1C26D2E5 		ldrb	r2, [r2, #1564]	@ zero_extendqisi2
 10350 586c 6FFCFFEA 		b	.L941
 10351              	.LVL1217:
 10352              	.L783:
 10353              	.LBE235:
 10354              	.LBE270:
 10355              	.LBB271:
 10356              	.LBB243:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10357              		.loc 1 1709 0
 10358 5870 8CE61FE5 		ldr	lr, .L981+72
 10359 5874 0316DEE5 		ldrb	r1, [lr, #1539]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10360              		.loc 1 1710 0
 10361 5878 0426DEE5 		ldrb	r2, [lr, #1540]	@ zero_extendqisi2
 10362 587c 6BFCFFEA 		b	.L941
 10363              	.LVL1218:
 10364              	.L761:
 10365              	.LBE243:
 10366              	.LBE271:
 10367              	.LBB272:
 10368              	.LBB226:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10369              		.loc 1 1709 0
 10370 5880 9CE61FE5 		ldr	lr, .L981+72
 10371 5884 BB15DEE5 		ldrb	r1, [lr, #1467]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10372              		.loc 1 1710 0
 10373 5888 BC25DEE5 		ldrb	r2, [lr, #1468]	@ zero_extendqisi2
 10374 588c 67FCFFEA 		b	.L941
 10375              	.LVL1219:
 10376              	.L776:
 10377              	.LBE226:
 10378              	.LBE272:
 10379              	.LBB273:
 10380              	.LBB191:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10381              		.loc 1 1736 0
 10382 5890 F135DAE5 		ldrb	r3, [r10, #1521]	@ zero_extendqisi2
 10383              	.LVL1220:
 10384              	.L946:
 10385              	.LBE191:
 10386              	.LBE273:
 10387              	.LBB274:
 10388              	.LBB200:
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10389              		.loc 1 1737 0
 10390 5894 0100A0E3 		mov	r0, #1
 10391 5898 B0161FE5 		ldr	r1, .L981+76
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10392              		.loc 1 1736 0
 10393 589c 2830CBE5 		strb	r3, [fp, #40]
1739:../uvc.c      **** 			  break;
 10394              		.loc 1 1739 0
 10395 58a0 0180A0E3 		mov	r8, #1
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10396              		.loc 1 1737 0
 10397 58a4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10398              	.LVL1221:
1738:../uvc.c      **** 			  Len = 1;
 10399              		.loc 1 1738 0
 10400 58a8 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 10401              	.LVL1222:
 10402 58ac 82FFFFEA 		b	.L835
 10403              	.LVL1223:
 10404              	.L809:
 10405              	.LBE200:
 10406              	.LBE274:
 10407              	.LBB275:
 10408              	.LBB252:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10409              		.loc 1 1736 0
 10410 58b0 CC161FE5 		ldr	r1, .L981+72
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10411              		.loc 1 1737 0
 10412 58b4 0100A0E3 		mov	r0, #1
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10413              		.loc 1 1736 0
 10414 58b8 3936D1E5 		ldrb	r3, [r1, #1593]	@ zero_extendqisi2
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10415              		.loc 1 1737 0
 10416 58bc D4161FE5 		ldr	r1, .L981+76
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10417              		.loc 1 1736 0
 10418 58c0 2830CBE5 		strb	r3, [fp, #40]
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10419              		.loc 1 1737 0
 10420 58c4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10421              	.LVL1224:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10422              		.loc 1 1674 0
 10423 58c8 FF20A0E3 		mov	r2, #255
 10424 58cc 0230A0E1 		mov	r3, r2
1738:../uvc.c      **** 			  Len = 1;
 10425              		.loc 1 1738 0
 10426 58d0 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 10427              	.LVL1225:
1739:../uvc.c      **** 			  break;
 10428              		.loc 1 1739 0
 10429 58d4 0180A0E3 		mov	r8, #1
 10430 58d8 EFFCFFEA 		b	.L811
 10431              	.LVL1226:
 10432              	.L749:
 10433              	.LBE252:
 10434              	.LBE275:
 10435              	.LBB276:
 10436              	.LBB181:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10437              		.loc 1 1736 0
 10438 58dc A935DAE5 		ldrb	r3, [r10, #1449]	@ zero_extendqisi2
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10439              		.loc 1 1674 0
 10440 58e0 FFC0A0E3 		mov	ip, #255
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10441              		.loc 1 1737 0
 10442 58e4 0100A0E3 		mov	r0, #1
 10443 58e8 00171FE5 		ldr	r1, .L981+76
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10444              		.loc 1 1736 0
 10445 58ec 2830CBE5 		strb	r3, [fp, #40]
1739:../uvc.c      **** 			  break;
 10446              		.loc 1 1739 0
 10447 58f0 0180A0E3 		mov	r8, #1
1737:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10448              		.loc 1 1737 0
 10449 58f4 1CC08DE5 		str	ip, [sp, #28]
 10450 58f8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10451              	.LVL1227:
1738:../uvc.c      **** 			  Len = 1;
 10452              		.loc 1 1738 0
 10453 58fc 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 10454              	.LVL1228:
 10455 5900 1CC09DE5 		ldr	ip, [sp, #28]
 10456 5904 8BFBFFEA 		b	.L751
 10457              	.LVL1229:
 10458              	.L787:
 10459              	.LBE181:
 10460              	.LBE276:
 10461              	.LBB277:
 10462              	.LBB244:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10463              		.loc 1 1736 0
 10464 5908 24E71FE5 		ldr	lr, .L981+72
 10465 590c 0936DEE5 		ldrb	r3, [lr, #1545]	@ zero_extendqisi2
 10466 5910 DFFFFFEA 		b	.L946
 10467              	.LVL1230:
 10468              	.L738:
 10469              	.LBE244:
 10470              	.LBE277:
 10471              	.LBB278:
 10472              	.LBB218:
 10473 5914 9135DAE5 		ldrb	r3, [r10, #1425]	@ zero_extendqisi2
 10474 5918 DDFFFFEA 		b	.L946
 10475              	.LVL1231:
 10476              	.L822:
 10477              	.LBE218:
 10478              	.LBE278:
 10479              	.LBB279:
 10480              	.LBB211:
 10481 591c 5136DAE5 		ldrb	r3, [r10, #1617]	@ zero_extendqisi2
 10482 5920 DBFFFFEA 		b	.L946
 10483              	.LVL1232:
 10484              	.L833:
 10485              	.LBE211:
 10486              	.LBE279:
 10487              	.LBB280:
 10488              	.LBB201:
 10489 5924 6936DAE5 		ldrb	r3, [r10, #1641]	@ zero_extendqisi2
 10490 5928 D9FFFFEA 		b	.L946
 10491              	.LVL1233:
 10492              	.L772:
 10493              	.LBE201:
 10494              	.LBE280:
 10495              	.LBB281:
 10496              	.LBB192:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10497              		.loc 1 1709 0
 10498 592c EB15DAE5 		ldrb	r1, [r10, #1515]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10499              		.loc 1 1710 0
 10500 5930 EC25DAE5 		ldrb	r2, [r10, #1516]	@ zero_extendqisi2
 10501 5934 3DFCFFEA 		b	.L941
 10502              	.LVL1234:
 10503              	.L745:
 10504              	.LBE192:
 10505              	.LBE281:
 10506              	.LBB282:
 10507              	.LBB182:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10508              		.loc 1 1709 0
 10509 5938 A315DAE5 		ldrb	r1, [r10, #1443]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10510              		.loc 1 1710 0
 10511 593c A425DAE5 		ldrb	r2, [r10, #1444]	@ zero_extendqisi2
 10512 5940 72FBFFEA 		b	.L932
 10513              	.LVL1235:
 10514              	.L765:
 10515              	.LBE182:
 10516              	.LBE282:
 10517              	.LBB283:
 10518              	.LBB227:
1736:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 10519              		.loc 1 1736 0
 10520 5944 60E71FE5 		ldr	lr, .L981+72
 10521 5948 C135DEE5 		ldrb	r3, [lr, #1473]	@ zero_extendqisi2
 10522 594c D0FFFFEA 		b	.L946
 10523              	.LVL1236:
 10524              	.L798:
 10525              	.LBE227:
 10526              	.LBE283:
 10527              	.LBB284:
 10528              	.LBB236:
 10529 5950 2136DAE5 		ldrb	r3, [r10, #1569]	@ zero_extendqisi2
 10530 5954 CEFFFFEA 		b	.L946
 10531              	.LVL1237:
 10532              	.L734:
 10533              	.LBE236:
 10534              	.LBE284:
 10535              	.LBB285:
 10536              	.LBB219:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10537              		.loc 1 1709 0
 10538 5958 74271FE5 		ldr	r2, .L981+72
 10539 595c 8B15D2E5 		ldrb	r1, [r2, #1419]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10540              		.loc 1 1710 0
 10541 5960 8C25D2E5 		ldrb	r2, [r2, #1420]	@ zero_extendqisi2
 10542 5964 31FCFFEA 		b	.L941
 10543              	.LVL1238:
 10544              	.L829:
 10545              	.LBE219:
 10546              	.LBE285:
 10547              	.LBB286:
 10548              	.LBB202:
1709:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 10549              		.loc 1 1709 0
 10550 5968 84271FE5 		ldr	r2, .L981+72
 10551 596c 6316D2E5 		ldrb	r1, [r2, #1635]	@ zero_extendqisi2
1710:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 10552              		.loc 1 1710 0
 10553 5970 6426D2E5 		ldrb	r2, [r2, #1636]	@ zero_extendqisi2
 10554 5974 2DFCFFEA 		b	.L941
 10555              	.LVL1239:
 10556              	.L867:
 10557              	.LBE202:
 10558              	.LBE286:
 10559              	.LBE325:
 10560              	.LBE477:
 10561              	.LBB478:
 10562              	.LBB456:
 10563              	.LBB445:
 10564              	.LBB439:
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 10565              		.loc 1 863 0
 10566 5978 BB30DBE5 		ldrb	r3, [fp, #187]	@ zero_extendqisi2
 856:../uvc.c      **** 				     RegAdd1 = pEXTSenCtrl[CtrlID - 0x10]->Reg2; //ExUCtrlParArry[locCtrlID][1];
 10567              		.loc 1 856 0
 10568 597c 3425DAE5 		ldrb	r2, [r10, #1332]	@ zero_extendqisi2
 10569              	.LVL1240:
 857:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 10570              		.loc 1 857 0
 10571 5980 3505DAE5 		ldrb	r0, [r10, #1333]	@ zero_extendqisi2
 858:../uvc.c      **** 
 10572              		.loc 1 858 0
 10573 5984 4315DAE5 		ldrb	r1, [r10, #1347]	@ zero_extendqisi2
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 10574              		.loc 1 863 0
 10575 5988 000053E3 		cmp	r3, #0
 857:../uvc.c      **** 				     devAdd = pEXTSenCtrl[CtrlID - 0x10]->DeviceAdd;
 10576              		.loc 1 857 0
 10577 598c FF0000E2 		and	r0, r0, #255
 10578              	.LVL1241:
 858:../uvc.c      **** 
 10579              		.loc 1 858 0
 10580 5990 FF1001E2 		and	r1, r1, #255
 10581              	.LVL1242:
 863:../uvc.c      **** 						 glEp0Buffer[0] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo;//ext_control array;
 10582              		.loc 1 863 0
 10583 5994 9802000A 		beq	.L875
 864:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 10584              		.loc 1 864 0
 10585 5998 B4371FE5 		ldr	r3, .L981+72
 10586 599c 4125D3E5 		ldrb	r2, [r3, #1345]	@ zero_extendqisi2
 865:../uvc.c      **** 		 	 		 }else{
 10587              		.loc 1 865 0
 10588 59a0 4235D3E5 		ldrb	r3, [r3, #1346]	@ zero_extendqisi2
 864:../uvc.c      **** 						 glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 10589              		.loc 1 864 0
 10590 59a4 2820C4E5 		strb	r2, [r4, #40]
 865:../uvc.c      **** 		 	 		 }else{
 10591              		.loc 1 865 0
 10592 59a8 2930C4E5 		strb	r3, [r4, #41]
 10593              	.LVL1243:
 10594              	.L876:
1109:../uvc.c      **** 
 10595              		.loc 1 1109 0
 10596 59ac C4171FE5 		ldr	r1, .L981+76
 872:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 10597              		.loc 1 872 0
 10598 59b0 2820DBE5 		ldrb	r2, [fp, #40]	@ zero_extendqisi2
 10599              	.LVL1244:
 873:../uvc.c      **** 			 		 break;
 10600              		.loc 1 873 0
 10601 59b4 2930DBE5 		ldrb	r3, [fp, #41]	@ zero_extendqisi2
1109:../uvc.c      **** 
 10602              		.loc 1 1109 0
 10603 59b8 0700A0E1 		mov	r0, r7
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10604              		.loc 1 753 0
 10605 59bc FF70A0E3 		mov	r7, #255
 10606              	.LVL1245:
 10607              	.L947:
1109:../uvc.c      **** 
 10608              		.loc 1 1109 0
 10609 59c0 20208DE5 		str	r2, [sp, #32]
 10610 59c4 18308DE5 		str	r3, [sp, #24]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10611              		.loc 1 753 0
 10612 59c8 0780A0E1 		mov	r8, r7
1109:../uvc.c      **** 
 10613              		.loc 1 1109 0
 10614 59cc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10615              	.LVL1246:
 10616 59d0 20209DE5 		ldr	r2, [sp, #32]
 10617 59d4 18309DE5 		ldr	r3, [sp, #24]
 10618 59d8 F4FCFFEA 		b	.L874
 10619              	.LVL1247:
 10620              	.L871:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10621              		.loc 1 1160 0
 10622 59dc 7B34DAE5 		ldrb	r3, [r10, #1147]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10623              		.loc 1 1161 0
 10624 59e0 7CC4DAE5 		ldrb	ip, [r10, #1148]	@ zero_extendqisi2
 10625              	.LVL1248:
 10626              	.L949:
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10627              		.loc 1 1162 0
 10628 59e4 0020A0E3 		mov	r2, #0
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10629              		.loc 1 1160 0
 10630 59e8 2830CBE5 		strb	r3, [fp, #40]
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10631              		.loc 1 1165 0
 10632 59ec 0700A0E1 		mov	r0, r7
 10633 59f0 08181FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10634              		.loc 1 753 0
 10635 59f4 FF30A0E3 		mov	r3, #255
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10636              		.loc 1 1161 0
 10637 59f8 29C0CBE5 		strb	ip, [fp, #41]
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10638              		.loc 1 1162 0
 10639 59fc 2A20CBE5 		strb	r2, [fp, #42]
1163:../uvc.c      **** 		 	 }
 10640              		.loc 1 1163 0
 10641 5a00 2B20CBE5 		strb	r2, [fp, #43]
 10642 5a04 E3FCFFEA 		b	.L944
 10643              	.L864:
1651:../uvc.c      **** 			  break;
 10644              		.loc 1 1651 0
 10645 5a08 0000A0E3 		mov	r0, #0
 10646 5a0c 0020A0E1 		mov	r2, r0
 10647 5a10 0110A0E3 		mov	r1, #1
 10648 5a14 FEFFFFEB 		bl	CyU3PUsbStall
 10649              	.LVL1249:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10650              		.loc 1 753 0
 10651 5a18 FF30A0E3 		mov	r3, #255
 10652 5a1c 0320A0E1 		mov	r2, r3
 10653 5a20 0370A0E1 		mov	r7, r3
 10654 5a24 0380A0E1 		mov	r8, r3
 10655 5a28 E0FCFFEA 		b	.L874
 10656              	.LVL1250:
 10657              	.L646:
 10658              	.LBE439:
 10659              	.LBE445:
 10660              	.LBE456:
 10661              	.LBE478:
 10662              	.LBB479:
 10663              	.LBB430:
 10664              	.LBB399:
 10665              	.LBB336:
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10666              		.loc 1 770 0
 10667 5a2c 0030A0E3 		mov	r3, #0
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10668              		.loc 1 771 0
 10669 5a30 0200A0E3 		mov	r0, #2
 10670 5a34 4C181FE5 		ldr	r1, .L981+76
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10671              		.loc 1 769 0
 10672 5a38 2870CBE5 		strb	r7, [fp, #40]
 10673 5a3c 6FFAFFEA 		b	.L919
 10674              	.LVL1251:
 10675              	.L693:
 10676              	.LBE336:
 10677              	.LBE399:
 10678              	.LBB400:
 10679              	.LBB347:
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10680              		.loc 1 770 0
 10681 5a40 0020A0E3 		mov	r2, #0
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10682              		.loc 1 771 0
 10683 5a44 0200A0E3 		mov	r0, #2
 10684 5a48 60181FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10685              		.loc 1 753 0
 10686 5a4c FF30A0E3 		mov	r3, #255
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10687              		.loc 1 769 0
 10688 5a50 2870CBE5 		strb	r7, [fp, #40]
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10689              		.loc 1 770 0
 10690 5a54 2920CBE5 		strb	r2, [fp, #41]
 10691 5a58 CEFCFFEA 		b	.L944
 10692              	.L690:
 986:../uvc.c      **** 						 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 10693              		.loc 1 986 0
 10694 5a5c AB20DBE5 		ldrb	r2, [fp, #171]	@ zero_extendqisi2
 10695 5a60 000052E3 		cmp	r2, #0
 10696 5a64 5402000A 		beq	.L698
 987:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 10697              		.loc 1 987 0
 10698 5a68 5C25DAE5 		ldrb	r2, [r10, #1372]	@ zero_extendqisi2
 988:../uvc.c      **** 		 	 		 }else{
 10699              		.loc 1 988 0
 10700 5a6c 5E35DAE5 		ldrb	r3, [r10, #1374]	@ zero_extendqisi2
 987:../uvc.c      **** 						 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 10701              		.loc 1 987 0
 10702 5a70 2820C4E5 		strb	r2, [r4, #40]
 988:../uvc.c      **** 		 	 		 }else{
 10703              		.loc 1 988 0
 10704 5a74 2A30C4E5 		strb	r3, [r4, #42]
 10705              	.LVL1252:
 10706              	.L699:
 998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10707              		.loc 1 998 0
 10708 5a78 0030A0E3 		mov	r3, #0
1109:../uvc.c      **** 
 10709              		.loc 1 1109 0
 10710 5a7c 0700A0E1 		mov	r0, r7
 998:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 10711              		.loc 1 998 0
 10712 5a80 2930CBE5 		strb	r3, [fp, #41]
 999:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 10713              		.loc 1 999 0
 10714 5a84 2B30CBE5 		strb	r3, [fp, #43]
1109:../uvc.c      **** 
 10715              		.loc 1 1109 0
 10716 5a88 A0181FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10717              		.loc 1 753 0
 10718 5a8c FF70A0E3 		mov	r7, #255
 10719              	.LVL1253:
1000:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 10720              		.loc 1 1000 0
 10721 5a90 2820DBE5 		ldrb	r2, [fp, #40]	@ zero_extendqisi2
 10722              	.LVL1254:
1001:../uvc.c      **** 					 break;
 10723              		.loc 1 1001 0
 10724 5a94 2A30DBE5 		ldrb	r3, [fp, #42]	@ zero_extendqisi2
 10725              	.LVL1255:
 10726 5a98 C8FFFFEA 		b	.L947
 10727              	.LVL1256:
 10728              	.L704:
 10729              	.LBE347:
 10730              	.LBE400:
 10731              	.LBB401:
 10732              	.LBB378:
1093:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 10733              		.loc 1 1093 0
 10734 5a9c AE20DBE5 		ldrb	r2, [fp, #174]	@ zero_extendqisi2
 10735 5aa0 000052E3 		cmp	r2, #0
 10736 5aa4 3A02000A 		beq	.L712
1094:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 10737              		.loc 1 1094 0
 10738 5aa8 4923DAE5 		ldrb	r2, [r10, #841]	@ zero_extendqisi2
1095:../uvc.c      **** 		 	 		 }else{
 10739              		.loc 1 1095 0
 10740 5aac 4A33DAE5 		ldrb	r3, [r10, #842]	@ zero_extendqisi2
1094:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 10741              		.loc 1 1094 0
 10742 5ab0 2820CBE5 		strb	r2, [fp, #40]
1095:../uvc.c      **** 		 	 		 }else{
 10743              		.loc 1 1095 0
 10744 5ab4 2930CBE5 		strb	r3, [fp, #41]
 10745              	.LVL1257:
 10746              	.L713:
1102:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 10747              		.loc 1 1102 0
 10748 5ab8 2820DBE5 		ldrb	r2, [fp, #40]	@ zero_extendqisi2
 10749              	.LVL1258:
1103:../uvc.c      **** 
 10750              		.loc 1 1103 0
 10751 5abc 2930DBE5 		ldrb	r3, [fp, #41]	@ zero_extendqisi2
 10752              	.LVL1259:
1109:../uvc.c      **** 
 10753              		.loc 1 1109 0
 10754 5ac0 0700A0E1 		mov	r0, r7
 10755 5ac4 DC181FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10756              		.loc 1 753 0
 10757 5ac8 FF80A0E3 		mov	r8, #255
1109:../uvc.c      **** 
 10758              		.loc 1 1109 0
 10759 5acc 20208DE5 		str	r2, [sp, #32]
 10760 5ad0 18308DE5 		str	r3, [sp, #24]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10761              		.loc 1 753 0
 10762 5ad4 0870A0E1 		mov	r7, r8
1109:../uvc.c      **** 
 10763              		.loc 1 1109 0
 10764 5ad8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10765              	.LVL1260:
 10766 5adc 20209DE5 		ldr	r2, [sp, #32]
 10767 5ae0 18309DE5 		ldr	r3, [sp, #24]
 10768 5ae4 14FFFFEA 		b	.L711
 10769              	.LVL1261:
 10770              	.L661:
 10771              	.LBE378:
 10772              	.LBE401:
 10773              	.LBB402:
 10774              	.LBB356:
1021:../uvc.c      **** 						 glEp0Buffer[0] = pPUCSenCtrl[CtrlID]->UVCCurVLo;//ext_control array;
 10775              		.loc 1 1021 0
 10776 5ae8 A730DBE5 		ldrb	r3, [fp, #167]	@ zero_extendqisi2
 10777 5aec 000053E3 		cmp	r3, #0
 10778 5af0 1F02000A 		beq	.L669
1022:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10779              		.loc 1 1022 0
 10780 5af4 8125DAE5 		ldrb	r2, [r10, #1409]	@ zero_extendqisi2
1023:../uvc.c      **** 		 	 		 }else{
 10781              		.loc 1 1023 0
 10782 5af8 8235DAE5 		ldrb	r3, [r10, #1410]	@ zero_extendqisi2
1022:../uvc.c      **** 						 glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 10783              		.loc 1 1022 0
 10784 5afc 2820CBE5 		strb	r2, [fp, #40]
1023:../uvc.c      **** 		 	 		 }else{
 10785              		.loc 1 1023 0
 10786 5b00 2930CBE5 		strb	r3, [fp, #41]
 10787              	.LVL1262:
 10788              	.L670:
1030:../uvc.c      **** 					 sendData1 = glEp0Buffer[1];
 10789              		.loc 1 1030 0
 10790 5b04 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 10791              	.LVL1263:
1109:../uvc.c      **** 
 10792              		.loc 1 1109 0
 10793 5b08 0700A0E1 		mov	r0, r7
 10794 5b0c 24191FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10795              		.loc 1 753 0
 10796 5b10 FF70A0E3 		mov	r7, #255
 10797              	.LVL1264:
1031:../uvc.c      **** 					 break;
 10798              		.loc 1 1031 0
 10799 5b14 2980DBE5 		ldrb	r8, [fp, #41]	@ zero_extendqisi2
 10800              	.LVL1265:
1109:../uvc.c      **** 
 10801              		.loc 1 1109 0
 10802 5b18 18308DE5 		str	r3, [sp, #24]
 10803 5b1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10804              	.LVL1266:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10805              		.loc 1 753 0
 10806 5b20 07C0A0E1 		mov	ip, r7
 10807 5b24 18309DE5 		ldr	r3, [sp, #24]
 10808 5b28 2DFDFFEA 		b	.L668
 10809              	.LVL1267:
 10810              	.L640:
 10811              	.LBE356:
 10812              	.LBE402:
 10813              	.LBB403:
 10814              	.LBB337:
1651:../uvc.c      **** 			  break;
 10815              		.loc 1 1651 0
 10816 5b2c 0000A0E3 		mov	r0, #0
 10817 5b30 0020A0E1 		mov	r2, r0
 10818 5b34 0110A0E3 		mov	r1, #1
 10819 5b38 FEFFFFEB 		bl	CyU3PUsbStall
 10820              	.LVL1268:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10821              		.loc 1 753 0
 10822 5b3c FF30A0E3 		mov	r3, #255
 10823 5b40 0370A0E1 		mov	r7, r3
 10824              	.LVL1269:
 10825 5b44 0380A0E1 		mov	r8, r3
 10826 5b48 8AFDFFEA 		b	.L650
 10827              	.LVL1270:
 10828              	.L647:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10829              		.loc 1 1160 0
 10830 5b4c 0B12DAE5 		ldrb	r1, [r10, #523]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10831              		.loc 1 1161 0
 10832 5b50 0C22DAE5 		ldrb	r2, [r10, #524]	@ zero_extendqisi2
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10833              		.loc 1 1162 0
 10834 5b54 0030A0E3 		mov	r3, #0
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10835              		.loc 1 1165 0
 10836 5b58 0700A0E1 		mov	r0, r7
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10837              		.loc 1 1160 0
 10838 5b5c 2810CBE5 		strb	r1, [fp, #40]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10839              		.loc 1 753 0
 10840 5b60 FF70A0E3 		mov	r7, #255
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10841              		.loc 1 1165 0
 10842 5b64 7C191FE5 		ldr	r1, .L981+76
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10843              		.loc 1 1162 0
 10844 5b68 2A30CBE5 		strb	r3, [fp, #42]
1163:../uvc.c      **** 		 	 }
 10845              		.loc 1 1163 0
 10846 5b6c 2B30CBE5 		strb	r3, [fp, #43]
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10847              		.loc 1 1161 0
 10848 5b70 2920CBE5 		strb	r2, [fp, #41]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10849              		.loc 1 753 0
 10850 5b74 0780A0E1 		mov	r8, r7
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10851              		.loc 1 1165 0
 10852 5b78 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10853              	.LVL1271:
1166:../uvc.c      **** 			  break;
 10854              		.loc 1 1166 0
 10855 5b7c 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 10856              	.LVL1272:
 10857 5b80 7CFDFFEA 		b	.L650
 10858              	.LVL1273:
 10859              	.L665:
 10860              	.LBE337:
 10861              	.LBE403:
 10862              	.LBB404:
 10863              	.LBB357:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10864              		.loc 1 1160 0
 10865 5b84 9BC2DAE5 		ldrb	ip, [r10, #667]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10866              		.loc 1 1161 0
 10867 5b88 9C22DAE5 		ldrb	r2, [r10, #668]	@ zero_extendqisi2
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10868              		.loc 1 1162 0
 10869 5b8c 0030A0E3 		mov	r3, #0
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10870              		.loc 1 1165 0
 10871 5b90 0700A0E1 		mov	r0, r7
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10872              		.loc 1 753 0
 10873 5b94 FF80A0E3 		mov	r8, #255
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10874              		.loc 1 1165 0
 10875 5b98 B0191FE5 		ldr	r1, .L981+76
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10876              		.loc 1 1160 0
 10877 5b9c 28C0CBE5 		strb	ip, [fp, #40]
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10878              		.loc 1 1162 0
 10879 5ba0 2A30CBE5 		strb	r3, [fp, #42]
1163:../uvc.c      **** 		 	 }
 10880              		.loc 1 1163 0
 10881 5ba4 2B30CBE5 		strb	r3, [fp, #43]
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10882              		.loc 1 1161 0
 10883 5ba8 2920CBE5 		strb	r2, [fp, #41]
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10884              		.loc 1 753 0
 10885 5bac 0870A0E1 		mov	r7, r8
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10886              		.loc 1 1165 0
 10887 5bb0 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 10888              	.LVL1274:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10889              		.loc 1 753 0
 10890 5bb4 08C0A0E1 		mov	ip, r8
1166:../uvc.c      **** 			  break;
 10891              		.loc 1 1166 0
 10892 5bb8 2830DBE5 		ldrb	r3, [fp, #40]	@ zero_extendqisi2
 10893              	.LVL1275:
 10894 5bbc 08FDFFEA 		b	.L668
 10895              	.LVL1276:
 10896              	.L664:
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 10897              		.loc 1 770 0
 10898 5bc0 0030A0E3 		mov	r3, #0
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10899              		.loc 1 771 0
 10900 5bc4 0200A0E3 		mov	r0, #2
 10901 5bc8 E0191FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10902              		.loc 1 753 0
 10903 5bcc FF80A0E3 		mov	r8, #255
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 10904              		.loc 1 769 0
 10905 5bd0 2870CBE5 		strb	r7, [fp, #40]
 10906 5bd4 12FBFFEA 		b	.L921
 10907              	.LVL1277:
 10908              	.L708:
 10909              	.LBE357:
 10910              	.LBE404:
 10911              	.LBB405:
 10912              	.LBB379:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10913              		.loc 1 1160 0
 10914 5bd8 4333DAE5 		ldrb	r3, [r10, #835]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10915              		.loc 1 1161 0
 10916 5bdc 44C3DAE5 		ldrb	ip, [r10, #836]	@ zero_extendqisi2
 10917              	.LVL1278:
 10918              	.L948:
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10919              		.loc 1 1162 0
 10920 5be0 0020A0E3 		mov	r2, #0
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 10921              		.loc 1 1160 0
 10922 5be4 2830CBE5 		strb	r3, [fp, #40]
1165:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 10923              		.loc 1 1165 0
 10924 5be8 0700A0E1 		mov	r0, r7
 10925 5bec 041A1FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 10926              		.loc 1 753 0
 10927 5bf0 FF30A0E3 		mov	r3, #255
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 10928              		.loc 1 1161 0
 10929 5bf4 29C0CBE5 		strb	ip, [fp, #41]
1162:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 10930              		.loc 1 1162 0
 10931 5bf8 2A20CBE5 		strb	r2, [fp, #42]
1163:../uvc.c      **** 		 	 }
 10932              		.loc 1 1163 0
 10933 5bfc 2B20CBE5 		strb	r2, [fp, #43]
 10934 5c00 C7FEFFEA 		b	.L930
 10935              	.LVL1279:
 10936              	.L641:
 10937              	.LBE379:
 10938              	.LBE405:
 10939              	.LBB406:
 10940              	.LBB338:
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 10941              		.loc 1 1146 0
 10942 5c04 201A1FE5 		ldr	r1, .L981+72
 10943 5c08 0922D1E5 		ldrb	r2, [r1, #521]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 10944              		.loc 1 1147 0
 10945 5c0c 0A32D1E5 		ldrb	r3, [r1, #522]	@ zero_extendqisi2
 10946 5c10 F7F9FFEA 		b	.L920
 10947              	.LVL1280:
 10948              	.L674:
 10949              	.LBE338:
 10950              	.LBE406:
 10951              	.LBB407:
 10952              	.LBB368:
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 10953              		.loc 1 1146 0
 10954 5c14 301A1FE5 		ldr	r1, .L981+72
 10955 5c18 C9C2D1E5 		ldrb	ip, [r1, #713]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 10956              		.loc 1 1147 0
 10957 5c1c CA22D1E5 		ldrb	r2, [r1, #714]	@ zero_extendqisi2
 10958 5c20 50FBFFEA 		b	.L929
 10959              	.LVL1281:
 10960              	.L659:
 10961              	.LBE368:
 10962              	.LBE407:
 10963              	.LBB408:
 10964              	.LBB358:
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 10965              		.loc 1 1146 0
 10966 5c24 403A1FE5 		ldr	r3, .L981+72
 10967 5c28 9922D3E5 		ldrb	r2, [r3, #665]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 10968              		.loc 1 1147 0
 10969 5c2c 9A32D3E5 		ldrb	r3, [r3, #666]	@ zero_extendqisi2
 10970 5c30 F7FAFFEA 		b	.L922
 10971              	.LVL1282:
 10972              	.L702:
 10973              	.LBE358:
 10974              	.LBE408:
 10975              	.LBB409:
 10976              	.LBB380:
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 10977              		.loc 1 1146 0
 10978 5c34 502A1FE5 		ldr	r2, .L981+72
 10979 5c38 41C3D2E5 		ldrb	ip, [r2, #833]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 10980              		.loc 1 1147 0
 10981 5c3c 4223D2E5 		ldrb	r2, [r2, #834]	@ zero_extendqisi2
 10982 5c40 48FBFFEA 		b	.L929
 10983              	.LVL1283:
 10984              	.L688:
 10985              	.LBE380:
 10986              	.LBE409:
 10987              	.LBB410:
 10988              	.LBB348:
1140:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 10989              		.loc 1 1140 0
 10990 5c44 682A1FE5 		ldr	r2, .L981+64
 10991 5c48 E9FEFFEA 		b	.L927
 10992              	.LVL1284:
 10993              	.L676:
 10994              	.LBE348:
 10995              	.LBE410:
 10996              	.LBB411:
 10997              	.LBB369:
1051:../uvc.c      **** 						 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//ext_control array;
 10998              		.loc 1 1051 0
 10999 5c4c A920DBE5 		ldrb	r2, [fp, #169]	@ zero_extendqisi2
 11000 5c50 000052E3 		cmp	r2, #0
 11001 5c54 B901000A 		beq	.L684
1053:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 11002              		.loc 1 1053 0
 11003 5c58 74EA1FE5 		ldr	lr, .L981+72
 11004 5c5c D122DEE5 		ldrb	r2, [lr, #721]	@ zero_extendqisi2
1054:../uvc.c      **** 		 	 		 }else{
 11005              		.loc 1 1054 0
 11006 5c60 D232DEE5 		ldrb	r3, [lr, #722]	@ zero_extendqisi2
1053:../uvc.c      **** 						 glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 11007              		.loc 1 1053 0
 11008 5c64 032002E2 		and	r2, r2, #3
 11009 5c68 2820C4E5 		strb	r2, [r4, #40]
1054:../uvc.c      **** 		 	 		 }else{
 11010              		.loc 1 1054 0
 11011 5c6c 2930C4E5 		strb	r3, [r4, #41]
 11012 5c70 90FFFFEA 		b	.L713
 11013              	.LVL1285:
 11014              	.L694:
 11015              	.LBE369:
 11016              	.LBE411:
 11017              	.LBB412:
 11018              	.LBB349:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11019              		.loc 1 1160 0
 11020 5c74 FB32DAE5 		ldrb	r3, [r10, #763]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11021              		.loc 1 1161 0
 11022 5c78 FCC2DAE5 		ldrb	ip, [r10, #764]	@ zero_extendqisi2
 11023 5c7c 58FFFFEA 		b	.L949
 11024              	.LVL1286:
 11025              	.L680:
 11026              	.LBE349:
 11027              	.LBE412:
 11028              	.LBB413:
 11029              	.LBB370:
1160:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 11030              		.loc 1 1160 0
 11031 5c80 9C2A1FE5 		ldr	r2, .L981+72
 11032 5c84 CB32D2E5 		ldrb	r3, [r2, #715]	@ zero_extendqisi2
1161:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 11033              		.loc 1 1161 0
 11034 5c88 CCC2D2E5 		ldrb	ip, [r2, #716]	@ zero_extendqisi2
 11035 5c8c D3FFFFEA 		b	.L948
 11036              	.LVL1287:
 11037              	.L658:
 11038              	.LBE370:
 11039              	.LBE413:
 11040              	.LBB414:
 11041              	.LBB359:
1651:../uvc.c      **** 			  break;
 11042              		.loc 1 1651 0
 11043 5c90 0000A0E3 		mov	r0, #0
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11044              		.loc 1 753 0
 11045 5c94 FF80A0E3 		mov	r8, #255
1651:../uvc.c      **** 			  break;
 11046              		.loc 1 1651 0
 11047 5c98 0020A0E1 		mov	r2, r0
 11048 5c9c 0110A0E3 		mov	r1, #1
 11049 5ca0 FEFFFFEB 		bl	CyU3PUsbStall
 11050              	.LVL1288:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11051              		.loc 1 753 0
 11052 5ca4 0870A0E1 		mov	r7, r8
 11053              	.LVL1289:
 11054 5ca8 0830A0E1 		mov	r3, r8
 11055 5cac 08C0A0E1 		mov	ip, r8
 11056 5cb0 CBFCFFEA 		b	.L668
 11057              	.LVL1290:
 11058              	.L643:
 11059              	.LBE359:
 11060              	.LBE414:
 11061              	.LBB415:
 11062              	.LBB339:
 951:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 11063              		.loc 1 951 0
 11064 5cb4 A120DBE5 		ldrb	r2, [fp, #161]	@ zero_extendqisi2
 11065 5cb8 000052E3 		cmp	r2, #0
 952:../uvc.c      **** 		 	 		 }else{
 11066              		.loc 1 952 0
 11067 5cbc 1102DA15 		ldrneb	r0, [r10, #529]	@ zero_extendqisi2
 951:../uvc.c      **** 		 	 			Data0 = CtrlParArry[CtrlID][13];
 11068              		.loc 1 951 0
 11069 5cc0 9801000A 		beq	.L980
 11070              	.LVL1291:
 11071              	.L652:
 959:../uvc.c      **** 						  Data0 = ~Data0;
 11072              		.loc 1 959 0
 11073 5cc4 800010E3 		tst	r0, #128
 960:../uvc.c      **** 					  }else{
 11074              		.loc 1 960 0
 11075 5cc8 0030E011 		mvnne	r3, r0
 962:../uvc.c      **** 					  }
 11076              		.loc 1 962 0
 11077 5ccc 80304002 		subeq	r3, r0, #128
 11078 5cd0 FF3003E2 		and	r3, r3, #255
 11079              	.LVL1292:
1109:../uvc.c      **** 
 11080              		.loc 1 1109 0
 11081 5cd4 0700A0E1 		mov	r0, r7
 965:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11082              		.loc 1 965 0
 11083 5cd8 0020A0E3 		mov	r2, #0
1109:../uvc.c      **** 
 11084              		.loc 1 1109 0
 11085 5cdc F41A1FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11086              		.loc 1 753 0
 11087 5ce0 FF70A0E3 		mov	r7, #255
 11088              	.LVL1293:
 964:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 11089              		.loc 1 964 0
 11090 5ce4 2830CBE5 		strb	r3, [fp, #40]
 965:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11091              		.loc 1 965 0
 11092 5ce8 2920CBE5 		strb	r2, [fp, #41]
 11093              	.LVL1294:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11094              		.loc 1 753 0
 11095 5cec 0780A0E1 		mov	r8, r7
1109:../uvc.c      **** 
 11096              		.loc 1 1109 0
 11097 5cf0 18308DE5 		str	r3, [sp, #24]
 11098 5cf4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11099              	.LVL1295:
 11100 5cf8 18309DE5 		ldr	r3, [sp, #24]
 11101 5cfc 1DFDFFEA 		b	.L650
 11102              	.LVL1296:
 11103              	.L760:
 11104              	.LBE339:
 11105              	.LBE415:
 11106              	.LBE430:
 11107              	.LBE479:
 11108              	.LBB480:
 11109              	.LBB326:
 11110              	.LBB287:
 11111              	.LBB228:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11112              		.loc 1 1694 0
 11113 5d00 1C3B1FE5 		ldr	r3, .L981+72
 11114 5d04 C575D3E5 		ldrb	r7, [r3, #1477]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11115              		.loc 1 1695 0
 11116 5d08 C625D3E5 		ldrb	r2, [r3, #1478]	@ zero_extendqisi2
 11117              	.LVL1297:
 11118              	.L945:
 11119              	.LBE228:
 11120              	.LBE287:
 11121              	.LBB288:
 11122              	.LBB203:
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11123              		.loc 1 1696 0
 11124 5d0c 0030A0E3 		mov	r3, #0
1702:../uvc.c      **** 
 11125              		.loc 1 1702 0
 11126 5d10 0800A0E1 		mov	r0, r8
 11127 5d14 2C1B1FE5 		ldr	r1, .L981+76
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11128              		.loc 1 1694 0
 11129 5d18 2870CBE5 		strb	r7, [fp, #40]
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11130              		.loc 1 1695 0
 11131 5d1c 2920CBE5 		strb	r2, [fp, #41]
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11132              		.loc 1 1696 0
 11133 5d20 2A30CBE5 		strb	r3, [fp, #42]
1697:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11134              		.loc 1 1697 0
 11135 5d24 2B30CBE5 		strb	r3, [fp, #43]
 11136              	.LVL1298:
1702:../uvc.c      **** 
 11137              		.loc 1 1702 0
 11138 5d28 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11139              	.LVL1299:
 11140 5d2c 62FEFFEA 		b	.L835
 11141              	.LVL1300:
 11142              	.L782:
 11143              	.LBE203:
 11144              	.LBE288:
 11145              	.LBB289:
 11146              	.LBB245:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11147              		.loc 1 1694 0
 11148 5d30 4C3B1FE5 		ldr	r3, .L981+72
 11149 5d34 0D76D3E5 		ldrb	r7, [r3, #1549]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11150              		.loc 1 1695 0
 11151 5d38 0E26D3E5 		ldrb	r2, [r3, #1550]	@ zero_extendqisi2
 11152 5d3c F2FFFFEA 		b	.L945
 11153              	.LVL1301:
 11154              	.L748:
 11155              	.LBE245:
 11156              	.LBE289:
 11157              	.LBB290:
 11158              	.LBB183:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11159              		.loc 1 1727 0
 11160 5d40 A715DAE5 		ldrb	r1, [r10, #1447]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11161              		.loc 1 1728 0
 11162 5d44 A825DAE5 		ldrb	r2, [r10, #1448]	@ zero_extendqisi2
 11163 5d48 70FAFFEA 		b	.L932
 11164              	.L747:
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11165              		.loc 1 1685 0
 11166 5d4c 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11167              		.loc 1 1686 0
 11168 5d50 0200A0E3 		mov	r0, #2
 11169 5d54 6C1B1FE5 		ldr	r1, .L981+76
1684:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11170              		.loc 1 1684 0
 11171 5d58 2880CBE5 		strb	r8, [fp, #40]
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11172              		.loc 1 1685 0
 11173 5d5c 2930CBE5 		strb	r3, [fp, #41]
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11174              		.loc 1 1686 0
 11175 5d60 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11176              	.LVL1302:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11177              		.loc 1 1674 0
 11178 5d64 FFC0A0E3 		mov	ip, #255
1687:../uvc.c      **** 			  break;
 11179              		.loc 1 1687 0
 11180 5d68 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 11181              	.LVL1303:
 11182 5d6c 71FAFFEA 		b	.L751
 11183              	.LVL1304:
 11184              	.L775:
 11185              	.LBE183:
 11186              	.LBE290:
 11187              	.LBB291:
 11188              	.LBB193:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11189              		.loc 1 1727 0
 11190 5d70 EF15DAE5 		ldrb	r1, [r10, #1519]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11191              		.loc 1 1728 0
 11192 5d74 F025DAE5 		ldrb	r2, [r10, #1520]	@ zero_extendqisi2
 11193 5d78 2CFBFFEA 		b	.L941
 11194              	.LVL1305:
 11195              	.L741:
 11196              	.LBE193:
 11197              	.LBE291:
 11198              	.LBB292:
 11199              	.LBB184:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11200              		.loc 1 1887 0
 11201 5d7c 0000A0E3 		mov	r0, #0
 11202 5d80 0020A0E1 		mov	r2, r0
 11203 5d84 0110A0E3 		mov	r1, #1
 11204 5d88 FEFFFFEB 		bl	CyU3PUsbStall
 11205              	.LVL1306:
1888:../uvc.c      **** 			  break;
 11206              		.loc 1 1888 0
 11207 5d8c 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 11208 5d90 0400A0E3 		mov	r0, #4
 11209 5d94 B41B1FE5 		ldr	r1, .L981+68
 11210 5d98 0120A0E3 		mov	r2, #1
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11211              		.loc 1 1674 0
 11212 5d9c FF70A0E3 		mov	r7, #255
1888:../uvc.c      **** 			  break;
 11213              		.loc 1 1888 0
 11214 5da0 FEFFFFEB 		bl	CyU3PDebugPrint
 11215              	.LVL1307:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11216              		.loc 1 1674 0
 11217 5da4 07C0A0E1 		mov	ip, r7
 11218 5da8 62FAFFEA 		b	.L751
 11219              	.LVL1308:
 11220              	.L817:
 11221              	.LBE184:
 11222              	.LBE292:
 11223              	.LBB293:
 11224              	.LBB212:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11225              		.loc 1 1694 0
 11226 5dac 5576DAE5 		ldrb	r7, [r10, #1621]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11227              		.loc 1 1695 0
 11228 5db0 5626DAE5 		ldrb	r2, [r10, #1622]	@ zero_extendqisi2
 11229 5db4 D4FFFFEA 		b	.L945
 11230              	.LVL1309:
 11231              	.L832:
 11232              	.LBE212:
 11233              	.LBE293:
 11234              	.LBB294:
 11235              	.LBB204:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11236              		.loc 1 1727 0
 11237 5db8 D4EB1FE5 		ldr	lr, .L981+72
 11238 5dbc 6716DEE5 		ldrb	r1, [lr, #1639]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11239              		.loc 1 1728 0
 11240 5dc0 6826DEE5 		ldrb	r2, [lr, #1640]	@ zero_extendqisi2
 11241 5dc4 19FBFFEA 		b	.L941
 11242              	.L825:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11243              		.loc 1 1887 0
 11244 5dc8 0000A0E3 		mov	r0, #0
 11245 5dcc 0020A0E1 		mov	r2, r0
 11246 5dd0 0110A0E3 		mov	r1, #1
 11247 5dd4 FEFFFFEB 		bl	CyU3PUsbStall
 11248              	.LVL1310:
1888:../uvc.c      **** 			  break;
 11249              		.loc 1 1888 0
 11250 5dd8 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 11251 5ddc 0400A0E3 		mov	r0, #4
 11252 5de0 001C1FE5 		ldr	r1, .L981+68
 11253 5de4 0920A0E3 		mov	r2, #9
 11254 5de8 FEFFFFEB 		bl	CyU3PDebugPrint
 11255              	.LVL1311:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11256              		.loc 1 1674 0
 11257 5dec FF70A0E3 		mov	r7, #255
 11258 5df0 31FEFFEA 		b	.L835
 11259              	.LVL1312:
 11260              	.L744:
 11261              	.LBE204:
 11262              	.LBE294:
 11263              	.LBB295:
 11264              	.LBB185:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11265              		.loc 1 1694 0
 11266 5df4 102C1FE5 		ldr	r2, .L981+72
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11267              		.loc 1 1696 0
 11268 5df8 0030A0E3 		mov	r3, #0
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11269              		.loc 1 1694 0
 11270 5dfc AD75D2E5 		ldrb	r7, [r2, #1453]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11271              		.loc 1 1695 0
 11272 5e00 AE25D2E5 		ldrb	r2, [r2, #1454]	@ zero_extendqisi2
1702:../uvc.c      **** 
 11273              		.loc 1 1702 0
 11274 5e04 0800A0E1 		mov	r0, r8
 11275 5e08 201C1FE5 		ldr	r1, .L981+76
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11276              		.loc 1 1694 0
 11277 5e0c 2870CBE5 		strb	r7, [fp, #40]
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11278              		.loc 1 1695 0
 11279 5e10 2920CBE5 		strb	r2, [fp, #41]
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11280              		.loc 1 1696 0
 11281 5e14 2A30CBE5 		strb	r3, [fp, #42]
1697:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11282              		.loc 1 1697 0
 11283 5e18 2B30CBE5 		strb	r3, [fp, #43]
 11284              	.LVL1313:
1702:../uvc.c      **** 
 11285              		.loc 1 1702 0
 11286 5e1c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11287              	.LVL1314:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11288              		.loc 1 1674 0
 11289 5e20 FFC0A0E3 		mov	ip, #255
 11290 5e24 43FAFFEA 		b	.L751
 11291              	.LVL1315:
 11292              	.L764:
 11293              	.LBE185:
 11294              	.LBE295:
 11295              	.LBB296:
 11296              	.LBB229:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11297              		.loc 1 1727 0
 11298 5e28 443C1FE5 		ldr	r3, .L981+72
 11299 5e2c BF15D3E5 		ldrb	r1, [r3, #1471]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11300              		.loc 1 1728 0
 11301 5e30 C025D3E5 		ldrb	r2, [r3, #1472]	@ zero_extendqisi2
 11302 5e34 FDFAFFEA 		b	.L941
 11303              	.LVL1316:
 11304              	.L737:
 11305              	.LBE229:
 11306              	.LBE296:
 11307              	.LBB297:
 11308              	.LBB220:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11309              		.loc 1 1727 0
 11310 5e38 54EC1FE5 		ldr	lr, .L981+72
 11311 5e3c 8F15DEE5 		ldrb	r1, [lr, #1423]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11312              		.loc 1 1728 0
 11313 5e40 9025DEE5 		ldrb	r2, [lr, #1424]	@ zero_extendqisi2
 11314 5e44 F9FAFFEA 		b	.L941
 11315              	.LVL1317:
 11316              	.L801:
 11317              	.LBE220:
 11318              	.LBE297:
 11319              	.LBB298:
 11320              	.LBB253:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11321              		.loc 1 1887 0
 11322 5e48 0000A0E3 		mov	r0, #0
 11323 5e4c 0020A0E1 		mov	r2, r0
 11324 5e50 0110A0E3 		mov	r1, #1
 11325 5e54 FEFFFFEB 		bl	CyU3PUsbStall
 11326              	.LVL1318:
1888:../uvc.c      **** 			  break;
 11327              		.loc 1 1888 0
 11328 5e58 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 11329 5e5c 0720A0E3 		mov	r2, #7
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11330              		.loc 1 1674 0
 11331 5e60 FF70A0E3 		mov	r7, #255
1888:../uvc.c      **** 			  break;
 11332              		.loc 1 1888 0
 11333 5e64 0400A0E3 		mov	r0, #4
 11334 5e68 881C1FE5 		ldr	r1, .L981+68
 11335 5e6c FEFFFFEB 		bl	CyU3PDebugPrint
 11336              	.LVL1319:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11337              		.loc 1 1674 0
 11338 5e70 0720A0E1 		mov	r2, r7
 11339 5e74 0730A0E1 		mov	r3, r7
 11340 5e78 87FBFFEA 		b	.L811
 11341              	.LVL1320:
 11342              	.L828:
 11343              	.LBE253:
 11344              	.LBE298:
 11345              	.LBB299:
 11346              	.LBB205:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11347              		.loc 1 1694 0
 11348 5e7c 981C1FE5 		ldr	r1, .L981+72
 11349 5e80 6D76D1E5 		ldrb	r7, [r1, #1645]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11350              		.loc 1 1695 0
 11351 5e84 6E26D1E5 		ldrb	r2, [r1, #1646]	@ zero_extendqisi2
 11352 5e88 9FFFFFEA 		b	.L945
 11353              	.LVL1321:
 11354              	.L821:
 11355              	.LBE205:
 11356              	.LBE299:
 11357              	.LBB300:
 11358              	.LBB213:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11359              		.loc 1 1727 0
 11360 5e8c 4F16DAE5 		ldrb	r1, [r10, #1615]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11361              		.loc 1 1728 0
 11362 5e90 5026DAE5 		ldrb	r2, [r10, #1616]	@ zero_extendqisi2
 11363 5e94 E5FAFFEA 		b	.L941
 11364              	.LVL1322:
 11365              	.L808:
 11366              	.LBE213:
 11367              	.LBE300:
 11368              	.LBB301:
 11369              	.LBB254:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11370              		.loc 1 1727 0
 11371 5e98 B4EC1FE5 		ldr	lr, .L981+72
 11372 5e9c 3716DEE5 		ldrb	r1, [lr, #1591]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11373              		.loc 1 1728 0
 11374 5ea0 3826DEE5 		ldrb	r2, [lr, #1592]	@ zero_extendqisi2
 11375 5ea4 71FBFFEA 		b	.L939
 11376              	.L807:
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11377              		.loc 1 1685 0
 11378 5ea8 0030A0E3 		mov	r3, #0
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11379              		.loc 1 1686 0
 11380 5eac 0200A0E3 		mov	r0, #2
 11381 5eb0 C81C1FE5 		ldr	r1, .L981+76
1685:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11382              		.loc 1 1685 0
 11383 5eb4 2930CBE5 		strb	r3, [fp, #41]
1684:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11384              		.loc 1 1684 0
 11385 5eb8 2880CBE5 		strb	r8, [fp, #40]
1686:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11386              		.loc 1 1686 0
 11387 5ebc FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11388              	.LVL1323:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11389              		.loc 1 1674 0
 11390 5ec0 FF20A0E3 		mov	r2, #255
 11391 5ec4 0230A0E1 		mov	r3, r2
1687:../uvc.c      **** 			  break;
 11392              		.loc 1 1687 0
 11393 5ec8 2870DBE5 		ldrb	r7, [fp, #40]	@ zero_extendqisi2
 11394              	.LVL1324:
 11395 5ecc 72FBFFEA 		b	.L811
 11396              	.LVL1325:
 11397              	.L797:
 11398              	.LBE254:
 11399              	.LBE301:
 11400              	.LBB302:
 11401              	.LBB237:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11402              		.loc 1 1727 0
 11403 5ed0 ECEC1FE5 		ldr	lr, .L981+72
 11404 5ed4 1F16DEE5 		ldrb	r1, [lr, #1567]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11405              		.loc 1 1728 0
 11406 5ed8 2026DEE5 		ldrb	r2, [lr, #1568]	@ zero_extendqisi2
 11407 5edc D3FAFFEA 		b	.L941
 11408              	.LVL1326:
 11409              	.L733:
 11410              	.LBE237:
 11411              	.LBE302:
 11412              	.LBB303:
 11413              	.LBB221:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11414              		.loc 1 1694 0
 11415 5ee0 FCEC1FE5 		ldr	lr, .L981+72
 11416 5ee4 9575DEE5 		ldrb	r7, [lr, #1429]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11417              		.loc 1 1695 0
 11418 5ee8 9625DEE5 		ldrb	r2, [lr, #1430]	@ zero_extendqisi2
 11419 5eec 86FFFFEA 		b	.L945
 11420              	.LVL1327:
 11421              	.L804:
 11422              	.LBE221:
 11423              	.LBE303:
 11424              	.LBB304:
 11425              	.LBB255:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11426              		.loc 1 1694 0
 11427 5ef0 0C1D1FE5 		ldr	r1, .L981+72
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11428              		.loc 1 1696 0
 11429 5ef4 0030A0E3 		mov	r3, #0
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11430              		.loc 1 1695 0
 11431 5ef8 3E26D1E5 		ldrb	r2, [r1, #1598]	@ zero_extendqisi2
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11432              		.loc 1 1694 0
 11433 5efc 3D76D1E5 		ldrb	r7, [r1, #1597]	@ zero_extendqisi2
1702:../uvc.c      **** 
 11434              		.loc 1 1702 0
 11435 5f00 0800A0E1 		mov	r0, r8
 11436 5f04 1C1D1FE5 		ldr	r1, .L981+76
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11437              		.loc 1 1695 0
 11438 5f08 2920CBE5 		strb	r2, [fp, #41]
1696:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 11439              		.loc 1 1696 0
 11440 5f0c 2A30CBE5 		strb	r3, [fp, #42]
1697:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 11441              		.loc 1 1697 0
 11442 5f10 2B30CBE5 		strb	r3, [fp, #43]
 11443              	.LVL1328:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11444              		.loc 1 1694 0
 11445 5f14 2870CBE5 		strb	r7, [fp, #40]
1702:../uvc.c      **** 
 11446              		.loc 1 1702 0
 11447 5f18 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 11448              	.LVL1329:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11449              		.loc 1 1674 0
 11450 5f1c FF20A0E3 		mov	r2, #255
 11451 5f20 0230A0E1 		mov	r3, r2
 11452 5f24 5CFBFFEA 		b	.L811
 11453              	.LVL1330:
 11454              	.L793:
 11455              	.LBE255:
 11456              	.LBE304:
 11457              	.LBB305:
 11458              	.LBB238:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11459              		.loc 1 1694 0
 11460 5f28 441D1FE5 		ldr	r1, .L981+72
 11461 5f2c 2576D1E5 		ldrb	r7, [r1, #1573]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11462              		.loc 1 1695 0
 11463 5f30 2626D1E5 		ldrb	r2, [r1, #1574]	@ zero_extendqisi2
 11464 5f34 74FFFFEA 		b	.L945
 11465              	.LVL1331:
 11466              	.L779:
 11467              	.LBE238:
 11468              	.LBE305:
 11469              	.LBB306:
 11470              	.LBB246:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11471              		.loc 1 1887 0
 11472 5f38 0000A0E3 		mov	r0, #0
 11473 5f3c 0020A0E1 		mov	r2, r0
 11474 5f40 0110A0E3 		mov	r1, #1
 11475 5f44 FEFFFFEB 		bl	CyU3PUsbStall
 11476              	.LVL1332:
1888:../uvc.c      **** 			  break;
 11477              		.loc 1 1888 0
 11478 5f48 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 11479 5f4c 0400A0E3 		mov	r0, #4
 11480 5f50 701D1FE5 		ldr	r1, .L981+68
 11481 5f54 0520A0E3 		mov	r2, #5
 11482 5f58 FEFFFFEB 		bl	CyU3PDebugPrint
 11483              	.LVL1333:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11484              		.loc 1 1674 0
 11485 5f5c FF70A0E3 		mov	r7, #255
 11486              	.LVL1334:
 11487 5f60 D5FDFFEA 		b	.L835
 11488              	.LVL1335:
 11489              	.L786:
1727:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 11490              		.loc 1 1727 0
 11491 5f64 803D1FE5 		ldr	r3, .L981+72
 11492 5f68 0716D3E5 		ldrb	r1, [r3, #1543]	@ zero_extendqisi2
1728:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11493              		.loc 1 1728 0
 11494 5f6c 0826D3E5 		ldrb	r2, [r3, #1544]	@ zero_extendqisi2
 11495 5f70 AEFAFFEA 		b	.L941
 11496              	.LVL1336:
 11497              	.L742:
 11498              	.LBE246:
 11499              	.LBE306:
 11500              	.LBB307:
 11501              	.LBB186:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11502              		.loc 1 1718 0
 11503 5f74 903D1FE5 		ldr	r3, .L981+72
 11504 5f78 A515D3E5 		ldrb	r1, [r3, #1445]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11505              		.loc 1 1719 0
 11506 5f7c A625D3E5 		ldrb	r2, [r3, #1446]	@ zero_extendqisi2
 11507 5f80 E2F9FFEA 		b	.L932
 11508              	.LVL1337:
 11509              	.L771:
 11510              	.LBE186:
 11511              	.LBE307:
 11512              	.LBB308:
 11513              	.LBB194:
1694:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 11514              		.loc 1 1694 0
 11515 5f84 A01D1FE5 		ldr	r1, .L981+72
 11516 5f88 F575D1E5 		ldrb	r7, [r1, #1525]	@ zero_extendqisi2
1695:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 11517              		.loc 1 1695 0
 11518 5f8c F625D1E5 		ldrb	r2, [r1, #1526]	@ zero_extendqisi2
 11519 5f90 5DFFFFEA 		b	.L945
 11520              	.LVL1338:
 11521              	.L757:
 11522              	.LBE194:
 11523              	.LBE308:
 11524              	.LBB309:
 11525              	.LBB230:
1887:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 11526              		.loc 1 1887 0
 11527 5f94 0000A0E3 		mov	r0, #0
 11528 5f98 0020A0E1 		mov	r2, r0
 11529 5f9c 0110A0E3 		mov	r1, #1
 11530 5fa0 FEFFFFEB 		bl	CyU3PUsbStall
 11531              	.LVL1339:
1888:../uvc.c      **** 			  break;
 11532              		.loc 1 1888 0
 11533 5fa4 0030D7E5 		ldrb	r3, [r7]	@ zero_extendqisi2
 11534 5fa8 0400A0E3 		mov	r0, #4
 11535 5fac CC1D1FE5 		ldr	r1, .L981+68
 11536 5fb0 0220A0E3 		mov	r2, #2
 11537 5fb4 FEFFFFEB 		bl	CyU3PDebugPrint
 11538              	.LVL1340:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11539              		.loc 1 1674 0
 11540 5fb8 FF70A0E3 		mov	r7, #255
 11541              	.LVL1341:
 11542 5fbc BEFDFFEA 		b	.L835
 11543              	.LVL1342:
 11544              	.L802:
 11545              	.LBE230:
 11546              	.LBE309:
 11547              	.LBB310:
 11548              	.LBB256:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11549              		.loc 1 1718 0
 11550 5fc0 DC3D1FE5 		ldr	r3, .L981+72
 11551 5fc4 3516D3E5 		ldrb	r1, [r3, #1589]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11552              		.loc 1 1719 0
 11553 5fc8 3626D3E5 		ldrb	r2, [r3, #1590]	@ zero_extendqisi2
 11554 5fcc 27FBFFEA 		b	.L939
 11555              	.LVL1343:
 11556              	.L758:
 11557              	.LBE256:
 11558              	.LBE310:
 11559              	.LBB311:
 11560              	.LBB231:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11561              		.loc 1 1718 0
 11562 5fd0 EC2D1FE5 		ldr	r2, .L981+72
 11563 5fd4 BD15D2E5 		ldrb	r1, [r2, #1469]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11564              		.loc 1 1719 0
 11565 5fd8 BE25D2E5 		ldrb	r2, [r2, #1470]	@ zero_extendqisi2
 11566 5fdc 93FAFFEA 		b	.L941
 11567              	.LVL1344:
 11568              	.L791:
 11569              	.LBE231:
 11570              	.LBE311:
 11571              	.LBB312:
 11572              	.LBB239:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11573              		.loc 1 1718 0
 11574 5fe0 FC3D1FE5 		ldr	r3, .L981+72
 11575 5fe4 1D16D3E5 		ldrb	r1, [r3, #1565]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11576              		.loc 1 1719 0
 11577 5fe8 1E26D3E5 		ldrb	r2, [r3, #1566]	@ zero_extendqisi2
 11578 5fec 8FFAFFEA 		b	.L941
 11579              	.LVL1345:
 11580              	.L780:
 11581              	.LBE239:
 11582              	.LBE312:
 11583              	.LBB313:
 11584              	.LBB247:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11585              		.loc 1 1718 0
 11586 5ff0 0C2E1FE5 		ldr	r2, .L981+72
 11587 5ff4 0516D2E5 		ldrb	r1, [r2, #1541]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11588              		.loc 1 1719 0
 11589 5ff8 0626D2E5 		ldrb	r2, [r2, #1542]	@ zero_extendqisi2
 11590 5ffc 8BFAFFEA 		b	.L941
 11591              	.LVL1346:
 11592              	.L769:
 11593              	.LBE247:
 11594              	.LBE313:
 11595              	.LBB314:
 11596              	.LBB195:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11597              		.loc 1 1718 0
 11598 6000 1C2E1FE5 		ldr	r2, .L981+72
 11599 6004 ED15D2E5 		ldrb	r1, [r2, #1517]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11600              		.loc 1 1719 0
 11601 6008 EE25D2E5 		ldrb	r2, [r2, #1518]	@ zero_extendqisi2
 11602 600c 87FAFFEA 		b	.L941
 11603              	.LVL1347:
 11604              	.L815:
 11605              	.LBE195:
 11606              	.LBE314:
 11607              	.LBB315:
 11608              	.LBB214:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11609              		.loc 1 1718 0
 11610 6010 2CEE1FE5 		ldr	lr, .L981+72
 11611 6014 4D16DEE5 		ldrb	r1, [lr, #1613]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11612              		.loc 1 1719 0
 11613 6018 4E26DEE5 		ldrb	r2, [lr, #1614]	@ zero_extendqisi2
 11614 601c 83FAFFEA 		b	.L941
 11615              	.LVL1348:
 11616              	.L731:
 11617              	.LBE214:
 11618              	.LBE315:
 11619              	.LBB316:
 11620              	.LBB222:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11621              		.loc 1 1718 0
 11622 6020 3C3E1FE5 		ldr	r3, .L981+72
 11623 6024 8D15D3E5 		ldrb	r1, [r3, #1421]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11624              		.loc 1 1719 0
 11625 6028 8E25D3E5 		ldrb	r2, [r3, #1422]	@ zero_extendqisi2
 11626 602c 7FFAFFEA 		b	.L941
 11627              	.LVL1349:
 11628              	.L826:
 11629              	.LBE222:
 11630              	.LBE316:
 11631              	.LBB317:
 11632              	.LBB206:
1718:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 11633              		.loc 1 1718 0
 11634 6030 4C3E1FE5 		ldr	r3, .L981+72
 11635 6034 6516D3E5 		ldrb	r1, [r3, #1637]	@ zero_extendqisi2
1719:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 11636              		.loc 1 1719 0
 11637 6038 6626D3E5 		ldrb	r2, [r3, #1638]	@ zero_extendqisi2
 11638 603c 7BFAFFEA 		b	.L941
 11639              	.LVL1350:
 11640              	.L865:
 11641              	.LBE206:
 11642              	.LBE317:
 11643              	.LBE326:
 11644              	.LBE480:
 11645              	.LBB481:
 11646              	.LBB457:
 11647              	.LBB446:
 11648              	.LBB440:
1146:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 11649              		.loc 1 1146 0
 11650 6040 5C1E1FE5 		ldr	r1, .L981+72
 11651 6044 79C4D1E5 		ldrb	ip, [r1, #1145]	@ zero_extendqisi2
1147:../uvc.c      **** 			 }
 11652              		.loc 1 1147 0
 11653 6048 7A24D1E5 		ldrb	r2, [r1, #1146]	@ zero_extendqisi2
 11654 604c 4CFBFFEA 		b	.L943
 11655              	.L872:
1173:../uvc.c      **** 		 	 }
 11656              		.loc 1 1173 0
 11657 6050 7D24DAE5 		ldrb	r2, [r10, #1149]	@ zero_extendqisi2
1175:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11658              		.loc 1 1175 0
 11659 6054 0100A0E3 		mov	r0, #1
 11660 6058 701E1FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11661              		.loc 1 753 0
 11662 605c FF30A0E3 		mov	r3, #255
1173:../uvc.c      **** 		 	 }
 11663              		.loc 1 1173 0
 11664 6060 2820CBE5 		strb	r2, [fp, #40]
 11665 6064 4BFBFFEA 		b	.L944
 11666              	.L870:
 770:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 11667              		.loc 1 770 0
 11668 6068 0020A0E3 		mov	r2, #0
 771:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 11669              		.loc 1 771 0
 11670 606c 0200A0E3 		mov	r0, #2
 11671 6070 881E1FE5 		ldr	r1, .L981+76
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11672              		.loc 1 753 0
 11673 6074 FF30A0E3 		mov	r3, #255
 769:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 11674              		.loc 1 769 0
 11675 6078 2870CBE5 		strb	r7, [fp, #40]
 11676 607c 44FBFFEA 		b	.L942
 11677              	.L868:
1128:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 11678              		.loc 1 1128 0
 11679 6080 77C4DAE5 		ldrb	ip, [r10, #1143]	@ zero_extendqisi2
1129:../uvc.c      **** 			 }
 11680              		.loc 1 1129 0
 11681 6084 7824DAE5 		ldrb	r2, [r10, #1144]	@ zero_extendqisi2
 11682 6088 3DFBFFEA 		b	.L943
 11683              	.LVL1351:
 11684              	.L672:
 11685              	.LBE440:
 11686              	.LBE446:
 11687              	.LBE457:
 11688              	.LBE481:
 11689              	.LBB482:
 11690              	.LBB431:
 11691              	.LBB416:
 11692              	.LBB360:
1612:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, 0x0, dataIdx);  //First: disable sharpness.
 11693              		.loc 1 1612 0
 11694 608c A02E1FE5 		ldr	r2, .L981+80
 11695 6090 1C0092E5 		ldr	r0, [r2, #28]
 11696              	.LVL1352:
 11697 6094 1CC08DE5 		str	ip, [sp, #28]
 11698 6098 FEFFFFEB 		bl	_txe_mutex_get
 11699              	.LVL1353:
1613:../uvc.c      **** 								 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11700              		.loc 1 1613 0
 11701 609c 1CC09DE5 		ldr	ip, [sp, #28]
 11702 60a0 0830A0E1 		mov	r3, r8
 11703 60a4 00C08DE5 		str	ip, [sp]
 11704 60a8 04C08DE5 		str	ip, [sp, #4]
 11705 60ac 24209DE5 		ldr	r2, [sp, #36]
 11706 60b0 0710A0E3 		mov	r1, #7
 11707 60b4 C80E1FE5 		ldr	r0, .L981+80
 11708 60b8 FEFFFFEB 		bl	cmdSet
 11709              	.LVL1354:
1614:../uvc.c      **** 
 11710              		.loc 1 1614 0
 11711 60bc D03E1FE5 		ldr	r3, .L981+80
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11712              		.loc 1 753 0
 11713 60c0 FF80A0E3 		mov	r8, #255
 11714              	.LVL1355:
1614:../uvc.c      **** 
 11715              		.loc 1 1614 0
 11716 60c4 1C0093E5 		ldr	r0, [r3, #28]
 11717 60c8 FEFFFFEB 		bl	_txe_mutex_put
 11718              	.LVL1356:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11719              		.loc 1 753 0
 11720 60cc 0830A0E1 		mov	r3, r8
 11721 60d0 1CC09DE5 		ldr	ip, [sp, #28]
 11722 60d4 C2FBFFEA 		b	.L668
 11723              	.LVL1357:
 11724              	.L812:
 11725              	.LBE360:
 11726              	.LBE416:
 11727              	.LBE431:
 11728              	.LBE482:
 11729              	.LBB483:
 11730              	.LBB327:
 11731              	.LBB318:
 11732              	.LBB257:
1855:../uvc.c      **** 					  }
 11733              		.loc 1 1855 0
 11734 60d8 0020A0E1 		mov	r2, r0
 11735 60dc 0610A0E1 		mov	r1, r6
 11736 60e0 FEFFFFEB 		bl	CyU3PUsbStall
 11737              	.LVL1358:
 11738 60e4 E8FCFFEA 		b	.L813
 11739              	.LVL1359:
 11740              	.L880:
 11741              	.LBE257:
 11742              	.LBE318:
 11743              	.LBE327:
 11744              	.LBE483:
 11745              	.LBB484:
 11746              	.LBB458:
 11747              	.LBB447:
 11748              	.LBB441:
1320:../uvc.c      **** 									 dataIdx++;
 11749              		.loc 1 1320 0
 11750 60e8 8010A0E3 		mov	r1, #128
 11751 60ec 0030A0E3 		mov	r3, #0
 11752 60f0 0A008DE8 		stmia	sp, {r1, r3}
 11753 60f4 080F1FE5 		ldr	r0, .L981+80
 11754 60f8 28309DE5 		ldr	r3, [sp, #40]
 11755 60fc 1B10A0E3 		mov	r1, #27
 11756 6100 FEFFFFEB 		bl	cmdSet
 11757              	.LVL1360:
1322:../uvc.c      **** 								 }
 11758              		.loc 1 1322 0
 11759 6104 0110A0E3 		mov	r1, #1
 11760 6108 04108DE5 		str	r1, [sp, #4]
 11761 610c 00808DE5 		str	r8, [sp]
 11762 6110 2C209DE5 		ldr	r2, [sp, #44]
 11763 6114 28309DE5 		ldr	r3, [sp, #40]
 11764 6118 1B10A0E3 		mov	r1, #27
 11765 611c 300F1FE5 		ldr	r0, .L981+80
 11766 6120 FEFFFFEB 		bl	cmdSet
 11767              	.LVL1361:
 11768 6124 4EFDFFEA 		b	.L879
 11769              	.LVL1362:
 11770              	.L756:
 11771              	.LBE441:
 11772              	.LBE447:
 11773              	.LBE458:
 11774              	.LBE484:
 11775              	.LBB485:
 11776              	.LBB328:
 11777              	.LBB319:
 11778              	.LBB187:
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11779              		.loc 1 1785 0
 11780 6128 3C7F1FE5 		ldr	r7, .L981+80
1783:../uvc.c      **** 			  		    	dataIdx = 0;
 11781              		.loc 1 1783 0
 11782 612c 0020A0E3 		mov	r2, #0
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11783              		.loc 1 1785 0
 11784 6130 1C0097E5 		ldr	r0, [r7, #28]
 11785 6134 0010E0E3 		mvn	r1, #0
 11786 6138 1CC08DE5 		str	ip, [sp, #28]
1783:../uvc.c      **** 			  		    	dataIdx = 0;
 11787              		.loc 1 1783 0
 11788 613c 7923CAE5 		strb	r2, [r10, #889]
 11789              	.LVL1363:
1785:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11790              		.loc 1 1785 0
 11791 6140 18308DE5 		str	r3, [sp, #24]
 11792 6144 FEFFFFEB 		bl	_txe_mutex_get
 11793              	.LVL1364:
1786:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11794              		.loc 1 1786 0
 11795 6148 00E0A0E3 		mov	lr, #0
 11796 614c 00E08DE5 		str	lr, [sp]
 11797 6150 04E08DE5 		str	lr, [sp, #4]
 11798 6154 24209DE5 		ldr	r2, [sp, #36]
 11799 6158 18309DE5 		ldr	r3, [sp, #24]
 11800 615c 1010A0E3 		mov	r1, #16
 11801 6160 0700A0E1 		mov	r0, r7
 11802 6164 FEFFFFEB 		bl	cmdSet
 11803              	.LVL1365:
1787:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
 11804              		.loc 1 1787 0
 11805 6168 1C0097E5 		ldr	r0, [r7, #28]
 11806 616c FEFFFFEB 		bl	_txe_mutex_put
 11807              	.LVL1366:
 11808              	.LBB172:
 11809              	.LBB173:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 11810              		.loc 1 680 0
 11811 6170 0010E0E3 		mvn	r1, #0
 11812 6174 1C0097E5 		ldr	r0, [r7, #28]
 11813 6178 FEFFFFEB 		bl	_txe_mutex_get
 11814              	.LVL1367:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 11815              		.loc 1 681 0
 11816 617c 0130A0E3 		mov	r3, #1
 11817 6180 0010A0E3 		mov	r1, #0
 11818 6184 04108DE5 		str	r1, [sp, #4]
 11819 6188 00308DE5 		str	r3, [sp]
 11820 618c 0700A0E1 		mov	r0, r7
 11821 6190 3030A0E3 		mov	r3, #48
 11822 6194 2010A0E3 		mov	r1, #32
 11823 6198 2720A0E3 		mov	r2, #39
 11824 619c FEFFFFEB 		bl	cmdSet
 11825              	.LVL1368:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11826              		.loc 1 682 0
 11827 61a0 0230A0E3 		mov	r3, #2
 11828              	.LVL1369:
 11829              	.L934:
 11830 61a4 0020A0E3 		mov	r2, #0
 11831 61a8 04208DE5 		str	r2, [sp, #4]
 11832              	.LVL1370:
 11833              	.L933:
 11834 61ac 0700A0E1 		mov	r0, r7
 11835 61b0 00308DE5 		str	r3, [sp]
 11836 61b4 2110A0E3 		mov	r1, #33
 11837 61b8 2520A0E3 		mov	r2, #37
 11838 61bc 3030A0E3 		mov	r3, #48
 11839 61c0 FEFFFFEB 		bl	cmdSet
 11840              	.LVL1371:
 683:../uvc.c      **** }
 11841              		.loc 1 683 0
 11842 61c4 1C0097E5 		ldr	r0, [r7, #28]
 11843 61c8 FEFFFFEB 		bl	_txe_mutex_put
 11844              	.LVL1372:
 11845              	.LBE173:
 11846              	.LBE172:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11847              		.loc 1 1674 0
 11848 61cc FF70A0E3 		mov	r7, #255
 11849 61d0 1CC09DE5 		ldr	ip, [sp, #28]
 11850 61d4 57F9FFEA 		b	.L751
 11851              	.LVL1373:
 11852              	.L755:
 11853              	.LBB174:
 11854              	.LBB175:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 11855              		.loc 1 680 0
 11856 61d8 EC7F1FE5 		ldr	r7, .L981+80
 11857 61dc 0010E0E3 		mvn	r1, #0
 11858 61e0 1C0097E5 		ldr	r0, [r7, #28]
 11859 61e4 1CC08DE5 		str	ip, [sp, #28]
 11860 61e8 FEFFFFEB 		bl	_txe_mutex_get
 11861              	.LVL1374:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 11862              		.loc 1 681 0
 11863 61ec 0030A0E3 		mov	r3, #0
 11864 61f0 00308DE5 		str	r3, [sp]
 11865 61f4 04308DE5 		str	r3, [sp, #4]
 11866 61f8 0700A0E1 		mov	r0, r7
 11867 61fc 3030A0E3 		mov	r3, #48
 11868 6200 2010A0E3 		mov	r1, #32
 11869 6204 2720A0E3 		mov	r2, #39
 11870 6208 FEFFFFEB 		bl	cmdSet
 11871              	.LVL1375:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11872              		.loc 1 682 0
 11873 620c 00E0A0E3 		mov	lr, #0
 11874 6210 0130A0E3 		mov	r3, #1
 11875 6214 04E08DE5 		str	lr, [sp, #4]
 11876 6218 E3FFFFEA 		b	.L933
 11877              	.LVL1376:
 11878              	.L754:
 11879              	.LBE175:
 11880              	.LBE174:
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11881              		.loc 1 1773 0
 11882 621c 38729FE5 		ldr	r7, .L983
1771:../uvc.c      **** 							dataIdx = 0;
 11883              		.loc 1 1771 0
 11884 6220 0020A0E3 		mov	r2, #0
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11885              		.loc 1 1773 0
 11886 6224 1C0097E5 		ldr	r0, [r7, #28]
 11887 6228 0010E0E3 		mvn	r1, #0
 11888 622c 1CC08DE5 		str	ip, [sp, #28]
1771:../uvc.c      **** 							dataIdx = 0;
 11889              		.loc 1 1771 0
 11890 6230 7923CAE5 		strb	r2, [r10, #889]
 11891              	.LVL1377:
1773:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 11892              		.loc 1 1773 0
 11893 6234 18308DE5 		str	r3, [sp, #24]
 11894 6238 FEFFFFEB 		bl	_txe_mutex_get
 11895              	.LVL1378:
1774:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11896              		.loc 1 1774 0
 11897 623c 00E0A0E3 		mov	lr, #0
 11898 6240 00E08DE5 		str	lr, [sp]
 11899 6244 04E08DE5 		str	lr, [sp, #4]
 11900 6248 24209DE5 		ldr	r2, [sp, #36]
 11901 624c 18309DE5 		ldr	r3, [sp, #24]
 11902 6250 1010A0E3 		mov	r1, #16
 11903 6254 0700A0E1 		mov	r0, r7
 11904 6258 FEFFFFEB 		bl	cmdSet
 11905              	.LVL1379:
1775:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 11906              		.loc 1 1775 0
 11907 625c 1C0097E5 		ldr	r0, [r7, #28]
 11908 6260 FEFFFFEB 		bl	_txe_mutex_put
 11909              	.LVL1380:
 11910              	.LBB176:
 11911              	.LBB177:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 11912              		.loc 1 680 0
 11913 6264 0010E0E3 		mvn	r1, #0
 11914 6268 1C0097E5 		ldr	r0, [r7, #28]
 11915 626c FEFFFFEB 		bl	_txe_mutex_get
 11916              	.LVL1381:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 11917              		.loc 1 681 0
 11918 6270 0010A0E3 		mov	r1, #0
 11919 6274 00108DE5 		str	r1, [sp]
 11920 6278 04108DE5 		str	r1, [sp, #4]
 11921 627c 3030A0E3 		mov	r3, #48
 11922 6280 0700A0E1 		mov	r0, r7
 11923 6284 2010A0E3 		mov	r1, #32
 11924 6288 2720A0E3 		mov	r2, #39
 11925 628c FEFFFFEB 		bl	cmdSet
 11926              	.LVL1382:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11927              		.loc 1 682 0
 11928 6290 0130A0E3 		mov	r3, #1
 11929 6294 C2FFFFEA 		b	.L934
 11930              	.LVL1383:
 11931              	.L752:
 11932              	.LBE177:
 11933              	.LBE176:
 11934              	.LBB178:
 11935              	.LBB179:
 680:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF L
 11936              		.loc 1 680 0
 11937 6298 BC719FE5 		ldr	r7, .L983
 11938 629c 0010E0E3 		mvn	r1, #0
 11939 62a0 1C0097E5 		ldr	r0, [r7, #28]
 11940 62a4 1CC08DE5 		str	ip, [sp, #28]
 11941 62a8 FEFFFFEB 		bl	_txe_mutex_get
 11942              	.LVL1384:
 681:../uvc.c      **** 	  cmdSet(cmdQuptr, 0x21/*noAFIrisMode*/, 0x25, 0x30, isAuto?1:2, dataIdx);  //set Iris Mode value 
 11943              		.loc 1 681 0
 11944 62ac 0130A0E3 		mov	r3, #1
 11945 62b0 00E0A0E3 		mov	lr, #0
 11946 62b4 00308DE5 		str	r3, [sp]
 11947 62b8 2010A0E3 		mov	r1, #32
 11948 62bc 3030A0E3 		mov	r3, #48
 11949 62c0 0700A0E1 		mov	r0, r7
 11950 62c4 04E08DE5 		str	lr, [sp, #4]
 11951 62c8 2720A0E3 		mov	r2, #39
 11952 62cc FEFFFFEB 		bl	cmdSet
 11953              	.LVL1385:
 682:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 11954              		.loc 1 682 0
 11955 62d0 0010A0E3 		mov	r1, #0
 11956 62d4 0230A0E3 		mov	r3, #2
 11957 62d8 04108DE5 		str	r1, [sp, #4]
 11958 62dc B2FFFFEA 		b	.L933
 11959              	.LVL1386:
 11960              	.L890:
 11961              	.LBE179:
 11962              	.LBE178:
1674:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11963              		.loc 1 1674 0
 11964 62e0 FF70A0E3 		mov	r7, #255
 11965 62e4 13F9FFEA 		b	.L751
 11966              	.LVL1387:
 11967              	.L877:
 11968              	.LBE187:
 11969              	.LBE319:
 11970              	.LBE328:
 11971              	.LBE485:
 11972              	.LBB486:
 11973              	.LBB459:
 11974              	.LBB448:
 11975              	.LBB442:
1643:../uvc.c      **** 			   }
 11976              		.loc 1 1643 0
 11977 62e8 0400A0E3 		mov	r0, #4
 11978 62ec 6C119FE5 		ldr	r1, .L983+4
 11979 62f0 FEFFFFEB 		bl	CyU3PDebugPrint
 11980              	.LVL1388:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 11981              		.loc 1 753 0
 11982 62f4 FF30A0E3 		mov	r3, #255
 11983 62f8 0320A0E1 		mov	r2, r3
 11984 62fc 0370A0E1 		mov	r7, r3
 11985 6300 0380A0E1 		mov	r8, r3
 11986 6304 A9FAFFEA 		b	.L874
 11987              	.L714:
 11988              	.LBE442:
 11989              	.LBE448:
 11990              	.LBE459:
 11991              	.LBE486:
 11992              	.LBB487:
 11993              	.LBB432:
 11994              	.LBB417:
 11995              	.LBB381:
1643:../uvc.c      **** 			   }
 11996              		.loc 1 1643 0
 11997 6308 0400A0E3 		mov	r0, #4
 11998 630c 4C119FE5 		ldr	r1, .L983+4
 11999 6310 FEFFFFEB 		bl	CyU3PDebugPrint
 12000              	.LVL1389:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12001              		.loc 1 753 0
 12002 6314 FF30A0E3 		mov	r3, #255
 12003 6318 0320A0E1 		mov	r2, r3
 12004 631c 0380A0E1 		mov	r8, r3
 12005 6320 0370A0E1 		mov	r7, r3
 12006 6324 04FDFFEA 		b	.L711
 12007              	.LVL1390:
 12008              	.L980:
 12009              	.LBE381:
 12010              	.LBE417:
 12011              	.LBB418:
 12012              	.LBB340:
 954:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = Data0;
 12013              		.loc 1 954 0
 12014 6328 0310A0E1 		mov	r1, r3
 12015 632c FEFFFFEB 		bl	SensorGetControl
 12016              	.LVL1391:
 956:../uvc.c      **** 		 	 		 }
 12017              		.loc 1 956 0
 12018 6330 0130A0E3 		mov	r3, #1
 12019 6334 A130CBE5 		strb	r3, [fp, #161]
 955:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12020              		.loc 1 955 0
 12021 6338 1102CAE5 		strb	r0, [r10, #529]
 12022 633c 60FEFFEA 		b	.L652
 12023              	.LVL1392:
 12024              	.L684:
 12025              	.LBE340:
 12026              	.LBE418:
 12027              	.LBB419:
 12028              	.LBB371:
1056:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 12029              		.loc 1 1056 0
 12030 6340 0310A0E1 		mov	r1, r3
 12031 6344 0C00A0E1 		mov	r0, ip
 12032 6348 FEFFFFEB 		bl	SensorGetControl
 12033              	.LVL1393:
1059:../uvc.c      **** 
 12034              		.loc 1 1059 0
 12035 634c 10119FE5 		ldr	r1, .L983+8
1057:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 12036              		.loc 1 1057 0
 12037 6350 0C319FE5 		ldr	r3, .L983+8
1059:../uvc.c      **** 
 12038              		.loc 1 1059 0
 12039 6354 D222D1E5 		ldrb	r2, [r1, #722]	@ zero_extendqisi2
 12040 6358 2920C4E5 		strb	r2, [r4, #41]
1058:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12041              		.loc 1 1058 0
 12042 635c 031000E2 		and	r1, r0, #3
1057:../uvc.c      **** 		 	 			glEp0Buffer[0] = glEp0Buffer[0] & 0x3;    // get two least Bits
 12043              		.loc 1 1057 0
 12044 6360 D102C3E5 		strb	r0, [r3, #721]
1061:../uvc.c      **** 		 	 		 }
 12045              		.loc 1 1061 0
 12046 6364 0130A0E3 		mov	r3, #1
1058:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12047              		.loc 1 1058 0
 12048 6368 2810C4E5 		strb	r1, [r4, #40]
1061:../uvc.c      **** 		 	 		 }
 12049              		.loc 1 1061 0
 12050 636c A930C4E5 		strb	r3, [r4, #169]
 12051 6370 D0FDFFEA 		b	.L713
 12052              	.LVL1394:
 12053              	.L669:
 12054              	.LBE371:
 12055              	.LBE419:
 12056              	.LBB420:
 12057              	.LBB361:
1025:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 12058              		.loc 1 1025 0
 12059 6374 FEFFFFEB 		bl	SensorGetControl
 12060              	.LVL1395:
1028:../uvc.c      **** 		 	 		 }
 12061              		.loc 1 1028 0
 12062 6378 0130A0E3 		mov	r3, #1
 12063 637c A730CBE5 		strb	r3, [fp, #167]
1026:../uvc.c      **** 		 	 			glEp0Buffer[1] = pPUCSenCtrl[CtrlID]->UVCCurVHi;
 12064              		.loc 1 1026 0
 12065 6380 8105CAE5 		strb	r0, [r10, #1409]
1027:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12066              		.loc 1 1027 0
 12067 6384 8225DAE5 		ldrb	r2, [r10, #1410]	@ zero_extendqisi2
1025:../uvc.c      **** 		 	 			pPUCSenCtrl[CtrlID]->UVCCurVLo = glEp0Buffer[0];
 12068              		.loc 1 1025 0
 12069 6388 2800CBE5 		strb	r0, [fp, #40]
1027:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12070              		.loc 1 1027 0
 12071 638c 2920CBE5 		strb	r2, [fp, #41]
 12072 6390 DBFDFFEA 		b	.L670
 12073              	.LVL1396:
 12074              	.L712:
 12075              	.LBE361:
 12076              	.LBE420:
 12077              	.LBB421:
 12078              	.LBB382:
1097:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 12079              		.loc 1 1097 0
 12080 6394 0310A0E1 		mov	r1, r3
 12081 6398 0C00A0E1 		mov	r0, ip
 12082 639c FEFFFFEB 		bl	SensorGetControl
 12083              	.LVL1397:
1099:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12084              		.loc 1 1099 0
 12085 63a0 4A23DAE5 		ldrb	r2, [r10, #842]	@ zero_extendqisi2
1100:../uvc.c      **** 		 	 		 }
 12086              		.loc 1 1100 0
 12087 63a4 0130A0E3 		mov	r3, #1
1099:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12088              		.loc 1 1099 0
 12089 63a8 2920CBE5 		strb	r2, [fp, #41]
1100:../uvc.c      **** 		 	 		 }
 12090              		.loc 1 1100 0
 12091 63ac AE30CBE5 		strb	r3, [fp, #174]
1097:../uvc.c      **** 		 	 			CtrlParArry[CtrlID][13] = glEp0Buffer[0];
 12092              		.loc 1 1097 0
 12093 63b0 2800CBE5 		strb	r0, [fp, #40]
1098:../uvc.c      **** 		 	 			glEp0Buffer[1] = CtrlParArry[CtrlID][14];
 12094              		.loc 1 1098 0
 12095 63b4 4903CAE5 		strb	r0, [r10, #841]
 12096 63b8 BEFDFFEA 		b	.L713
 12097              	.LVL1398:
 12098              	.L698:
 12099              	.LBE382:
 12100              	.LBE421:
 12101              	.LBB422:
 12102              	.LBB350:
 990:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 12103              		.loc 1 990 0
 12104 63bc 0300A0E1 		mov	r0, r3
 12105 63c0 0C10A0E1 		mov	r1, ip
 12106 63c4 1CC08DE5 		str	ip, [sp, #28]
 12107 63c8 FEFFFFEB 		bl	SensorGetControl
 12108              	.LVL1399:
 991:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 12109              		.loc 1 991 0
 12110 63cc 1CC09DE5 		ldr	ip, [sp, #28]
 12111 63d0 0C10A0E1 		mov	r1, ip
 990:../uvc.c      **** 		 	 			Data1 = SensorGetControl(RegAdd1, devAdd);
 12112              		.loc 1 990 0
 12113 63d4 0080A0E1 		mov	r8, r0
 12114              	.LVL1400:
 991:../uvc.c      **** 						glEp0Buffer[0] = Data0;
 12115              		.loc 1 991 0
 12116 63d8 24009DE5 		ldr	r0, [sp, #36]
 12117              	.LVL1401:
 12118 63dc FEFFFFEB 		bl	SensorGetControl
 12119              	.LVL1402:
 996:../uvc.c      **** 		 	 		 }
 12120              		.loc 1 996 0
 12121 63e0 0130A0E3 		mov	r3, #1
 992:../uvc.c      **** 						WBMenuCmpArry[0] = glEp0Buffer[0];//using for blue part
 12122              		.loc 1 992 0
 12123 63e4 2880C4E5 		strb	r8, [r4, #40]
 993:../uvc.c      **** 						glEp0Buffer[2] = Data1;
 12124              		.loc 1 993 0
 12125 63e8 5C85CAE5 		strb	r8, [r10, #1372]
 996:../uvc.c      **** 		 	 		 }
 12126              		.loc 1 996 0
 12127 63ec AB30C4E5 		strb	r3, [r4, #171]
 994:../uvc.c      **** 						WBMenuCmpArry[2]= glEp0Buffer[2];//using for red part
 12128              		.loc 1 994 0
 12129 63f0 2A00C4E5 		strb	r0, [r4, #42]
 995:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12130              		.loc 1 995 0
 12131 63f4 5E05CAE5 		strb	r0, [r10, #1374]
 12132 63f8 9EFDFFEA 		b	.L699
 12133              	.LVL1403:
 12134              	.L875:
 12135              	.LBE350:
 12136              	.LBE422:
 12137              	.LBE432:
 12138              	.LBE487:
 12139              	.LBB488:
 12140              	.LBB460:
 12141              	.LBB449:
 12142              	.LBB443:
 867:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12143              		.loc 1 867 0
 12144 63fc FEFFFFEB 		bl	SensorGetControl
 12145              	.LVL1404:
 868:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12146              		.loc 1 868 0
 12147 6400 5CE09FE5 		ldr	lr, .L983+8
 870:../uvc.c      **** 		 	 		 }
 12148              		.loc 1 870 0
 12149 6404 0130A0E3 		mov	r3, #1
 12150 6408 BB30C4E5 		strb	r3, [r4, #187]
 868:../uvc.c      **** 		 	 			glEp0Buffer[1] = pEXTSenCtrl[CtrlID - 0x10]->UVCCurVHi;
 12151              		.loc 1 868 0
 12152 640c 4105CEE5 		strb	r0, [lr, #1345]
 869:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12153              		.loc 1 869 0
 12154 6410 4225DEE5 		ldrb	r2, [lr, #1346]	@ zero_extendqisi2
 867:../uvc.c      **** 		 	 			pEXTSenCtrl[CtrlID - 0x10]->UVCCurVLo = glEp0Buffer[0];
 12155              		.loc 1 867 0
 12156 6414 2800C4E5 		strb	r0, [r4, #40]
 869:../uvc.c      **** 		 	 			curFlag[CtrlID] = CyTrue;
 12157              		.loc 1 869 0
 12158 6418 2920C4E5 		strb	r2, [r4, #41]
 12159 641c 62FDFFEA 		b	.L876
 12160              	.LVL1405:
 12161              	.L655:
 12162              	.LBE443:
 12163              	.LBE449:
 12164              	.LBE460:
 12165              	.LBE488:
 12166              	.LBB489:
 12167              	.LBB433:
 12168              	.LBB423:
 12169              	.LBB341:
1643:../uvc.c      **** 			   }
 12170              		.loc 1 1643 0
 12171 6420 0400A0E3 		mov	r0, #4
 12172              	.LVL1406:
 12173 6424 34109FE5 		ldr	r1, .L983+4
 12174 6428 FEFFFFEB 		bl	CyU3PDebugPrint
 12175              	.LVL1407:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12176              		.loc 1 753 0
 12177 642c FF30A0E3 		mov	r3, #255
 12178 6430 0370A0E1 		mov	r7, r3
 12179              	.LVL1408:
 12180 6434 0380A0E1 		mov	r8, r3
 12181 6438 4EFBFFEA 		b	.L650
 12182              	.LVL1409:
 12183              	.L671:
 12184              	.LBE341:
 12185              	.LBE423:
 12186              	.LBB424:
 12187              	.LBB362:
 12188 643c FF80A0E3 		mov	r8, #255
1643:../uvc.c      **** 			   }
 12189              		.loc 1 1643 0
 12190 6440 0400A0E3 		mov	r0, #4
 12191              	.LVL1410:
 12192 6444 14109FE5 		ldr	r1, .L983+4
 12193 6448 FEFFFFEB 		bl	CyU3PDebugPrint
 12194              	.LVL1411:
 753:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 12195              		.loc 1 753 0
 12196 644c 0870A0E1 		mov	r7, r8
 12197              	.LVL1412:
 12198 6450 0830A0E1 		mov	r3, r8
 12199 6454 08C0A0E1 		mov	ip, r8
 12200 6458 E1FAFFEA 		b	.L668
 12201              	.L984:
 12202              		.align	2
 12203              	.L983:
 12204 645c 00000000 		.word	cmdQu
 12205 6460 9C050000 		.word	.LC34
 12206 6464 00000000 		.word	.LANCHOR1
 12207              	.LBE362:
 12208              	.LBE424:
 12209              	.LBE433:
 12210              	.LBE489:
 12211              		.cfi_endproc
 12212              	.LFE25:
 12214              		.align	2
 12215              		.global	CyFxGpifCB
 12217              	CyFxGpifCB:
 12218              	.LFB13:
2417:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12219              		.loc 1 2417 0
 12220              		.cfi_startproc
 12221              		@ args = 0, pretend = 0, frame = 0
 12222              		@ frame_needed = 0, uses_anonymous_args = 0
2418:../uvc.c      ****     {
 12223              		.loc 1 2418 0
 12224 6468 010050E3 		cmp	r0, #1
2417:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 12225              		.loc 1 2417 0
 12226 646c 10402DE9 		stmfd	sp!, {r4, lr}
 12227              	.LCFI29:
 12228              		.cfi_def_cfa_offset 8
 12229              		.cfi_offset 4, -8
 12230              		.cfi_offset 14, -4
2418:../uvc.c      ****     {
 12231              		.loc 1 2418 0
 12232 6470 1080BD18 		ldmnefd	sp!, {r4, pc}
 12233              	.LBB494:
 12234              	.LBB495:
2315:../uvc.c      ****     {
 12235              		.loc 1 2315 0
 12236 6474 C4309FE5 		ldr	r3, .L1002
 12237 6478 4830D3E5 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 12238 647c 030053E3 		cmp	r3, #3
 12239 6480 1000000A 		beq	.L1001
2341:../uvc.c      ****     {
 12240              		.loc 1 2341 0
 12241 6484 020053E3 		cmp	r3, #2
 12242 6488 1080BD18 		ldmnefd	sp!, {r4, pc}
2343:../uvc.c      ****         {
 12243              		.loc 1 2343 0
 12244 648c 083041E2 		sub	r3, r1, #8
 12245 6490 0A0053E3 		cmp	r3, #10
 12246 6494 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 12247 6498 200000EA 		b	.L994
 12248              	.L996:
 12249 649c 18650000 		.word	.L989
 12250 64a0 20650000 		.word	.L994
 12251 64a4 20650000 		.word	.L994
 12252 64a8 E8640000 		.word	.L985
 12253 64ac 20650000 		.word	.L994
 12254 64b0 20650000 		.word	.L994
 12255 64b4 20650000 		.word	.L994
 12256 64b8 EC640000 		.word	.L1000
 12257 64bc 20650000 		.word	.L994
 12258 64c0 20650000 		.word	.L994
 12259 64c4 E8640000 		.word	.L985
 12260              	.L1001:
2317:../uvc.c      ****         {
 12261              		.loc 1 2317 0
 12262 64c8 0B1041E2 		sub	r1, r1, #11
 12263 64cc 030051E3 		cmp	r1, #3
 12264 64d0 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 12265 64d4 150000EA 		b	.L988
 12266              	.L990:
 12267 64d8 18650000 		.word	.L989
 12268 64dc EC640000 		.word	.L1000
 12269 64e0 E8640000 		.word	.L985
 12270 64e4 E8640000 		.word	.L985
 12271              	.L985:
 12272 64e8 1080BDE8 		ldmfd	sp!, {r4, pc}
 12273              	.L1000:
2343:../uvc.c      ****         {
 12274              		.loc 1 2343 0
 12275 64ec 0110A0E3 		mov	r1, #1
 12276              	.L991:
2400:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 12277              		.loc 1 2400 0
 12278 64f0 4C009FE5 		ldr	r0, .L1002+4
 12279 64f4 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
2401:../uvc.c      ****         {
 12280              		.loc 1 2401 0
 12281 64f8 004050E2 		subs	r4, r0, #0
 12282 64fc 1080BD08 		ldmeqfd	sp!, {r4, pc}
2403:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
 12283              		.loc 1 2403 0
 12284 6500 0400A0E3 		mov	r0, #4
 12285 6504 3C109FE5 		ldr	r1, .L1002+8
 12286 6508 0420A0E1 		mov	r2, r4
 12287 650c FEFFFFEB 		bl	CyU3PDebugPrint
2404:../uvc.c      ****         }
 12288              		.loc 1 2404 0
 12289 6510 0400A0E1 		mov	r0, r4
 12290 6514 FEFFFFEB 		bl	CyFxAppErrorHandler
 12291              	.L989:
2317:../uvc.c      ****         {
 12292              		.loc 1 2317 0
 12293 6518 0010A0E3 		mov	r1, #0
 12294 651c F3FFFFEA 		b	.L991
 12295              	.L994:
2389:../uvc.c      ****                 /* Unexpected current state. Return error. */
 12296              		.loc 1 2389 0
 12297 6520 0120A0E1 		mov	r2, r1
 12298 6524 0100A0E3 		mov	r0, #1
 12299 6528 1C109FE5 		ldr	r1, .L1002+12
 12300 652c FEFFFFEB 		bl	CyU3PDebugPrint
 12301              	.L988:
 12302              	.LBE495:
 12303              	.LBE494:
 12304              	.LBB496:
 12305              	.LBB497:
2424:../uvc.c      ****     }
 12306              		.loc 1 2424 0
 12307 6530 0400A0E3 		mov	r0, #4
 12308 6534 14109FE5 		ldr	r1, .L1002+16
 12309              	.LBE497:
 12310              	.LBE496:
2427:../uvc.c      **** 
 12311              		.loc 1 2427 0
 12312 6538 1040BDE8 		ldmfd	sp!, {r4, lr}
 12313              	.LBB499:
 12314              	.LBB498:
2424:../uvc.c      ****     }
 12315              		.loc 1 2424 0
 12316 653c FEFFFFEA 		b	CyU3PDebugPrint
 12317              	.L1003:
 12318              		.align	2
 12319              	.L1002:
 12320 6540 00000000 		.word	.LANCHOR0
 12321 6544 00000000 		.word	glChHandleUVCStream
 12322 6548 C40C0000 		.word	.LC73
 12323 654c AC0C0000 		.word	.LC72
 12324 6550 F40C0000 		.word	.LC74
 12325              	.LBE498:
 12326              	.LBE499:
 12327              		.cfi_endproc
 12328              	.LFE13:
 12330              		.align	2
 12331              		.global	CyFxApplicationDefine
 12333              	CyFxApplicationDefine:
 12334              	.LFB27:
4613:../uvc.c      **** }
4614:../uvc.c      **** 
4615:../uvc.c      **** 
4616:../uvc.c      **** /*
4617:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
4618:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
4619:../uvc.c      ****  */
4620:../uvc.c      **** void
4621:../uvc.c      **** CyFxApplicationDefine (
4622:../uvc.c      ****         void)
4623:../uvc.c      **** {
 12335              		.loc 1 4623 0
 12336              		.cfi_startproc
 12337              		@ args = 0, pretend = 0, frame = 32
 12338              		@ frame_needed = 0, uses_anonymous_args = 0
 12339              	.LVL1413:
 12340 6554 F0472DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, lr}
 12341              	.LCFI30:
 12342              		.cfi_def_cfa_offset 32
 12343              		.cfi_offset 4, -32
 12344              		.cfi_offset 5, -28
 12345              		.cfi_offset 6, -24
 12346              		.cfi_offset 7, -20
 12347              		.cfi_offset 8, -16
 12348              		.cfi_offset 9, -12
 12349              		.cfi_offset 10, -8
 12350              		.cfi_offset 14, -4
4624:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
4625:../uvc.c      ****     uint32_t retThrdCreate;
4626:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
4627:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
4628:../uvc.c      **** 
4629:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
4630:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12351              		.loc 1 4630 0
 12352 6558 010AA0E3 		mov	r0, #4096
4623:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
 12353              		.loc 1 4623 0
 12354 655c 40D04DE2 		sub	sp, sp, #64
 12355              	.LCFI31:
 12356              		.cfi_def_cfa_offset 96
 12357              		.loc 1 4630 0
 12358 6560 FEFFFFEB 		bl	CyU3PMemAlloc
 12359              	.LVL1414:
 12360 6564 0070A0E1 		mov	r7, r0
 12361              	.LVL1415:
4631:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12362              		.loc 1 4631 0
 12363 6568 010AA0E3 		mov	r0, #4096
 12364              	.LVL1416:
 12365 656c FEFFFFEB 		bl	CyU3PMemAlloc
 12366              	.LVL1417:
 12367 6570 0060A0E1 		mov	r6, r0
 12368              	.LVL1418:
4632:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12369              		.loc 1 4632 0
 12370 6574 010AA0E3 		mov	r0, #4096
 12371              	.LVL1419:
 12372 6578 FEFFFFEB 		bl	CyU3PMemAlloc
 12373              	.LVL1420:
4633:../uvc.c      **** 
4634:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 12374              		.loc 1 4634 0
 12375 657c 000056E3 		cmp	r6, #0
 12376 6580 00005713 		cmpne	r7, #0
 12377 6584 00A0A013 		movne	r10, #0
 12378 6588 01A0A003 		moveq	r10, #1
4632:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 12379              		.loc 1 4632 0
 12380 658c 0090A0E1 		mov	r9, r0
 12381              	.LVL1421:
 12382              		.loc 1 4634 0
 12383 6590 0000001A 		bne	.L1015
 12384              	.LVL1422:
 12385              	.L1005:
 12386              	.L1007:
 12387 6594 FEFFFFEA 		b	.L1007
 12388              	.LVL1423:
 12389              	.L1015:
 12390              		.loc 1 4634 0 is_stmt 0 discriminator 1
 12391 6598 000050E3 		cmp	r0, #0
 12392 659c FCFFFF0A 		beq	.L1005
 12393              	.LVL1424:
4635:../uvc.c      ****         goto fatalErrorHandler;
4636:../uvc.c      **** 
4637:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
4638:../uvc.c      ****     char *cmdName = "I2CcmdQue";
4639:../uvc.c      ****     char *staName = "I2CstaQue";
4640:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, cmdName, CMDQU0, &cmdQuMux);
 12394              		.loc 1 4640 0 is_stmt 1
 12395 65a0 F4309FE5 		ldr	r3, .L1016
 12396 65a4 20008DE2 		add	r0, sp, #32
 12397              	.LVL1425:
 12398 65a8 00308DE5 		str	r3, [sp]
 12399 65ac 4010A0E3 		mov	r1, #64
 12400 65b0 E8209FE5 		ldr	r2, .L1016+4
 12401 65b4 0A30A0E1 		mov	r3, r10
 12402 65b8 FEFFFFEB 		bl	cmdbufCreate
 12403              	.LVL1426:
 12404 65bc 20E08DE2 		add	lr, sp, #32
 12405 65c0 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 12406 65c4 D8C09FE5 		ldr	ip, .L1016+8
4641:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
4642:../uvc.c      **** 	//VdRingBuf  cmdbufCreate(uint16_t size, char * name, uint8_t id, CyU3PMutex *muxPtr);
4643:../uvc.c      **** 
4644:../uvc.c      **** 	/****** initialize command descriptor ***********/
4645:../uvc.c      **** 	cmdquInit(cmdQuptr);
4646:../uvc.c      **** 	cmdquInit(statQuptr);
4647:../uvc.c      **** 
4648:../uvc.c      ****     /* Create the UVC application thread. */
4649:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 12407              		.loc 1 4649 0
 12408 65c8 0840A0E3 		mov	r4, #8
4640:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12409              		.loc 1 4640 0
 12410 65cc 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 12411 65d0 0F009EE8 		ldmia	lr, {r0, r1, r2, r3}
 12412              		.loc 1 4649 0
 12413 65d4 0150A0E3 		mov	r5, #1
4640:../uvc.c      **** 	//statQu = cmdbufCreate(MAXSTA, staName, STAQU0, &staQuMux);
 12414              		.loc 1 4640 0
 12415 65d8 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
4645:../uvc.c      **** 	cmdquInit(statQuptr);
 12416              		.loc 1 4645 0
 12417 65dc 10004CE2 		sub	r0, ip, #16
 12418 65e0 FEFFFFEB 		bl	cmdquInit
 12419              	.LVL1427:
4646:../uvc.c      **** 
 12420              		.loc 1 4646 0
 12421 65e4 BC009FE5 		ldr	r0, .L1016+12
 12422 65e8 FEFFFFEB 		bl	cmdquInit
 12423              	.LVL1428:
 12424              		.loc 1 4649 0
 12425 65ec A880A0E3 		mov	r8, #168
 12426 65f0 012AA0E3 		mov	r2, #4096
 12427 65f4 0A30A0E1 		mov	r3, r10
 12428 65f8 14008DE9 		stmib	sp, {r2, r4}
 12429 65fc A8009FE5 		ldr	r0, .L1016+16
 12430 6600 00708DE5 		str	r7, [sp]
 12431 6604 10A08DE5 		str	r10, [sp, #16]
 12432 6608 0C408DE5 		str	r4, [sp, #12]
 12433 660c 14508DE5 		str	r5, [sp, #20]
 12434 6610 18808DE5 		str	r8, [sp, #24]
 12435 6614 94109FE5 		ldr	r1, .L1016+20
 12436 6618 94209FE5 		ldr	r2, .L1016+24
 12437 661c FEFFFFEB 		bl	_txe_thread_create
 12438              	.LVL1429:
4650:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
4651:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
4652:../uvc.c      ****             0,                                          /* No input parameter to thread */
4653:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
4654:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
4655:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4656:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
4657:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4658:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4659:../uvc.c      ****             );
4660:../uvc.c      ****     if (retThrdCreate != 0)
 12439              		.loc 1 4660 0
 12440 6620 003050E2 		subs	r3, r0, #0
 12441 6624 DAFFFF1A 		bne	.L1005
4661:../uvc.c      ****     {
4662:../uvc.c      ****         goto fatalErrorHandler;
4663:../uvc.c      ****     }
4664:../uvc.c      **** 
4665:../uvc.c      ****     /* Create the control request handling thread. */
4666:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 12442              		.loc 1 4666 0
 12443 6628 027BA0E3 		mov	r7, #2048
 12444              	.LVL1430:
 12445 662c 10308DE5 		str	r3, [sp, #16]
 12446 6630 00608DE5 		str	r6, [sp]
 12447 6634 08408DE5 		str	r4, [sp, #8]
 12448 6638 0C408DE5 		str	r4, [sp, #12]
 12449 663c 14508DE5 		str	r5, [sp, #20]
 12450 6640 18808DE5 		str	r8, [sp, #24]
 12451 6644 04708DE5 		str	r7, [sp, #4]
 12452 6648 68009FE5 		ldr	r0, .L1016+28
 12453              	.LVL1431:
 12454 664c 68109FE5 		ldr	r1, .L1016+32
 12455 6650 68209FE5 		ldr	r2, .L1016+36
 12456 6654 FEFFFFEB 		bl	_txe_thread_create
 12457              	.LVL1432:
4667:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
4668:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
4669:../uvc.c      ****             0,                                                  /* No input parameter to thread */
4670:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
4671:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
4672:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
4673:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
4674:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
4675:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
4676:../uvc.c      ****             );
4677:../uvc.c      ****     if (retThrdCreate != 0)
 12458              		.loc 1 4677 0
 12459 6658 003050E2 		subs	r3, r0, #0
 12460 665c CCFFFF1A 		bne	.L1005
4678:../uvc.c      ****     {
4679:../uvc.c      ****         goto fatalErrorHandler;
4680:../uvc.c      ****     }
4681:../uvc.c      **** #if 1
4682:../uvc.c      ****     /* Create the I2C control command handling thread. */
4683:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 12461              		.loc 1 4683 0
 12462 6660 00908DE5 		str	r9, [sp]
 12463 6664 04708DE5 		str	r7, [sp, #4]
 12464 6668 08408DE5 		str	r4, [sp, #8]
 12465 666c 0C408DE5 		str	r4, [sp, #12]
 12466 6670 10308DE5 		str	r3, [sp, #16]
 12467 6674 14508DE5 		str	r5, [sp, #20]
 12468 6678 18808DE5 		str	r8, [sp, #24]
 12469 667c 40009FE5 		ldr	r0, .L1016+40
 12470              	.LVL1433:
 12471 6680 40109FE5 		ldr	r1, .L1016+44
 12472 6684 40209FE5 		ldr	r2, .L1016+48
 12473 6688 FEFFFFEB 		bl	_txe_thread_create
 12474              	.LVL1434:
4684:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
4685:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
4686:../uvc.c      ****             0,                                          /* No input parameter to thread */
4687:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
4688:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
4689:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
4690:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
4691:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
4692:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
4693:../uvc.c      ****             );
4694:../uvc.c      ****     if (retThrdCreate != 0)
 12475              		.loc 1 4694 0
 12476 668c 000050E3 		cmp	r0, #0
 12477 6690 BFFFFF1A 		bne	.L1005
4695:../uvc.c      ****     {
4696:../uvc.c      ****         goto fatalErrorHandler;
4697:../uvc.c      ****     }
4698:../uvc.c      **** #endif
4699:../uvc.c      **** 
4700:../uvc.c      ****     return;
4701:../uvc.c      **** 
4702:../uvc.c      **** fatalErrorHandler:
4703:../uvc.c      ****     /* Add custom recovery or debug actions here */
4704:../uvc.c      ****     /* Loop indefinitely */
4705:../uvc.c      ****     while (1);
4706:../uvc.c      **** }
 12478              		.loc 1 4706 0
 12479 6694 40D08DE2 		add	sp, sp, #64
 12480              		@ sp needed
 12481 6698 F087BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, r10, pc}
 12482              	.LVL1435:
 12483              	.L1017:
 12484              		.align	2
 12485              	.L1016:
 12486 669c 00000000 		.word	cmdQuMux
 12487 66a0 0C0D0000 		.word	.LC75
 12488 66a4 00000000 		.word	cmdQu
 12489 66a8 00000000 		.word	statQu
 12490 66ac E4000000 		.word	.LANCHOR0+228
 12491 66b0 180D0000 		.word	.LC76
 12492 66b4 00000000 		.word	UVCAppThread_Entry
 12493 66b8 8C010000 		.word	.LANCHOR0+396
 12494 66bc 2C0D0000 		.word	.LC77
 12495 66c0 00000000 		.word	UVCAppEP0Thread_Entry
 12496 66c4 34020000 		.word	.LANCHOR0+564
 12497 66c8 440D0000 		.word	.LC78
 12498 66cc 00000000 		.word	I2cAppThread_Entry
 12499              		.cfi_endproc
 12500              	.LFE27:
 12502              		.section	.text.startup,"ax",%progbits
 12503              		.align	2
 12504              		.global	main
 12506              	main:
 12507              	.LFB28:
4707:../uvc.c      **** 
4708:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
4709:../uvc.c      ****  * the ThreadX RTOS here.
4710:../uvc.c      ****  */
4711:../uvc.c      **** int
4712:../uvc.c      **** main (
4713:../uvc.c      ****         void)
4714:../uvc.c      **** {
 12508              		.loc 1 4714 0
 12509              		.cfi_startproc
 12510              		@ args = 0, pretend = 0, frame = 56
 12511              		@ frame_needed = 0, uses_anonymous_args = 0
 12512 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 12513              	.LCFI32:
 12514              		.cfi_def_cfa_offset 12
 12515              		.cfi_offset 4, -12
 12516              		.cfi_offset 5, -8
 12517              		.cfi_offset 14, -4
 12518 0004 3CD04DE2 		sub	sp, sp, #60
 12519              	.LCFI33:
 12520              		.cfi_def_cfa_offset 72
4715:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
4716:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
4717:../uvc.c      **** 
4718:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
4719:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
4720:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12521              		.loc 1 4720 0
 12522 0008 0230A0E3 		mov	r3, #2
4721:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
4722:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
4723:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12523              		.loc 1 4723 0
 12524 000c 0010A0E3 		mov	r1, #0
4724:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12525              		.loc 1 4724 0
 12526 0010 0320A0E3 		mov	r2, #3
4719:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12527              		.loc 1 4719 0
 12528 0014 0150A0E3 		mov	r5, #1
4725:../uvc.c      **** 
4726:../uvc.c      ****     /* Initialize the device */
4727:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 12529              		.loc 1 4727 0
 12530 0018 0D00A0E1 		mov	r0, sp
4719:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 12531              		.loc 1 4719 0
 12532 001c 00508DE5 		str	r5, [sp]
4720:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 12533              		.loc 1 4720 0
 12534 0020 0430CDE5 		strb	r3, [sp, #4]
4721:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 12535              		.loc 1 4721 0
 12536 0024 0530CDE5 		strb	r3, [sp, #5]
4722:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 12537              		.loc 1 4722 0
 12538 0028 0630CDE5 		strb	r3, [sp, #6]
4723:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 12539              		.loc 1 4723 0
 12540 002c 08108DE5 		str	r1, [sp, #8]
4724:../uvc.c      **** 
 12541              		.loc 1 4724 0
 12542 0030 0C20CDE5 		strb	r2, [sp, #12]
 12543              		.loc 1 4727 0
 12544 0034 FEFFFFEB 		bl	CyU3PDeviceInit
 12545              	.LVL1436:
4728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12546              		.loc 1 4728 0
 12547 0038 004050E2 		subs	r4, r0, #0
 12548 003c 0000000A 		beq	.L1023
 12549              	.L1019:
 12550              	.L1020:
 12551 0040 FEFFFFEA 		b	.L1020
 12552              	.L1023:
4729:../uvc.c      ****     {
4730:../uvc.c      ****         goto handle_fatal_error;
4731:../uvc.c      ****     }
4732:../uvc.c      **** 
4733:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
4734:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 12553              		.loc 1 4734 0
 12554 0044 0410A0E1 		mov	r1, r4
 12555 0048 0420A0E1 		mov	r2, r4
 12556 004c 0500A0E1 		mov	r0, r5
 12557              	.LVL1437:
 12558 0050 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 12559              	.LVL1438:
4735:../uvc.c      **** 
4736:../uvc.c      ****     /* Configure the IO matrix for the device. */
4737:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
4738:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
4739:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
4740:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
4741:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
4742:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
4743:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
4744:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
4745:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
4746:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
4747:../uvc.c      **** 
4748:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 12560              		.loc 1 4748 0
 12561 0054 10008DE2 		add	r0, sp, #16
4738:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 12562              		.loc 1 4738 0
 12563 0058 2640CDE5 		strb	r4, [sp, #38]
4739:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 12564              		.loc 1 4739 0
 12565 005c 28408DE5 		str	r4, [sp, #40]
4740:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 12566              		.loc 1 4740 0
 12567 0060 2C408DE5 		str	r4, [sp, #44]
4741:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 12568              		.loc 1 4741 0
 12569 0064 30408DE5 		str	r4, [sp, #48]
4742:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 12570              		.loc 1 4742 0
 12571 0068 34408DE5 		str	r4, [sp, #52]
4745:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 12572              		.loc 1 4745 0
 12573 006c 1C408DE5 		str	r4, [sp, #28]
4746:../uvc.c      **** 
 12574              		.loc 1 4746 0
 12575 0070 20408DE5 		str	r4, [sp, #32]
4737:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 12576              		.loc 1 4737 0
 12577 0074 10508DE5 		str	r5, [sp, #16]
4743:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 12578              		.loc 1 4743 0
 12579 0078 14508DE5 		str	r5, [sp, #20]
4744:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 12580              		.loc 1 4744 0
 12581 007c 18508DE5 		str	r5, [sp, #24]
 12582              		.loc 1 4748 0
 12583 0080 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 12584              	.LVL1439:
4749:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 12585              		.loc 1 4749 0
 12586 0084 004050E2 		subs	r4, r0, #0
 12587 0088 ECFFFF1A 		bne	.L1019
4750:../uvc.c      ****     {
4751:../uvc.c      ****         goto handle_fatal_error;
4752:../uvc.c      ****     }
4753:../uvc.c      **** 
4754:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
4755:../uvc.c      ****     CyU3PKernelEntry ();
 12588              		.loc 1 4755 0
 12589 008c FEFFFFEB 		bl	_tx_initialize_kernel_enter
 12590              	.LVL1440:
4756:../uvc.c      **** 
4757:../uvc.c      ****     /* Dummy return to make the compiler happy */
4758:../uvc.c      ****     return 0;
4759:../uvc.c      **** 
4760:../uvc.c      **** handle_fatal_error:
4761:../uvc.c      ****     /* Cannot recover from this error. */
4762:../uvc.c      ****     while (1);
4763:../uvc.c      **** }
 12591              		.loc 1 4763 0
 12592 0090 0400A0E1 		mov	r0, r4
 12593 0094 3CD08DE2 		add	sp, sp, #60
 12594              		@ sp needed
 12595 0098 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 12596              		.cfi_endproc
 12597              	.LFE28:
 12599              		.comm	I2CCmdTimer,44,4
 12600              		.comm	posTick,4,4
 12601              		.global	glUVCHeader
 12602              		.global	glProbeStilCtrl20
 12603              		.global	glProbeCtrl20
 12604              		.global	glProbeStilCtrl
 12605              		.global	glProbeCtrlFull
 12606              		.global	glProbeCtrl
 12607              		.global	streamingStarted
 12608              		.global	clearFeatureRqtReceived
 12609              		.global	usbSpeed
 12610              		.global	isUsbConnected
 12611              		.global	pbcpbak
 12612              		.global	pbcbak
 12613              		.global	pbbak
 12614              		.global	fbbak
 12615              		.global	pbc
 12616              		.global	pb
 12617              		.global	fb
 12618              		.comm	wLength,2,2
 12619              		.comm	wIndex,2,2
 12620              		.comm	wValue,2,2
 12621              		.comm	bRequest,1,1
 12622              		.comm	bmReqType,1,1
 12623              		.comm	imgHdMux,56,4
 12624              		.comm	timMux,56,4
 12625              		.comm	staQuMux,56,4
 12626              		.comm	cmdQuMux,56,4
 12627              		.comm	statQu,32,4
 12628              		.comm	cmdQu,32,4
 12629              		.global	testSnap
 12630              		.global	snapButFlag
 12631              		.comm	glInterStaBuffer,4,4
 12632              		.comm	glChHandleInterStat,172,4
 12633              		.comm	glChHandleStillStream,232,4
 12634              		.comm	glChHandleUVCStream,232,4
 12635              		.global	CyFxGpifConfig_usb2
 12636              		.global	CyFxGpifRegValue_usb2
 12637              		.global	CyFxGpifWavedataPosition_usb2
 12638              		.global	CyFxGpifWavedata_usb2
 12639              		.global	CyFxGpifTransition_usb2
 12640              		.global	CyFxGpifConfig
 12641              		.global	CyFxGpifRegValue
 12642              		.global	CyFxGpifWavedataPosition
 12643              		.global	CyFxGpifWavedata
 12644              		.global	CyFxGpifTransition
 12645              		.section	.rodata
 12646              		.align	2
 12647              		.set	.LANCHOR2,. + 0
 12650              	ShutSp:
 12651 0000 3582     		.short	-32203
 12652 0002 1B41     		.short	16667
 12653 0004 8D20     		.short	8333
 12654 0006 A00F     		.short	4000
 12655 0008 D007     		.short	2000
 12656 000a E803     		.short	1000
 12657 000c F401     		.short	500
 12658 000e C800     		.short	200
 12659 0010 6400     		.short	100
 12660 0012 0A00     		.short	10
 12661 0014 0000     		.short	0
 12662 0016 00000000 		.space	10
 12662      00000000 
 12662      0000
 12665              	CyFxGpifConfig:
 12666 0020 0F00     		.short	15
 12667 0022 0000     		.space	2
 12668 0024 00000000 		.word	CyFxGpifWavedata
 12669 0028 00000000 		.word	CyFxGpifWavedataPosition
 12670 002c 0500     		.short	5
 12671 002e 0000     		.space	2
 12672 0030 00000000 		.word	CyFxGpifTransition
 12673 0034 4C00     		.short	76
 12674 0036 0000     		.space	2
 12675 0038 00000000 		.word	CyFxGpifRegValue
 12678              	CyFxGpifConfig_usb2:
 12679 003c 9300     		.short	147
 12680 003e 0000     		.space	2
 12681 0040 00000000 		.word	CyFxGpifWavedata_usb2
 12682 0044 00000000 		.word	CyFxGpifWavedataPosition_usb2
 12683 0048 0800     		.short	8
 12684 004a 0000     		.space	2
 12685 004c 00000000 		.word	CyFxGpifTransition_usb2
 12686 0050 4C00     		.short	76
 12687 0052 0000     		.space	2
 12688 0054 00000000 		.word	CyFxGpifRegValue_usb2
 12689              		.data
 12690              		.align	2
 12691              		.set	.LANCHOR1,. + 0
 12694              	glProbeCtrlFull:
 12695 0000 00       		.byte	0
 12696 0001 00       		.byte	0
 12697 0002 01       		.byte	1
 12698 0003 01       		.byte	1
 12699 0004 15       		.byte	21
 12700 0005 16       		.byte	22
 12701 0006 05       		.byte	5
 12702 0007 00       		.byte	0
 12703 0008 00       		.byte	0
 12704 0009 00       		.byte	0
 12705 000a 00       		.byte	0
 12706 000b 00       		.byte	0
 12707 000c 00       		.byte	0
 12708 000d 00       		.byte	0
 12709 000e 00       		.byte	0
 12710 000f 00       		.byte	0
 12711 0010 00       		.byte	0
 12712 0011 00       		.byte	0
 12713 0012 00       		.byte	0
 12714 0013 C6       		.byte	-58
 12715 0014 99       		.byte	-103
 12716 0015 00       		.byte	0
 12717 0016 00       		.byte	0
 12718 0017 40       		.byte	64
 12719 0018 00       		.byte	0
 12720 0019 00       		.byte	0
 12721 001a 0000     		.space	2
 12724              	glProbeCtrl20:
 12725 001c 00       		.byte	0
 12726 001d 00       		.byte	0
 12727 001e 01       		.byte	1
 12728 001f 01       		.byte	1
 12729 0020 80       		.byte	-128
 12730 0021 1A       		.byte	26
 12731 0022 06       		.byte	6
 12732 0023 00       		.byte	0
 12733 0024 00       		.byte	0
 12734 0025 00       		.byte	0
 12735 0026 00       		.byte	0
 12736 0027 00       		.byte	0
 12737 0028 00       		.byte	0
 12738 0029 00       		.byte	0
 12739 002a 00       		.byte	0
 12740 002b 00       		.byte	0
 12741 002c 00       		.byte	0
 12742 002d 00       		.byte	0
 12743 002e 00       		.byte	0
 12744 002f D2       		.byte	-46
 12745 0030 0F       		.byte	15
 12746 0031 00       		.byte	0
 12747 0032 00       		.byte	0
 12748 0033 40       		.byte	64
 12749 0034 00       		.byte	0
 12750 0035 00       		.byte	0
 12751 0036 0000     		.space	2
 12754              	glProbeCtrl:
 12755 0038 00       		.byte	0
 12756 0039 00       		.byte	0
 12757 003a 01       		.byte	1
 12758 003b 01       		.byte	1
 12759 003c 15       		.byte	21
 12760 003d 16       		.byte	22
 12761 003e 05       		.byte	5
 12762 003f 00       		.byte	0
 12763 0040 00       		.byte	0
 12764 0041 00       		.byte	0
 12765 0042 00       		.byte	0
 12766 0043 00       		.byte	0
 12767 0044 00       		.byte	0
 12768 0045 00       		.byte	0
 12769 0046 00       		.byte	0
 12770 0047 00       		.byte	0
 12771 0048 00       		.byte	0
 12772 0049 00       		.byte	0
 12773 004a 00       		.byte	0
 12774 004b 48       		.byte	72
 12775 004c 3F       		.byte	63
 12776 004d 00       		.byte	0
 12777 004e 00       		.byte	0
 12778 004f 40       		.byte	64
 12779 0050 00       		.byte	0
 12780 0051 00       		.byte	0
 12783              	ROIMode:
 12784 0052 01       		.byte	1
 12785 0053 00       		.space	1
 12788              	glProbeStilCtrl:
 12789 0054 01       		.byte	1
 12790 0055 02       		.byte	2
 12791 0056 00       		.byte	0
 12792 0057 00       		.byte	0
 12793 0058 C6       		.byte	-58
 12794 0059 99       		.byte	-103
 12795 005a 00       		.byte	0
 12796 005b 00       		.byte	0
 12797 005c 40       		.byte	64
 12798 005d 00       		.byte	0
 12799 005e 00       		.byte	0
 12800 005f 00       		.space	1
 12803              	glProbeStilCtrl20:
 12804 0060 01       		.byte	1
 12805 0061 01       		.byte	1
 12806 0062 00       		.byte	0
 12807 0063 00       		.byte	0
 12808 0064 D2       		.byte	-46
 12809 0065 0F       		.byte	15
 12810 0066 00       		.byte	0
 12811 0067 00       		.byte	0
 12812 0068 40       		.byte	64
 12813 0069 00       		.byte	0
 12814 006a 00       		.byte	0
 12815 006b 00       		.space	1
 12818              	ExUCtrlParArry:
 12819 006c 00       		.byte	0
 12820 006d 00       		.byte	0
 12821 006e 04       		.byte	4
 12822 006f 01       		.byte	1
 12823 0070 00       		.byte	0
 12824 0071 38       		.byte	56
 12825 0072 01       		.byte	1
 12826 0073 01       		.byte	1
 12827 0074 00       		.byte	0
 12828 0075 03       		.byte	3
 12829 0076 00       		.byte	0
 12830 0077 4E       		.byte	78
 12831 0078 00       		.byte	0
 12832 0079 4E       		.byte	78
 12833 007a 00       		.byte	0
 12834 007b 30       		.byte	48
 12835 007c 01       		.byte	1
 12836 007d 00       		.byte	0
 12837 007e 00       		.byte	0
 12838 007f 00000000 		.space	5
 12838      00
 12839 0084 00       		.byte	0
 12840 0085 00       		.byte	0
 12841 0086 01       		.byte	1
 12842 0087 00       		.byte	0
 12843 0088 00       		.byte	0
 12844 0089 00       		.byte	0
 12845 008a 00       		.byte	0
 12846 008b 01       		.byte	1
 12847 008c 00       		.byte	0
 12848 008d 03       		.byte	3
 12849 008e 00       		.byte	0
 12850 008f 00       		.byte	0
 12851 0090 00       		.byte	0
 12852 0091 00       		.byte	0
 12853 0092 00       		.byte	0
 12854 0093 30       		.byte	48
 12855 0094 01       		.byte	1
 12856 0095 00       		.byte	0
 12857 0096 00       		.byte	0
 12858 0097 00000000 		.space	5
 12858      00
 12859 009c 00       		.byte	0
 12860 009d 00       		.byte	0
 12861 009e 02       		.byte	2
 12862 009f 00       		.byte	0
 12863 00a0 00       		.byte	0
 12864 00a1 FF       		.byte	-1
 12865 00a2 00       		.byte	0
 12866 00a3 01       		.byte	1
 12867 00a4 00       		.byte	0
 12868 00a5 03       		.byte	3
 12869 00a6 00       		.byte	0
 12870 00a7 01       		.byte	1
 12871 00a8 00       		.byte	0
 12872 00a9 00       		.byte	0
 12873 00aa 00       		.byte	0
 12874 00ab 30       		.byte	48
 12875 00ac 01       		.byte	1
 12876 00ad 01       		.byte	1
 12877 00ae 00       		.byte	0
 12878 00af 00000000 		.space	5
 12878      00
 12879 00b4 00       		.byte	0
 12880 00b5 00       		.byte	0
 12881 00b6 02       		.byte	2
 12882 00b7 00       		.byte	0
 12883 00b8 00       		.byte	0
 12884 00b9 00       		.byte	0
 12885 00ba 00       		.byte	0
 12886 00bb 00       		.byte	0
 12887 00bc 00       		.byte	0
 12888 00bd 03       		.byte	3
 12889 00be 00       		.byte	0
 12890 00bf 00       		.byte	0
 12891 00c0 00       		.byte	0
 12892 00c1 00       		.byte	0
 12893 00c2 00       		.byte	0
 12894 00c3 30       		.byte	48
 12895 00c4 01       		.byte	1
 12896 00c5 01       		.byte	1
 12897 00c6 00       		.byte	0
 12898 00c7 00000000 		.space	5
 12898      00
 12899 00cc 13       		.byte	19
 12900 00cd 14       		.byte	20
 12901 00ce 02       		.byte	2
 12902 00cf 00       		.byte	0
 12903 00d0 00       		.byte	0
 12904 00d1 FF       		.byte	-1
 12905 00d2 FF       		.byte	-1
 12906 00d3 01       		.byte	1
 12907 00d4 00       		.byte	0
 12908 00d5 03       		.byte	3
 12909 00d6 00       		.byte	0
 12910 00d7 66       		.byte	102
 12911 00d8 66       		.byte	102
 12912 00d9 66       		.byte	102
 12913 00da 66       		.byte	102
 12914 00db 30       		.byte	48
 12915 00dc 01       		.byte	1
 12916 00dd 00       		.byte	0
 12917 00de 00       		.byte	0
 12918 00df 00000000 		.space	5
 12918      00
 12919 00e4 11       		.byte	17
 12920 00e5 00       		.byte	0
 12921 00e6 02       		.byte	2
 12922 00e7 01       		.byte	1
 12923 00e8 00       		.byte	0
 12924 00e9 03       		.byte	3
 12925 00ea 00       		.byte	0
 12926 00eb 01       		.byte	1
 12927 00ec 00       		.byte	0
 12928 00ed 03       		.byte	3
 12929 00ee 00       		.byte	0
 12930 00ef 80       		.byte	-128
 12931 00f0 00       		.byte	0
 12932 00f1 80       		.byte	-128
 12933 00f2 00       		.byte	0
 12934 00f3 30       		.byte	48
 12935 00f4 01       		.byte	1
 12936 00f5 01       		.byte	1
 12937 00f6 00       		.byte	0
 12938 00f7 00000000 		.space	5
 12938      00
 12939 00fc 10       		.byte	16
 12940 00fd 00       		.byte	0
 12941 00fe 01       		.byte	1
 12942 00ff 01       		.byte	1
 12943 0100 00       		.byte	0
 12944 0101 02       		.byte	2
 12945 0102 00       		.byte	0
 12946 0103 01       		.byte	1
 12947 0104 00       		.byte	0
 12948 0105 03       		.byte	3
 12949 0106 00       		.byte	0
 12950 0107 00       		.byte	0
 12951 0108 00       		.byte	0
 12952 0109 00       		.byte	0
 12953 010a 00       		.byte	0
 12954 010b 30       		.byte	48
 12955 010c 01       		.byte	1
 12956 010d 01       		.byte	1
 12957 010e 00       		.byte	0
 12958 010f 00000000 		.space	5
 12958      00
 12959 0114 00       		.byte	0
 12960 0115 00       		.byte	0
 12961 0116 04       		.byte	4
 12962 0117 01       		.byte	1
 12963 0118 00       		.byte	0
 12964 0119 38       		.byte	56
 12965 011a 01       		.byte	1
 12966 011b 01       		.byte	1
 12967 011c 00       		.byte	0
 12968 011d 03       		.byte	3
 12969 011e 00       		.byte	0
 12970 011f 4E       		.byte	78
 12971 0120 00       		.byte	0
 12972 0121 4E       		.byte	78
 12973 0122 00       		.byte	0
 12974 0123 30       		.byte	48
 12975 0124 01       		.byte	1
 12976 0125 00       		.byte	0
 12977 0126 00       		.byte	0
 12978 0127 00000000 		.space	5
 12978      00
 12979 012c 00       		.byte	0
 12980 012d 00       		.byte	0
 12981 012e 01       		.byte	1
 12982 012f 00       		.byte	0
 12983 0130 00       		.byte	0
 12984 0131 00       		.byte	0
 12985 0132 00       		.byte	0
 12986 0133 01       		.byte	1
 12987 0134 00       		.byte	0
 12988 0135 03       		.byte	3
 12989 0136 00       		.byte	0
 12990 0137 00       		.byte	0
 12991 0138 00       		.byte	0
 12992 0139 00       		.byte	0
 12993 013a 00       		.byte	0
 12994 013b 30       		.byte	48
 12995 013c 01       		.byte	1
 12996 013d 00       		.byte	0
 12997 013e 00       		.byte	0
 12998 013f 00000000 		.space	5
 12998      00
 12999 0144 00       		.byte	0
 13000 0145 00       		.byte	0
 13001 0146 02       		.byte	2
 13002 0147 00       		.byte	0
 13003 0148 00       		.byte	0
 13004 0149 05       		.byte	5
 13005 014a 00       		.byte	0
 13006 014b 01       		.byte	1
 13007 014c 00       		.byte	0
 13008 014d 03       		.byte	3
 13009 014e 00       		.byte	0
 13010 014f 00       		.byte	0
 13011 0150 00       		.byte	0
 13012 0151 00       		.byte	0
 13013 0152 00       		.byte	0
 13014 0153 30       		.byte	48
 13015 0154 01       		.byte	1
 13016 0155 00       		.byte	0
 13017 0156 00       		.byte	0
 13018 0157 00000000 		.space	5
 13018      00
 13019 015c 00       		.byte	0
 13020 015d 00       		.byte	0
 13021 015e 03       		.byte	3
 13022 015f 00       		.byte	0
 13023 0160 00       		.byte	0
 13024 0161 0A       		.byte	10
 13025 0162 00       		.byte	0
 13026 0163 01       		.byte	1
 13027 0164 00       		.byte	0
 13028 0165 03       		.byte	3
 13029 0166 00       		.byte	0
 13030 0167 00       		.byte	0
 13031 0168 00       		.byte	0
 13032 0169 00       		.byte	0
 13033 016a 00       		.byte	0
 13034 016b 30       		.byte	48
 13035 016c 01       		.byte	1
 13036 016d 00       		.byte	0
 13037 016e 00       		.byte	0
 13038 016f 00000000 		.space	5
 13038      00
 13039 0174 00       		.byte	0
 13040 0175 00       		.byte	0
 13041 0176 02       		.byte	2
 13042 0177 00       		.byte	0
 13043 0178 00       		.byte	0
 13044 0179 40       		.byte	64
 13045 017a 00       		.byte	0
 13046 017b 01       		.byte	1
 13047 017c 00       		.byte	0
 13048 017d 03       		.byte	3
 13049 017e 00       		.byte	0
 13050 017f 0F       		.byte	15
 13051 0180 11       		.byte	17
 13052 0181 00       		.byte	0
 13053 0182 00       		.byte	0
 13054 0183 30       		.byte	48
 13055 0184 01       		.byte	1
 13056 0185 00       		.byte	0
 13057 0186 00       		.byte	0
 13058 0187 00000000 		.space	5
 13058      00
 13059 018c 00       		.byte	0
 13060 018d 00       		.byte	0
 13061 018e 02       		.byte	2
 13062 018f 00       		.byte	0
 13063 0190 00       		.byte	0
 13064 0191 64       		.byte	100
 13065 0192 00       		.byte	0
 13066 0193 01       		.byte	1
 13067 0194 00       		.byte	0
 13068 0195 03       		.byte	3
 13069 0196 00       		.byte	0
 13070 0197 00       		.byte	0
 13071 0198 00       		.byte	0
 13072 0199 00       		.byte	0
 13073 019a 00       		.byte	0
 13074 019b 30       		.byte	48
 13075 019c 01       		.byte	1
 13076 019d 00       		.byte	0
 13077 019e 00       		.byte	0
 13078 019f 00000000 		.space	5
 13078      00
 13079 01a4 00       		.byte	0
 13080 01a5 00       		.byte	0
 13081 01a6 02       		.byte	2
 13082 01a7 00       		.byte	0
 13083 01a8 00       		.byte	0
 13084 01a9 64       		.byte	100
 13085 01aa 00       		.byte	0
 13086 01ab 01       		.byte	1
 13087 01ac 00       		.byte	0
 13088 01ad 03       		.byte	3
 13089 01ae 00       		.byte	0
 13090 01af 00       		.byte	0
 13091 01b0 00       		.byte	0
 13092 01b1 00       		.byte	0
 13093 01b2 00       		.byte	0
 13094 01b3 30       		.byte	48
 13095 01b4 01       		.byte	1
 13096 01b5 00       		.byte	0
 13097 01b6 00       		.byte	0
 13098 01b7 00000000 		.space	5
 13098      00
 13099 01bc 00       		.byte	0
 13100 01bd 00       		.byte	0
 13101 01be 02       		.byte	2
 13102 01bf 00       		.byte	0
 13103 01c0 00       		.byte	0
 13104 01c1 64       		.byte	100
 13105 01c2 00       		.byte	0
 13106 01c3 01       		.byte	1
 13107 01c4 00       		.byte	0
 13108 01c5 03       		.byte	3
 13109 01c6 00       		.byte	0
 13110 01c7 00       		.byte	0
 13111 01c8 00       		.byte	0
 13112 01c9 00       		.byte	0
 13113 01ca 00       		.byte	0
 13114 01cb 30       		.byte	48
 13115 01cc 01       		.byte	1
 13116 01cd 00       		.byte	0
 13117 01ce 00       		.byte	0
 13118 01cf 00000000 		.space	5
 13118      00
 13119 01d4 00       		.byte	0
 13120 01d5 00       		.byte	0
 13121 01d6 02       		.byte	2
 13122 01d7 00       		.byte	0
 13123 01d8 00       		.byte	0
 13124 01d9 64       		.byte	100
 13125 01da 00       		.byte	0
 13126 01db 01       		.byte	1
 13127 01dc 00       		.byte	0
 13128 01dd 03       		.byte	3
 13129 01de 00       		.byte	0
 13130 01df 00       		.byte	0
 13131 01e0 00       		.byte	0
 13132 01e1 00       		.byte	0
 13133 01e2 00       		.byte	0
 13134 01e3 30       		.byte	48
 13135 01e4 01       		.byte	1
 13136 01e5 00       		.byte	0
 13137 01e6 00       		.byte	0
 13138 01e7 00000000 		.space	5
 13138      00
 13141              	CtrlParArry:
 13142 01ec 10       		.byte	16
 13143 01ed 10       		.byte	16
 13144 01ee 02       		.byte	2
 13145 01ef 00       		.byte	0
 13146 01f0 00       		.byte	0
 13147 01f1 03       		.byte	3
 13148 01f2 00       		.byte	0
 13149 01f3 01       		.byte	1
 13150 01f4 00       		.byte	0
 13151 01f5 03       		.byte	3
 13152 01f6 00       		.byte	0
 13153 01f7 03       		.byte	3
 13154 01f8 00       		.byte	0
 13155 01f9 03       		.byte	3
 13156 01fa 00       		.byte	0
 13157 01fb 30       		.byte	48
 13158 01fc 01       		.byte	1
 13159 01fd 00       		.byte	0
 13160 01fe 00       		.byte	0
 13161 01ff 00000000 		.space	5
 13161      00
 13162 0204 15       		.byte	21
 13163 0205 15       		.byte	21
 13164 0206 02       		.byte	2
 13165 0207 00       		.byte	0
 13166 0208 00       		.byte	0
 13167 0209 FF       		.byte	-1
 13168 020a 00       		.byte	0
 13169 020b 01       		.byte	1
 13170 020c 00       		.byte	0
 13171 020d 03       		.byte	3
 13172 020e 00       		.byte	0
 13173 020f 76       		.byte	118
 13174 0210 00       		.byte	0
 13175 0211 76       		.byte	118
 13176 0212 C7       		.byte	-57
 13177 0213 30       		.byte	48
 13178 0214 01       		.byte	1
 13179 0215 01       		.byte	1
 13180 0216 00       		.byte	0
 13181 0217 00000000 		.space	5
 13181      00
 13182 021c 04       		.byte	4
 13183 021d 04       		.byte	4
 13184 021e 02       		.byte	2
 13185 021f 00       		.byte	0
 13186 0220 00       		.byte	0
 13187 0221 FF       		.byte	-1
 13188 0222 00       		.byte	0
 13189 0223 01       		.byte	1
 13190 0224 00       		.byte	0
 13191 0225 03       		.byte	3
 13192 0226 00       		.byte	0
 13193 0227 70       		.byte	112
 13194 0228 00       		.byte	0
 13195 0229 70       		.byte	112
 13196 022a 00       		.byte	0
 13197 022b 30       		.byte	48
 13198 022c 01       		.byte	1
 13199 022d 01       		.byte	1
 13200 022e 00       		.byte	0
 13201 022f 00000000 		.space	5
 13201      00
 13202 0234 00       		.byte	0
 13203 0235 00       		.byte	0
 13204 0236 02       		.byte	2
 13205 0237 00       		.byte	0
 13206 0238 00       		.byte	0
 13207 0239 64       		.byte	100
 13208 023a 00       		.byte	0
 13209 023b 01       		.byte	1
 13210 023c 00       		.byte	0
 13211 023d 03       		.byte	3
 13212 023e 00       		.byte	0
 13213 023f 00       		.byte	0
 13214 0240 00       		.byte	0
 13215 0241 00       		.byte	0
 13216 0242 00       		.byte	0
 13217 0243 30       		.byte	48
 13218 0244 01       		.byte	1
 13219 0245 00       		.byte	0
 13220 0246 00       		.byte	0
 13221 0247 00000000 		.space	5
 13221      00
 13222 024c 07       		.byte	7
 13223 024d 07       		.byte	7
 13224 024e 02       		.byte	2
 13225 024f 00       		.byte	0
 13226 0250 00       		.byte	0
 13227 0251 01       		.byte	1
 13228 0252 00       		.byte	0
 13229 0253 01       		.byte	1
 13230 0254 00       		.byte	0
 13231 0255 03       		.byte	3
 13232 0256 00       		.byte	0
 13233 0257 01       		.byte	1
 13234 0258 00       		.byte	0
 13235 0259 01       		.byte	1
 13236 025a 00       		.byte	0
 13237 025b 30       		.byte	48
 13238 025c 01       		.byte	1
 13239 025d 00       		.byte	0
 13240 025e 00       		.byte	0
 13241 025f 00000000 		.space	5
 13241      00
 13242 0264 DF       		.byte	-33
 13243 0265 E1       		.byte	-31
 13244 0266 02       		.byte	2
 13245 0267 00       		.byte	0
 13246 0268 00       		.byte	0
 13247 0269 FF       		.byte	-1
 13248 026a 00       		.byte	0
 13249 026b 01       		.byte	1
 13250 026c 00       		.byte	0
 13251 026d 03       		.byte	3
 13252 026e 00       		.byte	0
 13253 026f 80       		.byte	-128
 13254 0270 00       		.byte	0
 13255 0271 00       		.byte	0
 13256 0272 00       		.byte	0
 13257 0273 C6       		.byte	-58
 13258 0274 01       		.byte	1
 13259 0275 01       		.byte	1
 13260 0276 00       		.byte	0
 13261 0277 00000000 		.space	5
 13261      00
 13262 027c 85       		.byte	-123
 13263 027d 86       		.byte	-122
 13264 027e 02       		.byte	2
 13265 027f 00       		.byte	0
 13266 0280 00       		.byte	0
 13267 0281 64       		.byte	100
 13268 0282 00       		.byte	0
 13269 0283 01       		.byte	1
 13270 0284 00       		.byte	0
 13271 0285 03       		.byte	3
 13272 0286 00       		.byte	0
 13273 0287 32       		.byte	50
 13274 0288 00       		.byte	0
 13275 0289 32       		.byte	50
 13276 028a 00       		.byte	0
 13277 028b F2       		.byte	-14
 13278 028c 01       		.byte	1
 13279 028d 01       		.byte	1
 13280 028e 00       		.byte	0
 13281 028f 00000000 		.space	5
 13281      00
 13282 0294 06       		.byte	6
 13283 0295 06       		.byte	6
 13284 0296 02       		.byte	2
 13285 0297 00       		.byte	0
 13286 0298 00       		.byte	0
 13287 0299 FF       		.byte	-1
 13288 029a 00       		.byte	0
 13289 029b 01       		.byte	1
 13290 029c 00       		.byte	0
 13291 029d 03       		.byte	3
 13292 029e 00       		.byte	0
 13293 029f 20       		.byte	32
 13294 02a0 00       		.byte	0
 13295 02a1 20       		.byte	32
 13296 02a2 00       		.byte	0
 13297 02a3 30       		.byte	48
 13298 02a4 01       		.byte	1
 13299 02a5 01       		.byte	1
 13300 02a6 00       		.byte	0
 13301 02a7 00000000 		.space	5
 13301      00
 13302 02ac 00       		.byte	0
 13303 02ad 00       		.byte	0
 13304 02ae 02       		.byte	2
 13305 02af 00       		.byte	0
 13306 02b0 00       		.byte	0
 13307 02b1 64       		.byte	100
 13308 02b2 00       		.byte	0
 13309 02b3 01       		.byte	1
 13310 02b4 00       		.byte	0
 13311 02b5 03       		.byte	3
 13312 02b6 00       		.byte	0
 13313 02b7 00       		.byte	0
 13314 02b8 00       		.byte	0
 13315 02b9 00       		.byte	0
 13316 02ba 00       		.byte	0
 13317 02bb 30       		.byte	48
 13318 02bc 01       		.byte	1
 13319 02bd 00       		.byte	0
 13320 02be 00       		.byte	0
 13321 02bf 00000000 		.space	5
 13321      00
 13322 02c4 08       		.byte	8
 13323 02c5 08       		.byte	8
 13324 02c6 02       		.byte	2
 13325 02c7 00       		.byte	0
 13326 02c8 00       		.byte	0
 13327 02c9 05       		.byte	5
 13328 02ca 00       		.byte	0
 13329 02cb 01       		.byte	1
 13330 02cc 00       		.byte	0
 13331 02cd 03       		.byte	3
 13332 02ce 00       		.byte	0
 13333 02cf 00       		.byte	0
 13334 02d0 00       		.byte	0
 13335 02d1 00       		.byte	0
 13336 02d2 00       		.byte	0
 13337 02d3 30       		.byte	48
 13338 02d4 01       		.byte	1
 13339 02d5 00       		.byte	0
 13340 02d6 00       		.byte	0
 13341 02d7 00000000 		.space	5
 13341      00
 13342 02dc 00       		.byte	0
 13343 02dd 00       		.byte	0
 13344 02de 02       		.byte	2
 13345 02df 00       		.byte	0
 13346 02e0 00       		.byte	0
 13347 02e1 40       		.byte	64
 13348 02e2 00       		.byte	0
 13349 02e3 01       		.byte	1
 13350 02e4 00       		.byte	0
 13351 02e5 03       		.byte	3
 13352 02e6 00       		.byte	0
 13353 02e7 00       		.byte	0
 13354 02e8 00       		.byte	0
 13355 02e9 00       		.byte	0
 13356 02ea 00       		.byte	0
 13357 02eb 30       		.byte	48
 13358 02ec 01       		.byte	1
 13359 02ed 00       		.byte	0
 13360 02ee 00       		.byte	0
 13361 02ef 00000000 		.space	5
 13361      00
 13362 02f4 09       		.byte	9
 13363 02f5 0A       		.byte	10
 13364 02f6 04       		.byte	4
 13365 02f7 00       		.byte	0
 13366 02f8 00       		.byte	0
 13367 02f9 40       		.byte	64
 13368 02fa 00       		.byte	0
 13369 02fb 01       		.byte	1
 13370 02fc 00       		.byte	0
 13371 02fd 03       		.byte	3
 13372 02fe 00       		.byte	0
 13373 02ff 20       		.byte	32
 13374 0300 38       		.byte	56
 13375 0301 20       		.byte	32
 13376 0302 38       		.byte	56
 13377 0303 30       		.byte	48
 13378 0304 01       		.byte	1
 13379 0305 00       		.byte	0
 13380 0306 00       		.byte	0
 13381 0307 00000000 		.space	5
 13381      00
 13382 030c 00       		.byte	0
 13383 030d 00       		.byte	0
 13384 030e 02       		.byte	2
 13385 030f 00       		.byte	0
 13386 0310 00       		.byte	0
 13387 0311 64       		.byte	100
 13388 0312 00       		.byte	0
 13389 0313 01       		.byte	1
 13390 0314 00       		.byte	0
 13391 0315 03       		.byte	3
 13392 0316 00       		.byte	0
 13393 0317 00       		.byte	0
 13394 0318 00       		.byte	0
 13395 0319 00       		.byte	0
 13396 031a 00       		.byte	0
 13397 031b 30       		.byte	48
 13398 031c 01       		.byte	1
 13399 031d 00       		.byte	0
 13400 031e 00       		.byte	0
 13401 031f 00000000 		.space	5
 13401      00
 13402 0324 00       		.byte	0
 13403 0325 00       		.byte	0
 13404 0326 02       		.byte	2
 13405 0327 00       		.byte	0
 13406 0328 00       		.byte	0
 13407 0329 64       		.byte	100
 13408 032a 00       		.byte	0
 13409 032b 01       		.byte	1
 13410 032c 00       		.byte	0
 13411 032d 03       		.byte	3
 13412 032e 00       		.byte	0
 13413 032f 00       		.byte	0
 13414 0330 00       		.byte	0
 13415 0331 00       		.byte	0
 13416 0332 00       		.byte	0
 13417 0333 30       		.byte	48
 13418 0334 01       		.byte	1
 13419 0335 00       		.byte	0
 13420 0336 00       		.byte	0
 13421 0337 00000000 		.space	5
 13421      00
 13422 033c 2A       		.byte	42
 13423 033d 2A       		.byte	42
 13424 033e 02       		.byte	2
 13425 033f 00       		.byte	0
 13426 0340 00       		.byte	0
 13427 0341 1B       		.byte	27
 13428 0342 00       		.byte	0
 13429 0343 01       		.byte	1
 13430 0344 00       		.byte	0
 13431 0345 03       		.byte	3
 13432 0346 00       		.byte	0
 13433 0347 00       		.byte	0
 13434 0348 00       		.byte	0
 13435 0349 00       		.byte	0
 13436 034a 00       		.byte	0
 13437 034b 30       		.byte	48
 13438 034c 01       		.byte	1
 13439 034d 00       		.byte	0
 13440 034e 00       		.byte	0
 13441 034f 00000000 		.space	5
 13441      00
 13442 0354 00       		.byte	0
 13443 0355 00       		.byte	0
 13444 0356 02       		.byte	2
 13445 0357 00       		.byte	0
 13446 0358 00       		.byte	0
 13447 0359 64       		.byte	100
 13448 035a 00       		.byte	0
 13449 035b 01       		.byte	1
 13450 035c 00       		.byte	0
 13451 035d 03       		.byte	3
 13452 035e 00       		.byte	0
 13453 035f 00       		.byte	0
 13454 0360 00       		.byte	0
 13455 0361 00       		.byte	0
 13456 0362 00       		.byte	0
 13457 0363 30       		.byte	48
 13458 0364 01       		.byte	1
 13459 0365 00       		.byte	0
 13460 0366 00       		.byte	0
 13461 0367 00000000 		.space	5
 13461      00
 13462 036c 00       		.byte	0
 13463 036d 00       		.byte	0
 13464 036e 02       		.byte	2
 13465 036f 00       		.byte	0
 13466 0370 00       		.byte	0
 13467 0371 12       		.byte	18
 13468 0372 00       		.byte	0
 13469 0373 01       		.byte	1
 13470 0374 00       		.byte	0
 13471 0375 03       		.byte	3
 13472 0376 00       		.byte	0
 13473 0377 00       		.byte	0
 13474 0378 00       		.byte	0
 13475 0379 00       		.byte	0
 13476 037a 00       		.byte	0
 13477 037b 30       		.byte	48
 13478 037c 01       		.byte	1
 13479 037d 00       		.byte	0
 13480 037e 00       		.byte	0
 13481 037f 00000000 		.space	5
 13481      00
 13482 0384 01       		.byte	1
 13483 0385 01       		.byte	1
 13484 0386 02       		.byte	2
 13485 0387 00       		.byte	0
 13486 0388 00       		.byte	0
 13487 0389 09       		.byte	9
 13488 038a 00       		.byte	0
 13489 038b 01       		.byte	1
 13490 038c 00       		.byte	0
 13491 038d 03       		.byte	3
 13492 038e 00       		.byte	0
 13493 038f 00       		.byte	0
 13494 0390 00       		.byte	0
 13495 0391 01       		.byte	1
 13496 0392 00       		.byte	0
 13497 0393 30       		.byte	48
 13498 0394 01       		.byte	1
 13499 0395 00       		.byte	0
 13500 0396 00       		.byte	0
 13501 0397 00000000 		.space	5
 13501      00
 13502 039c 05       		.byte	5
 13503 039d 05       		.byte	5
 13504 039e 02       		.byte	2
 13505 039f 00       		.byte	0
 13506 03a0 00       		.byte	0
 13507 03a1 03       		.byte	3
 13508 03a2 00       		.byte	0
 13509 03a3 01       		.byte	1
 13510 03a4 00       		.byte	0
 13511 03a5 03       		.byte	3
 13512 03a6 00       		.byte	0
 13513 03a7 00       		.byte	0
 13514 03a8 00       		.byte	0
 13515 03a9 00       		.byte	0
 13516 03aa 00       		.byte	0
 13517 03ab 30       		.byte	48
 13518 03ac 01       		.byte	1
 13519 03ad 00       		.byte	0
 13520 03ae 00       		.byte	0
 13521 03af 00000000 		.space	5
 13521      00
 13522 03b4 18       		.byte	24
 13523 03b5 18       		.byte	24
 13524 03b6 02       		.byte	2
 13525 03b7 00       		.byte	0
 13526 03b8 00       		.byte	0
 13527 03b9 01       		.byte	1
 13528 03ba 00       		.byte	0
 13529 03bb 01       		.byte	1
 13530 03bc 00       		.byte	0
 13531 03bd 03       		.byte	3
 13532 03be 00       		.byte	0
 13533 03bf 00       		.byte	0
 13534 03c0 00       		.byte	0
 13535 03c1 00       		.byte	0
 13536 03c2 00       		.byte	0
 13537 03c3 30       		.byte	48
 13538 03c4 01       		.byte	1
 13539 03c5 00       		.byte	0
 13540 03c6 00       		.byte	0
 13541 03c7 00000000 		.space	5
 13541      00
 13542 03cc 19       		.byte	25
 13543 03cd 19       		.byte	25
 13544 03ce 01       		.byte	1
 13545 03cf 00       		.byte	0
 13546 03d0 00       		.byte	0
 13547 03d1 40       		.byte	64
 13548 03d2 00       		.byte	0
 13549 03d3 01       		.byte	1
 13550 03d4 00       		.byte	0
 13551 03d5 03       		.byte	3
 13552 03d6 00       		.byte	0
 13553 03d7 20       		.byte	32
 13554 03d8 00       		.byte	0
 13555 03d9 20       		.byte	32
 13556 03da 00       		.byte	0
 13557 03db 30       		.byte	48
 13558 03dc 01       		.byte	1
 13559 03dd 00       		.byte	0
 13560 03de 00       		.byte	0
 13561 03df 00000000 		.space	5
 13561      00
 13562 03e4 20       		.byte	32
 13563 03e5 20       		.byte	32
 13564 03e6 02       		.byte	2
 13565 03e7 00       		.byte	0
 13566 03e8 00       		.byte	0
 13567 03e9 02       		.byte	2
 13568 03ea 00       		.byte	0
 13569 03eb 01       		.byte	1
 13570 03ec 00       		.byte	0
 13571 03ed 03       		.byte	3
 13572 03ee 00       		.byte	0
 13573 03ef 00       		.byte	0
 13574 03f0 00       		.byte	0
 13575 03f1 00       		.byte	0
 13576 03f2 00       		.byte	0
 13577 03f3 30       		.byte	48
 13578 03f4 01       		.byte	1
 13579 03f5 00       		.byte	0
 13580 03f6 00       		.byte	0
 13581 03f7 00000000 		.space	5
 13581      00
 13582 03fc 22       		.byte	34
 13583 03fd 22       		.byte	34
 13584 03fe 02       		.byte	2
 13585 03ff 00       		.byte	0
 13586 0400 00       		.byte	0
 13587 0401 3F       		.byte	63
 13588 0402 00       		.byte	0
 13589 0403 01       		.byte	1
 13590 0404 00       		.byte	0
 13591 0405 03       		.byte	3
 13592 0406 00       		.byte	0
 13593 0407 00       		.byte	0
 13594 0408 00       		.byte	0
 13595 0409 00       		.byte	0
 13596 040a 00       		.byte	0
 13597 040b 30       		.byte	48
 13598 040c 01       		.byte	1
 13599 040d 00       		.byte	0
 13600 040e 00       		.byte	0
 13601 040f 00000000 		.space	5
 13601      00
 13602 0414 23       		.byte	35
 13603 0415 23       		.byte	35
 13604 0416 02       		.byte	2
 13605 0417 00       		.byte	0
 13606 0418 00       		.byte	0
 13607 0419 64       		.byte	100
 13608 041a 00       		.byte	0
 13609 041b 01       		.byte	1
 13610 041c 00       		.byte	0
 13611 041d 03       		.byte	3
 13612 041e 00       		.byte	0
 13613 041f 10       		.byte	16
 13614 0420 00       		.byte	0
 13615 0421 10       		.byte	16
 13616 0422 00       		.byte	0
 13617 0423 30       		.byte	48
 13618 0424 01       		.byte	1
 13619 0425 00       		.byte	0
 13620 0426 00       		.byte	0
 13621 0427 00000000 		.space	5
 13621      00
 13622 042c 24       		.byte	36
 13623 042d 24       		.byte	36
 13624 042e 02       		.byte	2
 13625 042f 00       		.byte	0
 13626 0430 00       		.byte	0
 13627 0431 64       		.byte	100
 13628 0432 00       		.byte	0
 13629 0433 01       		.byte	1
 13630 0434 00       		.byte	0
 13631 0435 03       		.byte	3
 13632 0436 00       		.byte	0
 13633 0437 10       		.byte	16
 13634 0438 00       		.byte	0
 13635 0439 10       		.byte	16
 13636 043a 00       		.byte	0
 13637 043b 30       		.byte	48
 13638 043c 01       		.byte	1
 13639 043d 00       		.byte	0
 13640 043e 00       		.byte	0
 13641 043f 00000000 		.space	5
 13641      00
 13642 0444 02       		.byte	2
 13643 0445 03       		.byte	3
 13644 0446 04       		.byte	4
 13645 0447 00       		.byte	0
 13646 0448 00       		.byte	0
 13647 0449 7F       		.byte	127
 13648 044a 00       		.byte	0
 13649 044b 01       		.byte	1
 13650 044c 00       		.byte	0
 13651 044d 03       		.byte	3
 13652 044e 00       		.byte	0
 13653 044f 00       		.byte	0
 13654 0450 20       		.byte	32
 13655 0451 00       		.byte	0
 13656 0452 20       		.byte	32
 13657 0453 30       		.byte	48
 13658 0454 01       		.byte	1
 13659 0455 00       		.byte	0
 13660 0456 00       		.byte	0
 13661 0457 00000000 		.space	5
 13661      00
 13662 045c 04       		.byte	4
 13663 045d 04       		.byte	4
 13664 045e 02       		.byte	2
 13665 045f 00       		.byte	0
 13666 0460 00       		.byte	0
 13667 0461 FF       		.byte	-1
 13668 0462 00       		.byte	0
 13669 0463 01       		.byte	1
 13670 0464 00       		.byte	0
 13671 0465 03       		.byte	3
 13672 0466 00       		.byte	0
 13673 0467 60       		.byte	96
 13674 0468 00       		.byte	0
 13675 0469 60       		.byte	96
 13676 046a 00       		.byte	0
 13677 046b 30       		.byte	48
 13678 046c 01       		.byte	1
 13679 046d 00       		.byte	0
 13680 046e 00       		.byte	0
 13681 046f 00000000 		.space	5
 13681      00
 13682 0474 00       		.byte	0
 13683 0475 00       		.byte	0
 13684 0476 02       		.byte	2
 13685 0477 00       		.byte	0
 13686 0478 00       		.byte	0
 13687 0479 19       		.byte	25
 13688 047a 00       		.byte	0
 13689 047b 01       		.byte	1
 13690 047c 00       		.byte	0
 13691 047d 03       		.byte	3
 13692 047e 00       		.byte	0
 13693 047f 00       		.byte	0
 13694 0480 00       		.byte	0
 13695 0481 00       		.byte	0
 13696 0482 00       		.byte	0
 13697 0483 30       		.byte	48
 13698 0484 01       		.byte	1
 13699 0485 00       		.byte	0
 13700 0486 00       		.byte	0
 13701 0487 00000000 		.space	5
 13701      00
 13702 048c 10       		.byte	16
 13703 048d 10       		.byte	16
 13704 048e 02       		.byte	2
 13705 048f 00       		.byte	0
 13706 0490 00       		.byte	0
 13707 0491 06       		.byte	6
 13708 0492 00       		.byte	0
 13709 0493 01       		.byte	1
 13710 0494 00       		.byte	0
 13711 0495 03       		.byte	3
 13712 0496 00       		.byte	0
 13713 0497 03       		.byte	3
 13714 0498 00       		.byte	0
 13715 0499 03       		.byte	3
 13716 049a 00       		.byte	0
 13717 049b 30       		.byte	48
 13718 049c 01       		.byte	1
 13719 049d 00       		.byte	0
 13720 049e 00       		.byte	0
 13721 049f 00000000 		.space	5
 13721      00
 13722 04a4 00       		.byte	0
 13723 04a5 00       		.byte	0
 13724 04a6 02       		.byte	2
 13725 04a7 00       		.byte	0
 13726 04a8 00       		.byte	0
 13727 04a9 03       		.byte	3
 13728 04aa 00       		.byte	0
 13729 04ab 01       		.byte	1
 13730 04ac 00       		.byte	0
 13731 04ad 03       		.byte	3
 13732 04ae 00       		.byte	0
 13733 04af 00       		.byte	0
 13734 04b0 00       		.byte	0
 13735 04b1 00       		.byte	0
 13736 04b2 00       		.byte	0
 13737 04b3 30       		.byte	48
 13738 04b4 01       		.byte	1
 13739 04b5 00       		.byte	0
 13740 04b6 00       		.byte	0
 13741 04b7 00000000 		.space	5
 13741      00
 13742 04bc 50       		.byte	80
 13743 04bd 50       		.byte	80
 13744 04be 01       		.byte	1
 13745 04bf 00       		.byte	0
 13746 04c0 00       		.byte	0
 13747 04c1 03       		.byte	3
 13748 04c2 00       		.byte	0
 13749 04c3 01       		.byte	1
 13750 04c4 00       		.byte	0
 13751 04c5 03       		.byte	3
 13752 04c6 00       		.byte	0
 13753 04c7 00       		.byte	0
 13754 04c8 00       		.byte	0
 13755 04c9 00       		.byte	0
 13756 04ca 00       		.byte	0
 13757 04cb 30       		.byte	48
 13758 04cc 01       		.byte	1
 13759 04cd 00       		.byte	0
 13760 04ce 00       		.byte	0
 13761 04cf 00000000 		.space	5
 13761      00
 13762 04d4 00       		.byte	0
 13763 04d5 00       		.byte	0
 13764 04d6 0B       		.byte	11
 13765 04d7 00       		.byte	0
 13766 04d8 00       		.byte	0
 13767 04d9 FF       		.byte	-1
 13768 04da FF       		.byte	-1
 13769 04db 01       		.byte	1
 13770 04dc 00       		.byte	0
 13771 04dd 03       		.byte	3
 13772 04de 00       		.byte	0
 13773 04df 00       		.byte	0
 13774 04e0 00       		.byte	0
 13775 04e1 00       		.byte	0
 13776 04e2 00       		.byte	0
 13777 04e3 00       		.byte	0
 13778 04e4 01       		.byte	1
 13779 04e5 00       		.byte	0
 13780 04e6 00       		.byte	0
 13781 04e7 00000000 		.space	5
 13781      00
 13784              	glUVCHeader:
 13785 04ec 0C       		.byte	12
 13786 04ed 8C       		.byte	-116
 13787 04ee 00       		.byte	0
 13788 04ef 00       		.byte	0
 13789 04f0 00       		.byte	0
 13790 04f1 00       		.byte	0
 13791 04f2 00       		.byte	0
 13792 04f3 00       		.byte	0
 13793 04f4 00       		.byte	0
 13794 04f5 00       		.byte	0
 13795 04f6 00       		.byte	0
 13796 04f7 00       		.byte	0
 13799              	EXTBLCWinPos:
 13800 04f8 14       		.byte	20
 13801 04f9 13       		.byte	19
 13802 04fa 02       		.byte	2
 13803 04fb 00       		.byte	0
 13804 04fc 00       		.byte	0
 13805 04fd FF       		.byte	-1
 13806 04fe FF       		.byte	-1
 13807 04ff 01       		.byte	1
 13808 0500 00       		.byte	0
 13809 0501 03       		.byte	3
 13810 0502 00       		.byte	0
 13811 0503 66       		.byte	102
 13812 0504 66       		.byte	102
 13813 0505 66       		.byte	102
 13814 0506 66       		.byte	102
 13815 0507 30       		.byte	48
 13816 0508 01       		.byte	1
 13817 0509 00       		.byte	0
 13818 050a 0000     		.space	2
 13821              	EXTBLCWeight:
 13822 050c 11       		.byte	17
 13823 050d 11       		.byte	17
 13824 050e 02       		.byte	2
 13825 050f 00       		.byte	0
 13826 0510 00       		.byte	0
 13827 0511 FF       		.byte	-1
 13828 0512 00       		.byte	0
 13829 0513 01       		.byte	1
 13830 0514 00       		.byte	0
 13831 0515 03       		.byte	3
 13832 0516 00       		.byte	0
 13833 0517 80       		.byte	-128
 13834 0518 00       		.byte	0
 13835 0519 80       		.byte	-128
 13836 051a 00       		.byte	0
 13837 051b 30       		.byte	48
 13838 051c 01       		.byte	1
 13839 051d 00       		.byte	0
 13840 051e 0000     		.space	2
 13843              	EXTShutter:
 13844 0520 00       		.byte	0
 13845 0521 02       		.byte	2
 13846 0522 02       		.byte	2
 13847 0523 00       		.byte	0
 13848 0524 00       		.byte	0
 13849 0525 08       		.byte	8
 13850 0526 00       		.byte	0
 13851 0527 01       		.byte	1
 13852 0528 00       		.byte	0
 13853 0529 03       		.byte	3
 13854 052a 00       		.byte	0
 13855 052b 00       		.byte	0
 13856 052c 00       		.byte	0
 13857 052d 00       		.byte	0
 13858 052e 00       		.byte	0
 13859 052f 30       		.byte	48
 13860 0530 01       		.byte	1
 13861 0531 00       		.byte	0
 13862 0532 0000     		.space	2
 13865              	EXTShutlev:
 13866 0534 02       		.byte	2
 13867 0535 12       		.byte	18
 13868 0536 02       		.byte	2
 13869 0537 00       		.byte	0
 13870 0538 00       		.byte	0
 13871 0539 FF       		.byte	-1
 13872 053a 7F       		.byte	127
 13873 053b 01       		.byte	1
 13874 053c 00       		.byte	0
 13875 053d 03       		.byte	3
 13876 053e 00       		.byte	0
 13877 053f 3F       		.byte	63
 13878 0540 00       		.byte	0
 13879 0541 3F       		.byte	63
 13880 0542 00       		.byte	0
 13881 0543 30       		.byte	48
 13882 0544 01       		.byte	1
 13883 0545 00       		.byte	0
 13884 0546 0000     		.space	2
 13887              	EXTAexModGainlev:
 13888 0548 00       		.byte	0
 13889 0549 03       		.byte	3
 13890 054a 04       		.byte	4
 13891 054b 00       		.byte	0
 13892 054c 00       		.byte	0
 13893 054d 03       		.byte	3
 13894 054e 7F       		.byte	127
 13895 054f 01       		.byte	1
 13896 0550 00       		.byte	0
 13897 0551 03       		.byte	3
 13898 0552 00       		.byte	0
 13899 0553 00       		.byte	0
 13900 0554 3F       		.byte	63
 13901 0555 00       		.byte	0
 13902 0556 3F       		.byte	63
 13903 0557 30       		.byte	48
 13904 0558 01       		.byte	1
 13905 0559 00       		.byte	0
 13906 055a 0000     		.space	2
 13909              	WBMenuCmpArry:
 13910 055c 20       		.byte	32
 13911 055d 0F       		.byte	15
 13912 055e 38       		.byte	56
 13913 055f F0       		.byte	-16
 13916              	PUCBLC:
 13917 0560 10       		.byte	16
 13918 0561 11       		.byte	17
 13919 0562 02       		.byte	2
 13920 0563 00       		.byte	0
 13921 0564 00       		.byte	0
 13922 0565 03       		.byte	3
 13923 0566 00       		.byte	0
 13924 0567 01       		.byte	1
 13925 0568 00       		.byte	0
 13926 0569 03       		.byte	3
 13927 056a 00       		.byte	0
 13928 056b 03       		.byte	3
 13929 056c 00       		.byte	0
 13930 056d 03       		.byte	3
 13931 056e 00       		.byte	0
 13932 056f 30       		.byte	48
 13933 0570 01       		.byte	1
 13934 0571 00       		.byte	0
 13935 0572 0000     		.space	2
 13938              	PUCSharp:
 13939 0574 06       		.byte	6
 13940 0575 07       		.byte	7
 13941 0576 02       		.byte	2
 13942 0577 00       		.byte	0
 13943 0578 00       		.byte	0
 13944 0579 08       		.byte	8
 13945 057a 00       		.byte	0
 13946 057b 01       		.byte	1
 13947 057c 00       		.byte	0
 13948 057d 03       		.byte	3
 13949 057e 00       		.byte	0
 13950 057f 00       		.byte	0
 13951 0580 00       		.byte	0
 13952 0581 00       		.byte	0
 13953 0582 00       		.byte	0
 13954 0583 30       		.byte	48
 13955 0584 01       		.byte	1
 13956 0585 00       		.byte	0
 13957 0586 0000     		.space	2
 13960              	CTCtrlParArry:
 13961 0588 00       		.byte	0
 13962 0589 00       		.byte	0
 13963 058a 01       		.byte	1
 13964 058b 00       		.byte	0
 13965 058c 00       		.byte	0
 13966 058d 03       		.byte	3
 13967 058e 00       		.byte	0
 13968 058f 01       		.byte	1
 13969 0590 00       		.byte	0
 13970 0591 03       		.byte	3
 13971 0592 00       		.byte	0
 13972 0593 03       		.byte	3
 13973 0594 00       		.byte	0
 13974 0595 03       		.byte	3
 13975 0596 00       		.byte	0
 13976 0597 30       		.byte	48
 13977 0598 01       		.byte	1
 13978 0599 00       		.byte	0
 13979 059a 00       		.byte	0
 13980 059b 00000000 		.space	5
 13980      00
 13981 05a0 00       		.byte	0
 13982 05a1 00       		.byte	0
 13983 05a2 01       		.byte	1
 13984 05a3 01       		.byte	1
 13985 05a4 00       		.byte	0
 13986 05a5 0F       		.byte	15
 13987 05a6 00       		.byte	0
 13988 05a7 0F       		.byte	15
 13989 05a8 00       		.byte	0
 13990 05a9 03       		.byte	3
 13991 05aa 00       		.byte	0
 13992 05ab 02       		.byte	2
 13993 05ac 00       		.byte	0
 13994 05ad 02       		.byte	2
 13995 05ae 00       		.byte	0
 13996 05af 30       		.byte	48
 13997 05b0 01       		.byte	1
 13998 05b1 01       		.byte	1
 13999 05b2 00       		.byte	0
 14000 05b3 00000000 		.space	5
 14000      00
 14001 05b8 02       		.byte	2
 14002 05b9 00       		.byte	0
 14003 05ba 01       		.byte	1
 14004 05bb 00       		.byte	0
 14005 05bc 00       		.byte	0
 14006 05bd 01       		.byte	1
 14007 05be 00       		.byte	0
 14008 05bf 01       		.byte	1
 14009 05c0 00       		.byte	0
 14010 05c1 03       		.byte	3
 14011 05c2 00       		.byte	0
 14012 05c3 00       		.byte	0
 14013 05c4 00       		.byte	0
 14014 05c5 00       		.byte	0
 14015 05c6 00       		.byte	0
 14016 05c7 30       		.byte	48
 14017 05c8 01       		.byte	1
 14018 05c9 01       		.byte	1
 14019 05ca 00       		.byte	0
 14020 05cb 00000000 		.space	5
 14020      00
 14021 05d0 00       		.byte	0
 14022 05d1 00       		.byte	0
 14023 05d2 04       		.byte	4
 14024 05d3 01       		.byte	1
 14025 05d4 00       		.byte	0
 14026 05d5 38       		.byte	56
 14027 05d6 01       		.byte	1
 14028 05d7 01       		.byte	1
 14029 05d8 00       		.byte	0
 14030 05d9 03       		.byte	3
 14031 05da 00       		.byte	0
 14032 05db 4E       		.byte	78
 14033 05dc 00       		.byte	0
 14034 05dd 4E       		.byte	78
 14035 05de 00       		.byte	0
 14036 05df 30       		.byte	48
 14037 05e0 01       		.byte	1
 14038 05e1 00       		.byte	0
 14039 05e2 00       		.byte	0
 14040 05e3 00000000 		.space	5
 14040      00
 14041 05e8 04       		.byte	4
 14042 05e9 00       		.byte	0
 14043 05ea 01       		.byte	1
 14044 05eb 00       		.byte	0
 14045 05ec 00       		.byte	0
 14046 05ed 00       		.byte	0
 14047 05ee 00       		.byte	0
 14048 05ef 01       		.byte	1
 14049 05f0 00       		.byte	0
 14050 05f1 03       		.byte	3
 14051 05f2 00       		.byte	0
 14052 05f3 00       		.byte	0
 14053 05f4 00       		.byte	0
 14054 05f5 00       		.byte	0
 14055 05f6 00       		.byte	0
 14056 05f7 30       		.byte	48
 14057 05f8 01       		.byte	1
 14058 05f9 00       		.byte	0
 14059 05fa 00       		.byte	0
 14060 05fb 00000000 		.space	5
 14060      00
 14061 0600 05       		.byte	5
 14062 0601 00       		.byte	0
 14063 0602 02       		.byte	2
 14064 0603 00       		.byte	0
 14065 0604 00       		.byte	0
 14066 0605 FF       		.byte	-1
 14067 0606 00       		.byte	0
 14068 0607 01       		.byte	1
 14069 0608 00       		.byte	0
 14070 0609 03       		.byte	3
 14071 060a 00       		.byte	0
 14072 060b 01       		.byte	1
 14073 060c 00       		.byte	0
 14074 060d 00       		.byte	0
 14075 060e 00       		.byte	0
 14076 060f 30       		.byte	48
 14077 0610 01       		.byte	1
 14078 0611 01       		.byte	1
 14079 0612 00       		.byte	0
 14080 0613 00000000 		.space	5
 14080      00
 14081 0618 06       		.byte	6
 14082 0619 00       		.byte	0
 14083 061a 02       		.byte	2
 14084 061b 00       		.byte	0
 14085 061c 00       		.byte	0
 14086 061d 00       		.byte	0
 14087 061e 00       		.byte	0
 14088 061f 00       		.byte	0
 14089 0620 00       		.byte	0
 14090 0621 03       		.byte	3
 14091 0622 00       		.byte	0
 14092 0623 00       		.byte	0
 14093 0624 00       		.byte	0
 14094 0625 00       		.byte	0
 14095 0626 00       		.byte	0
 14096 0627 30       		.byte	48
 14097 0628 01       		.byte	1
 14098 0629 01       		.byte	1
 14099 062a 00       		.byte	0
 14100 062b 00000000 		.space	5
 14100      00
 14101 0630 23       		.byte	35
 14102 0631 00       		.byte	0
 14103 0632 02       		.byte	2
 14104 0633 00       		.byte	0
 14105 0634 00       		.byte	0
 14106 0635 30       		.byte	48
 14107 0636 00       		.byte	0
 14108 0637 01       		.byte	1
 14109 0638 00       		.byte	0
 14110 0639 03       		.byte	3
 14111 063a 0A       		.byte	10
 14112 063b 00       		.byte	0
 14113 063c 00       		.byte	0
 14114 063d 0A       		.byte	10
 14115 063e 00       		.byte	0
 14116 063f 30       		.byte	48
 14117 0640 01       		.byte	1
 14118 0641 01       		.byte	1
 14119 0642 00       		.byte	0
 14120 0643 00000000 		.space	5
 14120      00
 14121 0648 08       		.byte	8
 14122 0649 00       		.byte	0
 14123 064a 01       		.byte	1
 14124 064b 00       		.byte	0
 14125 064c 00       		.byte	0
 14126 064d 7F       		.byte	127
 14127 064e 00       		.byte	0
 14128 064f 01       		.byte	1
 14129 0650 00       		.byte	0
 14130 0651 03       		.byte	3
 14131 0652 00       		.byte	0
 14132 0653 00       		.byte	0
 14133 0654 00       		.byte	0
 14134 0655 00       		.byte	0
 14135 0656 00       		.byte	0
 14136 0657 30       		.byte	48
 14137 0658 01       		.byte	1
 14138 0659 00       		.byte	0
 14139 065a 00       		.byte	0
 14140 065b 00000000 		.space	5
 14140      00
 14141 0660 09       		.byte	9
 14142 0661 00       		.byte	0
 14143 0662 02       		.byte	2
 14144 0663 00       		.byte	0
 14145 0664 00       		.byte	0
 14146 0665 05       		.byte	5
 14147 0666 00       		.byte	0
 14148 0667 01       		.byte	1
 14149 0668 00       		.byte	0
 14150 0669 03       		.byte	3
 14151 066a 00       		.byte	0
 14152 066b 00       		.byte	0
 14153 066c 00       		.byte	0
 14154 066d 00       		.byte	0
 14155 066e 00       		.byte	0
 14156 066f 30       		.byte	48
 14157 0670 01       		.byte	1
 14158 0671 00       		.byte	0
 14159 0672 00       		.byte	0
 14160 0673 00000000 		.space	5
 14160      00
 14161 0678 10       		.byte	16
 14162 0679 00       		.byte	0
 14163 067a 03       		.byte	3
 14164 067b 00       		.byte	0
 14165 067c 00       		.byte	0
 14166 067d 00       		.byte	0
 14167 067e 00       		.byte	0
 14168 067f 00       		.byte	0
 14169 0680 00       		.byte	0
 14170 0681 03       		.byte	3
 14171 0682 00       		.byte	0
 14172 0683 00       		.byte	0
 14173 0684 00       		.byte	0
 14174 0685 00       		.byte	0
 14175 0686 00       		.byte	0
 14176 0687 30       		.byte	48
 14177 0688 01       		.byte	1
 14178 0689 00       		.byte	0
 14179 068a 00       		.byte	0
 14180 068b 00000000 		.space	5
 14180      00
 14181 0690 00       		.byte	0
 14182 0691 00       		.byte	0
 14183 0692 02       		.byte	2
 14184 0693 00       		.byte	0
 14185 0694 00       		.byte	0
 14186 0695 40       		.byte	64
 14187 0696 00       		.byte	0
 14188 0697 01       		.byte	1
 14189 0698 00       		.byte	0
 14190 0699 03       		.byte	3
 14191 069a 00       		.byte	0
 14192 069b 0F       		.byte	15
 14193 069c 11       		.byte	17
 14194 069d 00       		.byte	0
 14195 069e 00       		.byte	0
 14196 069f 30       		.byte	48
 14197 06a0 01       		.byte	1
 14198 06a1 00       		.byte	0
 14199 06a2 00       		.byte	0
 14200 06a3 00000000 		.space	5
 14200      00
 14201 06a8 00       		.byte	0
 14202 06a9 00       		.byte	0
 14203 06aa 02       		.byte	2
 14204 06ab 00       		.byte	0
 14205 06ac 00       		.byte	0
 14206 06ad 64       		.byte	100
 14207 06ae 00       		.byte	0
 14208 06af 01       		.byte	1
 14209 06b0 00       		.byte	0
 14210 06b1 03       		.byte	3
 14211 06b2 00       		.byte	0
 14212 06b3 00       		.byte	0
 14213 06b4 00       		.byte	0
 14214 06b5 00       		.byte	0
 14215 06b6 00       		.byte	0
 14216 06b7 30       		.byte	48
 14217 06b8 01       		.byte	1
 14218 06b9 00       		.byte	0
 14219 06ba 00       		.byte	0
 14220 06bb 00000000 		.space	5
 14220      00
 14221 06c0 00       		.byte	0
 14222 06c1 00       		.byte	0
 14223 06c2 02       		.byte	2
 14224 06c3 00       		.byte	0
 14225 06c4 00       		.byte	0
 14226 06c5 64       		.byte	100
 14227 06c6 00       		.byte	0
 14228 06c7 01       		.byte	1
 14229 06c8 00       		.byte	0
 14230 06c9 03       		.byte	3
 14231 06ca 00       		.byte	0
 14232 06cb 00       		.byte	0
 14233 06cc 00       		.byte	0
 14234 06cd 00       		.byte	0
 14235 06ce 00       		.byte	0
 14236 06cf 30       		.byte	48
 14237 06d0 01       		.byte	1
 14238 06d1 00       		.byte	0
 14239 06d2 00       		.byte	0
 14240 06d3 00000000 		.space	5
 14240      00
 14241 06d8 00       		.byte	0
 14242 06d9 00       		.byte	0
 14243 06da 02       		.byte	2
 14244 06db 00       		.byte	0
 14245 06dc 00       		.byte	0
 14246 06dd 64       		.byte	100
 14247 06de 00       		.byte	0
 14248 06df 01       		.byte	1
 14249 06e0 00       		.byte	0
 14250 06e1 03       		.byte	3
 14251 06e2 00       		.byte	0
 14252 06e3 00       		.byte	0
 14253 06e4 00       		.byte	0
 14254 06e5 00       		.byte	0
 14255 06e6 00       		.byte	0
 14256 06e7 30       		.byte	48
 14257 06e8 01       		.byte	1
 14258 06e9 00       		.byte	0
 14259 06ea 00       		.byte	0
 14260 06eb 00000000 		.space	5
 14260      00
 14261 06f0 00       		.byte	0
 14262 06f1 00       		.byte	0
 14263 06f2 02       		.byte	2
 14264 06f3 00       		.byte	0
 14265 06f4 00       		.byte	0
 14266 06f5 64       		.byte	100
 14267 06f6 00       		.byte	0
 14268 06f7 01       		.byte	1
 14269 06f8 00       		.byte	0
 14270 06f9 03       		.byte	3
 14271 06fa 00       		.byte	0
 14272 06fb 00       		.byte	0
 14273 06fc 00       		.byte	0
 14274 06fd 00       		.byte	0
 14275 06fe 00       		.byte	0
 14276 06ff 30       		.byte	48
 14277 0700 01       		.byte	1
 14278 0701 00       		.byte	0
 14279 0702 00       		.byte	0
 14280 0703 00000000 		.space	5
 14280      00
 14283              	snapButFlag:
 14284 0708 01       		.byte	1
 14285 0709 000000   		.space	3
 14288              	CyFxGpifRegValue_usb2:
 14289 070c 08830080 		.word	-2147450104
 14290 0710 67000000 		.word	103
 14291 0714 01000000 		.word	1
 14292 0718 46000000 		.word	70
 14293 071c 00000000 		.word	0
 14294 0720 00000000 		.word	0
 14295 0724 02000000 		.word	2
 14296 0728 82000000 		.word	130
 14297 072c 82070000 		.word	1922
 14298 0730 40040000 		.word	1088
 14299 0734 FCFF0000 		.word	65532
 14300 0738 28000000 		.word	40
 14301 073c 00000000 		.word	0
 14302 0740 00000000 		.word	0
 14303 0744 00000000 		.word	0
 14304 0748 00000000 		.word	0
 14305 074c 01000000 		.word	1
 14306 0750 00000000 		.word	0
 14307 0754 00000000 		.word	0
 14308 0758 00000000 		.word	0
 14309 075c 00000000 		.word	0
 14310 0760 00000000 		.word	0
 14311 0764 00000000 		.word	0
 14312 0768 00000000 		.word	0
 14313 076c 00000000 		.word	0
 14314 0770 00000000 		.word	0
 14315 0774 00000000 		.word	0
 14316 0778 00000000 		.word	0
 14317 077c 00000000 		.word	0
 14318 0780 06000000 		.word	6
 14319 0784 00000000 		.word	0
 14320 0788 FFFF0000 		.word	65535
 14321 078c 09010000 		.word	265
 14322 0790 00000000 		.word	0
 14323 0794 F71F0000 		.word	8183
 14324 0798 00000000 		.word	0
 14325 079c FFFF0000 		.word	65535
 14326 07a0 09010000 		.word	265
 14327 07a4 00000000 		.word	0
 14328 07a8 F71F0000 		.word	8183
 14329 07ac 00000000 		.word	0
 14330 07b0 00000000 		.word	0
 14331 07b4 00000000 		.word	0
 14332 07b8 00000000 		.word	0
 14333 07bc 00000000 		.word	0
 14334 07c0 00000000 		.word	0
 14335 07c4 00000000 		.word	0
 14336 07c8 00000000 		.word	0
 14337 07cc 00000000 		.word	0
 14338 07d0 00000000 		.word	0
 14339 07d4 00000000 		.word	0
 14340 07d8 00000000 		.word	0
 14341 07dc 00000000 		.word	0
 14342 07e0 00000000 		.word	0
 14343 07e4 00000000 		.word	0
 14344 07e8 00000000 		.word	0
 14345 07ec 00000000 		.word	0
 14346 07f0 00000000 		.word	0
 14347 07f4 00000000 		.word	0
 14348 07f8 00000000 		.word	0
 14349 07fc 00000000 		.word	0
 14350 0800 00000000 		.word	0
 14351 0804 00000000 		.word	0
 14352 0808 00040180 		.word	-2147417088
 14353 080c 01040180 		.word	-2147417087
 14354 0810 02040180 		.word	-2147417086
 14355 0814 03040180 		.word	-2147417085
 14356 0818 00000000 		.word	0
 14357 081c 00000000 		.word	0
 14358 0820 00000000 		.word	0
 14359 0824 00000000 		.word	0
 14360 0828 00000000 		.word	0
 14361 082c 00000000 		.word	0
 14362 0830 00000000 		.word	0
 14363 0834 00000000 		.word	0
 14364 0838 C1FFFFFF 		.word	-63
 14367              	CyFxGpifWavedataPosition_usb2:
 14368 083c 00       		.byte	0
 14369 083d 01       		.byte	1
 14370 083e 02       		.byte	2
 14371 083f 03       		.byte	3
 14372 0840 04       		.byte	4
 14373 0841 05       		.byte	5
 14374 0842 06       		.byte	6
 14375 0843 07       		.byte	7
 14376 0844 08       		.byte	8
 14377 0845 09       		.byte	9
 14378 0846 0A       		.byte	10
 14379 0847 08       		.byte	8
 14380 0848 0B       		.byte	11
 14381 0849 0C       		.byte	12
 14382 084a 0D       		.byte	13
 14383 084b 08       		.byte	8
 14384 084c 0E       		.byte	14
 14385 084d 0F       		.byte	15
 14386 084e 08       		.byte	8
 14387 084f 08       		.byte	8
 14388 0850 08       		.byte	8
 14389 0851 08       		.byte	8
 14390 0852 08       		.byte	8
 14391 0853 08       		.byte	8
 14392 0854 08       		.byte	8
 14393 0855 08       		.byte	8
 14394 0856 08       		.byte	8
 14395 0857 08       		.byte	8
 14396 0858 08       		.byte	8
 14397 0859 08       		.byte	8
 14398 085a 08       		.byte	8
 14399 085b 08       		.byte	8
 14400 085c 08       		.byte	8
 14401 085d 08       		.byte	8
 14402 085e 08       		.byte	8
 14403 085f 08       		.byte	8
 14404 0860 08       		.byte	8
 14405 0861 08       		.byte	8
 14406 0862 08       		.byte	8
 14407 0863 08       		.byte	8
 14408 0864 08       		.byte	8
 14409 0865 08       		.byte	8
 14410 0866 08       		.byte	8
 14411 0867 08       		.byte	8
 14412 0868 08       		.byte	8
 14413 0869 08       		.byte	8
 14414 086a 08       		.byte	8
 14415 086b 08       		.byte	8
 14416 086c 08       		.byte	8
 14417 086d 08       		.byte	8
 14418 086e 08       		.byte	8
 14419 086f 08       		.byte	8
 14420 0870 08       		.byte	8
 14421 0871 08       		.byte	8
 14422 0872 08       		.byte	8
 14423 0873 08       		.byte	8
 14424 0874 08       		.byte	8
 14425 0875 08       		.byte	8
 14426 0876 08       		.byte	8
 14427 0877 08       		.byte	8
 14428 0878 08       		.byte	8
 14429 0879 08       		.byte	8
 14430 087a 08       		.byte	8
 14431 087b 08       		.byte	8
 14432 087c 08       		.byte	8
 14433 087d 08       		.byte	8
 14434 087e 08       		.byte	8
 14435 087f 08       		.byte	8
 14436 0880 08       		.byte	8
 14437 0881 08       		.byte	8
 14438 0882 08       		.byte	8
 14439 0883 08       		.byte	8
 14440 0884 08       		.byte	8
 14441 0885 08       		.byte	8
 14442 0886 08       		.byte	8
 14443 0887 08       		.byte	8
 14444 0888 08       		.byte	8
 14445 0889 08       		.byte	8
 14446 088a 08       		.byte	8
 14447 088b 08       		.byte	8
 14448 088c 08       		.byte	8
 14449 088d 08       		.byte	8
 14450 088e 08       		.byte	8
 14451 088f 08       		.byte	8
 14452 0890 08       		.byte	8
 14453 0891 08       		.byte	8
 14454 0892 08       		.byte	8
 14455 0893 08       		.byte	8
 14456 0894 08       		.byte	8
 14457 0895 08       		.byte	8
 14458 0896 08       		.byte	8
 14459 0897 08       		.byte	8
 14460 0898 08       		.byte	8
 14461 0899 08       		.byte	8
 14462 089a 08       		.byte	8
 14463 089b 08       		.byte	8
 14464 089c 08       		.byte	8
 14465 089d 08       		.byte	8
 14466 089e 08       		.byte	8
 14467 089f 08       		.byte	8
 14468 08a0 08       		.byte	8
 14469 08a1 08       		.byte	8
 14470 08a2 08       		.byte	8
 14471 08a3 08       		.byte	8
 14472 08a4 08       		.byte	8
 14473 08a5 08       		.byte	8
 14474 08a6 08       		.byte	8
 14475 08a7 08       		.byte	8
 14476 08a8 08       		.byte	8
 14477 08a9 08       		.byte	8
 14478 08aa 08       		.byte	8
 14479 08ab 08       		.byte	8
 14480 08ac 08       		.byte	8
 14481 08ad 08       		.byte	8
 14482 08ae 08       		.byte	8
 14483 08af 08       		.byte	8
 14484 08b0 08       		.byte	8
 14485 08b1 08       		.byte	8
 14486 08b2 08       		.byte	8
 14487 08b3 08       		.byte	8
 14488 08b4 08       		.byte	8
 14489 08b5 08       		.byte	8
 14490 08b6 08       		.byte	8
 14491 08b7 08       		.byte	8
 14492 08b8 08       		.byte	8
 14493 08b9 08       		.byte	8
 14494 08ba 08       		.byte	8
 14495 08bb 08       		.byte	8
 14496 08bc 00       		.byte	0
 14497 08bd 01       		.byte	1
 14498 08be 02       		.byte	2
 14499 08bf 10       		.byte	16
 14500 08c0 04       		.byte	4
 14501 08c1 05       		.byte	5
 14502 08c2 06       		.byte	6
 14503 08c3 07       		.byte	7
 14504 08c4 08       		.byte	8
 14505 08c5 09       		.byte	9
 14506 08c6 0A       		.byte	10
 14507 08c7 08       		.byte	8
 14508 08c8 11       		.byte	17
 14509 08c9 0C       		.byte	12
 14510 08ca 0D       		.byte	13
 14511 08cb 08       		.byte	8
 14512 08cc 0E       		.byte	14
 14513 08cd 0F       		.byte	15
 14514 08ce 08       		.byte	8
 14515 08cf 00       		.space	1
 14518              	CyFxGpifWavedata_usb2:
 14519 08d0 0181731E 		.word	510886145
 14520 08d4 00000000 		.word	0
 14521 08d8 00000080 		.word	-2147483648
 14522 08dc 00000000 		.word	0
 14523 08e0 00000000 		.word	0
 14524 08e4 00000000 		.word	0
 14525 08e8 0201703E 		.word	1047527682
 14526 08ec 00010000 		.word	256
 14527 08f0 A00000C0 		.word	-1073741664
 14528 08f4 00000000 		.word	0
 14529 08f8 00000000 		.word	0
 14530 08fc 00000000 		.word	0
 14531 0900 0394731E 		.word	510891011
 14532 0904 04000020 		.word	536870916
 14533 0908 60004080 		.word	-2143289248
 14534 090c 00000000 		.word	0
 14535 0910 00000000 		.word	0
 14536 0914 00000000 		.word	0
 14537 0918 0620702E 		.word	779100166
 14538 091c 0C000000 		.word	12
 14539 0920 00000080 		.word	-2147483648
 14540 0924 0620702E 		.word	779100166
 14541 0928 0C000000 		.word	12
 14542 092c 00000080 		.word	-2147483648
 14543 0930 0394731E 		.word	510891011
 14544 0934 04000020 		.word	536870916
 14545 0938 60004080 		.word	-2143289248
 14546 093c 0620702E 		.word	779100166
 14547 0940 0C000000 		.word	12
 14548 0944 00000080 		.word	-2147483648
 14549 0948 0C93731E 		.word	510890764
 14550 094c 04000024 		.word	603979780
 14551 0950 90004080 		.word	-2143289200
 14552 0954 0D20702E 		.word	779100173
 14553 0958 0C000000 		.word	12
 14554 095c 00000080 		.word	-2147483648
 14555 0960 0780724E 		.word	1316126727
 14556 0964 0A000000 		.word	10
 14557 0968 00000080 		.word	-2147483648
 14558 096c 08000000 		.word	8
 14559 0970 00000000 		.word	0
 14560 0974 00010080 		.word	-2147483392
 14561 0978 0920702E 		.word	779100169
 14562 097c 0C010000 		.word	268
 14563 0980 00000080 		.word	-2147483648
 14564 0984 0A01701E 		.word	510656778
 14565 0988 0E000100 		.word	65550
 14566 098c 00000080 		.word	-2147483648
 14567 0990 00000000 		.word	0
 14568 0994 00000000 		.word	0
 14569 0998 00000000 		.word	0
 14570 099c 00000000 		.word	0
 14571 09a0 00000000 		.word	0
 14572 09a4 00000000 		.word	0
 14573 09a8 0394731E 		.word	510891011
 14574 09ac 04000020 		.word	536870916
 14575 09b0 60004080 		.word	-2143289248
 14576 09b4 08000000 		.word	8
 14577 09b8 00000000 		.word	0
 14578 09bc 00010080 		.word	-2147483392
 14579 09c0 0B000000 		.word	11
 14580 09c4 00000000 		.word	0
 14581 09c8 00010080 		.word	-2147483392
 14582 09cc 0C93731E 		.word	510890764
 14583 09d0 04000024 		.word	603979780
 14584 09d4 90004080 		.word	-2143289200
 14585 09d8 0D20702E 		.word	779100173
 14586 09dc 0C000000 		.word	12
 14587 09e0 00000080 		.word	-2147483648
 14588 09e4 0D20702E 		.word	779100173
 14589 09e8 0C000000 		.word	12
 14590 09ec 00000080 		.word	-2147483648
 14591 09f0 0E60724E 		.word	1316118542
 14592 09f4 0A000000 		.word	10
 14593 09f8 00000080 		.word	-2147483648
 14594 09fc 0F000000 		.word	15
 14595 0a00 00000000 		.word	0
 14596 0a04 00010080 		.word	-2147483392
 14597 0a08 1020702E 		.word	779100176
 14598 0a0c 0C010000 		.word	268
 14599 0a10 00000080 		.word	-2147483648
 14600 0a14 1101701E 		.word	510656785
 14601 0a18 0E000100 		.word	65550
 14602 0a1c 00000080 		.word	-2147483648
 14603 0a20 0C93731E 		.word	510890764
 14604 0a24 04000024 		.word	603979780
 14605 0a28 90004080 		.word	-2143289200
 14606 0a2c 0F000000 		.word	15
 14607 0a30 00000000 		.word	0
 14608 0a34 00010080 		.word	-2147483392
 14609 0a38 12000000 		.word	18
 14610 0a3c 00000000 		.word	0
 14611 0a40 00010080 		.word	-2147483392
 14612 0a44 0394731E 		.word	510891011
 14613 0a48 04000020 		.word	536870916
 14614 0a4c 60004080 		.word	-2143289248
 14615 0a50 0480732E 		.word	779321348
 14616 0a54 02010000 		.word	258
 14617 0a58 0000C0C0 		.word	-1061158912
 14618 0a5c 0580732E 		.word	779321349
 14619 0a60 02010000 		.word	258
 14620 0a64 0000C0C0 		.word	-1061158912
 14621 0a68 0580732E 		.word	779321349
 14622 0a6c 02010000 		.word	258
 14623 0a70 0000C0C0 		.word	-1061158912
 14624 0a74 0480732E 		.word	779321348
 14625 0a78 02010000 		.word	258
 14626 0a7c 0000C0C0 		.word	-1061158912
 14629              	CyFxGpifTransition_usb2:
 14630 0a80 0000     		.short	0
 14631 0a82 5555     		.short	21845
 14632 0a84 AAAA     		.short	-21846
 14633 0a86 8888     		.short	-30584
 14634 0a88 1111     		.short	4369
 14635 0a8a 4444     		.short	17476
 14636 0a8c 3333     		.short	13107
 14637 0a8e CCCC     		.short	-13108
 14640              	CyFxGpifRegValue:
 14641 0a90 08830080 		.word	-2147450104
 14642 0a94 67000000 		.word	103
 14643 0a98 00000000 		.word	0
 14644 0a9c 46000000 		.word	70
 14645 0aa0 00000000 		.word	0
 14646 0aa4 00000000 		.word	0
 14647 0aa8 02000000 		.word	2
 14648 0aac 82000000 		.word	130
 14649 0ab0 82070000 		.word	1922
 14650 0ab4 40040000 		.word	1088
 14651 0ab8 FCFF0000 		.word	65532
 14652 0abc 28000000 		.word	40
 14653 0ac0 00000000 		.word	0
 14654 0ac4 00000000 		.word	0
 14655 0ac8 00000000 		.word	0
 14656 0acc 00000000 		.word	0
 14657 0ad0 01000000 		.word	1
 14658 0ad4 00000000 		.word	0
 14659 0ad8 00000000 		.word	0
 14660 0adc 00000000 		.word	0
 14661 0ae0 00000000 		.word	0
 14662 0ae4 00000000 		.word	0
 14663 0ae8 00000000 		.word	0
 14664 0aec 00000000 		.word	0
 14665 0af0 00000000 		.word	0
 14666 0af4 00000000 		.word	0
 14667 0af8 00000000 		.word	0
 14668 0afc 00000000 		.word	0
 14669 0b00 00000000 		.word	0
 14670 0b04 06000000 		.word	6
 14671 0b08 00000000 		.word	0
 14672 0b0c FFFF0000 		.word	65535
 14673 0b10 09010000 		.word	265
 14674 0b14 00000000 		.word	0
 14675 0b18 F71F0000 		.word	8183
 14676 0b1c 00000000 		.word	0
 14677 0b20 FFFF0000 		.word	65535
 14678 0b24 09010000 		.word	265
 14679 0b28 00000000 		.word	0
 14680 0b2c F71F0000 		.word	8183
 14681 0b30 00000000 		.word	0
 14682 0b34 00000000 		.word	0
 14683 0b38 00000000 		.word	0
 14684 0b3c 00000000 		.word	0
 14685 0b40 00000000 		.word	0
 14686 0b44 00000000 		.word	0
 14687 0b48 00000000 		.word	0
 14688 0b4c 00000000 		.word	0
 14689 0b50 00000000 		.word	0
 14690 0b54 00000000 		.word	0
 14691 0b58 00000000 		.word	0
 14692 0b5c 00000000 		.word	0
 14693 0b60 00000000 		.word	0
 14694 0b64 00000000 		.word	0
 14695 0b68 00000000 		.word	0
 14696 0b6c 00000000 		.word	0
 14697 0b70 00000000 		.word	0
 14698 0b74 00000000 		.word	0
 14699 0b78 00000000 		.word	0
 14700 0b7c 00000000 		.word	0
 14701 0b80 00000000 		.word	0
 14702 0b84 00000000 		.word	0
 14703 0b88 00000000 		.word	0
 14704 0b8c 00040180 		.word	-2147417088
 14705 0b90 01040180 		.word	-2147417087
 14706 0b94 02040180 		.word	-2147417086
 14707 0b98 03040180 		.word	-2147417085
 14708 0b9c 00000000 		.word	0
 14709 0ba0 00000000 		.word	0
 14710 0ba4 00000000 		.word	0
 14711 0ba8 00000000 		.word	0
 14712 0bac 00000000 		.word	0
 14713 0bb0 00000000 		.word	0
 14714 0bb4 00000000 		.word	0
 14715 0bb8 00000000 		.word	0
 14716 0bbc C1FFFFFF 		.word	-63
 14719              	CyFxGpifWavedataPosition:
 14720 0bc0 00       		.byte	0
 14721 0bc1 01       		.byte	1
 14722 0bc2 02       		.byte	2
 14723 0bc3 03       		.byte	3
 14724 0bc4 04       		.byte	4
 14725 0bc5 05       		.byte	5
 14726 0bc6 06       		.byte	6
 14727 0bc7 07       		.byte	7
 14728 0bc8 08       		.byte	8
 14729 0bc9 09       		.byte	9
 14730 0bca 0A       		.byte	10
 14731 0bcb 0B       		.byte	11
 14732 0bcc 0B       		.byte	11
 14733 0bcd 0B       		.byte	11
 14734 0bce 0B       		.byte	11
 14735 0bcf 00       		.space	1
 14738              	CyFxGpifWavedata:
 14739 0bd0 0181731E 		.word	510886145
 14740 0bd4 00000000 		.word	0
 14741 0bd8 00000080 		.word	-2147483648
 14742 0bdc 00000000 		.word	0
 14743 0be0 00000000 		.word	0
 14744 0be4 00000000 		.word	0
 14745 0be8 0201702E 		.word	779092226
 14746 0bec 00010000 		.word	256
 14747 0bf0 A0000080 		.word	-2147483488
 14748 0bf4 00000000 		.word	0
 14749 0bf8 00000000 		.word	0
 14750 0bfc 00000000 		.word	0
 14751 0c00 0380722E 		.word	779255811
 14752 0c04 02010020 		.word	536871170
 14753 0c08 60000080 		.word	-2147483552
 14754 0c0c 00000000 		.word	0
 14755 0c10 00000000 		.word	0
 14756 0c14 00000000 		.word	0
 14757 0c18 0460722E 		.word	779247620
 14758 0c1c 02010024 		.word	603980034
 14759 0c20 90000080 		.word	-2147483504
 14760 0c24 0594731E 		.word	510891013
 14761 0c28 06000000 		.word	6
 14762 0c2c 00000080 		.word	-2147483648
 14763 0c30 0380722E 		.word	779255811
 14764 0c34 02010020 		.word	536871170
 14765 0c38 60000080 		.word	-2147483552
 14766 0c3c 0693731E 		.word	510890758
 14767 0c40 06000000 		.word	6
 14768 0c44 00000080 		.word	-2147483648
 14769 0c48 0720703E 		.word	1047535623
 14770 0c4c 08010000 		.word	264
 14771 0c50 00000080 		.word	-2147483648
 14772 0c54 0820703E 		.word	1047535624
 14773 0c58 08010000 		.word	264
 14774 0c5c 00000080 		.word	-2147483648
 14775 0c60 0920703E 		.word	1047535625
 14776 0c64 08010000 		.word	264
 14777 0c68 00000080 		.word	-2147483648
 14778 0c6c 0A20703E 		.word	1047535626
 14779 0c70 08010000 		.word	264
 14780 0c74 00000080 		.word	-2147483648
 14781 0c78 0380722E 		.word	779255811
 14782 0c7c 02010020 		.word	536871170
 14783 0c80 60000080 		.word	-2147483552
 14784 0c84 0B000000 		.word	11
 14785 0c88 00000000 		.word	0
 14786 0c8c 00010080 		.word	-2147483392
 14787 0c90 0460722E 		.word	779247620
 14788 0c94 02010024 		.word	603980034
 14789 0c98 90000080 		.word	-2147483504
 14790 0c9c 0D000000 		.word	13
 14791 0ca0 00000000 		.word	0
 14792 0ca4 00010080 		.word	-2147483392
 14793 0ca8 0460722E 		.word	779247620
 14794 0cac 02010024 		.word	603980034
 14795 0cb0 90000080 		.word	-2147483504
 14796 0cb4 0C000000 		.word	12
 14797 0cb8 00000000 		.word	0
 14798 0cbc 00010080 		.word	-2147483392
 14799 0cc0 0380722E 		.word	779255811
 14800 0cc4 02010020 		.word	536871170
 14801 0cc8 60000080 		.word	-2147483552
 14802 0ccc 0E000000 		.word	14
 14803 0cd0 00000000 		.word	0
 14804 0cd4 00010080 		.word	-2147483392
 14805 0cd8 00000000 		.word	0
 14806 0cdc 00000000 		.word	0
 14807 0ce0 00000000 		.word	0
 14808 0ce4 00000000 		.word	0
 14809 0ce8 00000000 		.word	0
 14810 0cec 00000000 		.word	0
 14813              	CyFxGpifTransition:
 14814 0cf0 0000     		.short	0
 14815 0cf2 5555     		.short	21845
 14816 0cf4 8888     		.short	-30584
 14817 0cf6 AAAA     		.short	-21846
 14818 0cf8 3333     		.short	13107
 14819 0cfa 0000     		.section	.rodata.str1.4,"aMS",%progbits,1
 14820              		.align	2
 14821              	.LC0:
 14822 0000 49324320 		.ascii	"I2C pos-timer %d %d\015\012\000"
 14822      706F732D 
 14822      74696D65 
 14822      72202564 
 14822      2025640D 
 14823 0016 0000     		.space	2
 14824              	.LC1:
 14825 0018 76696465 		.ascii	"video stream GET request Code: %d, \012\000"
 14825      6F207374 
 14825      7265616D 
 14825      20474554 
 14825      20726571 
 14826 003d 000000   		.space	3
 14827              	.LC2:
 14828 0040 53657420 		.ascii	"Set the video mode format %x %d\012\000"
 14828      74686520 
 14828      76696465 
 14828      6F206D6F 
 14828      64652066 
 14829 0061 000000   		.space	3
 14830              	.LC3:
 14831 0064 53657420 		.ascii	"Set the video mode format setRes %d\012\000"
 14831      74686520 
 14831      76696465 
 14831      6F206D6F 
 14831      64652066 
 14832 0089 000000   		.space	3
 14833              	.LC4:
 14834 008c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 14834      43595F46 
 14834      585F5556 
 14834      435F5354 
 14834      5245414D 
 14835 00b2 0000     		.space	2
 14836              	.LC5:
 14837 00b4 47657420 		.ascii	"Get UVC still Prob(set) control %d %d %d\015\012\000"
 14837      55564320 
 14837      7374696C 
 14837      6C205072 
 14837      6F622873 
 14838 00df 00       		.space	1
 14839              	.LC6:
 14840 00e0 53657420 		.ascii	"Set the still mode format %x %d\012\000"
 14840      74686520 
 14840      7374696C 
 14840      6C206D6F 
 14840      64652066 
 14841 0101 000000   		.space	3
 14842              	.LC7:
 14843 0104 55564320 		.ascii	"UVC still commit control set %d %d %d\015\012\000"
 14843      7374696C 
 14843      6C20636F 
 14843      6D6D6974 
 14843      20636F6E 
 14844              	.LC8:
 14845 012c 53657420 		.ascii	"Set CY_FX_UVC_STIL_EVENT failed %x\012\000"
 14845      43595F46 
 14845      585F5556 
 14845      435F5354 
 14845      494C5F45 
 14846              	.LC9:
 14847 0150 47657420 		.ascii	"Get UVC still trigger control %d %d %d\015\012\000"
 14847      55564320 
 14847      7374696C 
 14847      6C207472 
 14847      69676765 
 14848 0179 000000   		.space	3
 14849              	.LC10:
 14850 017c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 14850      7374696C 
 14850      6C207472 
 14850      69676765 
 14850      7220636F 
 14851 01a3 00       		.space	1
 14852              	.LC11:
 14853 01a4 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 14853      7065722D 
 14853      74696D65 
 14853      72202564 
 14853      0D0A00
 14854 01b7 00       		.space	1
 14855              	.LC12:
 14856 01b8 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 14856      636F6D6D 
 14856      616E6420 
 14856      71756575 
 14856      65206973 
 14857 01db 00       		.space	1
 14858              	.LC13:
 14859 01dc 4572726F 		.ascii	"Error in multichannelcommitbuffer(1): Code = %d, si"
 14859      7220696E 
 14859      206D756C 
 14859      74696368 
 14859      616E6E65 
 14860 020f 7A65203D 		.ascii	"ze = %x, dmaDone %d %d\015\012\000"
 14860      2025782C 
 14860      20646D61 
 14860      446F6E65 
 14860      20256420 
 14861              	.LC14:
 14862 0228 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 14862      5420656E 
 14862      636F756E 
 14862      74657265 
 14862      642E2E2E 
 14863              	.LC15:
 14864 0248 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 14864      454E4420 
 14864      656E636F 
 14864      756E7465 
 14864      7265642E 
 14865 026a 0000     		.space	2
 14866              	.LC16:
 14867 026c 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 14867      64697363 
 14867      6F6E6E65 
 14867      63746564 
 14867      2E2E2E30 
 14868 028b 00       		.space	1
 14869              	.LC17:
 14870 028c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 14870      43595F46 
 14870      585F5556 
 14870      435F5649 
 14870      44454F5F 
 14871 02bf 0A00     		.ascii	"\012\000"
 14872 02c1 000000   		.space	3
 14873              	.LC18:
 14874 02c4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 14874      43595F46 
 14874      585F5556 
 14874      435F5649 
 14874      44454F5F 
 14875 02f7 00       		.ascii	"\000"
 14876              	.LC19:
 14877 02f8 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 14877      726E6174 
 14877      65207365 
 14877      7474696E 
 14877      6720302E 
 14878              	.LC20:
 14879 0310 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 14879      72206665 
 14879      61747572 
 14879      65207265 
 14879      71756573 
 14880 0333 00       		.space	1
 14881              	.LC21:
 14882 0334 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 14882      49324320 
 14882      636F6D6D 
 14882      616E6420 
 14882      69732030 
 14883 0367 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14883      78257820 
 14883      30782578 
 14883      20307825 
 14883      78203078 
 14884              	.LC22:
 14885 0380 54686520 		.ascii	"The I2C command setting value %x %x\015\012\000"
 14885      49324320 
 14885      636F6D6D 
 14885      616E6420 
 14885      73657474 
 14886 03a6 0000     		.space	2
 14887              	.LC23:
 14888 03a8 54686520 		.ascii	"The shutter set value %d 0x%x 0x%x 0x%x\015\012\000"
 14888      73687574 
 14888      74657220 
 14888      73657420 
 14888      76616C75 
 14889 03d2 0000     		.space	2
 14890              	.LC24:
 14891 03d4 74657374 		.ascii	"test shutter speed. 0x%x 0x%x 0x%x\015\012\000"
 14891      20736875 
 14891      74746572 
 14891      20737065 
 14891      65642E20 
 14892 03f9 000000   		.space	3
 14893              	.LC25:
 14894 03fc 74657374 		.ascii	"test shutter speed2. 0x%x 0x%x 0x%x\015\012\000"
 14894      20736875 
 14894      74746572 
 14894      20737065 
 14894      6564322E 
 14895 0422 0000     		.space	2
 14896              	.LC26:
 14897 0424 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 14897      206C6967 
 14897      68742063 
 14897      6F6D7065 
 14897      6E736174 
 14898 0457 25640D0A 		.ascii	"%d\015\012\000"
 14898      00
 14899              	.LC27:
 14900 045c 54686520 		.ascii	"The I2C current data is not available. try again. %"
 14900      49324320 
 14900      63757272 
 14900      656E7420 
 14900      64617461 
 14901 048f 64202564 		.ascii	"d %d\015\012\000"
 14901      0D0A00
 14902 0496 0000     		.space	2
 14903              	.LC28:
 14904 0498 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 14904      26414743 
 14904      2073656E 
 14904      7420746F 
 14904      20686F73 
 14905 04be 0000     		.space	2
 14906              	.LC29:
 14907 04c0 54686520 		.ascii	"The shutter&exposure 0x%x 0x%x 0x%x 0x%x\015\012\000"
 14907      73687574 
 14907      74657226 
 14907      6578706F 
 14907      73757265 
 14908 04eb 00       		.space	1
 14909              	.LC30:
 14910 04ec 4578704D 		.ascii	"ExpM&AGC gotten from host. 0x%x %d; 0x%x 0x%x %d\015"
 14910      26414743 
 14910      20676F74 
 14910      74656E20 
 14910      66726F6D 
 14911 051d 0A00     		.ascii	"\012\000"
 14912 051f 00       		.space	1
 14913              	.LC31:
 14914 0520 53687574 		.ascii	"Shutter level gotten from host. 0x%x %d; 0x%x 0x%x "
 14914      74657220 
 14914      6C657665 
 14914      6C20676F 
 14914      7474656E 
 14915 0553 25640D0A 		.ascii	"%d\015\012\000"
 14915      00
 14916              	.LC32:
 14917 0558 46726571 		.ascii	"Frequency setting is  %d %d\015\012\000"
 14917      75656E63 
 14917      79207365 
 14917      7474696E 
 14917      67206973 
 14918 0576 0000     		.space	2
 14919              	.LC33:
 14920 0578 46536574 		.ascii	"FSet the video mode format %x %d\012\000"
 14920      20746865 
 14920      20766964 
 14920      656F206D 
 14920      6F646520 
 14921 059a 0000     		.space	2
 14922              	.LC34:
 14923 059c 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 14923      67657420 
 14923      64617461 
 14923      2066726F 
 14923      6D20686F 
 14924 05c9 000000   		.space	3
 14925              	.LC35:
 14926 05cc 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 14926      52657175 
 14926      65737420 
 14926      30782578 
 14926      20706172 
 14927 05ff 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 14927      6E642074 
 14927      6F20686F 
 14927      73742030 
 14927      78257820 
 14928 061a 0000     		.space	2
 14929              	.LC36:
 14930 061c 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 14930      204F7020 
 14930      72656365 
 14930      69766573 
 14930      20284354 
 14931 0643 00       		.space	1
 14932              	.LC37:
 14933 0644 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 14933      756C7420 
 14933      73656C65 
 14933      63746F72 
 14933      20284354 
 14934 0666 0000     		.space	2
 14935              	.LC38:
 14936 0668 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 14936      756C7420 
 14936      72657175 
 14936      65737420 
 14936      28435429 
 14937 0689 000000   		.space	3
 14938              	.LC39:
 14939 068c 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 14939      52657175 
 14939      65737420 
 14939      30782578 
 14939      20706172 
 14940 06bf 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 14940      20307825 
 14940      78202F20 
 14940      73656E64 
 14940      20746F20 
 14941 06ec 00       		.ascii	"\000"
 14942 06ed 000000   		.space	3
 14943              	.LC40:
 14944 06f0 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 14944      73657420 
 14944      64656620 
 14944      64617461 
 14944      20307825 
 14945 070f 00       		.space	1
 14946              	.LC41:
 14947 0710 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 14947      73657420 
 14947      64656620 
 14947      64617461 
 14947      20307825 
 14948 0743 2E0D0A00 		.ascii	".\015\012\000"
 14949 0747 00       		.space	1
 14950              	.LC42:
 14951 0748 4572726F 		.ascii	"Error handler...\015\012\000"
 14951      72206861 
 14951      6E646C65 
 14951      722E2E2E 
 14951      0D0A00
 14952 075b 00       		.space	1
 14953              	.LC43:
 14954 075c 55415254 		.ascii	"UART initialization failed!\012\000"
 14954      20696E69 
 14954      7469616C 
 14954      697A6174 
 14954      696F6E20 
 14955 0779 000000   		.space	3
 14956              	.LC44:
 14957 077c 49324320 		.ascii	"I2C initialization failed!\012\000"
 14957      696E6974 
 14957      69616C69 
 14957      7A617469 
 14957      6F6E2066 
 14958              	.LC45:
 14959 0798 49324320 		.ascii	"I2C configuration failed!\012\000"
 14959      636F6E66 
 14959      69677572 
 14959      6174696F 
 14959      6E206661 
 14960 07b3 00       		.space	1
 14961              	.LC46:
 14962 07b4 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 14962      43726561 
 14962      74652045 
 14962      76656E74 
 14962      20666169 
 14963 07de 0000     		.space	2
 14964              	.LC47:
 14965 07e0 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 14965      20496E69 
 14965      74206661 
 14965      696C6564 
 14965      2C204572 
 14966 0803 00       		.space	1
 14967              	.LC48:
 14968 0804 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 14968      204F7665 
 14968      72726964 
 14968      65206661 
 14968      696C6564 
 14969 082b 00       		.space	1
 14970              	.LC49:
 14971 082c 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 14971      28323029 
 14971      204F7665 
 14971      72726964 
 14971      65206661 
 14972 0857 00       		.space	1
 14973              	.LC50:
 14974 0858 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 14974      28323429 
 14974      204F7665 
 14974      72726964 
 14974      65206661 
 14975 0883 00       		.space	1
 14976              	.LC51:
 14977 0884 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 14977      20536574 
 14977      20287265 
 14977      73657420 
 14977      32322920 
 14978 08b6 00       		.ascii	"\000"
 14979 08b7 00       		.space	1
 14980              	.LC52:
 14981 08b8 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 14981      20536574 
 14981      2028706F 
 14981      77657220 
 14981      32302920 
 14982 08ea 00       		.ascii	"\000"
 14983 08eb 00       		.space	1
 14984              	.LC53:
 14985 08ec 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 14985      20536574 
 14985      2028736E 
 14985      61702073 
 14985      686F7420 
 14986 091f 25640A00 		.ascii	"%d\012\000"
 14987 0923 00       		.space	1
 14988              	.LC54:
 14989 0924 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 14989      46756E63 
 14989      74696F6E 
 14989      20466169 
 14989      6C656420 
 14990 0953 00       		.space	1
 14991              	.LC55:
 14992 0954 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 14992      46756E63 
 14992      74696F6E 
 14992      20466169 
 14992      6C656420 
 14993 0983 00       		.space	1
 14994              	.LC56:
 14995 0984 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 14995      53657420 
 14995      456E6470 
 14995      6F696E74 
 14995      20636F6E 
 14996 09b4 00       		.ascii	"\000"
 14997 09b5 000000   		.space	3
 14998              	.LC57:
 14999 09b8 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 14999      496E7465 
 14999      72727570 
 14999      74205374 
 14999      61747573 
 15000 09eb 20436F64 		.ascii	" Code = %d\012\000"
 15000      65203D20 
 15000      25640A00 
 15001 09f7 00       		.space	1
 15002              	.LC58:
 15003 09f8 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 15003      65642074 
 15003      6F20616C 
 15003      6C6F6361 
 15003      7465206D 
 15004 0a2b 65720D0A 		.ascii	"er\015\012\000"
 15004      00
 15005              	.LC59:
 15006 0a30 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 15006      4368616E 
 15006      6E656C20 
 15006      43726561 
 15006      74696F6E 
 15007 0a5e 0000     		.space	2
 15008              	.LC60:
 15009 0a60 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 15009      436F6E6E 
 15009      65637420 
 15009      6661696C 
 15009      65642C20 
 15010 0a85 000000   		.space	3
 15011              	.LC61:
 15012 0a88 53657420 		.ascii	"Set the video mode format1 %x %d\012\000"
 15012      74686520 
 15012      76696465 
 15012      6F206D6F 
 15012      64652066 
 15013 0aaa 0000     		.space	2
 15014              	.LC62:
 15015 0aac 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 15015      4368616E 
 15015      6E656C20 
 15015      52657365 
 15015      74204661 
 15016 0ad7 00       		.space	1
 15017              	.LC63:
 15018 0ad8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 15018      4368616E 
 15018      6E656C20 
 15018      53657420 
 15018      5472616E 
 15019 0b09 00       		.ascii	"\000"
 15020 0b0a 0000     		.space	2
 15021              	.LC64:
 15022 0b0c 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 15022      4368616E 
 15022      6E656C20 
 15022      53657420 
 15022      5472616E 
 15023 0b3d 0A00     		.ascii	"\012\000"
 15024 0b3f 00       		.space	1
 15025              	.LC65:
 15026 0b40 0D0A2073 		.ascii	"\015\012 super gpif\000"
 15026      75706572 
 15026      20677069 
 15026      6600
 15027 0b4e 0000     		.space	2
 15028              	.LC66:
 15029 0b50 0D0A2068 		.ascii	"\015\012 high gpif\000"
 15029      69676820 
 15029      67706966 
 15029      00
 15030 0b5d 000000   		.space	3
 15031              	.LC67:
 15032 0b60 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 15032      696E6720 
 15032      47504946 
 15032      20436F6E 
 15032      66696775 
 15033 0b93 0A00     		.ascii	"\012\000"
 15034 0b95 000000   		.space	3
 15035              	.LC68:
 15036 0b98 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 15036      74696E67 
 15036      20475049 
 15036      46207374 
 15036      61746520 
 15037 0bcb 0D0A00   		.ascii	"\015\012\000"
 15038 0bce 0000     		.space	2
 15039              	.LC69:
 15040 0bd0 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 15040      73706565 
 15040      64203D20 
 15040      25642065 
 15040      76656E66 
 15041 0c00 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 15041      71756573 
 15041      74203D20 
 15041      30782578 
 15041      20775661 
 15042 0c30 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 15042      203D2030 
 15042      78257820 
 15042      6973666C 
 15042      61672030 
 15043 0c4a 0000     		.space	2
 15044              	.LC70:
 15045 0c4c 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 15045      64656661 
 15045      756C7420 
 15045      73657475 
 15045      70207265 
 15046              	.LC71:
 15047 0c78 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 15047      65642074 
 15047      6F207365 
 15047      6E642069 
 15047      6E746572 
 15048 0ca9 0A00     		.ascii	"\012\000"
 15049 0cab 00       		.space	1
 15050              	.LC72:
 15051 0cac 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 15051      6F6D6D69 
 15051      74656F66 
 15051      20737461 
 15051      7465203D 
 15052              	.LC73:
 15053 0cc4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 15053      6E656C20 
 15053      53657420 
 15053      57726170 
 15053      55702066 
 15054 0cf1 000000   		.space	3
 15055              	.LC74:
 15056 0cf4 436F6D6D 		.ascii	"Commit EOF failed!\015\012\000"
 15056      69742045 
 15056      4F462066 
 15056      61696C65 
 15056      64210D0A 
 15057 0d09 000000   		.space	3
 15058              	.LC75:
 15059 0d0c 49324363 		.ascii	"I2CcmdQue\000"
 15059      6D645175 
 15059      6500
 15060 0d16 0000     		.space	2
 15061              	.LC76:
 15062 0d18 33303A55 		.ascii	"30:UVC App Thread\000"
 15062      56432041 
 15062      70702054 
 15062      68726561 
 15062      6400
 15063 0d2a 0000     		.space	2
 15064              	.LC77:
 15065 0d2c 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 15065      56432041 
 15065      70702045 
 15065      50302054 
 15065      68726561 
 15066 0d42 0000     		.space	2
 15067              	.LC78:
 15068 0d44 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 15068      32432041 
 15068      70702043 
 15068      54524C20 
 15068      54687265 
 15069 0d5b 00       		.bss
 15070              		.align	2
 15071              		.set	.LANCHOR0,. + 0
 15074              	glFxUVCEvent:
 15075 0000 00000000 		.space	40
 15075      00000000 
 15075      00000000 
 15075      00000000 
 15075      00000000 
 15078              	glEp0Buffer:
 15079 0028 00000000 		.space	32
 15079      00000000 
 15079      00000000 
 15079      00000000 
 15079      00000000 
 15082              	usbSpeed:
 15083 0048 00       		.space	1
 15084 0049 000000   		.space	3
 15087              	glCommitCtrl:
 15088 004c 00000000 		.space	32
 15088      00000000 
 15088      00000000 
 15088      00000000 
 15088      00000000 
 15091              	is60Hz:
 15092 006c 00000000 		.space	4
 15095              	setRes:
 15096 0070 00       		.space	1
 15099              	setstilRes:
 15100 0071 00       		.space	1
 15103              	stiflag:
 15104 0072 00       		.space	1
 15105 0073 00       		.space	1
 15108              	fb:
 15109 0074 0000     		.space	2
 15112              	pb:
 15113 0076 0000     		.space	2
 15116              	pbc:
 15117 0078 0000     		.space	2
 15118 007a 0000     		.space	2
 15121              	hitFV:
 15122 007c 00000000 		.space	4
 15125              	prodCount:
 15126 0080 0000     		.space	2
 15129              	consCount:
 15130 0082 0000     		.space	2
 15133              	streamingStarted:
 15134 0084 00000000 		.space	4
 15137              	gpif_initialized:
 15138 0088 00000000 		.space	4
 15141              	isUsbConnected:
 15142 008c 00000000 		.space	4
 15145              	clearFeatureRqtReceived:
 15146 0090 00000000 		.space	4
 15149              	I2CCMDArry:
 15150 0094 00000000 		.space	12
 15150      00000000 
 15150      00000000 
 15153              	curFlag:
 15154 00a0 00000000 		.space	64
 15154      00000000 
 15154      00000000 
 15154      00000000 
 15154      00000000 
 15157              	CamMode:
 15158 00e0 00       		.space	1
 15161              	IMcount.8190:
 15162 00e1 00       		.space	1
 15163 00e2 0000     		.space	2
 15166              	uvcAppThread:
 15167 00e4 00000000 		.space	168
 15167      00000000 
 15167      00000000 
 15167      00000000 
 15167      00000000 
 15170              	uvcAppEP0Thread:
 15171 018c 00000000 		.space	168
 15171      00000000 
 15171      00000000 
 15171      00000000 
 15171      00000000 
 15174              	i2cAppThread:
 15175 0234 00000000 		.space	168
 15175      00000000 
 15175      00000000 
 15175      00000000 
 15175      00000000 
 15178              	pbcpbak:
 15179 02dc 0000     		.space	2
 15182              	pbcbak:
 15183 02de 0000     		.space	2
 15186              	pbbak:
 15187 02e0 0000     		.space	2
 15190              	fbbak:
 15191 02e2 0000     		.space	2
 15194              	testSnap:
 15195 02e4 00       		.space	1
 15196 02e5 000000   		.text
 15197              	.Letext0:
 15198              		.file 2 "c:\\program files (x86)\\cypress\\ez-usb fx3 sdk\\1.3\\arm gcc\\arm-none-eabi\\include\\s
 15199              		.file 3 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15200              		.file 4 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyfx
 15201              		.file 5 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_p
 15202              		.file 6 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/tx_a
 15203              		.file 7 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15204              		.file 8 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15205              		.file 9 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu3
 15206              		.file 10 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15207              		.file 11 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15208              		.file 12 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15209              		.file 13 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15210              		.file 14 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15211              		.file 15 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15212              		.file 16 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15213              		.file 17 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
 15214              		.file 18 "../sensor.h"
 15215              		.file 19 "../cmdqu.h"
 15216              		.file 20 "../uvc.h"
 15217              		.file 21 "../cyfxgpif2config.h"
 15218              		.file 22 "../cyfxgpif2config_usb2_720.h"
 15219              		.file 23 "C:\\Program Files (x86)\\Cypress\\EZ-USB FX3 SDK\\1.3\\\\firmware\\u3p_firmware\\inc/cyu
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:16     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:19     .text:00000000 I2CCmdCb
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:57     .text:00000030 $d
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:63     .text:0000003c $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:65     .text:0000003c UVCHandleVideoStreamingRqts
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:211    .text:00000190 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:218    .text:000001a0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:404    .text:00000374 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:411    .text:00000384 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:742    .text:000006ec $d
                            *COM*:00000002 wValue
                            *COM*:00000001 bRequest
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:763    .text:00000734 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:766    .text:00000734 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:935    .text:00000894 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:941    .text:000008a4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1054   .text:00000974 $d
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1065   .text:00000994 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1068   .text:00000994 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1303   .text:00000b24 $d
                            *COM*:00000038 imgHdMux
                            *COM*:000000e8 glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1313   .text:00000b40 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1315   .text:00000b40 CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1530   .text:00000cbc $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1541   .text:00000ccc $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1543   .text:00000ccc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1901   .text:00000f88 $d
                            *COM*:00000002 wLength
                            *COM*:00000002 wIndex
                            *COM*:00000001 bmReqType
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1919   .text:00000fb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:1922   .text:00000fb4 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2150   .text:000011b8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2158   .text:000011cc $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2161   .text:000011cc setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2229   .text:00001248 getShutCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2254   .text:00001264 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2267   .text:0000128c $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2368   .text:00001364 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2376   .text:00001378 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2379   .text:00001378 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2572   .text:000014ec $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2614   .text:00001588 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2667   .text:00001600 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:2708   .text:0000169c $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:4114   .text:0000230c $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:4137   .text:0000235c $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:4508   .text:000026a0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:4514   .text:000026b0 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5073   .text:00002b64 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5220   .text:00002c8c $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5233   .text:00002cb4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5649   .text:000030e4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5660   .text:00003104 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5930   .text:00003398 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5942   .text:000033bc $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:5945   .text:000033bc CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6246   .text:00003678 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6253   .text:00003688 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6256   .text:00003688 CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6300   .text:000036cc $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6305   .text:000036d4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6308   .text:000036d4 CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6336   .text:000036f0 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6340   .text:000036f4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:6343   .text:000036f4 UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7128   .text:00003d70 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7134   .text:00003d80 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7609   .text:00004168 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12217  .text:00006468 CyFxGpifCB
                            *COM*:000000ac glChHandleInterStat
                            *COM*:00000004 glInterStaBuffer
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7668   .text:00004240 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7671   .text:00004240 UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7734   .text:000042b4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:7742   .text:000042c4 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:9487   .text:000051a4 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:9515   .text:000051f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:9650   .text:00005328 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:9665   .text:00005348 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12204  .text:0000645c $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12214  .text:00006468 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12249  .text:0000649c $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12262  .text:000064c8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12267  .text:000064d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12272  .text:000064e8 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12320  .text:00006540 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12330  .text:00006554 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12333  .text:00006554 CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12486  .text:0000669c $d
                            *COM*:00000038 cmdQuMux
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12503  .text.startup:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12506  .text.startup:00000000 main
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13784  .data:000004ec glUVCHeader
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12803  .data:00000060 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12724  .data:0000001c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12788  .data:00000054 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12694  .data:00000000 glProbeCtrlFull
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12754  .data:00000038 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15133  .bss:00000084 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15145  .bss:00000090 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15082  .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15141  .bss:0000008c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15178  .bss:000002dc pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15182  .bss:000002de pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15186  .bss:000002e0 pbbak
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15190  .bss:000002e2 fbbak
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15116  .bss:00000078 pbc
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15112  .bss:00000076 pb
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15108  .bss:00000074 fb
                            *COM*:00000038 timMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15194  .bss:000002e4 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14283  .data:00000708 snapButFlag
                            *COM*:000000e8 glChHandleStillStream
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12678  .rodata:0000003c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14288  .data:0000070c CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14367  .data:0000083c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14518  .data:000008d0 CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14629  .data:00000a80 CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12665  .rodata:00000020 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14640  .data:00000a90 CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14719  .data:00000bc0 CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14738  .data:00000bd0 CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14813  .data:00000cf0 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12646  .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12650  .rodata:00000000 ShutSp
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12690  .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12783  .data:00000052 ROIMode
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:12818  .data:0000006c ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13141  .data:000001ec CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13799  .data:000004f8 EXTBLCWinPos
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13821  .data:0000050c EXTBLCWeight
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13843  .data:00000520 EXTShutter
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13865  .data:00000534 EXTShutlev
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13887  .data:00000548 EXTAexModGainlev
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13909  .data:0000055c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13916  .data:00000560 PUCBLC
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13938  .data:00000574 PUCSharp
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:13960  .data:00000588 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:14820  .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15070  .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15074  .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15078  .bss:00000028 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15087  .bss:0000004c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15091  .bss:0000006c is60Hz
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15095  .bss:00000070 setRes
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15099  .bss:00000071 setstilRes
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15103  .bss:00000072 stiflag
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15121  .bss:0000007c hitFV
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15125  .bss:00000080 prodCount
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15129  .bss:00000082 consCount
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15137  .bss:00000088 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15149  .bss:00000094 I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15153  .bss:000000a0 curFlag
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15157  .bss:000000e0 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15161  .bss:000000e1 IMcount.8190
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15166  .bss:000000e4 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15170  .bss:0000018c uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccFZh87y.s:15174  .bss:00000234 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CyU3PDebugPrint
_txe_event_flags_set
CyU3PUsbSendEP0Data
CyU3PUsbStall
CyU3PUsbGetEP0Data
SensorSetIrisControl
_tx_thread_sleep
_txe_timer_create
_tx_time_get
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
_txe_timer_change
SensorSetControl
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyFx3BusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbAckSetup
SensorWrite2B
SensorRead2B
SensorWrite2B2
cmdSet
memcpy
SensorGetControl
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
_txe_mutex_create
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PUsbGetSpeed
CyU3PDmaMultiChannelSetXfer
CyU3PGpifSMSwitch
CyU3PGpifLoad
CyU3PGpifSMStart
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PDmaMultiChannelSetWrapUp
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
